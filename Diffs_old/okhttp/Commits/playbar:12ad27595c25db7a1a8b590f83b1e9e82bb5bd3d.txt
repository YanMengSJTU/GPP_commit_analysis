diff --git a/CONTRIBUTING.md b/.github/CONTRIBUTING.md
similarity index 100%
rename from CONTRIBUTING.md
rename to .github/CONTRIBUTING.md
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
new file mode 100644
index 0000000000..e65d371715
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE.md
@@ -0,0 +1,12 @@
+What kind of issue is this?
+
+ - [ ] Question. This issue tracker is not the place for questions. If you want to ask how to do
+       something, or to understand why something isn't working the way you expect it to, use Stack
+       Overflow. https://stackoverflow.com/questions/tagged/okhttp
+
+ - [ ] Bug report. If you’ve found a bug, spend the time to write a failing test. Bugs with tests
+       get fixed. Here’s an example: https://gist.github.com/swankjesse/981fcae102f513eb13ed
+
+ - [ ] Feature Request. Start by telling us what problem you’re trying to solve. Often a solution
+       already exists! Don’t send pull requests to implement new features without first getting our
+       support. Sometimes we leave features out on purpose to keep the project small.
diff --git a/.travis.yml b/.travis.yml
index ed135a7902..1835d337fb 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -24,3 +24,8 @@ sudo: false
 cache:
   directories:
     - $HOME/.m2
+
+addons:
+  apt:
+    packages:
+      - oracle-java8-installer
diff --git a/CHANGELOG.md b/CHANGELOG.md
index a9cd519e0e..960d7d2f60 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,371 @@
 Change Log
 ==========
 
+## Version 3.2.0
+
+_2016-02-25_
+
+ *  Fix: Change the certificate pinner to always build full chains. This
+    prevents a potential crash when using certificate pinning with the Google
+    Play Services security provider.
+ *  Fix: Make IPv6 request lines consistent with Firefox and Chrome.
+ *  Fix: Recover gracefully when trimming the response cache fails.
+ *  New: Add multiple path segments using a single string in `HttpUrl.Builder`.
+ *  New: Support SHA-256 pins in certificate pinner.
+
+
+## Version 3.1.2
+
+_2016-02-10_
+
+ *  Fix: Don’t crash when finding the trust manager on Robolectric. We attempted
+    to detect the host platform and got confused because Robolectric looks like
+    Android but isn’t!
+ *  Fix: Change `CertificatePinner` to skip sanitizing the certificate chain
+    when no certificates were pinned. This avoids an SSL failure in insecure
+    “trust everyone” configurations, such as when talking to a development
+    HTTPS server that has a self-signed certificate.
+
+
+## Version 3.1.1
+
+_2016-02-07_
+
+ *  Fix: Don't crash when finding the trust manager if the Play Services (GMS)
+    security provider is installed.
+ *  Fix: The previous release introduced a performance regression on Android,
+    caused by looking up CA certificates. This is now fixed.
+
+
+## Version 3.1.0
+
+_2016-02-06_
+
+ *  New: WebSockets now defer some writes. This should improve performance for
+    some applications.
+ *  New: Override `equals()` and `hashCode()` in our new cookie class. This
+    class now defines equality by value rather than by reference.
+ *  New: Handle 408 responses by retrying the request. This allows servers to
+    direct clients to retry rather than failing permanently.
+ *  New: Expose the framed protocol in `Connection`. Previously this would
+    return the application-layer protocol (HTTP/1.1 or HTTP/1.0); now it always
+    returns the wire-layer protocol (HTTP/2, SPDY/3.1, or HTTP/1.1).
+ *  Fix: Permit the trusted CA root to be pinned by `CertificatePinner`.
+ *  Fix: Silently ignore unknown HTTP/2 settings. Previously this would cause
+    the entire connection to fail.
+ *  Fix: Don’t crash on unexpected charsets in the logging interceptor.
+ *  Fix: `OkHttpClient` is now non-final for the benefit of mocking frameworks.
+    Mocking sophisticated classes like `OkHttpClient` is fragile and you
+    shouldn’t do it. But if that’s how you want to live your life we won’t stand
+    in your way!
+
+
+## Version 3.0.1
+
+_2016-01-14_
+
+ *  Rollback OSGi support. This was causing library jars to include more classes
+    than expected, which interfered with Gradle builds.
+
+
+## Version 3.0.0
+
+_2016-01-13_
+
+This release commits to a stable 3.0 API. Read the 3.0.0-RC1 changes for advice
+on upgrading from 2.x to 3.x.
+
+ *  **The `Callback` interface now takes a `Call`**. This makes it easier to
+    check if the call was canceled from within the callback. When migrating
+    async calls to this new API, `Call` is now the first parameter for both
+    `onResponse()` and `onFailure()`.
+ *  Fix: handle multiple cookies in `JavaNetCookieJar` on Android.
+ *  Fix: improve the default HTTP message in MockWebServer responses.
+ *  Fix: don't leak file handles when a conditional GET throws.
+ *  Fix: Use charset specified by the request body content type in OkHttp's
+    logging interceptor.
+ *  Fix: Don't eagerly release pools on cache hits.
+ *  New: Make OkHttp OSGi ready.
+ *  New: Add already-implemented interfaces Closeable and Flushable to the cache.
+
+## Version 3.0.0-RC1
+
+_2016-01-02_
+
+OkHttp 3 is a major release focused on API simplicity and consistency. The API
+changes are numerous but most are cosmetic. Applications should be able to
+upgrade from the 2.x API to the 3.x API mechanically and without risk.
+
+Because the release includes breaking API changes, we're changing the project's
+package name from `com.squareup.okhttp` to `okhttp3`. This should make it
+possible for large applications to migrate incrementally. The Maven group ID
+is now `com.squareup.okhttp3`. For an explanation of this strategy, see Jake
+Wharton's post, [Java Interoperability Policy for Major Version
+Updates][major_versions].
+
+This release obsoletes OkHttp 2.x, and all code that uses OkHttp's
+`com.squareup.okhttp` package should upgrade to the `okhttp3` package. Libraries
+that depend on OkHttp should upgrade quickly to prevent applications from being
+stuck on the old version.
+
+ *  **There is no longer a global singleton connection pool.** In OkHttp 2.x,
+    all `OkHttpClient` instances shared a common connection pool by default.
+    In OkHttp 3.x, each new `OkHttpClient` gets its own private connection pool.
+    Applications should avoid creating many connection pools as doing so
+    prevents connection reuse. Each connection pool holds its own set of
+    connections alive so applications that have many pools also risk exhausting
+    memory!
+
+    The best practice in OkHttp 3 is to create a single OkHttpClient instance
+    and share it throughout the application. Requests that needs a customized
+    client should call `OkHttpClient.newBuilder()` on that shared instance.
+    This allows customization without the drawbacks of separate connection
+    pools.
+
+ *  **OkHttpClient is now stateless.** In the 2.x API `OkHttpClient` had getters
+    and setters. Internally each request was forced to make its own complete
+    snapshot of the `OkHttpClient` instance to defend against racy configuration
+    changes. In 3.x, `OkHttpClient` is now stateless and has a builder. Note
+    that this class is not strictly immutable as it has stateful members like
+    the connection pool and cache.
+
+ *  **Get and Set prefixes are now avoided.** With ubiquitous builders
+    throughout OkHttp these accessor prefixes aren't necessary. Previously
+    OkHttp used _get_ and _set_ prefixes sporadically which make the API
+    inconsistent and awkward to explore.
+
+ *  **OkHttpClient now implements the new `Call.Factory` interface.** This
+    interface will make your code easier to test. When you test code that makes
+    HTTP requests, you can use this interface to replace the real `OkHttpClient`
+    with your own mocks or fakes.
+
+    The interface will also let you use OkHttp's API with another HTTP client's
+    implementation. This is useful in sandboxed environments like Google App
+    Engine.
+
+ *  **OkHttp now does cookies.** We've replaced `java.net.CookieHandler` with
+    a new interface, `CookieJar` and added our own `Cookie` model class. This
+    new cookie follows the latest RFC and supports the same cookie attributes
+    as modern web browsers.
+
+ *  **Form and Multipart bodies are now modeled.** We've replaced the opaque
+    `FormEncodingBuilder` with the more powerful `FormBody` and
+    `FormBody.Builder` combo. Similarly we've upgraded `MultipartBuilder` into
+    `MultipartBody`, `MultipartBody.Part`, and `MultipartBody.Builder`.
+
+ *  **The Apache HTTP client and HttpURLConnection APIs are deprecated.** They
+    continue to work as they always have, but we're moving everything to the new
+    OkHttp 3 API. The `okhttp-apache` and `okhttp-urlconnection` modules should
+    be only be used to accelerate a transition to OkHttp's request/response API.
+    These deprecated modules will be dropped in an upcoming OkHttp 3.x release.
+
+ *  **Canceling batches of calls is now the application's responsibility.**
+    The API to cancel calls by tag has been removed and replaced with a more
+    general mechanism. The dispatcher now exposes all in-flight calls via its
+    `runningCalls()` and `queuedCalls()` methods. You can write code that
+    selects calls by tag, host, or whatever, and invokes `Call.cancel()` on the
+    ones that are no longer necessary.
+
+ *  **OkHttp no longer uses the global `java.net.Authenticator` by default.**
+    We've changed our `Authenticator` interface to authenticate web and proxy
+    authentication failures through a single method. An adapter for the old
+    authenticator is available in the `okhttp-urlconnection` module.
+
+ *  Fix: Don't throw `IOException` on `ResponseBody.contentLength()` or `close()`.
+ *  Fix: Never throw converting an `HttpUrl` to a `java.net.URI`. This changes
+    the `uri()` method to handle malformed percent-escapes and characters
+    forbidden by `URI`.
+ *  Fix: When a connect times out, attempt an alternate route. Previously route
+    selection was less efficient when differentiating failures.
+ *  New: `Response.peekBody()` lets you access the response body without
+    consuming it. This may be handy for interceptors!
+ *  New: `HttpUrl.newBuilder()` resolves a link to a builder.
+ *  New: Add the TLS version to the `Handshake`.
+ *  New: Drop `Request.uri()` and `Request#urlString()`. Just use
+    `Request.url().uri()` and `Request.url().toString()`.
+ *  New: Add URL to HTTP response logging.
+ *  New: Make `HttpUrl` the blessed URL method of `Request`.
+
+
+## Version 2.7.5
+
+_2016-02-25_
+
+ *  Fix: Change the certificate pinner to always build full chains. This
+    prevents a potential crash when using certificate pinning with the Google
+    Play Services security provider.
+
+
+## Version 2.7.4
+
+_2016-02-07_
+
+ *  Fix: Don't crash when finding the trust manager if the Play Services (GMS)
+    security provider is installed.
+ *  Fix: The previous release introduced a performance regression on Android,
+    caused by looking up CA certificates. This is now fixed.
+
+
+## Version 2.7.3
+
+_2016-02-06_
+
+ *  Fix: Permit the trusted CA root to be pinned by `CertificatePinner`.
+
+
+## Version 2.7.2
+
+_2016-01-07_
+
+ *  Fix: Don't eagerly release stream allocations on cache hits. We might still
+    need them to handle redirects.
+
+
+## Version 2.7.1
+
+_2016-01-01_
+
+ *  Fix: Don't do a health check on newly-created connections. This is
+    unnecessary work that could put the client in an inconsistent state if the
+    health check fails.
+
+
+## Version 2.7.0
+
+_2015-12-13_
+
+ *  **Rewritten connection management.** Previously OkHttp's connection pool
+    managed both idle and active connections for HTTP/2, but only idle
+    connections for HTTP/1.x. With this update the connection pool manages both
+    idle and active connections for everything. OkHttp now detects and warns on
+    connections that were allocated but never released, and will enforce HTTP/2
+    stream limits. This update also fixes `Call.cancel()` to not do I/O on the
+    calling thread.
+ *  Fix: Don't log gzipped data in the logging interceptor.
+ *  Fix: Don't resolve DNS addresses when connecting through a SOCKS proxy.
+ *  Fix: Drop the synthetic `OkHttp-Selected-Protocol` response header.
+ *  Fix: Support 204 and 205 'No Content' replies in the logging interceptor.
+ *  New: Add `Call.isExecuted()`.
+
+
+## Version 2.6.0
+
+_2015-11-22_
+
+ *  **New Logging Interceptor.** The `logging-interceptor` subproject offers
+    simple request and response logging. It may be configured to log headers and
+    bodies for debugging. It requires this Maven dependency:
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okhttp</groupId>
+       <artifactId>logging-interceptor</artifactId>
+       <version>2.6.0</version>
+     </dependency>
+     ```
+
+    Configure basic logging like this:
+
+    ```java
+    HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor();
+    loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BASIC);
+    client.networkInterceptors().add(loggingInterceptor);
+    ```
+
+    **Warning:** Avoid `Level.HEADERS` and `Level.BODY` in production because
+    they could leak passwords and other authentication credentials to insecure
+    logs.
+
+ *  **WebSocket API now uses `RequestBody` and `ResponseBody` for messages.**
+    This is a backwards-incompatible API change.
+
+ *  **The DNS service is now pluggable.** In some situations this may be useful
+    to manually prioritize specific IP addresses.
+
+ *  Fix: Don't throw when converting an `HttpUrl` to a `java.net.URI`.
+    Previously URLs with special characters like `|` and `[` would break when
+    subjected to URI’s overly-strict validation.
+ *  Fix: Don't re-encode `+` as `%20` in encoded URL query strings. OkHttp
+    prefers `%20` when doing its own encoding, but will retain `+` when that is
+    provided.
+ *  Fix: Enforce that callers call `WebSocket.close()` on IO errors. Error
+    handling in WebSockets is significantly improved.
+ *  Fix: Don't use SPDY/3 style header concatenation for HTTP/2 request headers.
+    This could have corrupted requests where multiple headers had the same name,
+    as in cookies.
+ *  Fix: Reject bad characters in the URL hostname. Previously characters like
+    `\0` would cause a late crash when building the request.
+ *  Fix: Allow interceptors to change the request method.
+ *  Fix: Don’t use the request's `User-Agent` or `Proxy-Authorization` when
+    connecting to an HTTPS server via an HTTP tunnel. The `Proxy-Authorization`
+    header was being leaked to the origin server.
+ *  Fix: Digits may be used in a URL scheme.
+ *  Fix: Improve connection timeout recovery.
+ *  Fix: Recover from `getsockname` crashes impacting Android releases prior to
+    4.2.2.
+ *  Fix: Drop partial support for HTTP/1.0. Previously OkHttp would send
+    `HTTP/1.0` on connections after seeing a response with `HTTP/1.0`. The fixed
+    behavior is consistent with Firefox and Chrome.
+ *  Fix: Allow a body in `OPTIONS` requests.
+ *  Fix: Don't percent-encode non-ASCII characters in URL fragments.
+ *  Fix: Handle null fragments.
+ *  Fix: Don’t crash on interceptors that throw `IOException` before a
+    connection is attempted.
+ *  New: Support [WebDAV][webdav] HTTP methods.
+ *  New: Buffer WebSocket frames for better performance.
+ *  New: Drop support for `TLS_DHE_DSS_WITH_AES_128_CBC_SHA`, our only remaining
+    DSS cipher suite. This is consistent with Firefox and Chrome which have also
+    dropped these cipher suite.
+
+## Version 2.5.0
+
+_2015-08-25_
+
+ *  **Timeouts now default to 10 seconds.** Previously we defaulted to never
+    timing out, and that was a lousy policy. If establishing a connection,
+    reading the next byte from a connection, or writing the next byte to a
+    connection takes more than 10 seconds to complete, you’ll need to adjust
+    the timeouts manually.
+
+ *  **OkHttp now rejects request headers that contain invalid characters.** This
+    includes potential security problems (newline characters) as well as simple
+    non-ASCII characters (including international characters and emoji).
+
+ *  **Call canceling is more reliable.**  We had a bug where a socket being
+     connected wasn't being closed when the application used `Call.cancel()`.
+
+ *  **Changing a HttpUrl’s scheme now tracks the default port.** We had a bug
+    where changing a URL from `http` to `https` would leave it on port 80.
+
+ *  **Okio has been updated to 1.6.0.**
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.6.0</version>
+     </dependency>
+     ```
+
+ *  New: `Cache.initialize()`. Call this on a background thread to eagerly
+    initialize the response cache.
+ *  New: Fold `MockWebServerRule` into `MockWebServer`. This makes it easier to
+    write JUnit tests with `MockWebServer`. The `MockWebServer` library now
+    depends on JUnit, though it continues to work with all testing frameworks.
+ *  Fix: `FormEncodingBuilder` is now consistent with browsers in which
+    characters it escapes. Previously we weren’t percent-encoding commas,
+    parens, and other characters.
+ *  Fix: Relax `FormEncodingBuilder` to support building empty forms.
+ *  Fix: Timeouts throw `SocketTimeoutException`, not `InterruptedIOException`.
+ *  Fix: Change `MockWebServer` to use the same logic as OkHttp when determining
+    whether an HTTP request permits a body.
+ *  Fix: `HttpUrl` now uses the canonical form for IPv6 addresses.
+ *  Fix: Use `HttpUrl` internally.
+ *  Fix: Recover from Android 4.2.2 EBADF crashes.
+ *  Fix: Don't crash with an `IllegalStateException` if an HTTP/2 or SPDY
+    write fails, leaving the connection in an inconsistent state.
+ *  Fix: Make sure the default user agent is ASCII.
+
+
 ## Version 2.4.0
 
 _2015-05-22_
@@ -32,7 +397,7 @@ _2015-05-16_
     Both are permitted-by-spec, but `%20` requires fewer special cases.
 
  *  **Okio has been updated to 1.4.0.**
-     ```
+     ```xml
      <dependency>
        <groupId>com.squareup.okio</groupId>
        <artifactId>okio</artifactId>
@@ -44,7 +409,7 @@ _2015-05-16_
     Passing null will now fail for request methods that require a body. Instead
     use an empty body such as this one:
 
-    ```
+    ```java
         RequestBody.create(null, new byte[0]);
     ```
 
@@ -53,7 +418,7 @@ _2015-05-16_
    your app. You'll need to pin both the top-level domain and the `*.` domain
    for full coverage.
 
-    ```
+    ```java
      client.setCertificatePinner(new CertificatePinner.Builder()
          .add("publicobject.com",   "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
          .add("*.publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
@@ -110,7 +475,7 @@ _2015-03-16_
 
  *  **Okio updated to 1.3.0.**
 
-    ```
+    ```xml
     <dependency>
       <groupId>com.squareup.okio</groupId>
       <artifactId>okio</artifactId>
@@ -215,14 +580,14 @@ _2014-11-04_
 
     To disable TLS fallback:
 
-    ```
+    ```java
     client.setConnectionSpecs(Arrays.asList(
         ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT));
     ```
 
     To disable cleartext connections, permitting `https` URLs only:
 
-    ```
+    ```java
     client.setConnectionSpecs(Arrays.asList(
         ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS));
     ```
@@ -256,7 +621,7 @@ _2014-11-04_
 
  *  **Okio updated to 1.0.1.**
 
-    ```
+    ```xml
     <dependency>
       <groupId>com.squareup.okio</groupId>
       <artifactId>okio</artifactId>
@@ -336,7 +701,7 @@ advice on upgrading from 1.x to 2.x.
     agent.
  *  New: Guava-like API to create headers:
 
-    ```
+    ```java
     Headers headers = Headers.of(name1, value1, name2, value2, ...).
     ```
 
@@ -379,7 +744,7 @@ in addition to synchronous blocking calls.
     add the `okhttp-urlconnection` module to your project and use the
     `OkUrlFactory` to create new instances of `HttpURLConnection`:
 
-    ```
+    ```java
     // OkHttp 1.x:
     HttpURLConnection connection = client.open(url);
 
@@ -634,4 +999,6 @@ _2013-05-06_
 
 Initial release.
 
- [brick]: (https://noncombatant.org/2015/05/01/about-http-public-key-pinning/)
+ [brick]: https://noncombatant.org/2015/05/01/about-http-public-key-pinning/
+ [webdav]: https://tools.ietf.org/html/rfc4918
+ [major_versions]: http://jakewharton.com/java-interoperability-policy-for-major-version-updates/
diff --git a/README.md b/README.md
index 6e010257bb..b6b059deb4 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,7 @@
 OkHttp
 ======
 
-An HTTP & SPDY client for Android and Java applications. For more information see [the website][1] and [the wiki][2].
+An HTTP & HTTP/2 client for Android and Java applications. For more information see [the website][1] and [the wiki][2].
 
 Download
 --------
@@ -9,14 +9,14 @@ Download
 Download [the latest JAR][3] or grab via Maven:
 ```xml
 <dependency>
-  <groupId>com.squareup.okhttp</groupId>
+  <groupId>com.squareup.okhttp3</groupId>
   <artifactId>okhttp</artifactId>
-  <version>2.4.0</version>
+  <version>3.2.0</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.okhttp:okhttp:2.4.0'
+compile 'com.squareup.okhttp3:okhttp:3.2.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -27,22 +27,22 @@ MockWebServer
 
 A library for testing HTTP, HTTPS, HTTP/2.0, and SPDY clients.
 
-MockWebServer coupling with OkHttp is essential for proper testing of SPDY and HTTP/2.0 so that code can be shared.
+MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2.0 so that code can be shared.
 
 ### Download
 
 Download [the latest JAR][4] or grab via Maven:
 ```xml
 <dependency>
-  <groupId>com.squareup.okhttp</groupId>
+  <groupId>com.squareup.okhttp3</groupId>
   <artifactId>mockwebserver</artifactId>
-  <version>2.4.0</version>
+  <version>3.2.0</version>
   <scope>test</scope>
 </dependency>
 ```
 or Gradle:
 ```groovy
-testCompile 'com.squareup.okhttp:mockwebserver:2.4.0'
+testCompile 'com.squareup.okhttp3:mockwebserver:3.2.0'
 ```
 
 
@@ -65,6 +65,6 @@ License
 
  [1]: http://square.github.io/okhttp
  [2]: https://github.com/square/okhttp/wiki
- [3]: https://search.maven.org/remote_content?g=com.squareup.okhttp&a=okhttp&v=LATEST
- [4]: https://search.maven.org/remote_content?g=com.squareup.okhttp&a=mockwebserver&v=LATEST
+ [3]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST
+ [4]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=mockwebserver&v=LATEST
  [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/benchmarks/README.md b/benchmarks/README.md
index 59f571fc55..ee9be3ff47 100644
--- a/benchmarks/README.md
+++ b/benchmarks/README.md
@@ -4,5 +4,5 @@ OkHttp Benchmarks
 This module allows you to test the performance of HTTP clients.
 
 ### Running
-  1. If you made modifications to `com.squareup.okhttp.benchmarks.Benchmark` run `mvn compile`.
+  1. If you made modifications to `Benchmark` run `mvn compile`.
   2. Run `mvn exec:exec` to launch a new JVM, which will execute the benchmark.
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index a56c4112d2..2dab72f0ef 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.5.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
@@ -25,17 +25,17 @@
       <version>14.0.1</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-urlconnection</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>mockwebserver</artifactId>
       <version>${project.version}</version>
     </dependency>
@@ -89,7 +89,7 @@
             <commandlineArgs>-Xbootclasspath/p:${bootclasspath}</commandlineArgs>
             <argument>-classpath</argument>
             <classpath />
-            <argument>com.squareup.okhttp.benchmarks.Benchmark</argument>
+            <argument>okhttp3.benchmarks.Benchmark</argument>
           </arguments>
         </configuration>
       </plugin>
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
similarity index 95%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
index 3f2609d207..2f97519a29 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
 import javax.net.ssl.SSLContext;
+import okhttp3.HttpUrl;
+import okhttp3.internal.SslContextBuilder;
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.HttpClient;
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
similarity index 89%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
index 04b7f7fbff..d69530fe0e 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
@@ -13,18 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
 import com.google.caliper.Param;
 import com.google.caliper.model.ArbitraryMeasurement;
 import com.google.caliper.runner.CaliperMain;
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.mockwebserver.Dispatcher;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -34,13 +27,20 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.net.ssl.SSLContext;
+import okhttp3.HttpUrl;
+import okhttp3.Protocol;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.GzipSink;
 
 /**
- * This benchmark is fake, but may be useful for certain relative comparisons.
- * It uses a local connection to a MockWebServer to measure how many identical
- * requests per second can be carried over a fixed number of threads.
+ * This benchmark is fake, but may be useful for certain relative comparisons. It uses a local
+ * connection to a MockWebServer to measure how many identical requests per second can be carried
+ * over a fixed number of threads.
  */
 public class Benchmark extends com.google.caliper.Benchmark {
   private static final int NUM_REPORTS = 10;
@@ -48,16 +48,16 @@
 
   private final Random random = new Random(0);
 
-  /** Which client to run.*/
+  /** Which client to run. */
   @Param
   Client client;
 
   /** How many concurrent requests to execute. */
-  @Param({ "1", "10" })
+  @Param({"1", "10"})
   int concurrencyLevel;
 
   /** How many requests to enqueue to await threads to execute them. */
-  @Param({ "10" })
+  @Param({"10"})
   int targetBacklog;
 
   /** True to use TLS. */
@@ -74,11 +74,11 @@
   boolean chunked;
 
   /** The size of the HTTP response body, in uncompressed bytes. */
-  @Param({ "128", "1048576" })
+  @Param({"128", "1048576"})
   int bodyByteCount;
 
   /** How many additional headers were included, beyond the built-in ones. */
-  @Param({ "0", "20" })
+  @Param({"0", "20"})
   int headerCount;
 
   /** Which ALPN protocols are in use. Only useful with TLS. */
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java b/benchmarks/src/main/java/okhttp3/benchmarks/Client.java
similarity index 96%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/Client.java
index bd777aa359..b7c6b3f3b9 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/Client.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
 enum Client {
   OkHttp {
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java
similarity index 91%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java
index 2820dc1cc8..0c0986ffeb 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java
@@ -13,13 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
-import com.squareup.okhttp.HttpUrl;
+import okhttp3.HttpUrl;
 
 /** An HTTP client to benchmark. */
 interface HttpClient {
   void prepare(Benchmark benchmark);
+
   void enqueue(HttpUrl url) throws Exception;
+
   boolean acceptingJobs();
 }
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
similarity index 98%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
index 1b5571b5de..8caa046c73 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
@@ -13,10 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.internal.SslContextBuilder;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.PooledByteBufAllocator;
@@ -46,6 +44,8 @@
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLEngine;
+import okhttp3.HttpUrl;
+import okhttp3.internal.SslContextBuilder;
 
 /** Netty isn't an HTTP client, but it's almost one. */
 class NettyHttpClient implements HttpClient {
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
similarity index 71%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
index 496e8d30bd..05eb5044d2 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
@@ -13,19 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
-import java.net.HttpURLConnection;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Call;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.ResponseBody;
+import okhttp3.internal.SslContextBuilder;
 
 class OkHttp extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
@@ -34,8 +35,9 @@
 
   @Override public void prepare(Benchmark benchmark) {
     super.prepare(benchmark);
-    client = new OkHttpClient();
-    client.setProtocols(benchmark.protocols);
+    client = new OkHttpClient.Builder()
+        .protocols(benchmark.protocols)
+        .build();
 
     if (benchmark.tls) {
       SSLContext sslContext = SslContextBuilder.localhost();
@@ -45,27 +47,30 @@
           return true;
         }
       };
-      client.setSslSocketFactory(socketFactory);
-      client.setHostnameVerifier(hostnameVerifier);
+      client = new OkHttpClient.Builder()
+          .sslSocketFactory(socketFactory)
+          .hostnameVerifier(hostnameVerifier)
+          .build();
     }
   }
 
   @Override public Runnable request(HttpUrl url) {
-    return new OkHttpRequest(url);
+    Call call = client.newCall(new Request.Builder().url(url).build());
+    return new OkHttpRequest(call);
   }
 
   class OkHttpRequest implements Runnable {
-    private final HttpUrl url;
+    private final Call call;
 
-    public OkHttpRequest(HttpUrl url) {
-      this.url = url;
+    public OkHttpRequest(Call call) {
+      this.call = call;
     }
 
     public void run() {
       long start = System.nanoTime();
       try {
-        HttpURLConnection urlConnection = new OkUrlFactory(client).open(url.url());
-        long total = readAllAndClose(urlConnection.getInputStream());
+        ResponseBody body = call.execute().body();
+        long total = readAllAndClose(body.byteStream());
         long finish = System.nanoTime();
 
         if (VERBOSE) {
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
similarity index 74%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
index cf0ad4accf..09bd3a73e3 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
@@ -13,16 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
-import com.squareup.okhttp.Callback;
-import com.squareup.okhttp.Dispatcher;
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
@@ -32,6 +24,15 @@
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Dispatcher;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.SslContextBuilder;
 
 class OkHttpAsync implements HttpClient {
   private static final boolean VERBOSE = false;
@@ -47,10 +48,11 @@
     concurrencyLevel = benchmark.concurrencyLevel;
     targetBacklog = benchmark.targetBacklog;
 
-    client = new OkHttpClient();
-    client.setProtocols(benchmark.protocols);
-    client.setDispatcher(new Dispatcher(new ThreadPoolExecutor(benchmark.concurrencyLevel,
-        benchmark.concurrencyLevel, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>())));
+    client = new OkHttpClient.Builder()
+        .protocols(benchmark.protocols)
+        .dispatcher(new Dispatcher(new ThreadPoolExecutor(benchmark.concurrencyLevel,
+            benchmark.concurrencyLevel, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>())))
+        .build();
 
     if (benchmark.tls) {
       SSLContext sslContext = SslContextBuilder.localhost();
@@ -60,16 +62,18 @@
           return true;
         }
       };
-      client.setSslSocketFactory(socketFactory);
-      client.setHostnameVerifier(hostnameVerifier);
+      client = client.newBuilder()
+          .sslSocketFactory(socketFactory)
+          .hostnameVerifier(hostnameVerifier)
+          .build();
     }
 
     callback = new Callback() {
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(Call call, IOException e) {
         System.out.println("Failed: " + e);
       }
 
-      @Override public void onResponse(Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) throws IOException {
         ResponseBody body = response.body();
         long total = SynchronousHttpClient.readAllAndClose(body.byteStream());
         long finish = System.nanoTime();
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java
similarity index 95%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java
index 3b9631511b..4a17b8693d 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
-import com.squareup.okhttp.HttpUrl;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import okhttp3.HttpUrl;
 
 /** Any HTTP client with a blocking API. */
 abstract class SynchronousHttpClient implements HttpClient {
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
similarity index 95%
rename from benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
rename to benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
index e17743095a..f5c02ce0b6 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
@@ -13,10 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.benchmarks;
+package okhttp3.benchmarks;
 
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
@@ -27,6 +25,8 @@
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.HttpUrl;
+import okhttp3.internal.SslContextBuilder;
 
 class UrlConnection extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
diff --git a/checkstyle.xml b/checkstyle.xml
index fc173af9e0..d8540c6168 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -44,7 +44,7 @@
     <module name="LocalVariableName"/>
     <module name="MemberName"/>
     <module name="MethodName"/>
-    <module name="PackageName"/>
+    <!--<module name="PackageName"/>-->
     <module name="ParameterName"/>
     <module name="StaticVariableName"/>
     <module name="TypeName"/>
@@ -82,7 +82,15 @@
     <module name="ParenPad"/>
     <module name="TypecastParenPad"/>
     <module name="WhitespaceAfter"/>
-    <module name="WhitespaceAround"/>
+    <module name="WhitespaceAround">
+      <property name="tokens"
+          value="ASSIGN, BAND, BAND_ASSIGN, BOR, BOR_ASSIGN, BSR, BSR_ASSIGN, BXOR, BXOR_ASSIGN,
+          COLON, DIV, DIV_ASSIGN, DO_WHILE, EQUAL, GE, GT, LAND, LCURLY, LE, LITERAL_CATCH,
+          LITERAL_DO, LITERAL_ELSE, LITERAL_FINALLY, LITERAL_FOR, LITERAL_IF, LITERAL_RETURN,
+          LITERAL_SWITCH, LITERAL_SYNCHRONIZED, LITERAL_TRY, LITERAL_WHILE, LOR, LT, MINUS,
+          MINUS_ASSIGN, MOD, MOD_ASSIGN, NOT_EQUAL, PLUS, PLUS_ASSIGN, QUESTION, SL, SLIST,
+          SL_ASSIGN, SR, SR_ASSIGN, STAR, STAR_ASSIGN, LITERAL_ASSERT, TYPE_EXTENSION_AND"/>
+    </module>
 
 
     <!-- Modifier Checks                                    -->
diff --git a/deploy_website.sh b/deploy_website.sh
index bbeedc2c36..c9b7f156b0 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -3,9 +3,6 @@
 set -ex
 
 REPO="git@github.com:square/okhttp.git"
-GROUP_ID="com.squareup.okhttp"
-ARTIFACT_ID="okhttp"
-
 DIR=temp-clone
 
 # Delete any existing temporary website clone
@@ -20,28 +17,12 @@ cd $DIR
 # Checkout and track the gh-pages branch
 git checkout -t origin/gh-pages
 
-# Delete everything
-rm -rf *
+# Delete everything that isn't versioned (1.x, 2.x)
+ls | grep -E -v '^\d+\.x$' | xargs rm -rf
 
 # Copy website files from real repo
 cp -R ../website/* .
 
-# Download the latest javadoc to directories like 'javadoc' or 'javadoc-urlconnection'.
-for DOCUMENTED_ARTIFACT in okhttp okhttp-urlconnection okhttp-apache
-do
-  curl -L "https://search.maven.org/remote_content?g=$GROUP_ID&a=$DOCUMENTED_ARTIFACT&v=LATEST&c=javadoc" > javadoc.zip
-  JAVADOC_DIR="javadoc${DOCUMENTED_ARTIFACT//okhttp/}"
-  mkdir $JAVADOC_DIR
-  unzip javadoc.zip -d $JAVADOC_DIR
-  rm javadoc.zip
-done
-
-# Download the 1.6.0 javadoc to '1.x/javadoc'.
-curl -L "https://search.maven.org/remote_content?g=$GROUP_ID&a=$ARTIFACT_ID&v=1.6.0&c=javadoc" > javadoc.zip
-mkdir -p 1.x/javadoc
-unzip javadoc.zip -d 1.x/javadoc
-rm javadoc.zip
-
 # Stage all files in git and create a commit
 git add .
 git add -u
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
index 00a3b0f54b..06cf0723f5 100644
--- a/mockwebserver/README.md
+++ b/mockwebserver/README.md
@@ -19,7 +19,7 @@ awkward-to-reproduce situations like 500 errors or slow-loading responses.
 ### Example
 
 Use MockWebServer the same way that you use mocking frameworks like
-[Mockito](https://code.google.com/p/mockito/):
+[Mockito](https://github.com/mockito/mockito):
 
 1. Script the mocks.
 2. Run application code.
@@ -42,7 +42,7 @@ public void test() throws Exception {
   server.start();
 
   // Ask the server for its URL. You'll need this to make HTTP requests.
-  URL baseUrl = server.getUrl("/v1/chat/");
+  HttpUrl baseUrl = server.url("/v1/chat/");
 
   // Exercise your application code, which should make those HTTP requests.
   // Responses are returned in the same order that they are enqueued.
@@ -108,7 +108,7 @@ Verify requests by their method, path, HTTP version, body, and headers.
 RecordedRequest request = server.takeRequest();
 assertEquals("POST /v1/chat/send HTTP/1.1", request.getRequestLine());
 assertEquals("application/json; charset=utf-8", request.getHeader("Content-Type"));
-assertEquals("{}", request.getUtf8Body());
+assertEquals("{}", request.getBody().readUtf8());
 ```
 
 #### Dispatcher
@@ -143,7 +143,7 @@ server.setDispatcher(dispatcher);
 Get MockWebServer via Maven:
 ```xml
 <dependency>
-  <groupId>com.squareup.okhttp</groupId>
+  <groupId>com.squareup.okhttp3</groupId>
   <artifactId>mockwebserver</artifactId>
   <version>(insert latest version)</version>
   <scope>test</scope>
@@ -152,7 +152,7 @@ Get MockWebServer via Maven:
 
 or via Gradle 
 ```groovy
-testCompile 'com.squareup.okhttp:mockwebserver:(insert latest version)'
+testCompile 'com.squareup.okhttp3:mockwebserver:(insert latest version)'
 ```
 
 ### License
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 3d5c842f8a..0d858e5524 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.5.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
@@ -14,18 +14,18 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-testing-support</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-ws</artifactId>
       <version>${project.version}</version>
     </dependency>
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
deleted file mode 100644
index 546d66036e..0000000000
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.math.BigInteger;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.KeyPairGenerator;
-import java.security.KeyStore;
-import java.security.SecureRandom;
-import java.security.Security;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.Date;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.TrustManagerFactory;
-import javax.security.auth.x500.X500Principal;
-import org.bouncycastle.jce.provider.BouncyCastleProvider;
-import org.bouncycastle.x509.X509V3CertificateGenerator;
-
-/**
- * Constructs an SSL context for testing. This uses Bouncy Castle to generate a
- * self-signed certificate for a single hostname such as "localhost".
- *
- * <p>The crypto performed by this class is relatively slow. Clients should
- * reuse SSL context instances where possible.
- */
-public final class SslContextBuilder {
-  static {
-    Security.addProvider(new BouncyCastleProvider());
-  }
-
-  private static final long ONE_DAY_MILLIS = 1000L * 60 * 60 * 24;
-  private static SSLContext localhost; // Lazily initialized.
-
-  private final String hostName;
-  private long notBefore = System.currentTimeMillis();
-  private long notAfter = System.currentTimeMillis() + ONE_DAY_MILLIS;
-
-  /**
-   * @param hostName the subject of the host. For TLS this should be the
-   * domain name that the client uses to identify the server.
-   */
-  public SslContextBuilder(String hostName) {
-    this.hostName = hostName;
-  }
-
-  /** Returns a new SSL context for this host's current localhost address. */
-  public static synchronized SSLContext localhost() {
-    if (localhost == null) {
-      try {
-        localhost = new SslContextBuilder(InetAddress.getByName("localhost").getHostName()).build();
-      } catch (GeneralSecurityException e) {
-        throw new RuntimeException(e);
-      } catch (UnknownHostException e) {
-        throw new RuntimeException(e);
-      }
-    }
-    return localhost;
-  }
-
-  public SSLContext build() throws GeneralSecurityException {
-    char[] password = "password".toCharArray();
-
-    // Generate public and private keys and use them to make a self-signed certificate.
-    KeyPair keyPair = generateKeyPair();
-    X509Certificate certificate = selfSignedCertificate(keyPair, "1");
-
-    // Put 'em in a key store.
-    KeyStore keyStore = newEmptyKeyStore(password);
-    Certificate[] certificateChain = { certificate };
-    keyStore.setKeyEntry("private", keyPair.getPrivate(), password, certificateChain);
-    keyStore.setCertificateEntry("cert", certificate);
-
-    // Wrap it up in an SSL context.
-    KeyManagerFactory keyManagerFactory =
-        KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
-    keyManagerFactory.init(keyStore, password);
-    TrustManagerFactory trustManagerFactory =
-        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
-    trustManagerFactory.init(keyStore);
-    SSLContext sslContext = SSLContext.getInstance("TLS");
-    sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(),
-        new SecureRandom());
-    return sslContext;
-  }
-
-  public KeyPair generateKeyPair() throws GeneralSecurityException {
-    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC");
-    keyPairGenerator.initialize(1024, new SecureRandom());
-    return keyPairGenerator.generateKeyPair();
-  }
-
-  /**
-   * Generates a certificate for {@code hostName} containing {@code keyPair}'s
-   * public key, signed by {@code keyPair}'s private key.
-   */
-  @SuppressWarnings("deprecation") // use the old Bouncy Castle APIs to reduce dependencies.
-  public X509Certificate selfSignedCertificate(KeyPair keyPair, String serialNumber)
-      throws GeneralSecurityException {
-    X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
-    X500Principal issuer = new X500Principal("CN=" + hostName);
-    X500Principal subject = new X500Principal("CN=" + hostName);
-    generator.setSerialNumber(new BigInteger(serialNumber));
-    generator.setIssuerDN(issuer);
-    generator.setNotBefore(new Date(notBefore));
-    generator.setNotAfter(new Date(notAfter));
-    generator.setSubjectDN(subject);
-    generator.setPublicKey(keyPair.getPublic());
-    generator.setSignatureAlgorithm("SHA256WithRSAEncryption");
-    return generator.generateX509Certificate(keyPair.getPrivate(), "BC");
-  }
-
-  private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
-    try {
-      KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
-      InputStream in = null; // By convention, 'null' creates an empty key store.
-      keyStore.load(in, password);
-      return keyStore;
-    } catch (IOException e) {
-      throw new AssertionError(e);
-    }
-  }
-}
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
deleted file mode 100644
index 4583621471..0000000000
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.mockwebserver;
-
-/** What should be done with the incoming socket. */
-public enum SocketPolicy {
-
-  /**
-   * Keep the socket open after the response. This is the default HTTP/1.1
-   * behavior.
-   */
-  KEEP_OPEN,
-
-  /**
-   * Close the socket after the response. This is the default HTTP/1.0
-   * behavior.
-   */
-  DISCONNECT_AT_END,
-
-  /**
-   * Wrap the socket with SSL at the completion of this request/response pair.
-   * Used for CONNECT messages to tunnel SSL over an HTTP proxy.
-   */
-  UPGRADE_TO_SSL_AT_END,
-
-  /**
-   * Request immediate close of connection without even reading the request. Use
-   * to simulate buggy SSL servers closing connections in response to
-   * unrecognized TLS extensions.
-   */
-  DISCONNECT_AT_START,
-
-  /**
-   * Close connection after reading the request but before writing the response.
-   * Use this to simulate late connection pool failures.
-   */
-  DISCONNECT_AFTER_REQUEST,
-
-  /** Close connection after writing half of the response body (if present). */
-  DISCONNECT_DURING_RESPONSE_BODY,
-
-  /** Don't trust the client during the SSL handshake. */
-  FAIL_HANDSHAKE,
-
-  /**
-   * Shutdown the socket input after sending the response. For testing bad
-   * behavior.
-   */
-  SHUTDOWN_INPUT_AT_END,
-
-  /**
-   * Shutdown the socket output after sending the response. For testing bad
-   * behavior.
-   */
-  SHUTDOWN_OUTPUT_AT_END,
-
-  /**
-   * Don't response to the request but keep the socket open. For testing
-   * read response header timeout issue.
-   */
-  NO_RESPONSE
-}
diff --git a/mockwebserver/src/main/java/okhttp3/internal/HeldCertificate.java b/mockwebserver/src/main/java/okhttp3/internal/HeldCertificate.java
new file mode 100644
index 0000000000..d6c45bd30b
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/internal/HeldCertificate.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.math.BigInteger;
+import java.security.GeneralSecurityException;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.SecureRandom;
+import java.security.Security;
+import java.security.cert.X509Certificate;
+import java.util.Date;
+import java.util.UUID;
+import javax.security.auth.x500.X500Principal;
+import org.bouncycastle.asn1.x509.BasicConstraints;
+import org.bouncycastle.asn1.x509.X509Extensions;
+import org.bouncycastle.jce.provider.BouncyCastleProvider;
+import org.bouncycastle.x509.X509V3CertificateGenerator;
+
+/**
+ * A certificate and its private key. This can be used on the server side by HTTPS servers, or on
+ * the client side to verify those HTTPS servers. A held certificate can also be used to sign other
+ * held certificates, as done in practice by certificate authorities.
+ */
+public final class HeldCertificate {
+  public final X509Certificate certificate;
+  public final KeyPair keyPair;
+
+  public HeldCertificate(X509Certificate certificate, KeyPair keyPair) {
+    this.certificate = certificate;
+    this.keyPair = keyPair;
+  }
+
+  public static final class Builder {
+    static {
+      Security.addProvider(new BouncyCastleProvider());
+    }
+
+    private final long duration = 1000L * 60 * 60 * 24; // One day.
+    private String hostname;
+    private String serialNumber = "1";
+    private KeyPair keyPair;
+    private HeldCertificate issuedBy;
+    private int maxIntermediateCas;
+
+    public Builder serialNumber(String serialNumber) {
+      this.serialNumber = serialNumber;
+      return this;
+    }
+
+    /**
+     * Set this certificate's name. Typically this is the URL hostname for TLS certificates. This is
+     * the CN (common name) in the certificate. Will be a random string if no value is provided.
+     */
+    public Builder commonName(String hostname) {
+      this.hostname = hostname;
+      return this;
+    }
+
+    public Builder keyPair(KeyPair keyPair) {
+      this.keyPair = keyPair;
+      return this;
+    }
+
+    /**
+     * Set the certificate that signs this certificate. If unset, a self-signed certificate will be
+     * generated.
+     */
+    public Builder issuedBy(HeldCertificate signedBy) {
+      this.issuedBy = signedBy;
+      return this;
+    }
+
+    /**
+     * Set this certificate to be a certificate authority, with up to {@code maxIntermediateCas}
+     * intermediate certificate authorities beneath it.
+     */
+    public Builder ca(int maxIntermediateCas) {
+      this.maxIntermediateCas = maxIntermediateCas;
+      return this;
+    }
+
+    public HeldCertificate build() throws GeneralSecurityException {
+      // Subject, public & private keys for this certificate.
+      KeyPair heldKeyPair = keyPair != null
+          ? keyPair
+          : generateKeyPair();
+      X500Principal subject = hostname != null
+          ? new X500Principal("CN=" + hostname)
+          : new X500Principal("CN=" + UUID.randomUUID());
+
+      // Subject, public & private keys for this certificate's signer. It may be self signed!
+      KeyPair signedByKeyPair;
+      X500Principal signedByPrincipal;
+      if (issuedBy != null) {
+        signedByKeyPair = issuedBy.keyPair;
+        signedByPrincipal = issuedBy.certificate.getSubjectX500Principal();
+      } else {
+        signedByKeyPair = heldKeyPair;
+        signedByPrincipal = subject;
+      }
+
+      // Generate & sign the certificate.
+      long now = System.currentTimeMillis();
+      X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
+      generator.setSerialNumber(new BigInteger(serialNumber));
+      generator.setIssuerDN(signedByPrincipal);
+      generator.setNotBefore(new Date(now));
+      generator.setNotAfter(new Date(now + duration));
+      generator.setSubjectDN(subject);
+      generator.setPublicKey(heldKeyPair.getPublic());
+      generator.setSignatureAlgorithm("SHA256WithRSAEncryption");
+
+      if (maxIntermediateCas > 0) {
+        generator.addExtension(X509Extensions.BasicConstraints, true,
+            new BasicConstraints(maxIntermediateCas));
+      }
+
+      X509Certificate certificate = generator.generateX509Certificate(
+          signedByKeyPair.getPrivate(), "BC");
+      return new HeldCertificate(certificate, heldKeyPair);
+    }
+
+    public KeyPair generateKeyPair() throws GeneralSecurityException {
+      KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC");
+      keyPairGenerator.initialize(1024, new SecureRandom());
+      return keyPairGenerator.generateKeyPair();
+    }
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/internal/SslContextBuilder.java b/mockwebserver/src/main/java/okhttp3/internal/SslContextBuilder.java
new file mode 100644
index 0000000000..b161e106e2
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/internal/SslContextBuilder.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.security.SecureRandom;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.List;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.TrustManagerFactory;
+
+/**
+ * Constructs an SSL context for testing. This uses Bouncy Castle to generate a self-signed
+ * certificate for a single hostname such as "localhost".
+ *
+ * <p>The crypto performed by this class is relatively slow. Clients should reuse SSL context
+ * instances where possible.
+ */
+public final class SslContextBuilder {
+  private static SSLContext localhost; // Lazily initialized.
+
+  /** Returns a new SSL context for this host's current localhost address. */
+  public static synchronized SSLContext localhost() {
+    if (localhost != null) return localhost;
+
+    try {
+      // Generate a self-signed cert for the server to serve and the client to trust.
+      HeldCertificate heldCertificate = new HeldCertificate.Builder()
+          .serialNumber("1")
+          .commonName(InetAddress.getByName("localhost").getHostName())
+          .build();
+
+      localhost = new SslContextBuilder()
+          .certificateChain(heldCertificate)
+          .addTrustedCertificate(heldCertificate.certificate)
+          .build();
+
+      return localhost;
+    } catch (GeneralSecurityException e) {
+      throw new RuntimeException(e);
+    } catch (UnknownHostException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  private HeldCertificate[] chain;
+  private List<X509Certificate> trustedCertificates = new ArrayList<>();
+
+  /**
+   * Configure the certificate chain to use when serving HTTPS responses. The first certificate
+   * in this chain is the server's certificate, further certificates are included in the handshake
+   * so the client can build a trusted path to a CA certificate.
+   */
+  public SslContextBuilder certificateChain(HeldCertificate... chain) {
+    this.chain = chain;
+    return this;
+  }
+
+  /**
+   * Add a certificate authority that this client trusts. Servers that provide certificate chains
+   * signed by these roots (or their intermediates) will be accepted.
+   */
+  public SslContextBuilder addTrustedCertificate(X509Certificate certificate) {
+    trustedCertificates.add(certificate);
+    return this;
+  }
+
+  public SSLContext build() throws GeneralSecurityException {
+    // Put the certificate in a key store.
+    char[] password = "password".toCharArray();
+    KeyStore keyStore = newEmptyKeyStore(password);
+
+    if (chain != null) {
+      Certificate[] certificates = new Certificate[chain.length];
+      for (int i = 0; i < chain.length; i++) {
+        certificates[i] = chain[i].certificate;
+      }
+      keyStore.setKeyEntry("private", chain[0].keyPair.getPrivate(), password, certificates);
+    }
+
+    for (int i = 0; i < trustedCertificates.size(); i++) {
+      keyStore.setCertificateEntry("cert_" + i, trustedCertificates.get(i));
+    }
+
+    // Wrap it up in an SSL context.
+    KeyManagerFactory keyManagerFactory =
+        KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
+    keyManagerFactory.init(keyStore, password);
+    TrustManagerFactory trustManagerFactory =
+        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+    trustManagerFactory.init(keyStore);
+    SSLContext sslContext = SSLContext.getInstance("TLS");
+    sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(),
+        new SecureRandom());
+    return sslContext;
+  }
+
+  private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
+    try {
+      KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
+      InputStream in = null; // By convention, 'null' creates an empty key store.
+      keyStore.load(in, password);
+      return keyStore;
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
+}
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/framed/FramedServer.java b/mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java
similarity index 91%
rename from mockwebserver/src/main/java/com/squareup/okhttp/internal/framed/FramedServer.java
rename to mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java
index b95b64d899..4ac8159d6c 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/framed/FramedServer.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/framed/FramedServer.java
@@ -14,12 +14,8 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
 import java.io.File;
 import java.io.IOException;
 import java.net.ProtocolException;
@@ -31,12 +27,18 @@
 import java.util.logging.Logger;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Protocol;
+import okhttp3.internal.Platform;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.Util;
 import okio.BufferedSink;
 import okio.Okio;
 import okio.Source;
 
+import static okhttp3.internal.Platform.INFO;
+
 /** A basic SPDY/HTTP_2 server that serves the contents of a local directory. */
-public final class FramedServer implements IncomingStreamHandler {
+public final class FramedServer extends FramedConnection.Listener {
   static final Logger logger = Logger.getLogger(FramedServer.class.getName());
 
   private final List<Protocol> framedProtocols =
@@ -65,11 +67,12 @@ private void run() throws Exception {
         if (protocol == null || !framedProtocols.contains(protocol)) {
           throw new ProtocolException("Protocol " + protocol + " unsupported");
         }
-        FramedConnection framedConnection = new FramedConnection.Builder(false, sslSocket)
+        FramedConnection framedConnection = new FramedConnection.Builder(false)
+            .socket(sslSocket)
             .protocol(protocol)
-            .handler(this)
+            .listener(this)
             .build();
-        framedConnection.sendConnectionPreface();
+        framedConnection.start();
       } catch (IOException e) {
         logger.log(Level.INFO, "FramedServer connection failure: " + e);
         Util.closeQuietly(socket);
@@ -89,7 +92,7 @@ private SSLSocket doSsl(Socket socket) throws IOException {
     return sslSocket;
   }
 
-  @Override public void receive(final FramedStream stream) throws IOException {
+  @Override public void onStream(final FramedStream stream) throws IOException {
     try {
       List<Header> requestHeaders = stream.getRequestHeaders();
       String path = null;
@@ -115,7 +118,7 @@ private SSLSocket doSsl(Socket socket) throws IOException {
         send404(stream, path);
       }
     } catch (IOException e) {
-      System.out.println(e.getMessage());
+      Platform.get().log(INFO, "Failure serving FramedStream: " + e.getMessage(), null);
     }
   }
 
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java
similarity index 61%
rename from mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java
rename to mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java
index 4e1e0e70f6..9f4fc9fb66 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.java
@@ -13,24 +13,31 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.mockwebserver;
+package okhttp3.mockwebserver;
 
 /** Handler for mock server requests. */
 public abstract class Dispatcher {
   /**
-   * Returns a response to satisfy {@code request}. This method may block (for
-   * instance, to wait on a CountdownLatch).
+   * Returns a response to satisfy {@code request}. This method may block (for instance, to wait on
+   * a CountdownLatch).
    */
   public abstract MockResponse dispatch(RecordedRequest request) throws InterruptedException;
 
   /**
-   * Returns an early guess of the next response, used for policy on how an
-   * incoming request should be received. The default implementation returns an
-   * empty response. Mischievous implementations can return other values to test
-   * HTTP edge cases, such as unhappy socket policies or throttled request
-   * bodies.
+   * Returns an early guess of the next response, used for policy on how an incoming request should
+   * be received. The default implementation returns an empty response. Mischievous implementations
+   * can return other values to test HTTP edge cases, such as unhappy socket policies or throttled
+   * request bodies.
    */
   public MockResponse peek() {
     return new MockResponse().setSocketPolicy(SocketPolicy.KEEP_OPEN);
   }
+
+  /**
+   * Release any resources held by this dispatcher. Any requests that are currently being dispatched
+   * should return immediately. Responses returned after shutdown will not be transmitted: their
+   * socket connections have already been closed.
+   */
+  public void shutdown() {
+  }
 }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
similarity index 75%
rename from mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
rename to mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
index 09dda5634b..9f56b34f99 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
@@ -13,20 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.mockwebserver;
+package okhttp3.mockwebserver;
 
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.ws.WebSocketListener;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import okhttp3.Headers;
+import okhttp3.internal.Internal;
+import okhttp3.internal.framed.Settings;
+import okhttp3.ws.WebSocketListener;
 import okio.Buffer;
 
 /** A scripted response to be replayed by the mock web server. */
 public final class MockResponse implements Cloneable {
   private static final String CHUNKED_BODY_HEADER = "Transfer-encoding: chunked";
 
-  private String status = "HTTP/1.1 200 OK";
+  private String status;
   private Headers.Builder headers = new Headers.Builder();
 
   private Buffer body;
@@ -41,10 +43,12 @@
   private TimeUnit bodyDelayUnit = TimeUnit.MILLISECONDS;
 
   private List<PushPromise> promises = new ArrayList<>();
+  private Settings settings;
   private WebSocketListener webSocketListener;
 
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
+    setResponseCode(200);
     setHeader("Content-Length", 0);
   }
 
@@ -65,7 +69,19 @@ public String getStatus() {
   }
 
   public MockResponse setResponseCode(int code) {
-    return setStatus("HTTP/1.1 " + code + " OK");
+    String reason = "Mock Response";
+    if (code >= 100 && code < 200) {
+      reason = "Informational";
+    } else if (code >= 200 && code < 300) {
+      reason = "OK";
+    } else if (code >= 300 && code < 400) {
+      reason = "Redirection";
+    } else if (code >= 400 && code < 500) {
+      reason = "Client Error";
+    } else if (code >= 500 && code < 600) {
+      reason = "Server Error";
+    }
+    return setStatus("HTTP/1.1 " + code + " " + reason);
   }
 
   public MockResponse setStatus(String status) {
@@ -79,8 +95,8 @@ public Headers getHeaders() {
   }
 
   /**
-   * Removes all HTTP headers including any "Content-Length" and
-   * "Transfer-encoding" headers that were added by default.
+   * Removes all HTTP headers including any "Content-Length" and "Transfer-encoding" headers that
+   * were added by default.
    */
   public MockResponse clearHeaders() {
     headers = new Headers.Builder();
@@ -88,8 +104,8 @@ public MockResponse clearHeaders() {
   }
 
   /**
-   * Adds {@code header} as an HTTP header. For well-formed HTTP {@code header}
-   * should contain a name followed by a colon and a value.
+   * Adds {@code header} as an HTTP header. For well-formed HTTP {@code header} should contain a
+   * name followed by a colon and a value.
    */
   public MockResponse addHeader(String header) {
     headers.add(header);
@@ -97,8 +113,8 @@ public MockResponse addHeader(String header) {
   }
 
   /**
-   * Adds a new header with the name and value. This may be used to add multiple
-   * headers with the same name.
+   * Adds a new header with the name and value. This may be used to add multiple headers with the
+   * same name.
    */
   public MockResponse addHeader(String name, Object value) {
     headers.add(name, String.valueOf(value));
@@ -106,8 +122,17 @@ public MockResponse addHeader(String name, Object value) {
   }
 
   /**
-   * Removes all headers named {@code name}, then adds a new header with the
-   * name and value.
+   * Adds a new header with the name and value. This may be used to add multiple headers with the
+   * same name. Unlike {@link #addHeader(String, Object)} this does not validate the name and
+   * value.
+   */
+  public MockResponse addHeaderLenient(String name, Object value) {
+    Internal.instance.addLenient(headers, name, String.valueOf(value));
+    return this;
+  }
+
+  /**
+   * Removes all headers named {@code name}, then adds a new header with the name and value.
    */
   public MockResponse setHeader(String name, Object value) {
     removeHeader(name);
@@ -143,8 +168,7 @@ public MockResponse setBody(String body) {
   }
 
   /**
-   * Sets the response body to {@code body}, chunked every {@code maxChunkSize}
-   * bytes.
+   * Sets the response body to {@code body}, chunked every {@code maxChunkSize} bytes.
    */
   public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
     removeHeader("Content-Length");
@@ -165,8 +189,8 @@ public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
   }
 
   /**
-   * Sets the response body to the UTF-8 encoded bytes of {@code body}, chunked
-   * every {@code maxChunkSize} bytes.
+   * Sets the response body to the UTF-8 encoded bytes of {@code body}, chunked every {@code
+   * maxChunkSize} bytes.
    */
   public MockResponse setChunkedBody(String body, int maxChunkSize) {
     return setChunkedBody(new Buffer().writeUtf8(body), maxChunkSize);
@@ -182,9 +206,8 @@ public MockResponse setSocketPolicy(SocketPolicy socketPolicy) {
   }
 
   /**
-   * Throttles the response body writer to sleep for the given period after each
-   * series of {@code bytesPerPeriod} bytes are written. Use this to simulate
-   * network behavior.
+   * Throttles the request reader and response writer to sleep for the given period after each
+   * series of {@code bytesPerPeriod} bytes are transferred. Use this to simulate network behavior.
    */
   public MockResponse throttleBody(long bytesPerPeriod, long period, TimeUnit unit) {
     this.throttleBytesPerPeriod = bytesPerPeriod;
@@ -202,8 +225,8 @@ public long getThrottlePeriod(TimeUnit unit) {
   }
 
   /**
-   * Set the delayed time of the response body to {@code delay}. This applies to the
-   * response body only; response headers are not affected.
+   * Set the delayed time of the response body to {@code delay}. This applies to the response body
+   * only; response headers are not affected.
    */
   public MockResponse setBodyDelay(long delay, TimeUnit unit) {
     bodyDelayAmount = delay;
@@ -216,9 +239,8 @@ public long getBodyDelay(TimeUnit unit) {
   }
 
   /**
-   * When {@link MockWebServer#setProtocols(java.util.List) protocols}
-   * include {@linkplain com.squareup.okhttp.Protocol#HTTP_2}, this attaches a
-   * pushed stream to this response.
+   * When {@link MockWebServer#setProtocols(java.util.List) protocols} include {@linkplain
+   * okhttp3.Protocol#HTTP_2}, this attaches a pushed stream to this response.
    */
   public MockResponse withPush(PushPromise promise) {
     this.promises.add(promise);
@@ -230,6 +252,19 @@ public MockResponse withPush(PushPromise promise) {
     return promises;
   }
 
+  /**
+   * When {@linkplain MockWebServer#setProtocols(java.util.List) protocols} include {@linkplain
+   * okhttp3.Protocol#HTTP_2 HTTP/2}, this pushes {@code settings} before writing the response.
+   */
+  public MockResponse withSettings(Settings settings) {
+    this.settings = settings;
+    return this;
+  }
+
+  public Settings getSettings() {
+    return settings;
+  }
+
   /**
    * Attempts to perform a web socket upgrade on the connection. This will overwrite any previously
    * set status or body.
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
similarity index 84%
rename from mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
rename to mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 458c6f9a5c..aa373f8b01 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -15,25 +15,8 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.mockwebserver;
-
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.framed.ErrorCode;
-import com.squareup.okhttp.internal.framed.FramedConnection;
-import com.squareup.okhttp.internal.framed.FramedStream;
-import com.squareup.okhttp.internal.framed.Header;
-import com.squareup.okhttp.internal.framed.IncomingStreamHandler;
-import com.squareup.okhttp.internal.http.HttpMethod;
-import com.squareup.okhttp.internal.ws.RealWebSocket;
-import com.squareup.okhttp.internal.ws.WebSocketProtocol;
-import com.squareup.okhttp.ws.WebSocketListener;
+package okhttp3.mockwebserver;
+
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -42,7 +25,6 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketException;
-import java.net.URL;
 import java.security.SecureRandom;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
@@ -70,6 +52,23 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Platform;
+import okhttp3.internal.Util;
+import okhttp3.internal.framed.ErrorCode;
+import okhttp3.internal.framed.FramedConnection;
+import okhttp3.internal.framed.FramedStream;
+import okhttp3.internal.framed.Header;
+import okhttp3.internal.framed.Settings;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.ws.RealWebSocket;
+import okhttp3.internal.ws.WebSocketProtocol;
+import okhttp3.ws.WebSocketListener;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -81,14 +80,21 @@
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
 
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_REQUEST_BODY;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
+import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
+import static okhttp3.mockwebserver.SocketPolicy.NO_RESPONSE;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
 
 /**
- * A scriptable web server. Callers supply canned responses and the server
- * replays them upon request in sequence.
+ * A scriptable web server. Callers supply canned responses and the server replays them upon request
+ * in sequence.
  */
 public final class MockWebServer implements TestRule {
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
@@ -174,18 +180,13 @@ public Proxy toProxyAddress() {
   }
 
   public void setServerSocketFactory(ServerSocketFactory serverSocketFactory) {
+    if (executor != null) {
+      throw new IllegalStateException(
+          "setServerSocketFactory() must be called before start()");
+    }
     this.serverSocketFactory = serverSocketFactory;
   }
 
-  /**
-   * Returns a URL for connecting to this server.
-   * @param path the request path, such as "/".
-   */
-  @Deprecated
-  public URL getUrl(String path) {
-    return url(path).url();
-  }
-
   /**
    * Returns a URL for connecting to this server.
    *
@@ -201,39 +202,26 @@ public HttpUrl url(String path) {
   }
 
   /**
-   * Returns a cookie domain for this server. This returns the server's
-   * non-loopback host name if it is known. Otherwise this returns ".local" for
-   * this server's loopback name.
-   */
-  public String getCookieDomain() {
-    String hostName = getHostName();
-    return hostName.contains(".") ? hostName : ".local";
-  }
-
-  /**
-   * Sets the number of bytes of the POST body to keep in memory to the given
-   * limit.
+   * Sets the number of bytes of the POST body to keep in memory to the given limit.
    */
   public void setBodyLimit(long maxBodyLength) {
     this.bodyLimit = maxBodyLength;
   }
 
   /**
-   * Sets whether ALPN is used on incoming HTTPS connections to
-   * negotiate a protocol like HTTP/1.1 or HTTP/2. Call this method to disable
-   * negotiation and restrict connections to HTTP/1.1.
+   * Sets whether ALPN is used on incoming HTTPS connections to negotiate a protocol like HTTP/1.1
+   * or HTTP/2. Call this method to disable negotiation and restrict connections to HTTP/1.1.
    */
   public void setProtocolNegotiationEnabled(boolean protocolNegotiationEnabled) {
     this.protocolNegotiationEnabled = protocolNegotiationEnabled;
   }
 
   /**
-   * Indicates the protocols supported by ALPN on incoming HTTPS
-   * connections. This list is ignored when
-   * {@link #setProtocolNegotiationEnabled negotiation is disabled}.
+   * Indicates the protocols supported by ALPN on incoming HTTPS connections. This list is ignored
+   * when {@link #setProtocolNegotiationEnabled negotiation is disabled}.
    *
-   * @param protocols the protocols to use, in order of preference. The list
-   *     must contain {@linkplain Protocol#HTTP_1_1}. It must not contain null.
+   * @param protocols the protocols to use, in order of preference. The list must contain
+   * {@linkplain Protocol#HTTP_1_1}. It must not contain null.
    */
   public void setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
@@ -248,8 +236,8 @@ public void setProtocols(List<Protocol> protocols) {
 
   /**
    * Serve requests with HTTPS rather than otherwise.
-   * @param tunnelProxy true to expect the HTTP CONNECT method before
-   *     negotiating TLS.
+   *
+   * @param tunnelProxy true to expect the HTTP CONNECT method before negotiating TLS.
    */
   public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
     this.sslSocketFactory = sslSocketFactory;
@@ -257,9 +245,9 @@ public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
   }
 
   /**
-   * Awaits the next HTTP request, removes it, and returns it. Callers should
-   * use this to verify the request was sent as intended. This method will block until the
-   * request is available, possibly forever.
+   * Awaits the next HTTP request, removes it, and returns it. Callers should use this to verify the
+   * request was sent as intended. This method will block until the request is available, possibly
+   * forever.
    *
    * @return the head of the request queue
    */
@@ -268,14 +256,12 @@ public RecordedRequest takeRequest() throws InterruptedException {
   }
 
   /**
-   * Awaits the next HTTP request (waiting up to the
-   * specified wait time if necessary), removes it, and returns it. Callers should
-   * use this to verify the request was sent as intended within the given time.
+   * Awaits the next HTTP request (waiting up to the specified wait time if necessary), removes it,
+   * and returns it. Callers should use this to verify the request was sent as intended within the
+   * given time.
    *
-   * @param timeout how long to wait before giving up, in units of
-  *        {@code unit}
-   * @param unit a {@code TimeUnit} determining how to interpret the
-   *        {@code timeout} parameter
+   * @param timeout how long to wait before giving up, in units of {@code unit}
+   * @param unit a {@code TimeUnit} determining how to interpret the {@code timeout} parameter
    * @return the head of the request queue
    */
   public RecordedRequest takeRequest(long timeout, TimeUnit unit) throws InterruptedException {
@@ -283,21 +269,20 @@ public RecordedRequest takeRequest(long timeout, TimeUnit unit) throws Interrupt
   }
 
   /**
-   * Returns the number of HTTP requests received thus far by this server. This
-   * may exceed the number of HTTP connections when connection reuse is in
-   * practice.
+   * Returns the number of HTTP requests received thus far by this server. This may exceed the
+   * number of HTTP connections when connection reuse is in practice.
    */
   public int getRequestCount() {
     return requestCount.get();
   }
 
   /**
-   * Scripts {@code response} to be returned to a request made in sequence. The
-   * first request is served by the first enqueued response; the second request
-   * by the second enqueued response; and so on.
+   * Scripts {@code response} to be returned to a request made in sequence. The first request is
+   * served by the first enqueued response; the second request by the second enqueued response; and
+   * so on.
    *
-   * @throws ClassCastException if the default dispatcher has been replaced
-   *     with {@link #setDispatcher(Dispatcher)}.
+   * @throws ClassCastException if the default dispatcher has been replaced with {@link
+   * #setDispatcher(Dispatcher)}.
    */
   public void enqueue(MockResponse response) {
     ((QueueDispatcher) dispatcher).enqueueResponse(response.clone());
@@ -311,9 +296,8 @@ public void start() throws IOException {
   /**
    * Starts the server on the loopback interface for the given port.
    *
-   * @param port the port to listen to, or 0 for any available port. Automated
-   *     tests should always use port 0 to avoid flakiness when a specific port
-   *     is unavailable.
+   * @param port the port to listen to, or 0 for any available port. Automated tests should always
+   * use port 0 to avoid flakiness when a specific port is unavailable.
    */
   public void start(int port) throws IOException {
     start(InetAddress.getByName("localhost"), port);
@@ -323,10 +307,8 @@ public void start(int port) throws IOException {
    * Starts the server on the given address and port.
    *
    * @param inetAddress the address to create the server socket on
-   *
-   * @param port the port to listen to, or 0 for any available port. Automated
-   *     tests should always use port 0 to avoid flakiness when a specific port
-   *     is unavailable.
+   * @param port the port to listen to, or 0 for any available port. Automated tests should always
+   * use port 0 to avoid flakiness when a specific port is unavailable.
    */
   public void start(InetAddress inetAddress, int port) throws IOException {
     start(new InetSocketAddress(inetAddress, port));
@@ -368,6 +350,7 @@ private synchronized void start(InetSocketAddress inetSocketAddress) throws IOEx
           Util.closeQuietly(s.next());
           s.remove();
         }
+        dispatcher.shutdown();
         executor.shutdown();
       }
 
@@ -461,11 +444,13 @@ public void processConnection() throws Exception {
         }
 
         if (protocol != Protocol.HTTP_1_1) {
-          FramedSocketHandler framedSocketHandler = new FramedSocketHandler(socket, protocol);
-          FramedConnection framedConnection =
-              new FramedConnection.Builder(false, socket).protocol(protocol)
-                  .handler(framedSocketHandler)
-                  .build();
+          FramedSocketHandler framedSocketListener = new FramedSocketHandler(socket, protocol);
+          FramedConnection framedConnection = new FramedConnection.Builder(false)
+              .socket(socket)
+              .protocol(protocol)
+              .listener(framedSocketListener)
+              .build();
+          framedConnection.start();
           openFramedConnections.add(framedConnection);
           openClientSockets.remove(socket);
           return;
@@ -502,7 +487,7 @@ private void createTunnel() throws IOException, InterruptedException {
           if (!processOneRequest(raw, source, sink)) {
             throw new IllegalStateException("Tunnel without any CONNECT!");
           }
-          if (socketPolicy == SocketPolicy.UPGRADE_TO_SSL_AT_END) return;
+          if (socketPolicy == UPGRADE_TO_SSL_AT_END) return;
         }
       }
 
@@ -519,11 +504,11 @@ private boolean processOneRequest(Socket socket, BufferedSource source, Buffered
         requestQueue.add(request);
 
         MockResponse response = dispatcher.dispatch(request);
-        if (response.getSocketPolicy() == SocketPolicy.DISCONNECT_AFTER_REQUEST) {
+        if (response.getSocketPolicy() == DISCONNECT_AFTER_REQUEST) {
           socket.close();
           return false;
         }
-        if (response.getSocketPolicy() == SocketPolicy.NO_RESPONSE) {
+        if (response.getSocketPolicy() == NO_RESPONSE) {
           // This read should block until the socket is closed. (Because nobody is writing.)
           if (source.exhausted()) return false;
           throw new ProtocolException("unexpected data");
@@ -545,12 +530,13 @@ private boolean processOneRequest(Socket socket, BufferedSource source, Buffered
               + " and responded: " + response);
         }
 
-        if (response.getSocketPolicy() == SocketPolicy.DISCONNECT_AT_END) {
+        // See warnings associated with these socket policies in SocketPolicy.
+        if (response.getSocketPolicy() == DISCONNECT_AT_END) {
           socket.close();
           return false;
-        } else if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_INPUT_AT_END) {
+        } else if (response.getSocketPolicy() == SHUTDOWN_INPUT_AT_END) {
           socket.shutdownInput();
-        } else if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_OUTPUT_AT_END) {
+        } else if (response.getSocketPolicy() == SHUTDOWN_OUTPUT_AT_END) {
           socket.shutdownOutput();
         }
 
@@ -562,7 +548,7 @@ private boolean processOneRequest(Socket socket, BufferedSource source, Buffered
 
   private void processHandshakeFailure(Socket raw) throws Exception {
     SSLContext context = SSLContext.getInstance("TLS");
-    context.init(null, new TrustManager[] { UNTRUSTED_TRUST_MANAGER }, new SecureRandom());
+    context.init(null, new TrustManager[] {UNTRUSTED_TRUST_MANAGER}, new SecureRandom());
     SSLSocketFactory sslSocketFactory = context.getSocketFactory();
     SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(
         raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);
@@ -664,13 +650,13 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
 
     ThreadPoolExecutor replyExecutor =
         new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-            Util.threadFactory(String.format("MockWebServer %s WebSocket", request.getPath()),
+            Util.threadFactory(Util.format("MockWebServer %s WebSocket", request.getPath()),
                 true));
     replyExecutor.allowCoreThreadTimeOut(true);
     final RealWebSocket webSocket =
         new RealWebSocket(false /* is server */, source, sink, new SecureRandom(), replyExecutor,
             listener, request.getPath()) {
-          @Override protected void closeConnection() throws IOException {
+          @Override protected void close() throws IOException {
             connectionClose.countDown();
           }
         };
@@ -702,6 +688,7 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
       throw new RuntimeException(e);
     }
 
+    replyExecutor.shutdown();
     Util.closeQuietly(sink);
     Util.closeQuietly(source);
   }
@@ -739,9 +726,9 @@ private void sleepIfDelayed(MockResponse response) {
   }
 
   /**
-   * Transfer bytes from {@code source} to {@code sink} until either {@code byteCount}
-   * bytes have been transferred or {@code source} is exhausted. The transfer is
-   * throttled according to {@code policy}.
+   * Transfer bytes from {@code source} to {@code sink} until either {@code byteCount} bytes have
+   * been transferred or {@code source} is exhausted. The transfer is throttled according to {@code
+   * policy}.
    */
   private void throttledTransfer(MockResponse policy, Socket socket, BufferedSource source,
       BufferedSink sink, long byteCount, boolean isRequest) throws IOException {
@@ -752,8 +739,9 @@ private void throttledTransfer(MockResponse policy, Socket socket, BufferedSourc
     long periodDelayMs = policy.getThrottlePeriod(TimeUnit.MILLISECONDS);
 
     long halfByteCount = byteCount / 2;
-    boolean disconnectHalfway =
-        !isRequest && policy.getSocketPolicy() == DISCONNECT_DURING_RESPONSE_BODY;
+    boolean disconnectHalfway = isRequest
+        ? policy.getSocketPolicy() == DISCONNECT_DURING_REQUEST_BODY
+        : policy.getSocketPolicy() == DISCONNECT_DURING_RESPONSE_BODY;
 
     while (!socket.isClosed()) {
       for (int b = 0; b < bytesPerPeriod; ) {
@@ -796,10 +784,9 @@ private void readEmptyLine(BufferedSource source) throws IOException {
   }
 
   /**
-   * Sets the dispatcher used to match incoming requests to mock responses.
-   * The default dispatcher simply serves a fixed sequence of responses from
-   * a {@link #enqueue(MockResponse) queue}; custom dispatchers can vary the
-   * response based on timing or the content of the request.
+   * Sets the dispatcher used to match incoming requests to mock responses. The default dispatcher
+   * simply serves a fixed sequence of responses from a {@link #enqueue(MockResponse) queue}; custom
+   * dispatchers can vary the response based on timing or the content of the request.
    */
   public void setDispatcher(Dispatcher dispatcher) {
     if (dispatcher == null) throw new NullPointerException();
@@ -845,7 +832,7 @@ public void setDispatcher(Dispatcher dispatcher) {
   }
 
   /** Processes HTTP requests layered over framed protocols. */
-  private class FramedSocketHandler implements IncomingStreamHandler {
+  private class FramedSocketHandler extends FramedConnection.Listener {
     private final Socket socket;
     private final Protocol protocol;
     private final AtomicInteger sequenceNumber = new AtomicInteger();
@@ -855,7 +842,7 @@ private FramedSocketHandler(Socket socket, Protocol protocol) {
       this.protocol = protocol;
     }
 
-    @Override public void receive(FramedStream stream) throws IOException {
+    @Override public void onStream(FramedStream stream) throws IOException {
       RecordedRequest request = readRequest(stream);
       requestQueue.add(request);
       MockResponse response;
@@ -886,8 +873,14 @@ private RecordedRequest readRequest(FramedStream stream) throws IOException {
           path = value;
         } else if (name.equals(Header.VERSION)) {
           version = value;
-        } else {
+        } else if (protocol == Protocol.SPDY_3) {
+          for (String s : value.split("\u0000", -1)) {
+            httpHeaders.add(name.utf8(), s);
+          }
+        } else if (protocol == Protocol.HTTP_2) {
           httpHeaders.add(name.utf8(), value);
+        } else {
+          throw new IllegalStateException();
         }
       }
 
@@ -902,7 +895,12 @@ private RecordedRequest readRequest(FramedStream stream) throws IOException {
     }
 
     private void writeResponse(FramedStream stream, MockResponse response) throws IOException {
-      if (response.getSocketPolicy() == SocketPolicy.NO_RESPONSE) {
+      Settings settings = response.getSettings();
+      if (settings != null) {
+        stream.getConnection().setSettings(settings);
+      }
+
+      if (response.getSocketPolicy() == NO_RESPONSE) {
         return;
       }
       List<Header> spdyHeaders = new ArrayList<>();
@@ -939,21 +937,21 @@ private void pushPromises(FramedStream stream, List<PushPromise> promises) throw
         List<Header> pushedHeaders = new ArrayList<>();
         pushedHeaders.add(new Header(stream.getConnection().getProtocol() == Protocol.SPDY_3
             ? Header.TARGET_HOST
-            : Header.TARGET_AUTHORITY, url(pushPromise.getPath()).host()));
-        pushedHeaders.add(new Header(Header.TARGET_METHOD, pushPromise.getMethod()));
-        pushedHeaders.add(new Header(Header.TARGET_PATH, pushPromise.getPath()));
-        Headers pushPromiseHeaders = pushPromise.getHeaders();
+            : Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
+        pushedHeaders.add(new Header(Header.TARGET_METHOD, pushPromise.method()));
+        pushedHeaders.add(new Header(Header.TARGET_PATH, pushPromise.path()));
+        Headers pushPromiseHeaders = pushPromise.headers();
         for (int i = 0, size = pushPromiseHeaders.size(); i < size; i++) {
           pushedHeaders.add(new Header(pushPromiseHeaders.name(i), pushPromiseHeaders.value(i)));
         }
-        String requestLine = pushPromise.getMethod() + ' ' + pushPromise.getPath() + " HTTP/1.1";
+        String requestLine = pushPromise.method() + ' ' + pushPromise.path() + " HTTP/1.1";
         List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
-        requestQueue.add(new RecordedRequest(requestLine, pushPromise.getHeaders(), chunkSizes, 0,
+        requestQueue.add(new RecordedRequest(requestLine, pushPromise.headers(), chunkSizes, 0,
             new Buffer(), sequenceNumber.getAndIncrement(), socket));
-        boolean hasBody = pushPromise.getResponse().getBody() != null;
+        boolean hasBody = pushPromise.response().getBody() != null;
         FramedStream pushedStream =
             stream.getConnection().pushStream(stream.getId(), pushedHeaders, hasBody);
-        writeResponse(pushedStream, pushPromise.getResponse());
+        writeResponse(pushedStream, pushPromise.response());
       }
     }
   }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.java
similarity index 84%
rename from mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java
rename to mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.java
index 649b4ee73a..744127cadd 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.mockwebserver;
+package okhttp3.mockwebserver;
 
-import com.squareup.okhttp.Headers;
+import okhttp3.Headers;
 
 /** An HTTP request initiated by the server. */
 public final class PushPromise {
@@ -31,19 +31,19 @@ public PushPromise(String method, String path, Headers headers, MockResponse res
     this.response = response;
   }
 
-  public String getMethod() {
+  public String method() {
     return method;
   }
 
-  public String getPath() {
+  public String path() {
     return path;
   }
 
-  public Headers getHeaders() {
+  public Headers headers() {
     return headers;
   }
 
-  public MockResponse getResponse() {
+  public MockResponse response() {
     return response;
   }
 }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
similarity index 69%
rename from mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java
rename to mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
index c9c206c17c..4071d4718b 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.java
@@ -13,17 +13,26 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.mockwebserver;
+package okhttp3.mockwebserver;
 
 import java.net.HttpURLConnection;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.logging.Logger;
 
 /**
- * Default dispatcher that processes a script of responses. Populate the script
- * by calling {@link #enqueueResponse(MockResponse)}.
+ * Default dispatcher that processes a script of responses. Populate the script by calling {@link
+ * #enqueueResponse(MockResponse)}.
  */
 public class QueueDispatcher extends Dispatcher {
+  /**
+   * Enqueued on shutdown to release threads waiting on {@link #dispatch}. Note that this response
+   * isn't transmitted because the connection is closed before this response is returned.
+   */
+  private static final MockResponse DEAD_LETTER = new MockResponse()
+      .setStatus("HTTP/1.1 " + 503 + " shutting down");
+
+  private static final Logger logger = Logger.getLogger(QueueDispatcher.class.getName());
   protected final BlockingQueue<MockResponse> responseQueue = new LinkedBlockingQueue<>();
   private MockResponse failFastResponse;
 
@@ -31,7 +40,7 @@
     // To permit interactive/browser testing, ignore requests for favicons.
     final String requestLine = request.getRequestLine();
     if (requestLine != null && requestLine.equals("GET /favicon.ico HTTP/1.1")) {
-      System.out.println("served " + requestLine);
+      logger.info("served " + requestLine);
       return new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_FOUND);
     }
 
@@ -40,7 +49,13 @@
       return failFastResponse;
     }
 
-    return responseQueue.take();
+    MockResponse result = responseQueue.take();
+
+    // If take() returned because we're shutting down, then enqueue another dead letter so that any
+    // other threads waiting on take() will also return.
+    if (result == DEAD_LETTER) responseQueue.add(DEAD_LETTER);
+
+    return result;
   }
 
   @Override public MockResponse peek() {
@@ -54,6 +69,10 @@ public void enqueueResponse(MockResponse response) {
     responseQueue.add(response);
   }
 
+  @Override public void shutdown() {
+    responseQueue.add(DEAD_LETTER);
+  }
+
   public void setFailFast(boolean failFast) {
     MockResponse failFastResponse = failFast
         ? new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_FOUND)
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
similarity index 91%
rename from mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
rename to mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
index 99d4d273b2..aa847001a2 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.mockwebserver;
+package okhttp3.mockwebserver;
 
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.TlsVersion;
 import java.net.Socket;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
+import okhttp3.Headers;
+import okhttp3.TlsVersion;
 import okio.Buffer;
 
 /** An HTTP request that came into the mock web server. */
@@ -82,16 +82,15 @@ public String getHeader(String name) {
   }
 
   /**
-   * Returns the sizes of the chunks of this request's body, or an empty list
-   * if the request's body was empty or unchunked.
+   * Returns the sizes of the chunks of this request's body, or an empty list if the request's body
+   * was empty or unchunked.
    */
   public List<Integer> getChunkSizes() {
     return chunkSizes;
   }
 
   /**
-   * Returns the total size of the body of this POST request (before
-   * truncation).
+   * Returns the total size of the body of this POST request (before truncation).
    */
   public long getBodySize() {
     return bodySize;
@@ -108,9 +107,8 @@ public String getUtf8Body() {
   }
 
   /**
-   * Returns the index of this request on its HTTP connection. Since a single
-   * HTTP connection may serve multiple requests, each request is assigned its
-   * own sequence number.
+   * Returns the index of this request on its HTTP connection. Since a single HTTP connection may
+   * serve multiple requests, each request is assigned its own sequence number.
    */
   public int getSequenceNumber() {
     return sequenceNumber;
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
new file mode 100644
index 0000000000..3142cb0767
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.mockwebserver;
+
+/**
+ * What should be done with the incoming socket.
+ *
+ * <p>Be careful when using values like {@link #DISCONNECT_AT_END}, {@link #SHUTDOWN_INPUT_AT_END}
+ * and {@link #SHUTDOWN_OUTPUT_AT_END} that close a socket after a response, and where there are
+ * follow-up requests. The client is unblocked and free to continue as soon as it has received the
+ * entire response body. If and when the client makes a subsequent request using a pooled socket the
+ * server may not have had time to close the socket. The socket will be closed at an indeterminate
+ * point before or during the second request. It may be closed after client has started sending the
+ * request body. If a request body is not retryable then the client may fail the request, making
+ * client behavior non-deterministic. Add delays in the client to improve the chances that the
+ * server has closed the socket before follow up requests are made.
+ */
+public enum SocketPolicy {
+
+  /**
+   * Keep the socket open after the response. This is the default HTTP/1.1 behavior.
+   */
+  KEEP_OPEN,
+
+  /**
+   * Close the socket after the response. This is the default HTTP/1.0 behavior.
+   *
+   * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
+   */
+  DISCONNECT_AT_END,
+
+  /**
+   * Wrap the socket with SSL at the completion of this request/response pair. Used for CONNECT
+   * messages to tunnel SSL over an HTTP proxy.
+   */
+  UPGRADE_TO_SSL_AT_END,
+
+  /**
+   * Request immediate close of connection without even reading the request. Use to simulate buggy
+   * SSL servers closing connections in response to unrecognized TLS extensions.
+   */
+  DISCONNECT_AT_START,
+
+  /**
+   * Close connection after reading the request but before writing the response. Use this to
+   * simulate late connection pool failures.
+   */
+  DISCONNECT_AFTER_REQUEST,
+
+  /** Close connection after reading half of the request body (if present). */
+  DISCONNECT_DURING_REQUEST_BODY,
+
+  /** Close connection after writing half of the response body (if present). */
+  DISCONNECT_DURING_RESPONSE_BODY,
+
+  /** Don't trust the client during the SSL handshake. */
+  FAIL_HANDSHAKE,
+
+  /**
+   * Shutdown the socket input after sending the response. For testing bad behavior.
+   *
+   * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
+   */
+  SHUTDOWN_INPUT_AT_END,
+
+  /**
+   * Shutdown the socket output after sending the response. For testing bad behavior.
+   *
+   * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
+   */
+  SHUTDOWN_OUTPUT_AT_END,
+
+  /**
+   * Don't respond to the request but keep the socket open. For testing read response header timeout
+   * issue.
+   */
+  NO_RESPONSE
+}
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
similarity index 96%
rename from mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
rename to mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
index 1c8c8206c9..5f189dc608 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.mockwebserver;
+package okhttp3.mockwebserver;
 
 import java.io.IOException;
 import java.net.HttpURLConnection;
@@ -46,7 +46,7 @@ public MockResponse dispatch(RecordedRequest request) throws InterruptedExceptio
     };
     assertEquals(0, requestsMade.size());
     mockWebServer.setDispatcher(dispatcher);
-    final URL url = mockWebServer.getUrl("/");
+    final URL url = mockWebServer.url("/").url();
     final HttpURLConnection conn = (HttpURLConnection) url.openConnection();
     conn.getResponseCode(); // Force the connection to hit the "server".
     // Make sure our dispatcher got the request.
@@ -86,7 +86,7 @@ public MockResponse dispatch(RecordedRequest request) throws InterruptedExceptio
   private Thread buildRequestThread(final String path, final AtomicInteger responseCode) {
     return new Thread(new Runnable() {
       @Override public void run() {
-        final URL url = mockWebServer.getUrl(path);
+        final URL url = mockWebServer.url(path).url();
         final HttpURLConnection conn;
         try {
           conn = (HttpURLConnection) url.openConnection();
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
similarity index 69%
rename from mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
rename to mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index e729393893..fe96642940 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -13,15 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.mockwebserver;
+package okhttp3.mockwebserver;
 
-import com.squareup.okhttp.Headers;
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.io.OutputStream;
 import java.net.ConnectException;
 import java.net.HttpURLConnection;
+import java.net.ProtocolException;
 import java.net.SocketTimeoutException;
 import java.net.URL;
 import java.net.URLConnection;
@@ -30,6 +31,8 @@
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import okhttp3.Headers;
+import okhttp3.internal.Util;
 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
@@ -53,11 +56,34 @@
     assertEquals("HTTP/1.1 200 OK", response.getStatus());
   }
 
+  @Test public void setResponseMockReason() {
+    String[] reasons = {
+        "Mock Response",
+        "Informational",
+        "OK",
+        "Redirection",
+        "Client Error",
+        "Server Error",
+        "Mock Response"
+    };
+    for (int i = 0; i < 600; i++) {
+      MockResponse response = new MockResponse().setResponseCode(i);
+      String expectedReason = reasons[i / 100];
+      assertEquals("HTTP/1.1 " + i + " " + expectedReason, response.getStatus());
+      assertEquals(Arrays.asList("Content-Length: 0"), headersToList(response));
+    }
+  }
+
+  @Test public void setStatusControlsWholeStatusLine() {
+    MockResponse response = new MockResponse().setStatus("HTTP/1.1 202 That'll do pig");
+    assertEquals(Arrays.asList("Content-Length: 0"), headersToList(response));
+    assertEquals("HTTP/1.1 202 That'll do pig", response.getStatus());
+  }
+
   @Test public void setBodyAdjustsHeaders() throws IOException {
     MockResponse response = new MockResponse().setBody("ABC");
     assertEquals(Arrays.asList("Content-Length: 3"), headersToList(response));
     assertEquals("ABC", response.getBody().readUtf8());
-    assertEquals("HTTP/1.1 200 OK", response.getStatus());
   }
 
   @Test public void mockResponseAddHeader() {
@@ -81,7 +107,7 @@
   @Test public void regularResponse() throws Exception {
     server.enqueue(new MockResponse().setBody("hello world"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
     connection.setRequestProperty("Accept-Language", "en-US");
     InputStream in = connection.getInputStream();
@@ -97,11 +123,11 @@
   @Test public void redirect() throws Exception {
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server.getUrl("/new-path"))
+        .addHeader("Location: " + server.url("/new-path"))
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("This is the new location!"));
 
-    URLConnection connection = server.getUrl("/").openConnection();
+    URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
     BufferedReader reader = new BufferedReader(new InputStreamReader(in));
     assertEquals("This is the new location!", reader.readLine());
@@ -113,8 +139,8 @@
   }
 
   /**
-   * Test that MockWebServer blocks for a call to enqueue() if a request
-   * is made before a mock response is ready.
+   * Test that MockWebServer blocks for a call to enqueue() if a request is made before a mock
+   * response is ready.
    */
   @Test public void dispatchBlocksWaitingForEnqueue() throws Exception {
     new Thread() {
@@ -127,7 +153,7 @@
       }
     }.start();
 
-    URLConnection connection = server.getUrl("/").openConnection();
+    URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
     BufferedReader reader = new BufferedReader(new InputStreamReader(in));
     assertEquals("enqueued in the background", reader.readLine());
@@ -139,7 +165,7 @@
         .clearHeaders()
         .addHeader("Transfer-encoding: chunked"));
 
-    URLConnection connection = server.getUrl("/").openConnection();
+    URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
     try {
       in.read();
@@ -155,7 +181,7 @@
         .addHeader("Content-Length: 4"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
-    URLConnection urlConnection = server.getUrl("/").openConnection();
+    URLConnection urlConnection = server.url("/").url().openConnection();
     urlConnection.setReadTimeout(1000);
     InputStream in = urlConnection.getInputStream();
     assertEquals('A', in.read());
@@ -167,7 +193,7 @@
     } catch (SocketTimeoutException expected) {
     }
 
-    URLConnection urlConnection2 = server.getUrl("/").openConnection();
+    URLConnection urlConnection2 = server.url("/").url().openConnection();
     InputStream in2 = urlConnection2.getInputStream();
     assertEquals('D', in2.read());
     assertEquals('E', in2.read());
@@ -183,22 +209,22 @@
     server.enqueue(new MockResponse()); // The jdk's HttpUrlConnection is a bastard.
     server.enqueue(new MockResponse());
     try {
-      server.getUrl("/a").openConnection().getInputStream();
+      server.url("/a").url().openConnection().getInputStream();
     } catch (IOException expected) {
     }
-    server.getUrl("/b").openConnection().getInputStream(); // Should succeed.
+    server.url("/b").url().openConnection().getInputStream(); // Should succeed.
   }
 
   /**
-   * Throttle the request body by sleeping 500ms after every 3 bytes. With a
-   * 6-byte request, this should yield one sleep for a total delay of 500ms.
+   * Throttle the request body by sleeping 500ms after every 3 bytes. With a 6-byte request, this
+   * should yield one sleep for a total delay of 500ms.
    */
   @Test public void throttleRequest() throws Exception {
     server.enqueue(new MockResponse()
         .throttleBody(3, 500, TimeUnit.MILLISECONDS));
 
     long startNanos = System.nanoTime();
-    URLConnection connection = server.getUrl("/").openConnection();
+    URLConnection connection = server.url("/").url().openConnection();
     connection.setDoOutput(true);
     connection.getOutputStream().write("ABCDEF".getBytes("UTF-8"));
     InputStream in = connection.getInputStream();
@@ -206,13 +232,13 @@
     long elapsedNanos = System.nanoTime() - startNanos;
     long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
 
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
   }
 
   /**
-   * Throttle the response body by sleeping 500ms after every 3 bytes. With a
-   * 6-byte response, this should yield one sleep for a total delay of 500ms.
+   * Throttle the response body by sleeping 500ms after every 3 bytes. With a 6-byte response, this
+   * should yield one sleep for a total delay of 500ms.
    */
   @Test public void throttleResponse() throws Exception {
     server.enqueue(new MockResponse()
@@ -220,7 +246,7 @@
         .throttleBody(3, 500, TimeUnit.MILLISECONDS));
 
     long startNanos = System.nanoTime();
-    URLConnection connection = server.getUrl("/").openConnection();
+    URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
     assertEquals('A', in.read());
     assertEquals('B', in.read());
@@ -232,8 +258,8 @@
     long elapsedNanos = System.nanoTime() - startNanos;
     long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
 
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
   }
 
   /** Delay the response body by sleeping 1s. */
@@ -243,26 +269,56 @@
         .setBodyDelay(1, SECONDS));
 
     long startNanos = System.nanoTime();
-    URLConnection connection = server.getUrl("/").openConnection();
+    URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
     assertEquals('A', in.read());
     long elapsedNanos = System.nanoTime() - startNanos;
     long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 1000);
+    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 1000);
 
     in.close();
   }
 
-  @Test public void disconnectHalfway() throws IOException {
+  @Test public void disconnectRequestHalfway() throws IOException {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
+
+    HttpURLConnection connection = (HttpURLConnection) server.url("/").url().openConnection();
+    connection.setRequestMethod("POST");
+    connection.setDoOutput(true);
+    connection.setFixedLengthStreamingMode(1024 * 1024 * 1024); // 1 GB
+    connection.connect();
+    OutputStream out = connection.getOutputStream();
+
+    byte[] data = new byte[1024 * 1024];
+    int i;
+    for (i = 0; i < 1024; i++) {
+      try {
+        out.write(data);
+        out.flush();
+      } catch (IOException e) {
+        break;
+      }
+    }
+    assertEquals(512f, i, 10f); // Halfway +/- 1%
+  }
+
+  @Test public void disconnectResponseHalfway() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("ab")
         .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
 
-    URLConnection connection = server.getUrl("/").openConnection();
-    assertEquals(2, connection.getHeaderFieldLong("Content-Length", -1));
+    URLConnection connection = server.url("/").url().openConnection();
+    assertEquals(2, connection.getContentLength());
     InputStream in = connection.getInputStream();
     assertEquals('a', in.read());
-    assertEquals(-1, in.read());
+    try {
+      int byteRead = in.read();
+      // OpenJDK behavior: end of stream.
+      assertEquals(-1, byteRead);
+    } catch (ProtocolException e) {
+      // On Android, HttpURLConnection is implemented by OkHttp v2. OkHttp
+      // treats an incomplete response body as a ProtocolException.
+    }
   }
 
   private List<String> headersToList(MockResponse response) {
@@ -294,7 +350,7 @@
     assertTrue(server.getPort() > 0);
   }
 
-  @Test public void hostNameImplicitlyStarts() throws IOException {
+  @Test public void hostnameImplicitlyStarts() throws IOException {
     assertNotNull(server.getHostName());
   }
 
@@ -313,7 +369,7 @@
     Statement statement = server.apply(new Statement() {
       @Override public void evaluate() throws Throwable {
         called.set(true);
-        server.getUrl("/").openConnection().connect();
+        server.url("/").url().openConnection().connect();
       }
     }, Description.EMPTY);
 
@@ -321,9 +377,23 @@
 
     assertTrue(called.get());
     try {
-      server.getUrl("/").openConnection().connect();
+      server.url("/").url().openConnection().connect();
       fail();
     } catch (ConnectException expected) {
     }
   }
+
+  @Test public void shutdownWhileBlockedDispatching() throws Exception {
+    // Enqueue a request that'll cause MockWebServer to hang on QueueDispatcher.dispatch().
+    HttpURLConnection connection = (HttpURLConnection) server.url("/").url().openConnection();
+    connection.setReadTimeout(500);
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+
+    // Shutting down the server should unblock the dispatcher.
+    server.shutdown();
+  }
 }
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index 70cab20dda..63b1cc8c8b 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.5.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
@@ -14,12 +14,12 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-testing-support</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
@@ -62,7 +62,7 @@
           </descriptorRefs>
           <archive>
             <manifest>
-              <mainClass>com.squareup.okhttp.curl.Main</mainClass>
+              <mainClass>okhttp3.curl.Main</mainClass>
             </manifest>
           </archive>
         </configuration>
diff --git a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java b/okcurl/src/main/java/okhttp3/curl/Main.java
similarity index 74%
rename from okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
rename to okcurl/src/main/java/okhttp3/curl/Main.java
index dbc51f379a..15e4f030d1 100644
--- a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
+++ b/okcurl/src/main/java/okhttp3/curl/Main.java
@@ -13,25 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.curl;
+package okhttp3.curl;
 
 import com.google.common.base.Joiner;
-import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.http.StatusLine;
-import com.squareup.okhttp.internal.framed.Http2;
-
-import io.airlift.command.Arguments;
-import io.airlift.command.Command;
-import io.airlift.command.HelpOption;
-import io.airlift.command.Option;
-import io.airlift.command.SingleCommand;
+import io.airlift.airline.Arguments;
+import io.airlift.airline.Command;
+import io.airlift.airline.HelpOption;
+import io.airlift.airline.Option;
+import io.airlift.airline.SingleCommand;
 import java.io.IOException;
 import java.io.InputStream;
 import java.security.cert.CertificateException;
@@ -49,6 +38,16 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okhttp3.Headers;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.internal.Util;
+import okhttp3.internal.framed.Http2;
+import okhttp3.internal.http.StatusLine;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
@@ -59,6 +58,7 @@
 public class Main extends HelpOption implements Runnable {
   static final String NAME = "okcurl";
   static final int DEFAULT_TIMEOUT = -1;
+  private static Logger frameLogger;
 
   static Main fromArgs(String... args) {
     return SingleCommand.singleCommand(Main.class).parse(args);
@@ -84,16 +84,16 @@ private static String protocols() {
     return Joiner.on(", ").join(Protocol.values());
   }
 
-  @Option(name = { "-X", "--request" }, description = "Specify request command to use")
+  @Option(name = {"-X", "--request"}, description = "Specify request command to use")
   public String method;
 
-  @Option(name = { "-d", "--data" }, description = "HTTP POST data")
+  @Option(name = {"-d", "--data"}, description = "HTTP POST data")
   public String data;
 
-  @Option(name = { "-H", "--header" }, description = "Custom header to pass to server")
+  @Option(name = {"-H", "--header"}, description = "Custom header to pass to server")
   public List<String> headers;
 
-  @Option(name = { "-A", "--user-agent" }, description = "User-Agent to send to server")
+  @Option(name = {"-A", "--user-agent"}, description = "User-Agent to send to server")
   public String userAgent = NAME + "/" + versionString();
 
   @Option(name = "--connect-timeout", description = "Maximum time allowed for connection (seconds)")
@@ -102,23 +102,23 @@ private static String protocols() {
   @Option(name = "--read-timeout", description = "Maximum time allowed for reading data (seconds)")
   public int readTimeout = DEFAULT_TIMEOUT;
 
-  @Option(name = { "-L", "--location" }, description = "Follow redirects")
+  @Option(name = {"-L", "--location"}, description = "Follow redirects")
   public boolean followRedirects;
 
-  @Option(name = { "-k", "--insecure" },
+  @Option(name = {"-k", "--insecure"},
       description = "Allow connections to SSL sites without certs")
   public boolean allowInsecure;
 
-  @Option(name = { "-i", "--include" }, description = "Include protocol headers in the output")
+  @Option(name = {"-i", "--include"}, description = "Include protocol headers in the output")
   public boolean showHeaders;
 
   @Option(name = "--frames", description = "Log HTTP/2 frames to STDERR")
   public boolean showHttp2Frames;
 
-  @Option(name = { "-e", "--referer" }, description = "Referer URL")
+  @Option(name = {"-e", "--referer"}, description = "Referer URL")
   public String referer;
 
-  @Option(name = { "-V", "--version" }, description = "Show version number and quit")
+  @Option(name = {"-V", "--version"}, description = "Show version number and quit")
   public boolean version;
 
   @Arguments(title = "url", description = "Remote resource URL")
@@ -170,21 +170,19 @@ private static String protocols() {
   }
 
   private OkHttpClient createClient() {
-    OkHttpClient client = new OkHttpClient();
-    client.setFollowSslRedirects(followRedirects);
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    builder.followSslRedirects(followRedirects);
     if (connectTimeout != DEFAULT_TIMEOUT) {
-      client.setConnectTimeout(connectTimeout, SECONDS);
+      builder.connectTimeout(connectTimeout, SECONDS);
     }
     if (readTimeout != DEFAULT_TIMEOUT) {
-      client.setReadTimeout(readTimeout, SECONDS);
+      builder.readTimeout(readTimeout, SECONDS);
     }
     if (allowInsecure) {
-      client.setSslSocketFactory(createInsecureSslSocketFactory());
-      client.setHostnameVerifier(createInsecureHostnameVerifier());
+      builder.sslSocketFactory(createInsecureSslSocketFactory());
+      builder.hostnameVerifier(createInsecureHostnameVerifier());
     }
-    // If we don't set this reference, there's no way to clean shutdown persistent connections.
-    client.setConnectionPool(ConnectionPool.getDefault());
-    return client;
+    return builder.build();
   }
 
   private String getRequestMethod() {
@@ -203,7 +201,7 @@ private RequestBody getRequestBody() {
     }
     String bodyData = data;
 
-    String mimeType = "application/x-form-urlencoded";
+    String mimeType = "application/x-www-form-urlencoded";
     if (headers != null) {
       for (String header : headers) {
         String[] parts = header.split(":", -1);
@@ -239,7 +237,7 @@ Request createRequest() {
   }
 
   private void close() {
-    client.getConnectionPool().evictAll(); // Close any persistent connections.
+    client.connectionPool().evictAll(); // Close any persistent connections.
   }
 
   private static SSLSocketFactory createInsecureSslSocketFactory() {
@@ -255,10 +253,10 @@ private static SSLSocketFactory createInsecureSslSocketFactory() {
         }
 
         @Override public X509Certificate[] getAcceptedIssuers() {
-          return null;
+          return new X509Certificate[0];
         }
       };
-      context.init(null, new TrustManager[] { permissive }, null);
+      context.init(null, new TrustManager[] {permissive}, null);
       return context.getSocketFactory();
     } catch (Exception e) {
       throw new AssertionError(e);
@@ -274,15 +272,15 @@ private static HostnameVerifier createInsecureHostnameVerifier() {
   }
 
   private static void enableHttp2FrameLogging() {
-    Logger logger = Logger.getLogger(Http2.class.getName() + "$FrameLogger");
-    logger.setLevel(Level.FINE);
+    frameLogger = Logger.getLogger(Http2.class.getName() + "$FrameLogger");
+    frameLogger.setLevel(Level.FINE);
     ConsoleHandler handler = new ConsoleHandler();
     handler.setLevel(Level.FINE);
     handler.setFormatter(new SimpleFormatter() {
       @Override public String format(LogRecord record) {
-        return String.format("%s%n", record.getMessage());
+        return Util.format("%s%n", record.getMessage());
       }
     });
-    logger.addHandler(handler);
+    frameLogger.addHandler(handler);
   }
 }
diff --git a/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java b/okcurl/src/test/java/okhttp3/curl/MainTest.java
similarity index 79%
rename from okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
rename to okcurl/src/test/java/okhttp3/curl/MainTest.java
index 0e2e3ae1fe..12fe6d5ec4 100644
--- a/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
+++ b/okcurl/src/test/java/okhttp3/curl/MainTest.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.curl;
+package okhttp3.curl;
 
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
+import okhttp3.Request;
+import okhttp3.RequestBody;
 import okio.Buffer;
 import org.junit.Test;
 
-import static com.squareup.okhttp.curl.Main.fromArgs;
+import static okhttp3.curl.Main.fromArgs;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 
@@ -29,14 +29,14 @@
   @Test public void simple() {
     Request request = fromArgs("http://example.com").createRequest();
     assertEquals("GET", request.method());
-    assertEquals("http://example.com/", request.urlString());
+    assertEquals("http://example.com/", request.url().toString());
     assertNull(request.body());
   }
 
   @Test public void put() throws IOException {
     Request request = fromArgs("-X", "PUT", "-d", "foo", "http://example.com").createRequest();
     assertEquals("PUT", request.method());
-    assertEquals("http://example.com/", request.urlString());
+    assertEquals("http://example.com/", request.url().toString());
     assertEquals(3, request.body().contentLength());
   }
 
@@ -44,8 +44,8 @@
     Request request = fromArgs("-d", "foo", "http://example.com").createRequest();
     RequestBody body = request.body();
     assertEquals("POST", request.method());
-    assertEquals("http://example.com/", request.urlString());
-    assertEquals("application/x-form-urlencoded; charset=utf-8", body.contentType().toString());
+    assertEquals("http://example.com/", request.url().toString());
+    assertEquals("application/x-www-form-urlencoded; charset=utf-8", body.contentType().toString());
     assertEquals("foo", bodyAsString(body));
   }
 
@@ -53,8 +53,8 @@
     Request request = fromArgs("-d", "foo", "-X", "PUT", "http://example.com").createRequest();
     RequestBody body = request.body();
     assertEquals("PUT", request.method());
-    assertEquals("http://example.com/", request.urlString());
-    assertEquals("application/x-form-urlencoded; charset=utf-8", body.contentType().toString());
+    assertEquals("http://example.com/", request.url().toString());
+    assertEquals("application/x-www-form-urlencoded; charset=utf-8", body.contentType().toString());
     assertEquals("foo", bodyAsString(body));
   }
 
@@ -63,7 +63,7 @@
         "http://example.com").createRequest();
     RequestBody body = request.body();
     assertEquals("POST", request.method());
-    assertEquals("http://example.com/", request.urlString());
+    assertEquals("http://example.com/", request.url().toString());
     assertEquals("application/json; charset=utf-8", body.contentType().toString());
     assertEquals("foo", bodyAsString(body));
   }
@@ -71,7 +71,7 @@
   @Test public void referer() {
     Request request = fromArgs("-e", "foo", "http://example.com").createRequest();
     assertEquals("GET", request.method());
-    assertEquals("http://example.com/", request.urlString());
+    assertEquals("http://example.com/", request.url().toString());
     assertEquals("foo", request.header("Referer"));
     assertNull(request.body());
   }
@@ -79,7 +79,7 @@
   @Test public void userAgent() {
     Request request = fromArgs("-A", "foo", "http://example.com").createRequest();
     assertEquals("GET", request.method());
-    assertEquals("http://example.com/", request.urlString());
+    assertEquals("http://example.com/", request.url().toString());
     assertEquals("foo", request.header("User-Agent"));
     assertNull(request.body());
   }
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index 5453b955d7..9f6f647bc6 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -4,35 +4,37 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.5.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
   <name>OkHttp Android Platform Support</name>
-  <description>Classes to support the Android platform's use of OkHttp (not required for most developers).</description>
+  <description>Classes to support the Android platform's use of OkHttp (not required for most
+    developers).
+  </description>
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-testing-support</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-urlconnection</artifactId>
       <version>${project.version}</version>
     </dependency>
- 
+
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>mockwebserver</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
@@ -45,7 +47,7 @@
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
-          <excludePackageNames>com.squareup.okhttp.internal.*</excludePackageNames>
+          <excludePackageNames>okhttp3.internal.*</excludePackageNames>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
           </links>
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidInternal.java b/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
similarity index 83%
rename from okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidInternal.java
rename to okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
index eeaf55473f..de5788539a 100644
--- a/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidInternal.java
+++ b/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
@@ -13,11 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.huc.CacheAdapter;
+package okhttp3;
 
 import java.net.ResponseCache;
+import okhttp3.internal.huc.CacheAdapter;
 
 /**
  * Back doors to enable the use of OkHttp within the Android platform libraries. OkHttp is used to
@@ -31,15 +30,16 @@ private AndroidInternal() {
 
   /** Sets the response cache to be used to read and write cached responses. */
   public static void setResponseCache(OkUrlFactory okUrlFactory, ResponseCache responseCache) {
-    OkHttpClient client = okUrlFactory.client();
+    OkHttpClient.Builder builder = okUrlFactory.client().newBuilder();
     if (responseCache instanceof OkCacheContainer) {
       // Avoid adding layers of wrappers. Rather than wrap the ResponseCache in yet another layer to
       // make the ResponseCache look like an InternalCache, we can unwrap the Cache instead.
       // This means that Cache stats will be correctly updated.
       OkCacheContainer okCacheContainer = (OkCacheContainer) responseCache;
-      client.setCache(okCacheContainer.getCache());
+      builder.cache(okCacheContainer.getCache());
     } else {
-      client.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
+      builder.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
     }
+    okUrlFactory.setClient(builder.build());
   }
 }
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidShimResponseCache.java b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
similarity index 76%
rename from okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidShimResponseCache.java
rename to okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
index 4986c38a4b..b0bb9fcf73 100644
--- a/okhttp-android-support/src/main/java/com/squareup/okhttp/AndroidShimResponseCache.java
+++ b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
@@ -13,9 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.huc.JavaApiConverter;
+package okhttp3;
 
 import java.io.File;
 import java.io.IOException;
@@ -26,6 +24,7 @@
 import java.net.URLConnection;
 import java.util.List;
 import java.util.Map;
+import okhttp3.internal.huc.JavaApiConverter;
 
 /**
  * A class provided for use by Android so that it can continue supporting a {@link ResponseCache}
@@ -46,8 +45,8 @@ public static AndroidShimResponseCache create(File directory, long maxSize) thro
 
   public boolean isEquivalent(File directory, long maxSize) {
     Cache installedCache = getCache();
-    return (installedCache.getDirectory().equals(directory)
-        && installedCache.getMaxSize() == maxSize
+    return (installedCache.directory().equals(directory)
+        && installedCache.maxSize() == maxSize
         && !installedCache.isClosed());
   }
 
@@ -71,7 +70,7 @@ public Cache getCache() {
       // The URLConnection is not cacheable or could not be converted. Stop.
       return null;
     }
-    com.squareup.okhttp.internal.http.CacheRequest okCacheRequest =
+    okhttp3.internal.http.CacheRequest okCacheRequest =
         delegate.internalCache.put(okResponse);
     if (okCacheRequest == null) {
       return null;
@@ -80,60 +79,55 @@ public Cache getCache() {
   }
 
   /**
-   * Returns the number of bytes currently being used to store the values in
-   * this cache. This may be greater than the {@link #maxSize} if a background
-   * deletion is pending.
+   * Returns the number of bytes currently being used to store the values in this cache. This may be
+   * greater than the {@link #maxSize} if a background deletion is pending.
    */
   public long size() throws IOException {
-    return delegate.getSize();
+    return delegate.size();
   }
 
   /**
-   * Returns the maximum number of bytes that this cache should use to store
-   * its data.
+   * Returns the maximum number of bytes that this cache should use to store its data.
    */
   public long maxSize() {
-    return delegate.getMaxSize();
+    return delegate.maxSize();
   }
 
   /**
-   * Force buffered operations to the filesystem. This ensures that responses
-   * written to the cache will be available the next time the cache is opened,
-   * even if this process is killed.
+   * Force buffered operations to the filesystem. This ensures that responses written to the cache
+   * will be available the next time the cache is opened, even if this process is killed.
    */
   public void flush() throws IOException {
     delegate.flush();
   }
 
   /**
-   * Returns the number of HTTP requests that required the network to either
-   * supply a response or validate a locally cached response.
+   * Returns the number of HTTP requests that required the network to either supply a response or
+   * validate a locally cached response.
    */
   public int getNetworkCount() {
-    return delegate.getNetworkCount();
+    return delegate.networkCount();
   }
 
   /**
-   * Returns the number of HTTP requests whose response was provided by the
-   * cache. This may include conditional {@code GET} requests that were
-   * validated over the network.
+   * Returns the number of HTTP requests whose response was provided by the cache. This may include
+   * conditional {@code GET} requests that were validated over the network.
    */
   public int getHitCount() {
-    return delegate.getHitCount();
+    return delegate.hitCount();
   }
 
   /**
-   * Returns the total number of HTTP requests that were made. This includes
-   * both client requests and requests that were made on the client's behalf
-   * to handle a redirects and retries.
+   * Returns the total number of HTTP requests that were made. This includes both client requests
+   * and requests that were made on the client's behalf to handle a redirects and retries.
    */
   public int getRequestCount() {
-    return delegate.getRequestCount();
+    return delegate.requestCount();
   }
 
   /**
-   * Uninstalls the cache and releases any active resources. Stored contents
-   * will remain on the filesystem.
+   * Uninstalls the cache and releases any active resources. Stored contents will remain on the
+   * filesystem.
    */
   public void close() throws IOException {
     delegate.close();
@@ -145,5 +139,4 @@ public void close() throws IOException {
   public void delete() throws IOException {
     delegate.delete();
   }
-
 }
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/OkCacheContainer.java b/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
similarity index 90%
rename from okhttp-android-support/src/main/java/com/squareup/okhttp/OkCacheContainer.java
rename to okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
index d7b62e3ae1..d52cb0133d 100644
--- a/okhttp-android-support/src/main/java/com/squareup/okhttp/OkCacheContainer.java
+++ b/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 /**
- * An interface that allows OkHttp to detect that a {@link java.net.ResponseCache} contains a
- * {@link Cache}.
+ * An interface that allows OkHttp to detect that a {@link java.net.ResponseCache} contains a {@link
+ * Cache}.
  */
 public interface OkCacheContainer {
   Cache getCache();
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
similarity index 87%
rename from okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
rename to okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
index e13c575391..8e02239dea 100644
--- a/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
@@ -13,13 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.huc;
+package okhttp3.internal.huc;
 
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.InternalCache;
-import com.squareup.okhttp.internal.http.CacheRequest;
-import com.squareup.okhttp.internal.http.CacheStrategy;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.net.CacheResponse;
@@ -28,6 +23,11 @@
 import java.net.URI;
 import java.util.List;
 import java.util.Map;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.http.CacheRequest;
+import okhttp3.internal.http.CacheStrategy;
 import okio.Okio;
 import okio.Sink;
 
@@ -52,7 +52,7 @@ public ResponseCache getDelegate() {
   }
 
   @Override public CacheRequest put(Response response) throws IOException {
-    URI uri = response.request().uri();
+    URI uri = response.request().url().uri();
     HttpURLConnection connection = JavaApiConverter.createJavaUrlConnectionForCachePut(response);
     final java.net.CacheRequest request = delegate.put(uri, connection);
     if (request == null) {
@@ -95,11 +95,11 @@ public ResponseCache getDelegate() {
   }
 
   /**
-   * Returns the {@link CacheResponse} from the delegate by converting the
-   * OkHttp {@link Request} into the arguments required by the {@link ResponseCache}.
+   * Returns the {@link CacheResponse} from the delegate by converting the OkHttp {@link Request}
+   * into the arguments required by the {@link ResponseCache}.
    */
   private CacheResponse getJavaCachedResponse(Request request) throws IOException {
     Map<String, List<String>> headers = JavaApiConverter.extractJavaHeaders(request);
-    return delegate.get(request.uri(), request.method(), headers);
+    return delegate.get(request.url().uri(), request.method(), headers);
   }
 }
diff --git a/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
similarity index 82%
rename from okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
rename to okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
index 89570cc874..2465372a55 100644
--- a/okhttp-android-support/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
@@ -13,21 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.huc;
-
-import com.squareup.okhttp.Handshake;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.CacheRequest;
-import com.squareup.okhttp.internal.http.HttpMethod;
-import com.squareup.okhttp.internal.http.OkHeaders;
-import com.squareup.okhttp.internal.http.StatusLine;
+package okhttp3.internal.huc;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -47,6 +34,21 @@
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.CipherSuite;
+import okhttp3.Handshake;
+import okhttp3.Headers;
+import okhttp3.MediaType;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.JavaNetHeaders;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.CacheRequest;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.http.StatusLine;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
@@ -61,9 +63,9 @@ private JavaApiConverter() {
   }
 
   /**
-   * Creates an OkHttp {@link Response} using the supplied {@link URI} and {@link URLConnection}
-   * to supply the data. The URLConnection is assumed to already be connected. If this method
-   * returns {@code null} the response is uncacheable.
+   * Creates an OkHttp {@link Response} using the supplied {@link URI} and {@link URLConnection} to
+   * supply the data. The URLConnection is assumed to already be connected. If this method returns
+   * {@code null} the response is uncacheable.
    */
   public static Response createOkResponseForCachePut(URI uri, URLConnection urlConnection)
       throws IOException {
@@ -104,7 +106,7 @@ public static Response createOkResponseForCachePut(URI uri, URLConnection urlCon
     okResponseBuilder.networkResponse(networkResponse);
 
     // Response headers
-    Headers okHeaders = extractOkResponseHeaders(httpUrlConnection);
+    Headers okHeaders = extractOkResponseHeaders(httpUrlConnection, okResponseBuilder);
     okResponseBuilder.headers(okHeaders);
 
     // Response body
@@ -124,9 +126,10 @@ public static Response createOkResponseForCachePut(URI uri, URLConnection urlCon
 
       Certificate[] localCertificates = httpsUrlConnection.getLocalCertificates();
 
-      Handshake handshake = Handshake.get(
-          httpsUrlConnection.getCipherSuite(), nullSafeImmutableList(peerCertificates),
-          nullSafeImmutableList(localCertificates));
+      String cipherSuiteString = httpsUrlConnection.getCipherSuite();
+      CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
+      Handshake handshake = Handshake.get(null, cipherSuite,
+          nullSafeImmutableList(peerCertificates), nullSafeImmutableList(localCertificates));
       okResponseBuilder.handshake(handshake);
     }
 
@@ -210,7 +213,7 @@ static Response createOkResponseForCacheGet(Request request, CacheResponse javaR
     }
 
     Request cacheRequest = new Request.Builder()
-        .url(request.httpUrl())
+        .url(request.url())
         .method(request.method(), null)
         .headers(varyHeaders)
         .build();
@@ -227,7 +230,7 @@ static Response createOkResponseForCacheGet(Request request, CacheResponse javaR
     okResponseBuilder.message(statusLine.message);
 
     // Response headers
-    Headers okHeaders = extractOkHeaders(javaResponse);
+    Headers okHeaders = extractOkHeaders(javaResponse, okResponseBuilder);
     okResponseBuilder.headers(okHeaders);
 
     // Response body
@@ -249,8 +252,10 @@ static Response createOkResponseForCacheGet(Request request, CacheResponse javaR
       if (localCertificates == null) {
         localCertificates = Collections.emptyList();
       }
-      Handshake handshake = Handshake.get(
-          javaSecureCacheResponse.getCipherSuite(), peerCertificates, localCertificates);
+
+      String cipherSuiteString = javaSecureCacheResponse.getCipherSuite();
+      CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
+      Handshake handshake = Handshake.get(null, cipherSuite, peerCertificates, localCertificates);
       okResponseBuilder.handshake(handshake);
     }
 
@@ -260,9 +265,9 @@ static Response createOkResponseForCacheGet(Request request, CacheResponse javaR
   /**
    * Creates an OkHttp {@link Request} from the supplied information.
    *
-   * <p>This method allows a {@code null} value for {@code requestHeaders} for situations
-   * where a connection is already connected and access to the headers has been lost.
-   * See {@link java.net.HttpURLConnection#getRequestProperties()} for details.
+   * <p>This method allows a {@code null} value for {@code requestHeaders} for situations where a
+   * connection is already connected and access to the headers has been lost. See {@link
+   * java.net.HttpURLConnection#getRequestProperties()} for details.
    */
   public static Request createOkRequest(
       URI uri, String requestMethod, Map<String, List<String>> requestHeaders) {
@@ -276,25 +281,25 @@ public static Request createOkRequest(
         .method(requestMethod, placeholderBody);
 
     if (requestHeaders != null) {
-      Headers headers = extractOkHeaders(requestHeaders);
+      Headers headers = extractOkHeaders(requestHeaders, null);
       builder.headers(headers);
     }
     return builder.build();
   }
 
   /**
-   * Creates a {@link java.net.CacheResponse} of the correct (sub)type using information
-   * gathered from the supplied {@link Response}.
+   * Creates a {@link java.net.CacheResponse} of the correct (sub)type using information gathered
+   * from the supplied {@link Response}.
    */
   public static CacheResponse createJavaCacheResponse(final Response response) {
-    final Headers headers = response.headers();
+    final Headers headers = withSyntheticHeaders(response);
     final ResponseBody body = response.body();
     if (response.request().isHttps()) {
       final Handshake handshake = response.handshake();
       return new SecureCacheResponse() {
         @Override
         public String getCipherSuite() {
-          return handshake != null ? handshake.cipherSuite() : null;
+          return handshake != null ? handshake.cipherSuite().javaName() : null;
         }
 
         @Override
@@ -328,7 +333,7 @@ public Principal getLocalPrincipal() {
         @Override
         public Map<String, List<String>> getHeaders() throws IOException {
           // Java requires that the entry with a null key be the status line.
-          return OkHeaders.toMultimap(headers, StatusLine.get(response).toString());
+          return JavaNetHeaders.toMultimap(headers, StatusLine.get(response).toString());
         }
 
         @Override
@@ -342,7 +347,7 @@ public InputStream getBody() throws IOException {
         @Override
         public Map<String, List<String>> getHeaders() throws IOException {
           // Java requires that the entry with a null key be the status line.
-          return OkHeaders.toMultimap(headers, StatusLine.get(response).toString());
+          return JavaNetHeaders.toMultimap(headers, StatusLine.get(response).toString());
         }
 
         @Override
@@ -360,6 +365,7 @@ public InputStream getBody() throws IOException {
       public void abort() {
         okCacheRequest.abort();
       }
+
       @Override
       public OutputStream getBody() throws IOException {
         Sink body = okCacheRequest.body();
@@ -376,6 +382,10 @@ public OutputStream getBody() throws IOException {
    * {@link Response}.
    */
   static HttpURLConnection createJavaUrlConnectionForCachePut(Response okResponse) {
+    okResponse = okResponse.newBuilder()
+        .body(null)
+        .headers(withSyntheticHeaders(okResponse))
+        .build();
     Request request = okResponse.request();
     // Create an object of the correct class in case the ResponseCache uses instanceof.
     if (request.isHttps()) {
@@ -385,37 +395,48 @@ static HttpURLConnection createJavaUrlConnectionForCachePut(Response okResponse)
     }
   }
 
+  private static Headers withSyntheticHeaders(Response okResponse) {
+    return okResponse.headers().newBuilder()
+        .add(OkHeaders.SENT_MILLIS, Long.toString(okResponse.sentRequestAtMillis()))
+        .add(OkHeaders.RECEIVED_MILLIS, Long.toString(okResponse.receivedResponseAtMillis()))
+        .build();
+  }
+
   /**
-   * Extracts an immutable request header map from the supplied {@link com.squareup.okhttp.Headers}.
+   * Extracts an immutable request header map from the supplied {@link Headers}.
    */
   static Map<String, List<String>> extractJavaHeaders(Request request) {
-    return OkHeaders.toMultimap(request.headers(), null);
+    return JavaNetHeaders.toMultimap(request.headers(), null);
   }
 
   /**
    * Extracts OkHttp headers from the supplied {@link java.net.CacheResponse}. Only real headers are
    * extracted. See {@link #extractStatusLine(java.net.CacheResponse)}.
    */
-  private static Headers extractOkHeaders(CacheResponse javaResponse) throws IOException {
+  private static Headers extractOkHeaders(
+      CacheResponse javaResponse, Response.Builder okResponseBuilder) throws IOException {
     Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
-    return extractOkHeaders(javaResponseHeaders);
+    return extractOkHeaders(javaResponseHeaders, okResponseBuilder);
   }
 
   /**
    * Extracts OkHttp headers from the supplied {@link java.net.HttpURLConnection}. Only real headers
    * are extracted. See {@link #extractStatusLine(java.net.HttpURLConnection)}.
    */
-  private static Headers extractOkResponseHeaders(HttpURLConnection httpUrlConnection) {
+  private static Headers extractOkResponseHeaders(
+      HttpURLConnection httpUrlConnection, Response.Builder okResponseBuilder) {
     Map<String, List<String>> javaResponseHeaders = httpUrlConnection.getHeaderFields();
-    return extractOkHeaders(javaResponseHeaders);
+    return extractOkHeaders(javaResponseHeaders, okResponseBuilder);
   }
 
   /**
-   * Extracts OkHttp headers from the supplied {@link Map}. Only real headers are
-   * extracted. Any entry (one with a {@code null} key) is discarded.
+   * Extracts OkHttp headers from the supplied {@link Map}. Only real headers are extracted. Any
+   * entry (one with a {@code null} key) is discarded. Special internal headers used to track cache
+   * metadata are omitted from the result and added to {@code okResponseBuilder} instead.
    */
   // @VisibleForTesting
-  static Headers extractOkHeaders(Map<String, List<String>> javaHeaders) {
+  static Headers extractOkHeaders(
+      Map<String, List<String>> javaHeaders, Response.Builder okResponseBuilder) {
     Headers.Builder okHeadersBuilder = new Headers.Builder();
     for (Map.Entry<String, List<String>> javaHeader : javaHeaders.entrySet()) {
       String name = javaHeader.getKey();
@@ -426,6 +447,16 @@ static Headers extractOkHeaders(Map<String, List<String>> javaHeaders) {
         // explicitly ignored because Headers.Builder does not support null keys.
         continue;
       }
+      if (okResponseBuilder != null && javaHeader.getValue().size() == 1) {
+        if (name.equals(OkHeaders.SENT_MILLIS)) {
+          okResponseBuilder.sentRequestAtMillis(Long.valueOf(javaHeader.getValue().get(0)));
+          continue;
+        }
+        if (name.equals(OkHeaders.RECEIVED_MILLIS)) {
+          okResponseBuilder.receivedResponseAtMillis(Long.valueOf(javaHeader.getValue().get(0)));
+          continue;
+        }
+      }
       for (String value : javaHeader.getValue()) {
         Internal.instance.addLenient(okHeadersBuilder, name, value);
       }
@@ -434,9 +465,9 @@ static Headers extractOkHeaders(Map<String, List<String>> javaHeaders) {
   }
 
   /**
-   * Extracts the status line from the supplied Java API {@link java.net.HttpURLConnection}.
-   * As per the spec, the status line is held as the header with the null key. Returns {@code null}
-   * if there is no status line.
+   * Extracts the status line from the supplied Java API {@link java.net.HttpURLConnection}. As per
+   * the spec, the status line is held as the header with the null key. Returns {@code null} if
+   * there is no status line.
    */
   private static String extractStatusLine(HttpURLConnection httpUrlConnection) {
     // Java specifies that this will be be response header with a null key.
@@ -444,9 +475,9 @@ private static String extractStatusLine(HttpURLConnection httpUrlConnection) {
   }
 
   /**
-   * Extracts the status line from the supplied Java API {@link java.net.CacheResponse}.
-   * As per the spec, the status line is held as the header with the null key. Throws a
-   * {@link ProtocolException} if there is no status line.
+   * Extracts the status line from the supplied Java API {@link java.net.CacheResponse}. As per the
+   * spec, the status line is held as the header with the null key. Throws a {@link
+   * ProtocolException} if there is no status line.
    */
   private static String extractStatusLine(CacheResponse javaResponse) throws IOException {
     Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
@@ -461,7 +492,7 @@ static String extractStatusLine(Map<String, List<String>> javaResponseHeaders)
       // The status line is missing. This suggests a badly behaving cache.
       throw new ProtocolException(
           "CacheResponse is missing a \'null\' header containing the status line. Headers="
-          + javaResponseHeaders);
+              + javaResponseHeaders);
     }
     return values.get(0);
   }
@@ -470,10 +501,9 @@ static String extractStatusLine(Map<String, List<String>> javaResponseHeaders)
    * Creates an OkHttp Response.Body containing the supplied information.
    */
   private static ResponseBody createOkBody(final Headers okHeaders,
-      final CacheResponse cacheResponse) {
+      final CacheResponse cacheResponse) throws IOException {
+    final BufferedSource body = Okio.buffer(Okio.source(cacheResponse.getBody()));
     return new ResponseBody() {
-      private BufferedSource body;
-
       @Override
       public MediaType contentType() {
         String contentTypeHeader = okHeaders.get("Content-Type");
@@ -484,11 +514,8 @@ public MediaType contentType() {
       public long contentLength() {
         return OkHeaders.contentLength(okHeaders);
       }
-      @Override public BufferedSource source() throws IOException {
-        if (body == null) {
-          InputStream is = cacheResponse.getBody();
-          body = Okio.buffer(Okio.source(is));
-        }
+
+      @Override public BufferedSource source() {
         return body;
       }
     };
@@ -497,36 +524,34 @@ public long contentLength() {
   /**
    * Creates an OkHttp Response.Body containing the supplied information.
    */
-  private static ResponseBody createOkBody(final URLConnection urlConnection) {
+  private static ResponseBody createOkBody(final URLConnection urlConnection) throws IOException {
     if (!urlConnection.getDoInput()) {
       return null;
     }
-    return new ResponseBody() {
-      private BufferedSource body;
 
+    final BufferedSource body = Okio.buffer(Okio.source(urlConnection.getInputStream()));
+    return new ResponseBody() {
       @Override public MediaType contentType() {
         String contentTypeHeader = urlConnection.getContentType();
         return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);
       }
+
       @Override public long contentLength() {
         String s = urlConnection.getHeaderField("Content-Length");
         return stringToLong(s);
       }
-      @Override public BufferedSource source() throws IOException {
-        if (body == null) {
-          InputStream is = urlConnection.getInputStream();
-          body = Okio.buffer(Okio.source(is));
-        }
+
+      @Override public BufferedSource source() {
         return body;
       }
     };
   }
 
   /**
-   * An {@link java.net.HttpURLConnection} that represents an HTTP request at the point where
-   * the request has been made, and the response headers have been received, but the body content,
-   * if present, has not been read yet. This intended to provide enough information for
-   * {@link java.net.ResponseCache} subclasses and no more.
+   * An {@link java.net.HttpURLConnection} that represents an HTTP request at the point where the
+   * request has been made, and the response headers have been received, but the body content, if
+   * present, has not been read yet. This intended to provide enough information for {@link
+   * java.net.ResponseCache} subclasses and no more.
    *
    * <p>Much of the method implementations are overrides to delegate to the OkHttp request and
    * response, or to deny access to information as a real HttpURLConnection would after connection.
@@ -537,7 +562,7 @@ private static ResponseBody createOkBody(final URLConnection urlConnection) {
     private final Response response;
 
     public CacheHttpURLConnection(Response response) {
-      super(response.request().url());
+      super(response.request().url().url());
       this.request = response.request();
       this.response = response;
 
@@ -586,7 +611,7 @@ public String getRequestProperty(String key) {
       // spec. There seems no good reason why this should fail while getRequestProperty() is ok.
       // We don't fail here, because we need all request header values for caching Vary responses
       // correctly.
-      return OkHeaders.toMultimap(request.headers(), null);
+      return JavaNetHeaders.toMultimap(request.headers(), null);
     }
 
     @Override
@@ -633,7 +658,7 @@ public String getHeaderFieldKey(int position) {
       if (position < 0) {
         throw new IllegalArgumentException("Invalid header index: " + position);
       }
-      if (position == 0) {
+      if (position == 0 || position > response.headers().size()) {
         return null;
       }
       return response.headers().name(position - 1);
@@ -648,6 +673,9 @@ public String getHeaderField(int position) {
       if (position == 0) {
         return StatusLine.get(response).toString();
       }
+      if (position > response.headers().size()) {
+        return null;
+      }
       return response.headers().value(position - 1);
     }
 
@@ -660,7 +688,7 @@ public String getHeaderField(String fieldName) {
 
     @Override
     public Map<String, List<String>> getHeaderFields() {
-      return OkHeaders.toMultimap(response.headers(), StatusLine.get(response).toString());
+      return JavaNetHeaders.toMultimap(response.headers(), StatusLine.get(response).toString());
     }
 
     @Override
@@ -723,7 +751,11 @@ public Object getContent(Class[] classes) throws IOException {
 
     @Override
     public InputStream getInputStream() throws IOException {
-      throw throwResponseBodyAccessException();
+      return new InputStream() {
+        @Override public int read() throws IOException {
+          throw throwResponseBodyAccessException();
+        }
+      };
     }
 
     @Override
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/AbstractResponseCache.java b/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java
similarity index 97%
rename from okhttp-android-support/src/test/java/com/squareup/okhttp/AbstractResponseCache.java
rename to okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java
index 2a59d22a02..d755487c92 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/AbstractResponseCache.java
+++ b/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 import java.net.CacheRequest;
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCache.java b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
similarity index 79%
rename from okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCache.java
rename to okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
index 30d965c2b7..c569a3b365 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCache.java
+++ b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
@@ -14,11 +14,7 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.android;
-
-import com.squareup.okhttp.Cache;
-import com.squareup.okhttp.AndroidShimResponseCache;
-import com.squareup.okhttp.OkCacheContainer;
+package okhttp3.android;
 
 import java.io.Closeable;
 import java.io.File;
@@ -30,15 +26,18 @@
 import java.net.URLConnection;
 import java.util.List;
 import java.util.Map;
+import okhttp3.AndroidShimResponseCache;
+import okhttp3.Cache;
+import okhttp3.OkCacheContainer;
 
 /**
  * A copy of android.net.http.HttpResponseCache taken from AOSP. Android need to keep this code
- * working somehow. Dependencies on com.squareup.okhttp are com.android.okhttp on Android.
- */
-/* <p>This class exists in okhttp-android-support to help keep the API as it always has been on
- * Android. The public API cannot be changed. This class delegates to
- * {@link com.squareup.okhttp.AndroidShimResponseCache}, a class that exists in a package that
- * enables it to interact with non-public OkHttp classes.
+ * working somehow. Dependencies on okhttp3 are com.android.okhttp on Android.
+ *
+ * <p>This class exists in okhttp-android-support to help keep the API as it always has been on
+ * Android. The public API cannot be changed. This class delegates to {@link
+ * AndroidShimResponseCache}, a class that exists in a package that enables it to interact with
+ * non-public OkHttp classes.
  */
 public final class HttpResponseCache extends ResponseCache implements Closeable, OkCacheContainer {
 
@@ -49,8 +48,8 @@ private HttpResponseCache(AndroidShimResponseCache shimResponseCache) {
   }
 
   /**
-   * Returns the currently-installed {@code HttpResponseCache}, or null if
-   * there is no cache installed or it is not a {@code HttpResponseCache}.
+   * Returns the currently-installed {@code HttpResponseCache}, or null if there is no cache
+   * installed or it is not a {@code HttpResponseCache}.
    */
   public static HttpResponseCache getInstalled() {
     ResponseCache installed = ResponseCache.getDefault();
@@ -66,9 +65,8 @@ public static HttpResponseCache getInstalled() {
    * @param directory the directory to hold cache data.
    * @param maxSize the maximum size of the cache in bytes.
    * @return the newly-installed cache
-   * @throws java.io.IOException if {@code directory} cannot be used for this cache.
-   *     Most applications should respond to this exception by logging a
-   *     warning.
+   * @throws java.io.IOException if {@code directory} cannot be used for this cache. Most
+   * applications should respond to this exception by logging a warning.
    */
   public static synchronized HttpResponseCache install(File directory, long maxSize) throws
       IOException {
@@ -103,9 +101,8 @@ public static synchronized HttpResponseCache install(File directory, long maxSiz
   }
 
   /**
-   * Returns the number of bytes currently being used to store the values in
-   * this cache. This may be greater than the {@link #maxSize} if a background
-   * deletion is pending.
+   * Returns the number of bytes currently being used to store the values in this cache. This may be
+   * greater than the {@link #maxSize} if a background deletion is pending.
    */
   public long size() {
     try {
@@ -117,17 +114,15 @@ public long size() {
   }
 
   /**
-   * Returns the maximum number of bytes that this cache should use to store
-   * its data.
+   * Returns the maximum number of bytes that this cache should use to store its data.
    */
   public long maxSize() {
     return shimResponseCache.maxSize();
   }
 
   /**
-   * Force buffered operations to the filesystem. This ensures that responses
-   * written to the cache will be available the next time the cache is opened,
-   * even if this process is killed.
+   * Force buffered operations to the filesystem. This ensures that responses written to the cache
+   * will be available the next time the cache is opened, even if this process is killed.
    */
   public void flush() {
     try {
@@ -137,34 +132,32 @@ public void flush() {
   }
 
   /**
-   * Returns the number of HTTP requests that required the network to either
-   * supply a response or validate a locally cached response.
+   * Returns the number of HTTP requests that required the network to either supply a response or
+   * validate a locally cached response.
    */
   public int getNetworkCount() {
     return shimResponseCache.getNetworkCount();
   }
 
   /**
-   * Returns the number of HTTP requests whose response was provided by the
-   * cache. This may include conditional {@code GET} requests that were
-   * validated over the network.
+   * Returns the number of HTTP requests whose response was provided by the cache. This may include
+   * conditional {@code GET} requests that were validated over the network.
    */
   public int getHitCount() {
     return shimResponseCache.getHitCount();
   }
 
   /**
-   * Returns the total number of HTTP requests that were made. This includes
-   * both client requests and requests that were made on the client's behalf
-   * to handle a redirects and retries.
+   * Returns the total number of HTTP requests that were made. This includes both client requests
+   * and requests that were made on the client's behalf to handle a redirects and retries.
    */
   public int getRequestCount() {
     return shimResponseCache.getRequestCount();
   }
 
   /**
-   * Uninstalls the cache and releases any active resources. Stored contents
-   * will remain on the filesystem.
+   * Uninstalls the cache and releases any active resources. Stored contents will remain on the
+   * filesystem.
    */
   @Override public void close() throws IOException {
     if (ResponseCache.getDefault() == this) {
@@ -187,5 +180,4 @@ public void delete() throws IOException {
   public Cache getCache() {
     return shimResponseCache.getCache();
   }
-
 }
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
similarity index 89%
rename from okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCacheTest.java
rename to okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
index 851501750b..dcb1c01815 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/android/HttpResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
@@ -14,14 +14,8 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.android;
-
-import com.squareup.okhttp.AndroidInternal;
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
+package okhttp3.android;
+
 import java.io.File;
 import java.io.InputStream;
 import java.net.CacheRequest;
@@ -31,6 +25,12 @@
 import java.net.URLConnection;
 import java.util.List;
 import java.util.Map;
+import okhttp3.AndroidInternal;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -48,16 +48,15 @@
  * A port of Android's android.net.http.HttpResponseCacheTest to JUnit4.
  */
 public final class HttpResponseCacheTest {
-
   @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
   @Rule public MockWebServer server = new MockWebServer();
 
   private File cacheDir;
-  private OkUrlFactory client;
+  private OkUrlFactory urlFactory;
 
   @Before public void setUp() throws Exception {
     cacheDir = cacheRule.getRoot();
-    client = new OkUrlFactory(new OkHttpClient());
+    urlFactory = new OkUrlFactory(new OkHttpClient());
   }
 
   @After public void tearDown() throws Exception {
@@ -133,8 +132,8 @@ public CacheRequest put(URI uri, URLConnection connection) {
   }
 
   /**
-   * Make sure that statistics tracking are wired all the way through the
-   * wrapper class. http://code.google.com/p/android/issues/detail?id=25418
+   * Make sure that statistics tracking are wired all the way through the wrapper class.
+   * http://code.google.com/p/android/issues/detail?id=25418
    */
   @Test public void statisticsTracking() throws Exception {
     HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
@@ -162,11 +161,11 @@ public CacheRequest put(URI uri, URLConnection connection) {
     assertEquals(2, cache.getHitCount());
   }
 
-  // This mimics the Android HttpHandler, which is found in the com.squareup.okhttp package.
+  // This mimics the Android HttpHandler, which is found in the okhttp3 package.
   private URLConnection openUrl(HttpUrl url) {
     ResponseCache responseCache = ResponseCache.getDefault();
-    AndroidInternal.setResponseCache(client, responseCache);
-    return client.open(url.url());
+    AndroidInternal.setResponseCache(urlFactory, responseCache);
+    return urlFactory.open(url.url());
   }
 
   private void initializeCache(HttpResponseCache cache) {
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
similarity index 83%
rename from okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
rename to okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
index 97593d5779..81aeaf2b9a 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
@@ -13,16 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.huc;
-
-import com.squareup.okhttp.AbstractResponseCache;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.testing.RecordingHostnameVerifier;
+package okhttp3.internal.huc;
+
 import java.io.IOException;
 import java.net.CacheRequest;
 import java.net.CacheResponse;
@@ -38,6 +30,15 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
+import okhttp3.AbstractResponseCache;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.internal.Internal;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.RecordingHostnameVerifier;
 import okio.Buffer;
 import org.junit.After;
 import org.junit.Before;
@@ -51,10 +52,10 @@
 /**
  * A white-box test for {@link CacheAdapter}. See also:
  * <ul>
- *   <li>{@link ResponseCacheTest} for black-box tests that check that {@link ResponseCache}
- *   classes are called correctly by OkHttp.</li>
- *   <li>{@link JavaApiConverterTest} for tests that check Java API classes / OkHttp conversion
- *   logic. </li>
+ *     <li>{@link ResponseCacheTest} for black-box tests that check that {@link ResponseCache}
+ *         classes are called correctly by OkHttp.
+ *     <li>{@link JavaApiConverterTest} for tests that check Java API classes / OkHttp conversion
+ *         logic.
  * </ul>
  */
 public class CacheAdapterTest {
@@ -81,8 +82,8 @@
     assertEquals("http", serverUrl.getProtocol());
 
     ResponseCache responseCache = new AbstractResponseCache() {
-      @Override
-      public CacheResponse get(URI uri, String method, Map<String, List<String>> headers) throws IOException {
+      @Override public CacheResponse get(
+          URI uri, String method, Map<String, List<String>> headers) throws IOException {
         assertEquals(toUri(serverUrl), uri);
         assertEquals("GET", method);
         assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
@@ -90,7 +91,7 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+    setInternalCache(new CacheAdapter(responseCache));
 
     connection = new OkUrlFactory(client).open(serverUrl);
     connection.setRequestProperty("key1", "value1");
@@ -113,9 +114,11 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setCache(client, new CacheAdapter(responseCache));
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
+    setInternalCache(new CacheAdapter(responseCache));
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
 
     connection = new OkUrlFactory(client).open(serverUrl);
     connection.setRequestProperty("key1", "value1");
@@ -157,7 +160,7 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+    setInternalCache(new CacheAdapter(responseCache));
 
     connection = new OkUrlFactory(client).open(serverUrl);
     connection.setRequestProperty("key", "value");
@@ -196,7 +199,7 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+    setInternalCache(new CacheAdapter(responseCache));
 
     connection = new OkUrlFactory(client).open(serverUrl);
 
@@ -214,7 +217,8 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         assertEquals(serverUrl, connection.getURL());
 
         HttpsURLConnection cacheHttpsUrlConnection = (HttpsURLConnection) connection;
-        HttpsURLConnection realHttpsUrlConnection = (HttpsURLConnection) CacheAdapterTest.this.connection;
+        HttpsURLConnection realHttpsUrlConnection =
+            (HttpsURLConnection) CacheAdapterTest.this.connection;
         assertEquals(realHttpsUrlConnection.getCipherSuite(),
             cacheHttpsUrlConnection.getCipherSuite());
         assertEquals(realHttpsUrlConnection.getPeerPrincipal(),
@@ -228,9 +232,11 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setCache(client, new CacheAdapter(responseCache));
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
+    setInternalCache(new CacheAdapter(responseCache));
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
 
     connection = new OkUrlFactory(client).open(serverUrl);
     executeGet(connection);
@@ -252,13 +258,19 @@ private void executePost(HttpURLConnection connection) throws IOException {
   private URL configureServer(MockResponse mockResponse) throws Exception {
     server.enqueue(mockResponse);
     server.start();
-    return server.getUrl("/");
+    return server.url("/").url();
   }
 
   private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false /* tunnelProxy */);
     server.enqueue(mockResponse);
     server.start();
-    return server.getUrl("/");
+    return server.url("/").url();
+  }
+
+  private void setInternalCache(InternalCache internalCache) {
+    OkHttpClient.Builder builder = client.newBuilder();
+    Internal.instance.setCache(builder, internalCache);
+    client = builder.build();
   }
 }
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
similarity index 93%
rename from okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
rename to okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
index 7255372bbe..f4c9b95dab 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
@@ -13,19 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.huc;
-
-import com.squareup.okhttp.Handshake;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
+package okhttp3.internal.huc;
+
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -49,6 +38,18 @@
 import java.util.Set;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.CipherSuite;
+import okhttp3.Handshake;
+import okhttp3.Headers;
+import okhttp3.MediaType;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.mockwebserver.MockWebServer;
 import okio.Buffer;
 import okio.BufferedSource;
 import org.junit.Before;
@@ -118,7 +119,7 @@
 
     Response response = JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
     Request cacheRequest = response.request();
-    assertEquals(request.httpUrl(), cacheRequest.httpUrl());
+    assertEquals(request.url(), cacheRequest.url());
     assertEquals(request.method(), cacheRequest.method());
     assertEquals(0, request.headers().size());
 
@@ -176,14 +177,15 @@
       }
 
       @Override public String getCipherSuite() {
-        return "SuperSecure";
+        return "SSL_RSA_WITH_NULL_MD5";
       }
 
       @Override public List<Certificate> getLocalCertificateChain() {
         return localCertificates;
       }
 
-      @Override public List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException {
+      @Override public List<Certificate> getServerCertificateChain()
+          throws SSLPeerUnverifiedException {
         return serverCertificates;
       }
 
@@ -198,7 +200,7 @@
 
     Response response = JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
     Request cacheRequest = response.request();
-    assertEquals(request.httpUrl(), cacheRequest.httpUrl());
+    assertEquals(request.url(), cacheRequest.url());
     assertEquals(request.method(), cacheRequest.method());
     assertEquals(0, request.headers().size());
 
@@ -211,7 +213,7 @@
 
     Handshake handshake = response.handshake();
     assertNotNull(handshake);
-    assertNotNullAndEquals("SuperSecure", handshake.cipherSuite());
+    assertNotNullAndEquals(CipherSuite.TLS_RSA_WITH_NULL_MD5, handshake.cipherSuite());
     assertEquals(localPrincipal, handshake.localPrincipal());
     assertEquals(serverPrincipal, handshake.peerPrincipal());
     assertEquals(serverCertificates, handshake.peerCertificates());
@@ -221,10 +223,10 @@
   @Test public void createOkRequest_nullRequestHeaders() throws Exception {
     URI uri = new URI("http://foo/bar");
 
-    Map<String,List<String>> javaRequestHeaders = null;
+    Map<String, List<String>> javaRequestHeaders = null;
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
     assertFalse(request.isHttps());
-    assertEquals(uri, request.uri());
+    assertEquals(uri, request.url().uri());
     Headers okRequestHeaders = request.headers();
     assertEquals(0, okRequestHeaders.size());
     assertEquals("POST", request.method());
@@ -233,11 +235,11 @@
   @Test public void createOkRequest_nonNullRequestHeaders() throws Exception {
     URI uri = new URI("https://foo/bar");
 
-    Map<String,List<String>> javaRequestHeaders = new HashMap<>();
+    Map<String, List<String>> javaRequestHeaders = new HashMap<>();
     javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
     assertTrue(request.isHttps());
-    assertEquals(uri, request.uri());
+    assertEquals(uri, request.url().uri());
     Headers okRequestHeaders = request.headers();
     assertEquals(1, okRequestHeaders.size());
     assertEquals("Bar", okRequestHeaders.get("Foo"));
@@ -251,12 +253,12 @@
   @Test public void createOkRequest_nullRequestHeaderKey() throws Exception {
     URI uri = new URI("https://foo/bar");
 
-    Map<String,List<String>> javaRequestHeaders = new HashMap<>();
+    Map<String, List<String>> javaRequestHeaders = new HashMap<>();
     javaRequestHeaders.put(null, Arrays.asList("GET / HTTP 1.1"));
     javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
     assertTrue(request.isHttps());
-    assertEquals(uri, request.uri());
+    assertEquals(uri, request.url().uri());
     Headers okRequestHeaders = request.headers();
     assertEquals(1, okRequestHeaders.size());
     assertEquals("Bar", okRequestHeaders.get("Foo"));
@@ -318,8 +320,9 @@
         JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
     // Check an arbitrary (not complete) set of methods that can be used to access the response
     // body.
+    InputStream is = httpUrlConnection.getInputStream();
     try {
-      httpUrlConnection.getInputStream();
+      is.read();
       fail();
     } catch (UnsupportedOperationException expected) {
     }
@@ -461,18 +464,18 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
         .get()
         .url("https://secure/request")
         .build();
-    Handshake handshake = Handshake.get("SecureCipher", Arrays.<Certificate>asList(SERVER_CERT),
-        Arrays.<Certificate>asList(LOCAL_CERT));
+    Handshake handshake = Handshake.get(null, CipherSuite.TLS_RSA_WITH_NULL_MD5,
+        Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
         .handshake(handshake)
         .build();
     HttpsURLConnection httpsUrlConnection =
         (HttpsURLConnection) JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
 
-    assertEquals("SecureCipher", httpsUrlConnection.getCipherSuite());
+    assertEquals("SSL_RSA_WITH_NULL_MD5", httpsUrlConnection.getCipherSuite());
     assertEquals(SERVER_CERT.getSubjectX500Principal(), httpsUrlConnection.getPeerPrincipal());
-    assertArrayEquals(new Certificate[] { LOCAL_CERT }, httpsUrlConnection.getLocalCertificates());
-    assertArrayEquals(new Certificate[] { SERVER_CERT },
+    assertArrayEquals(new Certificate[] {LOCAL_CERT}, httpsUrlConnection.getLocalCertificates());
+    assertArrayEquals(new Certificate[] {SERVER_CERT},
         httpsUrlConnection.getServerCertificates());
     assertEquals(LOCAL_CERT.getSubjectX500Principal(), httpsUrlConnection.getLocalPrincipal());
   }
@@ -548,11 +551,11 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
     Request okRequest =
         createArbitraryOkRequest().newBuilder()
             .url("https://secure/request")
-            .post(createRequestBody("RequestBody") )
+            .post(createRequestBody("RequestBody"))
             .build();
     ResponseBody responseBody = createResponseBody("ResponseBody");
-    Handshake handshake = Handshake.get("SecureCipher", Arrays.<Certificate>asList(SERVER_CERT),
-        Arrays.<Certificate>asList(LOCAL_CERT));
+    Handshake handshake = Handshake.get(null, CipherSuite.TLS_RSA_WITH_NULL_MD5,
+        Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
         .protocol(Protocol.HTTP_1_1)
         .code(200)
@@ -569,7 +572,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
     assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
     assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
     assertEquals("ResponseBody", readAll(javaCacheResponse.getBody()));
-    assertEquals(handshake.cipherSuite(), javaCacheResponse.getCipherSuite());
+    assertEquals(handshake.cipherSuite().javaName(), javaCacheResponse.getCipherSuite());
     assertEquals(handshake.localCertificates(), javaCacheResponse.getLocalCertificateChain());
     assertEquals(handshake.peerCertificates(), javaCacheResponse.getServerCertificateChain());
     assertEquals(handshake.localPrincipal(), javaCacheResponse.getLocalPrincipal());
@@ -594,7 +597,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
     javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
     javaResponseHeaders.put("key2", Arrays.asList("value2"));
 
-    Headers okHeaders = JavaApiConverter.extractOkHeaders(javaResponseHeaders);
+    Headers okHeaders = JavaApiConverter.extractOkHeaders(javaResponseHeaders, null);
     assertEquals(3, okHeaders.size()); // null entry should be stripped out
     assertEquals(Arrays.asList("value1_1", "value1_2"), okHeaders.values("key1"));
     assertEquals(Arrays.asList("value2"), okHeaders.values("key2"));
diff --git a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
similarity index 86%
rename from okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
rename to okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
index 1dbf78fc83..a73ca54854 100644
--- a/okhttp-android-support/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
@@ -14,20 +14,8 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.huc;
-
-import com.squareup.okhttp.AbstractResponseCache;
-import com.squareup.okhttp.AndroidInternal;
-import com.squareup.okhttp.AndroidShimResponseCache;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.testing.RecordingHostnameVerifier;
+package okhttp3.internal.huc;
+
 import java.io.BufferedReader;
 import java.io.ByteArrayInputStream;
 import java.io.FileNotFoundException;
@@ -67,6 +55,20 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
+import okhttp3.AbstractResponseCache;
+import okhttp3.AndroidInternal;
+import okhttp3.AndroidShimResponseCache;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.internal.Internal;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.RecordingHostnameVerifier;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -77,7 +79,6 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -86,8 +87,8 @@
 import static org.junit.Assert.fail;
 
 /**
- * Tests the interaction between OkHttp and {@link ResponseCache}.
- * Based on com.squareup.okhttp.CacheTest with changes for ResponseCache and HttpURLConnection.
+ * Tests the interaction between OkHttp and {@link ResponseCache}. Based on okhttp3.CacheTest with
+ * changes for ResponseCache and HttpURLConnection.
  */
 public final class ResponseCacheTest {
   @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
@@ -96,29 +97,26 @@
 
   private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private SSLContext sslContext = SslContextBuilder.localhost();
-  private OkHttpClient client;
   private ResponseCache cache;
   private CookieManager cookieManager;
+  private OkUrlFactory urlFactory;
 
   @Before public void setUp() throws Exception {
     server.setProtocolNegotiationEnabled(false);
 
-    client = new OkHttpClient();
-
     cache = AndroidShimResponseCache.create(cacheRule.getRoot(), 10 * 1024 * 1024);
-    AndroidInternal.setResponseCache(new OkUrlFactory(client), cache);
+    urlFactory = new OkUrlFactory(new OkHttpClient());
+    AndroidInternal.setResponseCache(urlFactory, cache);
 
     cookieManager = new CookieManager();
-    CookieManager.setDefault(cookieManager);
   }
 
   @After public void tearDown() throws Exception {
-    CookieManager.setDefault(null);
     ResponseCache.setDefault(null);
   }
 
   private HttpURLConnection openConnection(URL url) {
-    return new OkUrlFactory(client).open(url);
+    return urlFactory.open(url);
   }
 
   /**
@@ -133,45 +131,45 @@ private HttpURLConnection openConnection(URL url) {
     // assertCached(false, 100);
     assertCached(false, 101);
     assertCached(false, 102);
-    assertCached(true,  200);
+    assertCached(true, 200);
     assertCached(false, 201);
     assertCached(false, 202);
-    assertCached(true,  203);
-    assertCached(true,  204);
+    assertCached(true, 203);
+    assertCached(true, 204);
     assertCached(false, 205);
     assertCached(false, 206); //Electing to not cache partial responses
     assertCached(false, 207);
-    assertCached(true,  300);
-    assertCached(true,  301);
-    assertCached(true,  302);
+    assertCached(true, 300);
+    assertCached(true, 301);
+    assertCached(true, 302);
     assertCached(false, 303);
     assertCached(false, 304);
     assertCached(false, 305);
     assertCached(false, 306);
-    assertCached(true,  307);
-    assertCached(true,  308);
+    assertCached(true, 307);
+    assertCached(true, 308);
     assertCached(false, 400);
     assertCached(false, 401);
     assertCached(false, 402);
     assertCached(false, 403);
-    assertCached(true,  404);
-    assertCached(true,  405);
+    assertCached(true, 404);
+    assertCached(true, 405);
     assertCached(false, 406);
     assertCached(false, 408);
     assertCached(false, 409);
     // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true,  410);
+    assertCached(true, 410);
     assertCached(false, 411);
     assertCached(false, 412);
     assertCached(false, 413);
-    assertCached(true,  414);
+    assertCached(true, 414);
     assertCached(false, 415);
     assertCached(false, 416);
     assertCached(false, 417);
     assertCached(false, 418);
 
     assertCached(false, 500);
-    assertCached(true,  501);
+    assertCached(true, 501);
     assertCached(false, 502);
     assertCached(false, 503);
     assertCached(false, 504);
@@ -180,6 +178,8 @@ private HttpURLConnection openConnection(URL url) {
   }
 
   private void assertCached(boolean shouldPut, int responseCode) throws Exception {
+    int expectedResponseCode = responseCode;
+
     server = new MockWebServer();
     MockResponse mockResponse = new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
@@ -193,11 +193,22 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
       mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
     }
     server.enqueue(mockResponse);
+
+    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
+      // 408's are a bit of an outlier because we may repeat the request if we encounter this
+      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
+      // because of the retry. We just want to ensure the initial 408 isn't cached.
+      expectedResponseCode = 200;
+      server.enqueue(new MockResponse()
+          .setHeader("Cache-Control", "no-store")
+          .setBody("FGHIJ"));
+    }
+
     server.start();
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     HttpURLConnection connection = openConnection(url);
-    assertEquals(responseCode, connection.getResponseCode());
+    assertEquals(expectedResponseCode, connection.getResponseCode());
 
     // Exhaust the content stream.
     readAscii(connection);
@@ -236,7 +247,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(mockResponse);
 
     // Make sure that calling skip() doesn't omit bytes from the cache.
-    HttpURLConnection urlConnection = openConnection(server.getUrl("/"));
+    HttpURLConnection urlConnection = openConnection(server.url("/").url());
     InputStream in = urlConnection.getInputStream();
     assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
     reliableSkip(in, "puppies but hate ".length());
@@ -244,7 +255,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals(-1, in.read());
     in.close();
 
-    urlConnection = openConnection(server.getUrl("/")); // cached!
+    urlConnection = openConnection(server.url("/").url()); // cached!
     in = urlConnection.getInputStream();
     assertEquals("I love puppies but hate spiders",
         readAscii(urlConnection, "I love puppies but hate spiders".length()));
@@ -262,7 +273,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
-    HttpsURLConnection c1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    HttpsURLConnection c1 = (HttpsURLConnection) openConnection(server.url("/").url());
     c1.setSSLSocketFactory(sslContext.getSocketFactory());
     c1.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(c1));
@@ -274,7 +285,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Principal peerPrincipal = c1.getPeerPrincipal();
     Principal localPrincipal = c1.getLocalPrincipal();
 
-    HttpsURLConnection c2 = (HttpsURLConnection) openConnection(server.getUrl("/")); // cached!
+    HttpsURLConnection c2 = (HttpsURLConnection) openConnection(server.url("/").url()); // cached!
     c2.setSSLSocketFactory(sslContext.getSocketFactory());
     c2.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(c2));
@@ -299,10 +310,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse()
         .setBody("DEF"));
 
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    HttpURLConnection connection = openConnection(server.url("/").url());
     assertEquals("ABC", readAscii(connection));
 
-    connection = openConnection(server.getUrl("/")); // cached!
+    connection = openConnection(server.url("/").url()); // cached!
     assertEquals("ABC", readAscii(connection));
   }
 
@@ -316,18 +327,18 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse()
         .setBody("DEF"));
 
-    assertEquals("ABC", readAscii(openConnection(server.getUrl("/foo"))));
+    assertEquals("ABC", readAscii(openConnection(server.url("/foo").url())));
     RecordedRequest request1 = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
     assertEquals(0, request1.getSequenceNumber());
 
-    assertEquals("ABC", readAscii(openConnection(server.getUrl("/bar"))));
+    assertEquals("ABC", readAscii(openConnection(server.url("/bar").url())));
     RecordedRequest request2 = server.takeRequest();
     assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
     assertEquals(1, request2.getSequenceNumber());
 
     // an unrelated request should reuse the pooled connection
-    assertEquals("DEF", readAscii(openConnection(server.getUrl("/baz"))));
+    assertEquals("DEF", readAscii(openConnection(server.url("/baz").url())));
     RecordedRequest request3 = server.takeRequest();
     assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
     assertEquals(2, request3.getSequenceNumber());
@@ -347,15 +358,17 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse()
         .setBody("DEF"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(hostnameVerifier)
+        .build());
 
-    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
     assertEquals("ABC", readAscii(connection1));
     assertNotNull(connection1.getCipherSuite());
 
     // Cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.url("/").url());
     assertEquals("ABC", readAscii(connection2));
     assertNotNull(connection2.getCipherSuite());
 
@@ -363,10 +376,9 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   /**
-   * We've had bugs where caching and cross-protocol redirects yield class
-   * cast exceptions internal to the cache because we incorrectly assumed that
-   * HttpsURLConnection was always HTTPS and HttpURLConnection was always HTTP;
-   * in practice redirects mean that each can do either.
+   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
+   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
+   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
    *
    * https://github.com/square/okhttp/issues/214
    */
@@ -383,16 +395,18 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: " + server2.getUrl("/")));
+        .addHeader("Location: " + server2.url("/").url()));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(hostnameVerifier)
+        .build());
 
-    HttpURLConnection connection1 = openConnection(server.getUrl("/"));
+    HttpURLConnection connection1 = openConnection(server.url("/").url());
     assertEquals("ABC", readAscii(connection1));
 
     // Cached!
-    HttpURLConnection connection2 = openConnection(server.getUrl("/"));
+    HttpURLConnection connection2 = openConnection(server.url("/").url());
     assertEquals("ABC", readAscii(connection2));
   }
 
@@ -434,7 +448,7 @@ private void temporaryRedirectCachedWithCachingHeader(
     server.enqueue(new MockResponse()
         .setBody("c"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     assertEquals("a", readAscii(openConnection(url)));
     assertEquals("a", readAscii(openConnection(url)));
   }
@@ -448,7 +462,7 @@ private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) th
     server.enqueue(new MockResponse()
         .setBody("b"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     assertEquals("a", readAscii(openConnection(url)));
     assertEquals("b", readAscii(openConnection(url)));
   }
@@ -475,7 +489,7 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
         .setBody("Request #2"));
 
     BufferedReader reader = new BufferedReader(
-        new InputStreamReader(openConnection(server.getUrl("/")).getInputStream()));
+        new InputStreamReader(openConnection(server.url("/").url()).getInputStream()));
     assertEquals("ABCDE", reader.readLine());
     try {
       reader.readLine();
@@ -485,7 +499,7 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
       reader.close();
     }
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = openConnection(server.url("/").url());
     assertEquals("Request #2", readAscii(connection));
   }
 
@@ -510,7 +524,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(new MockResponse()
         .setBody("Request #2"));
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = openConnection(server.url("/").url());
     InputStream in = connection.getInputStream();
     assertEquals("ABCDE", readAscii(connection, 5));
     in.close();
@@ -520,7 +534,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     } catch (IOException expected) {
     }
 
-    connection = openConnection(server.getUrl("/"));
+    connection = openConnection(server.url("/").url());
     assertEquals("Request #2", readAscii(connection));
   }
 
@@ -534,7 +548,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
         .setBody("A"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     assertEquals("A", readAscii(openConnection(url)));
     URLConnection connection = openConnection(url);
     assertEquals("A", readAscii(connection));
@@ -563,8 +577,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
         .setBody("A"));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    URLConnection connection = openConnection(server.url("/").url());
     assertEquals("A", readAscii(connection));
     assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
         connection.getHeaderField("Warning"));
@@ -578,7 +592,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/?foo=bar");
+    URL url = server.url("/?foo=bar").url();
     assertEquals("A", readAscii(openConnection(url)));
     assertEquals("B", readAscii(openConnection(url)));
   }
@@ -702,7 +716,7 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
     server.enqueue(new MockResponse()
         .addHeader("X-Response-ID: 2"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
 
     HttpURLConnection request1 = openConnection(url);
     request1.setRequestMethod(requestMethod);
@@ -753,7 +767,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("C"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
 
     assertEquals("A", readAscii(openConnection(url)));
 
@@ -767,7 +781,8 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
   /**
    * Equivalent to {@code CacheTest.postInvalidatesCacheWithUncacheableResponse()} but demonstrating
    * that {@link ResponseCache} provides no mechanism for cache invalidation as the result of
-   * locally-made requests. In reality invalidation could take place from other clients at any time.
+   * locally-made requests. In reality invalidation could take place from other clients at any
+   * time.
    */
   @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
     // 1. seed the cache
@@ -780,7 +795,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .setBody("B")
         .setResponseCode(500));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
 
     assertEquals("A", readAscii(openConnection(url)));
 
@@ -867,7 +882,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("BB"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
 
     HttpURLConnection range = openConnection(url);
     range.addRequestProperty("Range", "bytes=1000-1001");
@@ -885,7 +900,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .setBody("B")
         .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
 
     assertEquals("A", readAscii(openConnection(url)));
     assertEquals("A", readAscii(openConnection(url)));
@@ -899,11 +914,11 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .addHeader("Cache-Control: max-age=60")
         .setBody("B"));
 
-    HttpURLConnection connection1 = openConnection(server.getUrl("/"));
+    HttpURLConnection connection1 = openConnection(server.url("/").url());
     connection1.setRequestProperty("Cache-Control", "no-store");
     assertEquals("A", readAscii(connection1));
 
-    HttpURLConnection connection2 = openConnection(server.getUrl("/"));
+    HttpURLConnection connection2 = openConnection(server.url("/").url());
     assertEquals("B", readAscii(connection2));
   }
 
@@ -931,9 +946,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     // At least three request/response pairs are required because after the first request is cached
     // a different execution path might be taken. Thus modifications to the cache applied during
     // the second request might not be visible until another request is performed.
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
   }
 
   @Test public void notModifiedSpecifiesEncoding() throws Exception {
@@ -948,9 +963,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("DEFDEFDEF"));
 
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("DEFDEFDEF", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+    assertEquals("DEFDEFDEF", readAscii(openConnection(server.url("/").url())));
   }
 
   /** https://github.com/square/okhttp/issues/947 */
@@ -963,8 +978,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("FAIL"));
 
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
   }
 
   @Test public void expiresDateBeforeModifiedDate() throws Exception {
@@ -982,9 +997,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = openConnection(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "max-age=30");
     assertEquals("B", readAscii(connection));
   }
@@ -997,9 +1012,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = openConnection(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "min-fresh=120");
     assertEquals("B", readAscii(connection));
   }
@@ -1012,9 +1027,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = openConnection(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "max-stale=180");
     assertEquals("A", readAscii(connection));
     assertEquals("110 HttpURLConnection \"Response is stale\"",
@@ -1030,10 +1045,10 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
 
     // With max-stale, we'll return that stale response.
-    URLConnection maxStaleConnection = openConnection(server.getUrl("/"));
+    URLConnection maxStaleConnection = openConnection(server.url("/").url());
     maxStaleConnection.setRequestProperty("Cache-Control", "max-stale");
     assertEquals("A", readAscii(maxStaleConnection));
     assertEquals("110 HttpURLConnection \"Response is stale\"",
@@ -1048,9 +1063,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = openConnection(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "max-stale=180");
     assertEquals("B", readAscii(connection));
   }
@@ -1058,7 +1073,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
     // (no responses enqueued)
 
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    HttpURLConnection connection = openConnection(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
   }
@@ -1069,8 +1084,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    URLConnection connection = openConnection(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
   }
@@ -1081,8 +1096,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    HttpURLConnection connection = openConnection(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
   }
@@ -1091,8 +1106,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("A"));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    HttpURLConnection connection = openConnection(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
   }
@@ -1105,7 +1120,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     assertEquals("A", readAscii(openConnection(url)));
     URLConnection connection = openConnection(url);
     connection.setRequestProperty("Cache-Control", "no-cache");
@@ -1120,7 +1135,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     assertEquals("A", readAscii(openConnection(url)));
     URLConnection connection = openConnection(url);
     connection.setRequestProperty("Pragma", "no-cache");
@@ -1155,7 +1170,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     assertEquals("A", readAscii(openConnection(url)));
 
     HttpURLConnection connection = openConnection(url);
@@ -1168,8 +1183,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   /**
-   * For Last-Modified and Date headers, we should echo the date back in the
-   * exact format we were served.
+   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
+   * served.
    */
   @Test public void retainServedDateFormat() throws Exception {
     // Serve a response with a non-standard date format that OkHttp supports.
@@ -1188,8 +1203,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
 
     // The first request has no conditions.
     RecordedRequest request1 = server.takeRequest();
@@ -1204,7 +1219,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    HttpURLConnection connection = openConnection(server.url("/").url());
     String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
     connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
     assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
@@ -1218,7 +1233,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     URLConnection connection = openConnection(url);
     connection.addRequestProperty("Authorization", "password");
     assertEquals("A", readAscii(connection));
@@ -1233,8 +1248,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/foo"))));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/bar"))));
+    assertEquals("A", readAscii(openConnection(server.url("/foo").url())));
+    assertEquals("B", readAscii(openConnection(server.url("/bar").url())));
   }
 
   @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
@@ -1247,9 +1262,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/b"))));
+    assertEquals("A", readAscii(openConnection(server.url("/a").url())));
+    assertEquals("A", readAscii(openConnection(server.url("/a").url())));
+    assertEquals("B", readAscii(openConnection(server.url("/b").url())));
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
@@ -1264,7 +1279,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     HttpURLConnection frenchConnection = openConnection(url);
     frenchConnection.setRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(frenchConnection));
@@ -1282,7 +1297,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     HttpURLConnection frenchConnection1 = openConnection(url);
     frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(frenchConnection1));
@@ -1300,8 +1315,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
   }
 
   @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
@@ -1312,8 +1327,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection2 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    HttpURLConnection connection2 = openConnection(server.url("/").url());
     connection2.setRequestProperty("Foo", "bar");
     assertEquals("B", readAscii(connection2));
   }
@@ -1326,10 +1341,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    HttpURLConnection connection1 = openConnection(server.getUrl("/"));
+    HttpURLConnection connection1 = openConnection(server.url("/").url());
     connection1.setRequestProperty("Foo", "bar");
     assertEquals("A", readAscii(connection1));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("B", readAscii(openConnection(server.url("/").url())));
   }
 
   @Test public void varyFieldsAreCaseInsensitive() throws Exception {
@@ -1340,7 +1355,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     HttpURLConnection frenchConnection1 = openConnection(url);
     frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(frenchConnection1));
@@ -1358,7 +1373,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     HttpURLConnection frenchConnection1 = openConnection(url);
     frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
     frenchConnection1.setRequestProperty("Accept-Charset", "UTF-8");
@@ -1380,7 +1395,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     HttpURLConnection frenchConnection = openConnection(url);
     frenchConnection.setRequestProperty("Accept-Language", "fr-CA");
     frenchConnection.setRequestProperty("Accept-Charset", "UTF-8");
@@ -1401,7 +1416,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     HttpURLConnection multiConnection1 = openConnection(url);
     multiConnection1.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
     multiConnection1.addRequestProperty("Accept-Language", "en-US");
@@ -1421,7 +1436,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     HttpURLConnection multiConnection = openConnection(url);
     multiConnection.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
     multiConnection.addRequestProperty("Accept-Language", "en-US");
@@ -1441,8 +1456,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    assertEquals("B", readAscii(openConnection(server.url("/").url())));
   }
 
   @Test public void varyAndHttps() throws Exception {
@@ -1454,10 +1469,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(hostnameVerifier)
+        .build());
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     HttpURLConnection connection1 = openConnection(url);
     connection1.setRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
@@ -1467,23 +1484,6 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("A", readAscii(connection2));
   }
 
-  @Test public void cachePlusCookies() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=FIRST; domain=" + server.getCookieDomain() + ";")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertCookies(url, "a=FIRST");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertCookies(url, "a=SECOND");
-  }
-
   @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("Allow: GET, HEAD")
@@ -1494,11 +1494,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Allow: GET, HEAD, PUT")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URLConnection connection1 = openConnection(server.getUrl("/"));
+    URLConnection connection1 = openConnection(server.url("/").url());
     assertEquals("A", readAscii(connection1));
     assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
 
-    URLConnection connection2 = openConnection(server.getUrl("/"));
+    URLConnection connection2 = openConnection(server.url("/").url());
     assertEquals("A", readAscii(connection2));
     assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
   }
@@ -1513,11 +1513,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Transfer-Encoding: none")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URLConnection connection1 = openConnection(server.getUrl("/"));
+    URLConnection connection1 = openConnection(server.url("/").url());
     assertEquals("A", readAscii(connection1));
     assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
 
-    URLConnection connection2 = openConnection(server.getUrl("/"));
+    URLConnection connection2 = openConnection(server.url("/").url());
     assertEquals("A", readAscii(connection2));
     assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
   }
@@ -1531,11 +1531,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URLConnection connection1 = openConnection(server.getUrl("/"));
+    URLConnection connection1 = openConnection(server.url("/").url());
     assertEquals("A", readAscii(connection1));
     assertEquals("199 test danger", connection1.getHeaderField("Warning"));
 
-    URLConnection connection2 = openConnection(server.getUrl("/"));
+    URLConnection connection2 = openConnection(server.url("/").url());
     assertEquals("A", readAscii(connection2));
     assertEquals(null, connection2.getHeaderField("Warning"));
   }
@@ -1549,11 +1549,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URLConnection connection1 = openConnection(server.getUrl("/"));
+    URLConnection connection1 = openConnection(server.url("/").url());
     assertEquals("A", readAscii(connection1));
     assertEquals("299 test danger", connection1.getHeaderField("Warning"));
 
-    URLConnection connection2 = openConnection(server.getUrl("/"));
+    URLConnection connection2 = openConnection(server.url("/").url());
     assertEquals("A", readAscii(connection2));
     assertEquals("299 test danger", connection2.getHeaderField("Warning"));
   }
@@ -1566,7 +1566,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     assertEquals(Arrays.asList(expectedCookies), actualCookies);
   }
 
-  @Test public void doNotCachePartialResponse() throws Exception  {
+  @Test public void doNotCachePartialResponse() throws Exception {
     assertNotCached(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
         .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
@@ -1600,22 +1600,22 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
 
     // cache miss; seed the cache with an entry that will require a network hit to be sure it is
     // still valid
-    HttpURLConnection connection1 = openConnection(server.getUrl("/a"));
+    HttpURLConnection connection1 = openConnection(server.url("/a").url());
     assertEquals("A", readAscii(connection1));
     assertEquals(null, connection1.getHeaderField("Allow"));
 
     // conditional cache hit; The cached data should be returned, but the cache is not updated.
-    HttpURLConnection connection2 = openConnection(server.getUrl("/a"));
+    HttpURLConnection connection2 = openConnection(server.url("/a").url());
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertEquals("A", readAscii(connection2));
     assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
 
     // conditional cache hit; The server responds with new data. The cache is updated.
-    HttpURLConnection connection3 = openConnection(server.getUrl("/a"));
+    HttpURLConnection connection3 = openConnection(server.url("/a").url());
     assertEquals("B", readAscii(connection3));
 
     // full cache hit; The data from connection3 has now replaced that from connection 1.
-    HttpURLConnection connection4 = openConnection(server.getUrl("/a"));
+    HttpURLConnection connection4 = openConnection(server.url("/a").url());
     assertEquals("B", readAscii(connection4));
 
     assertEquals(3, server.getRequestCount());
@@ -1627,8 +1627,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    URLConnection connection = openConnection(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
   }
@@ -1643,8 +1643,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    HttpURLConnection connection = openConnection(server.url("/").url());
     assertEquals("B", readAscii(connection));
   }
 
@@ -1656,8 +1656,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse()
         .setResponseCode(304));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    HttpURLConnection connection = openConnection(server.url("/").url());
     assertEquals("A", readAscii(connection));
   }
 
@@ -1665,7 +1665,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("A"));
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = openConnection(server.url("/").url());
     assertEquals("A", readAscii(connection));
   }
 
@@ -1677,14 +1677,13 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .setHeaders(headers.build())
         .setBody("body"));
 
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    HttpURLConnection connection = openConnection(server.url("/").url());
     assertEquals("A", connection.getHeaderField(""));
   }
 
   /**
-   * @param delta the offset from the current date to use. Negative
-   * values yield dates in the past; positive values yield dates in the
-   * future.
+   * @param delta the offset from the current date to use. Negative values yield dates in the past;
+   * positive values yield dates in the future.
    */
   private String formatDate(long delta, TimeUnit timeUnit) {
     return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
@@ -1701,7 +1700,7 @@ private void assertNotCached(MockResponse response) throws Exception {
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     assertEquals("A", readAscii(openConnection(url)));
     assertEquals("B", readAscii(openConnection(url)));
   }
@@ -1716,7 +1715,7 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
 
-    URL valid = server.getUrl("/valid");
+    URL valid = server.url("/valid").url();
     HttpURLConnection connection1 = openConnection(valid);
     assertEquals("A", readAscii(connection1));
     assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
@@ -1726,7 +1725,7 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertEquals("A-OK", connection2.getResponseMessage());
 
-    URL invalid = server.getUrl("/invalid");
+    URL invalid = server.url("/invalid").url();
     HttpURLConnection connection3 = openConnection(invalid);
     assertEquals("B", readAscii(connection3));
     assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
@@ -1744,18 +1743,17 @@ private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(response.setBody("B"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     assertEquals("A", readAscii(openConnection(url)));
     assertEquals("A", readAscii(openConnection(url)));
   }
 
   /**
-   * Shortens the body of {@code response} but not the corresponding headers.
-   * Only useful to test how clients respond to the premature conclusion of
-   * the HTTP body.
+   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
+   * how clients respond to the premature conclusion of the HTTP body.
    */
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
-    response.setSocketPolicy(DISCONNECT_AT_END);
+    response.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
     Headers headers = response.getHeaders();
     Buffer truncatedBody = new Buffer();
     truncatedBody.write(response.getBody(), numBytesToKeep);
@@ -1779,7 +1777,7 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
     END_OF_STREAM() {
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
-        response.setSocketPolicy(DISCONNECT_AT_END);
+        response.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
         response.removeHeader("Content-Length");
       }
     };
@@ -1801,9 +1799,8 @@ public Buffer gzip(String data) throws IOException {
   }
 
   /**
-   * Reads {@code count} characters from the stream. If the stream is
-   * exhausted before {@code count} characters can be read, the remaining
-   * characters are returned and the stream is closed.
+   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
+   * characters can be read, the remaining characters are returned and the stream is closed.
    */
   private String readAscii(URLConnection connection, int count) throws IOException {
     HttpURLConnection httpConnection = (HttpURLConnection) connection;
@@ -1848,8 +1845,8 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
   // Android-added tests.
 
   /**
-   * Test that we can interrogate the response when the cache is being
-   * populated. http://code.google.com/p/android/issues/detail?id=7787
+   * Test that we can interrogate the response when the cache is being populated.
+   * http://code.google.com/p/android/issues/detail?id=7787
    */
   @Test public void responseCacheCallbackApis() throws Exception {
     final String body = "ABCDE";
@@ -1861,13 +1858,14 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
         .addHeader("fgh: ijk")
         .setBody(body));
 
-    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
       @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
         HttpURLConnection httpURLConnection = (HttpURLConnection) connection;
-        assertEquals(server.getUrl("/"), uri.toURL());
+        assertEquals(server.url("/").url(), uri.toURL());
         assertEquals(200, httpURLConnection.getResponseCode());
+        InputStream is = httpURLConnection.getInputStream();
         try {
-          httpURLConnection.getInputStream();
+          is.read();
           fail();
         } catch (UnsupportedOperationException expected) {
         }
@@ -1879,7 +1877,7 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
       }
     }));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     HttpURLConnection connection = openConnection(url);
     assertEquals(body, readAscii(connection));
     assertEquals(1, cacheCount.get());
@@ -1888,7 +1886,7 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
   /** Don't explode if the cache returns a null body. http://b/3373699 */
   @Test public void responseCacheReturnsNullOutputStream() throws Exception {
     final AtomicBoolean aborted = new AtomicBoolean();
-    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
       @Override public CacheRequest put(URI uri, URLConnection connection) {
         return new CacheRequest() {
           @Override public void abort() {
@@ -1904,7 +1902,7 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
 
     server.enqueue(new MockResponse().setBody("abcdef"));
 
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    HttpURLConnection connection = openConnection(server.url("/").url());
     assertEquals("abc", readAscii(connection, 3));
     connection.getInputStream().close();
     assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
@@ -1918,7 +1916,7 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
     String cachedContentString = "Hello";
     final byte[] cachedContent = cachedContentString.getBytes(StandardCharsets.US_ASCII);
 
-    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
       @Override
       public CacheResponse get(URI uri, String requestMethod,
           Map<String, List<String>> requestHeaders)
@@ -1942,7 +1940,7 @@ public CacheResponse get(URI uri, String requestMethod,
         };
       }
     }));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    HttpURLConnection connection = openConnection(server.url("/").url());
     // If there was no status line from the cache an exception will be thrown. No network request
     // should be made.
     try {
@@ -1972,6 +1970,7 @@ private InsecureResponseCache(ResponseCache delegate) {
           @Override public InputStream getBody() throws IOException {
             return response.getBody();
           }
+
           @Override public Map<String, List<String>> getHeaders() throws IOException {
             return response.getHeaders();
           }
@@ -1986,15 +1985,15 @@ private InsecureResponseCache(ResponseCache delegate) {
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
-    AndroidInternal.setResponseCache(new OkUrlFactory(client), new InsecureResponseCache(cache));
+    AndroidInternal.setResponseCache(urlFactory, new InsecureResponseCache(cache));
 
-    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
     connection1.setSSLSocketFactory(sslContext.getSocketFactory());
     connection1.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(connection1));
 
     // Not cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.url("/").url());
     connection2.setSSLSocketFactory(sslContext.getSocketFactory());
     connection2.setHostnameVerifier(hostnameVerifier);
     assertEquals("DEF", readAscii(connection2));
@@ -2005,7 +2004,7 @@ private InsecureResponseCache(ResponseCache delegate) {
         .setBody("ABC"));
 
     final AtomicReference<Map<String, List<String>>> requestHeadersRef = new AtomicReference<>();
-    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
       @Override public CacheResponse get(URI uri, String requestMethod,
           Map<String, List<String>> requestHeaders) throws IOException {
         requestHeadersRef.set(requestHeaders);
@@ -2013,7 +2012,7 @@ private InsecureResponseCache(ResponseCache delegate) {
       }
     }));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     URLConnection urlConnection = openConnection(url);
     urlConnection.addRequestProperty("A", "android");
     readAscii(urlConnection);
@@ -2027,7 +2026,7 @@ private InsecureResponseCache(ResponseCache delegate) {
             .setStatus("HTTP/1.1 200 Fantastic");
     server.enqueue(response);
 
-    HttpURLConnection urlConnection = openConnection(server.getUrl("/"));
+    HttpURLConnection urlConnection = openConnection(server.url("/").url());
     assertEquals(200, urlConnection.getResponseCode());
     assertEquals("Fantastic", urlConnection.getResponseMessage());
     assertTrue(urlConnection.getDoInput());
@@ -2035,7 +2034,7 @@ private InsecureResponseCache(ResponseCache delegate) {
     assertEquals(-1, is.read());
     is.close();
 
-    urlConnection = openConnection(server.getUrl("/")); // cached!
+    urlConnection = openConnection(server.url("/").url()); // cached!
     assertTrue(urlConnection.getDoInput());
     InputStream cachedIs = urlConnection.getInputStream();
     assertEquals(-1, cachedIs.read());
@@ -2051,10 +2050,10 @@ private InsecureResponseCache(ResponseCache delegate) {
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = openConnection(server.url("/").url());
     connection.setUseCaches(false);
     assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("B", readAscii(openConnection(server.url("/").url())));
   }
 
   @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
@@ -2064,8 +2063,8 @@ private InsecureResponseCache(ResponseCache delegate) {
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(openConnection(server.url("/").url())));
+    URLConnection connection = openConnection(server.url("/").url());
     connection.setUseCaches(false);
     assertEquals("B", readAscii(connection));
   }
@@ -2100,11 +2099,11 @@ private InsecureResponseCache(ResponseCache delegate) {
     ResponseCache.setDefault(cache);
 
     // Use the platform's HTTP stack.
-    URLConnection connection = server.getUrl("/").openConnection();
+    URLConnection connection = server.url("/").url().openConnection();
     assertFalse(connection instanceof HttpURLConnectionImpl);
     assertEquals("A", readAscii(connection));
 
-    URLConnection connection2 = server.getUrl("/").openConnection();
+    URLConnection connection2 = server.url("/").url().openConnection();
     assertFalse(connection2 instanceof HttpURLConnectionImpl);
     assertEquals("A", readAscii(connection2));
   }
@@ -2124,11 +2123,11 @@ private InsecureResponseCache(ResponseCache delegate) {
     ResponseCache.setDefault(cache);
 
     // Use the platform's HTTP stack.
-    URLConnection connection = server.getUrl("/").openConnection();
+    URLConnection connection = server.url("/").url().openConnection();
     assertFalse(connection instanceof HttpURLConnectionImpl);
     assertEquals("A", readAscii(connection));
 
-    URLConnection connection2 = server.getUrl("/").openConnection();
+    URLConnection connection2 = server.url("/").url().openConnection();
     assertFalse(connection2 instanceof HttpURLConnectionImpl);
     assertEquals("B", readAscii(connection2));
   }
@@ -2148,12 +2147,12 @@ private InsecureResponseCache(ResponseCache delegate) {
     ResponseCache.setDefault(cache);
 
     // Use the platform's HTTP stack.
-    URLConnection connection = server.getUrl("/").openConnection();
+    URLConnection connection = server.url("/").url().openConnection();
     assertFalse(connection instanceof HttpURLConnectionImpl);
     connection.setRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection));
 
-    URLConnection connection2 = server.getUrl("/").openConnection();
+    URLConnection connection2 = server.url("/").url().openConnection();
     assertFalse(connection2 instanceof HttpURLConnectionImpl);
     assertEquals("B", readAscii(connection2));
   }
@@ -2173,12 +2172,18 @@ private InsecureResponseCache(ResponseCache delegate) {
     ResponseCache.setDefault(cache);
 
     // Use the platform's HTTP stack.
-    URLConnection connection = server.getUrl("/").openConnection();
+    URLConnection connection = server.url("/").url().openConnection();
     assertFalse(connection instanceof HttpURLConnectionImpl);
     assertEquals("A", readAscii(connection));
 
-    URLConnection connection2 = server.getUrl("/").openConnection();
+    URLConnection connection2 = server.url("/").url().openConnection();
     assertFalse(connection2 instanceof HttpURLConnectionImpl);
     assertEquals("B", readAscii(connection2));
   }
+
+  private void setInternalCache(InternalCache internalCache) {
+    OkHttpClient.Builder builder = urlFactory.client().newBuilder();
+    Internal.instance.setCache(builder, internalCache);
+    urlFactory.setClient(builder.build());
+  }
 }
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index 70722835fb..68fcf1add9 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.5.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
@@ -14,12 +14,12 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-testing-support</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
@@ -36,7 +36,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>mockwebserver</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
diff --git a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/HttpEntityBody.java b/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
similarity index 91%
rename from okhttp-apache/src/main/java/com/squareup/okhttp/apache/HttpEntityBody.java
rename to okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
index fd7884cd80..45d27aafd1 100644
--- a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/HttpEntityBody.java
+++ b/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
@@ -1,8 +1,8 @@
-package com.squareup.okhttp.apache;
+package okhttp3.apache;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
 import okio.BufferedSink;
 import org.apache.http.HttpEntity;
 
diff --git a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
similarity index 90%
rename from okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
rename to okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
index 3a9174a4d6..a1af89f867 100644
--- a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
+++ b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
@@ -1,15 +1,15 @@
 // Copyright 2013 Square, Inc.
-package com.squareup.okhttp.apache;
-
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
+package okhttp3.apache;
+
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpEntityEnclosingRequest;
@@ -32,11 +32,9 @@
 import static org.apache.http.HttpVersion.HTTP_1_1;
 
 /**
- * Implements Apache's {@link HttpClient} API using {@link OkHttpClient}.
- * <p>
- * <strong>Warning:</strong> Many core features of Apache HTTP client are not implemented by this
- * API. This includes the keep-alive strategy, cookie store, credentials provider, route planner
- * and others.
+ * @deprecated OkHttp will be dropping its ability to be used with {@link HttpClient} in an upcoming
+ * release. Applications that need this should either downgrade to the Apache implementation or
+ * upgrade to OkHttp's Request/Response API.
  */
 public final class OkApacheClient implements HttpClient {
   private static Request transformRequest(HttpRequest request) {
@@ -103,7 +101,7 @@ private static HttpResponse transformResponse(Response response) throws IOExcept
   private final HttpParams params = new AbstractHttpParams() {
     @Override public Object getParameter(String name) {
       if (name.equals(ConnRouteParams.DEFAULT_PROXY)) {
-        Proxy proxy = client.getProxy();
+        Proxy proxy = client.proxy();
         if (proxy == null) {
           return null;
         }
@@ -120,7 +118,9 @@ private static HttpResponse transformResponse(Response response) throws IOExcept
         if (host != null) {
           proxy = new Proxy(HTTP, new InetSocketAddress(host.getHostName(), host.getPort()));
         }
-        client.setProxy(proxy);
+        client = client.newBuilder()
+            .proxy(proxy)
+            .build();
         return this;
       }
       throw new IllegalArgumentException(name);
@@ -135,7 +135,7 @@ private static HttpResponse transformResponse(Response response) throws IOExcept
     }
   };
 
-  private final OkHttpClient client;
+  private OkHttpClient client;
 
   public OkApacheClient() {
     this(new OkHttpClient());
diff --git a/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java b/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
similarity index 87%
rename from okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
rename to okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
index 105f22f3d5..77493a2540 100644
--- a/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
+++ b/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
@@ -1,13 +1,13 @@
-package com.squareup.okhttp.apache;
+package okhttp3.apache;
 
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URISyntaxException;
 import java.util.zip.GZIPInputStream;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.GzipSink;
 import okio.Okio;
@@ -25,7 +25,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.Util.UTF_8;
+import static okhttp3.internal.Util.UTF_8;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
@@ -47,7 +47,7 @@
   @Test public void success() throws Exception {
     server.enqueue(new MockResponse().setBody("Hello, World!"));
 
-    HttpGet request = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
     HttpResponse response = client.execute(request);
     String actual = EntityUtils.toString(response.getEntity());
     assertEquals("Hello, World!", actual);
@@ -57,7 +57,7 @@
     server.enqueue(new MockResponse().setResponseCode(302).addHeader("Location", "/foo"));
     server.enqueue(new MockResponse().setBody("Hello, Redirect!"));
 
-    HttpGet request = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
     HttpResponse response = client.execute(request);
     String actual = EntityUtils.toString(response.getEntity(), UTF_8);
     assertEquals("Hello, Redirect!", actual);
@@ -66,7 +66,7 @@
   @Test public void sessionExpired() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(422));
 
-    HttpGet request = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
     HttpResponse response = client.execute(request);
     assertEquals(422, response.getStatusLine().getStatusCode());
   }
@@ -75,13 +75,13 @@
     server.enqueue(new MockResponse().addHeader("Foo", "Bar"));
     server.enqueue(new MockResponse().addHeader("Foo", "Bar").addHeader("Foo", "Baz"));
 
-    HttpGet request1 = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request1 = new HttpGet(server.url("/").url().toURI());
     HttpResponse response1 = client.execute(request1);
     Header[] headers1 = response1.getHeaders("Foo");
     assertEquals(1, headers1.length);
     assertEquals("Bar", headers1[0].getValue());
 
-    HttpGet request2 = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request2 = new HttpGet(server.url("/").url().toURI());
     HttpResponse response2 = client.execute(request2);
     Header[] headers2 = response2.getHeaders("Foo");
     assertEquals(2, headers2.length);
@@ -92,7 +92,7 @@
   @Test public void postByteEntity() throws Exception {
     server.enqueue(new MockResponse());
 
-    final HttpPost post = new HttpPost(server.getUrl("/").toURI());
+    final HttpPost post = new HttpPost(server.url("/").url().toURI());
     byte[] body = "Hello, world!".getBytes(UTF_8);
     post.setEntity(new ByteArrayEntity(body));
     client.execute(post);
@@ -105,7 +105,7 @@
   @Test public void postInputStreamEntity() throws Exception {
     server.enqueue(new MockResponse());
 
-    final HttpPost post = new HttpPost(server.getUrl("/").toURI());
+    final HttpPost post = new HttpPost(server.url("/").url().toURI());
     byte[] body = "Hello, world!".getBytes(UTF_8);
     post.setEntity(new InputStreamEntity(new ByteArrayInputStream(body), body.length));
     client.execute(post);
@@ -114,20 +114,22 @@
     assertEquals("Hello, world!", request.getBody().readUtf8());
     assertEquals(request.getHeader("Content-Length"), "13");
   }
+
   @Test public void postEmptyEntity() throws Exception {
     server.enqueue(new MockResponse());
-    final HttpPost post = new HttpPost(server.getUrl("/").toURI());
+    final HttpPost post = new HttpPost(server.url("/").url().toURI());
     client.execute(post);
-    
+
     RecordedRequest request = server.takeRequest();
     assertEquals(0, request.getBodySize());
     assertNotNull(request.getBody());
   }
+
   @Test public void putEmptyEntity() throws Exception {
     server.enqueue(new MockResponse());
-    final HttpPut put = new HttpPut(server.getUrl("/").toURI());
+    final HttpPut put = new HttpPut(server.url("/").url().toURI());
     client.execute(put);
-    
+
     RecordedRequest request = server.takeRequest();
     assertEquals(0, request.getBodySize());
     assertNotNull(request.getBody());
@@ -137,7 +139,7 @@
     server.enqueue(new MockResponse());
 
     HttpPost httpPost = new HttpPost();
-    httpPost.setURI(server.getUrl("/").toURI());
+    httpPost.setURI(server.url("/").url().toURI());
     httpPost.addHeader("Content-Type", "application/xml");
     httpPost.setEntity(new StringEntity("<yo/>"));
     client.execute(httpPost);
@@ -153,7 +155,7 @@
         .setHeader("Content-Type", "application/json"));
     server.enqueue(new MockResponse().setBody("Hello, World!"));
 
-    HttpGet request1 = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request1 = new HttpGet(server.url("/").url().toURI());
     HttpResponse response1 = client.execute(request1);
     Header[] headers1 = response1.getHeaders("Content-Type");
     assertEquals(1, headers1.length);
@@ -161,7 +163,7 @@
     assertNotNull(response1.getEntity().getContentType());
     assertEquals("text/html", response1.getEntity().getContentType().getValue());
 
-    HttpGet request2 = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request2 = new HttpGet(server.url("/").url().toURI());
     HttpResponse response2 = client.execute(request2);
     Header[] headers2 = response2.getHeaders("Content-Type");
     assertEquals(1, headers2.length);
@@ -169,7 +171,7 @@
     assertNotNull(response2.getEntity().getContentType());
     assertEquals("application/json", response2.getEntity().getContentType().getValue());
 
-    HttpGet request3 = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request3 = new HttpGet(server.url("/").url().toURI());
     HttpResponse response3 = client.execute(request3);
     Header[] headers3 = response3.getHeaders("Content-Type");
     assertEquals(0, headers3.length);
@@ -180,7 +182,7 @@
     server.enqueue(new MockResponse().setBody("{\"Message\": { \"text\": \"Hello, World!\" } }")
         .setHeader("cONTENT-tYPE", "application/json"));
 
-    HttpGet request = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
     HttpResponse response = client.execute(request);
     assertEquals("application/json", response.getEntity().getContentType().getValue());
   }
@@ -190,7 +192,7 @@
     server.enqueue(new MockResponse().setBody(gzip(text))
         .setHeader("Content-Encoding", "gzip"));
 
-    HttpGet request = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
     request.setHeader("Accept-encoding", "gzip"); // Not transparent gzip.
     HttpResponse response = client.execute(request);
     HttpEntity entity = response.getEntity();
@@ -210,7 +212,7 @@
         .setHeader("Content-Encoding", "gzip")
         .setHeader("Content-Type", "application/json"));
 
-    HttpGet request1 = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request1 = new HttpGet(server.url("/").url().toURI());
     request1.setHeader("Accept-encoding", "gzip"); // Not transparent gzip.
 
     HttpResponse response = client.execute(request1);
@@ -237,7 +239,7 @@
         .setHeader("Content-Encoding", "gzip")
         .setHeader("Content-Type", "application/json"));
 
-    HttpGet request = new HttpGet(server.getUrl("/").toURI());
+    HttpGet request = new HttpGet(server.url("/").url().toURI());
     HttpResponse response = client.execute(request);
     HttpEntity entity = response.getEntity();
 
diff --git a/okhttp-hpacktests/pom.xml b/okhttp-hpacktests/pom.xml
index 4d299fefdc..7e8fb57ad7 100644
--- a/okhttp-hpacktests/pom.xml
+++ b/okhttp-hpacktests/pom.xml
@@ -1,12 +1,14 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.4.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-hpacktests</artifactId>
@@ -18,12 +20,16 @@
       <artifactId>okio</artifactId>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-testing-support</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
@@ -34,17 +40,11 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>mockwebserver</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
-    <!--  Gson: Java to Json conversion -->
-    <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
-      <scope>compile</scope>
-    </dependency>
   </dependencies>
 
   <build>
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeInteropTest.java
similarity index 82%
rename from okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropTest.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeInteropTest.java
index 6cb7a86225..e99c2a29cd 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropTest.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeInteropTest.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.internal.framed.hpackjson.Story;
 import java.util.Collection;
+import okhttp3.internal.framed.hpackjson.Story;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
-import static com.squareup.okhttp.internal.framed.hpackjson.HpackJsonUtil.storiesForCurrentDraft;
+import static okhttp3.internal.framed.hpackjson.HpackJsonUtil.storiesForCurrentDraft;
 
 @RunWith(Parameterized.class)
 public class HpackDecodeInteropTest extends HpackDecodeTestBase {
@@ -30,7 +30,7 @@ public HpackDecodeInteropTest(Story story) {
     super(story);
   }
 
-  @Parameterized.Parameters(name="{0}")
+  @Parameterized.Parameters(name = "{0}")
   public static Collection<Story[]> createStories() throws Exception {
     return createStories(storiesForCurrentDraft());
   }
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeTestBase.java
similarity index 87%
rename from okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeTestBase.java
index fe5731911b..a77c4d8a02 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackDecodeTestBase.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.internal.framed.hpackjson.Case;
-import com.squareup.okhttp.internal.framed.hpackjson.HpackJsonUtil;
-import com.squareup.okhttp.internal.framed.hpackjson.Story;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.LinkedHashSet;
 import java.util.List;
+import okhttp3.internal.framed.hpackjson.Case;
+import okhttp3.internal.framed.hpackjson.HpackJsonUtil;
+import okhttp3.internal.framed.hpackjson.Story;
 import okio.Buffer;
 
 import static org.junit.Assert.assertEquals;
@@ -44,7 +44,7 @@
         fail("No stories for: " + interopTestName);
       }
       for (Story story : stories) {
-        result.add(new Story[] { story });
+        result.add(new Story[] {story});
       }
     }
     return result;
@@ -60,8 +60,7 @@ public HpackDecodeTestBase(Story story) {
   }
 
   /**
-   * Expects wire to be set for all cases, and compares the decoder's output to
-   * expected headers.
+   * Expects wire to be set for all cases, and compares the decoder's output to expected headers.
    */
   protected void testDecoder() throws Exception {
     testDecoder(story);
@@ -75,9 +74,10 @@ protected void testDecoder(Story story) throws Exception {
           hpackReader.getAndResetHeaderList());
     }
   }
+
   /**
-   * Checks if {@code expected} and {@code observed} are equal when viewed as a
-   * set and headers are deduped.
+   * Checks if {@code expected} and {@code observed} are equal when viewed as a set and headers are
+   * deduped.
    *
    * TODO: See if duped headers should be preserved on decode and verify.
    */
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackRoundTripTest.java
similarity index 86%
rename from okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackRoundTripTest.java
index 3d347590a8..8405a1fd7f 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/HpackRoundTripTest.java
@@ -13,17 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.internal.framed.hpackjson.Case;
-import com.squareup.okhttp.internal.framed.hpackjson.Story;
+import java.util.Collection;
+import okhttp3.internal.framed.hpackjson.Case;
+import okhttp3.internal.framed.hpackjson.Story;
 import okio.Buffer;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
-import java.util.Collection;
-
 /**
  * Tests for round-tripping headers through hpack..
  */
@@ -34,9 +33,9 @@
 @RunWith(Parameterized.class)
 public class HpackRoundTripTest extends HpackDecodeTestBase {
 
-  private static final String[] RAW_DATA = { "raw-data" };
+  private static final String[] RAW_DATA = {"raw-data"};
 
-  @Parameterized.Parameters(name="{0}")
+  @Parameterized.Parameters(name = "{0}")
   public static Collection<Story[]> getStories() throws Exception {
     return createStories(RAW_DATA);
   }
@@ -59,5 +58,4 @@ public void testRoundTrip() throws Exception {
 
     testDecoder(story);
   }
-
 }
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Case.java
similarity index 88%
rename from okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Case.java
index b62c9f50e3..4c931b7c0e 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Case.java
@@ -13,20 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed.hpackjson;
-
-import com.squareup.okhttp.internal.framed.Header;
-import okio.ByteString;
+package okhttp3.internal.framed.hpackjson;
 
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import okhttp3.internal.framed.Header;
+import okio.ByteString;
 
 /**
- * Representation of an individual case (set of headers and wire format).
- * There are many cases for a single story.  This class is used reflectively
- * with Gson to parse stories.
+ * Representation of an individual case (set of headers and wire format). There are many cases for a
+ * single story.  This class is used reflectively with Moshi to parse stories.
  */
 public class Case implements Cloneable {
 
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/HpackJsonUtil.java
similarity index 79%
rename from okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/HpackJsonUtil.java
index fa52d24287..1d38261c53 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/HpackJsonUtil.java
@@ -13,19 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed.hpackjson;
+package okhttp3.internal.framed.hpackjson;
 
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.InputStreamReader;
 import java.net.URISyntaxException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import okio.Okio;
 
 /**
  * Utilities for reading HPACK tests.
@@ -36,20 +35,25 @@
 
   private static final String STORY_RESOURCE_FORMAT = "/hpack-test-case/%s/story_%02d.json";
 
-  private static final Gson GSON = new GsonBuilder().create();
+  private static final Moshi MOSHI = new Moshi.Builder().build();
+  private static final JsonAdapter<Story> STORY_JSON_ADAPTER = MOSHI.adapter(Story.class);
 
   private static Story readStory(InputStream jsonResource) throws IOException {
-    return GSON.fromJson(new InputStreamReader(jsonResource, "UTF-8"), Story.class);
+    return STORY_JSON_ADAPTER.fromJson(Okio.buffer(Okio.source(jsonResource)));
+  }
+
+  private static Story readStory(File file) throws IOException {
+    return STORY_JSON_ADAPTER.fromJson(Okio.buffer(Okio.source(file)));
   }
 
   /** Iterate through the hpack-test-case resources, only picking stories for the current draft. */
   public static String[] storiesForCurrentDraft() throws URISyntaxException {
     File testCaseDirectory = new File(HpackJsonUtil.class.getResource("/hpack-test-case").toURI());
-    List<String> storyNames = new ArrayList<String>();
+    List<String> storyNames = new ArrayList<>();
     for (File path : testCaseDirectory.listFiles()) {
       if (path.isDirectory() && Arrays.asList(path.list()).contains("story_00.json")) {
         try {
-          Story firstStory = readStory(new FileInputStream(new File(path, "story_00.json")));
+          Story firstStory = readStory(new File(path, "story_00.json"));
           if (firstStory.getDraft() >= BASE_DRAFT) {
             storyNames.add(path.getName());
           }
@@ -85,5 +89,6 @@ private static Story readStory(InputStream jsonResource) throws IOException {
     return result;
   }
 
-  private HpackJsonUtil() { } // Utilities only.
+  private HpackJsonUtil() {
+  } // Utilities only.
 }
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Story.java
similarity index 92%
rename from okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java
rename to okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Story.java
index cf6a9a0807..3d14d5dab5 100644
--- a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/framed/hpackjson/Story.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed.hpackjson;
+package okhttp3.internal.framed.hpackjson;
 
 import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Representation of one story, a set of request headers to encode or decode.
- * This class is used reflectively with Gson to parse stories from files.
+ * Representation of one story, a set of request headers to encode or decode. This class is used
+ * reflectively with Moshi to parse stories from files.
  */
 public class Story implements Cloneable {
 
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
new file mode 100644
index 0000000000..1c5dcd952a
--- /dev/null
+++ b/okhttp-logging-interceptor/README.md
@@ -0,0 +1,50 @@
+Logging Interceptor
+===================
+
+An [OkHttp interceptor][1] which logs HTTP request and response data.
+
+```java
+HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
+logging.setLevel(Level.BASIC);
+OkHttpClient client = new OkHttpClient.Builder()
+  .addInterceptor(logging)
+  .build();
+```
+
+You can change the log level at any time by calling `setLevel`.
+
+To log to a custom location, pass a `Logger` instance to the constructor.
+```java
+HttpLoggingInterceptor logging = new HttpLoggingInterceptor(new Logger() {
+  @Override public void log(String message) {
+    Timber.tag("OkHttp").d(message);
+  }
+});
+```
+
+**Warning**: The logs generated by this interceptor when using the `HEADERS` or `BODY` levels has
+the potential to leak sensitive information such as "Authorization" or "Cookie" headers and the
+contents of request and response bodies. This data should only be logged in a controlled way or in
+a non-production environment.
+
+
+Download
+--------
+
+Get via Maven:
+```xml
+<dependency>
+  <groupId>com.squareup.okhttp3</groupId>
+  <artifactId>logging-interceptor</artifactId>
+  <version>(insert latest version)</version>
+</dependency>
+```
+
+or via Gradle 
+```groovy
+compile 'com.squareup.okhttp3:logging-interceptor:(insert latest version)'
+```
+
+
+
+ [1]: https://github.com/square/okhttp/wiki/Interceptors
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
new file mode 100644
index 0000000000..a837c6c898
--- /dev/null
+++ b/okhttp-logging-interceptor/pom.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.3.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>logging-interceptor</artifactId>
+  <name>OkHttp Logging Interceptor</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
new file mode 100644
index 0000000000..a88cef1390
--- /dev/null
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
@@ -0,0 +1,294 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.nio.charset.UnsupportedCharsetException;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Connection;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Platform;
+import okhttp3.internal.http.HttpEngine;
+import okio.Buffer;
+import okio.BufferedSource;
+
+import static okhttp3.internal.Platform.INFO;
+
+/**
+ * An OkHttp interceptor which logs request and response information. Can be applied as an
+ * {@linkplain OkHttpClient#interceptors() application interceptor} or as a {@linkplain
+ * OkHttpClient#networkInterceptors() network interceptor}. <p> The format of the logs created by
+ * this class should not be considered stable and may change slightly between releases. If you need
+ * a stable logging format, use your own interceptor.
+ */
+public final class HttpLoggingInterceptor implements Interceptor {
+  private static final Charset UTF8 = Charset.forName("UTF-8");
+
+  public enum Level {
+    /** No logs. */
+    NONE,
+    /**
+     * Logs request and response lines.
+     *
+     * <p>Example:
+     * <pre>{@code
+     * --> POST /greeting http/1.1 (3-byte body)
+     *
+     * <-- 200 OK (22ms, 6-byte body)
+     * }</pre>
+     */
+    BASIC,
+    /**
+     * Logs request and response lines and their respective headers.
+     *
+     * <p>Example:
+     * <pre>{@code
+     * --> POST /greeting http/1.1
+     * Host: example.com
+     * Content-Type: plain/text
+     * Content-Length: 3
+     * --> END POST
+     *
+     * <-- 200 OK (22ms)
+     * Content-Type: plain/text
+     * Content-Length: 6
+     * <-- END HTTP
+     * }</pre>
+     */
+    HEADERS,
+    /**
+     * Logs request and response lines and their respective headers and bodies (if present).
+     *
+     * <p>Example:
+     * <pre>{@code
+     * --> POST /greeting http/1.1
+     * Host: example.com
+     * Content-Type: plain/text
+     * Content-Length: 3
+     *
+     * Hi?
+     * --> END GET
+     *
+     * <-- 200 OK (22ms)
+     * Content-Type: plain/text
+     * Content-Length: 6
+     *
+     * Hello!
+     * <-- END HTTP
+     * }</pre>
+     */
+    BODY
+  }
+
+  public interface Logger {
+    void log(String message);
+
+    /** A {@link Logger} defaults output appropriate for the current platform. */
+    Logger DEFAULT = new Logger() {
+      @Override public void log(String message) {
+        Platform.get().log(INFO, message, null);
+      }
+    };
+  }
+
+  public HttpLoggingInterceptor() {
+    this(Logger.DEFAULT);
+  }
+
+  public HttpLoggingInterceptor(Logger logger) {
+    this.logger = logger;
+  }
+
+  private final Logger logger;
+
+  private volatile Level level = Level.NONE;
+
+  /** Change the level at which this interceptor logs. */
+  public HttpLoggingInterceptor setLevel(Level level) {
+    if (level == null) throw new NullPointerException("level == null. Use Level.NONE instead.");
+    this.level = level;
+    return this;
+  }
+
+  public Level getLevel() {
+    return level;
+  }
+
+  @Override public Response intercept(Chain chain) throws IOException {
+    Level level = this.level;
+
+    Request request = chain.request();
+    if (level == Level.NONE) {
+      return chain.proceed(request);
+    }
+
+    boolean logBody = level == Level.BODY;
+    boolean logHeaders = logBody || level == Level.HEADERS;
+
+    RequestBody requestBody = request.body();
+    boolean hasRequestBody = requestBody != null;
+
+    Connection connection = chain.connection();
+    Protocol protocol = connection != null ? connection.protocol() : Protocol.HTTP_1_1;
+    String requestStartMessage = "--> " + request.method() + ' ' + request.url() + ' ' + protocol;
+    if (!logHeaders && hasRequestBody) {
+      requestStartMessage += " (" + requestBody.contentLength() + "-byte body)";
+    }
+    logger.log(requestStartMessage);
+
+    if (logHeaders) {
+      if (hasRequestBody) {
+        // Request body headers are only present when installed as a network interceptor. Force
+        // them to be included (when available) so there values are known.
+        if (requestBody.contentType() != null) {
+          logger.log("Content-Type: " + requestBody.contentType());
+        }
+        if (requestBody.contentLength() != -1) {
+          logger.log("Content-Length: " + requestBody.contentLength());
+        }
+      }
+
+      Headers headers = request.headers();
+      for (int i = 0, count = headers.size(); i < count; i++) {
+        String name = headers.name(i);
+        // Skip headers from the request body as they are explicitly logged above.
+        if (!"Content-Type".equalsIgnoreCase(name) && !"Content-Length".equalsIgnoreCase(name)) {
+          logger.log(name + ": " + headers.value(i));
+        }
+      }
+
+      if (!logBody || !hasRequestBody) {
+        logger.log("--> END " + request.method());
+      } else if (bodyEncoded(request.headers())) {
+        logger.log("--> END " + request.method() + " (encoded body omitted)");
+      } else {
+        Buffer buffer = new Buffer();
+        requestBody.writeTo(buffer);
+
+        Charset charset = UTF8;
+        MediaType contentType = requestBody.contentType();
+        if (contentType != null) {
+          charset = contentType.charset(UTF8);
+        }
+
+        logger.log("");
+        if (isPlaintext(buffer)) {
+          logger.log(buffer.readString(charset));
+          logger.log("--> END " + request.method()
+              + " (" + requestBody.contentLength() + "-byte body)");
+        } else {
+          logger.log("--> END " + request.method() + " (binary "
+              + requestBody.contentLength() + "-byte body omitted)");
+        }
+      }
+    }
+
+    long startNs = System.nanoTime();
+    Response response = chain.proceed(request);
+    long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);
+
+    ResponseBody responseBody = response.body();
+    long contentLength = responseBody.contentLength();
+    String bodySize = contentLength != -1 ? contentLength + "-byte" : "unknown-length";
+    logger.log("<-- " + response.code() + ' ' + response.message() + ' '
+        + response.request().url() + " (" + tookMs + "ms" + (!logHeaders ? ", "
+        + bodySize + " body" : "") + ')');
+
+    if (logHeaders) {
+      Headers headers = response.headers();
+      for (int i = 0, count = headers.size(); i < count; i++) {
+        logger.log(headers.name(i) + ": " + headers.value(i));
+      }
+
+      if (!logBody || !HttpEngine.hasBody(response)) {
+        logger.log("<-- END HTTP");
+      } else if (bodyEncoded(response.headers())) {
+        logger.log("<-- END HTTP (encoded body omitted)");
+      } else {
+        BufferedSource source = responseBody.source();
+        source.request(Long.MAX_VALUE); // Buffer the entire body.
+        Buffer buffer = source.buffer();
+
+        Charset charset = UTF8;
+        MediaType contentType = responseBody.contentType();
+        if (contentType != null) {
+          try {
+            charset = contentType.charset(UTF8);
+          } catch (UnsupportedCharsetException e) {
+            logger.log("");
+            logger.log("Couldn't decode the response body; charset is likely malformed.");
+            logger.log("<-- END HTTP");
+
+            return response;
+          }
+        }
+
+        if (!isPlaintext(buffer)) {
+          logger.log("");
+          logger.log("<-- END HTTP (binary " + buffer.size() + "-byte body omitted)");
+          return response;
+        }
+
+        if (contentLength != 0) {
+          logger.log("");
+          logger.log(buffer.clone().readString(charset));
+        }
+
+        logger.log("<-- END HTTP (" + buffer.size() + "-byte body)");
+      }
+    }
+
+    return response;
+  }
+
+  /**
+   * Returns true if the body in question probably contains human readable text. Uses a small sample
+   * of code points to detect unicode control characters commonly used in binary file signatures.
+   */
+  static boolean isPlaintext(Buffer buffer) throws EOFException {
+    try {
+      Buffer prefix = new Buffer();
+      long byteCount = buffer.size() < 64 ? buffer.size() : 64;
+      buffer.copyTo(prefix, 0, byteCount);
+      for (int i = 0; i < 16; i++) {
+        if (prefix.exhausted()) {
+          break;
+        }
+        if (Character.isISOControl(prefix.readUtf8CodePoint())) {
+          return false;
+        }
+      }
+      return true;
+    } catch (EOFException e) {
+      return false; // Truncated UTF-8 sequence.
+    }
+  }
+
+  private boolean bodyEncoded(Headers headers) {
+    String contentEncoding = headers.get("Content-Encoding");
+    return contentEncoding != null && !contentEncoding.equalsIgnoreCase("identity");
+  }
+}
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
new file mode 100644
index 0000000000..429aa12127
--- /dev/null
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -0,0 +1,675 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Pattern;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.logging.HttpLoggingInterceptor.Level;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class HttpLoggingInterceptorTest {
+  private static final MediaType PLAIN = MediaType.parse("text/plain; charset=utf-8");
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private OkHttpClient client;
+  private String host;
+  private HttpUrl url;
+
+  private final LogRecorder networkLogs = new LogRecorder();
+  private final HttpLoggingInterceptor networkInterceptor =
+      new HttpLoggingInterceptor(networkLogs);
+
+  private final LogRecorder applicationLogs = new LogRecorder();
+  private final HttpLoggingInterceptor applicationInterceptor =
+      new HttpLoggingInterceptor(applicationLogs);
+
+  private void setLevel(Level level) {
+    networkInterceptor.setLevel(level);
+    applicationInterceptor.setLevel(level);
+  }
+
+  @Before public void setUp() {
+    client = new OkHttpClient.Builder()
+        .addNetworkInterceptor(networkInterceptor)
+        .addInterceptor(applicationInterceptor)
+        .build();
+
+    host = server.getHostName() + ":" + server.getPort();
+    url = server.url("/");
+  }
+
+  @Test public void levelGetter() {
+    // The default is NONE.
+    Assert.assertEquals(Level.NONE, applicationInterceptor.getLevel());
+
+    for (Level level : Level.values()) {
+      applicationInterceptor.setLevel(level);
+      assertEquals(level, applicationInterceptor.getLevel());
+    }
+  }
+
+  @Test public void setLevelShouldPreventNullValue() {
+    try {
+      applicationInterceptor.setLevel(null);
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("level == null. Use Level.NONE instead.", expected.getMessage());
+    }
+  }
+
+  @Test public void setLevelShouldReturnSameInstanceOfInterceptor() {
+    for (Level level : Level.values()) {
+      assertSame(applicationInterceptor, applicationInterceptor.setLevel(level));
+    }
+  }
+
+  @Test public void none() throws IOException {
+    server.enqueue(new MockResponse());
+    client.newCall(request().build()).execute();
+
+    applicationLogs.assertNoMoreLogs();
+    networkLogs.assertNoMoreLogs();
+  }
+
+  @Test public void basicGet() throws IOException {
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse());
+    client.newCall(request().build()).execute();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void basicPost() throws IOException {
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse());
+    client.newCall(request().post(RequestBody.create(PLAIN, "Hi?")).build()).execute();
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url + " http/1.1 (3-byte body)")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> POST " + url + " http/1.1 (3-byte body)")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void basicResponseBody() throws IOException {
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse()
+        .setBody("Hello!")
+        .setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 6-byte body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 6-byte body\\)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void basicChunkedResponseBody() throws IOException {
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse()
+        .setChunkedBody("Hello!", 2)
+        .setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, unknown-length body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, unknown-length body\\)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void headersGet() throws IOException {
+    setLevel(Level.HEADERS);
+
+    server.enqueue(new MockResponse());
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void headersPost() throws IOException {
+    setLevel(Level.HEADERS);
+
+    server.enqueue(new MockResponse());
+    Request request = request().post(RequestBody.create(PLAIN, "Hi?")).build();
+    Response response = client.newCall(request).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void headersPostNoContentType() throws IOException {
+    setLevel(Level.HEADERS);
+
+    server.enqueue(new MockResponse());
+    Request request = request().post(RequestBody.create(null, "Hi?")).build();
+    Response response = client.newCall(request).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void headersPostNoLength() throws IOException {
+    setLevel(Level.HEADERS);
+
+    server.enqueue(new MockResponse());
+    RequestBody body = new RequestBody() {
+      @Override public MediaType contentType() {
+        return PLAIN;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Hi!");
+      }
+    };
+    Response response = client.newCall(request().post(body).build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("Transfer-Encoding: chunked")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void headersResponseBody() throws IOException {
+    setLevel(Level.HEADERS);
+
+    server.enqueue(new MockResponse()
+        .setBody("Hello!")
+        .setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 6")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 6")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyGet() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse());
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyGet204() throws IOException {
+    setLevel(Level.BODY);
+    bodyGetNoBody(204);
+  }
+
+  @Test public void bodyGet205() throws IOException {
+    setLevel(Level.BODY);
+    bodyGetNoBody(205);
+  }
+
+  private void bodyGetNoBody(int code) throws IOException {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 " + code + " No Content"));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- " + code + " No Content " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- " + code + " No Content " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyPost() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse());
+    Request request = request().post(RequestBody.create(PLAIN, "Hi?")).build();
+    Response response = client.newCall(request).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("")
+        .assertLogEqual("Hi?")
+        .assertLogEqual("--> END POST (3-byte body)")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("")
+        .assertLogEqual("Hi?")
+        .assertLogEqual("--> END POST (3-byte body)")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP (0-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyResponseBody() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+        .setBody("Hello!")
+        .setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 6")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("Hello!")
+        .assertLogEqual("<-- END HTTP (6-byte body)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 6")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("Hello!")
+        .assertLogEqual("<-- END HTTP (6-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyResponseBodyChunked() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+        .setChunkedBody("Hello!", 2)
+        .setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Transfer-encoding: chunked")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("Hello!")
+        .assertLogEqual("<-- END HTTP (6-byte body)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Transfer-encoding: chunked")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("Hello!")
+        .assertLogEqual("<-- END HTTP (6-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyResponseNotIdentityEncoded() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+        .setHeader("Content-Encoding", "gzip")
+        .setHeader("Content-Type", PLAIN)
+        .setBody(new Buffer().write(ByteString.decodeBase64(
+            "H4sIAAAAAAAAAPNIzcnJ11HwQKIAdyO+9hMAAAA="))));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Encoding: gzip")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogMatch("Content-Length: \\d+")
+        .assertLogEqual("<-- END HTTP (encoded body omitted)")
+        .assertNoMoreLogs();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("Hello, Hello, Hello")
+        .assertLogEqual("<-- END HTTP (19-byte body)")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void bodyGetMalformedCharset() throws IOException {
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+        .setHeader("Content-Type", "text/html; charset=0")
+        .setBody("Ignore This"));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Type: text/html; charset=0")
+        .assertLogMatch("Content-Length: \\d+")
+        .assertLogMatch("")
+        .assertLogEqual("Couldn't decode the response body; charset is likely malformed.")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Type: text/html; charset=0")
+        .assertLogMatch("Content-Length: \\d+")
+        .assertLogEqual("")
+        .assertLogEqual("Couldn't decode the response body; charset is likely malformed.")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void isPlaintext() throws IOException {
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer()));
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("abc")));
+    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x80)));
+    assertFalse(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x00)));
+    assertFalse(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0xc0)));
+  }
+
+  @Test public void responseBodyIsBinary() throws IOException {
+    setLevel(Level.BODY);
+    Buffer buffer = new Buffer();
+    buffer.writeUtf8CodePoint(0x89);
+    buffer.writeUtf8CodePoint(0x50);
+    buffer.writeUtf8CodePoint(0x4e);
+    buffer.writeUtf8CodePoint(0x47);
+    buffer.writeUtf8CodePoint(0x0d);
+    buffer.writeUtf8CodePoint(0x0a);
+    buffer.writeUtf8CodePoint(0x1a);
+    buffer.writeUtf8CodePoint(0x0a);
+    server.enqueue(new MockResponse()
+        .setBody(buffer)
+        .setHeader("Content-Type", "image/png; charset=utf-8"));
+    Response response = client.newCall(request().build()).execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 9")
+        .assertLogEqual("Content-Type: image/png; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("<-- END HTTP (binary 9-byte body omitted)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 9")
+        .assertLogEqual("Content-Type: image/png; charset=utf-8")
+        .assertLogEqual("")
+        .assertLogEqual("<-- END HTTP (binary 9-byte body omitted)")
+        .assertNoMoreLogs();
+  }
+
+  private Request.Builder request() {
+    return new Request.Builder().url(url);
+  }
+
+  private static class LogRecorder implements HttpLoggingInterceptor.Logger {
+    private final List<String> logs = new ArrayList<>();
+    private int index;
+
+    LogRecorder assertLogEqual(String expected) {
+      assertTrue("No more messages found", index < logs.size());
+      String actual = logs.get(index++);
+      assertEquals(expected, actual);
+      return this;
+    }
+
+    LogRecorder assertLogMatch(String pattern) {
+      assertTrue("No more messages found", index < logs.size());
+      String actual = logs.get(index++);
+      assertTrue("<" + actual + "> did not match pattern <" + pattern + ">",
+          Pattern.matches(pattern, actual));
+      return this;
+    }
+
+    void assertNoMoreLogs() {
+      assertTrue("More messages remain: " + logs.subList(index, logs.size()), index == logs.size());
+    }
+
+    @Override public void log(String message) {
+      logs.add(message);
+    }
+  }
+}
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
index 2b19defa4f..7b6ad7cd7e 100644
--- a/okhttp-testing-support/pom.xml
+++ b/okhttp-testing-support/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.5.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-testing-support</artifactId>
@@ -19,7 +19,7 @@
       <optional>true</optional>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
diff --git a/okhttp-testing-support/src/main/java/com/squareup/okhttp/internal/io/InMemoryFileSystem.java b/okhttp-testing-support/src/main/java/com/squareup/okhttp/internal/io/InMemoryFileSystem.java
deleted file mode 100644
index 3a043cbd1f..0000000000
--- a/okhttp-testing-support/src/main/java/com/squareup/okhttp/internal/io/InMemoryFileSystem.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.io;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import okio.Buffer;
-import okio.Sink;
-import okio.Source;
-
-/** A simple file system where all files are held in memory. Not safe for concurrent use. */
-public final class InMemoryFileSystem implements FileSystem {
-  private final Map<File, Buffer> files = new LinkedHashMap<>();
-
-  @Override public Source source(File file) throws FileNotFoundException {
-    Buffer result = files.get(file);
-    if (result == null) throw new FileNotFoundException();
-    return result.clone();
-  }
-
-  @Override public Sink sink(File file) throws FileNotFoundException {
-    Buffer result = new Buffer();
-    files.put(file, result);
-    return result;
-  }
-
-  @Override public Sink appendingSink(File file) throws FileNotFoundException {
-    Buffer result = files.get(file);
-    return result != null ? result : sink(file);
-  }
-
-  @Override public void delete(File file) throws IOException {
-    files.remove(file);
-  }
-
-  @Override public boolean exists(File file) throws IOException {
-    return files.containsKey(file);
-  }
-
-  @Override public long size(File file) {
-    Buffer buffer = files.get(file);
-    return buffer != null ? buffer.size() : 0L;
-  }
-
-  @Override public void rename(File from, File to) throws IOException {
-    Buffer buffer = files.remove(from);
-    if (buffer == null) throw new FileNotFoundException();
-    files.put(to, buffer);
-  }
-
-  @Override public void deleteContents(File directory) throws IOException {
-    String prefix = directory.toString() + "/";
-    for (Iterator<File> i = files.keySet().iterator(); i.hasNext(); ) {
-      File file = i.next();
-      if (file.toString().startsWith(prefix)) i.remove();
-    }
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
new file mode 100644
index 0000000000..f2edc75d66
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+public final class FakeDns implements Dns {
+  private List<String> requestedHosts = new ArrayList<>();
+  private List<InetAddress> addresses = Collections.emptyList();
+
+  /** Sets the addresses to be returned by this fake DNS service. */
+  public FakeDns addresses(List<InetAddress> addresses) {
+    this.addresses = new ArrayList<>(addresses);
+    return this;
+  }
+
+  /** Sets the service to throw when a hostname is requested. */
+  public FakeDns unknownHost() {
+    this.addresses = Collections.emptyList();
+    return this;
+  }
+
+  public InetAddress address(int index) {
+    return addresses.get(index);
+  }
+
+  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+    requestedHosts.add(hostname);
+    if (addresses.isEmpty()) throw new UnknownHostException();
+    return addresses;
+  }
+
+  public void assertRequests(String... expectedHosts) {
+    assertEquals(Arrays.asList(expectedHosts), requestedHosts);
+    requestedHosts.clear();
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java b/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java
new file mode 100644
index 0000000000..c7d37f57ea
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public final class FakeProxySelector extends ProxySelector {
+  public final List<Proxy> proxies = new ArrayList<>();
+
+  public FakeProxySelector addProxy(Proxy proxy) {
+    proxies.add(proxy);
+    return this;
+  }
+
+  @Override public List<Proxy> select(URI uri) {
+    // Don't handle 'socket' schemes, which the RI's Socket class may request (for SOCKS).
+    return uri.getScheme().equals("http") || uri.getScheme().equals("https") ? proxies
+        : Collections.singletonList(Proxy.NO_PROXY);
+  }
+
+  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java b/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java
rename to okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
index 215e968dfe..ab67a9f06e 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
@@ -14,7 +14,7 @@
  * License for the specific language governing permissions and limitations under
  * the License.
  */
-package com.squareup.okhttp.internal.tls;
+package okhttp3;
 
 import java.security.Principal;
 import java.security.cert.Certificate;
@@ -23,7 +23,7 @@
 import javax.net.ssl.SSLSessionContext;
 import javax.security.cert.X509Certificate;
 
-final class FakeSSLSession implements SSLSession {
+public final class FakeSSLSession implements SSLSession {
   private final Certificate[] certificates;
 
   public FakeSSLSession(Certificate... certificates) throws Exception {
diff --git a/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
new file mode 100644
index 0000000000..bd4f9be142
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+public final class RecordingCookieJar implements CookieJar {
+  private final Deque<List<Cookie>> requestCookies = new ArrayDeque<>();
+  private final Deque<List<Cookie>> responseCookies = new ArrayDeque<>();
+
+  public void enqueueRequestCookies(Cookie... cookies) {
+    requestCookies.add(Arrays.asList(cookies));
+  }
+
+  public List<Cookie> takeResponseCookies() {
+    return responseCookies.removeFirst();
+  }
+
+  public void assertResponseCookies(String... cookies) {
+    List<Cookie> actualCookies = takeResponseCookies();
+    List<String> actualCookieStrings = new ArrayList<>();
+    for (Cookie cookie : actualCookies) {
+      actualCookieStrings.add(cookie.toString());
+    }
+    assertEquals(Arrays.asList(cookies), actualCookieStrings);
+  }
+
+  @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
+    responseCookies.add(cookies);
+  }
+
+  @Override public List<Cookie> loadForRequest(HttpUrl url) {
+    if (requestCookies.isEmpty()) return Collections.emptyList();
+    return requestCookies.removeFirst();
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/com/squareup/okhttp/testing/RecordingHostnameVerifier.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
similarity index 96%
rename from okhttp-testing-support/src/main/java/com/squareup/okhttp/testing/RecordingHostnameVerifier.java
rename to okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
index d4d343a5f3..568b7c518c 100644
--- a/okhttp-testing-support/src/main/java/com/squareup/okhttp/testing/RecordingHostnameVerifier.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.testing;
+package okhttp3;
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java b/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
new file mode 100644
index 0000000000..bb6f519092
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.io;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import okio.Buffer;
+import okio.ForwardingSink;
+import okio.ForwardingSource;
+import okio.Sink;
+import okio.Source;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+/** A simple file system where all files are held in memory. Not safe for concurrent use. */
+public final class InMemoryFileSystem implements FileSystem, TestRule {
+  private final Map<File, Buffer> files = new LinkedHashMap<>();
+  private final Map<Source, File> openSources = new IdentityHashMap<>();
+  private final Map<Sink, File> openSinks = new IdentityHashMap<>();
+
+  @Override public Statement apply(final Statement base, Description description) {
+    return new Statement() {
+      @Override public void evaluate() throws Throwable {
+        base.evaluate();
+        ensureResourcesClosed();
+      }
+    };
+  }
+
+  public void ensureResourcesClosed() {
+    List<String> openResources = new ArrayList<>();
+    for (File file : openSources.values()) {
+      openResources.add("Source for " + file);
+    }
+    for (File file : openSinks.values()) {
+      openResources.add("Sink for " + file);
+    }
+    if (!openResources.isEmpty()) {
+      StringBuilder builder = new StringBuilder("Resources acquired but not closed:");
+      for (String resource : openResources) {
+        builder.append("\n * ").append(resource);
+      }
+      throw new IllegalStateException(builder.toString());
+    }
+  }
+
+  @Override public Source source(File file) throws FileNotFoundException {
+    Buffer result = files.get(file);
+    if (result == null) throw new FileNotFoundException();
+
+    final Source source = result.clone();
+    openSources.put(source, file);
+
+    return new ForwardingSource(source) {
+      @Override public void close() throws IOException {
+        openSources.remove(source);
+        super.close();
+      }
+    };
+  }
+
+  @Override public Sink sink(File file) throws FileNotFoundException {
+    return sink(file, false);
+  }
+
+  @Override public Sink appendingSink(File file) throws FileNotFoundException {
+    return sink(file, true);
+  }
+
+  private Sink sink(File file, boolean appending) {
+    Buffer result = null;
+    if (appending) {
+      result = files.get(file);
+    }
+    if (result == null) {
+      result = new Buffer();
+    }
+    files.put(file, result);
+
+    final Sink sink = result;
+    openSinks.put(sink, file);
+
+    return new ForwardingSink(sink) {
+      @Override public void close() throws IOException {
+        openSinks.remove(sink);
+        super.close();
+      }
+    };
+  }
+
+  @Override public void delete(File file) throws IOException {
+    files.remove(file);
+  }
+
+  @Override public boolean exists(File file) {
+    return files.containsKey(file);
+  }
+
+  @Override public long size(File file) {
+    Buffer buffer = files.get(file);
+    return buffer != null ? buffer.size() : 0L;
+  }
+
+  @Override public void rename(File from, File to) throws IOException {
+    Buffer buffer = files.remove(from);
+    if (buffer == null) throw new FileNotFoundException();
+    files.put(to, buffer);
+  }
+
+  @Override public void deleteContents(File directory) throws IOException {
+    String prefix = directory.toString() + "/";
+    for (Iterator<File> i = files.keySet().iterator(); i.hasNext(); ) {
+      File file = i.next();
+      if (file.toString().startsWith(prefix)) i.remove();
+    }
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/com/squareup/okhttp/testing/InstallUncaughtExceptionHandlerListener.java b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
similarity index 90%
rename from okhttp-testing-support/src/main/java/com/squareup/okhttp/testing/InstallUncaughtExceptionHandlerListener.java
rename to okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
index 4dd4c92e94..38652c07de 100644
--- a/okhttp-testing-support/src/main/java/com/squareup/okhttp/testing/InstallUncaughtExceptionHandlerListener.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
@@ -13,20 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.testing;
+package okhttp3.testing;
 
+import java.io.PrintWriter;
+import java.io.StringWriter;
 import org.junit.runner.Description;
 import org.junit.runner.Result;
 import org.junit.runner.notification.RunListener;
 
-import java.io.PrintWriter;
-import java.io.StringWriter;
-
 /**
- * A {@link org.junit.runner.notification.RunListener} used to install an aggressive default
- * {@link java.lang.Thread.UncaughtExceptionHandler} similar to the one found on Android.
- * No exceptions should escape from OkHttp that might cause apps to be killed or tests to fail on
- * Android.
+ * A {@link org.junit.runner.notification.RunListener} used to install an aggressive default {@link
+ * java.lang.Thread.UncaughtExceptionHandler} similar to the one found on Android. No exceptions
+ * should escape from OkHttp that might cause apps to be killed or tests to fail on Android.
  */
 public class InstallUncaughtExceptionHandlerListener extends RunListener {
 
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index ae31be751a..137a079310 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.5.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
@@ -18,18 +18,18 @@
       <artifactId>okio</artifactId>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-testing-support</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-urlconnection</artifactId>
       <version>${project.version}</version>
     </dependency>
@@ -40,16 +40,11 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>mockwebserver</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
-      <scope>test</scope>
-    </dependency>
   </dependencies>
 
   <build>
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CertificatePinnerTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CertificatePinnerTest.java
deleted file mode 100644
index 91b5a590f1..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CertificatePinnerTest.java
+++ /dev/null
@@ -1,253 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.SslContextBuilder;
-import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.cert.X509Certificate;
-import java.util.Set;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import okio.ByteString;
-import org.junit.Test;
-
-import static com.squareup.okhttp.TestUtil.setOf;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class CertificatePinnerTest {
-  static SslContextBuilder sslContextBuilder;
-
-  static KeyPair keyPairA;
-  static X509Certificate keypairACertificate1;
-  static String keypairACertificate1Pin;
-  static ByteString keypairACertificate1PinBase64;
-
-  static KeyPair keyPairB;
-  static X509Certificate keypairBCertificate1;
-  static String keypairBCertificate1Pin;
-  static ByteString keypairBCertificate1PinBase64;
-
-  static KeyPair keyPairC;
-  static X509Certificate keypairCCertificate1;
-  static String keypairCCertificate1Pin;
-
-  static {
-    try {
-      sslContextBuilder = new SslContextBuilder("example.com");
-
-      keyPairA = sslContextBuilder.generateKeyPair();
-      keypairACertificate1 = sslContextBuilder.selfSignedCertificate(keyPairA, "1");
-      keypairACertificate1Pin = CertificatePinner.pin(keypairACertificate1);
-      keypairACertificate1PinBase64 = pinToBase64(keypairACertificate1Pin);
-
-      keyPairB = sslContextBuilder.generateKeyPair();
-      keypairBCertificate1 = sslContextBuilder.selfSignedCertificate(keyPairB, "1");
-      keypairBCertificate1Pin = CertificatePinner.pin(keypairBCertificate1);
-      keypairBCertificate1PinBase64 = pinToBase64(keypairBCertificate1Pin);
-
-      keyPairC = sslContextBuilder.generateKeyPair();
-      keypairCCertificate1 = sslContextBuilder.selfSignedCertificate(keyPairC, "1");
-      keypairCCertificate1Pin = CertificatePinner.pin(keypairCCertificate1);
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  static ByteString pinToBase64(String pin) {
-    return ByteString.decodeBase64(pin.substring("sha1/".length()));
-  }
-
-  @Test public void malformedPin() throws Exception {
-    CertificatePinner.Builder builder = new CertificatePinner.Builder();
-    try {
-      builder.add("example.com", "md5/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void malformedBase64() throws Exception {
-    CertificatePinner.Builder builder = new CertificatePinner.Builder();
-    try {
-      builder.add("example.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw*");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  /** Multiple certificates generated from the same keypair have the same pin. */
-  @Test public void sameKeypairSamePin() throws Exception {
-    X509Certificate keypairACertificate2 = sslContextBuilder.selfSignedCertificate(keyPairA, "2");
-    String keypairACertificate2Pin = CertificatePinner.pin(keypairACertificate2);
-
-    X509Certificate keypairBCertificate2 = sslContextBuilder.selfSignedCertificate(keyPairB, "2");
-    String keypairBCertificate2Pin = CertificatePinner.pin(keypairBCertificate2);
-
-    assertTrue(keypairACertificate1Pin.equals(keypairACertificate2Pin));
-    assertTrue(keypairBCertificate1Pin.equals(keypairBCertificate2Pin));
-    assertFalse(keypairACertificate1Pin.equals(keypairBCertificate1Pin));
-  }
-
-  @Test public void successfulCheck() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", keypairACertificate1Pin)
-        .build();
-
-    certificatePinner.check("example.com", keypairACertificate1);
-  }
-
-  @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", keypairBCertificate1Pin)
-        .build();
-
-    certificatePinner.check("example.com", keypairACertificate1, keypairBCertificate1);
-  }
-
-  @Test public void unsuccessfulCheck() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", keypairACertificate1Pin)
-        .build();
-
-    try {
-      certificatePinner.check("example.com", keypairBCertificate1);
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void multipleCertificatesForOneHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", keypairACertificate1Pin, keypairBCertificate1Pin)
-        .build();
-
-    certificatePinner.check("example.com", keypairACertificate1);
-    certificatePinner.check("example.com", keypairBCertificate1);
-  }
-
-  @Test public void multipleHostnamesForOneCertificate() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", keypairACertificate1Pin)
-        .add("www.example.com", keypairACertificate1Pin)
-        .build();
-
-    certificatePinner.check("example.com", keypairACertificate1);
-    certificatePinner.check("www.example.com", keypairACertificate1);
-  }
-
-  @Test public void absentHostnameMatches() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder().build();
-    certificatePinner.check("example.com", keypairACertificate1);
-  }
-
-  @Test public void successfulCheckForWildcardHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", keypairACertificate1Pin)
-        .build();
-
-    certificatePinner.check("a.example.com", keypairACertificate1);
-  }
-
-  @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", keypairBCertificate1Pin)
-        .build();
-
-    certificatePinner.check("a.example.com", keypairACertificate1, keypairBCertificate1);
-  }
-
-  @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", keypairACertificate1Pin)
-        .build();
-
-    try {
-      certificatePinner.check("a.example.com", keypairBCertificate1);
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void multipleCertificatesForOneWildcardHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", keypairACertificate1Pin, keypairBCertificate1Pin)
-        .build();
-
-    certificatePinner.check("a.example.com", keypairACertificate1);
-    certificatePinner.check("a.example.com", keypairBCertificate1);
-  }
-
-  @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", keypairACertificate1Pin)
-        .add("a.example.com", keypairBCertificate1Pin)
-        .build();
-
-    certificatePinner.check("a.example.com", keypairACertificate1);
-    certificatePinner.check("a.example.com", keypairBCertificate1);
-  }
-
-  @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", keypairACertificate1Pin)
-        .add("a.example.com", keypairBCertificate1Pin)
-        .build();
-
-    try {
-      certificatePinner.check("a.example.com", keypairCCertificate1);
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void successfulFindMatchingPins() {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("first.com", keypairACertificate1Pin, keypairBCertificate1Pin)
-        .add("second.com", keypairCCertificate1Pin)
-        .build();
-
-    Set<ByteString> expectedPins = setOf(keypairACertificate1PinBase64, keypairBCertificate1PinBase64);
-    Set<ByteString> matchedPins  = certificatePinner.findMatchingPins("first.com");
-
-    assertEquals(expectedPins, matchedPins);
-  }
-
-  @Test public void successfulFindMatchingPinsForWildcardAndDirectCertificates() {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", keypairACertificate1Pin)
-        .add("a.example.com", keypairBCertificate1Pin)
-        .add("b.example.com", keypairCCertificate1Pin)
-        .build();
-
-    Set<ByteString> expectedPins = setOf(keypairACertificate1PinBase64, keypairBCertificate1PinBase64);
-    Set<ByteString> matchedPins  = certificatePinner.findMatchingPins("a.example.com");
-
-    assertEquals(expectedPins, matchedPins);
-  }
-
-  @Test public void wildcardHostnameShouldNotMatchThroughDot() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", keypairACertificate1Pin)
-        .build();
-
-    assertNull(certificatePinner.findMatchingPins("example.com"));
-    assertNull(certificatePinner.findMatchingPins("a.b.example.com"));
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
deleted file mode 100644
index d528c7a906..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
+++ /dev/null
@@ -1,584 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
-import com.squareup.okhttp.internal.http.RecordingProxySelector;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.testing.RecordingHostnameVerifier;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.Executor;
-import javax.net.SocketFactory;
-import javax.net.ssl.SSLContext;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class ConnectionPoolTest {
-  static {
-    Internal.initializeInstanceForTests();
-  }
-
-  private static final List<ConnectionSpec> CONNECTION_SPECS = Util.immutableList(
-      ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
-
-  private static final int KEEP_ALIVE_DURATION_MS = 5000;
-
-  private SSLContext sslContext = SslContextBuilder.localhost();
-  private MockWebServer spdyServer;
-  private InetSocketAddress spdySocketAddress;
-  private Address spdyAddress;
-
-  private MockWebServer httpServer;
-  private Address httpAddress;
-  private InetSocketAddress httpSocketAddress;
-
-  private ConnectionPool pool;
-  private FakeExecutor cleanupExecutor;
-  private Connection httpA;
-  private Connection httpB;
-  private Connection httpC;
-  private Connection httpD;
-  private Connection httpE;
-  private Connection spdyA;
-
-  private Object owner;
-
-  @Before public void setUp() throws Exception {
-    setUp(2);
-  }
-
-  private void setUp(int poolSize) throws Exception {
-    SocketFactory socketFactory = SocketFactory.getDefault();
-    RecordingProxySelector proxySelector = new RecordingProxySelector();
-
-    spdyServer = new MockWebServer();
-    httpServer = new MockWebServer();
-    spdyServer.useHttps(sslContext.getSocketFactory(), false);
-
-    httpServer.start();
-    httpAddress = new Address(httpServer.getHostName(), httpServer.getPort(), socketFactory, null,
-        null, null, AuthenticatorAdapter.INSTANCE, null,
-        Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1), CONNECTION_SPECS, proxySelector);
-    httpSocketAddress = new InetSocketAddress(InetAddress.getByName(httpServer.getHostName()),
-        httpServer.getPort());
-
-    spdyServer.start();
-    spdyAddress = new Address(spdyServer.getHostName(), spdyServer.getPort(), socketFactory,
-        sslContext.getSocketFactory(), new RecordingHostnameVerifier(), CertificatePinner.DEFAULT,
-        AuthenticatorAdapter.INSTANCE, null, Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1),
-        CONNECTION_SPECS, proxySelector);
-    spdySocketAddress = new InetSocketAddress(InetAddress.getByName(spdyServer.getHostName()),
-        spdyServer.getPort());
-
-    Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress);
-    Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress);
-    pool = new ConnectionPool(poolSize, KEEP_ALIVE_DURATION_MS);
-    // Disable the automatic execution of the cleanup.
-    cleanupExecutor = new FakeExecutor();
-    pool.replaceCleanupExecutorForTests(cleanupExecutor);
-    httpA = new Connection(pool, httpRoute);
-    httpA.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
-    httpB = new Connection(pool, httpRoute);
-    httpB.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
-    httpC = new Connection(pool, httpRoute);
-    httpC.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
-    httpD = new Connection(pool, httpRoute);
-    httpD.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
-    httpE = new Connection(pool, httpRoute);
-    httpE.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
-    spdyA = new Connection(pool, spdyRoute);
-    spdyA.connect(20000, 20000, 2000, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
-
-    owner = new Object();
-    httpA.setOwner(owner);
-    httpB.setOwner(owner);
-    httpC.setOwner(owner);
-    httpD.setOwner(owner);
-    httpE.setOwner(owner);
-  }
-
-  @After public void tearDown() throws Exception {
-    httpServer.shutdown();
-    spdyServer.shutdown();
-
-    Util.closeQuietly(httpA.getSocket());
-    Util.closeQuietly(httpB.getSocket());
-    Util.closeQuietly(httpC.getSocket());
-    Util.closeQuietly(httpD.getSocket());
-    Util.closeQuietly(httpE.getSocket());
-    Util.closeQuietly(spdyA.getSocket());
-  }
-
-  private void resetWithPoolSize(int poolSize) throws Exception {
-    tearDown();
-    setUp(poolSize);
-  }
-
-  @Test public void poolSingleHttpConnection() throws Exception {
-    resetWithPoolSize(1);
-    Connection connection = pool.get(httpAddress);
-    assertNull(connection);
-
-    connection = new Connection(pool, new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress));
-    connection.connect(200, 200, 200, null, CONNECTION_SPECS, false /* connectionRetryEnabled */);
-    connection.setOwner(owner);
-    assertEquals(0, pool.getConnectionCount());
-
-    pool.recycle(connection);
-    assertNull(connection.getOwner());
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getMultiplexedConnectionCount());
-
-    Connection recycledConnection = pool.get(httpAddress);
-    assertNull(connection.getOwner());
-    assertEquals(connection, recycledConnection);
-    assertTrue(recycledConnection.isAlive());
-
-    recycledConnection = pool.get(httpAddress);
-    assertNull(recycledConnection);
-  }
-
-  @Test public void getDoesNotScheduleCleanup() {
-    Connection connection = pool.get(httpAddress);
-    assertNull(connection);
-    cleanupExecutor.assertExecutionScheduled(false);
-  }
-
-  @Test public void recycleSchedulesCleanup() {
-    cleanupExecutor.assertExecutionScheduled(false);
-    pool.recycle(httpA);
-    cleanupExecutor.assertExecutionScheduled(true);
-  }
-
-  @Test public void shareSchedulesCleanup() {
-    cleanupExecutor.assertExecutionScheduled(false);
-    pool.share(spdyA);
-    cleanupExecutor.assertExecutionScheduled(true);
-  }
-
-  @Test public void poolPrefersMostRecentlyRecycled() throws Exception {
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    pool.recycle(httpC);
-    assertPooled(pool, httpC, httpB, httpA);
-
-    pool.performCleanup();
-    assertPooled(pool, httpC, httpB);
-  }
-
-  @Test public void getSpdyConnection() throws Exception {
-    pool.share(spdyA);
-    assertSame(spdyA, pool.get(spdyAddress));
-    assertPooled(pool, spdyA);
-  }
-
-  @Test public void getHttpConnection() throws Exception {
-    pool.recycle(httpA);
-    assertSame(httpA, pool.get(httpAddress));
-    assertPooled(pool);
-  }
-
-  @Test public void expiredConnectionNotReturned() throws Exception {
-    pool.recycle(httpA);
-
-    // Allow enough time to pass so that the connection is now expired.
-    Thread.sleep(KEEP_ALIVE_DURATION_MS * 2);
-
-    // The connection is held, but will not be returned.
-    assertNull(pool.get(httpAddress));
-    assertPooled(pool, httpA);
-
-    // The connection must be cleaned up.
-    pool.performCleanup();
-    assertPooled(pool);
-  }
-
-  @Test public void maxIdleConnectionLimitIsEnforced() throws Exception {
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    pool.recycle(httpC);
-    pool.recycle(httpD);
-    assertPooled(pool, httpD, httpC, httpB, httpA);
-
-    pool.performCleanup();
-    assertPooled(pool, httpD, httpC);
-  }
-
-  @Test public void expiredConnectionsAreEvicted() throws Exception {
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-
-    // Allow enough time to pass so that the connections are now expired.
-    Thread.sleep(2 * KEEP_ALIVE_DURATION_MS);
-    assertPooled(pool, httpB, httpA);
-
-    // The connections must be cleaned up.
-    pool.performCleanup();
-    assertPooled(pool);
-  }
-
-  @Test public void nonAliveConnectionNotReturned() throws Exception {
-    pool.recycle(httpA);
-
-    // Close the connection. It is an ex-connection. It has ceased to be.
-    httpA.getSocket().close();
-    assertPooled(pool, httpA);
-    assertNull(pool.get(httpAddress));
-
-    // The connection must be cleaned up.
-    pool.performCleanup();
-    assertPooled(pool);
-  }
-
-  @Test public void differentAddressConnectionNotReturned() throws Exception {
-    pool.recycle(httpA);
-    assertNull(pool.get(spdyAddress));
-    assertPooled(pool, httpA);
-  }
-
-  @Test public void gettingSpdyConnectionPromotesItToFrontOfQueue() throws Exception {
-    pool.share(spdyA);
-    pool.recycle(httpA);
-    assertPooled(pool, httpA, spdyA);
-    assertSame(spdyA, pool.get(spdyAddress));
-    assertPooled(pool, spdyA, httpA);
-  }
-
-  @Test public void gettingConnectionReturnsOldestFirst() throws Exception {
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    assertSame(httpA, pool.get(httpAddress));
-  }
-
-  @Test public void recyclingNonAliveConnectionClosesThatConnection() throws Exception {
-    httpA.getSocket().shutdownInput();
-    pool.recycle(httpA); // Should close httpA.
-    assertTrue(httpA.getSocket().isClosed());
-
-    // The pool should remain empty, and there is no need to schedule a cleanup.
-    assertPooled(pool);
-    cleanupExecutor.assertExecutionScheduled(false);
-  }
-
-  @Test public void shareHttpConnectionFails() throws Exception {
-    try {
-      pool.share(httpA);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    // The pool should remain empty, and there is no need to schedule a cleanup.
-    assertPooled(pool);
-    cleanupExecutor.assertExecutionScheduled(false);
-  }
-
-  @Test public void recycleSpdyConnectionDoesNothing() throws Exception {
-    pool.recycle(spdyA);
-    // The pool should remain empty, and there is no need to schedule the cleanup.
-    assertPooled(pool);
-    cleanupExecutor.assertExecutionScheduled(false);
-  }
-
-  @Test public void validateIdleSpdyConnectionTimeout() throws Exception {
-    pool.share(spdyA);
-    assertPooled(pool, spdyA); // Connection should be in the pool.
-
-    Thread.sleep((long) (KEEP_ALIVE_DURATION_MS * 0.7));
-    pool.performCleanup();
-    assertPooled(pool, spdyA); // Connection should still be in the pool.
-
-    Thread.sleep((long) (KEEP_ALIVE_DURATION_MS * 0.4));
-    pool.performCleanup();
-    assertPooled(pool); // Connection should have been removed.
-  }
-
-  @Test public void validateIdleHttpConnectionTimeout() throws Exception {
-    pool.recycle(httpA);
-    assertPooled(pool, httpA); // Connection should be in the pool.
-    cleanupExecutor.assertExecutionScheduled(true);
-
-    Thread.sleep((long) (KEEP_ALIVE_DURATION_MS * 0.7));
-    pool.performCleanup();
-    assertPooled(pool, httpA); // Connection should still be in the pool.
-
-    Thread.sleep((long) (KEEP_ALIVE_DURATION_MS * 0.4));
-    pool.performCleanup();
-    assertPooled(pool); // Connection should have been removed.
-  }
-
-  @Test public void maxConnections() throws IOException, InterruptedException {
-    // Pool should be empty.
-    assertEquals(0, pool.getConnectionCount());
-
-    // http A should be added to the pool.
-    pool.recycle(httpA);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getMultiplexedConnectionCount());
-
-    // http B should be added to the pool.
-    pool.recycle(httpB);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getMultiplexedConnectionCount());
-
-    // http C should be added
-    pool.recycle(httpC);
-    assertEquals(3, pool.getConnectionCount());
-    assertEquals(3, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getSpdyConnectionCount());
-
-    pool.performCleanup();
-
-    // http A should be removed by cleanup.
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getMultiplexedConnectionCount());
-
-    // spdy A should be added
-    pool.share(spdyA);
-    assertEquals(3, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    pool.performCleanup();
-
-    // http B should be removed by cleanup.
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getMultiplexedConnectionCount());
-
-    // http C should be returned.
-    Connection recycledHttpConnection = pool.get(httpAddress);
-    recycledHttpConnection.setOwner(owner);
-    assertNotNull(recycledHttpConnection);
-    assertTrue(recycledHttpConnection.isAlive());
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getMultiplexedConnectionCount());
-
-    // spdy A will be returned but also kept in the pool.
-    Connection sharedSpdyConnection = pool.get(spdyAddress);
-    assertNotNull(sharedSpdyConnection);
-    assertEquals(spdyA, sharedSpdyConnection);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getMultiplexedConnectionCount());
-
-    // http C should be added to the pool
-    pool.recycle(httpC);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getMultiplexedConnectionCount());
-
-    // An http connection should be removed from the pool.
-    recycledHttpConnection = pool.get(httpAddress);
-    assertNotNull(recycledHttpConnection);
-    assertTrue(recycledHttpConnection.isAlive());
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getMultiplexedConnectionCount());
-
-    // spdy A will be returned but also kept in the pool.
-    sharedSpdyConnection = pool.get(spdyAddress);
-    assertEquals(spdyA, sharedSpdyConnection);
-    assertNotNull(sharedSpdyConnection);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getMultiplexedConnectionCount());
-
-    // http D should be added to the pool.
-    pool.recycle(httpD);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getMultiplexedConnectionCount());
-
-    // http E should be added to the pool.
-    pool.recycle(httpE);
-    assertEquals(3, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    pool.performCleanup();
-
-    // spdy A should be removed from the pool by cleanup.
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getMultiplexedConnectionCount());
-  }
-
-  @Test public void connectionCleanup() throws Exception {
-    ConnectionPool pool = new ConnectionPool(10, KEEP_ALIVE_DURATION_MS);
-
-    // Add 3 connections to the pool.
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    pool.share(spdyA);
-
-    // Give the cleanup callable time to run and settle down.
-    Thread.sleep(100);
-
-    // Kill http A.
-    Util.closeQuietly(httpA.getSocket());
-
-    assertEquals(3, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // Http A should be removed.
-    pool.performCleanup();
-    assertPooled(pool, spdyA, httpB);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getMultiplexedConnectionCount());
-
-    // Now let enough time pass for the connections to expire.
-    Thread.sleep(2 * KEEP_ALIVE_DURATION_MS);
-
-    // All remaining connections should be removed.
-    pool.performCleanup();
-    assertEquals(0, pool.getConnectionCount());
-  }
-
-  @Test public void maxIdleConnectionsLimitEnforced() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-
-    // Hit the max idle connections limit of 2.
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    Thread.sleep(100); // Give the cleanup callable time to run.
-    assertPooled(pool, httpB, httpA);
-
-    // Adding httpC bumps httpA.
-    pool.recycle(httpC);
-    Thread.sleep(100); // Give the cleanup callable time to run.
-    assertPooled(pool, httpC, httpB);
-
-    // Adding httpD bumps httpB.
-    pool.recycle(httpD);
-    Thread.sleep(100); // Give the cleanup callable time to run.
-    assertPooled(pool, httpD, httpC);
-
-    // Adding httpE bumps httpC.
-    pool.recycle(httpE);
-    Thread.sleep(100); // Give the cleanup callable time to run.
-    assertPooled(pool, httpE, httpD);
-  }
-
-  @Test public void evictAllConnections() throws Exception {
-    resetWithPoolSize(10);
-    pool.recycle(httpA);
-    Util.closeQuietly(httpA.getSocket()); // Include a closed connection in the pool.
-    pool.recycle(httpB);
-    pool.share(spdyA);
-    int connectionCount = pool.getConnectionCount();
-    assertTrue(connectionCount == 2 || connectionCount == 3);
-
-    pool.evictAll();
-    assertEquals(0, pool.getConnectionCount());
-  }
-
-  @Test public void closeIfOwnedBy() throws Exception {
-    httpA.closeIfOwnedBy(owner);
-    assertFalse(httpA.isAlive());
-    assertFalse(httpA.clearOwner());
-  }
-
-  @Test public void closeIfOwnedByDoesNothingIfNotOwner() throws Exception {
-    httpA.closeIfOwnedBy(new Object());
-    assertTrue(httpA.isAlive());
-    assertTrue(httpA.clearOwner());
-  }
-
-  @Test public void closeIfOwnedByFailsForSpdyConnections() throws Exception {
-    try {
-      spdyA.closeIfOwnedBy(owner);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cleanupRunnableStopsEventually() throws Exception {
-    pool.recycle(httpA);
-    pool.share(spdyA);
-    assertPooled(pool, spdyA, httpA);
-
-    // The cleanup should terminate once the pool is empty again.
-    cleanupExecutor.fakeExecute();
-    assertPooled(pool);
-
-    cleanupExecutor.assertExecutionScheduled(false);
-
-    // Adding a new connection should cause the cleanup to start up again.
-    pool.recycle(httpB);
-
-    cleanupExecutor.assertExecutionScheduled(true);
-
-    // The cleanup should terminate once the pool is empty again.
-    cleanupExecutor.fakeExecute();
-    assertPooled(pool);
-  }
-
-  private void assertPooled(ConnectionPool pool, Connection... connections) throws Exception {
-    assertEquals(Arrays.asList(connections), pool.getConnections());
-  }
-
-  /**
-   * An executor that does not actually execute anything by default. See
-   * {@link #fakeExecute()}.
-   */
-  private static class FakeExecutor implements Executor {
-
-    private Runnable runnable;
-
-    @Override
-    public void execute(Runnable runnable) {
-      // This is a bonus assertion for the invariant: At no time should two runnables be scheduled.
-      assertNull(this.runnable);
-      this.runnable = runnable;
-    }
-
-    public void assertExecutionScheduled(boolean expected) {
-      assertEquals(expected, runnable != null);
-    }
-
-    /**
-     * Executes the runnable.
-     */
-    public void fakeExecute() {
-      Runnable toRun = this.runnable;
-      this.runnable = null;
-      toRun.run();
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
deleted file mode 100644
index 7f2635b306..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.RecordingAuthenticator;
-import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
-import com.squareup.okhttp.internal.http.RecordingProxySelector;
-import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
-import java.io.IOException;
-import java.net.Authenticator;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.CookieHandler;
-import java.net.CookieManager;
-import java.net.ProxySelector;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.TimeUnit;
-import javax.net.SocketFactory;
-import org.junit.After;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class OkHttpClientTest {
-  private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
-  private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
-  private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();
-  private static final Authenticator DEFAULT_AUTHENTICATOR = null; // No Authenticator.getDefault().
-
-  @After public void tearDown() throws Exception {
-    ProxySelector.setDefault(DEFAULT_PROXY_SELECTOR);
-    CookieManager.setDefault(DEFAULT_COOKIE_HANDLER);
-    ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
-    Authenticator.setDefault(DEFAULT_AUTHENTICATOR);
-  }
-
-  @Test public void timeoutDefaults() {
-    OkHttpClient client = new OkHttpClient();
-    assertEquals(10_000, client.getConnectTimeout());
-    assertEquals(10_000, client.getReadTimeout());
-    assertEquals(10_000, client.getWriteTimeout());
-  }
-
-  @Test public void timeoutValidRange() {
-    OkHttpClient client = new OkHttpClient();
-    try {
-      client.setConnectTimeout(1, TimeUnit.NANOSECONDS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      client.setWriteTimeout(1, TimeUnit.NANOSECONDS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      client.setReadTimeout(1, TimeUnit.NANOSECONDS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      client.setConnectTimeout(365, TimeUnit.DAYS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      client.setWriteTimeout(365, TimeUnit.DAYS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      client.setReadTimeout(365, TimeUnit.DAYS);
-    } catch (IllegalArgumentException ignored) {
-    }
-  }
-
-  /** Confirm that {@code copyWithDefaults} gets expected constant values. */
-  @Test public void copyWithDefaultsWhenDefaultIsAConstant() throws Exception {
-    OkHttpClient client = new OkHttpClient().copyWithDefaults();
-    assertNull(client.internalCache());
-    assertEquals(10_000, client.getConnectTimeout());
-    assertEquals(10_000, client.getReadTimeout());
-    assertEquals(10_000, client.getWriteTimeout());
-    assertTrue(client.getFollowSslRedirects());
-    assertNull(client.getProxy());
-    assertEquals(Arrays.asList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1),
-        client.getProtocols());
-  }
-
-  /**
-   * Confirm that {@code copyWithDefaults} gets some default implementations
-   * from the core library.
-   */
-  @Test public void copyWithDefaultsWhenDefaultIsGlobal() throws Exception {
-    ProxySelector proxySelector = new RecordingProxySelector();
-    CookieManager cookieManager = new CookieManager();
-    Authenticator authenticator = new RecordingAuthenticator();
-    SocketFactory socketFactory = SocketFactory.getDefault(); // Global isn't configurable.
-    OkHostnameVerifier hostnameVerifier = OkHostnameVerifier.INSTANCE; // Global isn't configurable.
-    CertificatePinner certificatePinner = CertificatePinner.DEFAULT; // Global isn't configurable.
-
-    CookieManager.setDefault(cookieManager);
-    ProxySelector.setDefault(proxySelector);
-    Authenticator.setDefault(authenticator);
-
-    OkHttpClient client = new OkHttpClient().copyWithDefaults();
-
-    assertSame(proxySelector, client.getProxySelector());
-    assertSame(cookieManager, client.getCookieHandler());
-    assertSame(AuthenticatorAdapter.INSTANCE, client.getAuthenticator());
-    assertSame(socketFactory, client.getSocketFactory());
-    assertSame(hostnameVerifier, client.getHostnameVerifier());
-    assertSame(certificatePinner, client.getCertificatePinner());
-  }
-
-  /** There is no default cache. */
-  @Test public void copyWithDefaultsCacheIsNull() throws Exception {
-    OkHttpClient client = new OkHttpClient().copyWithDefaults();
-    assertNull(client.getCache());
-  }
-
-  @Test public void copyWithDefaultsDoesNotHonorGlobalResponseCache() {
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        throw new AssertionError();
-      }
-
-      @Override public CacheRequest put(URI uri, URLConnection connection) {
-        throw new AssertionError();
-      }
-    });
-
-    OkHttpClient client = new OkHttpClient().copyWithDefaults();
-    assertNull(client.internalCache());
-  }
-
-  @Test public void clonedInterceptorsListsAreIndependent() throws Exception {
-    OkHttpClient original = new OkHttpClient();
-    OkHttpClient clone = original.clone();
-    clone.interceptors().add(null);
-    clone.networkInterceptors().add(null);
-    assertEquals(0, original.interceptors().size());
-    assertEquals(0, original.networkInterceptors().size());
-  }
-
-  /**
-   * When copying the client, stateful things like the connection pool are
-   * shared across all clients.
-   */
-  @Test public void cloneSharesStatefulInstances() throws Exception {
-    OkHttpClient client = new OkHttpClient();
-
-    // Values should be non-null.
-    OkHttpClient a = client.clone().copyWithDefaults();
-    assertNotNull(a.routeDatabase());
-    assertNotNull(a.getDispatcher());
-    assertNotNull(a.getConnectionPool());
-    assertNotNull(a.getSslSocketFactory());
-
-    // Multiple clients share the instances.
-    OkHttpClient b = client.clone().copyWithDefaults();
-    assertSame(a.routeDatabase(), b.routeDatabase());
-    assertSame(a.getDispatcher(), b.getDispatcher());
-    assertSame(a.getConnectionPool(), b.getConnectionPool());
-    assertSame(a.getSslSocketFactory(), b.getSslSocketFactory());
-  }
-
-  @Test public void setProtocolsRejectsHttp10() throws Exception {
-    OkHttpClient client = new OkHttpClient();
-    try {
-      client.setProtocols(Arrays.asList(Protocol.HTTP_1_0, Protocol.HTTP_1_1));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/TestUtil.java b/okhttp-tests/src/test/java/com/squareup/okhttp/TestUtil.java
deleted file mode 100644
index 9df55c6d53..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/TestUtil.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.framed.Header;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-
-public final class TestUtil {
-  private TestUtil() {
-  }
-
-  public static List<Header> headerEntries(String... elements) {
-    List<Header> result = new ArrayList<>(elements.length / 2);
-    for (int i = 0; i < elements.length; i += 2) {
-      result.add(new Header(elements[i], elements[i + 1]));
-    }
-    return result;
-  }
-
-  public static <T> Set<T> setOf(T... elements) {
-    return setOf(Arrays.asList(elements));
-  }
-
-  public static <T> Set<T> setOf(Collection<T> elements) {
-    return new LinkedHashSet<>(elements);
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
deleted file mode 100644
index 043234ec33..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
+++ /dev/null
@@ -1,360 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import java.io.IOException;
-import java.net.CookieHandler;
-import java.net.CookieManager;
-import java.net.HttpCookie;
-import java.net.HttpURLConnection;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-/** Android's CookiesTest. */
-public class CookiesTest {
-
-  private OkHttpClient client;
-
-  @Before
-  public void setUp() throws Exception {
-    client = new OkHttpClient();
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    CookieHandler.setDefault(null);
-  }
-
-  @Test
-  public void testNetscapeResponse() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    CookieHandler.setDefault(cookieManager);
-    MockWebServer server = new MockWebServer();
-    server.start();
-
-    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
-        + "expires=Fri, 31-Dec-9999 23:59:59 GMT; "
-        + "path=/path; "
-        + "domain=" + server.getCookieDomain() + "; "
-        + "secure"));
-    get(server, "/path/foo");
-
-    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertEquals(1, cookies.size());
-    HttpCookie cookie = cookies.get(0);
-    assertEquals("a", cookie.getName());
-    assertEquals("android", cookie.getValue());
-    assertEquals(null, cookie.getComment());
-    assertEquals(null, cookie.getCommentURL());
-    assertEquals(false, cookie.getDiscard());
-    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
-    assertTrue(cookie.getMaxAge() > 100000000000L);
-    assertEquals("/path", cookie.getPath());
-    assertEquals(true, cookie.getSecure());
-    assertEquals(0, cookie.getVersion());
-  }
-
-  @Test public void testRfc2109Response() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    CookieHandler.setDefault(cookieManager);
-    MockWebServer server = new MockWebServer();
-    server.start();
-
-    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
-        + "Comment=this cookie is delicious; "
-        + "Domain=" + server.getCookieDomain() + "; "
-        + "Max-Age=60; "
-        + "Path=/path; "
-        + "Secure; "
-        + "Version=1"));
-    get(server, "/path/foo");
-
-    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertEquals(1, cookies.size());
-    HttpCookie cookie = cookies.get(0);
-    assertEquals("a", cookie.getName());
-    assertEquals("android", cookie.getValue());
-    assertEquals("this cookie is delicious", cookie.getComment());
-    assertEquals(null, cookie.getCommentURL());
-    assertEquals(false, cookie.getDiscard());
-    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
-    assertEquals(60, cookie.getMaxAge());
-    assertEquals("/path", cookie.getPath());
-    assertEquals(true, cookie.getSecure());
-    assertEquals(1, cookie.getVersion());
-  }
-
-  @Test public void testRfc2965Response() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    CookieHandler.setDefault(cookieManager);
-    MockWebServer server = new MockWebServer();
-    server.start();
-
-    server.enqueue(new MockResponse().addHeader("Set-Cookie2: a=android; "
-        + "Comment=this cookie is delicious; "
-        + "CommentURL=http://google.com/; "
-        + "Discard; "
-        + "Domain=" + server.getCookieDomain() + "; "
-        + "Max-Age=60; "
-        + "Path=/path; "
-        + "Port=\"80,443," + server.getPort() + "\"; "
-        + "Secure; "
-        + "Version=1"));
-    get(server, "/path/foo");
-
-    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertEquals(1, cookies.size());
-    HttpCookie cookie = cookies.get(0);
-    assertEquals("a", cookie.getName());
-    assertEquals("android", cookie.getValue());
-    assertEquals("this cookie is delicious", cookie.getComment());
-    assertEquals("http://google.com/", cookie.getCommentURL());
-    assertEquals(true, cookie.getDiscard());
-    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
-    assertEquals(60, cookie.getMaxAge());
-    assertEquals("/path", cookie.getPath());
-    assertEquals("80,443," + server.getPort(), cookie.getPortlist());
-    assertEquals(true, cookie.getSecure());
-    assertEquals(1, cookie.getVersion());
-  }
-
-  @Test public void testQuotedAttributeValues() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    CookieHandler.setDefault(cookieManager);
-    MockWebServer server = new MockWebServer();
-    server.start();
-
-    server.enqueue(new MockResponse().addHeader("Set-Cookie2: a=\"android\"; "
-        + "Comment=\"this cookie is delicious\"; "
-        + "CommentURL=\"http://google.com/\"; "
-        + "Discard; "
-        + "Domain=\"" + server.getCookieDomain() + "\"; "
-        + "Max-Age=\"60\"; "
-        + "Path=\"/path\"; "
-        + "Port=\"80,443," + server.getPort() + "\"; "
-        + "Secure; "
-        + "Version=\"1\""));
-    get(server, "/path/foo");
-
-    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertEquals(1, cookies.size());
-    HttpCookie cookie = cookies.get(0);
-    assertEquals("a", cookie.getName());
-    assertEquals("android", cookie.getValue());
-    assertEquals("this cookie is delicious", cookie.getComment());
-    assertEquals("http://google.com/", cookie.getCommentURL());
-    assertEquals(true, cookie.getDiscard());
-    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
-    assertEquals(60, cookie.getMaxAge());
-    assertEquals("/path", cookie.getPath());
-    assertEquals("80,443," + server.getPort(), cookie.getPortlist());
-    assertEquals(true, cookie.getSecure());
-    assertEquals(1, cookie.getVersion());
-  }
-
-  @Test public void testSendingCookiesFromStore() throws Exception {
-    MockWebServer server = new MockWebServer();
-    server.enqueue(new MockResponse());
-    server.start();
-
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    HttpCookie cookieA = new HttpCookie("a", "android");
-    cookieA.setDomain(server.getCookieDomain());
-    cookieA.setPath("/");
-    cookieManager.getCookieStore().add(server.url("/").uri(), cookieA);
-    HttpCookie cookieB = new HttpCookie("b", "banana");
-    cookieB.setDomain(server.getCookieDomain());
-    cookieB.setPath("/");
-    cookieManager.getCookieStore().add(server.url("/").uri(), cookieB);
-    CookieHandler.setDefault(cookieManager);
-
-    get(server, "/");
-    RecordedRequest request = server.takeRequest();
-
-    assertEquals("$Version=\"1\"; "
-            + "a=\"android\";$Path=\"/\";$Domain=\""
-            + server.getCookieDomain()
-            + "\"; "
-            + "b=\"banana\";$Path=\"/\";$Domain=\""
-            + server.getCookieDomain()
-            + "\"", request.getHeader("Cookie"));
-  }
-
-  @Test public void testRedirectsDoNotIncludeTooManyCookies() throws Exception {
-    MockWebServer redirectTarget = new MockWebServer();
-    redirectTarget.enqueue(new MockResponse().setBody("A"));
-    redirectTarget.start();
-
-    MockWebServer redirectSource = new MockWebServer();
-    redirectSource.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + redirectTarget.url("/")));
-    redirectSource.start();
-
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    HttpCookie cookie = new HttpCookie("c", "cookie");
-    cookie.setDomain(redirectSource.getCookieDomain());
-    cookie.setPath("/");
-    String portList = Integer.toString(redirectSource.getPort());
-    cookie.setPortlist(portList);
-    cookieManager.getCookieStore().add(redirectSource.url("/").uri(), cookie);
-    CookieHandler.setDefault(cookieManager);
-
-    get(redirectSource, "/");
-    RecordedRequest request = redirectSource.takeRequest();
-
-    assertEquals("$Version=\"1\"; "
-            + "c=\"cookie\";$Path=\"/\";$Domain=\""
-            + redirectSource.getCookieDomain()
-            + "\";$Port=\""
-            + portList
-            + "\"", request.getHeader("Cookie"));
-
-    for (String header : redirectTarget.takeRequest().getHeaders().names()) {
-      if (header.startsWith("Cookie")) {
-        fail(header);
-      }
-    }
-  }
-
-  /**
-   * Test which headers show up where. The cookie manager should be notified
-   * of both user-specified and derived headers like {@code Host}. Headers
-   * named {@code Cookie} or {@code Cookie2} that are returned by the cookie
-   * manager should show up in the request and in {@code
-   * getRequestProperties}.
-   */
-  @Test public void testHeadersSentToCookieHandler() throws IOException, InterruptedException {
-    final Map<String, List<String>> cookieHandlerHeaders = new HashMap<>();
-    CookieHandler.setDefault(new CookieManager() {
-      @Override
-      public Map<String, List<String>> get(URI uri,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        cookieHandlerHeaders.putAll(requestHeaders);
-        Map<String, List<String>> result = new HashMap<>();
-        result.put("Cookie", Collections.singletonList("Bar=bar"));
-        result.put("Cookie2", Collections.singletonList("Baz=baz"));
-        result.put("Quux", Collections.singletonList("quux"));
-        return result;
-      }
-    });
-    MockWebServer server = new MockWebServer();
-    server.enqueue(new MockResponse());
-    server.start();
-
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
-    assertEquals(Collections.<String, List<String>>emptyMap(),
-        connection.getRequestProperties());
-
-    connection.setRequestProperty("Foo", "foo");
-    connection.setDoOutput(true);
-    connection.getOutputStream().write(5);
-    connection.getOutputStream().close();
-    connection.getInputStream().close();
-
-    RecordedRequest request = server.takeRequest();
-
-    assertContainsAll(cookieHandlerHeaders.keySet(), "Foo");
-    assertContainsAll(cookieHandlerHeaders.keySet(),
-        "Content-type", "User-Agent", "Connection", "Host");
-    assertFalse(cookieHandlerHeaders.containsKey("Cookie"));
-
-    /*
-     * The API specifies that calling getRequestProperties() on a connected instance should fail
-     * with an IllegalStateException, but the RI violates the spec and returns a valid map.
-     * http://www.mail-archive.com/net-dev@openjdk.java.net/msg01768.html
-     */
-    try {
-      assertContainsAll(connection.getRequestProperties().keySet(), "Foo");
-      assertContainsAll(connection.getRequestProperties().keySet(),
-          "Content-type", "Content-Length", "User-Agent", "Connection", "Host");
-      assertContainsAll(connection.getRequestProperties().keySet(), "Cookie", "Cookie2");
-      assertFalse(connection.getRequestProperties().containsKey("Quux"));
-    } catch (IllegalStateException expected) {
-    }
-
-    assertEquals("foo", request.getHeader("Foo"));
-    assertEquals("Bar=bar", request.getHeader("Cookie"));
-    assertEquals("Baz=baz", request.getHeader("Cookie2"));
-    assertNull(request.getHeader("Quux"));
-  }
-
-  @Test public void testCookiesSentIgnoresCase() throws Exception {
-    CookieHandler.setDefault(new CookieManager() {
-      @Override public Map<String, List<String>> get(URI uri,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        Map<String, List<String>> result = new HashMap<>();
-        result.put("COOKIE", Collections.singletonList("Bar=bar"));
-        result.put("cooKIE2", Collections.singletonList("Baz=baz"));
-        return result;
-      }
-    });
-    MockWebServer server = new MockWebServer();
-    server. enqueue(new MockResponse());
-    server.start();
-
-    get(server, "/");
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("Bar=bar", request.getHeader("Cookie"));
-    assertEquals("Baz=baz", request.getHeader("Cookie2"));
-    assertNull(request.getHeader("Quux"));
-  }
-
-  private void assertContains(Collection<String> collection, String element) {
-    for (String c : collection) {
-      if (c != null && c.equalsIgnoreCase(element)) {
-        return;
-      }
-    }
-    fail("No " + element + " in " + collection);
-  }
-
-  private void assertContainsAll(Collection<String> collection, String... toFind) {
-    for (String s : toFind) {
-      assertContains(collection, s);
-    }
-  }
-
-  private Map<String,List<String>> get(MockWebServer server, String path) throws Exception {
-    URLConnection connection = new OkUrlFactory(client).open(server.getUrl(path));
-    Map<String, List<String>> headers = connection.getHeaderFields();
-    connection.getInputStream().close();
-    return headers;
-  }
-
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
deleted file mode 100644
index 020c7f0e36..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.Util;
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.net.URL;
-import java.util.List;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLSession;
-
-import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
-
-public final class ExternalHttp2Example {
-  public static void main(String[] args) throws Exception {
-    URL url = new URL("https://twitter.com");
-    OkHttpClient client = new OkHttpClient()
-        .setProtocols(Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    HttpsURLConnection connection = (HttpsURLConnection) new OkUrlFactory(client)
-        .open(url);
-
-    connection.setHostnameVerifier(new HostnameVerifier() {
-      @Override public boolean verify(String s, SSLSession sslSession) {
-        System.out.println("VERIFYING " + s);
-        return true;
-      }
-    });
-
-    int responseCode = connection.getResponseCode();
-    System.out.println(responseCode);
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    // If null, probably you didn't add jetty's alpn jar to your boot classpath!
-    if (protocolValues != null && !protocolValues.isEmpty()) {
-      System.out.println("PROTOCOL " + protocolValues.get(0));
-    }
-
-    BufferedReader reader =
-        new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
-    String line;
-    while ((line = reader.readLine()) != null) {
-      System.out.println(line);
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
deleted file mode 100644
index a8009626c0..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.Util;
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.net.URL;
-import java.util.List;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLSession;
-
-import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
-
-public final class ExternalSpdyExample {
-  public static void main(String[] args) throws Exception {
-    URL url = new URL("https://www.google.ca/");
-    OkHttpClient client = new OkHttpClient()
-        .setProtocols(Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1));
-    HttpsURLConnection connection = (HttpsURLConnection) new OkUrlFactory(client)
-        .open(url);
-
-    connection.setHostnameVerifier(new HostnameVerifier() {
-      @Override public boolean verify(String s, SSLSession sslSession) {
-        System.out.println("VERIFYING " + s);
-        return true;
-      }
-    });
-
-    int responseCode = connection.getResponseCode();
-    System.out.println(responseCode);
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    // If null, probably you didn't add jetty's alpn jar to your boot classpath!
-    if (protocolValues != null && !protocolValues.isEmpty()) {
-      System.out.println("PROTOCOL " + protocolValues.get(0));
-    }
-
-    BufferedReader reader =
-        new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
-    String line;
-    while ((line = reader.readLine()) != null) {
-      System.out.println(line);
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp2Test.java
deleted file mode 100644
index 91ba56cef3..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp2Test.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.PushPromise;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-public class HttpOverHttp2Test extends HttpOverSpdyTest {
-
-  public HttpOverHttp2Test() {
-    super(Protocol.HTTP_2);
-    this.hostHeader = ":authority";
-  }
-
-  @Test public void serverSendsPushPromise_GET() throws Exception {
-    PushPromise pushPromise = new PushPromise("GET", "/foo/bar", Headers.of("foo", "bar"),
-        new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet"));
-    MockResponse response = new MockResponse()
-        .setBody("ABCDE")
-        .setStatus("HTTP/1.1 200 Sweet")
-        .withPush(pushPromise);
-    server.enqueue(response);
-
-    connection = client.open(server.getUrl("/foo"));
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Sweet", connection.getResponseMessage());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
-
-    RecordedRequest pushedRequest = server.takeRequest();
-    assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
-    assertEquals("bar", pushedRequest.getHeader("foo"));
-  }
-
-  @Test public void serverSendsPushPromise_HEAD() throws Exception {
-    PushPromise pushPromise = new PushPromise("HEAD", "/foo/bar", Headers.of("foo", "bar"),
-        new MockResponse().setStatus("HTTP/1.1 204 Sweet"));
-    MockResponse response = new MockResponse()
-        .setBody("ABCDE")
-        .setStatus("HTTP/1.1 200 Sweet")
-        .withPush(pushPromise);
-    server.enqueue(response);
-
-    connection = client.open(server.getUrl("/foo"));
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Sweet", connection.getResponseMessage());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
-
-    RecordedRequest pushedRequest = server.takeRequest();
-    assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
-    assertEquals("bar", pushedRequest.getHeader("foo"));
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
deleted file mode 100644
index 2d52eee13d..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ /dev/null
@@ -1,460 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Cache;
-import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.RecordingAuthenticator;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import com.squareup.okhttp.testing.RecordingHostnameVerifier;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.Authenticator;
-import java.net.CookieManager;
-import java.net.HttpURLConnection;
-import java.net.SocketTimeoutException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-
-/** Test how SPDY interacts with HTTP features. */
-public abstract class HttpOverSpdyTest {
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  /** Protocol to test, for example {@link com.squareup.okhttp.Protocol#SPDY_3} */
-  private final Protocol protocol;
-  protected String hostHeader = ":host";
-
-  protected SSLContext sslContext = SslContextBuilder.localhost();
-  protected HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  protected final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
-  protected HttpURLConnection connection;
-  protected Cache cache;
-
-  protected HttpOverSpdyTest(Protocol protocol){
-    this.protocol = protocol;
-  }
-
-  @Before public void setUp() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(hostnameVerifier);
-    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-  }
-
-  @After public void tearDown() throws Exception {
-    Authenticator.setDefault(null);
-  }
-
-  @Test public void get() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet");
-    server.enqueue(response);
-
-    connection = client.open(server.getUrl("/foo"));
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Sweet", connection.getResponseMessage());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
-  }
-
-  @Test public void emptyResponse() throws IOException {
-    server.enqueue(new MockResponse());
-
-    connection = client.open(server.getUrl("/foo"));
-    assertEquals(-1, connection.getInputStream().read());
-  }
-
-  byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
-
-  @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    connection = client.open(server.getUrl("/foo"));
-    connection.setDoOutput(true);
-    connection.setChunkedStreamingMode(0);
-    connection.getOutputStream().write(postBytes);
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertNull(request.getHeader("Content-Length"));
-  }
-
-  @Test public void userSuppliedContentLengthHeader() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    connection = client.open(server.getUrl("/foo"));
-    connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
-    connection.setDoOutput(true);
-    connection.getOutputStream().write(postBytes);
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
-  }
-
-  @Test public void closeAfterFlush() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    connection = client.open(server.getUrl("/foo"));
-    connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
-    connection.setDoOutput(true);
-    connection.getOutputStream().write(postBytes); // push bytes into SpdyDataOutputStream.buffer
-    connection.getOutputStream().flush(); // FramedConnection.writeData subject to write window
-    connection.getOutputStream().close(); // FramedConnection.writeData empty frame
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
-  }
-
-  @Test public void setFixedLengthStreamingModeSetsContentLength() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    connection = client.open(server.getUrl("/foo"));
-    connection.setFixedLengthStreamingMode(postBytes.length);
-    connection.setDoOutput(true);
-    connection.getOutputStream().write(postBytes);
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
-  }
-
-  @Test public void spdyConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDEF"));
-    server.enqueue(new MockResponse().setBody("GHIJKL"));
-
-    HttpURLConnection connection1 = client.open(server.getUrl("/r1"));
-    HttpURLConnection connection2 = client.open(server.getUrl("/r2"));
-    assertEquals("ABC", readAscii(connection1.getInputStream(), 3));
-    assertEquals("GHI", readAscii(connection2.getInputStream(), 3));
-    assertEquals("DEF", readAscii(connection1.getInputStream(), 3));
-    assertEquals("JKL", readAscii(connection2.getInputStream(), 3));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test @Ignore public void synchronousSpdyRequest() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.enqueue(new MockResponse().setBody("A"));
-
-    ExecutorService executor = Executors.newCachedThreadPool();
-    CountDownLatch countDownLatch = new CountDownLatch(2);
-    executor.execute(new SpdyRequest("/r1", countDownLatch));
-    executor.execute(new SpdyRequest("/r2", countDownLatch));
-    countDownLatch.await();
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void gzippedResponseBody() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Content-Encoding: gzip").setBody(gzip("ABCABCABC")));
-    assertContent("ABCABCABC", client.open(server.getUrl("/r1")), Integer.MAX_VALUE);
-  }
-
-  @Test public void authenticate() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
-        .addHeader("www-authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.getUrl("/"));
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest denied = server.takeRequest();
-    assertNull(denied.getHeader("Authorization"));
-    RecordedRequest accepted = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", accepted.getRequestLine());
-    assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-        accepted.getHeader("Authorization"));
-  }
-
-  @Test public void redirect() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-    connection = client.open(server.getUrl("/"));
-    assertContent("This is the new location!", connection, Integer.MAX_VALUE);
-
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("/", request1.getPath());
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("/foo", request2.getPath());
-  }
-
-  @Test public void readAfterLastByte() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC"));
-
-    connection = client.open(server.getUrl("/"));
-    InputStream in = connection.getInputStream();
-    assertEquals("ABC", readAscii(in, 3));
-    assertEquals(-1, in.read());
-    assertEquals(-1, in.read());
-  }
-
-  @Ignore // See https://github.com/square/okhttp/issues/578
-  @Test(timeout = 3000) public void readResponseHeaderTimeout() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
-    server.enqueue(new MockResponse().setBody("A"));
-
-    connection = client.open(server.getUrl("/"));
-    connection.setReadTimeout(1000);
-    assertContent("A", connection, Integer.MAX_VALUE);
-  }
-
-  /**
-   * Test to ensure we don't  throw a read timeout on responses that are
-   * progressing.  For this case, we take a 4KiB body and throttle it to
-   * 1KiB/second.  We set the read timeout to two seconds.  If our
-   * implementation is acting correctly, it will not throw, as it is
-   * progressing.
-   */
-  @Test public void readTimeoutMoreGranularThanBodySize() throws Exception {
-    char[] body = new char[4096]; // 4KiB to read
-    Arrays.fill(body, 'y');
-    server.enqueue(new MockResponse().setBody(new String(body)).throttleBody(1024, 1, SECONDS)); // slow connection 1KiB/second
-
-    connection = client.open(server.getUrl("/"));
-    connection.setReadTimeout(2000); // 2 seconds to read something.
-    assertContent(new String(body), connection, Integer.MAX_VALUE);
-  }
-
-  /**
-   * Test to ensure we throw a read timeout on responses that are progressing
-   * too slowly.  For this case, we take a 2KiB body and throttle it to
-   * 1KiB/second.  We set the read timeout to half a second.  If our
-   * implementation is acting correctly, it will throw, as a byte doesn't
-   * arrive in time.
-   */
-  @Test public void readTimeoutOnSlowConnection() throws Exception {
-    char[] body = new char[2048]; // 2KiB to read
-    Arrays.fill(body, 'y');
-    server.enqueue(new MockResponse()
-        .setBody(new String(body))
-        .throttleBody(1024, 1, SECONDS)); // slow connection 1KiB/second
-
-    connection = client.open(server.getUrl("/"));
-    connection.setReadTimeout(500); // half a second to read something
-    connection.connect();
-    try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-      fail("Should have timed out!");
-    } catch (SocketTimeoutException expected) {
-      assertEquals("timeout", expected.getMessage());
-    }
-  }
-
-  @Test public void spdyConnectionTimeout() throws Exception {
-    MockResponse response = new MockResponse().setBody("A");
-    response.setBodyDelay(1, TimeUnit.SECONDS);
-    server.enqueue(response);
-
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
-    connection1.setReadTimeout(2000);
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
-    connection2.setReadTimeout(200);
-    connection1.connect();
-    connection2.connect();
-    assertContent("A", connection1, Integer.MAX_VALUE);
-  }
-
-  @Test public void responsesAreCached() throws IOException {
-    client.client().setCache(cache);
-
-    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("A"));
-
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
-  }
-
-  @Test public void conditionalCache() throws IOException {
-    client.client().setCache(cache);
-
-    server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(2, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
-  }
-
-  @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
-    client.client().setCache(cache);
-
-    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("ABCD"));
-    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("EFGH"));
-
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
-    InputStream in1 = connection1.getInputStream();
-    assertEquals("AB", readAscii(in1, 2));
-    in1.close();
-
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
-    InputStream in2 = connection2.getInputStream();
-    assertEquals("ABCD", readAscii(in2, Integer.MAX_VALUE));
-    in2.close();
-  }
-
-  @Test public void acceptAndTransmitCookies() throws Exception {
-    CookieManager cookieManager = new CookieManager();
-    client.client().setCookieHandler(cookieManager);
-
-    server.enqueue(new MockResponse()
-        .addHeader("set-cookie: c=oreo; domain=" + server.getCookieDomain())
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertContent("A", client.open(url.url()), Integer.MAX_VALUE);
-    Map<String, List<String>> requestHeaders = Collections.emptyMap();
-    assertEquals(Collections.singletonMap("Cookie", Arrays.asList("c=oreo")),
-        cookieManager.get(url.uri(), requestHeaders));
-
-    assertContent("B", client.open(url.url()), Integer.MAX_VALUE);
-    RecordedRequest requestA = server.takeRequest();
-    assertNull(requestA.getHeader("Cookie"));
-    RecordedRequest requestB = server.takeRequest();
-    assertEquals("c=oreo", requestB.getHeader("Cookie"));
-  }
-
-  /** https://github.com/square/okhttp/issues/1191 */
-  @Test public void disconnectWithStreamNotEstablished() throws Exception {
-    ConnectionPool connectionPool = new ConnectionPool(5, 5000);
-    client.client().setConnectionPool(connectionPool);
-
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    // Disconnect before the stream is created. A connection is still established!
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
-    connection1.connect();
-    connection1.disconnect();
-
-    // That connection is pooled, and it works.
-    assertEquals(1, connectionPool.getSpdyConnectionCount());
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
-    assertContent("abc", connection2, 3);
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-  }
-
-  void assertContent(String expected, HttpURLConnection connection, int limit)
-      throws IOException {
-    connection.connect();
-    assertEquals(expected, readAscii(connection.getInputStream(), limit));
-  }
-
-  private String readAscii(InputStream in, int count) throws IOException {
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  public Buffer gzip(String bytes) throws IOException {
-    Buffer bytesOut = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
-    sink.writeUtf8(bytes);
-    sink.close();
-    return bytesOut;
-  }
-
-  class SpdyRequest implements Runnable {
-    String path;
-    CountDownLatch countDownLatch;
-    public SpdyRequest(String path, CountDownLatch countDownLatch) {
-      this.path = path;
-      this.countDownLatch = countDownLatch;
-    }
-
-    @Override public void run() {
-      try {
-        HttpURLConnection conn = client.open(server.getUrl(path));
-        assertEquals("A", readAscii(conn.getInputStream(), 1));
-        countDownLatch.countDown();
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/AddressTest.java b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
similarity index 74%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/AddressTest.java
rename to okhttp-tests/src/test/java/okhttp3/AddressTest.java
index 44c39a810e..30e376be5b 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/AddressTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/AddressTest.java
@@ -13,38 +13,38 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
-import com.squareup.okhttp.internal.http.RecordingProxySelector;
 import java.util.List;
 import javax.net.SocketFactory;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.RecordingProxySelector;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 
 public final class AddressTest {
+  private Dns dns = Dns.SYSTEM;
   private SocketFactory socketFactory = SocketFactory.getDefault();
-  private Authenticator authenticator = AuthenticatorAdapter.INSTANCE;
+  private Authenticator authenticator = Authenticator.NONE;
   private List<Protocol> protocols = Util.immutableList(Protocol.HTTP_1_1);
   private List<ConnectionSpec> connectionSpecs = Util.immutableList(ConnectionSpec.MODERN_TLS);
   private RecordingProxySelector proxySelector = new RecordingProxySelector();
 
   @Test public void equalsAndHashcode() throws Exception {
-    Address a = new Address("square.com", 80, socketFactory, null, null, null,
+    Address a = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, proxySelector);
-    Address b = new Address("square.com", 80, socketFactory, null, null, null,
+    Address b = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, proxySelector);
     assertEquals(a, b);
     assertEquals(a.hashCode(), b.hashCode());
   }
 
   @Test public void differentProxySelectorsAreDifferent() throws Exception {
-    Address a = new Address("square.com", 80, socketFactory, null, null, null,
+    Address a = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
-    Address b = new Address("square.com", 80, socketFactory, null, null, null,
+    Address b = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
     assertFalse(a.equals(b));
   }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheControlTest.java b/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
similarity index 99%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/CacheControlTest.java
rename to okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
index 5d1376737e..ef15052a93 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheControlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.util.concurrent.TimeUnit;
 import org.junit.Test;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
similarity index 85%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
rename to okhttp-tests/src/test/java/okhttp3/CacheTest.java
index b9e1d50139..418f7bd293 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
@@ -14,19 +14,10 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.io.FileSystem;
-import com.squareup.okhttp.internal.io.InMemoryFileSystem;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
+package okhttp3;
+
 import java.io.File;
 import java.io.IOException;
-import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
@@ -48,6 +39,13 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
+import okhttp3.internal.Internal;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.Util;
+import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -58,7 +56,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -66,7 +64,6 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-/** Test caching with {@link OkUrlFactory}. */
 public final class CacheTest {
   private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
     @Override public boolean verify(String s, SSLSession sslSession) {
@@ -76,23 +73,25 @@
 
   @Rule public MockWebServer server = new MockWebServer();
   @Rule public MockWebServer server2 = new MockWebServer();
+  @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
   private final SSLContext sslContext = SslContextBuilder.localhost();
-  private final FileSystem fileSystem = new InMemoryFileSystem();
-  private final OkHttpClient client = new OkHttpClient();
+  private OkHttpClient client;
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
 
   @Before public void setUp() throws Exception {
     server.setProtocolNegotiationEnabled(false);
     cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-    client.setCache(cache);
-    CookieHandler.setDefault(cookieManager);
+    client = new OkHttpClient.Builder()
+        .cache(cache)
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
   }
 
   @After public void tearDown() throws Exception {
     ResponseCache.setDefault(null);
-    CookieHandler.setDefault(null);
+    cache.delete();
   }
 
   /**
@@ -107,45 +106,45 @@
     // assertCached(false, 100);
     assertCached(false, 101);
     assertCached(false, 102);
-    assertCached(true,  200);
+    assertCached(true, 200);
     assertCached(false, 201);
     assertCached(false, 202);
-    assertCached(true,  203);
-    assertCached(true,  204);
+    assertCached(true, 203);
+    assertCached(true, 204);
     assertCached(false, 205);
     assertCached(false, 206); //Electing to not cache partial responses
     assertCached(false, 207);
-    assertCached(true,  300);
-    assertCached(true,  301);
-    assertCached(true,  302);
+    assertCached(true, 300);
+    assertCached(true, 301);
+    assertCached(true, 302);
     assertCached(false, 303);
     assertCached(false, 304);
     assertCached(false, 305);
     assertCached(false, 306);
-    assertCached(true,  307);
-    assertCached(true,  308);
+    assertCached(true, 307);
+    assertCached(true, 308);
     assertCached(false, 400);
     assertCached(false, 401);
     assertCached(false, 402);
     assertCached(false, 403);
-    assertCached(true,  404);
-    assertCached(true,  405);
+    assertCached(true, 404);
+    assertCached(true, 405);
     assertCached(false, 406);
     assertCached(false, 408);
     assertCached(false, 409);
     // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true,  410);
+    assertCached(true, 410);
     assertCached(false, 411);
     assertCached(false, 412);
     assertCached(false, 413);
-    assertCached(true,  414);
+    assertCached(true, 414);
     assertCached(false, 415);
     assertCached(false, 416);
     assertCached(false, 417);
     assertCached(false, 418);
 
     assertCached(false, 500);
-    assertCached(true,  501);
+    assertCached(true, 501);
     assertCached(false, 502);
     assertCached(false, 503);
     assertCached(false, 504);
@@ -154,6 +153,8 @@
   }
 
   private void assertCached(boolean shouldPut, int responseCode) throws Exception {
+    int expectedResponseCode = responseCode;
+
     server = new MockWebServer();
     MockResponse mockResponse = new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
@@ -170,13 +171,24 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
       mockResponse.setBody(""); // We forbid bodies for 204 and 205.
     }
     server.enqueue(mockResponse);
+
+    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
+      // 408's are a bit of an outlier because we may repeat the request if we encounter this
+      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
+      // because of the retry. We just want to ensure the initial 408 isn't cached.
+      expectedResponseCode = 200;
+      server.enqueue(new MockResponse()
+          .setHeader("Cache-Control", "no-store")
+          .setBody("FGHIJ"));
+    }
+
     server.start();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals(responseCode, response.code());
+    assertEquals(expectedResponseCode, response.code());
 
     // Exhaust the content stream.
     response.body().string();
@@ -225,8 +237,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals("spiders", in1.readUtf8("spiders".length()));
     assertTrue(in1.exhausted());
     in1.close();
-    assertEquals(1, cache.getWriteSuccessCount());
-    assertEquals(0, cache.getWriteAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
+    assertEquals(0, cache.writeAbortCount());
 
     Response response2 = client.newCall(request).execute();
     BufferedSource in2 = response2.body().source();
@@ -237,10 +249,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
     assertTrue(in2.exhausted());
     in2.close();
-    assertEquals(1, cache.getWriteSuccessCount());
-    assertEquals(0, cache.getWriteAbortCount());
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(1, cache.writeSuccessCount());
+    assertEquals(0, cache.writeAbortCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.hitCount());
   }
 
   @Test public void secureResponseCaching() throws IOException {
@@ -250,8 +262,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build();
 
     Request request = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request).execute();
@@ -259,20 +273,20 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals("ABC", in.readUtf8());
 
     // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    String suite = response1.handshake().cipherSuite();
+    CipherSuite cipherSuite = response1.handshake().cipherSuite();
     List<Certificate> localCerts = response1.handshake().localCertificates();
     List<Certificate> serverCerts = response1.handshake().peerCertificates();
     Principal peerPrincipal = response1.handshake().peerPrincipal();
     Principal localPrincipal = response1.handshake().localPrincipal();
 
     Response response2 = client.newCall(request).execute(); // Cached!
-    assertEquals("ABC", response2.body().source().readUtf8());
+    assertEquals("ABC", response2.body().string());
 
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(1, cache.hitCount());
 
-    assertEquals(suite, response2.handshake().cipherSuite());
+    assertEquals(cipherSuite, response2.handshake().cipherSuite());
     assertEquals(localCerts, response2.handshake().localCertificates());
     assertEquals(serverCerts, response2.handshake().peerCertificates());
     assertEquals(peerPrincipal, response2.handshake().peerPrincipal());
@@ -299,9 +313,9 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Response response2 = client.newCall(request).execute(); // Cached!
     assertEquals("ABC", response2.body().string());
 
-    assertEquals(4, cache.getRequestCount()); // 2 requests + 2 redirects
-    assertEquals(2, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 requests + 2 redirects
+    assertEquals(2, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void redirectToCachedResult() throws Exception {
@@ -351,8 +365,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse()
         .setBody("DEF"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build();
 
     Response response1 = get(server.url("/"));
     assertEquals("ABC", response1.body().string());
@@ -363,16 +379,15 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals("ABC", response2.body().string());
     assertNotNull(response2.handshake().cipherSuite());
 
-    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.hitCount());
     assertEquals(response1.handshake().cipherSuite(), response2.handshake().cipherSuite());
   }
 
   /**
-   * We've had bugs where caching and cross-protocol redirects yield class
-   * cast exceptions internal to the cache because we incorrectly assumed that
-   * HttpsURLConnection was always HTTPS and HttpURLConnection was always HTTP;
-   * in practice redirects mean that each can do either.
+   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
+   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
+   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
    *
    * https://github.com/square/okhttp/issues/214
    */
@@ -391,8 +406,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: " + server2.url("/")));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build();
 
     Response response1 = get(server.url("/"));
     assertEquals("ABC", response1.body().string());
@@ -401,8 +418,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Response response2 = get(server.url("/"));
     assertEquals("ABC", response2.body().string());
 
-    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void foundCachedWithExpiresHeader() throws Exception {
@@ -462,6 +479,26 @@ private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) th
     assertEquals("b", get(url).body().string());
   }
 
+  /** https://github.com/square/okhttp/issues/2198 */
+  @Test public void cachedRedirect() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Location: /bar"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    Request request1 = new Request.Builder().url(server.url("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("ABC", response1.body().string());
+
+    Request request2 = new Request.Builder().url(server.url("/")).build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("ABC", response2.body().string());
+  }
+
   @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
     testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
   }
@@ -493,12 +530,12 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
       bodySource.close();
     }
 
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(0, cache.getWriteSuccessCount());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(0, cache.writeSuccessCount());
     Response response = get(server.url("/"));
     assertEquals("Request #2", response.body().string());
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(1, cache.getWriteSuccessCount());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
   }
 
   @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
@@ -532,12 +569,12 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     } catch (IllegalStateException expected) {
     }
 
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(0, cache.getWriteSuccessCount());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(0, cache.writeSuccessCount());
     Response response2 = get(server.url("/"));
     assertEquals("Request #2", response2.body().string());
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(1, cache.getWriteSuccessCount());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
   }
 
   @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
@@ -740,8 +777,8 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
 
   private RequestBody requestBodyOrNull(String requestMethod) {
     return (requestMethod.equals("POST") || requestMethod.equals("PUT"))
-          ? RequestBody.create(MediaType.parse("text/plain"), "foo")
-          : null;
+        ? RequestBody.create(MediaType.parse("text/plain"), "foo")
+        : null;
   }
 
   @Test public void postInvalidatesCache() throws Exception {
@@ -1001,13 +1038,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    ConnectionPool pool = ConnectionPool.getDefault();
-    pool.evictAll();
-    client.setConnectionPool(pool);
-
     assertEquals("A", get(server.url("/")).body().string());
     assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, client.getConnectionPool().getConnectionCount());
+    assertEquals(1, client.connectionPool().idleConnectionCount());
   }
 
   @Test public void expiresDateBeforeModifiedDate() throws Exception {
@@ -1121,9 +1154,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     Response response = client.newCall(request).execute();
     assertTrue(response.body().source().exhausted());
     assertEquals(504, response.code());
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(0, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(1, cache.requestCount());
+    assertEquals(0, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
@@ -1139,9 +1172,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .build();
     Response response = client.newCall(request).execute();
     assertEquals("A", response.body().string());
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(1, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
@@ -1158,9 +1191,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     Response response = client.newCall(request).execute();
     assertTrue(response.body().source().exhausted());
     assertEquals(504, response.code());
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
@@ -1175,9 +1208,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     Response response = client.newCall(request).execute();
     assertTrue(response.body().source().exhausted());
     assertEquals(504, response.code());
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestCacheControlNoCache() throws Exception {
@@ -1262,8 +1295,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   /**
-   * For Last-Modified and Date headers, we should echo the date back in the
-   * exact format we were served.
+   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
+   * served.
    */
   @Test public void retainServedDateFormat() throws Exception {
     // Serve a response with a non-standard date format that OkHttp supports.
@@ -1366,14 +1399,14 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("C"));
 
     assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
     assertEquals("B", get(server.url("/")).body().string());
     assertEquals("C", get(server.url("/")).body().string());
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(3, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(3, cache.requestCount());
+    assertEquals(3, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void statisticsConditionalCacheHit() throws Exception {
@@ -1387,14 +1420,14 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
     assertEquals("A", get(server.url("/")).body().string());
     assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(3, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals(3, cache.requestCount());
+    assertEquals(3, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void statisticsFullCacheHit() throws Exception {
@@ -1403,14 +1436,14 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
 
     assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
     assertEquals("A", get(server.url("/")).body().string());
     assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals(3, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
@@ -1656,8 +1689,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build();
 
     HttpUrl url = server.url("/");
     Request request1 = new Request.Builder()
@@ -1676,20 +1711,25 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void cachePlusCookies() throws Exception {
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
     server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=FIRST; domain=" + server.getCookieDomain() + ";")
+        .addHeader("Set-Cookie: a=FIRST")
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
     server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
+        .addHeader("Set-Cookie: a=SECOND")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
-    assertCookies(url, "a=FIRST");
+    cookieJar.assertResponseCookies("a=FIRST; path=/");
     assertEquals("A", get(url).body().string());
-    assertCookies(url, "a=SECOND");
+    cookieJar.assertResponseCookies("a=SECOND; path=/");
   }
 
   @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
@@ -1774,7 +1814,7 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
     assertEquals(Arrays.asList(expectedCookies), actualCookies);
   }
 
-  @Test public void doNotCachePartialResponse() throws Exception  {
+  @Test public void doNotCachePartialResponse() throws Exception {
     assertNotCached(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
         .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
@@ -1873,13 +1913,13 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
 
     Response response = get(server.url("/"));
     assertEquals("A", response.header(""));
+    assertEquals("body", response.body().string());
   }
 
   /**
-   * Old implementations of OkHttp's response cache wrote header fields like
-   * ":status: 200 OK". This broke our cached response parser because it split
-   * on the first colon. This regression test exists to help us read these old
-   * bad cache entries.
+   * Old implementations of OkHttp's response cache wrote header fields like ":status: 200 OK". This
+   * broke our cached response parser because it split on the first colon. This regression test
+   * exists to help us read these old bad cache entries.
    *
    * https://github.com/square/okhttp/issues/227
    */
@@ -1923,11 +1963,13 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
         + "2\n"
         + "\n"
         + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.getDirectory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.getDirectory(), urlKey + ".1", entryBody);
-    writeFile(cache.getDirectory(), "journal", journalBody);
-    cache = new Cache(cache.getDirectory(), Integer.MAX_VALUE, fileSystem);
-    client.setCache(cache);
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
 
     Response response = get(url);
     assertEquals(entryBody, response.body().string());
@@ -1935,6 +1977,139 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
     assertEquals("foo", response.header("etag"));
   }
 
+  /** Exercise the cache format in OkHttp 2.7 and all earlier releases. */
+  @Test public void testGoldenCacheHttpsResponseOkHttp27() throws Exception {
+    HttpUrl url = server.url("/");
+    String urlKey = Util.md5Hex(url.toString());
+    String entryMetadata = ""
+        + "" + url + "\n"
+        + "GET\n"
+        + "0\n"
+        + "HTTP/1.1 200 OK\n"
+        + "4\n"
+        + "Content-Length: 3\n"
+        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
+        + "Cache-Control: max-age=60\n"
+        + "\n"
+        + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
+        + "1\n"
+        + "MIIBnDCCAQWgAwIBAgIBATANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTUxMjIyMDEx"
+        + "MTQwWhcNMTUxMjIzMDExMTQwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ"
+        + "AoGBAJTn2Dh8xYmegvpOSmsKb2Os6Cxf1L4fYbnHr/turInUD5r1P7ZAuxurY880q3GT5bUDoirS3IfucddrT1Ac"
+        + "AmUzEmk/FDjggiP8DlxFkY/XwXBlhRDVIp/mRuASPMGInckc0ZaixOkRFyrxADj+r1eaSmXCIvV5yTY6IaIokLj1"
+        + "AgMBAAEwDQYJKoZIhvcNAQELBQADgYEAFblnedqtfRqI9j2WDyPPoG0NTZf9xwjeUu+ju+Ktty8u9k7Lgrrd/DH2"
+        + "mQEtBD1Ctvp91MJfAClNg3faZzwClUyu5pd0QXRZEUwSwZQNen2QWDHRlVsItclBJ4t+AJLqTbwofWi4m4K8REOl"
+        + "593hD55E4+lY22JZiVQyjsQhe6I=\n"
+        + "0\n";
+    String entryBody = "abc";
+    String journalBody = ""
+        + "libcore.io.DiskLruCache\n"
+        + "1\n"
+        + "201105\n"
+        + "2\n"
+        + "\n"
+        + "DIRTY " + urlKey + "\n"
+        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache.close();
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Response response = get(url);
+    assertEquals(entryBody, response.body().string());
+    assertEquals("3", response.header("Content-Length"));
+  }
+
+  /** The TLS version is present in OkHttp 3.0 and beyond. */
+  @Test public void testGoldenCacheHttpsResponseOkHttp30() throws Exception {
+    HttpUrl url = server.url("/");
+    String urlKey = Util.md5Hex(url.toString());
+    String entryMetadata = ""
+        + "" + url + "\n"
+        + "GET\n"
+        + "0\n"
+        + "HTTP/1.1 200 OK\n"
+        + "4\n"
+        + "Content-Length: 3\n"
+        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
+        + "Cache-Control: max-age=60\n"
+        + "\n"
+        + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
+        + "1\n"
+        + "MIIBnDCCAQWgAwIBAgIBATANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTUxMjIyMDEx"
+        + "MTQwWhcNMTUxMjIzMDExMTQwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ"
+        + "AoGBAJTn2Dh8xYmegvpOSmsKb2Os6Cxf1L4fYbnHr/turInUD5r1P7ZAuxurY880q3GT5bUDoirS3IfucddrT1Ac"
+        + "AmUzEmk/FDjggiP8DlxFkY/XwXBlhRDVIp/mRuASPMGInckc0ZaixOkRFyrxADj+r1eaSmXCIvV5yTY6IaIokLj1"
+        + "AgMBAAEwDQYJKoZIhvcNAQELBQADgYEAFblnedqtfRqI9j2WDyPPoG0NTZf9xwjeUu+ju+Ktty8u9k7Lgrrd/DH2"
+        + "mQEtBD1Ctvp91MJfAClNg3faZzwClUyu5pd0QXRZEUwSwZQNen2QWDHRlVsItclBJ4t+AJLqTbwofWi4m4K8REOl"
+        + "593hD55E4+lY22JZiVQyjsQhe6I=\n"
+        + "0\n"
+        + "TLSv1.2\n";
+    String entryBody = "abc";
+    String journalBody = ""
+        + "libcore.io.DiskLruCache\n"
+        + "1\n"
+        + "201105\n"
+        + "2\n"
+        + "\n"
+        + "DIRTY " + urlKey + "\n"
+        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache.close();
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Response response = get(url);
+    assertEquals(entryBody, response.body().string());
+    assertEquals("3", response.header("Content-Length"));
+  }
+
+  @Test public void testGoldenCacheHttpResponseOkHttp30() throws Exception {
+    HttpUrl url = server.url("/");
+    String urlKey = Util.md5Hex(url.toString());
+    String entryMetadata = ""
+        + "" + url + "\n"
+        + "GET\n"
+        + "0\n"
+        + "HTTP/1.1 200 OK\n"
+        + "4\n"
+        + "Cache-Control: max-age=60\n"
+        + "Content-Length: 3\n"
+        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n";
+    String entryBody = "abc";
+    String journalBody = ""
+        + "libcore.io.DiskLruCache\n"
+        + "1\n"
+        + "201105\n"
+        + "2\n"
+        + "\n"
+        + "DIRTY " + urlKey + "\n"
+        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache.close();
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    Response response = get(url);
+    assertEquals(entryBody, response.body().string());
+    assertEquals("3", response.header("Content-Length"));
+  }
+
   @Test public void evictAll() throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
@@ -1944,8 +2119,8 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
 
     HttpUrl url = server.url("/");
     assertEquals("A", get(url).body().string());
-    client.getCache().evictAll();
-    assertEquals(0, client.getCache().getSize());
+    client.cache().evictAll();
+    assertEquals(0, client.cache().size());
     assertEquals("B", get(url).body().string());
   }
 
@@ -1961,12 +2136,13 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
     assertEquals("A", get(url).body().string());
 
     final AtomicReference<String> ifNoneMatch = new AtomicReference<>();
-    client.networkInterceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        ifNoneMatch.compareAndSet(null, chain.request().header("If-None-Match"));
-        return chain.proceed(chain.request());
-      }
-    });
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            ifNoneMatch.compareAndSet(null, chain.request().header("If-None-Match"));
+            return chain.proceed(chain.request());
+          }
+        }).build();
 
     // Confirm the value is cached and intercepted.
     assertEquals("A", get(url).body().string());
@@ -1983,11 +2159,12 @@ public void assertCookies(HttpUrl url, String... expectedCookies) throws Excepti
     assertEquals("A", get(url).body().string());
 
     // Confirm the interceptor isn't exercised.
-    client.networkInterceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        throw new AssertionError();
-      }
-    });
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            throw new AssertionError();
+          }
+        }).build();
     assertEquals("A", get(url).body().string());
   }
 
@@ -2150,7 +2327,6 @@ private Response get(HttpUrl url) throws IOException {
     return client.newCall(request).execute();
   }
 
-
   private void writeFile(File directory, String file, String content) throws IOException {
     BufferedSink sink = Okio.buffer(fileSystem.sink(new File(directory, file)));
     sink.writeUtf8(content);
@@ -2158,9 +2334,8 @@ private void writeFile(File directory, String file, String content) throws IOExc
   }
 
   /**
-   * @param delta the offset from the current date to use. Negative
-   * values yield dates in the past; positive values yield dates in the
-   * future.
+   * @param delta the offset from the current date to use. Negative values yield dates in the past;
+   * positive values yield dates in the future.
    */
   private String formatDate(long delta, TimeUnit timeUnit) {
     return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
@@ -2230,9 +2405,8 @@ private void assertFullyCached(MockResponse response) throws Exception {
   }
 
   /**
-   * Shortens the body of {@code response} but not the corresponding headers.
-   * Only useful to test how clients respond to the premature conclusion of
-   * the HTTP body.
+   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
+   * how clients respond to the premature conclusion of the HTTP body.
    */
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
     response.setSocketPolicy(DISCONNECT_AT_END);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
similarity index 58%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
rename to okhttp-tests/src/test/java/okhttp3/CallTest.java
index fb6f54597f..18ede8338d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -13,23 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.DoubleInetAddressNetwork;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.RecordingOkAuthenticator;
-import com.squareup.okhttp.internal.SingleInetAddressNetwork;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.Version;
-import com.squareup.okhttp.internal.io.FileSystem;
-import com.squareup.okhttp.internal.io.InMemoryFileSystem;
-import com.squareup.okhttp.mockwebserver.Dispatcher;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import com.squareup.okhttp.testing.RecordingHostnameVerifier;
+package okhttp3;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -40,11 +25,15 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.ProtocolException;
+import java.net.Proxy;
 import java.net.ServerSocket;
+import java.net.SocketTimeoutException;
+import java.net.UnknownHostException;
 import java.net.UnknownServiceException;
 import java.security.cert.Certificate;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
@@ -56,6 +45,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.logging.Logger;
 import javax.net.ServerSocketFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLHandshakeException;
@@ -63,6 +53,19 @@
 import javax.net.ssl.SSLProtocolException;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.internal.DoubleInetAddressDns;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.internal.http.RecordingProxySelector;
+import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -70,13 +73,14 @@
 import okio.Okio;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
 import org.junit.rules.Timeout;
 
-import static com.squareup.okhttp.internal.Internal.logger;
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotSame;
@@ -88,14 +92,15 @@
   @Rule public final TestRule timeout = new Timeout(30_000);
   @Rule public final MockWebServer server = new MockWebServer();
   @Rule public final MockWebServer server2 = new MockWebServer();
+  @Rule public final InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
   private SSLContext sslContext = SslContextBuilder.localhost();
-  private FileSystem fileSystem = new InMemoryFileSystem();
-  private OkHttpClient client = new OkHttpClient();
+  private OkHttpClient client = defaultClient();
   private RecordingCallback callback = new RecordingCallback();
   private TestLogHandler logHandler = new TestLogHandler();
   private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
   private ServerSocket nullServer;
+  private Logger logger = Logger.getLogger(OkHttpClient.class.getName());
 
   @Before public void setUp() throws Exception {
     logger.addHandler(logHandler);
@@ -108,18 +113,25 @@
   }
 
   @Test public void get() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc").addHeader("Content-Type: text/plain"));
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .clearHeaders()
+        .addHeader("content-type: text/plain")
+        .addHeader("content-length", "3"));
 
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("User-Agent", "SyncApiTest")
-        .build();
+    long sentAt = System.currentTimeMillis();
+    RecordedResponse recordedResponse = executeSynchronously("/", "User-Agent", "SyncApiTest");
+    long receivedAt = System.currentTimeMillis();
 
-    executeSynchronously(request)
-        .assertCode(200)
+    recordedResponse.assertCode(200)
         .assertSuccessful()
-        .assertHeader("Content-Type", "text/plain")
-        .assertBody("abc");
+        .assertHeaders(new Headers.Builder()
+            .add("content-type", "text/plain")
+            .add("content-length", "3")
+            .build())
+        .assertBody("abc")
+        .assertSentRequestAtMillis(sentAt, receivedAt)
+        .assertReceivedResponseAtMillis(sentAt, receivedAt);
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("GET", recordedRequest.getMethod());
@@ -130,14 +142,7 @@
 
   @Test public void buildRequestUsingHttpUrl() throws Exception {
     server.enqueue(new MockResponse());
-
-    HttpUrl httpUrl = server.url("/");
-    Request request = new Request.Builder()
-        .url(httpUrl)
-        .build();
-    assertEquals(httpUrl, request.httpUrl());
-
-    executeSynchronously(request).assertSuccessful();
+    executeSynchronously("/").assertSuccessful();
   }
 
   @Test public void invalidScheme() throws Exception {
@@ -162,24 +167,47 @@
 
   @Test public void getReturns500() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(500));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    executeSynchronously(request)
+    executeSynchronously("/")
         .assertCode(500)
         .assertNotSuccessful();
   }
 
+  @Test public void get_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    get();
+  }
+
+  @Test public void get_HTTPS() throws Exception {
+    enableTls();
+    get();
+  }
+
   @Test public void get_SPDY_3() throws Exception {
     enableProtocol(Protocol.SPDY_3);
     get();
   }
 
-  @Test public void get_HTTP_2() throws Exception {
+  @Test public void repeatedHeaderNames() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("B", "123")
+        .addHeader("B", "234"));
+
+    executeSynchronously("/", "A", "345", "A", "456")
+        .assertCode(200)
+        .assertHeader("B", "123", "234");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(Arrays.asList("345", "456"), recordedRequest.getHeaders().values("A"));
+  }
+
+  @Test public void repeatedHeaderNames_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    repeatedHeaderNames();
+  }
+
+  @Test public void repeatedHeaderNames_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
-    get();
+    repeatedHeaderNames();
   }
 
   @Test public void getWithRequestBody() throws Exception {
@@ -212,8 +240,8 @@
     assertNull(recordedRequest.getHeader("Content-Length"));
   }
 
-  @Test public void head_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
+  @Test public void head_HTTPS() throws Exception {
+    enableTls();
     head();
   }
 
@@ -222,6 +250,11 @@
     head();
   }
 
+  @Test public void head_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    head();
+  }
+
   @Test public void post() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -241,8 +274,8 @@
     assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
   }
 
-  @Test public void post_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
+  @Test public void post_HTTPS() throws Exception {
+    enableTls();
     post();
   }
 
@@ -251,6 +284,11 @@
     post();
   }
 
+  @Test public void post_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    post();
+  }
+
   @Test public void postZeroLength() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -270,8 +308,8 @@
     assertEquals(null, recordedRequest.getHeader("Content-Type"));
   }
 
-  @Test public void postZeroLength_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
+  @Test public void postZerolength_HTTPS() throws Exception {
+    enableTls();
     postZeroLength();
   }
 
@@ -280,12 +318,17 @@
     postZeroLength();
   }
 
+  @Test public void postZeroLength_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    postZeroLength();
+  }
+
   @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
     postBodyRetransmittedAfterAuthorizationFail("abc");
   }
 
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTPS() throws Exception {
+    enableTls();
     postBodyRetransmittedAfterAuthorizationFail("abc");
   }
 
@@ -294,13 +337,18 @@
     postBodyRetransmittedAfterAuthorizationFail("abc");
   }
 
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
   /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
   @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
     postBodyRetransmittedAfterAuthorizationFail("");
   }
 
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTPS() throws Exception {
+    enableTls();
     postBodyRetransmittedAfterAuthorizationFail("");
   }
 
@@ -309,6 +357,11 @@
     postBodyRetransmittedAfterAuthorizationFail("");
   }
 
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
   private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
     server.enqueue(new MockResponse().setResponseCode(401));
     server.enqueue(new MockResponse());
@@ -319,7 +372,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
 
     String credential = Credentials.basic("jesse", "secret");
-    client.setAuthenticator(new RecordingOkAuthenticator(credential));
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
 
     Response response = client.newCall(request).execute();
     assertEquals(200, response.code());
@@ -342,10 +397,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setBody("Success!"));
 
     String credential = Credentials.basic("jesse", "secret");
-    client.setAuthenticator(new RecordingOkAuthenticator(credential));
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
 
-    Request request = new Request.Builder().url(server.url("/")).build();
-    executeSynchronously(request)
+    executeSynchronously("/")
         .assertCode(200)
         .assertBody("Success!");
   }
@@ -356,7 +412,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
 
     String credential = Credentials.basic("jesse", "secret");
-    client.setAuthenticator(new RecordingOkAuthenticator(credential));
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
 
     try {
       client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
@@ -385,8 +443,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals(null, recordedRequest.getHeader("Content-Type"));
   }
 
-  @Test public void delete_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
+  @Test public void delete_HTTPS() throws Exception {
+    enableTls();
     delete();
   }
 
@@ -395,6 +453,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     delete();
   }
 
+  @Test public void delete_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    delete();
+  }
+
   @Test public void deleteWithRequestBody() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -431,8 +494,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
   }
 
-  @Test public void put_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
+  @Test public void put_HTTPS() throws Exception {
+    enableTls();
     put();
   }
 
@@ -441,6 +504,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     put();
   }
 
+  @Test public void put_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    put();
+  }
+
   @Test public void patch() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -460,13 +528,18 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
   }
 
-  @Test public void patch_SPDY_3() throws Exception {
-    enableProtocol(Protocol.SPDY_3);
+  @Test public void patch_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
     patch();
   }
 
-  @Test public void patch_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
+  @Test public void patch_HTTPS() throws Exception {
+    enableTls();
+    patch();
+  }
+
+  @Test public void patch_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
     patch();
   }
 
@@ -497,19 +570,20 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
 
     Call call = client.newCall(request);
-    call.execute();
+    Response response = call.execute();
+    response.body().close();
 
     try {
       call.execute();
       fail();
-    } catch (IllegalStateException e){
+    } catch (IllegalStateException e) {
       assertEquals("Already Executed", e.getMessage());
     }
 
     try {
       call.enqueue(callback);
       fail();
-    } catch (IllegalStateException e){
+    } catch (IllegalStateException e) {
       assertEquals("Already Executed", e.getMessage());
     }
 
@@ -532,14 +606,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     try {
       call.execute();
       fail();
-    } catch (IllegalStateException e){
+    } catch (IllegalStateException e) {
       assertEquals("Already Executed", e.getMessage());
     }
 
     try {
       call.enqueue(callback);
       fail();
-    } catch (IllegalStateException e){
+    } catch (IllegalStateException e) {
       assertEquals("Already Executed", e.getMessage());
     }
 
@@ -557,7 +631,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     client.newCall(request).enqueue(callback);
 
-    callback.await(request.httpUrl())
+    callback.await(request.url())
         .assertCode(200)
         .assertHeader("Content-Type", "text/plain")
         .assertBody("abc");
@@ -573,11 +647,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
 
     client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(Call call, IOException e) {
         fail();
       }
 
-      @Override public void onResponse(Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) throws IOException {
         throw new IOException("a");
       }
     });
@@ -591,14 +665,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setBody("def"));
     server.enqueue(new MockResponse().setBody("ghi"));
 
-    executeSynchronously(new Request.Builder().url(server.url("/a")).build())
-        .assertBody("abc");
-
-    executeSynchronously(new Request.Builder().url(server.url("/b")).build())
-        .assertBody("def");
-
-    executeSynchronously(new Request.Builder().url(server.url("/c")).build())
-        .assertBody("ghi");
+    executeSynchronously("/a").assertBody("abc");
+    executeSynchronously("/b").assertBody("def");
+    executeSynchronously("/c").assertBody("ghi");
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
@@ -630,11 +699,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder().url(server.url("/a")).build();
     client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(Call call, IOException e) {
         throw new AssertionError();
       }
 
-      @Override public void onResponse(Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) throws IOException {
         InputStream bytes = response.body().byteStream();
         assertEquals('a', bytes.read());
         assertEquals('b', bytes.read());
@@ -655,11 +724,15 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
 
     // First request: time out after 1000ms.
-    client.setReadTimeout(1000, TimeUnit.MILLISECONDS);
-    executeSynchronously(new Request.Builder().url(server.url("/a")).build()).assertBody("abc");
+    client = client.newBuilder()
+        .readTimeout(1000, TimeUnit.MILLISECONDS)
+        .build();
+    executeSynchronously("/a").assertBody("abc");
 
     // Second request: time out after 250ms.
-    client.setReadTimeout(250, TimeUnit.MILLISECONDS);
+    client = client.newBuilder()
+        .readTimeout(250, TimeUnit.MILLISECONDS)
+        .build();
     Request request = new Request.Builder().url(server.url("/b")).build();
     Response response = client.newCall(request).execute();
     BufferedSource bodySource = response.body().source();
@@ -674,19 +747,23 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       // Timed out as expected.
       long elapsedNanos = System.nanoTime() - startNanos;
       long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(elapsedNanos);
-      assertTrue(String.format("Timed out: %sms", elapsedMillis), elapsedMillis < 500);
+      assertTrue(Util.format("Timed out: %sms", elapsedMillis), elapsedMillis < 500);
+    } finally {
+      bodySource.close();
     }
   }
 
-  // https://github.com/square/okhttp/issues/442
-  @Test public void timeoutsNotRetried() throws Exception {
+  /** https://github.com/square/okhttp/issues/442 */
+  @Test public void tlsTimeoutsNotRetried() throws Exception {
+    enableTls();
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.NO_RESPONSE));
     server.enqueue(new MockResponse()
         .setBody("unreachable!"));
 
-    Internal.instance.setNetwork(client, new DoubleInetAddressNetwork());
-    client.setReadTimeout(100, TimeUnit.MILLISECONDS);
+    client = client.newBuilder()
+        .readTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
 
     Request request = new Request.Builder().url(server.url("/")).build();
     try {
@@ -697,6 +774,74 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
   }
 
+  /**
+   * Make a request with two routes. The first route will time out because it's connecting to a
+   * special address that never connects. The automatic retry will succeed.
+   */
+  @Test public void connectTimeoutsAttemptsAlternateRoute() throws Exception {
+    InetSocketAddress unreachableAddress = new InetSocketAddress("10.255.255.1", 8080);
+
+    RecordingProxySelector proxySelector = new RecordingProxySelector();
+    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, unreachableAddress));
+    proxySelector.proxies.add(server.toProxyAddress());
+
+    server.enqueue(new MockResponse()
+        .setBody("success!"));
+
+    client = client.newBuilder()
+        .proxySelector(proxySelector)
+        .readTimeout(100, TimeUnit.MILLISECONDS)
+        .connectTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    Request request = new Request.Builder().url("http://android.com/").build();
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("success!");
+  }
+
+  /**
+   * Make a request with two routes. The first route will fail because the null server connects but
+   * never responds. The manual retry will succeed.
+   */
+  @Test public void readTimeoutFails() throws Exception {
+    InetSocketAddress nullServerAddress = startNullServer();
+
+    RecordingProxySelector proxySelector = new RecordingProxySelector();
+    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, nullServerAddress));
+    proxySelector.proxies.add(server.toProxyAddress());
+
+    server.enqueue(new MockResponse()
+        .setBody("success!"));
+
+    client = client.newBuilder()
+        .proxySelector(proxySelector)
+        .readTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    Request request = new Request.Builder().url("http://android.com/").build();
+    executeSynchronously(request)
+        .assertFailure(SocketTimeoutException.class);
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("success!");
+  }
+
+  /** https://github.com/square/okhttp/issues/1801 */
+  @Test public void asyncCallEngineInitialized() throws Exception {
+    OkHttpClient c = new OkHttpClient.Builder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            throw new IOException();
+          }
+        })
+        .build();
+    Request request = new Request.Builder().url(server.url("/")).build();
+    c.newCall(request).enqueue(callback);
+    RecordedResponse response = callback.await(request.url());
+    assertEquals(request, response.request);
+  }
+
   @Test public void reusedSinksGetIndependentTimeoutInstances() throws Exception {
     server.enqueue(new MockResponse());
     server.enqueue(new MockResponse());
@@ -706,6 +851,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       @Override public MediaType contentType() {
         return MediaType.parse("text/plain");
       }
+
       @Override public void writeTo(BufferedSink sink) throws IOException {
         sink.writeUtf8("abc");
         sink.timeout().deadline(5, TimeUnit.SECONDS);
@@ -723,6 +869,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       @Override public MediaType contentType() {
         return MediaType.parse("text/plain");
       }
+
       @Override public void writeTo(BufferedSink sink) throws IOException {
         assertFalse(sink.timeout().hasDeadline());
         sink.writeUtf8("def");
@@ -764,61 +911,56 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void tls() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    enableTls();
     server.enqueue(new MockResponse()
         .setBody("abc")
         .addHeader("Content-Type: text/plain"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-
-    executeSynchronously(new Request.Builder().url(server.url("/")).build())
-        .assertHandshake();
+    executeSynchronously("/").assertHandshake();
   }
 
   @Test public void tls_Async() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    enableTls();
     server.enqueue(new MockResponse()
         .setBody("abc")
         .addHeader("Content-Type: text/plain"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-
     Request request = new Request.Builder()
         .url(server.url("/"))
         .build();
     client.newCall(request).enqueue(callback);
 
-    callback.await(request.httpUrl()).assertHandshake();
+    callback.await(request.url()).assertHandshake();
   }
 
   @Test public void recoverWhenRetryOnConnectionFailureIsTrue() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+    server.enqueue(new MockResponse().setBody("seed connection pool"));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
     server.enqueue(new MockResponse().setBody("retry success"));
 
-    Internal.instance.setNetwork(client, new DoubleInetAddressNetwork());
-    assertTrue(client.getRetryOnConnectionFailure());
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+    assertTrue(client.retryOnConnectionFailure());
 
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response = client.newCall(request).execute();
-    assertEquals("retry success", response.body().string());
+    executeSynchronously("/").assertBody("seed connection pool");
+    executeSynchronously("/").assertBody("retry success");
   }
 
   @Test public void noRecoverWhenRetryOnConnectionFailureIsFalse() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+    server.enqueue(new MockResponse().setBody("seed connection pool"));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
     server.enqueue(new MockResponse().setBody("unreachable!"));
 
-    Internal.instance.setNetwork(client, new DoubleInetAddressNetwork());
-    client.setRetryOnConnectionFailure(false);
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .retryOnConnectionFailure(false)
+        .build();
 
-    Request request = new Request.Builder().url(server.url("/")).build();
-    try {
-      // If this succeeds, too many requests were made.
-      client.newCall(request).execute();
-      fail();
-    } catch (IOException expected) {
-    }
+    executeSynchronously("/").assertBody("seed connection pool");
+
+    // If this succeeds, too many requests were made.
+    executeSynchronously("/").assertFailure(IOException.class);
   }
 
   @Test public void recoverFromTlsHandshakeFailure() throws Exception {
@@ -826,12 +968,13 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("abc"));
 
-    suppressTlsFallbackScsv(client);
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    Internal.instance.setNetwork(client, new SingleInetAddressNetwork());
+    client = client.newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .dns(new SingleInetAddressDns())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .build();
 
-    executeSynchronously(new Request.Builder().url(server.url("/")).build())
-        .assertBody("abc");
+    executeSynchronously("/").assertBody("abc");
   }
 
   @Test public void recoverFromTlsHandshakeFailure_tlsFallbackScsvEnabled() throws Exception {
@@ -848,9 +991,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     RecordingSSLSocketFactory clientSocketFactory =
         new RecordingSSLSocketFactory(sslContext.getSocketFactory());
-    client.setSslSocketFactory(clientSocketFactory);
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    Internal.instance.setNetwork(client, new SingleInetAddressNetwork());
+    client = client.newBuilder()
+        .sslSocketFactory(clientSocketFactory)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .dns(new SingleInetAddressDns())
+        .build();
 
     Request request = new Request.Builder().url(server.url("/")).build();
     try {
@@ -871,27 +1016,30 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("abc"));
 
-    suppressTlsFallbackScsv(client);
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client = client.newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
         .build();
     client.newCall(request).enqueue(callback);
 
-    callback.await(request.httpUrl()).assertBody("abc");
+    callback.await(request.url()).assertBody("abc");
   }
 
   @Test public void noRecoveryFromTlsHandshakeFailureWhenTlsFallbackIsDisabled() throws Exception {
-    client.setConnectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT));
+    client = client.newBuilder()
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .dns(new SingleInetAddressDns())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .build();
 
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
 
-    suppressTlsFallbackScsv(client);
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    Internal.instance.setNetwork(client, new SingleInetAddressNetwork());
-
     Request request = new Request.Builder().url(server.url("/")).build();
     try {
       client.newCall(request).execute();
@@ -905,8 +1053,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
   @Test public void cleartextCallsFailWhenCleartextIsDisabled() throws Exception {
     // Configure the client with only TLS configurations. No cleartext!
-    client.setConnectionSpecs(
-        Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS));
+    client = client.newBuilder()
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+        .build();
 
     server.enqueue(new MockResponse());
 
@@ -920,26 +1069,26 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void setFollowSslRedirectsFalse() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setResponseCode(301).addHeader("Location: http://square.com"));
+    enableTls();
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: http://square.com"));
 
-    client.setFollowSslRedirects(false);
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client = client.newBuilder()
+        .followSslRedirects(false)
+        .build();
 
     Request request = new Request.Builder().url(server.url("/")).build();
     Response response = client.newCall(request).execute();
     assertEquals(301, response.code());
+    response.body().close();
   }
 
   @Test public void matchingPinnedCertificate() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    enableTls();
     server.enqueue(new MockResponse());
     server.enqueue(new MockResponse());
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-
     // Make a first request without certificate pinning. Use it to collect certificates to pin.
     Request request1 = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request1).execute();
@@ -947,25 +1096,28 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     for (Certificate certificate : response1.handshake().peerCertificates()) {
       certificatePinnerBuilder.add(server.getHostName(), CertificatePinner.pin(certificate));
     }
+    response1.body().close();
 
     // Make another request with certificate pinning. It should complete normally.
-    client.setCertificatePinner(certificatePinnerBuilder.build());
+    client = client.newBuilder()
+        .certificatePinner(certificatePinnerBuilder.build())
+        .build();
     Request request2 = new Request.Builder().url(server.url("/")).build();
     Response response2 = client.newCall(request2).execute();
     assertNotSame(response2.handshake(), response1.handshake());
+    response2.body().close();
   }
 
   @Test public void unmatchingPinnedCertificate() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    enableTls();
     server.enqueue(new MockResponse());
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-
     // Pin publicobject.com's cert.
-    client.setCertificatePinner(new CertificatePinner.Builder()
-        .add(server.getHostName(), "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
-        .build());
+    client = client.newBuilder()
+        .certificatePinner(new CertificatePinner.Builder()
+            .add(server.getHostName(), "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+            .build())
+        .build();
 
     // When we pin the wrong certificate, connectivity fails.
     Request request = new Request.Builder().url(server.url("/")).build();
@@ -986,7 +1138,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     client.newCall(request).enqueue(callback);
 
-    callback.await(request.httpUrl())
+    callback.await(request.url())
         .assertCode(200)
         .assertBody("abc");
 
@@ -1032,44 +1184,54 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .addHeader("Vary: Accept-Charset")
         .setBody("A"));
 
-    client.setCache(cache);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
 
     // Store a response in the cache.
     HttpUrl url = server.url("/");
-    Request cacheStoreRequest = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "fr-CA")
-        .addHeader("Accept-Charset", "UTF-8")
-        .build();
-    executeSynchronously(cacheStoreRequest)
+    long request1SentAt = System.currentTimeMillis();
+    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
         .assertCode(200)
         .assertBody("A");
+    long request1ReceivedAt = System.currentTimeMillis();
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
-    // Hit that stored response.
-    Request cacheHitRequest = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "en-US") // Different, but Vary says it doesn't matter.
-        .addHeader("Accept-Charset", "UTF-8")
-        .build();
-    RecordedResponse cacheHit = executeSynchronously(cacheHitRequest);
+    // Hit that stored response. It's different, but Vary says it doesn't matter.
+    Thread.sleep(10); // Make sure the timestamps are unique.
+    RecordedResponse cacheHit = executeSynchronously(
+        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
 
     // Check the merged response. The request is the application's original request.
     cacheHit.assertCode(200)
         .assertBody("A")
-        .assertHeader("ETag", "v1")
-        .assertRequestUrl(cacheStoreRequest.url())
+        .assertHeaders(new Headers.Builder()
+            .add("ETag", "v1")
+            .add("Cache-Control", "max-age=60")
+            .add("Vary", "Accept-Charset")
+            .add("Content-Length", "1")
+            .build())
+        .assertRequestUrl(url)
         .assertRequestHeader("Accept-Language", "en-US")
-        .assertRequestHeader("Accept-Charset", "UTF-8");
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
 
     // Check the cached response. Its request contains only the saved Vary headers.
     cacheHit.cacheResponse()
         .assertCode(200)
-        .assertHeader("ETag", "v1")
+        .assertHeaders(new Headers.Builder()
+            .add("ETag", "v1")
+            .add("Cache-Control", "max-age=60")
+            .add("Vary", "Accept-Charset")
+            .add("Content-Length", "1")
+            .build())
         .assertRequestMethod("GET")
-        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestUrl(url)
         .assertRequestHeader("Accept-Language")
-        .assertRequestHeader("Accept-Charset", "UTF-8");
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
 
     cacheHit.assertNoNetworkResponse();
   }
@@ -1084,48 +1246,49 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .addHeader("Donut: b")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    client.setCache(cache);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
 
     // Store a response in the cache.
-    HttpUrl url = server.url("/");
-    Request cacheStoreRequest = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "fr-CA")
-        .addHeader("Accept-Charset", "UTF-8")
-        .build();
-    executeSynchronously(cacheStoreRequest)
+    long request1At = System.currentTimeMillis();
+    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
         .assertCode(200)
         .assertHeader("Donut", "a")
         .assertBody("A");
+    long request1ReceivedAt = System.currentTimeMillis();
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
-    // Hit that stored response.
-    Request cacheHitRequest = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "en-US") // Different, but Vary says it doesn't matter.
-        .addHeader("Accept-Charset", "UTF-8")
-        .build();
-    RecordedResponse cacheHit = executeSynchronously(cacheHitRequest);
+    // Hit that stored response. It's different, but Vary says it doesn't matter.
+    Thread.sleep(10); // Make sure the timestamps are unique.
+    long request2SentAt = System.currentTimeMillis();
+    RecordedResponse cacheHit = executeSynchronously(
+        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
+    long request2ReceivedAt = System.currentTimeMillis();
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
 
     // Check the merged response. The request is the application's original request.
     cacheHit.assertCode(200)
         .assertBody("A")
         .assertHeader("Donut", "b")
-        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestUrl(server.url("/"))
         .assertRequestHeader("Accept-Language", "en-US")
         .assertRequestHeader("Accept-Charset", "UTF-8")
-        .assertRequestHeader("If-None-Match"); // No If-None-Match on the user's request.
+        .assertRequestHeader("If-None-Match") // No If-None-Match on the user's request.
+        .assertSentRequestAtMillis(request1At, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1At, request1ReceivedAt);
 
     // Check the cached response. Its request contains only the saved Vary headers.
     cacheHit.cacheResponse()
         .assertCode(200)
         .assertHeader("Donut", "a")
         .assertHeader("ETag", "v1")
-        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestUrl(server.url("/"))
         .assertRequestHeader("Accept-Language") // No Vary on Accept-Language.
         .assertRequestHeader("Accept-Charset", "UTF-8") // Because of Vary on Accept-Charset.
-        .assertRequestHeader("If-None-Match"); // This wasn't present in the original request.
+        .assertRequestHeader("If-None-Match") // This wasn't present in the original request.
+        .assertSentRequestAtMillis(request1At, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1At, request1ReceivedAt);
 
     // Check the network response. It has the caller's request, plus some caching headers.
     cacheHit.networkResponse()
@@ -1133,7 +1296,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertHeader("Donut", "b")
         .assertRequestHeader("Accept-Language", "en-US")
         .assertRequestHeader("Accept-Charset", "UTF-8")
-        .assertRequestHeader("If-None-Match", "v1"); // If-None-Match in the validation request.
+        .assertRequestHeader("If-None-Match", "v1") // If-None-Match in the validation request.
+        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
+        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
   }
 
   @Test public void conditionalCacheHit_Async() throws Exception {
@@ -1142,20 +1307,22 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    client.setCache(cache);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
 
     Request request1 = new Request.Builder()
         .url(server.url("/"))
         .build();
     client.newCall(request1).enqueue(callback);
-    callback.await(request1.httpUrl()).assertCode(200).assertBody("A");
+    callback.await(request1.url()).assertCode(200).assertBody("A");
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
     Request request2 = new Request.Builder()
         .url(server.url("/"))
         .build();
     client.newCall(request2).enqueue(callback);
-    callback.await(request2.httpUrl()).assertCode(200).assertBody("A");
+    callback.await(request2.url()).assertCode(200).assertBody("A");
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
   }
 
@@ -1169,81 +1336,104 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .addHeader("Donut: b")
         .setBody("B"));
 
-    client.setCache(cache);
-
-    Request cacheStoreRequest = new Request.Builder()
-        .url(server.url("/"))
-        .addHeader("Accept-Language", "fr-CA")
-        .addHeader("Accept-Charset", "UTF-8")
+    client = client.newBuilder()
+        .cache(cache)
         .build();
-    executeSynchronously(cacheStoreRequest)
+
+    long request1SentAt = System.currentTimeMillis();
+    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
         .assertCode(200)
         .assertBody("A");
+    long request1ReceivedAt = System.currentTimeMillis();
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
-    Request cacheMissRequest = new Request.Builder()
-        .url(server.url("/"))
-        .addHeader("Accept-Language", "en-US") // Different, but Vary says it doesn't matter.
-        .addHeader("Accept-Charset", "UTF-8")
-        .build();
-    RecordedResponse cacheHit = executeSynchronously(cacheMissRequest);
+    // Different request, but Vary says it doesn't matter.
+    Thread.sleep(10); // Make sure the timestamps are unique.
+    long request2SentAt = System.currentTimeMillis();
+    RecordedResponse cacheMiss = executeSynchronously(
+        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
+    long request2ReceivedAt = System.currentTimeMillis();
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
 
     // Check the user response. It has the application's original request.
-    cacheHit.assertCode(200)
+    cacheMiss.assertCode(200)
         .assertBody("B")
         .assertHeader("Donut", "b")
-        .assertRequestUrl(cacheStoreRequest.url());
+        .assertRequestUrl(server.url("/"))
+        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
+        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
 
     // Check the cache response. Even though it's a miss, we used the cache.
-    cacheHit.cacheResponse()
+    cacheMiss.cacheResponse()
         .assertCode(200)
         .assertHeader("Donut", "a")
         .assertHeader("ETag", "v1")
-        .assertRequestUrl(cacheStoreRequest.url());
+        .assertRequestUrl(server.url("/"))
+        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
 
     // Check the network response. It has the network request, plus caching headers.
-    cacheHit.networkResponse()
+    cacheMiss.networkResponse()
         .assertCode(200)
         .assertHeader("Donut", "b")
         .assertRequestHeader("If-None-Match", "v1")  // If-None-Match in the validation request.
-        .assertRequestUrl(cacheStoreRequest.url());
+        .assertRequestUrl(server.url("/"))
+        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
+        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
   }
 
   @Test public void conditionalCacheMiss_Async() throws Exception {
     server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    client.setCache(cache);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
 
     Request request1 = new Request.Builder()
         .url(server.url("/"))
         .build();
     client.newCall(request1).enqueue(callback);
-    callback.await(request1.httpUrl()).assertCode(200).assertBody("A");
+    callback.await(request1.url()).assertCode(200).assertBody("A");
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
     Request request2 = new Request.Builder()
         .url(server.url("/"))
         .build();
     client.newCall(request2).enqueue(callback);
-    callback.await(request2.httpUrl()).assertCode(200).assertBody("B");
+    callback.await(request2.url()).assertCode(200).assertBody("B");
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
   }
 
   @Test public void onlyIfCachedReturns504WhenNotCached() throws Exception {
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "only-if-cached")
-        .build();
-
-    executeSynchronously(request)
+    executeSynchronously("/", "Cache-Control", "only-if-cached")
         .assertCode(504)
         .assertBody("")
         .assertNoNetworkResponse()
         .assertNoCacheResponse();
   }
 
+  @Test public void networkDropsOnConditionalGet() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    // Seed the cache.
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    executeSynchronously("/")
+        .assertCode(200)
+        .assertBody("A");
+
+    // Attempt conditional cache validation and a DNS miss.
+    client.connectionPool().evictAll();
+    client = client.newBuilder()
+        .dns(new FakeDns().unknownHost())
+        .build();
+    executeSynchronously("/").assertFailure(UnknownHostException.class);
+  }
+
   @Test public void redirect() throws Exception {
     server.enqueue(new MockResponse()
         .setResponseCode(301)
@@ -1257,7 +1447,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setBody("/b has moved!"));
     server.enqueue(new MockResponse().setBody("C"));
 
-    executeSynchronously(new Request.Builder().url(server.url("/a")).build())
+    executeSynchronously("/a")
         .assertCode(200)
         .assertBody("C")
         .priorResponse()
@@ -1293,48 +1483,142 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
   }
 
-  @Test public void redirectsDoNotIncludeTooManyCookies() throws Exception {
-    server2.enqueue(new MockResponse().setBody("Page 2"));
+  @Test public void getClientRequestTimeout() throws Exception {
+    enqueueRequestTimeoutResponses();
+
+    Response response = client.newCall(new Request.Builder()
+        .url(server.url("/")).build()).execute();
+
+    assertEquals("Body", response.body().string());
+  }
+
+  private void enqueueRequestTimeoutResponses() {
     server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/")));
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(HttpURLConnection.HTTP_CLIENT_TIMEOUT)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse().setBody("Body"));
+  }
 
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    HttpCookie cookie = new HttpCookie("c", "cookie");
-    cookie.setDomain(server.getCookieDomain());
-    cookie.setPath("/");
-    String portList = Integer.toString(server.getPort());
-    cookie.setPortlist(portList);
-    cookieManager.getCookieStore().add(server.url("/").uri(), cookie);
-    client.setCookieHandler(cookieManager);
+  @Test public void requestBodyRetransmittedOnClientRequestTimeout() throws Exception {
+    enqueueRequestTimeoutResponses();
 
     Response response = client.newCall(new Request.Builder()
-        .url(server.url("/page1"))
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "Hello"))
         .build()).execute();
-    assertEquals("Page 2", response.body().string());
+
+    assertEquals("Body", response.body().string());
 
     RecordedRequest request1 = server.takeRequest();
-    assertEquals("$Version=\"1\"; c=\"cookie\";$Path=\"/\";$Domain=\""
-        + server.getCookieDomain()
-        + "\";$Port=\""
-        + portList
-        + "\"", request1.getHeader("Cookie"));
+    assertEquals("Hello", request1.getBody().readUtf8());
 
-    RecordedRequest request2 = server2.takeRequest();
-    assertNull(request2.getHeader("Cookie"));
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("Hello", request2.getBody().readUtf8());
   }
 
-  @Test public void redirectsDoNotIncludeTooManyAuthHeaders() throws Exception {
-    server2.enqueue(new MockResponse().setBody("Page 2"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(401));
+  @Test public void propfindRedirectsToPropfind() throws Exception {
     server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: " + server2.url("/b")));
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /page2")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("Page 2"));
 
-    client.setAuthenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")));
+    Response response = client.newCall(new Request.Builder()
+        .url(server.url("/page1"))
+        .method("PROPFIND", RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
+        .build()).execute();
+    assertEquals("Page 2", response.body().string());
 
-    Request request = new Request.Builder().url(server.url("/a")).build();
+    RecordedRequest page1 = server.takeRequest();
+    assertEquals("PROPFIND /page1 HTTP/1.1", page1.getRequestLine());
+    assertEquals("Request Body", page1.getBody().readUtf8());
+
+    RecordedRequest page2 = server.takeRequest();
+    assertEquals("PROPFIND /page2 HTTP/1.1", page2.getRequestLine());
+  }
+
+  @Test public void responseCookies() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie", "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT")
+        .addHeader("Set-Cookie", "c=d; Expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure"));
+
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    executeSynchronously("/").assertCode(200);
+
+    List<Cookie> responseCookies = cookieJar.takeResponseCookies();
+    assertEquals(2, responseCookies.size());
+    assertEquals("a=b; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/",
+        responseCookies.get(0).toString());
+    assertEquals("c=d; expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure",
+        responseCookies.get(1).toString());
+  }
+
+  @Test public void requestCookies() throws Exception {
+    server.enqueue(new MockResponse());
+
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+
+    cookieJar.enqueueRequestCookies(
+        new Cookie.Builder().name("a").value("b").domain(server.getHostName()).build(),
+        new Cookie.Builder().name("c").value("d").domain(server.getHostName()).build());
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    executeSynchronously("/").assertCode(200);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("a=b; c=d", recordedRequest.getHeader("Cookie"));
+  }
+
+  @Test public void redirectsDoNotIncludeTooManyCookies() throws Exception {
+    server2.enqueue(new MockResponse().setBody("Page 2"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.url("/")));
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    HttpCookie cookie = new HttpCookie("c", "cookie");
+    cookie.setDomain(server.getHostName());
+    cookie.setPath("/");
+    String portList = Integer.toString(server.getPort());
+    cookie.setPortlist(portList);
+    cookieManager.getCookieStore().add(server.url("/").uri(), cookie);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+
+    Response response = client.newCall(new Request.Builder()
+        .url(server.url("/page1"))
+        .build()).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("c=cookie", request1.getHeader("Cookie"));
+
+    RecordedRequest request2 = server2.takeRequest();
+    assertNull(request2.getHeader("Cookie"));
+  }
+
+  @Test public void redirectsDoNotIncludeTooManyAuthHeaders() throws Exception {
+    server2.enqueue(new MockResponse().setBody("Page 2"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: " + server2.url("/b")));
+
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
+        .build();
+
+    Request request = new Request.Builder().url(server.url("/a")).build();
     Response response = client.newCall(request).execute();
     assertEquals("Page 2", response.body().string());
 
@@ -1359,7 +1643,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     Request request = new Request.Builder().url(server.url("/a")).build();
     client.newCall(request).enqueue(callback);
 
-    callback.await(server.url("/c"))
+    callback.await(server.url("/a"))
         .assertCode(200)
         .assertBody("C")
         .priorResponse()
@@ -1383,7 +1667,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
     server.enqueue(new MockResponse().setBody("Success!"));
 
-    executeSynchronously(new Request.Builder().url(server.url("/0")).build())
+    executeSynchronously("/0")
         .assertCode(200)
         .assertBody("Success!");
   }
@@ -1399,7 +1683,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder().url(server.url("/0")).build();
     client.newCall(request).enqueue(callback);
-    callback.await(server.url("/20"))
+    callback.await(server.url("/0"))
         .assertCode(200)
         .assertBody("Success!");
   }
@@ -1430,7 +1714,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder().url(server.url("/0")).build();
     client.newCall(request).enqueue(callback);
-    callback.await(server.url("/20")).assertFailure("Too many follow-up requests: 21");
+    callback.await(server.url("/0")).assertFailure("Too many follow-up requests: 21");
   }
 
   @Test public void http204WithBodyDisallowed() throws IOException {
@@ -1438,12 +1722,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setResponseCode(204)
         .setBody("I'm not even supposed to be here today."));
 
-    try {
-      executeSynchronously(new Request.Builder().url(server.url("/")).build());
-      fail();
-    } catch (ProtocolException e) {
-      assertEquals("HTTP 204 had non-zero Content-Length: 39", e.getMessage());
-    }
+    executeSynchronously("/")
+        .assertFailure("HTTP 204 had non-zero Content-Length: 39");
   }
 
   @Test public void http205WithBodyDisallowed() throws IOException {
@@ -1451,12 +1731,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setResponseCode(205)
         .setBody("I'm not even supposed to be here today."));
 
-    try {
-      executeSynchronously(new Request.Builder().url(server.url("/")).build());
-      fail();
-    } catch (ProtocolException e) {
-      assertEquals("HTTP 205 had non-zero Content-Length: 39", e.getMessage());
-    }
+    executeSynchronously("/")
+        .assertFailure("HTTP 205 had non-zero Content-Length: 39");
   }
 
   @Test public void canceledBeforeExecute() throws Exception {
@@ -1510,17 +1786,25 @@ private InetSocketAddress startNullServer() throws IOException {
     return new InetSocketAddress(address.getAddress(), nullServer.getLocalPort());
   }
 
-  @Test public void cancelTagImmediatelyAfterEnqueue() throws Exception {
+  @Test public void cancelImmediatelyAfterEnqueue() throws Exception {
+    server.enqueue(new MockResponse());
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/a"))
-        .tag("request")
         .build());
     call.enqueue(callback);
-    client.cancel("request");
-    assertEquals(0, server.getRequestCount());
+    call.cancel();
     callback.await(server.url("/a")).assertFailure("Canceled");
   }
 
+  @Test public void cancelAll() throws Exception {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    call.enqueue(callback);
+    client.dispatcher().cancelAll();
+    callback.await(server.url("/")).assertFailure("Canceled");
+  }
+
   @Test public void cancelBeforeBodyIsRead() throws Exception {
     server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
 
@@ -1544,21 +1828,28 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void cancelInFlightBeforeResponseReadThrowsIOE() throws Exception {
+    Request request = new Request.Builder().url(server.url("/a")).build();
+    final Call call = client.newCall(request);
+
     server.setDispatcher(new Dispatcher() {
       @Override public MockResponse dispatch(RecordedRequest request) {
-        client.cancel("request");
+        call.cancel();
         return new MockResponse().setBody("A");
       }
     });
 
-    Request request = new Request.Builder().url(server.url("/a")).tag("request").build();
     try {
-      client.newCall(request).execute();
+      call.execute();
       fail();
     } catch (IOException expected) {
     }
   }
 
+  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_HTTPS() throws Exception {
+    enableTls();
+    cancelInFlightBeforeResponseReadThrowsIOE();
+  }
+
   @Test public void cancelInFlightBeforeResponseReadThrowsIOE_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     cancelInFlightBeforeResponseReadThrowsIOE();
@@ -1574,26 +1865,34 @@ private InetSocketAddress startNullServer() throws IOException {
    * I/O takes place.
    */
   @Test public void canceledBeforeIOSignalsOnFailure() throws Exception {
-    client.getDispatcher().setMaxRequests(1); // Force requests to be executed serially.
+    client.dispatcher().setMaxRequests(1); // Force requests to be executed serially.
+
+    Request requestA = new Request.Builder().url(server.url("/a")).build();
+    Request requestB = new Request.Builder().url(server.url("/b")).build();
+    final Call callA = client.newCall(requestA);
+    final Call callB = client.newCall(requestB);
+
     server.setDispatcher(new Dispatcher() {
       char nextResponse = 'A';
 
       @Override public MockResponse dispatch(RecordedRequest request) {
-        client.cancel("request B");
+        callB.cancel();
         return new MockResponse().setBody(Character.toString(nextResponse++));
       }
     });
 
-    Request requestA = new Request.Builder().url(server.url("/a")).tag("request A").build();
-    client.newCall(requestA).enqueue(callback);
+    callA.enqueue(callback);
+    callB.enqueue(callback);
     assertEquals("/a", server.takeRequest().getPath());
 
-    Request requestB = new Request.Builder().url(server.url("/b")).tag("request B").build();
-    client.newCall(requestB).enqueue(callback);
-
-    callback.await(requestA.httpUrl()).assertBody("A");
+    callback.await(requestA.url()).assertBody("A");
     // At this point we know the callback is ready, and that it will receive a cancel failure.
-    callback.await(requestB.httpUrl()).assertFailure("Canceled");
+    callback.await(requestB.url()).assertFailure("Canceled");
+  }
+
+  @Test public void canceledBeforeIOSignalsOnFailure_HTTPS() throws Exception {
+    enableTls();
+    canceledBeforeIOSignalsOnFailure();
   }
 
   @Test public void canceledBeforeIOSignalsOnFailure_HTTP_2() throws Exception {
@@ -1607,7 +1906,7 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
-    Request requestA = new Request.Builder().url(server.url("/a")).tag("request A").build();
+    Request requestA = new Request.Builder().url(server.url("/a")).build();
     final Call call = client.newCall(requestA);
     server.setDispatcher(new Dispatcher() {
       @Override public MockResponse dispatch(RecordedRequest request) {
@@ -1619,10 +1918,15 @@ private InetSocketAddress startNullServer() throws IOException {
     call.enqueue(callback);
     assertEquals("/a", server.takeRequest().getPath());
 
-    callback.await(requestA.httpUrl()).assertFailure("Canceled", "stream was reset: CANCEL",
+    callback.await(requestA.url()).assertFailure("Canceled", "stream was reset: CANCEL",
         "Socket closed");
   }
 
+  @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTPS() throws Exception {
+    enableTls();
+    canceledBeforeResponseReadSignalsOnFailure();
+  }
+
   @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTP_2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     canceledBeforeResponseReadSignalsOnFailure();
@@ -1644,15 +1948,15 @@ private InetSocketAddress startNullServer() throws IOException {
     final AtomicReference<String> bodyRef = new AtomicReference<>();
     final AtomicBoolean failureRef = new AtomicBoolean();
 
-    Request request = new Request.Builder().url(server.url("/a")).tag("request A").build();
+    Request request = new Request.Builder().url(server.url("/a")).build();
     final Call call = client.newCall(request);
     call.enqueue(new Callback() {
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(Call call, IOException e) {
         failureRef.set(true);
         latch.countDown();
       }
 
-      @Override public void onResponse(Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) throws IOException {
         call.cancel();
         try {
           bodyRef.set(response.body().string());
@@ -1670,6 +1974,12 @@ private InetSocketAddress startNullServer() throws IOException {
     assertFalse(failureRef.get());
   }
 
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTPS()
+      throws Exception {
+    enableTls();
+    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
+  }
+
   @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTP_2()
       throws Exception {
     enableProtocol(Protocol.HTTP_2);
@@ -1683,12 +1993,13 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void cancelWithInterceptor() throws Exception {
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        chain.proceed(chain.request());
-        throw new AssertionError(); // We expect an exception.
-      }
-    });
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            chain.proceed(chain.request());
+            throw new AssertionError(); // We expect an exception.
+          }
+        }).build();
 
     Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
     call.cancel();
@@ -1709,13 +2020,9 @@ private InetSocketAddress startNullServer() throws IOException {
         .setBody(gzippedBody)
         .addHeader("Content-Encoding: gzip"));
 
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
     // Confirm that the user request doesn't have Accept-Encoding, and the user
     // response doesn't have a Content-Encoding or Content-Length.
-    RecordedResponse userResponse = executeSynchronously(request);
+    RecordedResponse userResponse = executeSynchronously("/");
     userResponse.assertCode(200)
         .assertRequestHeader("Accept-Encoding")
         .assertHeader("Content-Encoding")
@@ -1729,6 +2036,20 @@ private InetSocketAddress startNullServer() throws IOException {
         .assertRequestHeader("Accept-Encoding", "gzip");
   }
 
+  /** https://github.com/square/okhttp/issues/1927 */
+  @Test public void gzipResponseAfterAuthenticationChallenge() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse()
+        .setBody(gzip("abcabcabc"))
+        .addHeader("Content-Encoding: gzip"));
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator("password"))
+        .build();
+
+    executeSynchronously("/").assertBody("abcabcabc");
+  }
+
   @Test public void asyncResponseCanBeConsumedLater() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
     server.enqueue(new MockResponse().setBody("def"));
@@ -1740,11 +2061,11 @@ private InetSocketAddress startNullServer() throws IOException {
 
     final BlockingQueue<Response> responseRef = new SynchronousQueue<>();
     client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(Call call, IOException e) {
         throw new AssertionError();
       }
 
-      @Override public void onResponse(Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) throws IOException {
         try {
           responseRef.put(response);
         } catch (InterruptedException e) {
@@ -1758,7 +2079,7 @@ private InetSocketAddress startNullServer() throws IOException {
     assertEquals("abc", response.body().string());
 
     // Make another request just to confirm that that connection can be reused...
-    executeSynchronously(new Request.Builder().url(server.url("/")).build()).assertBody("def");
+    executeSynchronously("/").assertBody("def");
     assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
     assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
 
@@ -1769,7 +2090,7 @@ private InetSocketAddress startNullServer() throws IOException {
   @Test public void userAgentIsIncludedByDefault() throws Exception {
     server.enqueue(new MockResponse());
 
-    executeSynchronously(new Request.Builder().url(server.url("/")).build());
+    executeSynchronously("/");
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertTrue(recordedRequest.getHeader("User-Agent")
@@ -1783,11 +2104,10 @@ private InetSocketAddress startNullServer() throws IOException {
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    client.setFollowRedirects(false);
-    RecordedResponse recordedResponse = executeSynchronously(
-        new Request.Builder().url(server.url("/a")).build());
-
-    recordedResponse
+    client = client.newBuilder()
+        .followRedirects(false)
+        .build();
+    executeSynchronously("/a")
         .assertBody("A")
         .assertCode(302);
   }
@@ -1832,19 +2152,496 @@ private InetSocketAddress startNullServer() throws IOException {
         .build();
     server.enqueue(new MockResponse().setHeaders(headers));
 
+    executeSynchronously("/")
+        .assertHeader("a\tb", "c\u007fd")
+        .assertHeader("\ud83c\udf69", "\u2615\ufe0f")
+        .assertHeader("", "ef");
+  }
+
+  @Test public void customDns() throws Exception {
+    // Configure a DNS that returns our MockWebServer for every hostname.
+    FakeDns dns = new FakeDns();
+    dns.addresses(Dns.SYSTEM.lookup(server.url("/").host()));
+    client = client.newBuilder()
+        .dns(dns)
+        .build();
+
+    server.enqueue(new MockResponse());
+    Request request = new Request.Builder()
+        .url(server.url("/").newBuilder().host("android.com").build())
+        .build();
+    executeSynchronously(request).assertCode(200);
+
+    dns.assertRequests("android.com");
+  }
+
+  /** We had a bug where failed HTTP/2 calls could break the entire connection. */
+  @Test public void failingCallsDoNotInterfereWithConnection() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    server.enqueue(new MockResponse().setBody("Response 1"));
+    server.enqueue(new MockResponse().setBody("Response 2"));
+
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("abc");
+        sink.flush();
+
+        makeFailingCall();
+
+        sink.writeUtf8("def");
+        sink.flush();
+      }
+    };
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(requestBody)
+        .build());
+    assertEquals("Response 1", call.execute().body().string());
+  }
+
+  /** Test which headers are sent unencrypted to the HTTP proxy. */
+  @Test public void proxyConnectOmitsApplicationHeaders() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("encrypted response from the origin server"));
+
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .proxy(server.toProxyAddress())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .header("Private", "Secret")
+        .header("User-Agent", "App 1.0")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("encrypted response from the origin server", response.body().string());
+
+    RecordedRequest connect = server.takeRequest();
+    assertNull(connect.getHeader("Private"));
+    assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
+    assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("Secret", get.getHeader("Private"));
+    assertEquals("App 1.0", get.getHeader("User-Agent"));
+
+    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
+  }
+
+  /** Respond to a proxy authorization challenge. */
+  @Test public void proxyAuthenticateOnConnect() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    RecordedRequest connect1 = server.takeRequest();
+    assertEquals("CONNECT android.com:443 HTTP/1.1", connect1.getRequestLine());
+    assertNull(connect1.getHeader("Proxy-Authorization"));
+
+    RecordedRequest connect2 = server.takeRequest();
+    assertEquals("CONNECT android.com:443 HTTP/1.1", connect2.getRequestLine());
+    assertEquals("password", connect2.getHeader("Proxy-Authorization"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
+    assertNull(get.getHeader("Proxy-Authorization"));
+  }
+
+  /** Confirm that the proxy authenticator works for unencrypted HTTP proxies. */
+  @Test public void httpProxyAuthenticate() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .build();
+
+    Request request = new Request.Builder()
+        .url("http://android.com/foo")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    RecordedRequest get1 = server.takeRequest();
+    assertEquals("GET http://android.com/foo HTTP/1.1", get1.getRequestLine());
+    assertNull(get1.getHeader("Proxy-Authorization"));
+
+    RecordedRequest get2 = server.takeRequest();
+    assertEquals("GET http://android.com/foo HTTP/1.1", get2.getRequestLine());
+    assertEquals("password", get2.getHeader("Proxy-Authorization"));
+  }
+
+  /**
+   * OkHttp has a bug where a `Connection: close` response header is not honored when establishing
+   * a TLS tunnel. https://github.com/square/okhttp/issues/2426
+   */
+  @Test public void proxyAuthenticateOnConnectWithConnectionClose() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), true);
+    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
+        .addHeader("Connection: close"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    // First CONNECT call needs a new connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Second CONNECT call needs a new connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // GET reuses the connection from the second connect.
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void tooManyProxyAuthFailuresWithConnectionClose() throws IOException {
+    server.useHttps(sslContext.getSocketFactory(), true);
+    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(407)
+          .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
+          .addHeader("Connection: close"));
+    }
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
+  /**
+   * Confirm that we don't send the Proxy-Authorization header from the request to the proxy server.
+   * We used to have that behavior but it is problematic because unrelated requests end up sharing
+   * credentials. Worse, that approach leaks proxy credentials to the origin server.
+   */
+  @Test public void noProactiveProxyAuthorization() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .proxy(server.toProxyAddress())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .header("Proxy-Authorization", "password")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("response body", response.body().string());
+
+    RecordedRequest connect = server.takeRequest();
+    assertNull(connect.getHeader("Proxy-Authorization"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("password", get.getHeader("Proxy-Authorization"));
+  }
+
+  @Test public void interceptorGetsFramedProtocol() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    // Capture the protocol as it is observed by the interceptor.
+    final AtomicReference<Protocol> protocolRef = new AtomicReference<>();
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        protocolRef.set(chain.connection().protocol());
+        return chain.proceed(chain.request());
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    // Make an HTTP/2 request and confirm that the protocol matches.
+    server.enqueue(new MockResponse());
+    executeSynchronously("/");
+    assertEquals(Protocol.HTTP_2, protocolRef.get());
+  }
+
+  @Test public void serverSendsInvalidResponseHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTP/1.1 200 OK"));
+
+    executeSynchronously("/")
+        .assertFailure("Unexpected status line: HTP/1.1 200 OK");
+  }
+
+  @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 2147483648 OK"));
+
+    executeSynchronously("/")
+        .assertFailure("Unexpected status line: HTTP/1.1 2147483648 OK");
+  }
+
+  @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 00a OK"));
+
+    executeSynchronously("/")
+        .assertFailure("Unexpected status line: HTTP/1.1 00a OK");
+  }
+
+  @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus(" HTTP/1.1 200 OK"));
+
+    executeSynchronously("/")
+        .assertFailure("Unexpected status line:  HTTP/1.1 200 OK");
+  }
+
+  @Test public void connectFails() throws Exception {
+    server.shutdown();
+
+    executeSynchronously("/")
+        .assertFailure(IOException.class);
+  }
+
+  @Test public void requestBodySurvivesRetries() throws Exception {
+    server.enqueue(new MockResponse());
+
+    // Enable a misconfigured proxy selector to guarantee that the request is retried.
+    client = client.newBuilder()
+        .proxySelector(new FakeProxySelector()
+            .addProxy(server2.toProxyAddress()))
+        .build();
+    server2.shutdown();
+
     Request request = new Request.Builder()
         .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    executeSynchronously(request);
+    assertEquals("abc", server.takeRequest().getBody().readUtf8());
+  }
+
+  @Ignore // This may fail in DNS lookup, which we don't have timeouts for.
+  @Test public void invalidHost() throws Exception {
+    Request request = new Request.Builder()
+        .url(HttpUrl.parse("http://1234.1.1.1/"))
         .build();
 
     executeSynchronously(request)
-        .assertHeader("a\tb", "c\u007fd")
-        .assertHeader("\ud83c\udf69", "\u2615\ufe0f")
-        .assertHeader("", "ef");
+        .assertFailure(UnknownHostException.class);
   }
 
-  private RecordedResponse executeSynchronously(Request request) throws IOException {
+  @Test public void uploadBodySmallChunkedEncoding() throws Exception {
+    upload(true, 1048576, 256);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(1048576, recordedRequest.getBodySize());
+    assertFalse(recordedRequest.getChunkSizes().isEmpty());
+  }
+
+  @Test public void uploadBodyLargeChunkedEncoding() throws Exception {
+    upload(true, 1048576, 65536);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(1048576, recordedRequest.getBodySize());
+    assertFalse(recordedRequest.getChunkSizes().isEmpty());
+  }
+
+  @Test public void uploadBodySmallFixedLength() throws Exception {
+    upload(false, 1048576, 256);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(1048576, recordedRequest.getBodySize());
+    assertTrue(recordedRequest.getChunkSizes().isEmpty());
+  }
+
+  @Test public void uploadBodyLargeFixedLength() throws Exception {
+    upload(false, 1048576, 65536);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(1048576, recordedRequest.getBodySize());
+    assertTrue(recordedRequest.getChunkSizes().isEmpty());
+  }
+
+  private void upload(
+      final boolean chunked, final int size, final int writeSize) throws Exception {
+    server.enqueue(new MockResponse());
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .post(requestBody(chunked, size, writeSize))
+        .build());
+  }
+
+  /** https://github.com/square/okhttp/issues/2344 */
+  @Test public void ipv6HostHasSquareBraces() throws Exception {
+    // Use a proxy to fake IPv6 connectivity, even if localhost doesn't have IPv6.
+    server.useHttps(sslContext.getSocketFactory(), true);
+    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response body"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://[::1]/")
+        .build();
     Response response = client.newCall(request).execute();
-    return new RecordedResponse(request, response, null, response.body().string(), null);
+    assertEquals("response body", response.body().string());
+
+    RecordedRequest connect = server.takeRequest();
+    assertEquals("CONNECT [::1]:443 HTTP/1.1", connect.getRequestLine());
+    assertEquals("[::1]:443", connect.getHeader("Host"));
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals("GET / HTTP/1.1", get.getRequestLine());
+    assertEquals("[::1]", get.getHeader("Host"));
+  }
+
+  private RequestBody requestBody(final boolean chunked, final long size, final int writeSize) {
+    final byte[] buffer = new byte[writeSize];
+    Arrays.fill(buffer, (byte) 'x');
+
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain; charset=utf-8");
+      }
+
+      @Override public long contentLength() throws IOException {
+        return chunked ? -1L : size;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        for (int count = 0; count < size; count += writeSize) {
+          sink.write(buffer, 0, (int) Math.min(size - count, writeSize));
+        }
+      }
+    };
+  }
+
+  @Test public void emptyResponseBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("abc", "def"));
+    executeSynchronously("/")
+        .assertCode(200)
+        .assertHeader("abc", "def")
+        .assertBody("");
+  }
+
+  private void makeFailingCall() {
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() throws IOException {
+        return 1;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        throw new IOException("write body fail!");
+      }
+    };
+    OkHttpClient nonRetryingClient = client.newBuilder()
+        .retryOnConnectionFailure(false)
+        .build();
+    Call call = nonRetryingClient.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(requestBody)
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("write body fail!", expected.getMessage());
+    }
+  }
+
+  private RecordedResponse executeSynchronously(String path, String... headers) throws IOException {
+    Request.Builder builder = new Request.Builder();
+    builder.url(server.url(path));
+    for (int i = 0, size = headers.length; i < size; i += 2) {
+      builder.addHeader(headers[i], headers[i + 1]);
+    }
+    return executeSynchronously(builder.build());
+  }
+
+  private RecordedResponse executeSynchronously(Request request) throws IOException {
+    Call call = client.newCall(request);
+    try {
+      Response response = call.execute();
+      String bodyString = response.body().string();
+      return new RecordedResponse(request, response, null, bodyString, null);
+    } catch (IOException e) {
+      return new RecordedResponse(request, null, null, null, e);
+    }
   }
 
   /**
@@ -1852,11 +2649,19 @@ private RecordedResponse executeSynchronously(Request request) throws IOExceptio
    * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
    */
   private void enableProtocol(Protocol protocol) {
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
+    enableTls();
+    client = client.newBuilder()
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .build();
+    server.setProtocols(client.protocols());
+  }
+
+  private void enableTls() {
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
     server.useHttps(sslContext.getSocketFactory(), false);
-    server.setProtocols(client.getProtocols());
   }
 
   private Buffer gzip(String data) throws IOException {
@@ -1889,8 +2694,9 @@ public RecordingSSLSocketFactory(SSLSocketFactory delegate) {
     }
 
     @Override
-    protected void configureSocket(SSLSocket sslSocket) throws IOException {
+    protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
       socketsCreated.add(sslSocket);
+      return sslSocket;
     }
 
     public List<SSLSocket> getSocketsCreated() {
@@ -1900,12 +2706,10 @@ protected void configureSocket(SSLSocket sslSocket) throws IOException {
 
   /**
    * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
-   * TLS_FALLBACK_SCSV cipher on fallback connections. See
-   * {@link com.squareup.okhttp.FallbackTestClientSocketFactory} for details.
+   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
+   * for details.
    */
-  private void suppressTlsFallbackScsv(OkHttpClient client) {
-    FallbackTestClientSocketFactory clientSocketFactory =
-        new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
-    client.setSslSocketFactory(clientSocketFactory);
+  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
+    return new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
new file mode 100644
index 0000000000..8bfcb8c2ae
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -0,0 +1,252 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.security.GeneralSecurityException;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.internal.HeldCertificate;
+import okhttp3.internal.tls.CertificateChainCleaner;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class CertificateChainCleanerTest {
+  @Test public void normalizeSingleSelfSignedCertificate() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(root), cleaner.clean(list(root), "hostname"));
+  }
+
+  @Test public void normalizeUnknownSelfSignedCertificate() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get();
+
+    try {
+      cleaner.clean(list(root), "hostname");
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void orderedChainOfCertificatesWithRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(certA)
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certB, certA, root), cleaner.clean(list(certB, certA, root), "hostname"));
+  }
+
+  @Test public void orderedChainOfCertificatesWithoutRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(certA)
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certB, certA, root),
+        cleaner.clean(list(certB, certA), "hostname")); // Root is added!
+  }
+
+  @Test public void unorderedChainOfCertificatesWithRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(certA)
+        .build();
+    HeldCertificate certC = new HeldCertificate.Builder()
+        .serialNumber("4")
+        .issuedBy(certB)
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certC, certB, certA, root),
+        cleaner.clean(list(certC, certA, root, certB), "hostname"));
+  }
+
+  @Test public void unorderedChainOfCertificatesWithoutRoot() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(certA)
+        .build();
+    HeldCertificate certC = new HeldCertificate.Builder()
+        .serialNumber("4")
+        .issuedBy(certB)
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certC, certB, certA, root),
+        cleaner.clean(list(certC, certA, certB), "hostname"));
+  }
+
+  @Test public void unrelatedCertificatesAreOmitted() throws Exception {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(root)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(certA)
+        .build();
+    HeldCertificate certUnnecessary = new HeldCertificate.Builder()
+        .serialNumber("4")
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    assertEquals(list(certB, certA, root),
+        cleaner.clean(list(certB, certUnnecessary, certA, root), "hostname"));
+  }
+
+  @Test public void chainGoesAllTheWayToSelfSignedRoot() throws Exception {
+    HeldCertificate selfSigned = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate trusted = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .issuedBy(selfSigned)
+        .build();
+    HeldCertificate certA = new HeldCertificate.Builder()
+        .serialNumber("3")
+        .issuedBy(trusted)
+        .build();
+    HeldCertificate certB = new HeldCertificate.Builder()
+        .serialNumber("4")
+        .issuedBy(certA)
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(
+        selfSigned.certificate, trusted.certificate);
+    assertEquals(list(certB, certA, trusted, selfSigned),
+        cleaner.clean(list(certB, certA), "hostname"));
+    assertEquals(list(certB, certA, trusted, selfSigned),
+        cleaner.clean(list(certB, certA, trusted), "hostname"));
+    assertEquals(list(certB, certA, trusted, selfSigned),
+        cleaner.clean(list(certB, certA, trusted, selfSigned), "hostname"));
+  }
+
+  @Test public void trustedRootNotSelfSigned() throws Exception {
+    HeldCertificate unknownSigner = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .build();
+    HeldCertificate trusted = new HeldCertificate.Builder()
+        .issuedBy(unknownSigner)
+        .serialNumber("2")
+        .build();
+    HeldCertificate intermediateCa = new HeldCertificate.Builder()
+        .issuedBy(trusted)
+        .serialNumber("3")
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .issuedBy(intermediateCa)
+        .serialNumber("4")
+        .build();
+
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(trusted.certificate);
+    assertEquals(list(certificate, intermediateCa, trusted),
+        cleaner.clean(list(certificate, intermediateCa), "hostname"));
+    assertEquals(list(certificate, intermediateCa, trusted),
+        cleaner.clean(list(certificate, intermediateCa, trusted), "hostname"));
+  }
+
+  @Test public void chainMaxLength() throws Exception {
+    List<HeldCertificate> heldCertificates = chainOfLength(10);
+    List<Certificate> certificates = new ArrayList<>();
+    for (HeldCertificate heldCertificate : heldCertificates) {
+      certificates.add(heldCertificate.certificate);
+    }
+
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
+    assertEquals(certificates, cleaner.clean(certificates, "hostname"));
+    assertEquals(certificates, cleaner.clean(certificates.subList(0, 9), "hostname"));
+  }
+
+  @Test public void chainTooLong() throws Exception {
+    List<HeldCertificate> heldCertificates = chainOfLength(11);
+    List<Certificate> certificates = new ArrayList<>();
+    for (HeldCertificate heldCertificate : heldCertificates) {
+      certificates.add(heldCertificate.certificate);
+    }
+
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
+    try {
+      cleaner.clean(certificates, "hostname");
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  /** Returns a chain starting at the leaf certificate and progressing to the root. */
+  private List<HeldCertificate> chainOfLength(int length) throws GeneralSecurityException {
+    List<HeldCertificate> result = new ArrayList<>();
+    for (int i = 1; i <= length; i++) {
+      result.add(0, new HeldCertificate.Builder()
+          .issuedBy(!result.isEmpty() ? result.get(0) : null)
+          .serialNumber(Integer.toString(i))
+          .build());
+    }
+    return result;
+  }
+
+  private List<Certificate> list(HeldCertificate... heldCertificates) {
+    List<Certificate> result = new ArrayList<>();
+    for (HeldCertificate heldCertificate : heldCertificates) {
+      result.add(heldCertificate.certificate);
+    }
+    return result;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
new file mode 100644
index 0000000000..9442ddaf71
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.security.GeneralSecurityException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.CertificatePinner.Pin;
+import okhttp3.internal.HeldCertificate;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CertificatePinnerTest {
+  static HeldCertificate certA1;
+  static String certA1Sha256Pin;
+
+  static HeldCertificate certB1;
+  static String certB1Sha256Pin;
+
+  static HeldCertificate certC1;
+  static String certC1Sha256Pin;
+
+  static {
+    try {
+      certA1 = new HeldCertificate.Builder()
+          .serialNumber("100")
+          .build();
+      certA1Sha256Pin = "sha256/" + CertificatePinner.sha256(certA1.certificate).base64();
+
+      certB1 = new HeldCertificate.Builder()
+          .serialNumber("200")
+          .build();
+      certB1Sha256Pin = "sha256/" + CertificatePinner.sha256(certB1.certificate).base64();
+
+      certC1 = new HeldCertificate.Builder()
+          .serialNumber("300")
+          .build();
+      certC1Sha256Pin = "sha256/" + CertificatePinner.sha256(certC1.certificate).base64();
+    } catch (GeneralSecurityException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  @Test public void malformedPin() throws Exception {
+    CertificatePinner.Builder builder = new CertificatePinner.Builder();
+    try {
+      builder.add("example.com", "md5/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void malformedBase64() throws Exception {
+    CertificatePinner.Builder builder = new CertificatePinner.Builder();
+    try {
+      builder.add("example.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw*");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  /** Multiple certificates generated from the same keypair have the same pin. */
+  @Test public void sameKeypairSamePin() throws Exception {
+    HeldCertificate heldCertificateA2 = new HeldCertificate.Builder()
+        .keyPair(certA1.keyPair)
+        .serialNumber("101")
+        .build();
+    String keypairACertificate2Pin = CertificatePinner.pin(heldCertificateA2.certificate);
+
+    HeldCertificate heldCertificateB2 = new HeldCertificate.Builder()
+        .keyPair(certB1.keyPair)
+        .serialNumber("201")
+        .build();
+    String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate);
+
+    assertTrue(certA1Sha256Pin.equals(keypairACertificate2Pin));
+    assertTrue(certB1Sha256Pin.equals(keypairBCertificate2Pin));
+    assertFalse(certA1Sha256Pin.equals(certB1Sha256Pin));
+  }
+
+  @Test public void successfulCheck() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certA1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate);
+  }
+
+  @Test public void successfulCheckSha1Pin() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate).base64())
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate);
+  }
+
+  @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate, certB1.certificate);
+  }
+
+  @Test public void unsuccessfulCheck() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certA1Sha256Pin)
+        .build();
+
+    try {
+      certificatePinner.check("example.com", certB1.certificate);
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void multipleCertificatesForOneHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certA1Sha256Pin, certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate);
+    certificatePinner.check("example.com", certB1.certificate);
+  }
+
+  @Test public void multipleHostnamesForOneCertificate() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certA1Sha256Pin)
+        .add("www.example.com", certA1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate);
+    certificatePinner.check("www.example.com", certA1.certificate);
+  }
+
+  @Test public void absentHostnameMatches() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder().build();
+    certificatePinner.check("example.com", certA1.certificate);
+  }
+
+  @Test public void successfulCheckForWildcardHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", certA1.certificate);
+  }
+
+  @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname()
+      throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", certA1.certificate, certB1.certificate);
+  }
+
+  @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build();
+
+    try {
+      certificatePinner.check("a.example.com", certB1.certificate);
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void multipleCertificatesForOneWildcardHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin, certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", certA1.certificate);
+    certificatePinner.check("a.example.com", certB1.certificate);
+  }
+
+  @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate()
+      throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", certA1.certificate);
+    certificatePinner.check("a.example.com", certB1.certificate);
+  }
+
+  @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate()
+      throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
+        .build();
+
+    try {
+      certificatePinner.check("a.example.com", certC1.certificate);
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void successfulFindMatchingPins() {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("first.com", certA1Sha256Pin, certB1Sha256Pin)
+        .add("second.com", certC1Sha256Pin)
+        .build();
+
+    List<Pin> expectedPins = Arrays.asList(
+        new Pin("first.com", certA1Sha256Pin),
+        new Pin("first.com", certB1Sha256Pin));
+    assertEquals(expectedPins, certificatePinner.findMatchingPins("first.com"));
+  }
+
+  @Test public void successfulFindMatchingPinsForWildcardAndDirectCertificates() {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
+        .add("b.example.com", certC1Sha256Pin)
+        .build();
+
+    List<Pin> expectedPins = Arrays.asList(
+        new Pin("*.example.com", certA1Sha256Pin),
+        new Pin("a.example.com", certB1Sha256Pin));
+    assertEquals(expectedPins, certificatePinner.findMatchingPins("a.example.com"));
+  }
+
+  @Test public void wildcardHostnameShouldNotMatchThroughDot() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build();
+
+    assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("example.com"));
+    assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("a.b.example.com"));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
new file mode 100644
index 0000000000..84ebbc6824
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.Socket;
+import java.util.Collections;
+import java.util.concurrent.TimeUnit;
+import javax.net.SocketFactory;
+import okhttp3.internal.Internal;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.io.RealConnection;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class ConnectionPoolTest {
+  private final Address addressA = newAddress("a");
+  private final Route routeA1 = newRoute(addressA);
+  private final Address addressB = newAddress("b");
+  private final Route routeB1 = newRoute(addressB);
+  private final Address addressC = newAddress("c");
+  private final Route routeC1 = newRoute(addressC);
+
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
+  @Test public void connectionsEvictedWhenIdleLongEnough() throws Exception {
+    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 50L);
+
+    // Running at time 50, the pool returns that nothing can be evicted until time 150.
+    assertEquals(100L, pool.cleanup(50L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket.isClosed());
+
+    // Running at time 60, the pool returns that nothing can be evicted until time 150.
+    assertEquals(90L, pool.cleanup(60L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket.isClosed());
+
+    // Running at time 149, the pool returns that nothing can be evicted until time 150.
+    assertEquals(1L, pool.cleanup(149L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket.isClosed());
+
+    // Running at time 150, the pool evicts.
+    assertEquals(0, pool.cleanup(150L));
+    assertEquals(0, pool.connectionCount());
+    assertTrue(c1.socket.isClosed());
+
+    // Running again, the pool reports that no further runs are necessary.
+    assertEquals(-1, pool.cleanup(150L));
+    assertEquals(0, pool.connectionCount());
+    assertTrue(c1.socket.isClosed());
+  }
+
+  @Test public void inUseConnectionsNotEvicted() throws Exception {
+    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 50L);
+    StreamAllocation streamAllocation = new StreamAllocation(pool, addressA);
+    streamAllocation.acquire(c1);
+
+    // Running at time 50, the pool returns that nothing can be evicted until time 150.
+    assertEquals(100L, pool.cleanup(50L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket.isClosed());
+
+    // Running at time 60, the pool returns that nothing can be evicted until time 160.
+    assertEquals(100L, pool.cleanup(60L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket.isClosed());
+
+    // Running at time 160, the pool returns that nothing can be evicted until time 260.
+    assertEquals(100L, pool.cleanup(160L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket.isClosed());
+  }
+
+  @Test public void cleanupPrioritizesEarliestEviction() throws Exception {
+    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 75L);
+    RealConnection c2 = newConnection(pool, routeB1, 50L);
+
+    // Running at time 75, the pool returns that nothing can be evicted until time 150.
+    assertEquals(75L, pool.cleanup(75L));
+    assertEquals(2, pool.connectionCount());
+
+    // Running at time 149, the pool returns that nothing can be evicted until time 150.
+    assertEquals(1L, pool.cleanup(149L));
+    assertEquals(2, pool.connectionCount());
+
+    // Running at time 150, the pool evicts c2.
+    assertEquals(0L, pool.cleanup(150L));
+    assertEquals(1, pool.connectionCount());
+    assertFalse(c1.socket.isClosed());
+    assertTrue(c2.socket.isClosed());
+
+    // Running at time 150, the pool returns that nothing can be evicted until time 175.
+    assertEquals(25L, pool.cleanup(150L));
+    assertEquals(1, pool.connectionCount());
+
+    // Running at time 175, the pool evicts c1.
+    assertEquals(0L, pool.cleanup(175L));
+    assertEquals(0, pool.connectionCount());
+    assertTrue(c1.socket.isClosed());
+    assertTrue(c2.socket.isClosed());
+  }
+
+  @Test public void oldestConnectionsEvictedIfIdleLimitExceeded() throws Exception {
+    ConnectionPool pool = new ConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 50L);
+    RealConnection c2 = newConnection(pool, routeB1, 75L);
+
+    // With 2 connections, there's no need to evict until the connections time out.
+    assertEquals(50L, pool.cleanup(100L));
+    assertEquals(2, pool.connectionCount());
+    assertFalse(c1.socket.isClosed());
+    assertFalse(c2.socket.isClosed());
+
+    // Add a third connection
+    RealConnection c3 = newConnection(pool, routeC1, 75L);
+
+    // The third connection bounces the first.
+    assertEquals(0L, pool.cleanup(100L));
+    assertEquals(2, pool.connectionCount());
+    assertTrue(c1.socket.isClosed());
+    assertFalse(c2.socket.isClosed());
+    assertFalse(c3.socket.isClosed());
+  }
+
+  @Test public void leakedAllocation() throws Exception {
+    ConnectionPool pool = new ConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 0L);
+    allocateAndLeakAllocation(pool, c1);
+
+    awaitGarbageCollection();
+    assertEquals(0L, pool.cleanup(100L));
+    assertEquals(Collections.emptyList(), c1.allocations);
+
+    assertTrue(c1.noNewStreams); // Can't allocate once a leak has been detected.
+  }
+
+  /** Use a helper method so there's no hidden reference remaining on the stack. */
+  private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
+    StreamAllocation leak = new StreamAllocation(pool, connection.route().address());
+    leak.acquire(connection);
+  }
+
+  /**
+   * See FinalizationTester for discussion on how to best trigger GC in tests.
+   * https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
+   * java/lang/ref/FinalizationTester.java
+   */
+  private void awaitGarbageCollection() throws InterruptedException {
+    Runtime.getRuntime().gc();
+    Thread.sleep(100);
+    System.runFinalization();
+  }
+
+  private RealConnection newConnection(ConnectionPool pool, Route route, long idleAtNanos) {
+    RealConnection connection = new RealConnection(route);
+    connection.idleAtNanos = idleAtNanos;
+    connection.socket = new Socket();
+    synchronized (pool) {
+      pool.put(connection);
+    }
+    return connection;
+  }
+
+  private Address newAddress(String name) {
+    return new Address(name, 1, Dns.SYSTEM, SocketFactory.getDefault(), null, null, null,
+        new RecordingOkAuthenticator("password"), null, Collections.<Protocol>emptyList(),
+        Collections.<ConnectionSpec>emptyList(),
+        ProxySelector.getDefault());
+  }
+
+  private Route newRoute(Address address) {
+    return new Route(address, Proxy.NO_PROXY,
+        InetSocketAddress.createUnresolved(address.url().host(), address.url().port()));
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
new file mode 100644
index 0000000000..a25d8debef
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
@@ -0,0 +1,323 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.rules.Timeout;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class ConnectionReuseTest {
+  @Rule public final TestRule timeout = new Timeout(30_000);
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private SSLContext sslContext = SslContextBuilder.localhost();
+  private OkHttpClient client = defaultClient();
+
+  @Test public void connectionsAreReused() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionReused(request, request);
+  }
+
+  @Test public void connectionsAreReusedWithHttp2() throws Exception {
+    enableHttp2();
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionReused(request, request);
+  }
+
+  @Test public void connectionsAreNotReusedWithRequestConnectionClose() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request requestA = new Request.Builder()
+        .url(server.url("/"))
+        .header("Connection", "close")
+        .build();
+    Request requestB = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionNotReused(requestA, requestB);
+  }
+
+  @Test public void connectionsAreNotReusedWithResponseConnectionClose() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Connection", "close")
+        .setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request requestA = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Request requestB = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionNotReused(requestA, requestB);
+  }
+
+  @Test public void connectionsAreNotReusedWithUnknownLengthResponseBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("a")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionNotReused(request, request);
+  }
+
+  @Test public void connectionsAreNotReusedIfPoolIsSizeZero() throws Exception {
+    client = client.newBuilder()
+        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
+        .build();
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    assertConnectionNotReused(request, request);
+  }
+
+  @Test public void connectionsReusedWithRedirectEvenIfPoolIsSizeZero() throws Exception {
+    client = client.newBuilder()
+        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
+        .build();
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("b", response.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionsNotReusedWithRedirectIfDiscardingResponseIsSlow() throws Exception {
+    client = client.newBuilder()
+        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
+        .build();
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .setBodyDelay(1, TimeUnit.SECONDS)
+        .setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("b", response.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void silentRetryWhenIdempotentRequestFailsOnReusedConnection() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response responseA = client.newCall(request).execute();
+    assertEquals("a", responseA.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    Response responseB = client.newCall(request).execute();
+    assertEquals("b", responseB.body().string());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void staleConnectionNotReusedForNonIdempotentRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("a")
+        .setSocketPolicy(SocketPolicy.SHUTDOWN_OUTPUT_AT_END));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request requestA = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response responseA = client.newCall(requestA).execute();
+    assertEquals("a", responseA.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    Request requestB = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "b"))
+        .build();
+    Response responseB = client.newCall(requestB).execute();
+    assertEquals("b", responseB.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void http2ConnectionsAreSharedBeforeResponseIsConsumed() throws Exception {
+    enableHttp2();
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response1 = client.newCall(request).execute();
+    Response response2 = client.newCall(request).execute();
+    response1.body().string(); // Discard the response body.
+    response2.body().string(); // Discard the response body.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionsAreEvicted() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    client = client.newBuilder()
+        .connectionPool(new ConnectionPool(5, 250, TimeUnit.MILLISECONDS))
+        .build();
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response1 = client.newCall(request).execute();
+    assertEquals("a", response1.body().string());
+
+    // Give the thread pool a chance to evict.
+    Thread.sleep(500);
+
+    Response response2 = client.newCall(request).execute();
+    assertEquals("b", response2.body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionsAreNotReusedIfSslSocketFactoryChanges() throws Exception {
+    enableHttps();
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    response.body().close();
+
+    // This client shares a connection pool but has a different SSL socket factory.
+    SSLContext sslContext2 = SSLContext.getInstance("TLS");
+    sslContext2.init(null, null, null);
+    SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
+    OkHttpClient anotherClient = client.newBuilder()
+        .sslSocketFactory(sslSocketFactory2)
+        .build();
+
+    // This client fails to connect because the new SSL socket factory refuses.
+    try {
+      anotherClient.newCall(request).execute();
+      fail();
+    } catch (SSLException expected) {
+    }
+  }
+
+  @Test public void connectionsAreNotReusedIfHostnameVerifierChanges() throws Exception {
+    enableHttps();
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response1 = client.newCall(request).execute();
+    response1.body().close();
+
+    // This client shares a connection pool but has a different SSL socket factory.
+    OkHttpClient anotherClient = client.newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Response response2 = anotherClient.newCall(request).execute();
+    response2.body().close();
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  private void enableHttps() {
+    enableHttpsAndAlpn(Protocol.HTTP_1_1);
+  }
+
+  private void enableHttp2() {
+    enableHttpsAndAlpn(Protocol.HTTP_2, Protocol.HTTP_1_1);
+  }
+
+  private void enableHttpsAndAlpn(Protocol... protocols) {
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .protocols(Arrays.asList(protocols))
+        .build();
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.setProtocols(client.protocols());
+  }
+
+  private void assertConnectionReused(Request... requests) throws Exception {
+    for (int i = 0; i < requests.length; i++) {
+      Response response = client.newCall(requests[i]).execute();
+      response.body().string(); // Discard the response body.
+      assertEquals(i, server.takeRequest().getSequenceNumber());
+    }
+  }
+
+  private void assertConnectionNotReused(Request... requests) throws Exception {
+    for (Request request : requests) {
+      Response response = client.newCall(request).execute();
+      response.body().string(); // Discard the response body.
+      assertEquals(0, server.takeRequest().getSequenceNumber());
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionSpecTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
similarity index 54%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionSpecTest.java
rename to okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
index 7833cca694..7fbd08e628 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionSpecTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
@@ -13,31 +13,51 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
-
-import org.junit.Test;
+package okhttp3;
 
 import java.util.Arrays;
 import java.util.LinkedHashSet;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 public final class ConnectionSpecTest {
+  @Test public void noTlsVersions() throws Exception {
+    try {
+      new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+          .tlsVersions(new TlsVersion[0])
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("At least one TLS version is required", expected.getMessage());
+    }
+  }
 
-  @Test
-  public void cleartextBuilder() throws Exception {
+  @Test public void noCipherSuites() throws Exception {
+    try {
+      new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+          .cipherSuites(new CipherSuite[0])
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("At least one cipher suite is required", expected.getMessage());
+    }
+  }
+
+  @Test public void cleartextBuilder() throws Exception {
     ConnectionSpec cleartextSpec = new ConnectionSpec.Builder(false).build();
     assertFalse(cleartextSpec.isTls());
   }
 
-  @Test
-  public void tlsBuilder_explicitCiphers() throws Exception {
+  @Test public void tlsBuilder_explicitCiphers() throws Exception {
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
         .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
         .tlsVersions(TlsVersion.TLS_1_2)
@@ -48,8 +68,7 @@ public void tlsBuilder_explicitCiphers() throws Exception {
     assertTrue(tlsSpec.supportsTlsExtensions());
   }
 
-  @Test
-  public void tlsBuilder_defaultCiphers() throws Exception {
+  @Test public void tlsBuilder_defaultCiphers() throws Exception {
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
         .tlsVersions(TlsVersion.TLS_1_2)
         .supportsTlsExtensions(true)
@@ -59,8 +78,7 @@ public void tlsBuilder_defaultCiphers() throws Exception {
     assertTrue(tlsSpec.supportsTlsExtensions());
   }
 
-  @Test
-  public void tls_defaultCiphers_noFallbackIndicator() throws Exception {
+  @Test public void tls_defaultCiphers_noFallbackIndicator() throws Exception {
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
         .tlsVersions(TlsVersion.TLS_1_2)
         .supportsTlsExtensions(false)
@@ -79,17 +97,16 @@ public void tls_defaultCiphers_noFallbackIndicator() throws Exception {
     assertTrue(tlsSpec.isCompatible(socket));
     tlsSpec.apply(socket, false /* isFallback */);
 
-    assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
+    assertEquals(set(TlsVersion.TLS_1_2.javaName), set(socket.getEnabledProtocols()));
 
     Set<String> expectedCipherSet =
-        createSet(
+        set(
             CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
             CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName);
     assertEquals(expectedCipherSet, expectedCipherSet);
   }
 
-  @Test
-  public void tls_defaultCiphers_withFallbackIndicator() throws Exception {
+  @Test public void tls_defaultCiphers_withFallbackIndicator() throws Exception {
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
         .tlsVersions(TlsVersion.TLS_1_2)
         .supportsTlsExtensions(false)
@@ -108,10 +125,10 @@ public void tls_defaultCiphers_withFallbackIndicator() throws Exception {
     assertTrue(tlsSpec.isCompatible(socket));
     tlsSpec.apply(socket, true /* isFallback */);
 
-    assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
+    assertEquals(set(TlsVersion.TLS_1_2.javaName), set(socket.getEnabledProtocols()));
 
     Set<String> expectedCipherSet =
-        createSet(
+        set(
             CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
             CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName);
     if (Arrays.asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
@@ -120,8 +137,7 @@ public void tls_defaultCiphers_withFallbackIndicator() throws Exception {
     assertEquals(expectedCipherSet, expectedCipherSet);
   }
 
-  @Test
-  public void tls_explicitCiphers() throws Exception {
+  @Test public void tls_explicitCiphers() throws Exception {
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
         .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
         .tlsVersions(TlsVersion.TLS_1_2)
@@ -141,17 +157,16 @@ public void tls_explicitCiphers() throws Exception {
     assertTrue(tlsSpec.isCompatible(socket));
     tlsSpec.apply(socket, true /* isFallback */);
 
-    assertEquals(createSet(TlsVersion.TLS_1_2.javaName), createSet(socket.getEnabledProtocols()));
+    assertEquals(set(TlsVersion.TLS_1_2.javaName), set(socket.getEnabledProtocols()));
 
-    Set<String> expectedCipherSet = createSet(CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName);
+    Set<String> expectedCipherSet = set(CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName);
     if (Arrays.asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
       expectedCipherSet.add("TLS_FALLBACK_SCSV");
     }
     assertEquals(expectedCipherSet, expectedCipherSet);
   }
 
-  @Test
-  public void tls_stringCiphersAndVersions() throws Exception {
+  @Test public void tls_stringCiphersAndVersions() throws Exception {
     // Supporting arbitrary input strings allows users to enable suites and versions that are not
     // yet known to the library, but are supported by the platform.
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
@@ -160,7 +175,7 @@ public void tls_stringCiphersAndVersions() throws Exception {
         .build();
   }
 
-  public void tls_missingRequiredCipher() throws Exception {
+  @Test public void tls_missingRequiredCipher() throws Exception {
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
         .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
         .tlsVersions(TlsVersion.TLS_1_2)
@@ -185,8 +200,43 @@ public void tls_missingRequiredCipher() throws Exception {
     assertFalse(tlsSpec.isCompatible(socket));
   }
 
-  @Test
-  public void tls_missingTlsVersion() throws Exception {
+  @Test public void allEnabledCipherSuites() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .allEnabledCipherSuites()
+        .build();
+    assertNull(tlsSpec.cipherSuites());
+
+    SSLSocket sslSocket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    sslSocket.setEnabledCipherSuites(new String[] {
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+    });
+
+    tlsSpec.apply(sslSocket, false);
+    assertEquals(Arrays.asList(
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName),
+        Arrays.asList(sslSocket.getEnabledCipherSuites()));
+  }
+
+  @Test public void allEnabledTlsVersions() throws Exception {
+    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .allEnabledTlsVersions()
+        .build();
+    assertNull(tlsSpec.tlsVersions());
+
+    SSLSocket sslSocket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
+    sslSocket.setEnabledProtocols(new String[] {
+        TlsVersion.SSL_3_0.javaName(),
+        TlsVersion.TLS_1_1.javaName()
+    });
+
+    tlsSpec.apply(sslSocket, false);
+    assertEquals(Arrays.asList(TlsVersion.SSL_3_0.javaName(), TlsVersion.TLS_1_1.javaName()),
+        Arrays.asList(sslSocket.getEnabledProtocols()));
+  }
+
+  @Test public void tls_missingTlsVersion() throws Exception {
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
         .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
         .tlsVersions(TlsVersion.TLS_1_2)
@@ -199,14 +249,55 @@ public void tls_missingTlsVersion() throws Exception {
     });
 
     socket.setEnabledProtocols(
-        new String[] { TlsVersion.TLS_1_2.javaName, TlsVersion.TLS_1_1.javaName });
+        new String[] {TlsVersion.TLS_1_2.javaName, TlsVersion.TLS_1_1.javaName});
     assertTrue(tlsSpec.isCompatible(socket));
 
-    socket.setEnabledProtocols(new String[] { TlsVersion.TLS_1_1.javaName });
+    socket.setEnabledProtocols(new String[] {TlsVersion.TLS_1_1.javaName});
     assertFalse(tlsSpec.isCompatible(socket));
   }
 
-  private static Set<String> createSet(String... values) {
-    return new LinkedHashSet<String>(Arrays.asList(values));
+  @Test public void equalsAndHashCode() throws Exception {
+    ConnectionSpec allCipherSuites = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .allEnabledCipherSuites()
+        .build();
+    ConnectionSpec allTlsVersions = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .allEnabledTlsVersions()
+        .build();
+
+    Set<Object> set = new CopyOnWriteArraySet<>();
+    assertTrue(set.add(ConnectionSpec.MODERN_TLS));
+    assertTrue(set.add(ConnectionSpec.COMPATIBLE_TLS));
+    assertTrue(set.add(ConnectionSpec.CLEARTEXT));
+    assertTrue(set.add(allTlsVersions));
+    assertTrue(set.add(allCipherSuites));
+
+    assertTrue(set.remove(ConnectionSpec.MODERN_TLS));
+    assertTrue(set.remove(ConnectionSpec.COMPATIBLE_TLS));
+    assertTrue(set.remove(ConnectionSpec.CLEARTEXT));
+    assertTrue(set.remove(allTlsVersions));
+    assertTrue(set.remove(allCipherSuites));
+    assertTrue(set.isEmpty());
+  }
+
+  @Test public void allEnabledToString() throws Exception {
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .allEnabledTlsVersions()
+        .allEnabledCipherSuites()
+        .build();
+    assertEquals("ConnectionSpec(cipherSuites=[all enabled], tlsVersions=[all enabled], "
+        + "supportsTlsExtensions=true)", connectionSpec.toString());
+  }
+
+  @Test public void simpleToString() throws Exception {
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .tlsVersions(TlsVersion.TLS_1_2)
+        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
+        .build();
+    assertEquals("ConnectionSpec(cipherSuites=[TLS_RSA_WITH_RC4_128_MD5], tlsVersions=[TLS_1_2], "
+        + "supportsTlsExtensions=true)", connectionSpec.toString());
+  }
+
+  private static <T> Set<T> set(T... values) {
+    return new LinkedHashSet<>(Arrays.asList(values));
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CookieTest.java b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
new file mode 100644
index 0000000000..bee549dc7d
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
@@ -0,0 +1,495 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+import java.util.Objects;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpDate;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CookieTest {
+  HttpUrl url = HttpUrl.parse("https://example.com/");
+
+  @Test public void simpleCookie() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42");
+    assertEquals("SID=31d4d96e407aad42; path=/", cookie.toString());
+  }
+
+  @Test public void noEqualsSign() throws Exception {
+    assertNull(Cookie.parse(url, "foo"));
+    assertNull(Cookie.parse(url, "foo; Path=/"));
+  }
+
+  @Test public void emptyName() throws Exception {
+    assertNull(Cookie.parse(url, "=b"));
+    assertNull(Cookie.parse(url, " =b"));
+    assertNull(Cookie.parse(url, "\r\t \n=b"));
+  }
+
+  @Test public void trimLeadingAndTrailingWhitespaceFromName() throws Exception {
+    assertEquals("a", Cookie.parse(url, " a=b").name());
+    assertEquals("a", Cookie.parse(url, "a =b").name());
+    assertEquals("a", Cookie.parse(url, "\r\t \na\n\t \n=b").name());
+  }
+
+  @Test public void emptyValue() throws Exception {
+    assertEquals("", Cookie.parse(url, "a=").value());
+    assertEquals("", Cookie.parse(url, "a= ").value());
+    assertEquals("", Cookie.parse(url, "a=\r\t \n").value());
+  }
+
+  @Test public void trimLeadingAndTrailingWhitespaceFromValue() throws Exception {
+    assertEquals("", Cookie.parse(url, "a= ").value());
+    assertEquals("b", Cookie.parse(url, "a= b").value());
+    assertEquals("b", Cookie.parse(url, "a=b ").value());
+    assertEquals("b", Cookie.parse(url, "a=\r\t \nb\n\t \n").value());
+  }
+
+  @Test public void maxAge() throws Exception {
+    assertEquals(51000L,
+        Cookie.parse(50000L, url, "a=b; Max-Age=1").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854724").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854725").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854726").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=1").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=2").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=3").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=10000000000000000000").expiresAt());
+  }
+
+  @Test public void maxAgeNonPositive() throws Exception {
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=-1").expiresAt());
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=0").expiresAt());
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=-9223372036854775808").expiresAt());
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=-9223372036854775809").expiresAt());
+    assertEquals(Long.MIN_VALUE,
+        Cookie.parse(50000L, url, "a=b; Max-Age=-10000000000000000000").expiresAt());
+  }
+
+  @Test public void domainAndPath() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Domain=example.com");
+    assertEquals("example.com", cookie.domain());
+    assertEquals("/", cookie.path());
+    assertFalse(cookie.hostOnly());
+    assertEquals("SID=31d4d96e407aad42; domain=example.com; path=/", cookie.toString());
+  }
+
+  @Test public void secureAndHttpOnly() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Secure; HttpOnly");
+    assertTrue(cookie.secure());
+    assertTrue(cookie.httpOnly());
+    assertEquals("SID=31d4d96e407aad42; path=/; secure; httponly", cookie.toString());
+  }
+
+  @Test public void expiresDate() throws Exception {
+    assertEquals(date("1970-01-01T00:00:00.000+0000"), new Date(
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT").expiresAt()));
+    assertEquals(date("2021-06-09T10:18:14.000+0000"), new Date(
+        Cookie.parse(url, "a=b; Expires=Wed, 09 Jun 2021 10:18:14 GMT").expiresAt()));
+    assertEquals(date("1994-11-06T08:49:37.000+0000"), new Date(
+        Cookie.parse(url, "a=b; Expires=Sun, 06 Nov 1994 08:49:37 GMT").expiresAt()));
+  }
+
+  @Test public void awkwardDates() throws Exception {
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 70 00:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 January 1970 00:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Janucember 1970 00:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 1 Jan 1970 00:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 0:00:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:0:00 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:0 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=00:00:00 Thu, 01 Jan 1970 GMT").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 01").expiresAt());
+    assertEquals(0L,
+        Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 1").expiresAt());
+  }
+
+  @Test public void invalidYear() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1600 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 19999 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 00:00:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidMonth() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Foo 1970 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Foocember 1970 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 1970 00:00:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidDayOfMonth() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 32 Jan 1970 00:00:00 GMT").expiresAt());
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, Jan 1970 00:00:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidHour() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 24:00:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidMinute() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:60:00 GMT").expiresAt());
+  }
+
+  @Test public void invalidSecond() throws Exception {
+    assertEquals(HttpDate.MAX_DATE,
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:60 GMT").expiresAt());
+  }
+
+  @Test public void domainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com");
+    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+  }
+
+  /** If no domain is present, match only the origin domain. */
+  @Test public void domainMatchesNoDomain() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b");
+    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+  }
+
+  /** Ignore an optional leading `.` in the domain. */
+  @Test public void domainMatchesIgnoresLeadingDot() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=.example.com");
+    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+  }
+
+  /** Ignore the entire attribute if the domain ends with `.`. */
+  @Test public void domainIgnoredWithTrailingDot() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com.");
+    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+  }
+
+  @Test public void idnDomainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.parse("http://☃.net/"), "a=b; domain=☃.net");
+    assertTrue(cookie.matches(HttpUrl.parse("http://☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://xn--n3h.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.xn--n3h.net/")));
+  }
+
+  @Test public void punycodeDomainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.parse("http://xn--n3h.net/"), "a=b; domain=xn--n3h.net");
+    assertTrue(cookie.matches(HttpUrl.parse("http://☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://xn--n3h.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.parse("http://www.xn--n3h.net/")));
+  }
+
+  @Test public void domainMatchesIpAddress() throws Exception {
+    HttpUrl urlWithIp = HttpUrl.parse("http://123.45.234.56/");
+    assertNull(Cookie.parse(urlWithIp, "a=b; domain=234.56"));
+    assertEquals("123.45.234.56", Cookie.parse(urlWithIp, "a=b; domain=123.45.234.56").domain());
+  }
+
+  @Test public void hostOnly() throws Exception {
+    assertTrue(Cookie.parse(url, "a=b").hostOnly());
+    assertFalse(Cookie.parse(url, "a=b; domain=example.com").hostOnly());
+  }
+
+  @Test public void defaultPath() throws Exception {
+    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"), "a=b").path());
+    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/"), "a=b").path());
+    assertEquals("/", Cookie.parse(HttpUrl.parse("http://example.com/foo"), "a=b").path());
+    assertEquals("/", Cookie.parse(HttpUrl.parse("http://example.com/"), "a=b").path());
+  }
+
+  @Test public void defaultPathIsUsedIfPathDoesntHaveLeadingSlash() throws Exception {
+    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+        "a=b; path=quux").path());
+    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+        "a=b; path=").path());
+  }
+
+  @Test public void pathAttributeDoesntNeedToMatch() throws Exception {
+    assertEquals("/quux", Cookie.parse(HttpUrl.parse("http://example.com/"),
+        "a=b; path=/quux").path());
+    assertEquals("/quux", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+        "a=b; path=/quux").path());
+  }
+
+  @Test public void httpOnly() throws Exception {
+    assertFalse(Cookie.parse(url, "a=b").httpOnly());
+    assertTrue(Cookie.parse(url, "a=b; HttpOnly").httpOnly());
+  }
+
+  @Test public void secure() throws Exception {
+    assertFalse(Cookie.parse(url, "a=b").secure());
+    assertTrue(Cookie.parse(url, "a=b; Secure").secure());
+  }
+
+  @Test public void maxAgeTakesPrecedenceOverExpires() throws Exception {
+    // Max-Age = 1, Expires = 2. In either order.
+    assertEquals(1000L, Cookie.parse(
+        0L, url, "a=b; Max-Age=1; Expires=Thu, 01 Jan 1970 00:00:02 GMT").expiresAt());
+    assertEquals(1000L, Cookie.parse(
+        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:02 GMT; Max-Age=1").expiresAt());
+    // Max-Age = 2, Expires = 1. In either order.
+    assertEquals(2000L, Cookie.parse(
+        0L, url, "a=b; Max-Age=2; Expires=Thu, 01 Jan 1970 00:00:01 GMT").expiresAt());
+    assertEquals(2000L, Cookie.parse(
+        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Max-Age=2").expiresAt());
+  }
+
+  /** If a cookie incorrectly defines multiple 'Max-Age' attributes, the last one defined wins. */
+  @Test public void lastMaxAgeWins() throws Exception {
+    assertEquals(3000L, Cookie.parse(
+        0L, url, "a=b; Max-Age=2; Max-Age=4; Max-Age=1; Max-Age=3").expiresAt());
+  }
+
+  /** If a cookie incorrectly defines multiple 'Expires' attributes, the last one defined wins. */
+  @Test public void lastExpiresAtWins() throws Exception {
+    assertEquals(3000L, Cookie.parse(0L, url, "a=b; "
+        + "Expires=Thu, 01 Jan 1970 00:00:02 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:04 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:01 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:03 GMT").expiresAt());
+  }
+
+  @Test public void maxAgeOrExpiresMakesCookiePersistent() throws Exception {
+    assertFalse(Cookie.parse(0L, url, "a=b").persistent());
+    assertTrue(Cookie.parse(0L, url, "a=b; Max-Age=1").persistent());
+    assertTrue(Cookie.parse(0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT").persistent());
+  }
+
+  @Test public void parseAll() throws Exception {
+    Headers headers = new Headers.Builder()
+        .add("Set-Cookie: a=b")
+        .add("Set-Cookie: c=d")
+        .build();
+    List<Cookie> cookies = Cookie.parseAll(url, headers);
+    assertEquals(2, cookies.size());
+    assertEquals("a=b; path=/", cookies.get(0).toString());
+    assertEquals("c=d; path=/", cookies.get(1).toString());
+  }
+
+  @Test public void builder() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain("example.com")
+        .build();
+    assertEquals("a", cookie.name());
+    assertEquals("b", cookie.value());
+    assertEquals(HttpDate.MAX_DATE, cookie.expiresAt());
+    assertEquals("example.com", cookie.domain());
+    assertEquals("/", cookie.path());
+    assertFalse(cookie.secure());
+    assertFalse(cookie.httpOnly());
+    assertFalse(cookie.persistent());
+    assertFalse(cookie.hostOnly());
+  }
+
+  @Test public void builderNameValidation() throws Exception {
+    try {
+      new Cookie.Builder().name(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      new Cookie.Builder().name(" a ");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderValueValidation() throws Exception {
+    try {
+      new Cookie.Builder().value(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      new Cookie.Builder().value(" b ");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderClampsMaxDate() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(Long.MAX_VALUE)
+        .build();
+    assertEquals("a=b; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/", cookie.toString());
+  }
+
+  @Test public void builderExpiresAt() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(date("1970-01-01T00:00:01.000+0000").getTime())
+        .build();
+    assertEquals("a=b; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/", cookie.toString());
+  }
+
+  @Test public void builderClampsMinDate() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(date("1970-01-01T00:00:00.000+0000").getTime())
+        .build();
+    assertEquals("a=b; max-age=0; path=/", cookie.toString());
+  }
+
+  @Test public void builderDomainValidation() throws Exception {
+    try {
+      new Cookie.Builder().hostOnlyDomain(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      new Cookie.Builder().hostOnlyDomain("a/b");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderDomain() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("squareup.com")
+        .build();
+    assertEquals("squareup.com", cookie.domain());
+    assertTrue(cookie.hostOnly());
+  }
+
+  @Test public void builderPath() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .path("/foo")
+        .build();
+    assertEquals("/foo", cookie.path());
+  }
+
+  @Test public void builderPathValidation() throws Exception {
+    try {
+      new Cookie.Builder().path(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      new Cookie.Builder().path("foo");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderSecure() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .secure()
+        .build();
+    assertEquals(true, cookie.secure());
+  }
+
+  @Test public void builderHttpOnly() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .httpOnly()
+        .build();
+    assertEquals(true, cookie.httpOnly());
+  }
+
+  @Test public void equalsAndHashCode() throws Exception {
+    List<String> cookieStrings = Arrays.asList(
+        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
+        "a= ; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
+        "a=b;          Domain=example.com; Max-Age=5; Secure; HttpOnly",
+        "a=b; Path=/c;                     Max-Age=5; Secure; HttpOnly",
+        "a=b; Path=/c; Domain=example.com;            Secure; HttpOnly",
+        "a=b; Path=/c; Domain=example.com; Max-Age=5;         HttpOnly",
+        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure;         "
+    );
+    for (String stringA : cookieStrings) {
+      Cookie cookieA = Cookie.parse(0, url, stringA);
+      for (String stringB : cookieStrings) {
+        Cookie cookieB = Cookie.parse(0, url, stringB);
+        if (Objects.equals(stringA, stringB)) {
+          assertEquals(cookieA.hashCode(), cookieB.hashCode());
+          assertEquals(cookieA, cookieB);
+        } else {
+          assertFalse(cookieA.hashCode() == cookieB.hashCode());
+          assertFalse(cookieA.equals(cookieB));
+        }
+      }
+      assertFalse(cookieA.equals(null));
+    }
+  }
+
+  private Date date(String s) throws ParseException {
+    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
+    format.setTimeZone(Util.UTC);
+    return format.parse(s);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocket.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
similarity index 99%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocket.java
rename to okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
index e13a50fcb9..f07559387b 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocket.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 import java.io.InputStream;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
similarity index 56%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocketFactory.java
rename to okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
index a14db22e67..5a14d0fbd6 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
@@ -13,19 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.Socket;
 import java.net.UnknownHostException;
-import javax.net.SocketFactory;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 
 /**
- * A {@link SSLSocketFactory} that delegates calls. Sockets can be configured after
- * creation by overriding {@link #configureSocket(javax.net.ssl.SSLSocket)}.
+ * A {@link SSLSocketFactory} that delegates calls. Sockets can be configured after creation by
+ * overriding {@link #configureSocket(javax.net.ssl.SSLSocket)}.
  */
 public class DelegatingSSLSocketFactory extends SSLSocketFactory {
 
@@ -35,62 +34,49 @@ public DelegatingSSLSocketFactory(SSLSocketFactory delegate) {
     this.delegate = delegate;
   }
 
-  @Override
-  public SSLSocket createSocket() throws IOException {
+  @Override public SSLSocket createSocket() throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket();
-    configureSocket(sslSocket);
-    return sslSocket;
+    return configureSocket(sslSocket);
   }
 
-  @Override
-  public SSLSocket createSocket(String host, int port) throws IOException, UnknownHostException {
+  @Override public SSLSocket createSocket(String host, int port) throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port);
-    configureSocket(sslSocket);
-    return sslSocket;
+    return configureSocket(sslSocket);
   }
 
-  @Override
-  public SSLSocket createSocket(String host, int port, InetAddress localAddress, int localPort)
-      throws IOException, UnknownHostException {
+  @Override public SSLSocket createSocket(
+      String host, int port, InetAddress localAddress, int localPort) throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port, localAddress, localPort);
-    configureSocket(sslSocket);
-    return sslSocket;
+    return configureSocket(sslSocket);
   }
 
-  @Override
-  public SSLSocket createSocket(InetAddress host, int port) throws IOException {
+  @Override public SSLSocket createSocket(InetAddress host, int port) throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port);
-    configureSocket(sslSocket);
-    return sslSocket;
+    return configureSocket(sslSocket);
   }
 
-  @Override
-  public SSLSocket createSocket(InetAddress host, int port, InetAddress localAddress, int localPort)
-      throws IOException {
+  @Override public SSLSocket createSocket(
+      InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port, localAddress, localPort);
-    configureSocket(sslSocket);
-    return sslSocket;
+    return configureSocket(sslSocket);
   }
 
-  @Override
-  public String[] getDefaultCipherSuites() {
+  @Override public String[] getDefaultCipherSuites() {
     return delegate.getDefaultCipherSuites();
   }
 
-  @Override
-  public String[] getSupportedCipherSuites() {
+  @Override public String[] getSupportedCipherSuites() {
     return delegate.getSupportedCipherSuites();
   }
 
-  @Override
-  public SSLSocket createSocket(Socket socket, String host, int port, boolean autoClose)
-      throws IOException {
+  @Override public SSLSocket createSocket(
+      Socket socket, String host, int port, boolean autoClose) throws IOException {
     SSLSocket sslSocket = (SSLSocket) delegate.createSocket(socket, host, port, autoClose);
-    configureSocket(sslSocket);
-    return sslSocket;
+    return configureSocket(sslSocket);
   }
 
-  protected void configureSocket(SSLSocket sslSocket) throws IOException {
+  protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
     // No-op by default.
+    return sslSocket;
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingServerSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingServerSocketFactory.java
similarity index 84%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingServerSocketFactory.java
rename to okhttp-tests/src/test/java/okhttp3/DelegatingServerSocketFactory.java
index ef24aaaaeb..09b3a25d09 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingServerSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingServerSocketFactory.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 import java.net.InetAddress;
@@ -35,33 +35,30 @@ public DelegatingServerSocketFactory(ServerSocketFactory delegate) {
   @Override
   public ServerSocket createServerSocket() throws IOException {
     ServerSocket serverSocket = delegate.createServerSocket();
-    configureServerSocket(serverSocket);
-    return serverSocket;
+    return configureServerSocket(serverSocket);
   }
 
   @Override
   public ServerSocket createServerSocket(int port) throws IOException {
     ServerSocket serverSocket = delegate.createServerSocket(port);
-    configureServerSocket(serverSocket);
-    return serverSocket;
+    return configureServerSocket(serverSocket);
   }
 
   @Override
   public ServerSocket createServerSocket(int port, int backlog) throws IOException {
     ServerSocket serverSocket = delegate.createServerSocket(port, backlog);
-    configureServerSocket(serverSocket);
-    return serverSocket;
+    return configureServerSocket(serverSocket);
   }
 
   @Override
   public ServerSocket createServerSocket(int port, int backlog, InetAddress ifAddress)
       throws IOException {
     ServerSocket serverSocket = delegate.createServerSocket(port, backlog, ifAddress);
-    configureServerSocket(serverSocket);
-    return serverSocket;
+    return configureServerSocket(serverSocket);
   }
 
-  protected void configureServerSocket(ServerSocket serverSocket) throws IOException {
+  protected ServerSocket configureServerSocket(ServerSocket serverSocket) throws IOException {
     // No-op by default.
+    return serverSocket;
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
similarity index 86%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSocketFactory.java
rename to okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
index e8fdfe80fd..d21f37a31a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 import java.net.InetAddress;
@@ -36,41 +36,37 @@ public DelegatingSocketFactory(SocketFactory delegate) {
   @Override
   public Socket createSocket() throws IOException {
     Socket socket = delegate.createSocket();
-    configureSocket(socket);
-    return socket;
+    return configureSocket(socket);
   }
 
   @Override
   public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
     Socket socket = delegate.createSocket(host, port);
-    configureSocket(socket);
-    return socket;
+    return configureSocket(socket);
   }
 
   @Override
   public Socket createSocket(String host, int port, InetAddress localAddress, int localPort)
       throws IOException, UnknownHostException {
     Socket socket = delegate.createSocket(host, port, localAddress, localPort);
-    configureSocket(socket);
-    return socket;
+    return configureSocket(socket);
   }
 
   @Override
   public Socket createSocket(InetAddress host, int port) throws IOException {
     Socket socket = delegate.createSocket(host, port);
-    configureSocket(socket);
-    return socket;
+    return configureSocket(socket);
   }
 
   @Override
   public Socket createSocket(InetAddress host, int port, InetAddress localAddress, int localPort)
       throws IOException {
     Socket socket = delegate.createSocket(host, port, localAddress, localPort);
-    configureSocket(socket);
-    return socket;
+    return configureSocket(socket);
   }
 
-  protected void configureSocket(Socket socket) throws IOException {
+  protected Socket configureSocket(Socket socket) throws IOException {
     // No-op by default.
+    return socket;
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
similarity index 59%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
rename to okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
index 3d7701f298..4dc3d0c6bd 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
@@ -1,23 +1,32 @@
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.Call.AsyncCall;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.Iterator;
+import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.AbstractExecutorService;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
+import okhttp3.RealCall.AsyncCall;
 import org.junit.Before;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class DispatcherTest {
   RecordingExecutor executor = new RecordingExecutor();
   RecordingCallback callback = new RecordingCallback();
   Dispatcher dispatcher = new Dispatcher(executor);
-  OkHttpClient client = new OkHttpClient().setDispatcher(dispatcher);
+  OkHttpClient client = new OkHttpClient.Builder()
+      .dispatcher(dispatcher)
+      .build();
 
   @Before public void setUp() throws Exception {
     dispatcher.setMaxRequests(20);
@@ -114,14 +123,118 @@
 
   @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
     dispatcher.setMaxRequests(1);
-    client.newCall(newRequest("http://a/1", "tag1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    dispatcher.cancel("tag1");
+    Call c1 = client.newCall(newRequest("http://a/1", "tag1"));
+    Call c2 = client.newCall(newRequest("http://a/2"));
+    c1.enqueue(callback);
+    c2.enqueue(callback);
+    c1.cancel();
     executor.assertJobs("http://a/1");
     executor.finishJob("http://a/1");
     executor.assertJobs("http://a/2");
   }
 
+  @Test public void asyncCallAccessors() throws Exception {
+    dispatcher.setMaxRequests(3);
+    Call a1 = client.newCall(newRequest("http://a/1"));
+    Call a2 = client.newCall(newRequest("http://a/2"));
+    Call a3 = client.newCall(newRequest("http://a/3"));
+    Call a4 = client.newCall(newRequest("http://a/4"));
+    Call a5 = client.newCall(newRequest("http://a/5"));
+    a1.enqueue(callback);
+    a2.enqueue(callback);
+    a3.enqueue(callback);
+    a4.enqueue(callback);
+    a5.enqueue(callback);
+    assertEquals(3, dispatcher.runningCallsCount());
+    assertEquals(2, dispatcher.queuedCallsCount());
+    assertEquals(set(a1, a2, a3), set(dispatcher.runningCalls()));
+    assertEquals(set(a4, a5), set(dispatcher.queuedCalls()));
+  }
+
+  @Test public void synchronousCallAccessors() throws Exception {
+    final CountDownLatch ready = new CountDownLatch(2);
+    final CountDownLatch waiting = new CountDownLatch(1);
+    client = client.newBuilder()
+        .addInterceptor(
+            new Interceptor() {
+              @Override public Response intercept(Chain chain) throws IOException {
+                try {
+                  ready.countDown();
+                  waiting.await();
+                } catch (InterruptedException e) {
+                  throw new AssertionError();
+                }
+                throw new IOException();
+              }
+            })
+        .build();
+
+    Call a1 = client.newCall(newRequest("http://a/1"));
+    Call a2 = client.newCall(newRequest("http://a/2"));
+    Call a3 = client.newCall(newRequest("http://a/3"));
+    Call a4 = client.newCall(newRequest("http://a/4"));
+    Thread t1 = makeSynchronousCall(a1);
+    Thread t2 = makeSynchronousCall(a2);
+
+    // We created 4 calls and started 2 of them. That's 2 running calls and 0 queued.
+    ready.await();
+    assertEquals(2, dispatcher.runningCallsCount());
+    assertEquals(0, dispatcher.queuedCallsCount());
+    assertEquals(set(a1, a2), set(dispatcher.runningCalls()));
+    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+
+    // Cancel some calls. That doesn't impact running or queued.
+    a2.cancel();
+    a3.cancel();
+    assertEquals(set(a1, a2), set(dispatcher.runningCalls()));
+    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+
+    // Let the calls finish.
+    waiting.countDown();
+    t1.join();
+    t2.join();
+
+    // Now we should have 0 running calls and 0 queued calls.
+    assertEquals(0, dispatcher.runningCallsCount());
+    assertEquals(0, dispatcher.queuedCallsCount());
+    assertEquals(Collections.emptyList(), dispatcher.runningCalls());
+    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+
+    assertTrue(a1.isExecuted());
+    assertFalse(a1.isCanceled());
+
+    assertTrue(a2.isExecuted());
+    assertTrue(a2.isCanceled());
+
+    assertFalse(a3.isExecuted());
+    assertTrue(a3.isCanceled());
+
+    assertFalse(a4.isExecuted());
+    assertFalse(a4.isCanceled());
+  }
+
+  private <T> Set<T> set(T... values) {
+    return set(Arrays.asList(values));
+  }
+
+  private <T> Set<T> set(List<T> list) {
+    return new LinkedHashSet<>(list);
+  }
+
+  private Thread makeSynchronousCall(final Call call) {
+    Thread thread = new Thread() {
+      @Override public void run() {
+        try {
+          call.execute();
+          throw new AssertionError();
+        } catch (IOException expected) {
+        }
+      }
+    };
+    thread.start();
+    return thread;
+  }
+
   class RecordingExecutor extends AbstractExecutorService {
     private List<AsyncCall> calls = new ArrayList<>();
 
@@ -132,7 +245,7 @@
     public void assertJobs(String... expectedUrls) {
       List<String> actualUrls = new ArrayList<>();
       for (AsyncCall call : calls) {
-        actualUrls.add(call.request().urlString());
+        actualUrls.add(call.request().url().toString());
       }
       assertEquals(Arrays.asList(expectedUrls), actualUrls);
     }
@@ -140,7 +253,7 @@ public void assertJobs(String... expectedUrls) {
     public void finishJob(String url) {
       for (Iterator<AsyncCall> i = calls.iterator(); i.hasNext(); ) {
         AsyncCall call = i.next();
-        if (call.request().urlString().equals(url)) {
+        if (call.request().url().toString().equals(url)) {
           i.remove();
           dispatcher.finished(call);
           return;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/FallbackTestClientSocketFactory.java b/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
similarity index 56%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/FallbackTestClientSocketFactory.java
rename to okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
index 5f9e623c1c..eb9aaaa2d3 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/FallbackTestClientSocketFactory.java
+++ b/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
@@ -13,11 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
-import java.net.InetAddress;
-import java.net.Socket;
 import java.util.ArrayList;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
@@ -31,8 +29,8 @@
  */
 public class FallbackTestClientSocketFactory extends DelegatingSSLSocketFactory {
   /**
-   * The cipher suite used during TLS connection fallback to indicate a fallback.
-   * See https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
+   * The cipher suite used during TLS connection fallback to indicate a fallback. See
+   * https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
    */
   public static final String TLS_FALLBACK_SCSV = "TLS_FALLBACK_SCSV";
 
@@ -40,37 +38,8 @@ public FallbackTestClientSocketFactory(SSLSocketFactory delegate) {
     super(delegate);
   }
 
-  @Override public SSLSocket createSocket(Socket s, String host, int port, boolean autoClose)
-      throws IOException {
-    SSLSocket socket = super.createSocket(s, host, port, autoClose);
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
-  }
-
-  @Override public SSLSocket createSocket() throws IOException {
-    SSLSocket socket = super.createSocket();
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
-  }
-
-  @Override public SSLSocket createSocket(String host,int port) throws IOException {
-    SSLSocket socket = super.createSocket(host, port);
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
-  }
-
-  @Override public SSLSocket createSocket(String host,int port, InetAddress localHost,
-      int localPort) throws IOException {
-    SSLSocket socket = super.createSocket(host, port, localHost, localPort);
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
-  }
-
-  @Override public SSLSocket createSocket(InetAddress host,int port) throws IOException {
-    SSLSocket socket = super.createSocket(host, port);
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
-  }
-
-  @Override public SSLSocket createSocket(InetAddress address,int port,
-      InetAddress localAddress, int localPort) throws IOException {
-    SSLSocket socket = super.createSocket(address, port, localAddress, localPort);
-    return new TlsFallbackScsvDisabledSSLSocket(socket);
+  @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
+    return new TlsFallbackScsvDisabledSSLSocket(sslSocket);
   }
 
   private static class TlsFallbackScsvDisabledSSLSocket extends DelegatingSSLSocket {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
similarity index 76%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java
rename to okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
index 04e74a4564..34e40b96f7 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 import okio.Buffer;
@@ -21,73 +21,91 @@
 
 import static org.junit.Assert.assertEquals;
 
-public final class FormEncodingBuilderTest {
+public final class FormBodyTest {
   @Test public void urlEncoding() throws Exception {
-    RequestBody formEncoding = new FormEncodingBuilder()
-        .add("a&b", "c=d")
+    FormBody body = new FormBody.Builder()
+        .add("a+=& b", "c+=& d")
         .add("space, the", "final frontier")
         .add("%25", "%25")
         .build();
 
-    assertEquals("application/x-www-form-urlencoded", formEncoding.contentType().toString());
+    assertEquals(3, body.size());
 
-    String expected = "a%26b=c%3Dd&space%2C%20the=final%20frontier&%2525=%2525";
-    assertEquals(expected.length(), formEncoding.contentLength());
+    assertEquals("a%2B%3D%26%20b", body.encodedName(0));
+    assertEquals("space%2C%20the", body.encodedName(1));
+    assertEquals("%2525", body.encodedName(2));
+
+    assertEquals("a+=& b", body.name(0));
+    assertEquals("space, the", body.name(1));
+    assertEquals("%25", body.name(2));
+
+    assertEquals("c%2B%3D%26%20d", body.encodedValue(0));
+    assertEquals("final%20frontier", body.encodedValue(1));
+    assertEquals("%2525", body.encodedValue(2));
+
+    assertEquals("c+=& d", body.value(0));
+    assertEquals("final frontier", body.value(1));
+    assertEquals("%25", body.value(2));
+
+    assertEquals("application/x-www-form-urlencoded", body.contentType().toString());
+
+    String expected = "a%2B%3D%26%20b=c%2B%3D%26%20d&space%2C%20the=final%20frontier&%2525=%2525";
+    assertEquals(expected.length(), body.contentLength());
 
     Buffer out = new Buffer();
-    formEncoding.writeTo(out);
+    body.writeTo(out);
     assertEquals(expected, out.readUtf8());
   }
 
   @Test public void addEncoded() throws Exception {
-    RequestBody formEncoding = new FormEncodingBuilder()
+    FormBody body = new FormBody.Builder()
         .addEncoded("a+=& b", "c+=& d")
         .addEncoded("e+=& f", "g+=& h")
         .addEncoded("%25", "%25")
         .build();
 
-    String expected = "a%20%3D%26%20b=c%20%3D%26%20d&e%20%3D%26%20f=g%20%3D%26%20h&%25=%25";
+    String expected = "a+%3D%26%20b=c+%3D%26%20d&e+%3D%26%20f=g+%3D%26%20h&%25=%25";
     Buffer out = new Buffer();
-    formEncoding.writeTo(out);
+    body.writeTo(out);
     assertEquals(expected, out.readUtf8());
   }
 
   @Test public void encodedPair() throws Exception {
-    RequestBody formEncoding = new FormEncodingBuilder()
+    FormBody body = new FormBody.Builder()
         .add("sim", "ple")
         .build();
 
     String expected = "sim=ple";
-    assertEquals(expected.length(), formEncoding.contentLength());
+    assertEquals(expected.length(), body.contentLength());
 
     Buffer buffer = new Buffer();
-    formEncoding.writeTo(buffer);
+    body.writeTo(buffer);
     assertEquals(expected, buffer.readUtf8());
   }
 
   @Test public void encodeMultiplePairs() throws Exception {
-    RequestBody formEncoding = new FormEncodingBuilder()
+    FormBody body = new FormBody.Builder()
         .add("sim", "ple")
         .add("hey", "there")
         .add("help", "me")
         .build();
 
     String expected = "sim=ple&hey=there&help=me";
-    assertEquals(expected.length(), formEncoding.contentLength());
+    assertEquals(expected.length(), body.contentLength());
 
     Buffer buffer = new Buffer();
-    formEncoding.writeTo(buffer);
+    body.writeTo(buffer);
     assertEquals(expected, buffer.readUtf8());
   }
 
   @Test public void buildEmptyForm() throws Exception {
-    RequestBody formEncoding = new FormEncodingBuilder().build();
+    FormBody body = new FormBody.Builder().build();
 
     String expected = "";
-    assertEquals(expected.length(), formEncoding.contentLength());
+    assertEquals(expected.length(), body.contentLength());
 
     Buffer buffer = new Buffer();
-    formEncoding.writeTo(buffer);
+    body.writeTo(buffer);
     assertEquals(expected, buffer.readUtf8());
   }
 
@@ -170,8 +188,8 @@
 
   private String formEncode(int codePoint) throws IOException {
     // Wrap the codepoint with regular printable characters to prevent trimming.
-    RequestBody body = new FormEncodingBuilder()
-        .add("a", new String(new int[] { 'b', codePoint, 'c' }, 0, 3))
+    FormBody body = new FormBody.Builder()
+        .add("a", new String(new int[] {'b', codePoint, 'c'}, 0, 3))
         .build();
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
similarity index 77%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/HttpUrlTest.java
rename to okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
index b281069f5f..f7d655dbf0 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/HttpUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -13,20 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.UrlComponentEncodingTester.Component;
-import com.squareup.okhttp.UrlComponentEncodingTester.Encoding;
+import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URL;
+import java.net.UnknownHostException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.LinkedHashSet;
+import okhttp3.UrlComponentEncodingTester.Component;
+import okhttp3.UrlComponentEncodingTester.Encoding;
 import org.junit.Ignore;
 import org.junit.Test;
 
 import static java.util.Collections.singletonList;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
 public final class HttpUrlTest {
@@ -40,6 +43,11 @@
     assertEquals(expected, HttpUrl.parse("http://host/").resolve("  .  "));
   }
 
+  @Test public void parseHostAsciiNonPrintable() throws Exception {
+    String host = "host\u0001";
+    assertNull(HttpUrl.parse("http://" + host + "/"));
+  }
+
   @Test public void parseDoesNotTrimOtherWhitespaceCharacters() throws Exception {
     // Whitespace characters list from Google's Guava team: http://goo.gl/IcR9RD
     assertEquals("/%0B", HttpUrl.parse("http://h/\u000b").encodedPath()); // line tabulation
@@ -81,6 +89,8 @@
     assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("HTTP://host/"));
     assertEquals(HttpUrl.parse("https://host/"), HttpUrl.parse("https://host/"));
     assertEquals(HttpUrl.parse("https://host/"), HttpUrl.parse("HTTPS://host/"));
+    assertEquals(HttpUrl.Builder.ParseResult.UNSUPPORTED_SCHEME,
+        new HttpUrl.Builder().parse(null, "image640://480.png"));
     assertEquals(null, HttpUrl.parse("httpp://host/"));
     assertEquals(null, HttpUrl.parse("0ttp://host/"));
     assertEquals(null, HttpUrl.parse("ht+tp://host/"));
@@ -98,6 +108,22 @@
     assertEquals(null, HttpUrl.parse("#fragment"));
   }
 
+  @Test public void newBuilderResolve() throws Exception {
+    // Non-exhaustive tests because implementation is the same as resolve.
+    HttpUrl base = HttpUrl.parse("http://host/a/b");
+    assertEquals(HttpUrl.parse("https://host2/"), base.newBuilder("https://host2").build());
+    assertEquals(HttpUrl.parse("http://host2/"), base.newBuilder("//host2").build());
+    assertEquals(HttpUrl.parse("http://host/path"), base.newBuilder("/path").build());
+    assertEquals(HttpUrl.parse("http://host/a/path"), base.newBuilder("path").build());
+    assertEquals(HttpUrl.parse("http://host/a/b?query"), base.newBuilder("?query").build());
+    assertEquals(HttpUrl.parse("http://host/a/b#fragment"), base.newBuilder("#fragment").build());
+    assertEquals(HttpUrl.parse("http://host/a/b"), base.newBuilder("").build());
+    assertEquals(null, base.newBuilder("ftp://b"));
+    assertEquals(null, base.newBuilder("ht+tp://b"));
+    assertEquals(null, base.newBuilder("ht-tp://b"));
+    assertEquals(null, base.newBuilder("ht.tp://b"));
+  }
+
   @Test public void resolveNoScheme() throws Exception {
     HttpUrl base = HttpUrl.parse("http://host/a/b");
     assertEquals(HttpUrl.parse("http://host2/"), base.resolve("//host2"));
@@ -186,11 +212,20 @@
     assertEquals(HttpUrl.parse("http://user@host/path"), HttpUrl.parse("http://user@host/path"));
   }
 
+  /** Given multiple '@' characters, the last one is the delimiter. */
   @Test public void authorityWithMultipleAtSigns() throws Exception {
-    assertEquals(HttpUrl.parse("http://foo%40bar@baz/path"),
-        HttpUrl.parse("http://foo@bar@baz/path"));
-    assertEquals(HttpUrl.parse("http://foo:pass1%40bar%3Apass2@baz/path"),
-        HttpUrl.parse("http://foo:pass1@bar:pass2@baz/path"));
+    HttpUrl httpUrl = HttpUrl.parse("http://foo@bar@baz/path");
+    assertEquals("foo@bar", httpUrl.username());
+    assertEquals("", httpUrl.password());
+    assertEquals(HttpUrl.parse("http://foo%40bar@baz/path"), httpUrl);
+  }
+
+  /** Given multiple ':' characters, the first one is the delimiter. */
+  @Test public void authorityWithMultipleColons() throws Exception {
+    HttpUrl httpUrl = HttpUrl.parse("http://foo:pass1@bar:pass2@baz/path");
+    assertEquals("foo", httpUrl.username());
+    assertEquals("pass1@bar:pass2", httpUrl.password());
+    assertEquals(HttpUrl.parse("http://foo:pass1%40bar%3Apass2@baz/path"), httpUrl);
   }
 
   @Test public void usernameAndPassword() throws Exception {
@@ -403,6 +438,15 @@
     assertEquals("::", HttpUrl.parse("http://[0:0:0:0:0:0:0:0]/").host());
   }
 
+  /** The builder permits square braces but does not require them. */
+  @Test public void hostIPv6Builder() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://example.com/");
+    assertEquals("http://[::1]/", base.newBuilder().host("[::1]").build().toString());
+    assertEquals("http://[::1]/", base.newBuilder().host("[::0001]").build().toString());
+    assertEquals("http://[::1]/", base.newBuilder().host("::1").build().toString());
+    assertEquals("http://[::1]/", base.newBuilder().host("::0001").build().toString());
+  }
+
   @Test public void hostIpv4CanonicalForm() throws Exception {
     assertEquals("255.255.255.255", HttpUrl.parse("http://255.255.255.255/").host());
     assertEquals("1.2.3.4", HttpUrl.parse("http://1.2.3.4/").host());
@@ -447,8 +491,40 @@
     new UrlComponentEncodingTester()
         .override(Encoding.IDENTITY, ' ', '"', '#', '<', '>', '?', '`')
         .skipForUri('%', ' ', '"', '#', '<', '>', '\\', '^', '`', '{', '|', '}')
+        .identityForNonAscii()
         .test(Component.FRAGMENT);
-    // TODO(jwilson): don't percent-encode non-ASCII characters. (But do encode control characters!)
+  }
+
+  @Test public void fragmentNonAscii() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#Σ");
+    assertEquals("http://host/#Σ", url.toString());
+    assertEquals("Σ", url.fragment());
+    assertEquals("Σ", url.encodedFragment());
+    assertEquals("http://host/#Σ", url.uri().toString());
+  }
+
+  @Test public void fragmentNonAsciiThatOffendsJavaNetUri() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#\u0080");
+    assertEquals("http://host/#\u0080", url.toString());
+    assertEquals("\u0080", url.fragment());
+    assertEquals("\u0080", url.encodedFragment());
+    assertEquals(new URI("http://host/#"), url.uri()); // Control characters may be stripped!
+  }
+
+  @Test public void fragmentPercentEncodedNonAscii() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#%C2%80");
+    assertEquals("http://host/#%C2%80", url.toString());
+    assertEquals("\u0080", url.fragment());
+    assertEquals("%C2%80", url.encodedFragment());
+    assertEquals("http://host/#%C2%80", url.uri().toString());
+  }
+
+  @Test public void fragmentPercentEncodedPartialCodePoint() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#%80");
+    assertEquals("http://host/#%80", url.toString());
+    assertEquals("\ufffd", url.fragment()); // Unicode replacement character.
+    assertEquals("%80", url.encodedFragment());
+    assertEquals("http://host/#%80", url.uri().toString());
   }
 
   @Test public void relativePath() throws Exception {
@@ -544,6 +620,8 @@
         HttpUrl.parse("http://host/%/b").pathSegments());
     assertEquals(Arrays.asList("%"),
         HttpUrl.parse("http://host/%").pathSegments());
+    assertEquals(Arrays.asList("%00"),
+        HttpUrl.parse("http://github.com/%%30%30").pathSegments());
   }
 
   @Test public void malformedUtf8Encoding() {
@@ -732,6 +810,64 @@
     assertEquals(3, HttpUrl.parse("http://host/a/b/c").pathSize());
   }
 
+  @Test public void addPathSegments() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+
+    // Add a string with zero slashes: resulting URL gains one slash.
+    assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
+    assertEquals("/a/b/c/d", base.newBuilder().addPathSegments("d").build().encodedPath());
+
+    // Add a string with one slash: resulting URL gains two slashes.
+    assertEquals("/a/b/c//", base.newBuilder().addPathSegments("/").build().encodedPath());
+    assertEquals("/a/b/c/d/", base.newBuilder().addPathSegments("d/").build().encodedPath());
+    assertEquals("/a/b/c//d", base.newBuilder().addPathSegments("/d").build().encodedPath());
+
+    // Add a string with two slashes: resulting URL gains three slashes.
+    assertEquals("/a/b/c///", base.newBuilder().addPathSegments("//").build().encodedPath());
+    assertEquals("/a/b/c//d/", base.newBuilder().addPathSegments("/d/").build().encodedPath());
+    assertEquals("/a/b/c/d//", base.newBuilder().addPathSegments("d//").build().encodedPath());
+    assertEquals("/a/b/c///d", base.newBuilder().addPathSegments("//d").build().encodedPath());
+    assertEquals("/a/b/c/d/e/f", base.newBuilder().addPathSegments("d/e/f").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentsOntoTrailingSlash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c/");
+
+    // Add a string with zero slashes: resulting URL gains zero slashes.
+    assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
+    assertEquals("/a/b/c/d", base.newBuilder().addPathSegments("d").build().encodedPath());
+
+    // Add a string with one slash: resulting URL gains one slash.
+    assertEquals("/a/b/c//", base.newBuilder().addPathSegments("/").build().encodedPath());
+    assertEquals("/a/b/c/d/", base.newBuilder().addPathSegments("d/").build().encodedPath());
+    assertEquals("/a/b/c//d", base.newBuilder().addPathSegments("/d").build().encodedPath());
+
+    // Add a string with two slashes: resulting URL gains two slashes.
+    assertEquals("/a/b/c///", base.newBuilder().addPathSegments("//").build().encodedPath());
+    assertEquals("/a/b/c//d/", base.newBuilder().addPathSegments("/d/").build().encodedPath());
+    assertEquals("/a/b/c/d//", base.newBuilder().addPathSegments("d//").build().encodedPath());
+    assertEquals("/a/b/c///d", base.newBuilder().addPathSegments("//d").build().encodedPath());
+    assertEquals("/a/b/c/d/e/f", base.newBuilder().addPathSegments("d/e/f").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentsWithBackslash() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/");
+    assertEquals("/d/e", base.newBuilder().addPathSegments("d\\e").build().encodedPath());
+    assertEquals("/d/e", base.newBuilder().addEncodedPathSegments("d\\e").build().encodedPath());
+  }
+
+  @Test public void addPathSegmentsWithEmptyPaths() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c//d/e///f",
+        base.newBuilder().addPathSegments("/d/e///f").build().encodedPath());
+  }
+
+  @Test public void addEncodedPathSegments() throws Exception {
+    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    assertEquals("/a/b/c/d/e/%20/",
+        base.newBuilder().addEncodedPathSegments("d/e/%20/\n").build().encodedPath());
+  }
+
   @Test public void addPathSegmentDotDoesNothing() throws Exception {
     HttpUrl base = HttpUrl.parse("http://host/a/b/c");
     assertEquals("/a/b/c", base.newBuilder().addPathSegment(".").build().encodedPath());
@@ -912,14 +1048,134 @@
     assertEquals("http://username:password@host/path?query#fragment", uri.toString());
   }
 
-  @Test public void toUriForbiddenCharacter() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://host/a[b");
-    try {
-      httpUrl.uri();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertEquals("not valid as a java.net.URI: http://host/a[b", expected.getMessage());
-    }
+  @Test public void toUriSpecialQueryCharacters() throws Exception {
+    HttpUrl httpUrl = HttpUrl.parse("http://host/?d=abc!@[]^`{}|\\");
+    URI uri = httpUrl.uri();
+    assertEquals("http://host/?d=abc!@[]%5E%60%7B%7D%7C%5C", uri.toString());
+  }
+
+  @Test public void toUriWithUsernameNoPassword() throws Exception {
+    HttpUrl httpUrl = new HttpUrl.Builder()
+        .scheme("http")
+        .username("user")
+        .host("host")
+        .build();
+    assertEquals("http://user@host/", httpUrl.toString());
+    assertEquals("http://user@host/", httpUrl.uri().toString());
+  }
+
+  @Test public void toUriUsernameSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .username("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/", url.toString());
+    assertEquals("http://%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/", url.uri().toString());
+  }
+
+  @Test public void toUriPasswordSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .username("user")
+        .password("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://user:%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/", url.toString());
+    assertEquals("http://user:%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/",
+        url.uri().toString());
+  }
+
+  @Test public void toUriPathSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addPathSegment("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://host/=[]:;%22~%7C%3F%23@%5E%2F$%25*", url.toString());
+    assertEquals("http://host/=%5B%5D:;%22~%7C%3F%23@%5E%2F$%25*", url.uri().toString());
+  }
+
+  @Test public void toUriQueryParameterNameSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addQueryParameter("=[]:;\"~|?#@^/$%*", "a")
+        .build();
+    assertEquals("http://host/?%3D[]:;%22~|?%23@^/$%25*=a", url.toString());
+    assertEquals("http://host/?%3D[]:;%22~%7C?%23@%5E/$%25*=a", url.uri().toString());
+  }
+
+  @Test public void toUriQueryParameterValueSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addQueryParameter("a", "=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://host/?a=%3D[]:;%22~|?%23@^/$%25*", url.toString());
+    assertEquals("http://host/?a=%3D[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
+  }
+
+  @Test public void toUriQueryValueSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .query("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://host/?=[]:;%22~|?%23@^/$%25*", url.toString());
+    assertEquals("http://host/?=[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
+  }
+
+  @Test public void toUriFragmentSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .fragment("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertEquals("http://host/#=[]:;\"~|?#@^/$%25*", url.toString());
+    assertEquals("http://host/#=[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
+  }
+
+  @Test public void toUriWithControlCharacters() throws Exception {
+    // Percent-encoded in the path.
+    assertEquals(new URI("http://host/a%00b"), HttpUrl.parse("http://host/a\u0000b").uri());
+    assertEquals(new URI("http://host/a%C2%80b"), HttpUrl.parse("http://host/a\u0080b").uri());
+    assertEquals(new URI("http://host/a%C2%9Fb"), HttpUrl.parse("http://host/a\u009fb").uri());
+    // Percent-encoded in the query.
+    assertEquals(new URI("http://host/?a%00b"), HttpUrl.parse("http://host/?a\u0000b").uri());
+    assertEquals(new URI("http://host/?a%C2%80b"), HttpUrl.parse("http://host/?a\u0080b").uri());
+    assertEquals(new URI("http://host/?a%C2%9Fb"), HttpUrl.parse("http://host/?a\u009fb").uri());
+    // Stripped from the fragment.
+    assertEquals(new URI("http://host/#a%00b"), HttpUrl.parse("http://host/#a\u0000b").uri());
+    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u0080b").uri());
+    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u009fb").uri());
+  }
+
+  @Test public void toUriWithSpaceCharacters() throws Exception {
+    // Percent-encoded in the path.
+    assertEquals(new URI("http://host/a%0Bb"), HttpUrl.parse("http://host/a\u000bb").uri());
+    assertEquals(new URI("http://host/a%20b"), HttpUrl.parse("http://host/a b").uri());
+    assertEquals(new URI("http://host/a%E2%80%89b"), HttpUrl.parse("http://host/a\u2009b").uri());
+    assertEquals(new URI("http://host/a%E3%80%80b"), HttpUrl.parse("http://host/a\u3000b").uri());
+    // Percent-encoded in the query.
+    assertEquals(new URI("http://host/?a%0Bb"), HttpUrl.parse("http://host/?a\u000bb").uri());
+    assertEquals(new URI("http://host/?a%20b"), HttpUrl.parse("http://host/?a b").uri());
+    assertEquals(new URI("http://host/?a%E2%80%89b"), HttpUrl.parse("http://host/?a\u2009b").uri());
+    assertEquals(new URI("http://host/?a%E3%80%80b"), HttpUrl.parse("http://host/?a\u3000b").uri());
+    // Stripped from the fragment.
+    assertEquals(new URI("http://host/#a%0Bb"), HttpUrl.parse("http://host/#a\u000bb").uri());
+    assertEquals(new URI("http://host/#a%20b"), HttpUrl.parse("http://host/#a b").uri());
+    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u2009b").uri());
+    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u3000b").uri());
+  }
+
+  @Test public void toUriWithNonHexPercentEscape() throws Exception {
+    assertEquals(new URI("http://host/%25xx"), HttpUrl.parse("http://host/%xx").uri());
+  }
+
+  @Test public void toUriWithTruncatedPercentEscape() throws Exception {
+    assertEquals(new URI("http://host/%25a"), HttpUrl.parse("http://host/%a").uri());
+    assertEquals(new URI("http://host/%25"), HttpUrl.parse("http://host/%").uri());
   }
 
   @Test public void fromJavaNetUrl() throws Exception {
@@ -949,6 +1205,27 @@
     assertEquals(null, HttpUrl.get(uri));
   }
 
+  @Test public void fromJavaNetUrl_checked() throws Exception {
+    HttpUrl httpUrl = HttpUrl.getChecked("http://username:password@host/path?query#fragment");
+    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
+  }
+
+  @Test public void fromJavaNetUrlUnsupportedScheme_checked() throws Exception {
+    try {
+      HttpUrl.getChecked("mailto:user@example.com");
+      fail();
+    } catch (MalformedURLException e) {
+    }
+  }
+
+  @Test public void fromJavaNetUrlBadHost_checked() throws Exception {
+    try {
+      HttpUrl.getChecked("http://hostw ithspace/");
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
   @Test public void composeQueryWithComponents() throws Exception {
     HttpUrl base = HttpUrl.parse("http://host/");
     HttpUrl url = base.newBuilder().addQueryParameter("a+=& b", "c+=& d").build();
@@ -966,7 +1243,7 @@
   @Test public void composeQueryWithEncodedComponents() throws Exception {
     HttpUrl base = HttpUrl.parse("http://host/");
     HttpUrl url = base.newBuilder().addEncodedQueryParameter("a+=& b", "c+=& d").build();
-    assertEquals("http://host/?a%20%3D%26%20b=c%20%3D%26%20d", url.toString());
+    assertEquals("http://host/?a+%3D%26%20b=c+%3D%26%20d", url.toString());
     assertEquals("c =& d", url.queryParameter("a =& b"));
   }
 
@@ -1002,7 +1279,7 @@
         .addEncodedQueryParameter("a+=& b", "c+=& d")
         .setEncodedQueryParameter("a+=& b", "ef")
         .build();
-    assertEquals("http://host/?a%20%3D%26%20b=ef", url.toString());
+    assertEquals("http://host/?a+%3D%26%20b=ef", url.toString());
     assertEquals("ef", url.queryParameter("a =& b"));
   }
 
@@ -1113,8 +1390,8 @@
   }
 
   /**
-   * Although HttpUrl prefers percent-encodings in uppercase, it should preserve the exact
-   * structure of the original encoding.
+   * Although HttpUrl prefers percent-encodings in uppercase, it should preserve the exact structure
+   * of the original encoding.
    */
   @Test public void rawEncodingRetained() throws Exception {
     String urlString = "http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D#%6d%6D";
@@ -1129,4 +1406,24 @@
     assertEquals(urlString, url.newBuilder().build().toString());
     assertEquals("http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D", url.resolve("").toString());
   }
+
+  @Test public void clearFragment() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#fragment")
+        .newBuilder()
+        .fragment(null)
+        .build();
+    assertEquals("http://host/", url.toString());
+    assertEquals(null, url.fragment());
+    assertEquals(null, url.encodedFragment());
+  }
+
+  @Test public void clearEncodedFragment() throws Exception {
+    HttpUrl url = HttpUrl.parse("http://host/#fragment")
+        .newBuilder()
+        .encodedFragment(null)
+        .build();
+    assertEquals("http://host/", url.toString());
+    assertEquals(null, url.fragment());
+    assertEquals(null, url.encodedFragment());
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
similarity index 67%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java
rename to okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
index 054343c811..287f12a317 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
@@ -13,20 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.IOException;
 import java.util.Arrays;
-import java.util.List;
 import java.util.Locale;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ForwardingSink;
@@ -38,6 +38,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
@@ -47,7 +48,7 @@
 public final class InterceptorTest {
   @Rule public MockWebServer server = new MockWebServer();
 
-  private OkHttpClient client = new OkHttpClient();
+  private OkHttpClient client = defaultClient();
   private RecordingCallback callback = new RecordingCallback();
 
   @Test public void applicationInterceptorsCanShortCircuitResponses() throws Exception {
@@ -65,11 +66,12 @@
         .body(ResponseBody.create(MediaType.parse("text/plain; charset=utf-8"), "abc"))
         .build();
 
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return interceptorResponse;
-      }
-    });
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            return interceptorResponse;
+          }
+        }).build();
 
     Response response = client.newCall(request).execute();
     assertSame(interceptorResponse, response);
@@ -89,7 +91,9 @@
             .build();
       }
     };
-    client.networkInterceptors().add(interceptor);
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -114,7 +118,9 @@
         return chain.proceed(chain.request());
       }
     };
-    client.networkInterceptors().add(interceptor);
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -134,15 +140,17 @@
 
     Interceptor interceptor = new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
-        Address address = chain.connection().getRoute().getAddress();
-        String sameHost = address.getUriHost();
-        int differentPort = address.getUriPort() + 1;
+        Address address = chain.connection().route().address();
+        String sameHost = address.url().host();
+        int differentPort = address.url().port() + 1;
         return chain.proceed(chain.request().newBuilder()
             .url(HttpUrl.parse("http://" + sameHost + ":" + differentPort + "/"))
             .build());
       }
     };
-    client.networkInterceptors().add(interceptor);
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -160,13 +168,16 @@
   @Test public void networkInterceptorsHaveConnectionAccess() throws Exception {
     server.enqueue(new MockResponse());
 
-    client.networkInterceptors().add(new Interceptor() {
+    Interceptor interceptor = new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Connection connection = chain.connection();
         assertNotNull(connection);
         return chain.proceed(chain.request());
       }
-    });
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -179,7 +190,7 @@
         .setBody(gzip("abcabcabc"))
         .addHeader("Content-Encoding: gzip"));
 
-    client.networkInterceptors().add(new Interceptor() {
+    Interceptor interceptor = new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         // The network request has everything: User-Agent, Host, Accept-Encoding.
         Request networkRequest = chain.request();
@@ -193,7 +204,10 @@
         assertEquals("gzip", networkResponse.header("Content-Encoding"));
         return networkResponse;
       }
-    });
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -210,18 +224,49 @@
     assertEquals("abcabcabc", response.body().string());
   }
 
+  @Test public void networkInterceptorsCanChangeRequestMethodFromGetToPost() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Request originalRequest = chain.request();
+        MediaType mediaType = MediaType.parse("text/plain");
+        RequestBody body = RequestBody.create(mediaType, "abc");
+        return chain.proceed(originalRequest.newBuilder()
+            .method("POST", body)
+            .header("Content-Type", mediaType.toString())
+            .header("Content-Length", Long.toString(body.contentLength()))
+            .build());
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .get()
+        .build();
+
+    client.newCall(request).execute();
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("POST", recordedRequest.getMethod());
+    assertEquals("abc", recordedRequest.getBody().readUtf8());
+  }
+
   @Test public void applicationInterceptorsRewriteRequestToServer() throws Exception {
-    rewriteRequestToServer(client.interceptors());
+    rewriteRequestToServer(false);
   }
 
   @Test public void networkInterceptorsRewriteRequestToServer() throws Exception {
-    rewriteRequestToServer(client.networkInterceptors());
+    rewriteRequestToServer(true);
   }
 
-  private void rewriteRequestToServer(List<Interceptor> interceptors) throws Exception {
+  private void rewriteRequestToServer(boolean network) throws Exception {
     server.enqueue(new MockResponse());
 
-    interceptors.add(new Interceptor() {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Request originalRequest = chain.request();
         return chain.proceed(originalRequest.newBuilder()
@@ -247,19 +292,19 @@ private void rewriteRequestToServer(List<Interceptor> interceptors) throws Excep
   }
 
   @Test public void applicationInterceptorsRewriteResponseFromServer() throws Exception {
-    rewriteResponseFromServer(client.interceptors());
+    rewriteResponseFromServer(false);
   }
 
   @Test public void networkInterceptorsRewriteResponseFromServer() throws Exception {
-    rewriteResponseFromServer(client.networkInterceptors());
+    rewriteResponseFromServer(true);
   }
 
-  private void rewriteResponseFromServer(List<Interceptor> interceptors) throws Exception {
+  private void rewriteResponseFromServer(boolean network) throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("Original-Header: foo")
         .setBody("abc"));
 
-    interceptors.add(new Interceptor() {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Response originalResponse = chain.proceed(chain.request());
         return originalResponse.newBuilder()
@@ -280,17 +325,17 @@ private void rewriteResponseFromServer(List<Interceptor> interceptors) throws Ex
   }
 
   @Test public void multipleApplicationInterceptors() throws Exception {
-    multipleInterceptors(client.interceptors());
+    multipleInterceptors(false);
   }
 
   @Test public void multipleNetworkInterceptors() throws Exception {
-    multipleInterceptors(client.networkInterceptors());
+    multipleInterceptors(true);
   }
 
-  private void multipleInterceptors(List<Interceptor> interceptors) throws Exception {
+  private void multipleInterceptors(boolean network) throws Exception {
     server.enqueue(new MockResponse());
 
-    interceptors.add(new Interceptor() {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Request originalRequest = chain.request();
         Response originalResponse = chain.proceed(originalRequest.newBuilder()
@@ -301,7 +346,7 @@ private void multipleInterceptors(List<Interceptor> interceptors) throws Excepti
             .build();
       }
     });
-    interceptors.add(new Interceptor() {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Request originalRequest = chain.request();
         Response originalResponse = chain.proceed(originalRequest.newBuilder()
@@ -327,17 +372,17 @@ private void multipleInterceptors(List<Interceptor> interceptors) throws Excepti
   }
 
   @Test public void asyncApplicationInterceptors() throws Exception {
-    asyncInterceptors(client.interceptors());
+    asyncInterceptors(false);
   }
 
   @Test public void asyncNetworkInterceptors() throws Exception {
-    asyncInterceptors(client.networkInterceptors());
+    asyncInterceptors(true);
   }
 
-  private void asyncInterceptors(List<Interceptor> interceptors) throws Exception {
+  private void asyncInterceptors(boolean network) throws Exception {
     server.enqueue(new MockResponse());
 
-    interceptors.add(new Interceptor() {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Response originalResponse = chain.proceed(chain.request());
         return originalResponse.newBuilder()
@@ -351,7 +396,7 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
         .build();
     client.newCall(request).enqueue(callback);
 
-    callback.await(request.httpUrl())
+    callback.await(request.url())
         .assertCode(200)
         .assertHeader("OkHttp-Intercepted", "yep");
   }
@@ -360,12 +405,14 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     server.enqueue(new MockResponse().setBody("a"));
     server.enqueue(new MockResponse().setBody("b"));
 
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        chain.proceed(chain.request());
-        return chain.proceed(chain.request());
-      }
-    });
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            Response response1 = chain.proceed(chain.request());
+            response1.body().close();
+            return chain.proceed(chain.request());
+          }
+        }).build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -380,19 +427,20 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     server.enqueue(new MockResponse().setBody("a")); // Fetched by interceptor.
     server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
 
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        if (chain.request().url().getPath().equals("/b")) {
-          Request requestA = new Request.Builder()
-              .url(server.url("/a"))
-              .build();
-          Response responseA = client.newCall(requestA).execute();
-          assertEquals("a", responseA.body().string());
-        }
-
-        return chain.proceed(chain.request());
-      }
-    });
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            if (chain.request().url().encodedPath().equals("/b")) {
+              Request requestA = new Request.Builder()
+                  .url(server.url("/a"))
+                  .build();
+              Response responseA = client.newCall(requestA).execute();
+              assertEquals("a", responseA.body().string());
+            }
+
+            return chain.proceed(chain.request());
+          }
+        }).build();
 
     Request requestB = new Request.Builder()
         .url(server.url("/b"))
@@ -406,51 +454,49 @@ private void asyncInterceptors(List<Interceptor> interceptors) throws Exception
     server.enqueue(new MockResponse().setBody("a")); // Fetched by interceptor.
     server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
 
-    client.interceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        if (chain.request().url().getPath().equals("/b")) {
-          Request requestA = new Request.Builder()
-              .url(server.url("/a"))
-              .build();
-
-          try {
-            RecordingCallback callbackA = new RecordingCallback();
-            client.newCall(requestA).enqueue(callbackA);
-            callbackA.await(requestA.httpUrl()).assertBody("a");
-          } catch (Exception e) {
-            throw new RuntimeException(e);
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            if (chain.request().url().encodedPath().equals("/b")) {
+              Request requestA = new Request.Builder()
+                  .url(server.url("/a"))
+                  .build();
+
+              try {
+                RecordingCallback callbackA = new RecordingCallback();
+                client.newCall(requestA).enqueue(callbackA);
+                callbackA.await(requestA.url()).assertBody("a");
+              } catch (Exception e) {
+                throw new RuntimeException(e);
+              }
+            }
+
+            return chain.proceed(chain.request());
           }
-        }
-
-        return chain.proceed(chain.request());
-      }
-    });
+        }).build();
 
     Request requestB = new Request.Builder()
         .url(server.url("/b"))
         .build();
     RecordingCallback callbackB = new RecordingCallback();
     client.newCall(requestB).enqueue(callbackB);
-    callbackB.await(requestB.httpUrl()).assertBody("b");
+    callbackB.await(requestB.url()).assertBody("b");
   }
 
-  @Test public void applicationkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionSynchronous(client.interceptors());
+  @Test public void applicationInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionSynchronous(false);
   }
 
   @Test public void networkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionSynchronous(client.networkInterceptors());
+    interceptorThrowsRuntimeExceptionSynchronous(true);
   }
 
   /**
    * When an interceptor throws an unexpected exception, synchronous callers can catch it and deal
    * with it.
-   *
-   * TODO(jwilson): test that resources are not leaked when this happens.
    */
-  private void interceptorThrowsRuntimeExceptionSynchronous(
-      List<Interceptor> interceptors) throws Exception {
-    interceptors.add(new Interceptor() {
+  private void interceptorThrowsRuntimeExceptionSynchronous(boolean network) throws Exception {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         throw new RuntimeException("boom!");
       }
@@ -468,26 +514,20 @@ private void interceptorThrowsRuntimeExceptionSynchronous(
     }
   }
 
-  @Test public void applicationInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionAsynchronous(client.interceptors());
-  }
-
-  @Test public void networkInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionAsynchronous(client.networkInterceptors());
-  }
-
   @Test public void networkInterceptorModifiedRequestIsReturned() throws IOException {
     server.enqueue(new MockResponse());
 
     Interceptor modifyHeaderInterceptor = new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         return chain.proceed(chain.request().newBuilder()
-          .header("User-Agent", "intercepted request")
-          .build());
+            .header("User-Agent", "intercepted request")
+            .build());
       }
     };
 
-    client.networkInterceptors().add(modifyHeaderInterceptor);
+    client = client.newBuilder()
+        .addNetworkInterceptor(modifyHeaderInterceptor)
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -500,22 +540,29 @@ private void interceptorThrowsRuntimeExceptionSynchronous(
     assertEquals("intercepted request", response.networkResponse().request().header("User-Agent"));
   }
 
+  @Test public void applicationInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionAsynchronous(false);
+  }
+
+  @Test public void networkInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
+    interceptorThrowsRuntimeExceptionAsynchronous(true);
+  }
+
   /**
    * When an interceptor throws an unexpected exception, asynchronous callers are left hanging. The
    * exception goes to the uncaught exception handler.
-   *
-   * TODO(jwilson): test that resources are not leaked when this happens.
    */
-  private void interceptorThrowsRuntimeExceptionAsynchronous(
-        List<Interceptor> interceptors) throws Exception {
-    interceptors.add(new Interceptor() {
+  private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) throws Exception {
+    addInterceptor(network, new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         throw new RuntimeException("boom!");
       }
     });
 
     ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
-    client.setDispatcher(new Dispatcher(executor));
+    client = client.newBuilder()
+        .dispatcher(new Dispatcher(executor))
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -525,6 +572,90 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(
     assertEquals("boom!", executor.takeException().getMessage());
   }
 
+  @Test public void applicationInterceptorReturnsNull() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        chain.proceed(chain.request());
+        return null;
+      }
+    };
+    client = client.newBuilder()
+        .addInterceptor(interceptor)
+        .build();
+
+    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
+    client = client.newBuilder()
+        .dispatcher(new Dispatcher(executor))
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("application interceptor " + interceptor
+          + " returned null", expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorReturnsNull() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        chain.proceed(chain.request());
+        return null;
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
+    client = client.newBuilder()
+        .dispatcher(new Dispatcher(executor))
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("network interceptor " + interceptor + " returned null", expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorReturnsConnectionOnEmptyBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .addHeader("Connection", "Close"));
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Response response = chain.proceed(chain.request());
+        assertNotNull(chain.connection());
+        return response;
+      }
+    };
+
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    response.body().close();
+  }
+
   private RequestBody uppercase(final RequestBody original) {
     return new RequestBody() {
       @Override public MediaType contentType() {
@@ -576,6 +707,16 @@ private Buffer gzip(String data) throws IOException {
     return result;
   }
 
+  private void addInterceptor(boolean network, Interceptor interceptor) {
+    OkHttpClient.Builder builder = client.newBuilder();
+    if (network) {
+      builder.addNetworkInterceptor(interceptor);
+    } else {
+      builder.addInterceptor(interceptor);
+    }
+    client = builder.build();
+  }
+
   /** Catches exceptions that are otherwise headed for the uncaught exception handler. */
   private static class ExceptionCatchingExecutor extends ThreadPoolExecutor {
     private final BlockingQueue<Exception> exceptions = new LinkedBlockingQueue<>();
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
similarity index 96%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
rename to okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
index 25805957a5..b4e9c2ec2a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
@@ -14,12 +14,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.Util;
 import java.nio.charset.Charset;
 import java.nio.charset.IllegalCharsetNameException;
 import java.nio.charset.UnsupportedCharsetException;
+import okhttp3.internal.Util;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -30,8 +30,8 @@
 /**
  * Test MediaType API and parsing.
  *
- * <p>This test includes tests from <a
- * href="https://code.google.com/p/guava-libraries/">Guava's</a> MediaTypeTest.
+ * <p>This test includes tests from <a href="https://code.google.com/p/guava-libraries/">Guava's</a>
+ * MediaTypeTest.
  */
 public class MediaTypeTest {
   @Test public void testParse() throws Exception {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
similarity index 73%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java
rename to okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
index 4159679c76..a5a8664a87 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
@@ -13,21 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 import okio.Buffer;
 import okio.BufferedSink;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.Util.UTF_8;
+import static okhttp3.internal.Util.UTF_8;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
-public final class MultipartBuilderTest {
-  @Test(expected = IllegalStateException.class)
-  public void onePartRequired() throws Exception {
-    new MultipartBuilder().build();
+public final class MultipartBodyTest {
+  @Test public void onePartRequired() throws Exception {
+    try {
+      new MultipartBody.Builder().build();
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Multipart body must have at least one part.", e.getMessage());
+    }
   }
 
   @Test public void singlePart() throws Exception {
@@ -38,16 +42,19 @@ public void onePartRequired() throws Exception {
         + "Hello, World!\r\n"
         + "--123--\r\n";
 
-    RequestBody requestBody = new MultipartBuilder("123")
+    MultipartBody body = new MultipartBody.Builder("123")
         .addPart(RequestBody.create(null, "Hello, World!"))
         .build();
 
-    assertEquals("multipart/mixed; boundary=123", requestBody.contentType().toString());
+    assertEquals("123", body.boundary());
+    assertEquals(MultipartBody.MIXED, body.type());
+    assertEquals("multipart/mixed; boundary=123", body.contentType().toString());
+    assertEquals(1, body.parts().size());
+    assertEquals(53, body.contentLength());
 
     Buffer buffer = new Buffer();
-    requestBody.writeTo(buffer);
-    assertEquals(53, requestBody.contentLength());
-    assertEquals(buffer.size(), requestBody.contentLength());
+    body.writeTo(buffer);
+    assertEquals(buffer.size(), body.contentLength());
     assertEquals(expected, buffer.readUtf8());
   }
 
@@ -67,18 +74,21 @@ public void onePartRequired() throws Exception {
         + "Fox\r\n"
         + "--123--\r\n";
 
-    RequestBody requestBody = new MultipartBuilder("123")
+    MultipartBody body = new MultipartBody.Builder("123")
         .addPart(RequestBody.create(null, "Quick"))
         .addPart(RequestBody.create(null, "Brown"))
         .addPart(RequestBody.create(null, "Fox"))
         .build();
 
-    assertEquals("multipart/mixed; boundary=123", requestBody.contentType().toString());
+    assertEquals("123", body.boundary());
+    assertEquals(MultipartBody.MIXED, body.type());
+    assertEquals("multipart/mixed; boundary=123", body.contentType().toString());
+    assertEquals(3, body.parts().size());
+    assertEquals(112, body.contentLength());
 
     Buffer buffer = new Buffer();
-    requestBody.writeTo(buffer);
-    assertEquals(112, requestBody.contentLength());
-    assertEquals(buffer.size(), requestBody.contentLength());
+    body.writeTo(buffer);
+    assertEquals(buffer.size(), body.contentLength());
     assertEquals(expected, buffer.readUtf8());
   }
 
@@ -111,11 +121,11 @@ public void onePartRequired() throws Exception {
         + "\r\n"
         + "--AaB03x--\r\n";
 
-    RequestBody requestBody = new MultipartBuilder("AaB03x")
-        .type(MultipartBuilder.FORM)
+    MultipartBody body = new MultipartBody.Builder("AaB03x")
+        .setType(MultipartBody.FORM)
         .addFormDataPart("submit-name", "Larry")
         .addFormDataPart("files", null,
-            new MultipartBuilder("BbC04y")
+            new MultipartBody.Builder("BbC04y")
                 .addPart(
                     Headers.of("Content-Disposition", "file; filename=\"file1.txt\""),
                     RequestBody.create(
@@ -130,12 +140,15 @@ public void onePartRequired() throws Exception {
                 .build())
         .build();
 
-    assertEquals("multipart/form-data; boundary=AaB03x", requestBody.contentType().toString());
+    assertEquals("AaB03x", body.boundary());
+    assertEquals(MultipartBody.FORM, body.type());
+    assertEquals("multipart/form-data; boundary=AaB03x", body.contentType().toString());
+    assertEquals(2, body.parts().size());
+    assertEquals(568, body.contentLength());
 
     Buffer buffer = new Buffer();
-    requestBody.writeTo(buffer);
-    assertEquals(568, requestBody.contentLength());
-    assertEquals(buffer.size(), requestBody.contentLength());
+    body.writeTo(buffer);
+    assertEquals(buffer.size(), body.contentLength());
     assertEquals(expected, buffer.readUtf8());
   }
 
@@ -164,8 +177,8 @@ public void onePartRequired() throws Exception {
         + "Alpha\r\n"
         + "--AaB03x--\r\n";
 
-    RequestBody requestBody = new MultipartBuilder("AaB03x")
-        .type(MultipartBuilder.FORM)
+    MultipartBody body = new MultipartBody.Builder("AaB03x")
+        .setType(MultipartBody.FORM)
         .addFormDataPart("field with spaces", "filename with spaces.txt",
             RequestBody.create(MediaType.parse("text/plain; charset=utf-8"), "okay"))
         .addFormDataPart("field with \"", "\"")
@@ -174,7 +187,7 @@ public void onePartRequired() throws Exception {
         .build();
 
     Buffer buffer = new Buffer();
-    requestBody.writeTo(buffer);
+    body.writeTo(buffer);
     assertEquals(expected, buffer.readUtf8());
   }
 
@@ -209,24 +222,27 @@ public void onePartRequired() throws Exception {
         + "Fox\r\n"
         + "--123--\r\n";
 
-    RequestBody requestBody = new MultipartBuilder("123")
+    MultipartBody body = new MultipartBody.Builder("123")
         .addPart(RequestBody.create(null, "Quick"))
         .addPart(new StreamingBody("Brown"))
         .addPart(RequestBody.create(null, "Fox"))
         .build();
 
-    assertEquals("multipart/mixed; boundary=123", requestBody.contentType().toString());
+    assertEquals("123", body.boundary());
+    assertEquals(MultipartBody.MIXED, body.type());
+    assertEquals("multipart/mixed; boundary=123", body.contentType().toString());
+    assertEquals(3, body.parts().size());
+    assertEquals(-1, body.contentLength());
 
     Buffer buffer = new Buffer();
-    requestBody.writeTo(buffer);
+    body.writeTo(buffer);
     assertEquals(expected, buffer.readUtf8());
-    assertEquals(-1, requestBody.contentLength());
   }
 
   @Test public void contentTypeHeaderIsForbidden() throws Exception {
+    MultipartBody.Builder multipart = new MultipartBody.Builder();
     try {
-      new MultipartBuilder().addPart(
-          Headers.of("Content-Type", "text/plain"),
+      multipart.addPart(Headers.of("Content-Type", "text/plain"),
           RequestBody.create(null, "Hello, World!"));
       fail();
     } catch (IllegalArgumentException expected) {
@@ -234,9 +250,9 @@ public void onePartRequired() throws Exception {
   }
 
   @Test public void contentLengthHeaderIsForbidden() throws Exception {
+    MultipartBody.Builder multipart = new MultipartBody.Builder();
     try {
-      new MultipartBuilder().addPart(
-          Headers.of("Content-Length", "13"),
+      multipart.addPart(Headers.of("Content-Length", "13"),
           RequestBody.create(null, "Hello, World!"));
       fail();
     } catch (IllegalArgumentException expected) {
diff --git a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
new file mode 100644
index 0000000000..e369a4d4b1
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.CookieHandler;
+import java.net.CookieManager;
+import java.net.ProxySelector;
+import java.net.ResponseCache;
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+import org.junit.After;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.fail;
+
+public final class OkHttpClientTest {
+  private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
+  private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
+  private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();
+
+  @After public void tearDown() throws Exception {
+    ProxySelector.setDefault(DEFAULT_PROXY_SELECTOR);
+    CookieManager.setDefault(DEFAULT_COOKIE_HANDLER);
+    ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
+  }
+
+  @Test public void timeoutDefaults() {
+    OkHttpClient client = defaultClient();
+    assertEquals(10_000, client.connectTimeoutMillis());
+    assertEquals(10_000, client.readTimeoutMillis());
+    assertEquals(10_000, client.writeTimeoutMillis());
+  }
+
+  @Test public void timeoutValidRange() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.connectTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      builder.writeTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      builder.readTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      builder.connectTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      builder.writeTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
+    try {
+      builder.readTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
+  }
+
+  @Test public void clonedInterceptorsListsAreIndependent() throws Exception {
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request());
+      }
+    };
+    OkHttpClient original = defaultClient();
+    original.newBuilder()
+        .addInterceptor(interceptor)
+        .addNetworkInterceptor(interceptor)
+        .build();
+    assertEquals(0, original.interceptors().size());
+    assertEquals(0, original.networkInterceptors().size());
+  }
+
+  /**
+   * When copying the client, stateful things like the connection pool are shared across all
+   * clients.
+   */
+  @Test public void cloneSharesStatefulInstances() throws Exception {
+    OkHttpClient client = defaultClient();
+
+    // Values should be non-null.
+    OkHttpClient a = client.newBuilder().build();
+    assertNotNull(a.dispatcher());
+    assertNotNull(a.connectionPool());
+    assertNotNull(a.sslSocketFactory());
+
+    // Multiple clients share the instances.
+    OkHttpClient b = client.newBuilder().build();
+    assertSame(a.dispatcher(), b.dispatcher());
+    assertSame(a.connectionPool(), b.connectionPool());
+    assertSame(a.sslSocketFactory(), b.sslSocketFactory());
+  }
+
+  @Test public void setProtocolsRejectsHttp10() throws Exception {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.protocols(Arrays.asList(Protocol.HTTP_1_0, Protocol.HTTP_1_1));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
similarity index 75%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
rename to okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
index 129fecf145..ae7afa98df 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.ws.WebSocket;
 import java.io.IOException;
-import java.net.URL;
+import java.text.SimpleDateFormat;
 import java.util.Arrays;
+import java.util.Date;
+import okhttp3.ws.WebSocket;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -45,7 +46,7 @@ public RecordedResponse(Request request, Response response, WebSocket webSocket,
     this.failure = failure;
   }
 
-  public RecordedResponse assertRequestUrl(URL url) {
+  public RecordedResponse assertRequestUrl(HttpUrl url) {
     assertEquals(url, request.url());
     return this;
   }
@@ -80,6 +81,11 @@ public RecordedResponse assertHeader(String name, String... values) {
     return this;
   }
 
+  public RecordedResponse assertHeaders(Headers headers) {
+    assertEquals(headers, response.headers());
+    return this;
+  }
+
   public RecordedResponse assertBody(String expectedBody) {
     assertEquals(expectedBody, body);
     return this;
@@ -87,6 +93,7 @@ public RecordedResponse assertBody(String expectedBody) {
 
   public RecordedResponse assertHandshake() {
     Handshake handshake = response.handshake();
+    assertNotNull(handshake.tlsVersion());
     assertNotNull(handshake.cipherSuite());
     assertNotNull(handshake.peerPrincipal());
     assertEquals(1, handshake.peerCertificates().size());
@@ -96,8 +103,7 @@ public RecordedResponse assertHandshake() {
   }
 
   /**
-   * Asserts that the current response was redirected and returns the prior
-   * response.
+   * Asserts that the current response was redirected and returns the prior response.
    */
   public RecordedResponse priorResponse() {
     Response priorResponse = response.priorResponse();
@@ -107,8 +113,7 @@ public RecordedResponse priorResponse() {
   }
 
   /**
-   * Asserts that the current response used the network and returns the network
-   * response.
+   * Asserts that the current response used the network and returns the network response.
    */
   public RecordedResponse networkResponse() {
     Response networkResponse = response.networkResponse();
@@ -130,8 +135,7 @@ public RecordedResponse assertNoCacheResponse() {
   }
 
   /**
-   * Asserts that the current response used the cache and returns the cache
-   * response.
+   * Asserts that the current response used the cache and returns the cache response.
    */
   public RecordedResponse cacheResponse() {
     Response cacheResponse = response.cacheResponse();
@@ -140,8 +144,33 @@ public RecordedResponse cacheResponse() {
     return new RecordedResponse(cacheResponse.request(), cacheResponse, null, null, null);
   }
 
-  public void assertFailure(String... messages) {
+  public RecordedResponse assertFailure(Class<?> exceptionClass) {
+    assertTrue(exceptionClass.isInstance(failure));
+    return this;
+  }
+
+  public RecordedResponse assertFailure(String... messages) {
     assertNotNull(failure);
     assertTrue(failure.getMessage(), Arrays.asList(messages).contains(failure.getMessage()));
+    return this;
+  }
+
+  public RecordedResponse assertSentRequestAtMillis(long minimum, long maximum) {
+    assertDateInRange(minimum, response.sentRequestAtMillis(), maximum);
+    return this;
+  }
+
+  public RecordedResponse assertReceivedResponseAtMillis(long minimum, long maximum) {
+    assertDateInRange(minimum, response.receivedResponseAtMillis(), maximum);
+    return this;
+  }
+
+  private void assertDateInRange(long minimum, long actual, long maximum) {
+    assertTrue("actual " + format(actual) + " < minimum " + format(maximum), actual >= minimum);
+    assertTrue("actual " + format(actual) + " > maximum " + format(minimum), actual <= maximum);
+  }
+
+  private String format(long time) {
+    return new SimpleDateFormat("HH:mm:ss.SSS").format(new Date(time));
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java b/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
similarity index 66%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java
rename to okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
index 9d651473bc..56a1d7e003 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
@@ -13,14 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
-import okio.Buffer;
 
 /**
  * Records received HTTP responses so they can be later retrieved by tests.
@@ -30,30 +29,27 @@
 
   private final List<RecordedResponse> responses = new ArrayList<>();
 
-  @Override public synchronized void onFailure(Request request, IOException e) {
-    responses.add(new RecordedResponse(request, null, null, null, e));
+  @Override public synchronized void onFailure(Call call, IOException e) {
+    responses.add(new RecordedResponse(call.request(), null, null, null, e));
     notifyAll();
   }
 
-  @Override public synchronized void onResponse(Response response) throws IOException {
-    Buffer buffer = new Buffer();
-    ResponseBody body = response.body();
-    body.source().readAll(buffer);
-
-    responses.add(new RecordedResponse(response.request(), response, null, buffer.readUtf8(), null));
+  @Override public synchronized void onResponse(Call call, Response response) throws IOException {
+    String body = response.body().string();
+    responses.add(new RecordedResponse(call.request(), response, null, body, null));
     notifyAll();
   }
 
   /**
-   * Returns the recorded response triggered by {@code request}. Throws if the
-   * response isn't enqueued before the timeout.
+   * Returns the recorded response triggered by {@code request}. Throws if the response isn't
+   * enqueued before the timeout.
    */
   public synchronized RecordedResponse await(HttpUrl url) throws Exception {
     long timeoutMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime()) + TIMEOUT_MILLIS;
     while (true) {
       for (Iterator<RecordedResponse> i = responses.iterator(); i.hasNext(); ) {
         RecordedResponse recordedResponse = i.next();
-        if (recordedResponse.request.httpUrl().equals(url)) {
+        if (recordedResponse.request.url().equals(url)) {
           i.remove();
           return recordedResponse;
         }
@@ -66,12 +62,4 @@ public synchronized RecordedResponse await(HttpUrl url) throws Exception {
 
     throw new AssertionError("Timed out waiting for response to " + url);
   }
-
-  public synchronized void assertNoResponse(HttpUrl url) throws Exception {
-    for (RecordedResponse recordedResponse : responses) {
-      if (recordedResponse.request.httpUrl().equals(url)) {
-        throw new AssertionError("Expected no response for " + url);
-      }
-    }
-  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
similarity index 87%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
rename to okhttp-tests/src/test/java/okhttp3/RequestTest.java
index 39da50037c..4668f6005d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
@@ -13,16 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.net.URI;
-import java.net.URL;
 import java.util.Arrays;
 import java.util.Collections;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import org.junit.Test;
 
@@ -120,21 +119,22 @@
 
   @Test public void uninitializedURI() throws Exception {
     Request request = new Request.Builder().url("http://localhost/api").build();
-    assertEquals(new URI("http://localhost/api"), request.uri());
-    assertEquals(new URL("http://localhost/api"), request.url());
+    assertEquals(new URI("http://localhost/api"), request.url().uri());
+    assertEquals(HttpUrl.parse("http://localhost/api"), request.url());
   }
 
   @Test public void newBuilderUrlResetsUrl() throws Exception {
     Request requestWithoutCache = new Request.Builder().url("http://localhost/api").build();
-    Request builtRequestWithoutCache = requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
-    assertEquals(new URL("http://localhost/api/foo"), builtRequestWithoutCache.url());
+    Request builtRequestWithoutCache =
+        requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
+    assertEquals(HttpUrl.parse("http://localhost/api/foo"), builtRequestWithoutCache.url());
 
     Request requestWithCache = new Request.Builder().url("http://localhost/api").build();
     // cache url object
     requestWithCache.url();
     Request builtRequestWithCache = requestWithCache.newBuilder().url(
         "http://localhost/api/foo").build();
-    assertEquals(new URL("http://localhost/api/foo"), builtRequestWithCache.url());
+    assertEquals(HttpUrl.parse("http://localhost/api/foo"), builtRequestWithCache.url());
   }
 
   @Test public void cacheControl() throws Exception {
@@ -174,8 +174,31 @@
     }
   }
 
+  @Test public void headerForbidsNullArguments() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    try {
+      builder.header(null, "Value");
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      builder.addHeader(null, "Value");
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      builder.header("Name", null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+    try {
+      builder.addHeader("Name", null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
   @Test public void headerForbidsControlCharacters() throws Exception {
-    assertForbiddenHeader(null);
     assertForbiddenHeader("\u0000");
     assertForbiddenHeader("\r");
     assertForbiddenHeader("\n");
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
new file mode 100644
index 0000000000..8977fdf441
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Source;
+import okio.Timeout;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class ResponseTest {
+  @Test public void peekShorterThanResponse() throws Exception {
+    Response response = newResponse(responseBody("abcdef"));
+    ResponseBody peekedBody = response.peekBody(3);
+    assertEquals("abc", peekedBody.string());
+    assertEquals("abcdef", response.body().string());
+  }
+
+  @Test public void peekLongerThanResponse() throws Exception {
+    Response response = newResponse(responseBody("abc"));
+    ResponseBody peekedBody = response.peekBody(6);
+    assertEquals("abc", peekedBody.string());
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void peekAfterReadingResponse() throws Exception {
+    Response response = newResponse(responseBody("abc"));
+    assertEquals("abc", response.body().string());
+
+    try {
+      response.peekBody(3);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void eachPeakIsIndependent() throws Exception {
+    Response response = newResponse(responseBody("abcdef"));
+    ResponseBody p1 = response.peekBody(4);
+    ResponseBody p2 = response.peekBody(2);
+    assertEquals("abcdef", response.body().string());
+    assertEquals("abcd", p1.string());
+    assertEquals("ab", p2.string());
+  }
+
+  /**
+   * Returns a new response body that refuses to be read once it has been closed. This is true of
+   * most {@link BufferedSource} instances, but not of {@link Buffer}.
+   */
+  private ResponseBody responseBody(String content) {
+    final Buffer data = new Buffer().writeUtf8(content);
+
+    Source source = new Source() {
+      boolean closed;
+
+      @Override public void close() throws IOException {
+        closed = true;
+      }
+
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        if (closed) throw new IllegalStateException();
+        return data.read(sink, byteCount);
+      }
+
+      @Override public Timeout timeout() {
+        return Timeout.NONE;
+      }
+    };
+
+    return ResponseBody.create(null, -1, Okio.buffer(source));
+  }
+
+  private Response newResponse(ResponseBody responseBody) {
+    return new Response.Builder()
+        .request(new Request.Builder()
+            .url("https://example.com/")
+            .build())
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .body(responseBody)
+        .build();
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxy.java b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
similarity index 94%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxy.java
rename to okhttp-tests/src/test/java/okhttp3/SocksProxy.java
index e2a553203f..9c1b5a83cb 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxy.java
+++ b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
@@ -13,10 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -31,6 +29,8 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -41,6 +41,8 @@
  * See <a href="https://www.ietf.org/rfc/rfc1928.txt">RFC 1928</a>.
  */
 public final class SocksProxy {
+  public final String HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS = "onlyProxyCanResolveMe.org";
+
   private static final int VERSION_5 = 5;
   private static final int METHOD_NONE = 0xff;
   private static final int METHOD_NO_AUTHENTICATION_REQUIRED = 0;
@@ -156,7 +158,10 @@ private void acceptCommand(InetAddress fromAddress, BufferedSource fromSource,
       case ADDRESS_TYPE_DOMAIN_NAME:
         int domainNameLength = fromSource.readByte() & 0xff;
         String domainName = fromSource.readUtf8(domainNameLength);
-        toAddress = InetAddress.getByName(domainName);
+        // Resolve HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS to localhost.
+        toAddress = domainName.equalsIgnoreCase(HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
+            ? InetAddress.getLoopbackAddress()
+            : InetAddress.getByName(domainName);
         break;
 
       default:
@@ -203,7 +208,7 @@ private void transfer(final InetAddress fromAddress, final InetAddress toAddress
         Buffer buffer = new Buffer();
         try {
           while (true) {
-            long byteCount = source.read(buffer, 2048L);
+            long byteCount = source.read(buffer, 8192L);
             if (byteCount == -1L) break;
             sink.write(buffer, byteCount);
             sink.emit();
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java b/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
similarity index 72%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java
rename to okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
index 377ff83d9b..f74cb6f075 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
@@ -13,10 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.IOException;
 import java.net.Proxy;
 import java.net.ProxySelector;
@@ -24,6 +22,8 @@
 import java.net.URI;
 import java.util.Collections;
 import java.util.List;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -48,8 +48,9 @@
     server.enqueue(new MockResponse().setBody("abc"));
     server.enqueue(new MockResponse().setBody("def"));
 
-    OkHttpClient client = new OkHttpClient()
-        .setProxy(socksProxy.proxy());
+    OkHttpClient client = new OkHttpClient.Builder()
+        .proxy(socksProxy.proxy())
+        .build();
 
     Request request1 = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request1).execute();
@@ -76,8 +77,9 @@
       }
     };
 
-    OkHttpClient client = new OkHttpClient()
-        .setProxySelector(proxySelector);
+    OkHttpClient client = new OkHttpClient.Builder()
+        .proxySelector(proxySelector)
+        .build();
 
     Request request = new Request.Builder().url(server.url("/")).build();
     Response response = client.newCall(request).execute();
@@ -85,4 +87,24 @@
 
     assertEquals(1, socksProxy.connectionCount());
   }
+
+  @Test public void checkRemoteDNSResolve() throws Exception {
+    // This testcase will fail if the target is resolved locally instead of through the proxy.
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    OkHttpClient client = new OkHttpClient.Builder()
+        .proxy(socksProxy.proxy())
+        .build();
+
+    HttpUrl url = server.url("/")
+        .newBuilder()
+        .host(socksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
+        .build();
+
+    Request request = new Request.Builder().url(url).build();
+    Response response1 = client.newCall(request).execute();
+    assertEquals("abc", response1.body().string());
+
+    assertEquals(1, socksProxy.connectionCount());
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/TestLogHandler.java b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/TestLogHandler.java
rename to okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
index 24cb377cab..10f3cbb9d2 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/TestLogHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/okhttp-tests/src/test/java/okhttp3/TestUtil.java b/okhttp-tests/src/test/java/okhttp3/TestUtil.java
new file mode 100644
index 0000000000..a4581960eb
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/TestUtil.java
@@ -0,0 +1,55 @@
+package okhttp3;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.framed.Header;
+
+public final class TestUtil {
+  private TestUtil() {
+  }
+
+  private static final ConnectionPool connectionPool = new ConnectionPool();
+
+  /**
+   * Returns an OkHttpClient for all tests to use as a starting point.
+   *
+   * <p>The shared instance allows all tests to share a single connection pool, which prevents idle
+   * connections from consuming unnecessary resources while connections wait to be evicted.
+   *
+   * <p>This client is also configured to be slightly more deterministic, returning a single IP
+   * address for all hosts, regardless of the actual number of IP addresses reported by DNS.
+   */
+  public static OkHttpClient defaultClient() {
+    return new OkHttpClient.Builder()
+        .connectionPool(connectionPool)
+        .dns(new SingleInetAddressDns()) // Prevent unexpected fallback addresses.
+        .build();
+  }
+
+  public static List<Header> headerEntries(String... elements) {
+    List<Header> result = new ArrayList<>(elements.length / 2);
+    for (int i = 0; i < elements.length; i += 2) {
+      result.add(new Header(elements[i], elements[i + 1]));
+    }
+    return result;
+  }
+
+  public static <T> Set<T> setOf(T... elements) {
+    return setOf(Arrays.asList(elements));
+  }
+
+  public static <T> Set<T> setOf(Collection<T> elements) {
+    return new LinkedHashSet<>(elements);
+  }
+
+  public static String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
similarity index 76%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/URLConnectionTest.java
rename to okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index 2ea5997070..f3c69dc51e 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -13,21 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package okhttp3;
 
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.RecordingAuthenticator;
-import com.squareup.okhttp.internal.RecordingOkAuthenticator;
-import com.squareup.okhttp.internal.SingleInetAddressNetwork;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.Version;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import com.squareup.okhttp.testing.RecordingHostnameVerifier;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -47,6 +34,7 @@
 import java.net.URL;
 import java.net.URLConnection;
 import java.net.UnknownHostException;
+import java.security.SecureRandom;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
@@ -69,6 +57,19 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okhttp3.internal.DoubleInetAddressDns;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Platform;
+import okhttp3.internal.RecordingAuthenticator;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -80,16 +81,20 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
-import static com.squareup.okhttp.internal.Util.UTF_8;
-import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.internal.Util.UTF_8;
+import static okhttp3.internal.http.OkHeaders.SELECTED_PROTOCOL;
+import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -104,13 +109,13 @@
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
 
   private SSLContext sslContext = SslContextBuilder.localhost();
-  private OkUrlFactory client;
+  private OkUrlFactory urlFactory;
   private HttpURLConnection connection;
   private Cache cache;
 
   @Before public void setUp() throws Exception {
     server.setProtocolNegotiationEnabled(false);
-    client = new OkUrlFactory(new OkHttpClient());
+    urlFactory = new OkUrlFactory(defaultClient());
   }
 
   @After public void tearDown() throws Exception {
@@ -130,7 +135,7 @@
   @Test public void requestHeaders() throws IOException, InterruptedException {
     server.enqueue(new MockResponse());
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("D", "e");
     connection.addRequestProperty("D", "f");
     assertEquals("f", connection.getRequestProperty("D"));
@@ -189,7 +194,7 @@
   }
 
   @Test public void getRequestPropertyReturnsLastValue() throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("A", "value1");
     connection.addRequestProperty("A", "value2");
     assertEquals("value2", connection.getRequestProperty("A"));
@@ -202,7 +207,7 @@
         .addHeader("A: e")
         .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertEquals(200, connection.getResponseCode());
     assertEquals("Fantastic", connection.getResponseMessage());
     assertEquals("HTTP/1.0 200 Fantastic", connection.getHeaderField(null));
@@ -226,12 +231,13 @@
     assertEquals("d", connection.getHeaderField(1));
     assertEquals("A", connection.getHeaderFieldKey(2));
     assertEquals("e", connection.getHeaderField(2));
+    connection.getInputStream().close();
   }
 
   @Test public void serverSendsInvalidResponseHeaders() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getResponseCode();
       fail();
@@ -242,7 +248,7 @@
   @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getResponseCode();
       fail();
@@ -253,7 +259,7 @@
   @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getResponseCode();
       fail();
@@ -264,7 +270,7 @@
   @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
     server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getResponseCode();
       fail();
@@ -273,10 +279,10 @@
   }
 
   @Test public void connectRetriesUntilConnectedOrFailed() throws Exception {
-    URL url = server.getUrl("/foo");
+    URL url = server.url("/foo").url();
     server.shutdown();
 
-    connection = client.open(url);
+    connection = urlFactory.open(url);
     try {
       connection.connect();
       fail();
@@ -300,12 +306,13 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     server.enqueue(new MockResponse().setBody("abc"));
 
     // Use a misconfigured proxy to guarantee that the request is retried.
-    FakeProxySelector proxySelector = new FakeProxySelector();
-    proxySelector.proxies.add(server2.toProxyAddress());
-    client.client().setProxySelector(proxySelector);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxySelector(new FakeProxySelector()
+            .addProxy(server2.toProxyAddress()))
+        .build());
     server2.shutdown();
 
-    connection = client.open(server.getUrl("/def"));
+    connection = urlFactory.open(server.url("/def").url());
     connection.setDoOutput(true);
     transferKind.setForRequest(connection, 4);
     connection.getOutputStream().write("body".getBytes("UTF-8"));
@@ -316,13 +323,14 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
 
   @Test public void getErrorStreamOnSuccessfulRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertNull(connection.getErrorStream());
+    connection.getInputStream().close();
   }
 
   @Test public void getErrorStreamOnUnsuccessfulRequest() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(404).setBody("A"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection.getErrorStream(), Integer.MAX_VALUE));
   }
 
@@ -335,8 +343,13 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     server.enqueue(response);
     server.enqueue(response);
 
-    assertContent("ABCDE", client.open(server.getUrl("/")), 5);
-    assertContent("ABCDE", client.open(server.getUrl("/")), 5);
+    HttpURLConnection c1 = urlFactory.open(server.url("/").url());
+    assertContent("ABCDE", c1, 5);
+    HttpURLConnection c2 = urlFactory.open(server.url("/").url());
+    assertContent("ABCDE", c2, 5);
+
+    c1.getInputStream().close();
+    c2.getInputStream().close();
   }
 
   // Check that we recognize a few basic mime types by extension.
@@ -353,11 +366,11 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     server.enqueue(response);
     server.enqueue(response);
 
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/foo")));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/foo").url()));
     assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/bar?baz=quux")));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/bar?baz=quux").url()));
     assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/z")));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/z").url()));
     assertEquals(2, server.takeRequest().getSequenceNumber());
   }
 
@@ -368,11 +381,11 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     server.enqueue(response);
     server.enqueue(response);
 
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/foo")));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/foo").url()));
     assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/bar?baz=quux")));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/bar?baz=quux").url()));
     assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/z")));
+    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/z").url()));
     assertEquals(2, server.takeRequest().getSequenceNumber());
   }
 
@@ -391,7 +404,7 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
   @Test public void invalidHost() throws Exception {
     // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
     URL url = new URL("http://1234.1.1.1/index.html");
-    HttpURLConnection connection = client.open(url);
+    HttpURLConnection connection = urlFactory.open(url);
     try {
       connection.connect();
       fail();
@@ -406,11 +419,16 @@ private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception
     server.enqueue(responseAfter);
     server.enqueue(responseAfter); // Enqueue 2x because the broken connection may be reused.
 
-    HttpURLConnection connection1 = client.open(server.getUrl("/a"));
+    HttpURLConnection connection1 = urlFactory.open(server.url("/a").url());
     connection1.setReadTimeout(100);
     assertContent("This connection won't pool properly", connection1);
     assertEquals(0, server.takeRequest().getSequenceNumber());
-    HttpURLConnection connection2 = client.open(server.getUrl("/b"));
+
+    // Give the server time to enact the socket policy if it's one that could happen after the
+    // client has received the response.
+    Thread.sleep(500);
+
+    HttpURLConnection connection2 = urlFactory.open(server.url("/b").url());
     connection2.setReadTimeout(100);
     assertContent("This comes after a busted connection", connection2);
 
@@ -454,7 +472,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.setBodyLimit(0);
     server.enqueue(new MockResponse());
 
-    HttpURLConnection conn = client.open(server.getUrl("/"));
+    HttpURLConnection conn = urlFactory.open(server.url("/").url());
     conn.setDoOutput(true);
     conn.setRequestMethod("POST");
     if (uploadKind == TransferKind.CHUNKED) {
@@ -488,8 +506,8 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   @Test public void getResponseCodeNoResponseBody() throws Exception {
     server.enqueue(new MockResponse().addHeader("abc: def"));
 
-    URL url = server.getUrl("/");
-    HttpURLConnection conn = client.open(url);
+    URL url = server.url("/").url();
+    HttpURLConnection conn = urlFactory.open(url);
     conn.setDoInput(false);
     assertEquals("def", conn.getHeaderField("abc"));
     assertEquals(200, conn.getResponseCode());
@@ -504,9 +522,11 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.getUrl("/foo"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = urlFactory.open(server.url("/foo").url());
 
     assertContent("this response comes via HTTPS", connection);
 
@@ -518,10 +538,13 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse());
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
 
-    HttpsURLConnection httpsConnection = (HttpsURLConnection) client.open(server.getUrl("/foo"));
+    HttpsURLConnection httpsConnection
+        = (HttpsURLConnection) urlFactory.open(server.url("/foo").url());
 
     // Prior to calling connect(), getting the cipher suite is forbidden.
     try {
@@ -552,32 +575,40 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     SSLSocketFactory clientSocketFactory = sslContext.getSocketFactory();
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    client.client().setSslSocketFactory(clientSocketFactory);
-    client.client().setHostnameVerifier(hostnameVerifier);
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(clientSocketFactory)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertContent("this response comes via HTTPS", connection);
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertContent("another response via HTTPS", connection);
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
-  @Test public void connectViaHttpsReusingConnectionsDifferentFactories()
-      throws IOException, InterruptedException {
+  @Test public void connectViaHttpsReusingConnectionsDifferentFactories() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
 
     // install a custom SSL socket factory so the server can be authorized
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     assertContent("this response comes via HTTPS", connection1);
 
-    client.client().setSslSocketFactory(null);
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    SSLContext sslContext2 = SSLContext.getInstance("TLS");
+    sslContext2.init(null, null, null);
+    SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslSocketFactory2)
+        .build());
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     try {
       readAscii(connection2.getInputStream(), Integer.MAX_VALUE);
       fail("without an SSL socket factory, the connection should fail");
@@ -585,14 +616,18 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     }
   }
 
+  // TODO(jwilson): tests below this marker need to be migrated to OkHttp's request/response API.
+
   @Test public void connectViaHttpsWithSSLFallback() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("this response comes via SSL"));
 
-    suppressTlsFallbackScsv(client.client());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.getUrl("/foo"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .build());
+    connection = urlFactory.open(server.url("/foo").url());
 
     assertContent("this response comes via SSL", connection);
 
@@ -603,14 +638,15 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
 
   @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-
-    suppressTlsFallbackScsv(client.client());
-    Internal.instance.setNetwork(client.client(), new SingleInetAddressNetwork());
+    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
 
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.getUrl("/foo"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new SingleInetAddressDns())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .build());
+    connection = urlFactory.open(server.url("/foo").url());
 
     try {
       connection.getResponseCode();
@@ -621,8 +657,8 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   /**
-   * When a pooled connection fails, don't blame the route. Otherwise pooled
-   * connection failures can cause unnecessary SSL fallbacks.
+   * When a pooled connection fails, don't blame the route. Otherwise pooled connection failures can
+   * cause unnecessary SSL fallbacks.
    *
    * https://github.com/square/okhttp/issues/515
    */
@@ -630,14 +666,20 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse()
         .setBody("abc")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+        .setSocketPolicy(DISCONNECT_AT_END));
     server.enqueue(new MockResponse().setBody("def"));
 
-    suppressTlsFallbackScsv(client.client());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(suppressTlsFallbackClientSocketFactory())
+        .build());
+
+    assertContent("abc", urlFactory.open(server.url("/").url()));
 
-    assertContent("abc", client.open(server.getUrl("/")));
-    assertContent("def", client.open(server.getUrl("/")));
+    // Give the server time to disconnect.
+    Thread.sleep(500);
+
+    assertContent("def", urlFactory.open(server.url("/").url()));
 
     Set<TlsVersion> tlsVersions =
         EnumSet.of(TlsVersion.TLS_1_0, TlsVersion.TLS_1_2); // v1.2 on OpenJDK 8.
@@ -658,7 +700,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse()); // unused
 
-    connection = client.open(server.getUrl("/foo"));
+    connection = urlFactory.open(server.url("/foo").url());
     try {
       connection.getInputStream();
       fail();
@@ -685,7 +727,7 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
     server.enqueue(mockResponse);
 
     URL url = new URL("http://android.com/foo");
-    connection = proxyConfig.connect(server, client, url);
+    connection = proxyConfig.connect(server, urlFactory, url);
     assertContent("this response comes via a proxy", connection);
     assertTrue(connection.usingProxy());
 
@@ -698,15 +740,15 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
     server.enqueue(new MockResponse().setBody("abc\r\nYOU SHOULD NOT SEE THIS")
         .clearHeaders()
         .addHeader("Content-Length: 3"));
-    assertContent("abc", client.open(server.getUrl("/")));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
   }
 
   @Test public void contentDisagreesWithContentLengthHeaderBodyTooShort() throws IOException {
     server.enqueue(new MockResponse().setBody("abc")
         .setHeader("Content-Length", "5")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+        .setSocketPolicy(DISCONNECT_AT_END));
     try {
-      readAscii(client.open(server.getUrl("/")).getInputStream(), 5);
+      readAscii(urlFactory.open(server.url("/").url()).getInputStream(), 5);
       fail();
     } catch (ProtocolException expected) {
     }
@@ -714,11 +756,23 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
 
   public void testConnectViaSocketFactory(boolean useHttps) throws IOException {
     SocketFactory uselessSocketFactory = new SocketFactory() {
-      public Socket createSocket() { throw new IllegalArgumentException("useless"); }
-      public Socket createSocket(InetAddress host, int port) { return null; }
+      public Socket createSocket() {
+        throw new IllegalArgumentException("useless");
+      }
+
+      public Socket createSocket(InetAddress host, int port) {
+        return null;
+      }
+
       public Socket createSocket(InetAddress address, int port, InetAddress localAddress,
-          int localPort) { return null; }
-      public Socket createSocket(String host, int port) { return null; }
+          int localPort) {
+        return null;
+      }
+
+      public Socket createSocket(String host, int port) {
+        return null;
+      }
+
       public Socket createSocket(String host, int port, InetAddress localHost, int localPort) {
         return null;
       }
@@ -726,22 +780,28 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
 
     if (useHttps) {
       server.useHttps(sslContext.getSocketFactory(), false);
-      client.client().setSslSocketFactory(sslContext.getSocketFactory());
-      client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .sslSocketFactory(sslContext.getSocketFactory())
+          .hostnameVerifier(new RecordingHostnameVerifier())
+          .build());
     }
 
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
 
-    client.client().setSocketFactory(uselessSocketFactory);
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .socketFactory(uselessSocketFactory)
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getResponseCode();
       fail();
     } catch (IllegalArgumentException expected) {
     }
 
-    client.client().setSocketFactory(SocketFactory.getDefault());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .socketFactory(SocketFactory.getDefault())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals(200, connection.getResponseCode());
   }
 
@@ -764,7 +824,7 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
 
     server.enqueue(mockResponse);
 
-    assertContent("abc", client.open(server.getUrl("/")));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
   }
 
   @Test public void contentDisagreesWithChunkedHeaderBodyTooShort() throws IOException {
@@ -778,12 +838,12 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
 
     mockResponse.clearHeaders();
     mockResponse.addHeader("Transfer-encoding: chunked");
-    mockResponse.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
+    mockResponse.setSocketPolicy(DISCONNECT_AT_END);
 
     server.enqueue(mockResponse);
 
     try {
-      readAscii(client.open(server.getUrl("/")).getInputStream(), 5);
+      readAscii(urlFactory.open(server.url("/").url()).getInputStream(), 5);
       fail();
     } catch (ProtocolException expected) {
     }
@@ -802,10 +862,12 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
 
-    URL url = server.getUrl("/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = proxyConfig.connect(server, client, url);
+    URL url = server.url("/foo").url();
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = proxyConfig.connect(server, urlFactory, url);
 
     assertContent("this response comes via HTTPS", connection);
 
@@ -818,8 +880,8 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
   }
 
   /**
-   * We weren't honoring all of the appropriate proxy system properties when
-   * connecting via HTTPS. http://b/3097518
+   * We weren't honoring all of the appropriate proxy system properties when connecting via HTTPS.
+   * http://b/3097518
    */
   @Test public void connectViaHttpProxyToHttpsUsingProxySystemProperty() throws Exception {
     testConnectViaHttpProxyToHttps(ProxyConfig.PROXY_SYSTEM_PROPERTY);
@@ -830,28 +892,30 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
   }
 
   /**
-   * We were verifying the wrong hostname when connecting to an HTTPS site
-   * through a proxy. http://b/3097277
+   * We were verifying the wrong hostname when connecting to an HTTPS site through a proxy.
+   * http://b/3097277
    */
   private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
     server.useHttps(sslContext.getSocketFactory(), true);
     server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
+        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
 
     URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(hostnameVerifier);
-    connection = proxyConfig.connect(server, client, url);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(hostnameVerifier)
+        .build());
+    connection = proxyConfig.connect(server, urlFactory, url);
 
     assertContent("this response comes via a secure proxy", connection);
 
     RecordedRequest connect = server.takeRequest();
     assertEquals("Connect line failure on proxy", "CONNECT android.com:443 HTTP/1.1",
         connect.getRequestLine());
-    assertEquals("android.com", connect.getHeader("Host"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
 
     RecordedRequest get = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
@@ -866,31 +930,35 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     server.useHttps(sslContext.getSocketFactory(), true);
     // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
     MockResponse badProxyResponse = new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
         .setBody("bogus proxy connect response content");
     server.enqueue(badProxyResponse);
     server.enqueue(new MockResponse().setBody("response"));
 
     // Configure a single IP address for the host and a single configuration, so we only need one
     // failure to fail permanently.
-    Internal.instance.setNetwork(client.client(), new SingleInetAddressNetwork());
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setConnectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS));
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setProxy(server.toProxyAddress());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new SingleInetAddressDns())
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxy(server.toProxyAddress())
+        .build());
 
     URL url = new URL("https://android.com/foo");
-    connection = client.open(url);
+    connection = urlFactory.open(url);
     assertContent("response", connection);
 
     RecordedRequest connect = server.takeRequest();
     assertEquals("CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
-    assertEquals("android.com", connect.getHeader("Host"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
   }
 
   private void initResponseCache() throws IOException {
     cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-    client.client().setCache(cache);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .cache(cache)
+        .build());
   }
 
   /** Test which headers are sent unencrypted to the HTTP proxy. */
@@ -900,15 +968,17 @@ private void initResponseCache() throws IOException {
 
     server.useHttps(sslContext.getSocketFactory(), true);
     server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
+        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
 
-    client.client().setProxy(server.toProxyAddress());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(hostnameVerifier)
+        .build());
 
     URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(hostnameVerifier);
-    connection = client.open(url);
+    connection = urlFactory.open(url);
     connection.addRequestProperty("Private", "Secret");
     connection.addRequestProperty("Proxy-Authorization", "bar");
     connection.addRequestProperty("User-Agent", "baz");
@@ -916,9 +986,9 @@ private void initResponseCache() throws IOException {
 
     RecordedRequest connect = server.takeRequest();
     assertNull(connect.getHeader("Private"));
-    assertEquals("bar", connect.getHeader("Proxy-Authorization"));
-    assertEquals("baz", connect.getHeader("User-Agent"));
-    assertEquals("android.com", connect.getHeader("Host"));
+    assertNull(connect.getHeader("Proxy-Authorization"));
+    assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
+    assertEquals("android.com:443", connect.getHeader("Host"));
     assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
 
     RecordedRequest get = server.takeRequest();
@@ -932,15 +1002,18 @@ private void initResponseCache() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(407)
         .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
     server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
+        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("A"));
 
-    client.client().setProxy(server.toProxyAddress());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxyAuthenticator(new JavaNetAuthenticator())
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
 
     URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(url);
+    connection = urlFactory.open(url);
     assertContent("A", connection);
 
     RecordedRequest connect1 = server.takeRequest();
@@ -962,15 +1035,17 @@ private void initResponseCache() throws IOException {
   @Test public void proxyWithConnectionClose() throws IOException {
     server.useHttps(sslContext.getSocketFactory(), true);
     server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
+        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
 
-    client.client().setProxy(server.toProxyAddress());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
 
     URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(url);
+    connection = urlFactory.open(url);
     connection.setRequestProperty("Connection", "close");
 
     assertContent("this response comes via a proxy", connection);
@@ -982,17 +1057,18 @@ private void initResponseCache() throws IOException {
 
     server.useHttps(socketFactory, true);
     server.enqueue(
-        new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
+        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("response 1"));
     server.enqueue(new MockResponse().setBody("response 2"));
 
-    client.client().setProxy(server.toProxyAddress());
-
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(socketFactory)
+        .hostnameVerifier(hostnameVerifier)
+        .build());
     URL url = new URL("https://android.com/foo");
-    client.client().setSslSocketFactory(socketFactory);
-    client.client().setHostnameVerifier(hostnameVerifier);
-    assertContent("response 1", client.open(url));
-    assertContent("response 2", client.open(url));
+    assertContent("response 1", urlFactory.open(url));
+    assertContent("response 2", urlFactory.open(url));
   }
 
   @Test public void disconnectedConnection() throws IOException {
@@ -1000,7 +1076,7 @@ private void initResponseCache() throws IOException {
         .throttleBody(2, 100, TimeUnit.MILLISECONDS)
         .setBody("ABCD"));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     InputStream in = connection.getInputStream();
     assertEquals('A', (char) in.read());
     connection.disconnect();
@@ -1013,12 +1089,13 @@ private void initResponseCache() throws IOException {
       fail("Expected a connection closed exception");
     } catch (IOException expected) {
     }
+    in.close();
   }
 
   @Test public void disconnectBeforeConnect() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.disconnect();
     assertContent("A", connection);
     assertEquals(200, connection.getResponseCode());
@@ -1030,9 +1107,8 @@ private void initResponseCache() throws IOException {
   }
 
   /**
-   * Reads {@code count} characters from the stream. If the stream is
-   * exhausted before {@code count} characters can be read, the remaining
-   * characters are returned and the stream is closed.
+   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
+   * characters can be read, the remaining characters are returned and the stream is closed.
    */
   private String readAscii(InputStream in, int count) throws IOException {
     StringBuilder result = new StringBuilder();
@@ -1065,7 +1141,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     server.enqueue(response);
     server.enqueue(response);
 
-    InputStream in = client.open(server.getUrl("/")).getInputStream();
+    InputStream in = urlFactory.open(server.url("/").url()).getInputStream();
     assertFalse("This implementation claims to support mark().", in.markSupported());
     in.mark(5);
     assertEquals("ABCDE", readAscii(in, 5));
@@ -1075,13 +1151,13 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     } catch (IOException expected) {
     }
     assertEquals("FGHIJKLMNOPQRSTUVWXYZ", readAscii(in, Integer.MAX_VALUE));
-    assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", client.open(server.getUrl("/")));
+    in.close();
+    assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", urlFactory.open(server.url("/").url()));
   }
 
   /**
-   * We've had a bug where we forget the HTTP response when we see response
-   * code 401. This causes a new HTTP request to be issued for every call into
-   * the URLConnection.
+   * We've had a bug where we forget the HTTP response when we see response code 401. This causes a
+   * new HTTP request to be issued for every call into the URLConnection.
    */
   @Test public void unauthorizedResponseHandling() throws IOException {
     MockResponse response = new MockResponse().addHeader("WWW-Authenticate: challenge")
@@ -1091,13 +1167,14 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     server.enqueue(response);
     server.enqueue(response);
 
-    URL url = server.getUrl("/");
-    HttpURLConnection conn = client.open(url);
+    URL url = server.url("/").url();
+    HttpURLConnection conn = urlFactory.open(url);
 
     assertEquals(401, conn.getResponseCode());
     assertEquals(401, conn.getResponseCode());
     assertEquals(401, conn.getResponseCode());
     assertEquals(1, server.getRequestCount());
+    conn.getErrorStream().close();
   }
 
   @Test public void nonHexChunkSize() throws IOException {
@@ -1105,12 +1182,13 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
         .clearHeaders()
         .addHeader("Transfer-encoding: chunked"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     try {
       readAscii(connection.getInputStream(), Integer.MAX_VALUE);
       fail();
     } catch (IOException e) {
     }
+    connection.getInputStream().close();
   }
 
   @Test public void malformedChunkSize() throws IOException {
@@ -1118,11 +1196,13 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
         .clearHeaders()
         .addHeader("Transfer-encoding: chunked"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     try {
       readAscii(connection.getInputStream(), Integer.MAX_VALUE);
       fail();
     } catch (IOException e) {
+    } finally {
+      connection.getInputStream().close();
     }
   }
 
@@ -1131,7 +1211,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
         .clearHeaders()
         .addHeader("Transfer-encoding: chunked"));
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertContent("ABCDE", connection);
   }
 
@@ -1141,25 +1221,26 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
         .addHeader("Transfer-encoding: chunked")
         .setSocketPolicy(DISCONNECT_AT_END));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     try {
       readAscii(connection.getInputStream(), Integer.MAX_VALUE);
       fail();
     } catch (IOException e) {
+    } finally {
+      connection.getInputStream().close();
     }
   }
 
   /**
-   * This test checks whether connections are gzipped by default. This
-   * behavior in not required by the API, so a failure of this test does not
-   * imply a bug in the implementation.
+   * This test checks whether connections are gzipped by default. This behavior in not required by
+   * the API, so a failure of this test does not imply a bug in the implementation.
    */
   @Test public void gzipEncodingEnabledByDefault() throws IOException, InterruptedException {
     server.enqueue(new MockResponse()
         .setBody(gzip("ABCABCABC"))
         .addHeader("Content-Encoding: gzip"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("ABCABCABC", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     assertNull(connection.getContentEncoding());
     assertEquals(-1, connection.getContentLength());
@@ -1174,7 +1255,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
         .setBody(bodyBytes)
         .addHeader("Content-Encoding: gzip"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Accept-Encoding", "gzip");
     InputStream gunzippedIn = new GZIPInputStream(connection.getInputStream());
     assertEquals("ABCDEFGHIJKLMNOPQRSTUVWXYZ", readAscii(gunzippedIn, Integer.MAX_VALUE));
@@ -1203,7 +1284,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
   @Test public void clientConfiguredCustomContentEncoding() throws Exception {
     server.enqueue(new MockResponse().setBody("ABCDE").addHeader("Content-Encoding: custom"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Accept-Encoding", "custom");
     assertEquals("ABCDE", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1212,8 +1293,8 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
   }
 
   /**
-   * Test a bug where gzip input streams weren't exhausting the input stream,
-   * which corrupted the request that followed or prevented connection reuse.
+   * Test a bug where gzip input streams weren't exhausting the input stream, which corrupted the
+   * request that followed or prevented connection reuse.
    * http://code.google.com/p/android/issues/detail?id=7059
    * http://code.google.com/p/android/issues/detail?id=38817
    */
@@ -1223,8 +1304,10 @@ private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferK
       SSLSocketFactory socketFactory = sslContext.getSocketFactory();
       RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
       server.useHttps(socketFactory, false);
-      client.client().setSslSocketFactory(socketFactory);
-      client.client().setHostnameVerifier(hostnameVerifier);
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .sslSocketFactory(socketFactory)
+          .hostnameVerifier(hostnameVerifier)
+          .build());
     }
 
     MockResponse responseOne = new MockResponse();
@@ -1235,13 +1318,13 @@ private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferK
     transferKind.setBody(responseTwo, "two (identity)", 5);
     server.enqueue(responseTwo);
 
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     connection1.addRequestProperty("Accept-Encoding", "gzip");
     InputStream gunzippedIn = new GZIPInputStream(connection1.getInputStream());
     assertEquals("one (gzipped)", readAscii(gunzippedIn, Integer.MAX_VALUE));
     assertEquals(0, server.takeRequest().getSequenceNumber());
 
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("two (identity)", readAscii(connection2.getInputStream(), Integer.MAX_VALUE));
     assertEquals(1, server.takeRequest().getSequenceNumber());
   }
@@ -1255,28 +1338,28 @@ private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferK
         .setBody(gzip("b")));
 
     // Seed the pool with a bad connection.
-    assertContent("a", client.open(server.getUrl("/")));
+    assertContent("a", urlFactory.open(server.url("/").url()));
+
+    // Give the server time to disconnect.
+    Thread.sleep(500);
 
     // This connection will need to be recovered. When it is, transparent gzip should still work!
-    assertContent("b", client.open(server.getUrl("/")));
+    assertContent("b", urlFactory.open(server.url("/").url()));
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
   }
 
   @Test public void endOfStreamResponseIsNotPooled() throws Exception {
+    urlFactory.client().connectionPool().evictAll();
     server.enqueue(new MockResponse()
         .setBody("{}")
         .clearHeaders()
         .setSocketPolicy(DISCONNECT_AT_END));
 
-    ConnectionPool pool = ConnectionPool.getDefault();
-    pool.evictAll();
-    client.client().setConnectionPool(pool);
-
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertContent("{}", connection);
-    assertEquals(0, client.client().getConnectionPool().getConnectionCount());
+    assertEquals(0, urlFactory.client().connectionPool().idleConnectionCount());
   }
 
   @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
@@ -1296,13 +1379,13 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     transferKind.setBody(response2, "LMNOPQRSTUV", 1024);
     server.enqueue(response2);
 
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     InputStream in1 = connection1.getInputStream();
     assertEquals("ABCDE", readAscii(in1, 5));
     in1.close();
     connection1.disconnect();
 
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     InputStream in2 = connection2.getInputStream();
     assertEquals("LMNOP", readAscii(in2, 5));
     in2.close();
@@ -1320,7 +1403,7 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     server.enqueue(new MockResponse().setBody("A"));
 
     long startNanos = System.nanoTime();
-    URLConnection connection1 = client.open(server.getUrl("/"));
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
     InputStream in = connection1.getInputStream();
     in.close();
     long elapsedNanos = System.nanoTime() - startNanos;
@@ -1329,10 +1412,10 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     // If we're working correctly, this should be greater than 100ms, but less than double that.
     // Previously we had a bug where we would download the entire response body as long as no
     // individual read took longer than 100ms.
-    assertTrue(String.format("Time to close: %sms", elapsedMillis), elapsedMillis < 500);
+    assertTrue(Util.format("Time to close: %sms", elapsedMillis), elapsedMillis < 500);
 
     // Do another request to confirm that the discarded connection was not pooled.
-    assertContent("A", client.open(server.getUrl("/")));
+    assertContent("A", urlFactory.open(server.url("/").url()));
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
@@ -1342,12 +1425,13 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     server.enqueue(new MockResponse());
 
     String body = "ABCDEFGHIJKLMNOPQ";
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setChunkedStreamingMode(0); // OkHttp does not honor specific chunk sizes.
     connection.setDoOutput(true);
     OutputStream outputStream = connection.getOutputStream();
     outputStream.write(body.getBytes("US-ASCII"));
     assertEquals(200, connection.getResponseCode());
+    connection.getInputStream().close();
 
     RecordedRequest request = server.takeRequest();
     assertEquals(body, request.getBody().readUtf8());
@@ -1369,9 +1453,12 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     server.enqueue(pleaseAuthenticate);
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
     if (streamingMode == StreamingMode.FIXED_LENGTH) {
       connection.setFixedLengthStreamingMode(requestBody.length);
     } else if (streamingMode == StreamingMode.CHUNKED) {
@@ -1426,9 +1513,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse());
 
     String credential = Credentials.basic("jesse", "secret");
-    client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build());
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     OutputStream outputStream = connection.getOutputStream();
     outputStream.write(body.getBytes("UTF-8"));
@@ -1469,7 +1558,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   @Test public void allAttributesSetInServerAuthenticationCallbacks() throws Exception {
     List<String> calls = authCallsForHeader("WWW-Authenticate: Basic realm=\"Bar\"");
     assertEquals(1, calls.size());
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     String call = calls.get(0);
     assertTrue(call, call.contains("host=" + url.getHost()));
     assertTrue(call, call.contains("port=" + url.getPort()));
@@ -1484,7 +1573,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   @Test public void allAttributesSetInProxyAuthenticationCallbacks() throws Exception {
     List<String> calls = authCallsForHeader("Proxy-Authenticate: Basic realm=\"Bar\"");
     assertEquals(1, calls.size());
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     String call = calls.get(0);
     assertTrue(call, call.contains("host=" + url.getHost()));
     assertTrue(call, call.contains("port=" + url.getPort()));
@@ -1501,18 +1590,26 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     int responseCode = proxy ? 407 : 401;
     RecordingAuthenticator authenticator = new RecordingAuthenticator(null);
     Authenticator.setDefault(authenticator);
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(responseCode)
+    MockResponse pleaseAuthenticate = new MockResponse()
+        .setResponseCode(responseCode)
         .addHeader(authHeader)
         .setBody("Please authenticate.");
     server.enqueue(pleaseAuthenticate);
 
     if (proxy) {
-      client.client().setProxy(server.toProxyAddress());
-      connection = client.open(new URL("http://android.com"));
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .proxy(server.toProxyAddress())
+          .proxyAuthenticator(new JavaNetAuthenticator())
+          .build());
+      connection = urlFactory.open(new URL("http://android.com/"));
     } else {
-      connection = client.open(server.getUrl("/"));
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .authenticator(new JavaNetAuthenticator())
+          .build());
+      connection = urlFactory.open(server.url("/").url());
     }
     assertEquals(responseCode, connection.getResponseCode());
+    connection.getErrorStream().close();
     return authenticator.calls;
   }
 
@@ -1528,7 +1625,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   private void assertValidRequestMethod(String requestMethod) throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setRequestMethod(requestMethod);
     assertEquals(requestMethod, connection.getRequestMethod());
   }
@@ -1542,7 +1639,7 @@ private void assertValidRequestMethod(String requestMethod) throws Exception {
   }
 
   private void assertInvalidRequestMethod(String requestMethod) throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.setRequestMethod(requestMethod);
       fail();
@@ -1569,14 +1666,14 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
         .addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT")
         .addHeader("icy-metaint:16000")
         .setBody("mp3 data"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertEquals(200, connection.getResponseCode());
     assertEquals("OK", connection.getResponseMessage());
     assertContent("mp3 data", connection);
   }
 
   @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.setFixedLengthStreamingMode(-2);
       fail();
@@ -1585,13 +1682,13 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
   }
 
   @Test public void canSetNegativeChunkedStreamingMode() throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setChunkedStreamingMode(-2);
   }
 
   @Test public void cannotSetFixedLengthStreamingModeAfterConnect() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     try {
       connection.setFixedLengthStreamingMode(1);
@@ -1602,7 +1699,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
 
   @Test public void cannotSetChunkedStreamingModeAfterConnect() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     try {
       connection.setChunkedStreamingMode(1);
@@ -1612,7 +1709,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
   }
 
   @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setChunkedStreamingMode(1);
     try {
       connection.setFixedLengthStreamingMode(1);
@@ -1622,7 +1719,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
   }
 
   @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setFixedLengthStreamingMode(1);
     try {
       connection.setChunkedStreamingMode(1);
@@ -1647,11 +1744,13 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("Success!"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
     if (streamingMode == StreamingMode.FIXED_LENGTH) {
       connection.setFixedLengthStreamingMode(requestBody.length);
     } else if (streamingMode == StreamingMode.CHUNKED) {
@@ -1688,9 +1787,12 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.enqueue(new MockResponse().setBody("Successful auth!"));
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
     OutputStream outputStream = connection.getOutputStream();
     outputStream.write(requestBody);
     outputStream.close();
@@ -1722,7 +1824,10 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.enqueue(new MockResponse().setBody("Successful auth!"));
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
     // no authorization header for the first request...
@@ -1754,7 +1859,10 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.enqueue(successfulResponse);
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
     // no authorization header for the first request...
@@ -1778,7 +1886,10 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.enqueue(new MockResponse().setBody("Successful auth!"));
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1801,7 +1912,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     server.enqueue(response);
     server.enqueue(new MockResponse().setBody("This is the new location!"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("This is the new location!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1821,9 +1932,11 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("This is the new location!"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("This is the new location!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1840,10 +1953,12 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .addHeader("Location: http://anyhost/foo")
         .setBody("This page has moved!"));
 
-    client.client().setFollowSslRedirects(false);
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .followSslRedirects(false)
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1852,8 +1967,10 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .addHeader("Location: https://anyhost/foo")
         .setBody("This page has moved!"));
 
-    client.client().setFollowSslRedirects(false);
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .followSslRedirects(false)
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1862,13 +1979,15 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
 
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.getUrl("/"))
+        .addHeader("Location: " + server2.url("/").url())
         .setBody("This page has moved!"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setFollowSslRedirects(true);
-    HttpsURLConnection connection = (HttpsURLConnection) client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .followSslRedirects(true)
+        .build());
+    HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(server.url("/").url());
     assertContent("This is insecure HTTP!", connection);
     assertNull(connection.getCipherSuite());
     assertNull(connection.getLocalCertificates());
@@ -1882,13 +2001,15 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     server2.enqueue(new MockResponse().setBody("This is secure HTTPS!"));
 
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.getUrl("/"))
+        .addHeader("Location: " + server2.url("/").url())
         .setBody("This page has moved!"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setFollowSslRedirects(true);
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .followSslRedirects(true)
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     assertContent("This is secure HTTPS!", connection);
     assertFalse(connection instanceof HttpsURLConnection);
   }
@@ -1906,25 +2027,27 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
       server.useHttps(sslContext.getSocketFactory(), false);
       server2.useHttps(sslContext.getSocketFactory(), false);
       server2.setProtocolNegotiationEnabled(false);
-      client.client().setSslSocketFactory(sslContext.getSocketFactory());
-      client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+      urlFactory.setClient(urlFactory.client().newBuilder()
+          .sslSocketFactory(sslContext.getSocketFactory())
+          .hostnameVerifier(new RecordingHostnameVerifier())
+          .build());
     }
 
     server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
     server2.enqueue(new MockResponse().setBody("This is the 2nd server, again!"));
 
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.getUrl("/").toString())
+        .addHeader("Location: " + server2.url("/").url().toString())
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("This is the first server again!"));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertContent("This is the 2nd server!", connection);
-    assertEquals(server2.getUrl("/"), connection.getURL());
+    assertEquals(server2.url("/").url(), connection.getURL());
 
     // make sure the first server was careful to recycle the connection
-    assertContent("This is the first server again!", client.open(server.getUrl("/")));
-    assertContent("This is the 2nd server, again!", client.open(server2.getUrl("/")));
+    assertContent("This is the first server again!", urlFactory.open(server.url("/").url()));
+    assertContent("This is the 2nd server, again!", urlFactory.open(server2.url("/").url()));
 
     String server1Host = server.getHostName() + ":" + server.getPort();
     String server2Host = server2.getHostName() + ":" + server2.getPort();
@@ -1936,29 +2059,31 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
 
   @Test public void redirectWithProxySelector() throws Exception {
     final List<URI> proxySelectionRequests = new ArrayList<URI>();
-    client.client().setProxySelector(new ProxySelector() {
-      @Override public List<Proxy> select(URI uri) {
-        proxySelectionRequests.add(uri);
-        MockWebServer proxyServer = (uri.getPort() == server.getPort())
-            ? server
-            : server2;
-        return Arrays.asList(proxyServer.toProxyAddress());
-      }
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .proxySelector(new ProxySelector() {
+          @Override public List<Proxy> select(URI uri) {
+            proxySelectionRequests.add(uri);
+            MockWebServer proxyServer = (uri.getPort() == server.getPort())
+                ? server
+                : server2;
+            return Arrays.asList(proxyServer.toProxyAddress());
+          }
 
-      @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
-        throw new AssertionError();
-      }
-    });
+          @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
+            throw new AssertionError();
+          }
+        })
+        .build());
 
     server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
 
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.getUrl("/b").toString())
+        .addHeader("Location: " + server2.url("/b").url().toString())
         .setBody("This page has moved!"));
 
-    assertContent("This is the 2nd server!", client.open(server.getUrl("/a")));
+    assertContent("This is the 2nd server!", urlFactory.open(server.url("/a").url()));
 
-    assertEquals(Arrays.asList(server.getUrl("/a").toURI(), server2.getUrl("/b").toURI()),
+    assertEquals(Arrays.asList(server.url("/").url().toURI(), server2.url("/").url().toURI()),
         proxySelectionRequests);
   }
 
@@ -1967,11 +2092,12 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
 
     server.enqueue(new MockResponse().setResponseCode(401));
     server.enqueue(new MockResponse().setResponseCode(302)
-        .addHeader("Location: " + server2.getUrl("/b")));
+        .addHeader("Location: " + server2.url("/b").url()));
 
-    client.client().setAuthenticator(
-        new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")));
-    assertContent("Page 2", client.open(server.getUrl("/a")));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
+        .build());
+    assertContent("Page 2", urlFactory.open(server.url("/a").url()));
 
     RecordedRequest redirectRequest = server2.takeRequest();
     assertNull(redirectRequest.getHeader("Authorization"));
@@ -2010,10 +2136,10 @@ private void testResponseRedirectedWithPost(int redirectCode, TransferKind trans
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("Page 2"));
 
-    connection = client.open(server.getUrl("/page1"));
+    connection = urlFactory.open(server.url("/page1").url());
     connection.setDoOutput(true);
     transferKind.setForRequest(connection, 4);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
     OutputStream outputStream = connection.getOutputStream();
     outputStream.write(requestBody);
     outputStream.close();
@@ -2033,7 +2159,7 @@ private void testResponseRedirectedWithPost(int redirectCode, TransferKind trans
         .addHeader("Location: /page2"));
     server.enqueue(new MockResponse().setBody("Page 2"));
 
-    connection = client.open(server.getUrl("/page1"));
+    connection = urlFactory.open(server.url("/page1").url());
     connection.setDoOutput(true);
     connection.addRequestProperty("Content-Length", "4");
     connection.addRequestProperty("Content-Type", "text/plain; charset=utf-8");
@@ -2054,11 +2180,11 @@ private void testResponseRedirectedWithPost(int redirectCode, TransferKind trans
 
   @Test public void response305UseProxy() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_USE_PROXY)
-        .addHeader("Location: " + server.getUrl("/"))
+        .addHeader("Location: " + server.url("/").url())
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("Proxy Response"));
 
-    connection = client.open(server.getUrl("/foo"));
+    connection = urlFactory.open(server.url("/foo").url());
     // Fails on the RI, which gets "Proxy Response"
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -2109,9 +2235,9 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     server.enqueue(response1);
     server.enqueue(new MockResponse().setBody("Page 2"));
 
-    connection = client.open(server.getUrl("/page1"));
+    connection = urlFactory.open(server.url("/page1").url());
     connection.setRequestMethod(method);
-    byte[] requestBody = { 'A', 'B', 'C', 'D' };
+    byte[] requestBody = {'A', 'B', 'C', 'D'};
     if (method.equals("POST")) {
       connection.setDoOutput(true);
       OutputStream outputStream = connection.getOutputStream();
@@ -2126,7 +2252,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
 
     if (method.equals("GET")) {
       assertEquals("Page 2", response);
-    } else if (method.equals("HEAD"))  {
+    } else if (method.equals("HEAD")) {
       assertEquals("", response);
     } else {
       // Methods other than GET/HEAD shouldn't follow the redirect
@@ -2154,9 +2280,9 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     }
     server.enqueue(new MockResponse().setBody("Success!"));
 
-    connection = client.open(server.getUrl("/0"));
+    connection = urlFactory.open(server.url("/0").url());
     assertContent("Success!", connection);
-    assertEquals(server.getUrl("/20"), connection.getURL());
+    assertEquals(server.url("/20").url(), connection.getURL());
   }
 
   @Test public void doesNotFollow21Redirects() throws Exception {
@@ -2166,7 +2292,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
           .setBody("Redirecting to /" + (i + 1)));
     }
 
-    connection = client.open(server.getUrl("/0"));
+    connection = urlFactory.open(server.url("/0").url());
     try {
       connection.getInputStream();
       fail();
@@ -2174,34 +2300,82 @@ private void testRedirect(boolean temporary, String method) throws Exception {
       assertEquals(HttpURLConnection.HTTP_MOVED_TEMP, connection.getResponseCode());
       assertEquals("Too many follow-up requests: 21", expected.getMessage());
       assertContent("Redirecting to /21", connection);
-      assertEquals(server.getUrl("/20"), connection.getURL());
+      assertEquals(server.url("/20").url(), connection.getURL());
     }
   }
 
   @Test public void httpsWithCustomTrustManager() throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    RecordingTrustManager trustManager = new RecordingTrustManager();
+    RecordingTrustManager trustManager = new RecordingTrustManager(sslContext);
     SSLContext sc = SSLContext.getInstance("TLS");
-    sc.init(null, new TrustManager[] { trustManager }, new java.security.SecureRandom());
+    sc.init(null, new TrustManager[] {trustManager}, new SecureRandom());
 
-    client.client().setHostnameVerifier(hostnameVerifier);
-    client.client().setSslSocketFactory(sc.getSocketFactory());
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .hostnameVerifier(hostnameVerifier)
+        .sslSocketFactory(sc.getSocketFactory())
+        .build());
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
     server.enqueue(new MockResponse().setBody("GHI"));
 
-    URL url = server.getUrl("/");
-    assertContent("ABC", client.open(url));
-    assertContent("DEF", client.open(url));
-    assertContent("GHI", client.open(url));
+    URL url = server.url("/").url();
+    assertContent("ABC", urlFactory.open(url));
+    assertContent("DEF", urlFactory.open(url));
+    assertContent("GHI", urlFactory.open(url));
 
-    assertEquals(Arrays.asList("verify " + server.getHostName()),
-        hostnameVerifier.calls);
+    assertEquals(Arrays.asList("verify " + server.getHostName()), hostnameVerifier.calls);
     assertEquals(Arrays.asList("checkServerTrusted [CN=" + server.getHostName() + " 1]"),
         trustManager.calls);
   }
 
+  @Test public void getClientRequestTimeout() throws Exception {
+    enqueueClientRequestTimeoutResponses();
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Body", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+  }
+
+  private void enqueueClientRequestTimeoutResponses() {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(HttpURLConnection.HTTP_CLIENT_TIMEOUT)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse().setBody("Body"));
+  }
+
+  @Test public void bufferedBodyWithClientRequestTimeout() throws Exception {
+    enqueueClientRequestTimeoutResponses();
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    connection.setRequestMethod("POST");
+    connection.getOutputStream().write("Hello".getBytes("UTF-8"));
+
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Body", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("Hello", request1.getBody().readUtf8());
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("Hello", request2.getBody().readUtf8());
+  }
+
+  @Test public void streamedBodyWithClientRequestTimeout() throws Exception {
+    enqueueClientRequestTimeoutResponses();
+
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
+    connection.setRequestMethod("POST");
+    connection.setChunkedStreamingMode(0);
+    connection.getOutputStream().write("Hello".getBytes("UTF-8"));
+
+    assertEquals(408, connection.getResponseCode());
+    assertEquals(1, server.getRequestCount());
+  }
+
   @Test public void readTimeouts() throws IOException {
     // This relies on the fact that MockWebServer doesn't close the
     // connection after a response has been sent. This causes the client to
@@ -2211,7 +2385,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     server.enqueue(timeout);
     server.enqueue(new MockResponse().setBody("unused")); // to keep the server alive
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.setReadTimeout(1000);
     InputStream in = connection.getInputStream();
     assertEquals('A', in.read());
@@ -2222,38 +2396,45 @@ private void testRedirect(boolean temporary, String method) throws Exception {
       fail();
     } catch (SocketTimeoutException expected) {
     }
+    in.close();
   }
 
   /** Confirm that an unacknowledged write times out. */
   @Test public void writeTimeouts() throws IOException {
+    MockWebServer server = new MockWebServer();
     // Sockets on some platforms can have large buffers that mean writes do not block when
     // required. These socket factories explicitly set the buffer sizes on sockets created.
-    final int SOCKET_BUFFER_SIZE = 256 * 1024;
+    final int SOCKET_BUFFER_SIZE = 4 * 1024;
     server.setServerSocketFactory(
         new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
           @Override
-          protected void configureServerSocket(ServerSocket serverSocket) throws IOException {
+          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
+              throws IOException {
             serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return serverSocket;
           }
         });
-    client.client().setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-      @Override
-      protected void configureSocket(Socket socket) throws IOException {
-        socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-        socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-      }
-    });
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+          @Override protected Socket configureSocket(Socket socket) throws IOException {
+            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+            return socket;
+          }
+        })
+        .writeTimeout(500, TimeUnit.MILLISECONDS)
+        .build());
 
+    server.start();
     server.enqueue(new MockResponse()
         .throttleBody(1, 1, TimeUnit.SECONDS)); // Prevent the server from reading!
 
-    client.client().setWriteTimeout(500, TimeUnit.MILLISECONDS);
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     connection.setChunkedStreamingMode(0);
     OutputStream out = connection.getOutputStream();
     try {
-      byte[] data = new byte[16 * 1024 * 1024]; // 16 MiB.
+      byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
       out.write(data);
       fail();
     } catch (SocketTimeoutException expected) {
@@ -2263,7 +2444,7 @@ protected void configureSocket(Socket socket) throws IOException {
   @Test public void setChunkedEncodingAsRequestProperty() throws IOException, InterruptedException {
     server.enqueue(new MockResponse());
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setRequestProperty("Transfer-encoding", "chunked");
     connection.setDoOutput(true);
     connection.getOutputStream().write("ABC".getBytes("UTF-8"));
@@ -2277,11 +2458,11 @@ protected void configureSocket(Socket socket) throws IOException {
     server.enqueue(new MockResponse()); // server doesn't honor the connection: close header!
     server.enqueue(new MockResponse());
 
-    HttpURLConnection a = client.open(server.getUrl("/"));
+    HttpURLConnection a = urlFactory.open(server.url("/").url());
     a.setRequestProperty("Connection", "close");
     assertEquals(200, a.getResponseCode());
 
-    HttpURLConnection b = client.open(server.getUrl("/"));
+    HttpURLConnection b = urlFactory.open(server.url("/").url());
     assertEquals(200, b.getResponseCode());
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
@@ -2293,10 +2474,10 @@ protected void configureSocket(Socket socket) throws IOException {
     server.enqueue(new MockResponse().addHeader("Connection: close"));
     server.enqueue(new MockResponse());
 
-    HttpURLConnection a = client.open(server.getUrl("/"));
+    HttpURLConnection a = urlFactory.open(server.url("/").url());
     assertEquals(200, a.getResponseCode());
 
-    HttpURLConnection b = client.open(server.getUrl("/"));
+    HttpURLConnection b = urlFactory.open(server.url("/").url());
     assertEquals(200, b.getResponseCode());
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
@@ -2305,13 +2486,15 @@ protected void configureSocket(Socket socket) throws IOException {
   }
 
   @Test public void connectionCloseWithRedirect() throws IOException, InterruptedException {
-    MockResponse response = new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+    MockResponse response = new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /foo")
         .addHeader("Connection: close");
     server.enqueue(response);
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
+    server.enqueue(new MockResponse()
+        .setBody("This is the new location!"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("This is the new location!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -2325,12 +2508,18 @@ protected void configureSocket(Socket socket) throws IOException {
    * https://code.google.com/p/android/issues/detail?id=41576
    */
   @Test public void sameConnectionRedirectAndReuse() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+    // TODO(jwilson): this behavior shouldn't rely on having another IP address to attempt.
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build());
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
         .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().setBody("This is the new page!"));
+    server.enqueue(new MockResponse()
+        .setBody("This is the new page!"));
 
-    assertContent("This is the new page!", client.open(server.getUrl("/")));
+    assertContent("This is the new page!", urlFactory.open(server.url("/").url()));
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(0, server.takeRequest().getSequenceNumber());
@@ -2340,7 +2529,7 @@ protected void configureSocket(Socket socket) throws IOException {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
         .setBody("This body is not allowed!"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("This body is not allowed!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
@@ -2348,7 +2537,7 @@ protected void configureSocket(Socket socket) throws IOException {
   @Test public void singleByteReadIsSigned() throws IOException {
     server.enqueue(new MockResponse().setBody(new Buffer().writeByte(-2).writeByte(-1)));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     InputStream in = connection.getInputStream();
     assertEquals(254, in.read());
     assertEquals(255, in.read());
@@ -2368,14 +2557,14 @@ protected void configureSocket(Socket socket) throws IOException {
   }
 
   /**
-   * We explicitly permit apps to close the upload stream even after it has
-   * been transmitted.  We also permit flush so that buffered streams can
-   * do a no-op flush when they are closed. http://b/3038470
+   * We explicitly permit apps to close the upload stream even after it has been transmitted.  We
+   * also permit flush so that buffered streams can do a no-op flush when they are closed.
+   * http://b/3038470
    */
   private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setBody("abc"));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     byte[] upload = "def".getBytes("UTF-8");
 
@@ -2400,7 +2589,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   @Test public void getHeadersThrows() throws IOException {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getInputStream();
       fail();
@@ -2415,7 +2604,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void dnsFailureThrowsIOException() throws IOException {
-    connection = client.open(new URL("http://host.unlikelytld"));
+    connection = urlFactory.open(new URL("http://host.unlikelytld"));
     try {
       connection.connect();
       fail();
@@ -2424,7 +2613,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
-    connection = client.open(new URL("http:///foo.html"));
+    connection = urlFactory.open(new URL("http://./foo.html"));
     try {
       connection.connect();
       fail();
@@ -2436,13 +2625,13 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     server.enqueue(new MockResponse().setBody("ABC"));
 
     // The request should work once and then fail
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     connection1.setReadTimeout(100);
     InputStream input = connection1.getInputStream();
     assertEquals("ABC", readAscii(input, Integer.MAX_VALUE));
     server.shutdown();
     try {
-      HttpURLConnection connection2 = client.open(server.getUrl(""));
+      HttpURLConnection connection2 = urlFactory.open(server.url("").url());
       connection2.setReadTimeout(100);
       connection2.getInputStream();
       fail();
@@ -2455,9 +2644,9 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     server.enqueue(new MockResponse().setBody("ABC")
         .clearHeaders()
         .addHeader("Connection: close")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+        .setSocketPolicy(DISCONNECT_AT_END));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     InputStream in = connection.getInputStream();
     assertEquals("ABC", readAscii(in, 3));
     assertEquals(-1, in.read());
@@ -2466,40 +2655,42 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
 
   @Test public void getContent() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     InputStream in = (InputStream) connection.getContent();
     assertEquals("A", readAscii(in, Integer.MAX_VALUE));
   }
 
   @Test public void getContentOfType() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getContent(null);
       fail();
     } catch (NullPointerException expected) {
     }
     try {
-      connection.getContent(new Class[] { null });
+      connection.getContent(new Class[] {null});
       fail();
     } catch (NullPointerException expected) {
     }
-    assertNull(connection.getContent(new Class[] { getClass() }));
+    assertNull(connection.getContent(new Class[] {getClass()}));
+    connection.getInputStream().close();
   }
 
   @Test public void getOutputStreamOnGetFails() throws Exception {
     server.enqueue(new MockResponse());
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getOutputStream();
       fail();
     } catch (ProtocolException expected) {
     }
+    connection.getInputStream().close();
   }
 
   @Test public void getOutputAfterGetInputStreamFails() throws Exception {
     server.enqueue(new MockResponse());
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     try {
       connection.getInputStream();
@@ -2511,7 +2702,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
 
   @Test public void setDoOutputOrDoInputAfterConnectFails() throws Exception {
     server.enqueue(new MockResponse());
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.connect();
     try {
       connection.setDoOutput(true);
@@ -2523,36 +2714,41 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
       fail();
     } catch (IllegalStateException expected) {
     }
+    connection.getInputStream().close();
   }
 
   @Test public void clientSendsContentLength() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     OutputStream out = connection.getOutputStream();
-    out.write(new byte[] { 'A', 'B', 'C' });
+    out.write(new byte[] {'A', 'B', 'C'});
     out.close();
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     RecordedRequest request = server.takeRequest();
     assertEquals("3", request.getHeader("Content-Length"));
+    connection.getInputStream().close();
   }
 
   @Test public void getContentLengthConnects() throws Exception {
     server.enqueue(new MockResponse().setBody("ABC"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertEquals(3, connection.getContentLength());
+    connection.getInputStream().close();
   }
 
   @Test public void getContentTypeConnects() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("ABC"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("text/plain", connection.getContentType());
+    connection.getInputStream().close();
   }
 
   @Test public void getContentEncodingConnects() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Encoding: identity").setBody("ABC"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("identity", connection.getContentEncoding());
+    connection.getInputStream().close();
   }
 
   // http://b/4361656
@@ -2560,13 +2756,13 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     server.enqueue(new MockResponse().setBody("A"));
 
     URL url = new URL("http", server.getHostName(), server.getPort(), "?query");
-    assertEquals("A", readAscii(client.open(url).getInputStream(), Integer.MAX_VALUE));
+    assertEquals("A", readAscii(urlFactory.open(url).getInputStream(), Integer.MAX_VALUE));
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /?query HTTP/1.1", request.getRequestLine());
   }
 
   @Test public void doOutputForMethodThatDoesntSupportOutput() throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setRequestMethod("HEAD");
     connection.setDoOutput(true);
     try {
@@ -2594,7 +2790,7 @@ private void testInputStreamAvailable(TransferKind transferKind) throws IOExcept
     MockResponse response = new MockResponse();
     transferKind.setBody(response, body, 4);
     server.enqueue(response);
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     InputStream in = connection.getInputStream();
     for (int i = 0; i < body.length(); i++) {
       assertTrue(in.available() >= 0);
@@ -2634,7 +2830,10 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("B"));
     server.enqueue(new MockResponse().setBody("C"));
 
-    assertContent("A", client.open(server.getUrl("/a")));
+    assertContent("A", urlFactory.open(server.url("/a").url()));
+
+    // Give the server time to disconnect.
+    Thread.sleep(500);
 
     // If the request body is larger than OkHttp's replay buffer, the failure may still occur.
     byte[] requestBody = new byte[requestSize];
@@ -2642,7 +2841,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     for (int j = 0; j < 2; j++) {
       try {
-        connection = client.open(server.getUrl("/b"));
+        connection = urlFactory.open(server.url("/b").url());
         connection.setRequestMethod("POST");
         transferKind.setForRequest(connection, requestBody.length);
         for (int i = 0; i < requestBody.length; i += 1024) {
@@ -2668,15 +2867,15 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
   @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
     server.enqueue(new MockResponse().setBody("def"));
 
     // Seed the connection pool so we have something that can fail.
-    assertContent("abc", client.open(server.getUrl("/")));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
 
-    HttpURLConnection post = client.open(server.getUrl("/"));
+    HttpURLConnection post = urlFactory.open(server.url("/").url());
     post.setDoOutput(true);
-    post.getOutputStream().write("body!".getBytes(Util.UTF_8));
+    post.getOutputStream().write("body!".getBytes(UTF_8));
     assertContent("def", post);
 
     RecordedRequest get = server.takeRequest();
@@ -2694,7 +2893,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
   @Test public void fullyBufferedPostIsTooShort() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
 
-    connection = client.open(server.getUrl("/b"));
+    connection = urlFactory.open(server.url("/b").url());
     connection.setRequestProperty("Content-Length", "4");
     connection.setRequestMethod("POST");
     OutputStream out = connection.getOutputStream();
@@ -2711,7 +2910,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
   @Test public void fullyBufferedPostIsTooLong() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
 
-    connection = client.open(server.getUrl("/b"));
+    connection = urlFactory.open(server.url("/b").url());
     connection.setRequestProperty("Content-Length", "3");
     connection.setRequestMethod("POST");
     OutputStream out = connection.getOutputStream();
@@ -2752,7 +2951,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
   @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("B", "");
     assertContent("body", connection);
     assertEquals("", connection.getRequestProperty("B"));
@@ -2760,14 +2959,14 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
   @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().addHeader("A:").setBody("body"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     assertContent("body", connection);
     assertEquals("", connection.getHeaderField("A"));
   }
 
   @Test public void emptyRequestHeaderNameIsStrict() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.setRequestProperty("", "A");
       fail();
@@ -2779,13 +2978,14 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     Headers.Builder headers = new Headers.Builder();
     Internal.instance.addLenient(headers, ":A");
     server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.getResponseCode();
     assertEquals("A", connection.getHeaderField(""));
+    connection.getInputStream().close();
   }
 
   @Test public void requestHeaderValidationIsStrict() throws Exception {
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.addRequestProperty("a\tb", "Value");
       fail();
@@ -2822,7 +3022,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
         .build();
     server.enqueue(new MockResponse().setHeaders(headers));
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.getResponseCode();
     assertEquals("c\u007fd", connection.getHeaderField("a\tb"));
     assertEquals("\u2615\ufe0f", connection.getHeaderField("\ud83c\udf69"));
@@ -2850,34 +3050,38 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     String credential = Credentials.basic("jesse", "peanutbutter");
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential);
-    client.client().setAuthenticator(authenticator);
-    assertContent("A", client.open(server.getUrl("/private")));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(authenticator)
+        .build());
+    assertContent("A", urlFactory.open(server.url("/private").url()));
 
     assertNull(server.takeRequest().getHeader("Authorization"));
     assertEquals(credential, server.takeRequest().getHeader("Authorization"));
 
     assertEquals(Proxy.NO_PROXY, authenticator.onlyProxy());
     Response response = authenticator.onlyResponse();
-    assertEquals("/private", response.request().url().getPath());
+    assertEquals("/private", response.request().url().url().getPath());
     assertEquals(Arrays.asList(new Challenge("Basic", "protected area")), response.challenges());
   }
 
   @Test public void customTokenAuthenticator() throws Exception {
     MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-            .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
-            .setBody("Please authenticate.");
+        .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
+        .setBody("Please authenticate.");
     server.enqueue(pleaseAuthenticate);
     server.enqueue(new MockResponse().setBody("A"));
 
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator("oauthed abc123");
-    client.client().setAuthenticator(authenticator);
-    assertContent("A", client.open(server.getUrl("/private")));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(authenticator)
+        .build());
+    assertContent("A", urlFactory.open(server.url("/private").url()));
 
     assertNull(server.takeRequest().getHeader("Authorization"));
     assertEquals("oauthed abc123", server.takeRequest().getHeader("Authorization"));
 
     Response response = authenticator.onlyResponse();
-    assertEquals("/private", response.request().url().getPath());
+    assertEquals("/private", response.request().url().url().getPath());
     assertEquals(Arrays.asList(new Challenge("Bearer", "oauthed")), response.challenges());
   }
 
@@ -2892,14 +3096,16 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
         Credentials.basic("jesse", "peanutbutter"));
-    client.client().setAuthenticator(authenticator);
-    assertContent("c", client.open(server.getUrl("/a")));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(authenticator)
+        .build());
+    assertContent("c", urlFactory.open(server.url("/a").url()));
 
     Response challengeResponse = authenticator.responses.get(0);
-    assertEquals("/b", challengeResponse.request().url().getPath());
+    assertEquals("/b", challengeResponse.request().url().url().getPath());
 
     Response redirectedBy = challengeResponse.priorResponse();
-    assertEquals("/a", redirectedBy.request().url().getPath());
+    assertEquals("/a", redirectedBy.request().url().url().getPath());
   }
 
   @Test public void attemptAuthorization20Times() throws Exception {
@@ -2909,9 +3115,11 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("Success!"));
 
     String credential = Credentials.basic("jesse", "peanutbutter");
-    client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build());
 
-    connection = client.open(server.getUrl("/0"));
+    connection = urlFactory.open(server.url("/0").url());
     assertContent("Success!", connection);
   }
 
@@ -2921,9 +3129,11 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     }
 
     String credential = Credentials.basic("jesse", "peanutbutter");
-    client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build());
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     try {
       connection.getInputStream();
       fail();
@@ -2944,8 +3154,10 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
   private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException {
     enableProtocol(protocol);
     server.enqueue(new MockResponse().setBody("A"));
-    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
-    connection = client.open(server.getUrl("/"));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .build());
+    connection = urlFactory.open(server.url("/").url());
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
     assertEquals(Arrays.asList(protocol.toString()), protocolValues);
     assertContent("A", connection);
@@ -2953,14 +3165,14 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
 
   @Test public void http10SelectedProtocol() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 OK"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
     assertEquals(Arrays.asList("http/1.0"), protocolValues);
   }
 
   @Test public void http11SelectedProtocol() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
     assertEquals(Arrays.asList("http/1.1"), protocolValues);
   }
@@ -2998,7 +3210,7 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
   private void zeroLengthPayload(String method)
       throws IOException, InterruptedException {
     server.enqueue(new MockResponse());
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setRequestProperty("Content-Length", "0");
     connection.setRequestMethod(method);
     connection.setFixedLengthStreamingMode(0);
@@ -3013,7 +3225,7 @@ private void zeroLengthPayload(String method)
   @Test public void unspecifiedRequestBodyContentTypeGetsDefault() throws Exception {
     server.enqueue(new MockResponse());
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     connection.getOutputStream().write("abc".getBytes(UTF_8));
     assertEquals(200, connection.getResponseCode());
@@ -3026,13 +3238,15 @@ private void zeroLengthPayload(String method)
 
   @Test public void setProtocols() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    client.client().setProtocols(Arrays.asList(Protocol.HTTP_1_1));
-    assertContent("A", client.open(server.getUrl("/")));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .protocols(Arrays.asList(Protocol.HTTP_1_1))
+        .build());
+    assertContent("A", urlFactory.open(server.url("/").url()));
   }
 
   @Test public void setProtocolsWithoutHttp11() throws Exception {
     try {
-      client.client().setProtocols(Arrays.asList(Protocol.SPDY_3));
+      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.SPDY_3));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -3040,7 +3254,7 @@ private void zeroLengthPayload(String method)
 
   @Test public void setProtocolsWithNull() throws Exception {
     try {
-      client.client().setProtocols(Arrays.asList(Protocol.HTTP_1_1, null));
+      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_1_1, null));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -3050,7 +3264,7 @@ private void zeroLengthPayload(String method)
     server.setBodyLimit(0);
     server.enqueue(new MockResponse());
 
-    connection = client.open(server.getUrl("/"));
+    connection = urlFactory.open(server.url("/").url());
     connection.setDoOutput(true);
     long contentLength = Integer.MAX_VALUE + 1L;
     connection.setFixedLengthStreamingMode(contentLength);
@@ -3068,10 +3282,9 @@ private void zeroLengthPayload(String method)
   }
 
   /**
-   * We had a bug where we attempted to gunzip responses that didn't have a
-   * body. This only came up with 304s since that response code can include
-   * headers (like "Content-Encoding") without any content to go along with it.
-   * https://github.com/square/okhttp/issues/358
+   * We had a bug where we attempted to gunzip responses that didn't have a body. This only came up
+   * with 304s since that response code can include headers (like "Content-Encoding") without any
+   * content to go along with it. https://github.com/square/okhttp/issues/358
    */
   @Test public void noTransparentGzipFor304NotModified() throws Exception {
     server.enqueue(new MockResponse()
@@ -3080,11 +3293,11 @@ private void zeroLengthPayload(String method)
         .addHeader("Content-Encoding: gzip"));
     server.enqueue(new MockResponse().setBody("b"));
 
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection1.getResponseCode());
     assertContent("", connection1);
 
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertContent("b", connection2);
 
@@ -3107,7 +3320,7 @@ private void zeroLengthPayload(String method)
         .setBody(gzip("Moved! Moved! Moved!")));
     server.enqueue(new MockResponse().setBody("This is the new page!"));
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertContent("This is the new page!", connection);
 
     RecordedRequest requestA = server.takeRequest();
@@ -3118,13 +3331,13 @@ private void zeroLengthPayload(String method)
   }
 
   /**
-   * The RFC is unclear in this regard as it only specifies that this should
-   * invalidate the cache entry (if any).
+   * The RFC is unclear in this regard as it only specifies that this should invalidate the cache
+   * entry (if any).
    */
   @Test public void bodyPermittedOnDelete() throws Exception {
     server.enqueue(new MockResponse());
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     connection.setRequestMethod("DELETE");
     connection.setDoOutput(true);
     connection.getOutputStream().write("BODY".getBytes(UTF_8));
@@ -3139,7 +3352,7 @@ private void zeroLengthPayload(String method)
     server.enqueue(new MockResponse().setBody("abc"));
 
     System.setProperty("http.agent", "foo");
-    assertContent("abc", client.open(server.getUrl("/")));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
 
     RecordedRequest request = server.takeRequest();
     assertEquals("foo", request.getHeader("User-Agent"));
@@ -3150,7 +3363,7 @@ private void zeroLengthPayload(String method)
     server.enqueue(new MockResponse().setBody("abc"));
 
     System.setProperty("http.agent", "a\nb\ud83c\udf69c\ud83c\udf68d\u007fe");
-    assertContent("abc", client.open(server.getUrl("/")));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
 
     RecordedRequest request = server.takeRequest();
     assertEquals("a?b?c?d?e", request.getHeader("User-Agent"));
@@ -3159,7 +3372,7 @@ private void zeroLengthPayload(String method)
   @Test public void userAgentDefaultsToOkHttpVersion() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
-    assertContent("abc", client.open(server.getUrl("/")));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
 
     RecordedRequest request = server.takeRequest();
     assertEquals(Version.userAgent(), request.getHeader("User-Agent"));
@@ -3171,11 +3384,77 @@ private void zeroLengthPayload(String method)
         throw new AssertionError();
       }
     };
-    client.client().interceptors().add(interceptor);
-    client.client().networkInterceptors().add(interceptor);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .addInterceptor(interceptor)
+        .addNetworkInterceptor(interceptor)
+        .build());
 
     server.enqueue(new MockResponse().setBody("abc"));
-    assertContent("abc", client.open(server.getUrl("/")));
+    assertContent("abc", urlFactory.open(server.url("/").url()));
+  }
+
+  @Test public void urlWithSpaceInHost() throws Exception {
+    URLConnection urlConnection = urlFactory.open(new URL("http://and roid.com/"));
+    try {
+      urlConnection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void urlWithSpaceInHostViaHttpProxy() throws Exception {
+    server.enqueue(new MockResponse());
+    URLConnection urlConnection =
+        urlFactory.open(new URL("http://and roid.com/"), server.toProxyAddress());
+
+    try {
+      // This test is to check that a NullPointerException is not thrown.
+      urlConnection.getInputStream();
+      fail(); // the RI makes a bogus proxy request for "GET http://and roid.com/ HTTP/1.1"
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void urlHostWithNul() throws Exception {
+    URLConnection urlConnection = urlFactory.open(new URL("http://host\u0000/"));
+    try {
+      urlConnection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void urlRedirectToHostWithNul() throws Exception {
+    String redirectUrl = "http://host\u0000/";
+    server.enqueue(new MockResponse().setResponseCode(302)
+        .addHeaderLenient("Location", redirectUrl));
+
+    HttpURLConnection urlConnection = urlFactory.open(server.url("/").url());
+    assertEquals(302, urlConnection.getResponseCode());
+    assertEquals(redirectUrl, urlConnection.getHeaderField("Location"));
+  }
+
+  @Test public void urlWithBadAsciiHost() throws Exception {
+    URLConnection urlConnection = urlFactory.open(new URL("http://host\u0001/"));
+    try {
+      urlConnection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void instanceFollowsRedirects() throws Exception {
+    testInstanceFollowsRedirects("http://www.google.com/");
+    testInstanceFollowsRedirects("https://www.google.com/");
+  }
+
+  private void testInstanceFollowsRedirects(String spec) throws Exception {
+    URL url = new URL(spec);
+    HttpURLConnection urlConnection = urlFactory.open(url);
+    urlConnection.setInstanceFollowRedirects(true);
+    assertTrue(urlConnection.getInstanceFollowRedirects());
+    urlConnection.setInstanceFollowRedirects(false);
+    assertFalse(urlConnection.getInstanceFollowRedirects());
   }
 
   /** Returns a gzipped copy of {@code bytes}. */
@@ -3188,8 +3467,8 @@ public Buffer gzip(String data) throws IOException {
   }
 
   /**
-   * Reads at most {@code limit} characters from {@code in} and asserts that
-   * content equals {@code expected}.
+   * Reads at most {@code limit} characters from {@code in} and asserts that content equals {@code
+   * expected}.
    */
   private void assertContent(String expected, HttpURLConnection connection, int limit)
       throws IOException {
@@ -3211,6 +3490,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
           throws IOException {
         response.setChunkedBody(content, chunkSize);
       }
+
       @Override void setForRequest(HttpURLConnection connection, int contentLength) {
         connection.setChunkedStreamingMode(5);
       }
@@ -3219,6 +3499,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
       }
+
       @Override void setForRequest(HttpURLConnection connection, int contentLength) {
         connection.setFixedLengthStreamingMode(contentLength);
       }
@@ -3229,6 +3510,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
         response.setSocketPolicy(DISCONNECT_AT_END);
         response.removeHeader("Content-Length");
       }
+
       @Override void setForRequest(HttpURLConnection connection, int contentLength) {
       }
     };
@@ -3247,7 +3529,9 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
       @Override public HttpURLConnection connect(
           MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        streamHandlerFactory.client().setProxy(Proxy.NO_PROXY);
+        streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
+            .proxy(Proxy.NO_PROXY)
+            .build());
         return streamHandlerFactory.open(url);
       }
     },
@@ -3256,7 +3540,9 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
       @Override public HttpURLConnection connect(
           MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        streamHandlerFactory.client().setProxy(server.toProxyAddress());
+        streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
+            .proxy(server.toProxyAddress())
+            .build());
         return streamHandlerFactory.open(url);
       }
     },
@@ -3298,9 +3584,14 @@ public abstract HttpURLConnection connect(
 
   private static class RecordingTrustManager implements X509TrustManager {
     private final List<String> calls = new ArrayList<String>();
+    private final X509TrustManager delegate;
+
+    public RecordingTrustManager(SSLContext sslContext) {
+      this.delegate = Platform.get().trustManager(sslContext.getSocketFactory());
+    }
 
     public X509Certificate[] getAcceptedIssuers() {
-      return new X509Certificate[] { };
+      return delegate.getAcceptedIssuers();
     }
 
     public void checkClientTrusted(X509Certificate[] chain, String authType)
@@ -3322,40 +3613,27 @@ private String certificatesToString(X509Certificate[] certificates) {
     }
   }
 
-  private static class FakeProxySelector extends ProxySelector {
-    List<Proxy> proxies = new ArrayList<>();
-
-    @Override public List<Proxy> select(URI uri) {
-      // Don't handle 'socket' schemes, which the RI's Socket class may request (for SOCKS).
-      return uri.getScheme().equals("http") || uri.getScheme().equals("https") ? proxies
-          : Collections.singletonList(Proxy.NO_PROXY);
-    }
-
-    @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-    }
-  }
-
   /**
    * Tests that use this will fail unless boot classpath is set. Ex. {@code
    * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
    */
   private void enableProtocol(Protocol protocol) {
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
-    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .build());
     server.useHttps(sslContext.getSocketFactory(), false);
     server.setProtocolNegotiationEnabled(true);
-    server.setProtocols(client.client().getProtocols());
+    server.setProtocols(urlFactory.client().protocols());
   }
 
   /**
    * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
-   * TLS_FALLBACK_SCSV cipher on fallback connections. See
-   * {@link com.squareup.okhttp.FallbackTestClientSocketFactory} for details.
+   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
+   * for details.
    */
-  private void suppressTlsFallbackScsv(OkHttpClient client) {
-    FallbackTestClientSocketFactory clientSocketFactory =
-        new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
-    client.setSslSocketFactory(clientSocketFactory);
+  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
+    return new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/UrlComponentEncodingTester.java b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
similarity index 83%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/UrlComponentEncodingTester.java
rename to okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
index 199279f7c0..56611be40a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/UrlComponentEncodingTester.java
+++ b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.net.URI;
 import java.net.URL;
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.ByteString;
 
@@ -27,6 +28,10 @@
 
 /** Tests how each code point is encoded and decoded in the context of each URL component. */
 class UrlComponentEncodingTester {
+  private static final int UNICODE_2 = 0x07ff; // Arbitrary code point that's 2 bytes in UTF-8.
+  private static final int UNICODE_3 = 0xffff; // Arbitrary code point that's 3 bytes in UTF-8.
+  private static final int UNICODE_4 = 0x10ffff; // Arbitrary code point that's 4 bytes in UTF-8.
+
   /**
    * The default encode set for the ASCII range. The specific rules vary per-component: for example,
    * '?' may be identity-encoded in a fragment, but must be percent-encoded in a path.
@@ -34,6 +39,7 @@
    * See https://url.spec.whatwg.org/#percent-encoded-bytes
    */
   private static final Map<Integer, Encoding> defaultEncodings;
+
   static {
     Map<Integer, Encoding> map = new LinkedHashMap<>();
     map.put(       0x0, Encoding.PERCENT); // Null character
@@ -164,11 +170,14 @@
     map.put((int)  '}', Encoding.IDENTITY);
     map.put((int)  '~', Encoding.IDENTITY);
     map.put(      0x7f, Encoding.PERCENT); // Delete
+    map.put( UNICODE_2, Encoding.PERCENT);
+    map.put( UNICODE_3, Encoding.PERCENT);
+    map.put( UNICODE_4, Encoding.PERCENT);
     defaultEncodings = Collections.unmodifiableMap(map);
   }
 
   private final Map<Integer, Encoding> encodings;
-  private final StringBuilder skipForUri = new StringBuilder();
+  private final StringBuilder uriEscapedCodePoints = new StringBuilder();
 
   public UrlComponentEncodingTester() {
     this.encodings = new LinkedHashMap<>(defaultEncodings);
@@ -181,12 +190,19 @@ public UrlComponentEncodingTester override(Encoding encoding, int... codePoints)
     return this;
   }
 
+  public UrlComponentEncodingTester identityForNonAscii() {
+    encodings.put(UNICODE_2, Encoding.IDENTITY);
+    encodings.put(UNICODE_3, Encoding.IDENTITY);
+    encodings.put(UNICODE_4, Encoding.IDENTITY);
+    return this;
+  }
+
   /**
    * Configure a character to be skipped but only for conversion to and from {@code java.net.URI}.
    * That class is more strict than the others.
    */
   public UrlComponentEncodingTester skipForUri(int... codePoints) {
-    skipForUri.append(new String(codePoints, 0, codePoints.length));
+    uriEscapedCodePoints.append(new String(codePoints, 0, codePoints.length));
     return this;
   }
 
@@ -202,9 +218,10 @@ public UrlComponentEncodingTester test(Component component) {
       testToUrl(codePoint, encoding, component);
       testFromUrl(codePoint, encoding, component);
 
-      if (skipForUri.indexOf(Encoding.IDENTITY.encode(codePoint)) == -1) {
-        testToUri(codePoint, encoding, component);
-        testFromUri(codePoint, encoding, component);
+      if (codePoint != '%') {
+        boolean uriEscaped = uriEscapedCodePoints.indexOf(
+            Encoding.IDENTITY.encode(codePoint)) != -1;
+        testUri(codePoint, encoding, component, uriEscaped);
       }
     }
     return this;
@@ -215,7 +232,7 @@ private void testParseAlreadyEncoded(int codePoint, Encoding encoding, Component
     String urlString = component.urlString(encoded);
     HttpUrl url = HttpUrl.parse(urlString);
     if (!component.encodedValue(url).equals(encoded)) {
-      fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
     }
   }
 
@@ -226,7 +243,7 @@ private void testEncodeAndDecode(int codePoint, Component component) {
     HttpUrl url = builder.build();
     String actual = component.get(url);
     if (!expected.equals(actual)) {
-      fail(String.format("Roundtrip %s %#x %s", component, codePoint, url));
+      fail(Util.format("Roundtrip %s %#x %s", component, codePoint, url));
     }
   }
 
@@ -239,7 +256,7 @@ private void testParseOriginal(int codePoint, Encoding encoding, Component compo
 
     String s = component.encodedValue(url);
     if (!s.equals(encoded)) {
-      fail(String.format("Encoding %s %#02x using %s", component, codePoint, encoding));
+      fail(Util.format("Encoding %s %#02x using %s", component, codePoint, encoding));
     }
   }
 
@@ -248,7 +265,7 @@ private void testToUrl(int codePoint, Encoding encoding, Component component) {
     HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
     URL javaNetUrl = httpUrl.url();
     if (!javaNetUrl.toString().equals(javaNetUrl.toString())) {
-      fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
     }
   }
 
@@ -257,32 +274,40 @@ private void testFromUrl(int codePoint, Encoding encoding, Component component)
     HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
     HttpUrl toAndFromJavaNetUrl = HttpUrl.get(httpUrl.url());
     if (!toAndFromJavaNetUrl.equals(httpUrl)) {
-      fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
     }
   }
 
-  private void testToUri(int codePoint, Encoding encoding, Component component) {
+  private void testUri(
+      int codePoint, Encoding encoding, Component component, boolean uriEscaped) {
+    String string = new String(new int[] {codePoint}, 0, 1);
     String encoded = encoding.encode(codePoint);
     HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
     URI uri = httpUrl.uri();
-    if (!uri.toString().equals(uri.toString())) {
-      fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
-    }
-  }
-
-  private void testFromUri(int codePoint, Encoding encoding, Component component) {
-    String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
-    HttpUrl toAndFromUri = HttpUrl.get(httpUrl.uri());
-    if (!toAndFromUri.equals(httpUrl)) {
-      fail(String.format("Encoding %s %#x using %s", component, codePoint, encoding));
+    HttpUrl toAndFromUri = HttpUrl.get(uri);
+    if (uriEscaped) {
+      // The URI has more escaping than the HttpURL. Check that the decoded values still match.
+      if (uri.toString().equals(httpUrl.toString())) {
+        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      }
+      if (!component.get(toAndFromUri).equals(string)) {
+        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      }
+    } else {
+      // Check that the URI and HttpURL have the exact same escaping.
+      if (!toAndFromUri.equals(httpUrl)) {
+        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      }
+      if (!uri.toString().equals(httpUrl.toString())) {
+        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
+      }
     }
   }
 
   public enum Encoding {
     IDENTITY {
       public String encode(int codePoint) {
-        return new String(new int[] { codePoint }, 0, 1);
+        return new String(new int[] {codePoint}, 0, 1);
       }
     },
 
@@ -291,7 +316,7 @@ public String encode(int codePoint) {
         ByteString utf8 = ByteString.encodeUtf8(IDENTITY.encode(codePoint));
         Buffer percentEncoded = new Buffer();
         for (int i = 0; i < utf8.size(); i++) {
-          percentEncoded.writeUtf8(String.format("%%%02X", utf8.getByte(i) & 0xff));
+          percentEncoded.writeUtf8(Util.format("%%%02X", utf8.getByte(i) & 0xff));
         }
         return percentEncoded.readUtf8();
       }
@@ -309,12 +334,15 @@ public String encode(int codePoint) {
       @Override public String urlString(String value) {
         return "http://" + value + "@example.com/";
       }
+
       @Override public String encodedValue(HttpUrl url) {
         return url.encodedUsername();
       }
+
       @Override public void set(HttpUrl.Builder builder, String value) {
         builder.username(value);
       }
+
       @Override public String get(HttpUrl url) {
         return url.username();
       }
@@ -323,12 +351,15 @@ public String encode(int codePoint) {
       @Override public String urlString(String value) {
         return "http://:" + value + "@example.com/";
       }
+
       @Override public String encodedValue(HttpUrl url) {
         return url.encodedPassword();
       }
+
       @Override public void set(HttpUrl.Builder builder, String value) {
         builder.password(value);
       }
+
       @Override public String get(HttpUrl url) {
         return url.password();
       }
@@ -337,13 +368,16 @@ public String encode(int codePoint) {
       @Override public String urlString(String value) {
         return "http://example.com/a" + value + "z/";
       }
+
       @Override public String encodedValue(HttpUrl url) {
         String path = url.encodedPath();
         return path.substring(2, path.length() - 2);
       }
+
       @Override public void set(HttpUrl.Builder builder, String value) {
         builder.addPathSegment("a" + value + "z");
       }
+
       @Override public String get(HttpUrl url) {
         String pathSegment = url.pathSegments().get(0);
         return pathSegment.substring(1, pathSegment.length() - 1);
@@ -353,30 +387,38 @@ public String encode(int codePoint) {
       @Override public String urlString(String value) {
         return "http://example.com/?a" + value + "z";
       }
+
       @Override public String encodedValue(HttpUrl url) {
         String query = url.encodedQuery();
         return query.substring(1, query.length() - 1);
       }
+
       @Override public void set(HttpUrl.Builder builder, String value) {
-        builder.query(value);
+        builder.query("a" + value + "z");
       }
+
       @Override public String get(HttpUrl url) {
-        return url.query();
+        String query = url.query();
+        return query.substring(1, query.length() - 1);
       }
     },
     FRAGMENT {
       @Override public String urlString(String value) {
         return "http://example.com/#a" + value + "z";
       }
+
       @Override public String encodedValue(HttpUrl url) {
         String fragment = url.encodedFragment();
         return fragment.substring(1, fragment.length() - 1);
       }
+
       @Override public void set(HttpUrl.Builder builder, String value) {
-        builder.fragment(value);
+        builder.fragment("a" + value + "z");
       }
+
       @Override public String get(HttpUrl url) {
-        return url.fragment();
+        String fragment = url.fragment();
+        return fragment.substring(1, fragment.length() - 1);
       }
     };
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/WebPlatformUrlTest.java b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
similarity index 95%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/WebPlatformUrlTest.java
rename to okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
index e45761ce58..a15c57ea35 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/WebPlatformUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import okhttp3.internal.Util;
 import okio.BufferedSource;
 import okio.Okio;
 import org.junit.Test;
@@ -38,7 +38,7 @@
     try {
       List<Object[]> result = new ArrayList<>();
       for (WebPlatformUrlTestData urlTestData : loadTests()) {
-        result.add(new Object[] { urlTestData });
+        result.add(new Object[] {urlTestData});
       }
       return result;
     } catch (IOException e) {
@@ -57,8 +57,6 @@
       "Parsing: <http://f:00000000000000/c> against <http://example.org/foo/bar>",
       "Parsing: <http://f:\n/c> against <http://example.org/foo/bar>",
       "Parsing: <http://f:999999/c> against <http://example.org/foo/bar>",
-      "Parsing: <#β> against <http://example.org/foo/bar>",
-      "Parsing: <http://www.google.com/foo?bar=baz# »> against <about:blank>",
       "Parsing: <http://192.0x00A80001> against <about:blank>",
       // This test fails on Java 7 but passes on Java 8. See HttpUrlTest.hostWithTrailingDot().
       "Parsing: <http://%30%78%63%30%2e%30%32%35%30.01%2e> against <http://other.com/>",
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/WebPlatformUrlTestData.java b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/WebPlatformUrlTestData.java
rename to okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
index 2ea36939aa..72f92f9abf 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/WebPlatformUrlTestData.java
+++ b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.EOFException;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
 
@@ -81,7 +82,7 @@ private void set(String name, String value) {
   }
 
   @Override public String toString() {
-    return String.format("Parsing: <%s> against <%s>", input, base);
+    return Util.format("Parsing: <%s> against <%s>", input, base);
   }
 
   public static List<WebPlatformUrlTestData> load(BufferedSource source) throws IOException {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ConnectionSpecSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java
similarity index 96%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/ConnectionSpecSelectorTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java
index c94cc23213..b6aa5344c2 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ConnectionSpecSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ConnectionSpecSelectorTest.java
@@ -13,10 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
-import com.squareup.okhttp.ConnectionSpec;
-import com.squareup.okhttp.TlsVersion;
 import java.io.IOException;
 import java.security.cert.CertificateException;
 import java.util.Arrays;
@@ -25,6 +23,8 @@
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocket;
+import okhttp3.ConnectionSpec;
+import okhttp3.TlsVersion;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -91,7 +91,7 @@ public void someFallbacksSupported() throws Exception {
     ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(
         ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3);
 
-    TlsVersion[] enabledSocketTlsVersions = { TlsVersion.TLS_1_1, TlsVersion.TLS_1_0 };
+    TlsVersion[] enabledSocketTlsVersions = {TlsVersion.TLS_1_1, TlsVersion.TLS_1_0};
     SSLSocket socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
 
     // MODERN_TLS is used here.
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
similarity index 72%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
index c996d202dd..be2d0be61d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/DiskLruCacheTest.java
@@ -13,9 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
-import com.squareup.okhttp.internal.io.FileSystem;
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayDeque;
@@ -26,6 +25,7 @@
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.concurrent.Executor;
+import okhttp3.internal.io.FileSystem;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.Okio;
@@ -37,10 +37,10 @@
 import org.junit.rules.TemporaryFolder;
 import org.junit.rules.Timeout;
 
-import static com.squareup.okhttp.internal.DiskLruCache.JOURNAL_FILE;
-import static com.squareup.okhttp.internal.DiskLruCache.JOURNAL_FILE_BACKUP;
-import static com.squareup.okhttp.internal.DiskLruCache.MAGIC;
-import static com.squareup.okhttp.internal.DiskLruCache.VERSION_1;
+import static okhttp3.internal.DiskLruCache.JOURNAL_FILE;
+import static okhttp3.internal.DiskLruCache.JOURNAL_FILE_BACKUP;
+import static okhttp3.internal.DiskLruCache.MAGIC;
+import static okhttp3.internal.DiskLruCache.VERSION_1;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
@@ -50,7 +50,7 @@
 
 public final class DiskLruCacheTest {
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-  @Rule public final Timeout timeout = new Timeout(30 * 1000);
+  @Rule public final Timeout timeout = new Timeout(60 * 1000);
 
   private final FaultyFileSystem fileSystem = new FaultyFileSystem(FileSystem.SYSTEM);
   private final int appVersion = 100;
@@ -282,8 +282,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   }
 
   /**
-   * Each read sees a snapshot of the file at the time read was called.
-   * This means that two reads of the same key can see different data.
+   * Each read sees a snapshot of the file at the time read was called. This means that two reads of
+   * the same key can see different data.
    */
   @Test public void readAndWriteOverlapsMaintainConsistency() throws Exception {
     DiskLruCache.Editor v1Creator = cache.edit("k1");
@@ -697,6 +697,199 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     }
   }
 
+  @Test public void rebuildJournalFailurePreventsEditors() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    // Don't allow edits under any circumstances.
+    assertNull(cache.edit("a"));
+    assertNull(cache.edit("c"));
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    assertNull(snapshot.edit());
+    snapshot.close();
+  }
+
+  @Test public void rebuildJournalFailureIsRetried() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    // The rebuild is retried on cache hits and on cache edits.
+    DiskLruCache.Snapshot snapshot = cache.get("b");
+    snapshot.close();
+    assertNull(cache.edit("d"));
+    assertEquals(2, executor.jobs.size());
+
+    // On cache misses, no retry job is queued.
+    assertNull(cache.get("c"));
+    assertEquals(2, executor.jobs.size());
+
+    // Let the rebuild complete successfully.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
+    executor.jobs.removeFirst().run();
+    assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1");
+  }
+
+  @Test public void rebuildJournalFailureWithInFlightEditors() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+    DiskLruCache.Editor commitEditor = cache.edit("c");
+    DiskLruCache.Editor abortEditor = cache.edit("d");
+    cache.edit("e"); // Grab an editor, but don't do anything with it.
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    // In-flight editors can commit and have their values retained.
+    setString(commitEditor, 0, "c");
+    setString(commitEditor, 1, "c");
+    commitEditor.commit();
+    assertValue("c", "c", "c");
+
+    abortEditor.abort();
+
+    // Let the rebuild complete successfully.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
+    executor.jobs.removeFirst().run();
+    assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1", "DIRTY e", "CLEAN c 1 1");
+  }
+
+  @Test public void rebuildJournalFailureWithEditorsInFlightThenClose() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+    DiskLruCache.Editor commitEditor = cache.edit("c");
+    DiskLruCache.Editor abortEditor = cache.edit("d");
+    cache.edit("e"); // Grab an editor, but don't do anything with it.
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    setString(commitEditor, 0, "c");
+    setString(commitEditor, 1, "c");
+    commitEditor.commit();
+    assertValue("c", "c", "c");
+
+    abortEditor.abort();
+
+    cache.close();
+    createNewCache();
+
+    // Although 'c' successfully committed above, the journal wasn't available to issue a CLEAN op.
+    // Because the last state of 'c' was DIRTY before the journal failed, it should be removed
+    // entirely on a subsequent open.
+    assertEquals(4, cache.size());
+    assertAbsent("c");
+    assertAbsent("d");
+    assertAbsent("e");
+  }
+
+  @Test public void rebuildJournalFailureAllowsRemovals() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    assertTrue(cache.remove("a"));
+    assertAbsent("a");
+
+    // Let the rebuild complete successfully.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
+    executor.jobs.removeFirst().run();
+
+    assertJournalEquals("CLEAN b 1 1");
+  }
+
+  @Test public void rebuildJournalFailureWithRemovalThenClose() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    assertTrue(cache.remove("a"));
+    assertAbsent("a");
+
+    cache.close();
+    createNewCache();
+
+    // The journal will have no record that 'a' was removed. It will have an entry for 'a', but when
+    // it tries to read the cache files, it will find they were deleted. Once it encounters an entry
+    // with missing cache files, it should remove it from the cache entirely.
+    assertEquals(4, cache.size());
+    assertNull(cache.get("a"));
+    assertEquals(2, cache.size());
+  }
+
+  @Test public void rebuildJournalFailureAllowsEvictAll() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    cache.evictAll();
+
+    assertEquals(0, cache.size());
+    assertAbsent("a");
+    assertAbsent("b");
+
+    cache.close();
+    createNewCache();
+
+    // The journal has no record that 'a' and 'b' were removed. It will have an entry for both, but
+    // when it tries to read the cache files for either entry, it will discover the cache files are
+    // missing and remove the entries from the cache.
+    assertEquals(4, cache.size());
+    assertNull(cache.get("a"));
+    assertNull(cache.get("b"));
+    assertEquals(0, cache.size());
+  }
+
+  @Test public void rebuildJournalFailureWithCacheTrim() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "aa", "aa");
+      set("b", "bb", "bb");
+    }
+
+    // Cause the rebuild action to fail.
+    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
+    executor.jobs.removeFirst().run();
+
+    // Trigger a job to trim the cache.
+    cache.setMaxSize(4);
+    executor.jobs.removeFirst().run();
+
+    assertAbsent("a");
+    assertValue("b", "bb", "bb");
+  }
+
   @Test public void restoreBackupFile() throws Exception {
     DiskLruCache.Editor creator = cache.edit("k1");
     setString(creator, 0, "ABC");
@@ -763,6 +956,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("a", "a", "a");
     fileSystem.delete(getCleanFile("a", 1));
     assertNull(cache.get("a"));
+    assertEquals(0, cache.size());
   }
 
   @Test public void editSameVersion() throws Exception {
@@ -859,9 +1053,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   }
 
   /**
-   * We had a long-lived bug where {@link DiskLruCache#trimToSize} could
-   * infinite loop if entries being edited required deletion for the operation
-   * to complete.
+   * We had a long-lived bug where {@link DiskLruCache#trimToSize} could infinite loop if entries
+   * being edited required deletion for the operation to complete.
    */
   @Test public void trimToSizeWithActiveEdit() throws Exception {
     set("a", "a1234", "a1234");
@@ -1074,11 +1267,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "b", "b");
 
     // We can't begin the edit if writing 'DIRTY' fails.
-    fileSystem.setFaulty(journalFile, true);
+    fileSystem.setFaultyWrite(journalFile, true);
     assertNull(cache.edit("c"));
 
     // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaulty(journalFile, false);
+    fileSystem.setFaultyWrite(journalFile, false);
     assertNull(cache.edit("d"));
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
@@ -1102,11 +1295,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor editor = cache.edit("c");
     setString(editor, 0, "c");
     setString(editor, 1, "c");
-    fileSystem.setFaulty(journalFile, true);
+    fileSystem.setFaultyWrite(journalFile, true);
     editor.commit();
 
     // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaulty(journalFile, false);
+    fileSystem.setFaultyWrite(journalFile, false);
     assertNull(cache.edit("d"));
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
@@ -1126,11 +1319,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor editor = cache.edit("c");
     setString(editor, 0, "c");
     setString(editor, 1, "c");
-    fileSystem.setFaulty(journalFile, true);
+    fileSystem.setFaultyWrite(journalFile, true);
     editor.abort();
 
     // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaulty(journalFile, false);
+    fileSystem.setFaultyWrite(journalFile, false);
     assertNull(cache.edit("d"));
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
@@ -1147,17 +1340,276 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "b", "b");
 
     // Remove, but the journal write will fail.
-    fileSystem.setFaulty(journalFile, true);
+    fileSystem.setFaultyWrite(journalFile, true);
     assertTrue(cache.remove("a"));
 
     // Confirm that the entry was still removed.
-    fileSystem.setFaulty(journalFile, false);
+    fileSystem.setFaultyWrite(journalFile, false);
     cache.close();
     cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
     assertAbsent("a");
     assertValue("b", "b", "b");
   }
 
+  @Test public void cleanupTrimFailurePreventsNewEditors() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm that edits are prevented after a cache trim failure.
+    assertNull(cache.edit("a"));
+    assertNull(cache.edit("b"));
+    assertNull(cache.edit("c"));
+
+    // Allow the test to clean up.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+  }
+
+  @Test public void cleanupTrimFailureRetriedOnEditors() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // An edit should now add a job to clean up if the most recent trim failed.
+    assertNull(cache.edit("b"));
+    executor.jobs.pop().run();
+
+    // Confirm a successful cache trim now allows edits.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    assertNull(cache.edit("c"));
+    executor.jobs.pop().run();
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void cleanupTrimFailureWithInFlightEditor() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aaa");
+    set("b", "bb", "bb");
+    DiskLruCache.Editor inFlightEditor = cache.edit("c");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // The in-flight editor can still write after a trim failure.
+    setString(inFlightEditor, 0, "cc");
+    setString(inFlightEditor, 1, "cc");
+    inFlightEditor.commit();
+
+    // Confirm the committed values are present after a successful cache trim.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    executor.jobs.pop().run();
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void cleanupTrimFailureAllowsSnapshotReads() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we still allow snapshot reads after a trim failure.
+    assertValue("a", "aa", "aa");
+    assertValue("b", "bb", "bbb");
+
+    // Allow the test to clean up.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+  }
+
+  @Test public void cleanupTrimFailurePreventsSnapshotWrites() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm snapshot writes are prevented after a trim failure.
+    DiskLruCache.Snapshot snapshot1 = cache.get("a");
+    assertNull(snapshot1.edit());
+    snapshot1.close();
+    DiskLruCache.Snapshot snapshot2 = cache.get("b");
+    assertNull(snapshot2.edit());
+    snapshot2.close();
+
+    // Allow the test to clean up.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+  }
+
+  @Test public void evictAllAfterCleanupTrimFailure() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("c"));
+
+    // A successful eviction should allow new writes.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    cache.evictAll();
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void manualRemovalAfterCleanupTrimFailure() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("c"));
+
+    // A successful removal which trims the cache should allow new writes.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    cache.remove("a");
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void flushingAfterCleanupTrimFailure() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim job to fail.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
+    executor.jobs.pop().run();
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("c"));
+
+    // A successful flush trims the cache and should allow new writes.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
+    cache.flush();
+    set("c", "cc", "cc");
+    assertValue("c", "cc", "cc");
+  }
+
+  @Test public void cleanupTrimFailureWithPartialSnapshot() throws Exception {
+    cache.setMaxSize(8);
+    executor.jobs.pop();
+    set("a", "aa", "aa");
+    set("b", "bb", "bbb");
+
+    // Cause the cache trim to fail on the second value leaving a partial snapshot.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), true);
+    executor.jobs.pop().run();
+
+    // Confirm the partial snapshot is not returned.
+    assertNull(cache.get("a"));
+
+    // Confirm we prevent edits after a trim failure.
+    assertNull(cache.edit("a"));
+
+    // Confirm the partial snapshot is not returned after a successful trim.
+    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), false);
+    executor.jobs.pop().run();
+    assertNull(cache.get("a"));
+  }
+
+  @Test public void noSizeCorruptionAfterCreatorDetached() throws Exception {
+    // Create an editor for k1. Detach it by clearing the cache.
+    DiskLruCache.Editor editor = cache.edit("k1");
+    setString(editor, 0, "a");
+    setString(editor, 1, "a");
+    cache.evictAll();
+
+    // Create a new value in its place.
+    set("k1", "bb", "bb");
+    assertEquals(4, cache.size());
+
+    // Committing the detached editor should not change the cache's size.
+    editor.commit();
+    assertEquals(4, cache.size());
+    assertValue("k1", "bb", "bb");
+  }
+
+  @Test public void noSizeCorruptionAfterEditorDetached() throws Exception {
+    set("k1", "a", "a");
+
+    // Create an editor for k1. Detach it by clearing the cache.
+    DiskLruCache.Editor editor = cache.edit("k1");
+    setString(editor, 0, "bb");
+    setString(editor, 1, "bb");
+    cache.evictAll();
+
+    // Create a new value in its place.
+    set("k1", "ccc", "ccc");
+    assertEquals(6, cache.size());
+
+    // Committing the detached editor should not change the cache's size.
+    editor.commit();
+    assertEquals(6, cache.size());
+    assertValue("k1", "ccc", "ccc");
+  }
+
+  @Test public void noNewSourceAfterEditorDetached() throws Exception {
+    set("k1", "a", "a");
+
+    DiskLruCache.Editor editor = cache.edit("k1");
+    cache.evictAll();
+
+    assertNull(editor.newSource(0));
+  }
+
+  @Test public void editsDiscardedAfterEditorDetached() throws Exception {
+    set("k1", "a", "a");
+
+    // Create an editor, then detach it.
+    DiskLruCache.Editor editor = cache.edit("k1");
+    BufferedSink sink = Okio.buffer(editor.newSink(0));
+    cache.evictAll();
+
+    // Create another value in its place.
+    set("k1", "ccc", "ccc");
+
+    // Complete the original edit. It goes into a black hole.
+    sink.writeUtf8("bb");
+    sink.close();
+
+    assertValue("k1", "ccc", "ccc");
+  }
+
+  @Test public void abortAfterDetach() throws Exception {
+    set("k1", "a", "a");
+
+    DiskLruCache.Editor editor = cache.edit("k1");
+    cache.evictAll();
+
+    editor.abort();
+    assertEquals(0, cache.size());
+    assertAbsent("k1");
+  }
+
   private void assertJournalEquals(String... expectedBodyLines) throws Exception {
     List<String> expectedLines = new ArrayList<>();
     expectedLines.add(MAGIC);
@@ -1259,7 +1711,7 @@ private void generateSomeGarbageFiles() throws Exception {
     writeFile(new File(dir2, "otherFile1"), "F");
   }
 
-  private void assertGarbageFilesAllDeleted() throws Exception {
+  private void assertGarbageFilesAllDeleted() {
     assertFalse(fileSystem.exists(getCleanFile("g1", 0)));
     assertFalse(fileSystem.exists(getCleanFile("g1", 1)));
     assertFalse(fileSystem.exists(getCleanFile("g2", 0)));
@@ -1275,7 +1727,8 @@ private void set(String key, String value0, String value1) throws Exception {
     editor.commit();
   }
 
-  public static void setString(DiskLruCache.Editor editor, int index, String value) throws IOException {
+  public static void setString(DiskLruCache.Editor editor, int index, String value)
+      throws IOException {
     BufferedSink writer = Okio.buffer(editor.newSink(index));
     writer.writeUtf8(value);
     writer.close();
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DoubleInetAddressNetwork.java b/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
similarity index 70%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/DoubleInetAddressNetwork.java
rename to okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
index 4934b427c9..7811ff5d75 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DoubleInetAddressNetwork.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
@@ -13,18 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
 import java.net.InetAddress;
 import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.List;
+import okhttp3.Dns;
 
 /**
  * A network that always resolves two IP addresses per host. Use this when testing route selection
  * fallbacks to guarantee that a fallback address is available.
  */
-public class DoubleInetAddressNetwork implements Network {
-  @Override public InetAddress[] resolveInetAddresses(String host) throws UnknownHostException {
-    InetAddress[] allInetAddresses = Network.DEFAULT.resolveInetAddresses(host);
-    return new InetAddress[] { allInetAddresses[0], allInetAddresses[0] };
+public class DoubleInetAddressDns implements Dns {
+  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+    List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
+    return Arrays.asList(addresses.get(0), addresses.get(0));
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/FaultyFileSystem.java b/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
similarity index 75%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/FaultyFileSystem.java
rename to okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
index 537f361c38..3f237d0ad0 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/FaultyFileSystem.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/FaultyFileSystem.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
-import com.squareup.okhttp.internal.io.FileSystem;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.util.LinkedHashSet;
 import java.util.Set;
+import okhttp3.internal.io.FileSystem;
 import okio.Buffer;
 import okio.ForwardingSink;
 import okio.Sink;
@@ -29,12 +29,14 @@
 public final class FaultyFileSystem implements FileSystem {
   private final FileSystem delegate;
   private final Set<File> writeFaults = new LinkedHashSet<>();
+  private final Set<File> deleteFaults = new LinkedHashSet<>();
+  private final Set<File> renameFaults = new LinkedHashSet<>();
 
   public FaultyFileSystem(FileSystem delegate) {
     this.delegate = delegate;
   }
 
-  public void setFaulty(File file, boolean faulty) {
+  public void setFaultyWrite(File file, boolean faulty) {
     if (faulty) {
       writeFaults.add(file);
     } else {
@@ -42,6 +44,22 @@ public void setFaulty(File file, boolean faulty) {
     }
   }
 
+  public void setFaultyDelete(File file, boolean faulty) {
+    if (faulty) {
+      deleteFaults.add(file);
+    } else {
+      deleteFaults.remove(file);
+    }
+  }
+
+  public void setFaultyRename(File file, boolean faulty) {
+    if (faulty) {
+      renameFaults.add(file);
+    } else {
+      renameFaults.remove(file);
+    }
+  }
+
   @Override public Source source(File file) throws FileNotFoundException {
     return delegate.source(file);
   }
@@ -55,10 +73,11 @@ public void setFaulty(File file, boolean faulty) {
   }
 
   @Override public void delete(File file) throws IOException {
+    if (deleteFaults.contains(file)) throw new IOException("boom!");
     delegate.delete(file);
   }
 
-  @Override public boolean exists(File file) throws IOException {
+  @Override public boolean exists(File file) {
     return delegate.exists(file);
   }
 
@@ -67,6 +86,7 @@ public void setFaulty(File file, boolean faulty) {
   }
 
   @Override public void rename(File from, File to) throws IOException {
+    if (renameFaults.contains(from) || renameFaults.contains(to)) throw new IOException("boom!");
     delegate.rename(from, to);
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/Jdk9PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/Jdk9PlatformTest.java
new file mode 100644
index 0000000000..ed6deba9c7
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/Jdk9PlatformTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import org.junit.Test;
+
+import static okhttp3.internal.PlatformTest.getPlatform;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assume.assumeTrue;
+
+public class Jdk9PlatformTest {
+  @Test
+  public void buildsWhenJdk9() {
+    assumeTrue(getPlatform().equals("jdk9"));
+
+    assertNotNull(Jdk9Platform.buildIfSupported());
+  }
+
+  @Test
+  public void findsAlpnMethods() {
+    assumeTrue(getPlatform().equals("jdk9"));
+
+    Jdk9Platform platform = Jdk9Platform.buildIfSupported();
+
+    assertEquals("getApplicationProtocol", platform.getProtocolMethod.getName());
+    assertEquals("setApplicationProtocols", platform.setProtocolMethod.getName());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/JdkWithJettyBootPlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/JdkWithJettyBootPlatformTest.java
new file mode 100644
index 0000000000..04853ac106
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/JdkWithJettyBootPlatformTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import org.junit.Test;
+
+import static okhttp3.internal.PlatformTest.getPlatform;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assume.assumeTrue;
+
+public class JdkWithJettyBootPlatformTest {
+  @Test
+  public void testBuildsWithJettyBoot() {
+    assumeTrue(getPlatform().equals("jdk-with-jetty-boot"));
+
+    assertNotNull(JdkWithJettyBootPlatform.buildIfSupported());
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/OptionalMethodTest.java b/okhttp-tests/src/test/java/okhttp3/internal/OptionalMethodTest.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/OptionalMethodTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/OptionalMethodTest.java
index 3e129a2353..08e025c5d9 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/OptionalMethodTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/OptionalMethodTest.java
@@ -15,12 +15,11 @@
  *  limitations under the License.
  */
 
-package com.squareup.okhttp.internal;
-
-import org.junit.Test;
+package okhttp3.internal;
 
 import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
+import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -38,7 +37,8 @@ public String stringMethod() {
       return "string";
     }
 
-    public void voidMethod() {}
+    public void voidMethod() {
+    }
   }
 
   @SuppressWarnings("unused")
@@ -70,7 +70,8 @@ public void throwsRuntimeException() throws Exception {
       throw new NumberFormatException();
     }
 
-    protected void nonPublic() {}
+    protected void nonPublic() {
+    }
   }
 
   private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_ANY =
@@ -194,8 +195,10 @@ public void invokeBadArgs() throws Exception {
     assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1); // no args
     assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, 123);
     assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, true);
-    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, new Object());
-    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, "one", "two");
+    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
+        new Object());
+    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, "one",
+        "two");
   }
 
   @Test
@@ -268,11 +271,15 @@ public void invokeOptional() throws Exception {
   @Test
   public void invokeOptionalBadArgs() throws Exception {
     SubClass1 subClass1 = new SubClass1();
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1); // no args
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS,
+        subClass1); // no args
     assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, 123);
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, true);
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, new Object());
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, "one", "two");
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
+        true);
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
+        new Object());
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
+        "one", "two");
   }
 
   @Test
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/PlatformTest.java
new file mode 100644
index 0000000000..43e205d7dc
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/PlatformTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import org.junit.Test;
+
+public class PlatformTest {
+  @Test
+  public void alwaysBuilds() {
+    new Platform();
+  }
+
+  public static String getPlatform() {
+    return System.getProperty("okhttp.platform", "platform");
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java b/okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
rename to okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java
index 292875bff6..aeb34f742f 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
 import java.net.Authenticator;
 import java.net.PasswordAuthentication;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
similarity index 71%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
rename to okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
index f5b3617d9d..7d9d2bfe6a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
@@ -13,14 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
-import com.squareup.okhttp.Authenticator;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
+import java.io.IOException;
 import java.net.Proxy;
 import java.util.ArrayList;
 import java.util.List;
+import okhttp3.Authenticator;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.Route;
 
 public final class RecordingOkAuthenticator implements Authenticator {
   public final List<Response> responses = new ArrayList<>();
@@ -41,19 +43,12 @@ public Proxy onlyProxy() {
     return proxies.get(0);
   }
 
-  @Override public Request authenticate(Proxy proxy, Response response) {
+  @Override public Request authenticate(Route route, Response response) throws IOException {
     responses.add(response);
-    proxies.add(proxy);
+    proxies.add(route.proxy());
+    String header = response.code() == 407 ? "Proxy-Authorization" : "Authorization";
     return response.request().newBuilder()
-        .addHeader("Authorization", credential)
-        .build();
-  }
-
-  @Override public Request authenticateProxy(Proxy proxy, Response response) {
-    responses.add(response);
-    proxies.add(proxy);
-    return response.request().newBuilder()
-        .addHeader("Proxy-Authorization", credential)
+        .addHeader(header, credential)
         .build();
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/SingleInetAddressNetwork.java b/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
similarity index 61%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/SingleInetAddressNetwork.java
rename to okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
index beb48cb2e1..03e8ce08e9 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/SingleInetAddressNetwork.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
@@ -13,19 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
 import java.net.InetAddress;
 import java.net.UnknownHostException;
+import java.util.Collections;
+import java.util.List;
+import okhttp3.Dns;
 
 /**
- * A network that resolves only one IP address per host. Use this when testing
- * route selection fallbacks to prevent the host machine's various IP addresses
- * from interfering.
+ * A network that resolves only one IP address per host. Use this when testing route selection
+ * fallbacks to prevent the host machine's various IP addresses from interfering.
  */
-public class SingleInetAddressNetwork implements Network {
-  @Override public InetAddress[] resolveInetAddresses(String host) throws UnknownHostException {
-    InetAddress[] allInetAddresses = Network.DEFAULT.resolveInetAddresses(host);
-    return new InetAddress[] { allInetAddresses[0] };
+public class SingleInetAddressDns implements Dns {
+  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+    List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
+    return Collections.singletonList(addresses.get(0));
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/BaseTestHandler.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/BaseTestHandler.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/BaseTestHandler.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/BaseTestHandler.java
index 252b4c7f54..d619feff7c 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/BaseTestHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/BaseTestHandler.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
 import java.io.IOException;
 import java.util.List;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/HpackTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
similarity index 98%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/HpackTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
index aacddaba95..068ab647e7 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/HpackTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HpackTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
 import java.io.IOException;
 import java.util.Arrays;
@@ -23,7 +23,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static com.squareup.okhttp.TestUtil.headerEntries;
+import static okhttp3.TestUtil.headerEntries;
 import static okio.ByteString.decodeHex;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
@@ -41,8 +41,8 @@
   }
 
   /**
-   * Variable-length quantity special cases strings which are longer than 127
-   * bytes.  Values such as cookies can be 4KiB, and should be possible to send.
+   * Variable-length quantity special cases strings which are longer than 127 bytes.  Values such as
+   * cookies can be 4KiB, and should be possible to send.
    *
    * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-5.2
    */
@@ -61,8 +61,8 @@
   }
 
   /**
-   * HPACK has a max header table size, which can be smaller than the max header message.
-   * Ensure the larger header content is not lost.
+   * HPACK has a max header table size, which can be smaller than the max header message. Ensure the
+   * larger header content is not lost.
    */
   @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
     bytesIn.writeByte(0x00); // Literal indexed
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java
similarity index 84%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2ConnectionTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java
index 4e8e711f7b..b2a583857d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2ConnectionTest.java
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
+import java.net.Socket;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -29,17 +29,23 @@
 import org.junit.After;
 import org.junit.Test;
 
-import static com.squareup.okhttp.TestUtil.headerEntries;
-import static com.squareup.okhttp.internal.framed.ErrorCode.CANCEL;
-import static com.squareup.okhttp.internal.framed.ErrorCode.PROTOCOL_ERROR;
-import static com.squareup.okhttp.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static com.squareup.okhttp.internal.framed.Settings.PERSIST_VALUE;
-import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_DATA;
-import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_HEADERS;
-import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_PING;
-import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_RST_STREAM;
-import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_SETTINGS;
-import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_WINDOW_UPDATE;
+import static okhttp3.TestUtil.headerEntries;
+import static okhttp3.TestUtil.repeat;
+import static okhttp3.internal.Util.EMPTY_BYTE_ARRAY;
+import static okhttp3.internal.framed.ErrorCode.CANCEL;
+import static okhttp3.internal.framed.ErrorCode.PROTOCOL_ERROR;
+import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.framed.Settings.ENABLE_PUSH;
+import static okhttp3.internal.framed.Settings.HEADER_TABLE_SIZE;
+import static okhttp3.internal.framed.Settings.INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.framed.Settings.MAX_FRAME_SIZE;
+import static okhttp3.internal.framed.Settings.PERSIST_VALUE;
+import static okhttp3.internal.framed.Spdy3.TYPE_DATA;
+import static okhttp3.internal.framed.Spdy3.TYPE_HEADERS;
+import static okhttp3.internal.framed.Spdy3.TYPE_PING;
+import static okhttp3.internal.framed.Spdy3.TYPE_RST_STREAM;
+import static okhttp3.internal.framed.Spdy3.TYPE_SETTINGS;
+import static okhttp3.internal.framed.Spdy3.TYPE_WINDOW_UPDATE;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -99,9 +105,9 @@
     peer.setVariantAndClient(HTTP_2, false);
 
     Settings initial = new Settings();
-    initial.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 1684);
+    initial.set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 1684);
     Settings shouldntImpactConnection = new Settings();
-    shouldntImpactConnection.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 3368);
+    shouldntImpactConnection.set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 3368);
 
     peer.sendFrame().settings(initial);
     peer.acceptFrame(); // ACK
@@ -137,7 +143,7 @@
   @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
     boolean client = false; // Peer is server, so we are client.
     Settings settings = new Settings();
-    settings.set(Settings.HEADER_TABLE_SIZE, PERSIST_VALUE, 0);
+    settings.set(HEADER_TABLE_SIZE, PERSIST_VALUE, 0);
 
     FramedConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
 
@@ -151,7 +157,7 @@
   @Test public void peerHttp2ClientDisablesPush() throws Exception {
     boolean client = false; // Peer is client, so we are server.
     Settings settings = new Settings();
-    settings.set(Settings.ENABLE_PUSH, 0, 0); // The peer client disables push.
+    settings.set(ENABLE_PUSH, 0, 0); // The peer client disables push.
 
     FramedConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
 
@@ -162,7 +168,7 @@
   @Test public void peerIncreasesMaxFrameSize() throws Exception {
     int newMaxFrameSize = 0x4001;
     Settings settings = new Settings();
-    settings.set(Settings.MAX_FRAME_SIZE, 0, newMaxFrameSize);
+    settings.set(MAX_FRAME_SIZE, 0, newMaxFrameSize);
 
     FramedConnection connection = sendHttp2SettingsAndCheckForAck(true, settings);
 
@@ -177,7 +183,7 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM 3
     peer.acceptFrame(); // SYN_STREAM 5
-    peer.sendFrame().goAway(3, PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
+    peer.sendFrame().goAway(3, PROTOCOL_ERROR, EMPTY_BYTE_ARRAY);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // DATA STREAM 3
@@ -245,7 +251,7 @@
 
     // Play it back.
     FramedConnection connection = connection(peer, HTTP_2);
-    connection.okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, windowSize);
+    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, 0, windowSize);
     FramedStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(0, stream.unacknowledgedBytesRead);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
@@ -307,7 +313,7 @@ private Buffer data(int byteCount) {
     FramedConnection connection = connection(peer, HTTP_2);
     FramedStream client = connection.newStream(headerEntries("b", "banana"), true, true);
     BufferedSink out = Okio.buffer(client.getSink());
-    out.write(Util.EMPTY_BYTE_ARRAY);
+    out.write(EMPTY_BYTE_ARRAY);
     out.flush();
     out.close();
 
@@ -370,7 +376,9 @@ private Buffer data(int byteCount) {
 
     // play it back
     FramedConnection connection = connectionBuilder(peer, HTTP_2)
-        .pushObserver(observer).build();
+        .pushObserver(observer)
+        .build();
+    connection.start(false);
     FramedStream client = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
@@ -393,6 +401,7 @@ private Buffer data(int byteCount) {
 
     // play it back
     FramedConnection connection = connectionBuilder(peer, HTTP_2).build();
+    connection.start(false);
     connection.newStream(headerEntries("b", "banana"), false, true);
 
     // verify the peer received what was expected
@@ -417,8 +426,10 @@ private Buffer data(int byteCount) {
     peer.play();
 
     // play it back
-    connectionBuilder(peer, HTTP_2)
-        .pushObserver(PushObserver.CANCEL).build();
+    FramedConnection connection = connectionBuilder(peer, HTTP_2)
+        .pushObserver(PushObserver.CANCEL)
+        .build();
+    connection.start(false);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -427,6 +438,39 @@ private Buffer data(int byteCount) {
     assertEquals(CANCEL, rstStream.errorCode);
   }
 
+  /**
+   * When writing a set of headers fails due to an {@code IOException}, make sure the writer is left
+   * in a consistent state so the next writer also gets an {@code IOException} also instead of
+   * something worse (like an {@link IllegalStateException}.
+   *
+   * <p>See https://github.com/square/okhttp/issues/1651
+   */
+  @Test public void socketExceptionWhileWritingHeaders() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+    peer.acceptFrame(); // SYN_STREAM.
+    peer.play();
+
+    String longString = repeat('a', Http2.INITIAL_MAX_FRAME_SIZE + 1);
+    Socket socket = peer.openSocket();
+    FramedConnection connection = new FramedConnection.Builder(true)
+        .socket(socket)
+        .pushObserver(IGNORE)
+        .protocol(HTTP_2.getProtocol())
+        .build();
+    connection.start(false);
+    socket.shutdownOutput();
+    try {
+      connection.newStream(headerEntries("a", longString), false, true);
+      fail();
+    } catch (IOException expected) {
+    }
+    try {
+      connection.newStream(headerEntries("b", longString), false, true);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
   private FramedConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
       throws IOException, InterruptedException {
     peer.setVariantAndClient(HTTP_2, client);
@@ -450,12 +494,15 @@ private FramedConnection sendHttp2SettingsAndCheckForAck(boolean client, Setting
   }
 
   private FramedConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
-    return connectionBuilder(peer, variant).build();
+    FramedConnection connection = connectionBuilder(peer, variant).build();
+    connection.start(false);
+    return connection;
   }
 
   private FramedConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
       throws IOException {
-    return new FramedConnection.Builder(true, peer.openSocket())
+    return new FramedConnection.Builder(true)
+        .socket(peer.openSocket())
         .pushObserver(IGNORE)
         .protocol(variant.getProtocol());
   }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2FrameLoggerTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java
similarity index 84%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2FrameLoggerTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java
index 12a9e3bf90..864a368774 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2FrameLoggerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2FrameLoggerTest.java
@@ -13,26 +13,26 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.framed.Http2.FLAG_ACK;
-import static com.squareup.okhttp.internal.framed.Http2.FLAG_END_HEADERS;
-import static com.squareup.okhttp.internal.framed.Http2.FLAG_END_STREAM;
-import static com.squareup.okhttp.internal.framed.Http2.FLAG_NONE;
-import static com.squareup.okhttp.internal.framed.Http2.FrameLogger.formatFlags;
-import static com.squareup.okhttp.internal.framed.Http2.FrameLogger.formatHeader;
-import static com.squareup.okhttp.internal.framed.Http2.TYPE_CONTINUATION;
-import static com.squareup.okhttp.internal.framed.Http2.TYPE_DATA;
-import static com.squareup.okhttp.internal.framed.Http2.TYPE_GOAWAY;
-import static com.squareup.okhttp.internal.framed.Http2.TYPE_HEADERS;
-import static com.squareup.okhttp.internal.framed.Http2.TYPE_PING;
-import static com.squareup.okhttp.internal.framed.Http2.TYPE_PUSH_PROMISE;
-import static com.squareup.okhttp.internal.framed.Http2.TYPE_SETTINGS;
+import static okhttp3.internal.framed.Http2.FLAG_ACK;
+import static okhttp3.internal.framed.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.framed.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.framed.Http2.FLAG_NONE;
+import static okhttp3.internal.framed.Http2.FrameLogger.formatFlags;
+import static okhttp3.internal.framed.Http2.FrameLogger.formatHeader;
+import static okhttp3.internal.framed.Http2.TYPE_CONTINUATION;
+import static okhttp3.internal.framed.Http2.TYPE_DATA;
+import static okhttp3.internal.framed.Http2.TYPE_GOAWAY;
+import static okhttp3.internal.framed.Http2.TYPE_HEADERS;
+import static okhttp3.internal.framed.Http2.TYPE_PING;
+import static okhttp3.internal.framed.Http2.TYPE_PUSH_PROMISE;
+import static okhttp3.internal.framed.Http2.TYPE_SETTINGS;
 import static org.junit.Assert.assertEquals;
 
 public class Http2FrameLoggerTest {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java
similarity index 96%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2Test.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java
index 8e4f306a54..0ae2f31c78 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Http2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Http2Test.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -27,13 +28,13 @@
 import okio.Okio;
 import org.junit.Test;
 
-import static com.squareup.okhttp.TestUtil.headerEntries;
-import static com.squareup.okhttp.internal.framed.Http2.FLAG_COMPRESSED;
-import static com.squareup.okhttp.internal.framed.Http2.FLAG_END_HEADERS;
-import static com.squareup.okhttp.internal.framed.Http2.FLAG_END_STREAM;
-import static com.squareup.okhttp.internal.framed.Http2.FLAG_NONE;
-import static com.squareup.okhttp.internal.framed.Http2.FLAG_PADDED;
-import static com.squareup.okhttp.internal.framed.Http2.FLAG_PRIORITY;
+import static okhttp3.TestUtil.headerEntries;
+import static okhttp3.internal.framed.Http2.FLAG_COMPRESSED;
+import static okhttp3.internal.framed.Http2.FLAG_END_HEADERS;
+import static okhttp3.internal.framed.Http2.FLAG_END_STREAM;
+import static okhttp3.internal.framed.Http2.FLAG_NONE;
+import static okhttp3.internal.framed.Http2.FLAG_PADDED;
+import static okhttp3.internal.framed.Http2.FLAG_PRIORITY;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -268,7 +269,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     }
   }
 
-  @Test public void readSettingsFrameInvalidSettingId() throws IOException {
+  @Test public void readSettingsFrameUnknownSettingId() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
     frame.writeByte(Http2.TYPE_SETTINGS);
     frame.writeByte(Http2.FLAG_NONE);
@@ -276,12 +277,13 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeShort(7); // old number for SETTINGS_INITIAL_WINDOW_SIZE
     frame.writeInt(1);
 
-    try {
-      fr.nextFrame(new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR invalid settings id: 7", e.getMessage());
-    }
+    final AtomicInteger settingValue = new AtomicInteger();
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void settings(boolean clearPrevious, Settings settings) {
+        settingValue.set(settings.get(7));
+      }
+    });
+    assertEquals(settingValue.intValue(), 1);
   }
 
   @Test public void readSettingsFrameNegativeWindowSize() throws IOException {
@@ -729,7 +731,7 @@ private static Buffer gzip(byte[] data) throws IOException {
   private static List<Header> largeHeaders() {
     String[] nameValues = new String[32];
     char[] chars = new char[512];
-    for (int i = 0; i < nameValues.length;) {
+    for (int i = 0; i < nameValues.length; ) {
       Arrays.fill(chars, (char) i);
       nameValues[i++] = nameValues[i++] = String.valueOf(chars);
     }
@@ -738,7 +740,7 @@ private static Buffer gzip(byte[] data) throws IOException {
 
   private static void writeMedium(BufferedSink sink, int i) throws IOException {
     sink.writeByte((i >>> 16) & 0xff);
-    sink.writeByte((i >>>  8) & 0xff);
-    sink.writeByte( i         & 0xff);
+    sink.writeByte((i >>> 8) & 0xff);
+    sink.writeByte(i & 0xff);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java
new file mode 100644
index 0000000000..c747f0b7a4
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverHttp2Test.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.framed;
+
+import okhttp3.Call;
+import okhttp3.Headers;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.PushPromise;
+import okhttp3.mockwebserver.RecordedRequest;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class HttpOverHttp2Test extends HttpOverSpdyTest {
+
+  public HttpOverHttp2Test() {
+    super(Protocol.HTTP_2);
+    this.hostHeader = ":authority";
+  }
+
+  @Test public void serverSendsPushPromise_GET() throws Exception {
+    PushPromise pushPromise = new PushPromise("GET", "/foo/bar", Headers.of("foo", "bar"),
+        new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet"));
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet")
+        .withPush(pushPromise));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("Sweet", response.message());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
+
+    RecordedRequest pushedRequest = server.takeRequest();
+    assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
+    assertEquals("bar", pushedRequest.getHeader("foo"));
+  }
+
+  @Test public void serverSendsPushPromise_HEAD() throws Exception {
+    PushPromise pushPromise = new PushPromise("HEAD", "/foo/bar", Headers.of("foo", "bar"),
+        new MockResponse().setStatus("HTTP/1.1 204 Sweet"));
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet")
+        .withPush(pushPromise));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("Sweet", response.message());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
+
+    RecordedRequest pushedRequest = server.takeRequest();
+    assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
+    assertEquals("bar", pushedRequest.getHeader("foo"));
+  }
+
+  /**
+   * Push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests and
+   * confirm that the third concurrent request prepared a new connection.
+   */
+  @Test public void settingsLimitsMaxConcurrentStreams() throws Exception {
+    Settings settings = new Settings();
+    settings.set(Settings.MAX_CONCURRENT_STREAMS, 0, 2);
+
+    // Read & write a full request to confirm settings are accepted.
+    server.enqueue(new MockResponse().withSettings(settings));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setBody("GHI"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+
+    Call call3 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response3 = call3.execute();
+
+    assertEquals("ABC", response1.body().string());
+    assertEquals("DEF", response2.body().string());
+    assertEquals("GHI", response3.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // Settings connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection!
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdy3Test.java
similarity index 90%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdy3Test.java
index 4020bf4c25..6f7e793165 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdy3Test.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.Protocol;
+import okhttp3.Protocol;
 
 public class HttpOverSpdy3Test extends HttpOverSpdyTest {
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java
new file mode 100644
index 0000000000..7c27cd29d7
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HttpOverSpdyTest.java
@@ -0,0 +1,615 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.framed;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.Authenticator;
+import java.net.HttpURLConnection;
+import java.net.SocketTimeoutException;
+import java.util.Arrays;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import okhttp3.Cache;
+import okhttp3.Call;
+import okhttp3.Cookie;
+import okhttp3.Credentials;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.RecordingCookieJar;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.Util;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.RecordingHostnameVerifier;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+
+/** Test how SPDY interacts with HTTP features. */
+public abstract class HttpOverSpdyTest {
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  /** Protocol to test, for example {@link Protocol#SPDY_3} */
+  private final Protocol protocol;
+  protected String hostHeader = ":host";
+
+  protected SSLContext sslContext = SslContextBuilder.localhost();
+  protected HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+  protected OkHttpClient client;
+  protected Cache cache;
+
+  protected HttpOverSpdyTest(Protocol protocol) {
+    this.protocol = protocol;
+  }
+
+  @Before public void setUp() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
+    client = new OkHttpClient.Builder()
+        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+  }
+
+  @After public void tearDown() throws Exception {
+    Authenticator.setDefault(null);
+  }
+
+  @Test public void get() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .setStatus("HTTP/1.1 200 Sweet"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals("ABCDE", response.body().string());
+    assertEquals(200, response.code());
+    assertEquals("Sweet", response.message());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(hostHeader));
+  }
+
+  @Test public void emptyResponse() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .build());
+    Response response = call.execute();
+
+    assertEquals(-1, response.body().byteStream().read());
+    response.body().close();
+  }
+
+  byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+
+  @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABCDE"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .post(new RequestBody() {
+          @Override public MediaType contentType() {
+            return MediaType.parse("text/plain; charset=utf-8");
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.write(postBytes);
+          }
+        })
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody().readByteArray());
+    assertNull(request.getHeader("Content-Length"));
+  }
+
+  @Test public void userSuppliedContentLengthHeader() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABCDE"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .post(new RequestBody() {
+          @Override public MediaType contentType() {
+            return MediaType.parse("text/plain; charset=utf-8");
+          }
+
+          @Override public long contentLength() throws IOException {
+            return postBytes.length;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.write(postBytes);
+          }
+        })
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody().readByteArray());
+    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+  }
+
+  @Test public void closeAfterFlush() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABCDE"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/foo"))
+        .post(new RequestBody() {
+          @Override public MediaType contentType() {
+            return MediaType.parse("text/plain; charset=utf-8");
+          }
+
+          @Override public long contentLength() throws IOException {
+            return postBytes.length;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.write(postBytes);  // push bytes into SpdyDataOutputStream.buffer
+            sink.flush(); // FramedConnection.writeData subject to write window
+            sink.close(); // FramedConnection.writeData empty frame
+          }
+        })
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCDE", response.body().string());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody().readByteArray());
+    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+  }
+
+  @Test public void spdyConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABCDEF"));
+    server.enqueue(new MockResponse().setBody("GHIJKL"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/r1"))
+        .build());
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/r1"))
+        .build());
+    Response response1 = call1.execute();
+    Response response2 = call2.execute();
+
+    assertEquals("ABC", response1.body().source().readUtf8(3));
+    assertEquals("GHI", response2.body().source().readUtf8(3));
+    assertEquals("DEF", response1.body().source().readUtf8(3));
+    assertEquals("JKL", response2.body().source().readUtf8(3));
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test @Ignore public void synchronousSpdyRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    server.enqueue(new MockResponse().setBody("A"));
+
+    ExecutorService executor = Executors.newCachedThreadPool();
+    CountDownLatch countDownLatch = new CountDownLatch(2);
+    executor.execute(new SpdyRequest("/r1", countDownLatch));
+    executor.execute(new SpdyRequest("/r2", countDownLatch));
+    countDownLatch.await();
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void gzippedResponseBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("ABCABCABC")));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/r1"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals("ABCABCABC", response.body().string());
+  }
+
+  @Test public void authenticate() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
+        .addHeader("www-authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate."));
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    String credential = Credentials.basic("username", "password");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential))
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("Successful auth!", response.body().string());
+
+    RecordedRequest denied = server.takeRequest();
+    assertNull(denied.getHeader("Authorization"));
+    RecordedRequest accepted = server.takeRequest();
+    assertEquals("GET / HTTP/1.1", accepted.getRequestLine());
+    assertEquals(credential, accepted.getHeader("Authorization"));
+  }
+
+  @Test public void redirect() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("This is the new location!"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals("This is the new location!", response.body().string());
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("/", request1.getPath());
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("/foo", request2.getPath());
+  }
+
+  @Test public void readAfterLastByte() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABC"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+
+    InputStream in = response.body().byteStream();
+    assertEquals('A', in.read());
+    assertEquals('B', in.read());
+    assertEquals('C', in.read());
+    assertEquals(-1, in.read());
+    assertEquals(-1, in.read());
+  }
+
+  @Ignore // See https://github.com/square/okhttp/issues/578
+  @Test(timeout = 3000) public void readResponseHeaderTimeout() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+    server.enqueue(new MockResponse().setBody("A"));
+
+    client = client.newBuilder()
+        .readTimeout(1000, MILLISECONDS)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("A", response.body().string());
+  }
+
+  /**
+   * Test to ensure we don't  throw a read timeout on responses that are progressing.  For this
+   * case, we take a 4KiB body and throttle it to 1KiB/second.  We set the read timeout to two
+   * seconds.  If our implementation is acting correctly, it will not throw, as it is progressing.
+   */
+  @Test public void readTimeoutMoreGranularThanBodySize() throws Exception {
+    char[] body = new char[4096]; // 4KiB to read.
+    Arrays.fill(body, 'y');
+    server.enqueue(new MockResponse().setBody(new String(body))
+        .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
+
+    client = client.newBuilder()
+        .readTimeout(2, SECONDS)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals(new String(body), response.body().string());
+  }
+
+  /**
+   * Test to ensure we throw a read timeout on responses that are progressing too slowly.  For this
+   * case, we take a 2KiB body and throttle it to 1KiB/second.  We set the read timeout to half a
+   * second.  If our implementation is acting correctly, it will throw, as a byte doesn't arrive in
+   * time.
+   */
+  @Test public void readTimeoutOnSlowConnection() throws Exception {
+    char[] body = new char[2048]; // 2KiB to read.
+    Arrays.fill(body, 'y');
+    server.enqueue(new MockResponse()
+        .setBody(new String(body))
+        .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
+
+    client = client.newBuilder()
+        .readTimeout(500, MILLISECONDS) // Half a second to read something.
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+
+    try {
+      response.body().string();
+      fail("Should have timed out!");
+    } catch (SocketTimeoutException expected) {
+      assertEquals("timeout", expected.getMessage());
+    }
+  }
+
+  @Test public void spdyConnectionTimeout() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .setBodyDelay(1, SECONDS));
+
+    OkHttpClient client1 = client.newBuilder()
+        .readTimeout(2000, MILLISECONDS)
+        .build();
+    Call call1 = client1
+        .newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    OkHttpClient client2 = client.newBuilder()
+        .readTimeout(200, MILLISECONDS)
+        .build();
+    Call call2 = client2
+        .newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response1 = call1.execute();
+    assertEquals("A", response1.body().string());
+
+    try {
+      call2.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void responsesAreCached() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("cache-control: max-age=60")
+        .setBody("A"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    assertEquals("A", response1.body().string());
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("A", response2.body().string());
+
+    Call call3 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response3 = call3.execute();
+    assertEquals("A", response3.body().string());
+
+    assertEquals(3, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(2, cache.hitCount());
+  }
+
+  @Test public void conditionalCache() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("A", response1.body().string());
+
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("A", response2.body().string());
+
+    assertEquals(2, cache.requestCount());
+    assertEquals(2, cache.networkCount());
+    assertEquals(1, cache.hitCount());
+  }
+
+  @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("cache-control: max-age=60")
+        .setBody("ABCD"));
+    server.enqueue(new MockResponse()
+        .addHeader("cache-control: max-age=60")
+        .setBody("EFGH"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("AB", response1.body().source().readUtf8(2));
+    response1.body().close();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("ABCD", response2.body().source().readUtf8());
+    response2.body().close();
+  }
+
+  @Test public void sendRequestCookies() throws Exception {
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    Cookie requestCookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain(server.getHostName())
+        .build();
+    cookieJar.enqueueRequestCookies(requestCookie);
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    server.enqueue(new MockResponse());
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("a=b", request.getHeader("Cookie"));
+  }
+
+  @Test public void receiveResponseCookies() throws Exception {
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    client = client.newBuilder()
+        .cookieJar(cookieJar)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .addHeader("set-cookie: a=b"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    cookieJar.assertResponseCookies("a=b; path=/");
+  }
+
+  /** https://github.com/square/okhttp/issues/1191 */
+  @Test public void cancelWithStreamNotCompleted() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+    server.enqueue(new MockResponse()
+        .setBody("def"));
+
+    // Disconnect before the stream is created. A connection is still established!
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    call1.execute();
+    call1.cancel();
+
+    // That connection is pooled, and it works.
+    assertEquals(1, client.connectionPool().connectionCount());
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("def", response2.body().string());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  public Buffer gzip(String bytes) throws IOException {
+    Buffer bytesOut = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
+    sink.writeUtf8(bytes);
+    sink.close();
+    return bytesOut;
+  }
+
+  class SpdyRequest implements Runnable {
+    String path;
+    CountDownLatch countDownLatch;
+
+    public SpdyRequest(String path, CountDownLatch countDownLatch) {
+      this.path = path;
+      this.countDownLatch = countDownLatch;
+    }
+
+    @Override public void run() {
+      try {
+        Call call = client.newCall(new Request.Builder()
+            .url(server.url(path))
+            .build());
+        Response response = call.execute();
+        assertEquals("A", response.body().string());
+        countDownLatch.countDown();
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/HuffmanTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/HuffmanTest.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/HuffmanTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/HuffmanTest.java
index eeddd3e28d..b85a1b35b7 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/HuffmanTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/HuffmanTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/MockSpdyPeer.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
similarity index 95%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/MockSpdyPeer.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
index f30d099a9f..edc8f41c30 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/MockSpdyPeer.java
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.net.InetSocketAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.ArrayList;
@@ -31,6 +31,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.logging.Logger;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -82,8 +83,8 @@ public FrameWriter sendFrame() {
   }
 
   /**
-   * Sends a manually-constructed frame. This is useful to test frames that
-   * won't be generated naturally.
+   * Sends a manually-constructed frame. This is useful to test frames that won't be generated
+   * naturally.
    */
   public void sendFrame(byte[] frame) throws IOException {
     outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
@@ -91,9 +92,9 @@ public void sendFrame(byte[] frame) throws IOException {
   }
 
   /**
-   * Shortens the last frame from its original length to {@code length}. This
-   * will cause the peer to close the socket as soon as this frame has been
-   * written; otherwise the peer stays open until explicitly closed.
+   * Shortens the last frame from its original length to {@code length}. This will cause the peer to
+   * close the socket as soon as this frame has been written; otherwise the peer stays open until
+   * explicitly closed.
    */
   public FrameWriter truncateLastFrame(int length) {
     OutFrame lastFrame = outFrames.remove(outFrames.size() - 1);
@@ -116,8 +117,9 @@ public InFrame takeFrame() throws InterruptedException {
 
   public void play() throws IOException {
     if (serverSocket != null) throw new IllegalStateException();
-    serverSocket = new ServerSocket(0);
-    serverSocket.setReuseAddress(true);
+    serverSocket = new ServerSocket();
+    serverSocket.setReuseAddress(false);
+    serverSocket.bind(new InetSocketAddress("localhost", 0), 1);
     port = serverSocket.getLocalPort();
     executor.execute(new Runnable() {
       @Override public void run() {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/SettingsTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/SettingsTest.java
similarity index 91%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/SettingsTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/SettingsTest.java
index be5f8ecd1b..9eae7f89db 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/SettingsTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/SettingsTest.java
@@ -13,17 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static com.squareup.okhttp.internal.framed.Settings.DOWNLOAD_BANDWIDTH;
-import static com.squareup.okhttp.internal.framed.Settings.DOWNLOAD_RETRANS_RATE;
-import static com.squareup.okhttp.internal.framed.Settings.MAX_CONCURRENT_STREAMS;
-import static com.squareup.okhttp.internal.framed.Settings.PERSISTED;
-import static com.squareup.okhttp.internal.framed.Settings.PERSIST_VALUE;
-import static com.squareup.okhttp.internal.framed.Settings.UPLOAD_BANDWIDTH;
+import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.framed.Settings.DOWNLOAD_BANDWIDTH;
+import static okhttp3.internal.framed.Settings.DOWNLOAD_RETRANS_RATE;
+import static okhttp3.internal.framed.Settings.MAX_CONCURRENT_STREAMS;
+import static okhttp3.internal.framed.Settings.PERSISTED;
+import static okhttp3.internal.framed.Settings.PERSIST_VALUE;
+import static okhttp3.internal.framed.Settings.UPLOAD_BANDWIDTH;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Spdy3ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
similarity index 91%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Spdy3ConnectionTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
index dc3cfdec5f..96a6fb4288 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Spdy3ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3ConnectionTest.java
@@ -13,17 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.io.InterruptedIOException;
+import java.net.Socket;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Random;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.internal.Util;
 import okio.AsyncTimeout;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -34,21 +36,26 @@
 import org.junit.After;
 import org.junit.Test;
 
-import static com.squareup.okhttp.TestUtil.headerEntries;
-import static com.squareup.okhttp.internal.framed.ErrorCode.CANCEL;
-import static com.squareup.okhttp.internal.framed.ErrorCode.INTERNAL_ERROR;
-import static com.squareup.okhttp.internal.framed.ErrorCode.INVALID_STREAM;
-import static com.squareup.okhttp.internal.framed.ErrorCode.PROTOCOL_ERROR;
-import static com.squareup.okhttp.internal.framed.ErrorCode.REFUSED_STREAM;
-import static com.squareup.okhttp.internal.framed.ErrorCode.STREAM_IN_USE;
-import static com.squareup.okhttp.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static com.squareup.okhttp.internal.framed.Settings.PERSIST_VALUE;
-import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_DATA;
-import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_GOAWAY;
-import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_HEADERS;
-import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_PING;
-import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_RST_STREAM;
-import static com.squareup.okhttp.internal.framed.Spdy3.TYPE_WINDOW_UPDATE;
+import static okhttp3.TestUtil.headerEntries;
+import static okhttp3.internal.framed.ErrorCode.CANCEL;
+import static okhttp3.internal.framed.ErrorCode.INTERNAL_ERROR;
+import static okhttp3.internal.framed.ErrorCode.INVALID_STREAM;
+import static okhttp3.internal.framed.ErrorCode.PROTOCOL_ERROR;
+import static okhttp3.internal.framed.ErrorCode.REFUSED_STREAM;
+import static okhttp3.internal.framed.ErrorCode.STREAM_IN_USE;
+import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.framed.Settings.DOWNLOAD_BANDWIDTH;
+import static okhttp3.internal.framed.Settings.DOWNLOAD_RETRANS_RATE;
+import static okhttp3.internal.framed.Settings.INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.framed.Settings.MAX_CONCURRENT_STREAMS;
+import static okhttp3.internal.framed.Settings.PERSIST_VALUE;
+import static okhttp3.internal.framed.Settings.UPLOAD_BANDWIDTH;
+import static okhttp3.internal.framed.Spdy3.TYPE_DATA;
+import static okhttp3.internal.framed.Spdy3.TYPE_GOAWAY;
+import static okhttp3.internal.framed.Spdy3.TYPE_HEADERS;
+import static okhttp3.internal.framed.Spdy3.TYPE_PING;
+import static okhttp3.internal.framed.Spdy3.TYPE_RST_STREAM;
+import static okhttp3.internal.framed.Spdy3.TYPE_WINDOW_UPDATE;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -103,7 +110,6 @@
 
     FramedConnection connection = connection(peer, SPDY3);
     FramedStream stream = connection.newStream(headerEntries("a", "android"), false, false);
-    assertEquals(1, connection.openStreamCount());
     assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that inFinished has been received.
     assertEquals(0, connection.openStreamCount());
@@ -148,15 +154,19 @@
 
     // play it back
     final AtomicInteger receiveCount = new AtomicInteger();
-    IncomingStreamHandler handler = new IncomingStreamHandler() {
-      @Override public void receive(FramedStream stream) throws IOException {
+    FramedConnection.Listener handler = new FramedConnection.Listener() {
+      @Override public void onStream(FramedStream stream) throws IOException {
         receiveCount.incrementAndGet();
         assertEquals(pushHeaders, stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
         stream.reply(headerEntries("b", "banana"), true);
       }
     };
-    new FramedConnection.Builder(true, peer.openSocket()).handler(handler).build();
+    FramedConnection connection = new FramedConnection.Builder(true)
+        .socket(peer.openSocket())
+        .listener(handler)
+        .build();
+    connection.start(false);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame reply = peer.takeFrame();
@@ -176,14 +186,17 @@
 
     // play it back
     final AtomicInteger receiveCount = new AtomicInteger();
-    IncomingStreamHandler handler = new IncomingStreamHandler() {
-      @Override public void receive(FramedStream stream) throws IOException {
+    FramedConnection.Listener listener = new FramedConnection.Listener() {
+      @Override public void onStream(FramedStream stream) throws IOException {
         stream.reply(headerEntries("b", "banana"), false);
         receiveCount.incrementAndGet();
       }
     };
 
-    connectionBuilder(peer, SPDY3).handler(handler).build();
+    FramedConnection connection = connectionBuilder(peer, SPDY3)
+        .listener(listener)
+        .build();
+    connection.start(false);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame reply = peer.takeFrame();
@@ -252,33 +265,47 @@
 
   @Test public void serverSendsSettingsToClient() throws Exception {
     // write the mocking script
-    Settings settings = new Settings();
-    settings.set(Settings.MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 10);
+    final Settings settings = new Settings();
+    settings.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 10);
     peer.sendFrame().settings(settings);
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    FramedConnection connection = connection(peer, SPDY3);
+    final AtomicInteger maxConcurrentStreams = new AtomicInteger();
+    FramedConnection.Listener listener = new FramedConnection.Listener() {
+      @Override public void onStream(FramedStream stream) throws IOException {
+        throw new AssertionError();
+      }
+
+      @Override public void onSettings(FramedConnection connection) {
+        maxConcurrentStreams.set(connection.maxConcurrentStreams());
+      }
+    };
+    FramedConnection connection = connectionBuilder(peer, SPDY3)
+        .listener(listener)
+        .build();
+    connection.start(false);
 
     peer.takeFrame(); // Guarantees that the peer Settings frame has been processed.
     synchronized (connection) {
       assertEquals(10, connection.peerSettings.getMaxConcurrentStreams(-1));
     }
+    assertEquals(10, maxConcurrentStreams.get());
   }
 
   @Test public void multipleSettingsFramesAreMerged() throws Exception {
     // write the mocking script
     Settings settings1 = new Settings();
-    settings1.set(Settings.UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
-    settings1.set(Settings.DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
-    settings1.set(Settings.DOWNLOAD_RETRANS_RATE, 0, 300);
+    settings1.set(UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
+    settings1.set(DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
+    settings1.set(DOWNLOAD_RETRANS_RATE, 0, 300);
     peer.sendFrame().settings(settings1);
     Settings settings2 = new Settings();
-    settings2.set(Settings.DOWNLOAD_BANDWIDTH, 0, 400);
-    settings2.set(Settings.DOWNLOAD_RETRANS_RATE, PERSIST_VALUE, 500);
-    settings2.set(Settings.MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
+    settings2.set(DOWNLOAD_BANDWIDTH, 0, 400);
+    settings2.set(DOWNLOAD_RETRANS_RATE, PERSIST_VALUE, 500);
+    settings2.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
     peer.sendFrame().settings(settings2);
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame();
@@ -290,22 +317,22 @@
     peer.takeFrame(); // Guarantees that the Settings frame has been processed.
     synchronized (connection) {
       assertEquals(100, connection.peerSettings.getUploadBandwidth(-1));
-      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(Settings.UPLOAD_BANDWIDTH));
+      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(UPLOAD_BANDWIDTH));
       assertEquals(400, connection.peerSettings.getDownloadBandwidth(-1));
-      assertEquals(0, connection.peerSettings.flags(Settings.DOWNLOAD_BANDWIDTH));
+      assertEquals(0, connection.peerSettings.flags(DOWNLOAD_BANDWIDTH));
       assertEquals(500, connection.peerSettings.getDownloadRetransRate(-1));
-      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(Settings.DOWNLOAD_RETRANS_RATE));
+      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(DOWNLOAD_RETRANS_RATE));
       assertEquals(600, connection.peerSettings.getMaxConcurrentStreams(-1));
-      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(Settings.MAX_CONCURRENT_STREAMS));
+      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(MAX_CONCURRENT_STREAMS));
     }
   }
 
   @Test public void clearSettingsBeforeMerge() throws Exception {
     // write the mocking script
     Settings settings1 = new Settings();
-    settings1.set(Settings.UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
-    settings1.set(Settings.DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
-    settings1.set(Settings.DOWNLOAD_RETRANS_RATE, 0, 300);
+    settings1.set(UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
+    settings1.set(DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
+    settings1.set(DOWNLOAD_RETRANS_RATE, 0, 300);
     peer.sendFrame().settings(settings1);
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame();
@@ -318,7 +345,7 @@
 
     // fake a settings frame with clear flag set.
     Settings settings2 = new Settings();
-    settings2.set(Settings.MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
+    settings2.set(MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
     connection.readerRunnable.settings(true, settings2);
 
     synchronized (connection) {
@@ -454,8 +481,7 @@
   }
 
   /**
-   * Test that the client sends a RST_STREAM if doing so won't disrupt the
-   * output stream.
+   * Test that the client sends a RST_STREAM if doing so won't disrupt the output stream.
    */
   @Test public void clientClosesClientInputStream() throws Exception {
     // write the mocking script
@@ -496,8 +522,7 @@
   }
 
   /**
-   * Test that the client doesn't send a RST_STREAM if doing so will disrupt
-   * the output stream.
+   * Test that the client doesn't send a RST_STREAM if doing so will disrupt the output stream.
    */
   @Test public void clientClosesClientInputStreamIfOutputStreamIsClosed() throws Exception {
     // write the mocking script
@@ -611,15 +636,19 @@
 
     // play it back
     final AtomicInteger receiveCount = new AtomicInteger();
-    IncomingStreamHandler handler = new IncomingStreamHandler() {
-      @Override public void receive(FramedStream stream) throws IOException {
+    FramedConnection.Listener listener = new FramedConnection.Listener() {
+      @Override public void onStream(FramedStream stream) throws IOException {
         receiveCount.incrementAndGet();
         assertEquals(headerEntries("a", "android"), stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
         stream.reply(headerEntries("c", "cola"), true);
       }
     };
-    new FramedConnection.Builder(true, peer.openSocket()).handler(handler).build();
+    FramedConnection connection = new FramedConnection.Builder(true)
+        .socket(peer.openSocket())
+        .listener(listener)
+        .build();
+    connection.start(false);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame reply = peer.takeFrame();
@@ -924,7 +953,7 @@
 
   @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
     // Set the peer's receive window to 5 bytes!
-    Settings peerSettings = new Settings().set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
+    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
 
     // write the mocking script
     peer.sendFrame().settings(peerSettings);
@@ -965,7 +994,7 @@
   @Test public void writeTimesOutAwaitingConnectionWindow() throws Exception {
     // Set the peer's receive window to 5 bytes. Give the stream 5 bytes back, so only the
     // connection-level window is applicable.
-    Settings peerSettings = new Settings().set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
+    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
 
     // write the mocking script
     peer.sendFrame().settings(peerSettings);
@@ -1104,7 +1133,7 @@
 
     // Play it back.
     FramedConnection connection = connection(peer, SPDY3);
-    connection.okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, windowSize);
+    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, 0, windowSize);
     FramedStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(0, stream.unacknowledgedBytesRead);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
@@ -1307,13 +1336,46 @@ private void headerBlockHasTrailingCompressedBytes(String frame, int length) thr
     assertStreamData("robot", stream.getSource());
   }
 
+  @Test public void socketExceptionWhileWritingHeaders() throws Exception {
+    peer.acceptFrame(); // SYN_STREAM.
+    peer.play();
+
+    String longString = ByteString.of(randomBytes(2048)).base64();
+    Socket socket = peer.openSocket();
+    FramedConnection connection = new FramedConnection.Builder(true)
+        .socket(socket)
+        .protocol(SPDY3.getProtocol())
+        .build();
+    connection.start(false);
+    socket.shutdownOutput();
+    try {
+      connection.newStream(headerEntries("a", longString), false, true);
+      fail();
+    } catch (IOException expected) {
+    }
+    try {
+      connection.newStream(headerEntries("b", longString), false, true);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  private byte[] randomBytes(int length) {
+    byte[] bytes = new byte[length];
+    new Random(0).nextBytes(bytes);
+    return bytes;
+  }
+
   private FramedConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
-    return connectionBuilder(peer, variant).build();
+    FramedConnection connection = connectionBuilder(peer, variant).build();
+    connection.start(false);
+    return connection;
   }
 
   private FramedConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
       throws IOException {
-    return new FramedConnection.Builder(true, peer.openSocket())
+    return new FramedConnection.Builder(true)
+        .socket(peer.openSocket())
         .protocol(variant.getProtocol());
   }
 
@@ -1322,15 +1384,6 @@ private void assertStreamData(String expected, Source source) throws IOException
     assertEquals(expected, actual);
   }
 
-  private void assertFlushBlocks(BufferedSink out) throws IOException {
-    interruptAfterDelay(500);
-    try {
-      out.flush();
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-  }
-
   /** Interrupts the current thread after {@code delayMillis}. */
   private void interruptAfterDelay(final long delayMillis) {
     final Thread toInterrupt = Thread.currentThread();
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Spdy3Test.java b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Spdy3Test.java
rename to okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java
index 2627959fe0..953009ffc1 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/framed/Spdy3Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/framed/Spdy3Test.java
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.ByteString;
 import org.junit.Test;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java
new file mode 100644
index 0000000000..bf01f36fac
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/CookiesTest.java
@@ -0,0 +1,294 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.net.CookieHandler;
+import java.net.CookieManager;
+import java.net.HttpCookie;
+import java.net.HttpURLConnection;
+import java.net.InetAddress;
+import java.net.URI;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import okhttp3.Call;
+import okhttp3.HttpUrl;
+import okhttp3.JavaNetCookieJar;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import org.junit.Test;
+
+import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/** Derived from Android's CookiesTest. */
+public class CookiesTest {
+  private OkHttpClient client = defaultClient();
+
+  @Test
+  public void testNetscapeResponse() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+    MockWebServer server = new MockWebServer();
+    server.start();
+
+    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
+    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
+        + "expires=Fri, 31-Dec-9999 23:59:59 GMT; "
+        + "path=/path; "
+        + "domain=" + urlWithIpAddress.host() + "; "
+        + "secure"));
+    get(urlWithIpAddress);
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals(null, cookie.getComment());
+    assertEquals(null, cookie.getCommentURL());
+    assertEquals(false, cookie.getDiscard());
+    assertTrue(cookie.getMaxAge() > 100000000000L);
+    assertEquals("/path", cookie.getPath());
+    assertEquals(true, cookie.getSecure());
+    assertEquals(0, cookie.getVersion());
+  }
+
+  @Test public void testRfc2109Response() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+    MockWebServer server = new MockWebServer();
+    server.start();
+
+    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
+    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
+        + "Comment=this cookie is delicious; "
+        + "Domain=" + urlWithIpAddress.host() + "; "
+        + "Max-Age=60; "
+        + "Path=/path; "
+        + "Secure; "
+        + "Version=1"));
+    get(urlWithIpAddress);
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals(null, cookie.getCommentURL());
+    assertEquals(false, cookie.getDiscard());
+    assertEquals(60.0, cookie.getMaxAge(), 1.0); // Converting to a fixed date can cause rounding!
+    assertEquals("/path", cookie.getPath());
+    assertEquals(true, cookie.getSecure());
+  }
+
+  @Test public void testQuotedAttributeValues() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+    MockWebServer server = new MockWebServer();
+    server.start();
+
+    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
+    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=\"android\"; "
+        + "Comment=\"this cookie is delicious\"; "
+        + "CommentURL=\"http://google.com/\"; "
+        + "Discard; "
+        + "Domain=" + urlWithIpAddress.host() + "; "
+        + "Max-Age=60; "
+        + "Path=\"/path\"; "
+        + "Port=\"80,443," + server.getPort() + "\"; "
+        + "Secure; "
+        + "Version=\"1\""));
+    get(urlWithIpAddress);
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals(60.0, cookie.getMaxAge(), 1.0); // Converting to a fixed date can cause rounding!
+    assertEquals("/path", cookie.getPath());
+    assertEquals(true, cookie.getSecure());
+  }
+
+  @Test public void testSendingCookiesFromStore() throws Exception {
+    MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse());
+    server.start();
+    HttpUrl serverUrl = urlWithIpAddress(server, "/");
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    HttpCookie cookieA = new HttpCookie("a", "android");
+    cookieA.setDomain(serverUrl.host());
+    cookieA.setPath("/");
+    cookieManager.getCookieStore().add(serverUrl.uri(), cookieA);
+    HttpCookie cookieB = new HttpCookie("b", "banana");
+    cookieB.setDomain(serverUrl.host());
+    cookieB.setPath("/");
+    cookieManager.getCookieStore().add(serverUrl.uri(), cookieB);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+
+    get(serverUrl);
+    RecordedRequest request = server.takeRequest();
+
+    assertEquals("a=android; b=banana", request.getHeader("Cookie"));
+  }
+
+  @Test public void cookieHandlerLikeAndroid() throws Exception {
+    final MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse());
+    server.start();
+    final HttpUrl serverUrl = urlWithIpAddress(server, "/");
+
+    CookieHandler androidCookieHandler = new CookieHandler() {
+      @Override public Map<String, List<String>> get(URI uri, Map<String, List<String>> map)
+          throws IOException {
+        return Collections.singletonMap("Cookie", Collections.singletonList("$Version=\"1\"; "
+            + "a=\"android\";$Path=\"/\";$Domain=\"" + serverUrl.host() + "\"; "
+            + "b=\"banana\";$Path=\"/\";$Domain=\"" + serverUrl.host() + "\""));
+      }
+
+      @Override public void put(URI uri, Map<String, List<String>> map) throws IOException {
+      }
+    };
+
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(androidCookieHandler))
+        .build();
+
+    get(serverUrl);
+    RecordedRequest request = server.takeRequest();
+
+    assertEquals("a=android; b=banana", request.getHeader("Cookie"));
+  }
+
+  @Test public void receiveAndSendMultipleCookies() throws Exception {
+    MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie", "a=android")
+        .addHeader("Set-Cookie", "b=banana"));
+    server.enqueue(new MockResponse());
+    server.start();
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+
+    get(urlWithIpAddress(server, "/"));
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("Cookie"));
+
+    get(urlWithIpAddress(server, "/"));
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("a=android; b=banana", request2.getHeader("Cookie"));
+  }
+
+  @Test public void testRedirectsDoNotIncludeTooManyCookies() throws Exception {
+    MockWebServer redirectTarget = new MockWebServer();
+    redirectTarget.enqueue(new MockResponse().setBody("A"));
+    redirectTarget.start();
+    HttpUrl redirectTargetUrl = urlWithIpAddress(redirectTarget, "/");
+
+    MockWebServer redirectSource = new MockWebServer();
+    redirectSource.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + redirectTargetUrl));
+    redirectSource.start();
+    HttpUrl redirectSourceUrl = urlWithIpAddress(redirectSource, "/");
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    HttpCookie cookie = new HttpCookie("c", "cookie");
+    cookie.setDomain(redirectSourceUrl.host());
+    cookie.setPath("/");
+    String portList = Integer.toString(redirectSource.getPort());
+    cookie.setPortlist(portList);
+    cookieManager.getCookieStore().add(redirectSourceUrl.uri(), cookie);
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build();
+
+    get(redirectSourceUrl);
+    RecordedRequest request = redirectSource.takeRequest();
+
+    assertEquals("c=cookie", request.getHeader("Cookie"));
+
+    for (String header : redirectTarget.takeRequest().getHeaders().names()) {
+      if (header.startsWith("Cookie")) {
+        fail(header);
+      }
+    }
+  }
+
+  @Test public void testCookiesSentIgnoresCase() throws Exception {
+    client = client.newBuilder()
+        .cookieJar(new JavaNetCookieJar(new CookieManager() {
+          @Override public Map<String, List<String>> get(URI uri,
+              Map<String, List<String>> requestHeaders) throws IOException {
+            Map<String, List<String>> result = new HashMap<>();
+            result.put("COOKIE", Collections.singletonList("Bar=bar"));
+            result.put("cooKIE2", Collections.singletonList("Baz=baz"));
+            return result;
+          }
+        }))
+        .build();
+
+    MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse());
+    server.start();
+
+    get(server.url("/"));
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("Bar=bar; Baz=baz", request.getHeader("Cookie"));
+    assertNull(request.getHeader("Cookie2"));
+    assertNull(request.getHeader("Quux"));
+  }
+
+  private HttpUrl urlWithIpAddress(MockWebServer server, String path) throws Exception {
+    return server.url(path)
+        .newBuilder()
+        .host(InetAddress.getByName(server.getHostName()).getHostAddress())
+        .build();
+  }
+
+  private void get(HttpUrl url) throws Exception {
+    Call call = client.newCall(new Request.Builder()
+        .url(url)
+        .build());
+    Response response = call.execute();
+    response.body().close();
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
similarity index 80%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
index 7a70d03e34..eb85913192 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
@@ -13,14 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.DelegatingServerSocketFactory;
-import com.squareup.okhttp.DelegatingSocketFactory;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
+package okhttp3.internal.http;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -28,14 +22,18 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.concurrent.TimeUnit;
-
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import okhttp3.DelegatingServerSocketFactory;
+import okhttp3.DelegatingSocketFactory;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import okio.Buffer;
 import org.junit.Before;
 import org.junit.Test;
 
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-
 import static org.junit.Assert.fail;
 
 public final class DisconnectTest {
@@ -47,25 +45,26 @@
   private OkHttpClient client;
 
   @Before public void setUp() throws Exception {
-    server = new MockWebServer();
-    client = new OkHttpClient();
-
     // Sockets on some platforms can have large buffers that mean writes do not block when
     // required. These socket factories explicitly set the buffer sizes on sockets created.
+    server = new MockWebServer();
     server.setServerSocketFactory(
         new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
-          @Override
-          protected void configureServerSocket(ServerSocket serverSocket) throws IOException {
+          @Override protected ServerSocket configureServerSocket(
+              ServerSocket serverSocket) throws IOException {
             serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return serverSocket;
           }
         });
-    client.setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-      @Override
-      protected void configureSocket(Socket socket) throws IOException {
-        socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-        socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-      }
-    });
+    client = new OkHttpClient.Builder()
+        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+          @Override protected Socket configureSocket(Socket socket) throws IOException {
+            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return socket;
+          }
+        })
+        .build();
   }
 
   @Test public void interruptWritingRequestBody() throws Exception {
@@ -75,7 +74,7 @@ protected void configureSocket(Socket socket) throws IOException {
         .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
     server.start();
 
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
     disconnectLater(connection, 500);
 
     connection.setDoOutput(true);
@@ -102,7 +101,7 @@ protected void configureSocket(Socket socket) throws IOException {
         .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
     server.start();
 
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
     disconnectLater(connection, 500);
 
     InputStream responseBody = connection.getInputStream();
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
new file mode 100644
index 0000000000..73f9471fac
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.internal.http;
+
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Util;
+
+public final class ExternalHttp2Example {
+  public static void main(String[] args) throws Exception {
+    OkHttpClient client = new OkHttpClient.Builder()
+        .protocols(Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1))
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("https://www.google.ca/")
+        .build());
+
+    Response response = call.execute();
+    try {
+      System.out.println(response.code());
+      System.out.println("PROTOCOL " + response.protocol());
+
+      String line;
+      while ((line = response.body().source().readUtf8Line()) != null) {
+        System.out.println(line);
+      }
+    } finally {
+      response.body().close();
+    }
+
+    client.connectionPool().evictAll();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java
new file mode 100644
index 0000000000..c1598480ec
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalSpdyExample.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.internal.http;
+
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Util;
+
+public final class ExternalSpdyExample {
+  public static void main(String[] args) throws Exception {
+    OkHttpClient client = new OkHttpClient.Builder()
+        .protocols(Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1))
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("https://www.google.ca/")
+        .build());
+
+    Response response = call.execute();
+    try {
+      System.out.println(response.code());
+      System.out.println("PROTOCOL " + response.protocol());
+
+      String line;
+      while ((line = response.body().source().readUtf8Line()) != null) {
+        System.out.println(line);
+      }
+    } finally {
+      response.body().close();
+    }
+
+    client.connectionPool().evictAll();
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java
similarity index 66%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java
index 1f5ad6d002..84f37d13a3 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/HeadersTest.java
@@ -13,25 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.framed.Header;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-
+import okhttp3.Headers;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.framed.Header;
+import org.junit.Assert;
 import org.junit.Test;
 
-import static com.squareup.okhttp.TestUtil.headerEntries;
+import static okhttp3.TestUtil.headerEntries;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class HeadersTest {
@@ -42,24 +44,20 @@
         ":status", "200 OK",
         ":version", "HTTP/1.1");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response =
-        FramedTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
+    Response response = Http2xStream.readSpdy3HeadersList(headerBlock).request(request).build();
     Headers headers = response.headers();
-    assertEquals(4, headers.size());
-    assertEquals(Protocol.SPDY_3, response.protocol());
+    assertEquals(3, headers.size());
+    Assert.assertEquals(Protocol.SPDY_3, response.protocol());
     assertEquals(200, response.code());
     assertEquals("OK", response.message());
     assertEquals("no-cache, no-store", headers.get("cache-control"));
     assertEquals("Cookie2", headers.get("set-cookie"));
-    assertEquals(Protocol.SPDY_3.toString(), headers.get(OkHeaders.SELECTED_PROTOCOL));
-    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(0));
-    assertEquals(Protocol.SPDY_3.toString(), headers.value(0));
-    assertEquals("cache-control", headers.name(1));
-    assertEquals("no-cache, no-store", headers.value(1));
+    assertEquals("cache-control", headers.name(0));
+    assertEquals("no-cache, no-store", headers.value(0));
+    assertEquals("set-cookie", headers.name(1));
+    assertEquals("Cookie1", headers.value(1));
     assertEquals("set-cookie", headers.name(2));
-    assertEquals("Cookie1", headers.value(2));
-    assertEquals("set-cookie", headers.name(3));
-    assertEquals("Cookie2", headers.value(3));
+    assertEquals("Cookie2", headers.value(2));
     assertNull(headers.get(":status"));
     assertNull(headers.get(":version"));
   }
@@ -70,12 +68,9 @@
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response =
-        FramedTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
+    Response response = Http2xStream.readSpdy3HeadersList(headerBlock).request(request).build();
     Headers headers = response.headers();
-    assertEquals(1, headers.size());
-    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(0));
-    assertEquals(Protocol.SPDY_3.toString(), headers.value(0));
+    assertEquals(0, headers.size());
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
@@ -84,15 +79,14 @@
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = FramedTransport.readNameValueBlock(headerBlock, Protocol.HTTP_2)
-        .request(request).build();
+    Response response = Http2xStream.readHttp2HeadersList(headerBlock).request(request).build();
     Headers headers = response.headers();
     assertEquals(1, headers.size());
-    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(0));
-    assertEquals(Protocol.HTTP_2.toString(), headers.value(0));
+    assertEquals(":version", headers.name(0));
+    assertEquals("HTTP/1.1", headers.value(0));
   }
 
-  @Test public void toNameValueBlock() {
+  @Test public void spdy3HeadersList() {
     Request request = new Request.Builder()
         .url("http://square.com/")
         .header("cache-control", "no-cache, no-store")
@@ -100,8 +94,7 @@
         .addHeader("set-cookie", "Cookie2")
         .header(":status", "200 OK")
         .build();
-    List<Header> headerBlock =
-        FramedTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1");
+    List<Header> headerBlock = Http2xStream.spdy3HeadersList(request);
     List<Header> expected = headerEntries(
         ":method", "GET",
         ":path", "/",
@@ -114,7 +107,7 @@
     assertEquals(expected, headerBlock);
   }
 
-  @Test public void toNameValueBlockDropsForbiddenHeadersSpdy3() {
+  @Test public void spdy3HeadersListDropsForbiddenHeadersSpdy3() {
     Request request = new Request.Builder()
         .url("http://square.com/")
         .header("Connection", "close")
@@ -126,10 +119,10 @@
         ":version", "HTTP/1.1",
         ":host", "square.com",
         ":scheme", "http");
-    assertEquals(expected, FramedTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1"));
+    assertEquals(expected, Http2xStream.spdy3HeadersList(request));
   }
 
-  @Test public void toNameValueBlockDropsForbiddenHeadersHttp2() {
+  @Test public void http2HeadersListDropsForbiddenHeadersHttp2() {
     Request request = new Request.Builder()
         .url("http://square.com/")
         .header("Connection", "upgrade")
@@ -140,8 +133,7 @@
         ":path", "/",
         ":authority", "square.com",
         ":scheme", "http");
-    assertEquals(expected,
-        FramedTransport.writeNameValueBlock(request, Protocol.HTTP_2, "HTTP/1.1"));
+    assertEquals(expected, Http2xStream.http2HeadersList(request));
   }
 
   @Test public void ofTrims() {
@@ -312,4 +304,92 @@
     assertEquals(2, headerMap.get("cache-control").size());
     assertEquals(1, headerMap.get("user-agent").size());
   }
+
+  @Test public void toMultimapUsesCanonicalCase() {
+    Headers headers = Headers.of(
+        "cache-control", "no-store",
+        "Cache-Control", "no-cache",
+        "User-Agent", "OkHttp");
+    Map<String, List<String>> headerMap = headers.toMultimap();
+    assertEquals(2, headerMap.get("cache-control").size());
+    assertEquals(1, headerMap.get("user-agent").size());
+  }
+
+  @Test public void nameIndexesAreStrict() {
+    Headers headers = Headers.of("a", "b", "c", "d");
+    try {
+      headers.name(-1);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+    assertEquals("a", headers.name(0));
+    assertEquals("c", headers.name(1));
+    try {
+      headers.name(2);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void valueIndexesAreStrict() {
+    Headers headers = Headers.of("a", "b", "c", "d");
+    try {
+      headers.value(-1);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+    assertEquals("b", headers.value(0));
+    assertEquals("d", headers.value(1));
+    try {
+      headers.value(2);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void builderRejectsUnicodeInHeaderName() {
+    try {
+      new Headers.Builder().add("héader1", "value1");
+      fail("Should have complained about invalid name");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 1 in header name: héader1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void builderRejectsUnicodeInHeaderValue() {
+    try {
+      new Headers.Builder().add("header1", "valué1");
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 4 in header1 value: valué1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void headersEquals() {
+    Headers headers1 = new Headers.Builder()
+        .add("Connection", "close")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    Headers headers2 = new Headers.Builder()
+        .add("Connection", "close")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    assertTrue(headers1.equals(headers2));
+    assertEquals(headers1.hashCode(), headers2.hashCode());
+  }
+
+  @Test public void headersNotEquals() {
+    Headers headers1 = new Headers.Builder()
+        .add("Connection", "close")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    Headers headers2 = new Headers.Builder()
+        .add("Connection", "keep-alive")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    assertFalse(headers1.equals(headers2));
+    assertFalse(headers1.hashCode() == headers2.hashCode());
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpDateTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
similarity index 98%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpDateTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
index 2181774f43..0a22eb0f8a 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpDateTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
@@ -13,15 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
+import java.util.Date;
+import java.util.TimeZone;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.Date;
-import java.util.TimeZone;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RecordingProxySelector.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
similarity index 81%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RecordingProxySelector.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
index ed9cfa4ba9..33a51500e0 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RecordingProxySelector.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
@@ -24,13 +24,14 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import okhttp3.internal.Util;
 
 import static org.junit.Assert.assertEquals;
 
 public final class RecordingProxySelector extends ProxySelector {
-  final List<URI> requestedUris = new ArrayList<>();
-  List<Proxy> proxies = new ArrayList<>();
-  final List<String> failures = new ArrayList<>();
+  public final List<Proxy> proxies = new ArrayList<>();
+  public final List<URI> requestedUris = new ArrayList<>();
+  public final List<String> failures = new ArrayList<>();
 
   @Override public List<Proxy> select(URI uri) {
     requestedUris.add(uri);
@@ -45,7 +46,7 @@ public void assertRequests(URI... expectedUris) {
   @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
     InetSocketAddress socketAddress = (InetSocketAddress) sa;
     failures.add(
-        String.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
+        Util.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
             ioe.getMessage()));
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteExceptionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RouteExceptionTest.java
similarity index 97%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteExceptionTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http/RouteExceptionTest.java
index eeb95642cf..1a0c2d8f02 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteExceptionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RouteExceptionTest.java
@@ -13,11 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
-
-import org.junit.Test;
+package okhttp3.internal.http;
 
 import java.io.IOException;
+import org.junit.Test;
 
 import static org.junit.Assert.assertSame;
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
similarity index 51%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
index bb8d0821a6..7f0b47037d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
@@ -13,24 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Address;
-import com.squareup.okhttp.Authenticator;
-import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.ConnectionSpec;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Route;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.Network;
-import com.squareup.okhttp.internal.RouteDatabase;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
+package okhttp3.internal.http;
+
+import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
 import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -41,6 +32,15 @@
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Address;
+import okhttp3.Authenticator;
+import okhttp3.ConnectionSpec;
+import okhttp3.FakeDns;
+import okhttp3.Protocol;
+import okhttp3.Route;
+import okhttp3.internal.RouteDatabase;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.Util;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -57,14 +57,14 @@
       ConnectionSpec.CLEARTEXT);
 
   private static final int proxyAPort = 1001;
-  private static final String proxyAHost = "proxyA";
+  private static final String proxyAHost = "proxya";
   private static final Proxy proxyA =
-      new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyAHost, proxyAPort));
+      new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(proxyAHost, proxyAPort));
   private static final int proxyBPort = 1002;
-  private static final String proxyBHost = "proxyB";
+  private static final String proxyBHost = "proxyb";
   private static final Proxy proxyB =
-      new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyBHost, proxyBPort));
-  private String uriHost = "hostA";
+      new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(proxyBHost, proxyBPort));
+  private String uriHost = "hosta";
   private int uriPort = 1003;
 
   private SocketFactory socketFactory;
@@ -72,47 +72,24 @@
   private final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
   private HostnameVerifier hostnameVerifier;
 
-  private final Authenticator authenticator = AuthenticatorAdapter.INSTANCE;
+  private final Authenticator authenticator = Authenticator.NONE;
   private final List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
   private final FakeDns dns = new FakeDns();
   private final RecordingProxySelector proxySelector = new RecordingProxySelector();
-  private OkHttpClient client;
-  private RouteDatabase routeDatabase;
-  private Request httpRequest;
-  private Request httpsRequest;
+  private RouteDatabase routeDatabase = new RouteDatabase();
 
   @Before public void setUp() throws Exception {
     socketFactory = SocketFactory.getDefault();
     hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
-
-    client = new OkHttpClient()
-        .setAuthenticator(authenticator)
-        .setProxySelector(proxySelector)
-        .setSocketFactory(socketFactory)
-        .setSslSocketFactory(sslSocketFactory)
-        .setHostnameVerifier(hostnameVerifier)
-        .setProtocols(protocols)
-        .setConnectionSpecs(connectionSpecs)
-        .setConnectionPool(ConnectionPool.getDefault());
-    Internal.instance.setNetwork(client, dns);
-
-    routeDatabase = Internal.instance.routeDatabase(client);
-
-    httpRequest = new Request.Builder()
-        .url("http://" + uriHost + ":" + uriPort + "/path")
-        .build();
-    httpsRequest = new Request.Builder()
-        .url("https://" + uriHost + ":" + uriPort + "/path")
-        .build();
   }
 
   @Test public void singleRoute() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
 
     assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
+    dns.addresses(makeFakeAddresses(255, 1));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -125,14 +102,14 @@
 
   @Test public void singleRouteReturnsFailedRoute() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
 
     assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
+    dns.addresses(makeFakeAddresses(255, 1));
     Route route = routeSelector.next();
     routeDatabase.failed(route);
-    routeSelector = RouteSelector.get(address, httpRequest, client);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
+    routeSelector = new RouteSelector(address, routeDatabase);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
     assertFalse(routeSelector.hasNext());
     try {
       routeSelector.next();
@@ -142,15 +119,14 @@
   }
 
   @Test public void explicitProxyTriesThatProxysAddressesOnly() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, null, null, null, authenticator,
-        proxyA, protocols, connectionSpecs, proxySelector);
-    client.setProxy(proxyA);
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
+    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
+        authenticator, proxyA, protocols, connectionSpecs, proxySelector);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
 
     assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort);
+    dns.addresses(makeFakeAddresses(255, 2));
+    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
+    assertRoute(routeSelector.next(), address, proxyA, dns.address(1), proxyAPort);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(proxyAHost);
@@ -158,15 +134,14 @@
   }
 
   @Test public void explicitDirectProxy() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, null, null, null, authenticator,
-        NO_PROXY, protocols, connectionSpecs, proxySelector);
-    client.setProxy(NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
+    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
+        authenticator, NO_PROXY, protocols, connectionSpecs, proxySelector);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
 
     assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1], uriPort);
+    dns.addresses(makeFakeAddresses(255, 2));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(1), uriPort);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(uriHost);
@@ -174,15 +149,24 @@
   }
 
   @Test public void proxySelectorReturnsNull() throws Exception {
-    Address address = httpAddress();
+    ProxySelector nullProxySelector = new ProxySelector() {
+      @Override public List<Proxy> select(URI uri) {
+        assertEquals(uriHost, uri.getHost());
+        return null;
+      }
 
-    proxySelector.proxies = null;
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
-    proxySelector.assertRequests(httpRequest.uri());
+      @Override public void connectFailed(
+          URI uri, SocketAddress socketAddress, IOException e) {
+        throw new AssertionError();
+      }
+    };
 
+    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, nullProxySelector);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
     assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
+    dns.addresses(makeFakeAddresses(255, 1));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -190,16 +174,16 @@
 
   @Test public void proxySelectorReturnsNoProxies() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
 
     assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1], uriPort);
+    dns.addresses(makeFakeAddresses(255, 2));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(1), uriPort);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(uriHost);
-    proxySelector.assertRequests(httpRequest.uri());
+    proxySelector.assertRequests(address.url().uri());
   }
 
   @Test public void proxySelectorReturnsMultipleProxies() throws Exception {
@@ -207,26 +191,26 @@
 
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
-    proxySelector.assertRequests(httpRequest.uri());
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    proxySelector.assertRequests(address.url().uri());
 
     // First try the IP addresses of the first proxy, in sequence.
     assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort);
+    dns.addresses(makeFakeAddresses(255, 2));
+    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
+    assertRoute(routeSelector.next(), address, proxyA, dns.address(1), proxyAPort);
     dns.assertRequests(proxyAHost);
 
     // Next try the IP address of the second proxy.
     assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0], proxyBPort);
+    dns.addresses(makeFakeAddresses(254, 1));
+    assertRoute(routeSelector.next(), address, proxyB, dns.address(0), proxyBPort);
     dns.assertRequests(proxyBHost);
 
     // Finally try the only IP address of the origin server.
     assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(253, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
+    dns.addresses(makeFakeAddresses(253, 1));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -236,13 +220,13 @@
     Address address = httpAddress();
 
     proxySelector.proxies.add(NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
-    proxySelector.assertRequests(httpRequest.uri());
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    proxySelector.assertRequests(address.url().uri());
 
     // Only the origin server will be attempted.
     assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
+    dns.addresses(makeFakeAddresses(255, 1));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -254,16 +238,16 @@
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
     proxySelector.proxies.add(proxyA);
-    RouteSelector routeSelector = RouteSelector.get(address, httpRequest, client);
-    proxySelector.assertRequests(httpRequest.uri());
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    proxySelector.assertRequests(address.url().uri());
 
     assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
+    dns.addresses(makeFakeAddresses(255, 1));
+    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
     dns.assertRequests(proxyAHost);
 
     assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = null;
+    dns.unknownHost();
     try {
       routeSelector.next();
       fail();
@@ -272,13 +256,13 @@
     dns.assertRequests(proxyBHost);
 
     assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
+    dns.addresses(makeFakeAddresses(255, 1));
+    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
     dns.assertRequests(proxyAHost);
 
     assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
+    dns.addresses(makeFakeAddresses(254, 1));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
@@ -288,36 +272,35 @@
     Address address = httpsAddress();
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
 
     // Proxy A
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[0], proxyAPort);
+    dns.addresses(makeFakeAddresses(255, 2));
+    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
     dns.assertRequests(proxyAHost);
-    assertRoute(routeSelector.next(), address, proxyA, dns.inetAddresses[1], proxyAPort);
+    assertRoute(routeSelector.next(), address, proxyA, dns.address(1), proxyAPort);
 
     // Proxy B
-    dns.inetAddresses = makeFakeAddresses(254, 2);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[0], proxyBPort);
+    dns.addresses(makeFakeAddresses(254, 2));
+    assertRoute(routeSelector.next(), address, proxyB, dns.address(0), proxyBPort);
     dns.assertRequests(proxyBHost);
-    assertRoute(routeSelector.next(), address, proxyB, dns.inetAddresses[1], proxyBPort);
+    assertRoute(routeSelector.next(), address, proxyB, dns.address(1), proxyBPort);
 
     // Origin
-    dns.inetAddresses = makeFakeAddresses(253, 2);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[0], uriPort);
+    dns.addresses(makeFakeAddresses(253, 2));
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
     dns.assertRequests(uriHost);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.inetAddresses[1], uriPort);
+    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(1), uriPort);
 
     assertFalse(routeSelector.hasNext());
   }
 
   @Test public void failedRoutesAreLast() throws Exception {
     Address address = httpsAddress();
-    client.setProxy(Proxy.NO_PROXY);
-    RouteSelector routeSelector = RouteSelector.get(address, httpsRequest, client);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
 
     final int numberOfAddresses = 2;
-    dns.inetAddresses = makeFakeAddresses(255, numberOfAddresses);
+    dns.addresses(makeFakeAddresses(255, numberOfAddresses));
 
     // Extract the regular sequence of routes from selector.
     List<Route> regularRoutes = new ArrayList<>();
@@ -330,7 +313,7 @@
     // Add first regular route as failed.
     routeDatabase.failed(regularRoutes.get(0));
     // Reset selector
-    routeSelector = RouteSelector.get(address, httpsRequest, client);
+    routeSelector = new RouteSelector(address, routeDatabase);
 
     List<Route> routesWithFailedRoute = new ArrayList<>();
     while (routeSelector.hasNext()) {
@@ -353,58 +336,42 @@
     socketAddress = new InetSocketAddress(InetAddress.getByName("localhost"), 1234);
     assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
     socketAddress = new InetSocketAddress(
-        InetAddress.getByAddress(new byte[] { 127, 0, 0, 1 }), 1234);
+        InetAddress.getByAddress(new byte[] {127, 0, 0, 1}), 1234);
     assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
     socketAddress = new InetSocketAddress(
-        InetAddress.getByAddress("foobar", new byte[] { 127, 0, 0, 1 }), 1234);
+        InetAddress.getByAddress("foobar", new byte[] {127, 0, 0, 1}), 1234);
     assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
   }
 
   private void assertRoute(Route route, Address address, Proxy proxy, InetAddress socketAddress,
       int socketPort) {
-    assertEquals(address, route.getAddress());
-    assertEquals(proxy, route.getProxy());
-    assertEquals(socketAddress, route.getSocketAddress().getAddress());
-    assertEquals(socketPort, route.getSocketAddress().getPort());
+    assertEquals(address, route.address());
+    assertEquals(proxy, route.proxy());
+    assertEquals(socketAddress, route.socketAddress().getAddress());
+    assertEquals(socketPort, route.socketAddress().getPort());
   }
 
   /** Returns an address that's without an SSL socket factory or hostname verifier. */
   private Address httpAddress() {
-    return new Address(uriHost, uriPort, socketFactory, null, null, null, authenticator, null,
+    return new Address(uriHost, uriPort, dns, socketFactory, null, null, null, authenticator, null,
         protocols, connectionSpecs, proxySelector);
   }
 
   private Address httpsAddress() {
-    return new Address(uriHost, uriPort, socketFactory, sslSocketFactory,
+    return new Address(uriHost, uriPort, dns, socketFactory, sslSocketFactory,
         hostnameVerifier, null, authenticator, null, protocols, connectionSpecs, proxySelector);
   }
 
-  private static InetAddress[] makeFakeAddresses(int prefix, int count) {
+  private static List<InetAddress> makeFakeAddresses(int prefix, int count) {
     try {
-      InetAddress[] result = new InetAddress[count];
+      List<InetAddress> result = new ArrayList<>();
       for (int i = 0; i < count; i++) {
-        result[i] =
-            InetAddress.getByAddress(new byte[] { (byte) prefix, (byte) 0, (byte) 0, (byte) i });
+        result.add(InetAddress.getByAddress(
+            new byte[] {(byte) prefix, (byte) 0, (byte) 0, (byte) i}));
       }
       return result;
     } catch (UnknownHostException e) {
       throw new AssertionError();
     }
   }
-
-  private static class FakeDns implements Network {
-    List<String> requestedHosts = new ArrayList<>();
-    InetAddress[] inetAddresses;
-
-    @Override public InetAddress[] resolveInetAddresses(String host) throws UnknownHostException {
-      requestedHosts.add(host);
-      if (inetAddresses == null) throw new UnknownHostException();
-      return inetAddresses;
-    }
-
-    public void assertRequests(String... expectedHosts) {
-      assertEquals(Arrays.asList(expectedHosts), requestedHosts);
-      requestedHosts.clear();
-    }
-  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
similarity index 94%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
index f339f9ebe6..6eb1aa8b12 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
-import com.squareup.okhttp.Protocol;
 import java.io.IOException;
 import java.net.ProtocolException;
+import okhttp3.Protocol;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -44,9 +44,8 @@
   }
 
   /**
-   * This is not defined in the protocol but some servers won't add the leading
-   * empty space when the message is empty.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
+   * This is not defined in the protocol but some servers won't add the leading empty space when the
+   * message is empty. http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
    */
   @Test public void emptyMessageAndNoLeadingSpace() throws IOException {
     int version = 1;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
similarity index 80%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
index 63f55e1f18..47f4f0fc6b 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
@@ -13,14 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.DelegatingServerSocketFactory;
-import com.squareup.okhttp.DelegatingSocketFactory;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
+package okhttp3.internal.http;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -30,14 +23,18 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.concurrent.TimeUnit;
-
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import okhttp3.DelegatingServerSocketFactory;
+import okhttp3.DelegatingSocketFactory;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import okio.Buffer;
 import org.junit.Before;
 import org.junit.Test;
 
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-
 import static org.junit.Assert.fail;
 
 public final class ThreadInterruptTest {
@@ -49,25 +46,28 @@
   private OkHttpClient client;
 
   @Before public void setUp() throws Exception {
-    server = new MockWebServer();
-    client = new OkHttpClient();
-
     // Sockets on some platforms can have large buffers that mean writes do not block when
     // required. These socket factories explicitly set the buffer sizes on sockets created.
+    server = new MockWebServer();
     server.setServerSocketFactory(
         new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
           @Override
-          protected void configureServerSocket(ServerSocket serverSocket) throws IOException {
+          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
+              throws IOException {
             serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return serverSocket;
           }
         });
-    client.setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-      @Override
-      protected void configureSocket(Socket socket) throws IOException {
-        socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-        socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-      }
-    });
+    client = new OkHttpClient.Builder()
+        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+          @Override
+          protected Socket configureSocket(Socket socket) throws IOException {
+            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return socket;
+          }
+        })
+        .build();
   }
 
   @Test public void interruptWritingRequestBody() throws Exception {
@@ -79,7 +79,7 @@ protected void configureSocket(Socket socket) throws IOException {
 
     interruptLater(500);
 
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
     connection.setDoOutput(true);
     connection.setFixedLengthStreamingMode(requestBodySize);
     OutputStream requestBody = connection.getOutputStream();
@@ -106,7 +106,7 @@ protected void configureSocket(Socket socket) throws IOException {
 
     interruptLater(500);
 
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
     InputStream responseBody = connection.getInputStream();
     byte[] buffer = new byte[1024];
     try {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
new file mode 100644
index 0000000000..8c50399878
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
@@ -0,0 +1,305 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.Call;
+import okhttp3.CertificatePinner;
+import okhttp3.OkHttpClient;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.HeldCertificate;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CertificatePinnerChainValidationTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  /** The pinner should pull the root certificate from the trust manager. */
+  @Test public void pinRootNotPresentInChain() throws Exception {
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    HeldCertificate intermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("intermediate_ca")
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .issuedBy(intermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(rootCa.certificate))
+        .build();
+    SSLContext clientContext = new SslContextBuilder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    SSLContext serverSslContext = new SslContextBuilder()
+        .certificateChain(certificate, intermediateCa)
+        .build();
+    server.useHttps(serverSslContext.getSocketFactory(), false);
+
+    // The request should complete successfully.
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("abc", response1.body().string());
+
+    // Confirm that a second request also succeeds. This should detect caching problems.
+    server.enqueue(new MockResponse()
+        .setBody("def")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("def", response2.body().string());
+  }
+
+  /** The pinner should accept an intermediate from the server's chain. */
+  @Test public void pinIntermediatePresentInChain() throws Exception {
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    HeldCertificate intermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("intermediate_ca")
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .issuedBy(intermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(intermediateCa.certificate))
+        .build();
+    SSLContext clientContext = new SslContextBuilder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    SSLContext serverSslContext = new SslContextBuilder()
+        .certificateChain(certificate, intermediateCa)
+        .build();
+    server.useHttps(serverSslContext.getSocketFactory(), false);
+
+    // The request should complete successfully.
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals("abc", response1.body().string());
+
+    // Confirm that a second request also succeeds. This should detect caching problems.
+    server.enqueue(new MockResponse()
+        .setBody("def")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("def", response2.body().string());
+  }
+
+  @Test public void unrelatedPinnedLeafCertificateInChain() throws Exception {
+    // Start with a trusted root CA certificate.
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+
+    // Add a good intermediate CA, and have that issue a good certificate to localhost. Prepare an
+    // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
+    // certificate.
+    HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("2")
+        .commonName("good_intermediate_ca")
+        .build();
+    HeldCertificate goodCertificate = new HeldCertificate.Builder()
+        .issuedBy(goodIntermediateCa)
+        .serialNumber("3")
+        .commonName(server.getHostName())
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(goodCertificate.certificate))
+        .build();
+    SSLContext clientContext = new SslContextBuilder()
+        .addTrustedCertificate(rootCa.certificate)
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    // Add a bad intermediate CA and have that issue a rogue certificate for localhost. Prepare
+    // an SSL context for an attacking webserver. It includes both these rogue certificates plus the
+    // trusted good certificate above. The attack is that by including the good certificate in the
+    // chain, we may trick the certificate pinner into accepting the rouge certificate.
+    HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("4")
+        .commonName("bad_intermediate_ca")
+        .build();
+    HeldCertificate rogueCertificate = new HeldCertificate.Builder()
+        .serialNumber("5")
+        .issuedBy(compromisedIntermediateCa)
+        .commonName(server.getHostName())
+        .build();
+    SSLContext serverSslContext = new SslContextBuilder()
+        .certificateChain(rogueCertificate, compromisedIntermediateCa, goodCertificate, rootCa)
+        .build();
+    server.useHttps(serverSslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    // Make a request from client to server. It should succeed certificate checks (unfortunately the
+    // rogue CA is trusted) but it should fail certificate pinning.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+      // Certificate pinning fails!
+      String message = expected.getMessage();
+      assertTrue(message, message.startsWith("Certificate pinning failure!"));
+    }
+  }
+
+  @Test public void unrelatedPinnedIntermediateCertificateInChain() throws Exception {
+    // Start with two root CA certificates, one is good and the other is compromised.
+    HeldCertificate rootCa = new HeldCertificate.Builder()
+        .serialNumber("1")
+        .ca(3)
+        .commonName("root")
+        .build();
+    HeldCertificate compromisedRootCa = new HeldCertificate.Builder()
+        .serialNumber("2")
+        .ca(3)
+        .commonName("compromised_root")
+        .build();
+
+    // Add a good intermediate CA, and have that issue a good certificate to localhost. Prepare an
+    // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
+    // certificate.
+    HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(rootCa)
+        .ca(2)
+        .serialNumber("3")
+        .commonName("intermediate_ca")
+        .build();
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add(server.getHostName(), CertificatePinner.pin(goodIntermediateCa.certificate))
+        .build();
+    SSLContext clientContext = new SslContextBuilder()
+        .addTrustedCertificate(rootCa.certificate)
+        .addTrustedCertificate(compromisedRootCa.certificate)
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .certificatePinner(certificatePinner)
+        .build();
+
+    // The attacker compromises the root CA, issues an intermediate with the same common name
+    // "intermediate_ca" as the good CA. This signs a rogue certificate for localhost. The server
+    // serves the good CAs certificate in the chain, which means the certificate pinner sees a
+    // different set of certificates than the SSL verifier.
+    HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
+        .issuedBy(compromisedRootCa)
+        .ca(2)
+        .serialNumber("4")
+        .commonName("intermediate_ca")
+        .build();
+    HeldCertificate rogueCertificate = new HeldCertificate.Builder()
+        .serialNumber("5")
+        .issuedBy(compromisedIntermediateCa)
+        .commonName(server.getHostName())
+        .build();
+    SSLContext serverSslContext = new SslContextBuilder()
+        .certificateChain(
+            rogueCertificate, goodIntermediateCa, compromisedIntermediateCa, compromisedRootCa)
+        .build();
+    server.useHttps(serverSslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    // Make a request from client to server. It should succeed certificate checks (unfortunately the
+    // rogue CA is trusted) but it should fail certificate pinning.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SSLHandshakeException expected) {
+      // On Android, the handshake fails before the certificate pinner runs.
+      String message = expected.getMessage();
+      assertTrue(message, message.contains("Could not validate certificate"));
+    } catch (SSLPeerUnverifiedException expected) {
+      // On OpenJDK, the handshake succeeds but the certificate pinner fails.
+      String message = expected.getMessage();
+      assertTrue(message, message.startsWith("Certificate pinning failure!"));
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
similarity index 93%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
index d7f1c78cb8..f03f197d94 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
@@ -15,15 +15,16 @@
  * the License.
  */
 
-package com.squareup.okhttp.internal.tls;
+package okhttp3.internal.tls;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayInputStream;
 import java.security.cert.CertificateFactory;
 import java.security.cert.X509Certificate;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSession;
 import javax.security.auth.x500.X500Principal;
+import okhttp3.FakeSSLSession;
+import okhttp3.internal.Util;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -32,8 +33,8 @@
 import static org.junit.Assert.assertTrue;
 
 /**
- * Tests for our hostname verifier. Most of these tests are from AOSP, which
- * itself includes tests from the Apache HTTP Client test suite.
+ * Tests for our hostname verifier. Most of these tests are from AOSP, which itself includes tests
+ * from the Apache HTTP Client test suite.
  */
 public final class HostnameVerifierTest {
   private HostnameVerifier verifier = OkHostnameVerifier.INSTANCE;
@@ -144,9 +145,9 @@
   }
 
   /**
-   * Ignored due to incompatibilities between Android and Java on how non-ASCII
-   * subject alt names are parsed. Android fails to parse these, which means we
-   * fall back to the CN. The RI does parse them, so the CN is unused.
+   * Ignored due to incompatibilities between Android and Java on how non-ASCII subject alt names
+   * are parsed. Android fails to parse these, which means we fall back to the CN. The RI does parse
+   * them, so the CN is unused.
    */
   @Test @Ignore public void verifyNonAsciiSubjectAlt() throws Exception {
     // CN=foo.com, subjectAlt=bar.com, subjectAlt=&#x82b1;&#x5b50;.co.jp
@@ -329,9 +330,9 @@
   }
 
   /**
-   * Ignored due to incompatibilities between Android and Java on how non-ASCII
-   * subject alt names are parsed. Android fails to parse these, which means we
-   * fall back to the CN. The RI does parse them, so the CN is unused.
+   * Ignored due to incompatibilities between Android and Java on how non-ASCII subject alt names
+   * are parsed. Android fails to parse these, which means we fall back to the CN. The RI does parse
+   * them, so the CN is unused.
    */
   @Test @Ignore public void testWilcardNonAsciiSubjectAlt() throws Exception {
     // CN=*.foo.com, subjectAlt=*.bar.com, subjectAlt=*.&#x82b1;&#x5b50;.co.jp
@@ -432,10 +433,9 @@
   }
 
   /**
-   * Earlier implementations of Android's hostname verifier required that
-   * wildcard names wouldn't match "*.com" or similar. This was a nonstandard
-   * check that we've since dropped. It is the CA's responsibility to not hand
-   * out certificates that match so broadly.
+   * Earlier implementations of Android's hostname verifier required that wildcard names wouldn't
+   * match "*.com" or similar. This was a nonstandard check that we've since dropped. It is the CA's
+   * responsibility to not hand out certificates that match so broadly.
    */
   @Test public void wildcardsDoesNotNeedTwoDots() throws Exception {
     // openssl req -x509 -nodes -days 36500 -subj '/CN=*.com' -newkey rsa:512 -out cert.pem
@@ -518,28 +518,28 @@
 
   @Test public void verifyAsIpAddress() {
     // IPv4
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("127.0.0.1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("1.2.3.4"));
+    assertTrue(Util.verifyAsIpAddress("127.0.0.1"));
+    assertTrue(Util.verifyAsIpAddress("1.2.3.4"));
 
     // IPv6
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("2001:db8::1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::192.168.0.1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::ffff:192.168.0.1"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("FEDC:BA98:7654:3210:FEDC:BA98:7654:3210"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("1080:0:0:0:8:800:200C:417A"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("1080::8:800:200C:417A"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("FF01::101"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("0:0:0:0:0:0:13.1.68.3"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("0:0:0:0:0:FFFF:129.144.52.38"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::13.1.68.3"));
-    assertTrue(OkHostnameVerifier.verifyAsIpAddress("::FFFF:129.144.52.38"));
+    assertTrue(Util.verifyAsIpAddress("::1"));
+    assertTrue(Util.verifyAsIpAddress("2001:db8::1"));
+    assertTrue(Util.verifyAsIpAddress("::192.168.0.1"));
+    assertTrue(Util.verifyAsIpAddress("::ffff:192.168.0.1"));
+    assertTrue(Util.verifyAsIpAddress("FEDC:BA98:7654:3210:FEDC:BA98:7654:3210"));
+    assertTrue(Util.verifyAsIpAddress("1080:0:0:0:8:800:200C:417A"));
+    assertTrue(Util.verifyAsIpAddress("1080::8:800:200C:417A"));
+    assertTrue(Util.verifyAsIpAddress("FF01::101"));
+    assertTrue(Util.verifyAsIpAddress("0:0:0:0:0:0:13.1.68.3"));
+    assertTrue(Util.verifyAsIpAddress("0:0:0:0:0:FFFF:129.144.52.38"));
+    assertTrue(Util.verifyAsIpAddress("::13.1.68.3"));
+    assertTrue(Util.verifyAsIpAddress("::FFFF:129.144.52.38"));
 
     // Hostnames
-    assertFalse(OkHostnameVerifier.verifyAsIpAddress("go"));
-    assertFalse(OkHostnameVerifier.verifyAsIpAddress("localhost"));
-    assertFalse(OkHostnameVerifier.verifyAsIpAddress("squareup.com"));
-    assertFalse(OkHostnameVerifier.verifyAsIpAddress("www.nintendo.co.jp"));
+    assertFalse(Util.verifyAsIpAddress("go"));
+    assertFalse(Util.verifyAsIpAddress("localhost"));
+    assertFalse(Util.verifyAsIpAddress("squareup.com"));
+    assertFalse(Util.verifyAsIpAddress("www.nintendo.co.jp"));
   }
 
   private X509Certificate certificate(String certificate) throws Exception {
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index 7b7ee3f96b..2c95ffc6c2 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.5.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
@@ -14,12 +14,12 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-testing-support</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
@@ -31,7 +31,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>mockwebserver</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
@@ -44,7 +44,7 @@
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
-          <excludePackageNames>com.squareup.okhttp.internal.*</excludePackageNames>
+          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
           </links>
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
new file mode 100644
index 0000000000..b5440a4d02
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.Authenticator.RequestorType;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.PasswordAuthentication;
+import java.net.Proxy;
+import java.util.List;
+
+/**
+ * Adapts {@link java.net.Authenticator} to {@link Authenticator}. Configure OkHttp to use {@link
+ * java.net.Authenticator} with {@link OkHttpClient.Builder#authenticator} or {@link
+ * OkHttpClient.Builder#proxyAuthenticator(Authenticator)}.
+ */
+public final class JavaNetAuthenticator implements Authenticator {
+  @Override public Request authenticate(Route route, Response response) throws IOException {
+    List<Challenge> challenges = response.challenges();
+    Request request = response.request();
+    HttpUrl url = request.url();
+    boolean proxyAuthorization = response.code() == 407;
+    Proxy proxy = route.proxy();
+
+    for (int i = 0, size = challenges.size(); i < size; i++) {
+      Challenge challenge = challenges.get(i);
+      if (!"Basic".equalsIgnoreCase(challenge.scheme())) continue;
+
+      PasswordAuthentication auth;
+      if (proxyAuthorization) {
+        InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
+        auth = java.net.Authenticator.requestPasswordAuthentication(
+            proxyAddress.getHostName(), getConnectToInetAddress(proxy, url), proxyAddress.getPort(),
+            url.scheme(), challenge.realm(), challenge.scheme(), url.url(),
+            RequestorType.PROXY);
+      } else {
+        auth = java.net.Authenticator.requestPasswordAuthentication(
+            url.host(), getConnectToInetAddress(proxy, url), url.port(), url.scheme(),
+            challenge.realm(), challenge.scheme(), url.url(), RequestorType.SERVER);
+      }
+
+      if (auth != null) {
+        String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
+        return request.newBuilder()
+            .header(proxyAuthorization ? "Proxy-Authorization" : "Authorization", credential)
+            .build();
+      }
+    }
+
+    return null; // No challenges were satisfied!
+  }
+
+  private InetAddress getConnectToInetAddress(Proxy proxy, HttpUrl url) throws IOException {
+    return (proxy != null && proxy.type() != Proxy.Type.DIRECT)
+        ? ((InetSocketAddress) proxy.address()).getAddress()
+        : InetAddress.getByName(url.host());
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
new file mode 100644
index 0000000000..6af8a69b65
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.CookieHandler;
+import java.net.HttpCookie;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import okhttp3.internal.Platform;
+
+import static okhttp3.internal.Platform.WARN;
+import static okhttp3.internal.Util.delimiterOffset;
+import static okhttp3.internal.Util.trimSubstring;
+
+/** A cookie jar that delegates to a {@link java.net.CookieHandler}. */
+public final class JavaNetCookieJar implements CookieJar {
+  private final CookieHandler cookieHandler;
+
+  public JavaNetCookieJar(CookieHandler cookieHandler) {
+    this.cookieHandler = cookieHandler;
+  }
+
+  @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
+    if (cookieHandler != null) {
+      List<String> cookieStrings = new ArrayList<>();
+      for (Cookie cookie : cookies) {
+        cookieStrings.add(cookie.toString());
+      }
+      Map<String, List<String>> multimap = Collections.singletonMap("Set-Cookie", cookieStrings);
+      try {
+        cookieHandler.put(url.uri(), multimap);
+      } catch (IOException e) {
+        Platform.get().log(WARN, "Saving cookies failed for " + url.resolve("/..."), e);
+      }
+    }
+  }
+
+  @Override public List<Cookie> loadForRequest(HttpUrl url) {
+    // The RI passes all headers. We don't have 'em, so we don't pass 'em!
+    Map<String, List<String>> headers = Collections.emptyMap();
+    Map<String, List<String>> cookieHeaders;
+    try {
+      cookieHeaders = cookieHandler.get(url.uri(), headers);
+    } catch (IOException e) {
+      Platform.get().log(WARN, "Loading cookies failed for " + url.resolve("/..."), e);
+      return Collections.emptyList();
+    }
+
+    List<Cookie> cookies = null;
+    for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
+      String key = entry.getKey();
+      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
+          && !entry.getValue().isEmpty()) {
+        for (String header : entry.getValue()) {
+          if (cookies == null) cookies = new ArrayList<>();
+          cookies.addAll(decodeHeaderAsJavaNetCookies(url, header));
+        }
+      }
+    }
+
+    return cookies != null
+        ? Collections.unmodifiableList(cookies)
+        : Collections.<Cookie>emptyList();
+  }
+
+  /**
+   * Convert a request header to OkHttp's cookies via {@link HttpCookie}. That extra step handles
+   * multiple cookies in a single request header, which {@link Cookie#parse} doesn't support.
+   */
+  private List<Cookie> decodeHeaderAsJavaNetCookies(HttpUrl url, String header) {
+    List<Cookie> result = new ArrayList<>();
+    for (int pos = 0, limit = header.length(), pairEnd; pos < limit; pos = pairEnd + 1) {
+      pairEnd = delimiterOffset(header, pos, limit, ";,");
+      int equalsSign = delimiterOffset(header, pos, pairEnd, '=');
+      String name = trimSubstring(header, pos, equalsSign);
+      if (name.startsWith("$")) continue;
+
+      // We have either name=value or just a name.
+      String value = equalsSign < pairEnd
+          ? trimSubstring(header, equalsSign + 1, pairEnd)
+          : "";
+
+      // If the value is "quoted", drop the quotes.
+      if (value.startsWith("\"") && value.endsWith("\"")) {
+        value = value.substring(1, value.length() - 1);
+      }
+
+      result.add(new Cookie.Builder()
+          .name(name)
+          .value(value)
+          .domain(url.host())
+          .build());
+    }
+    return result;
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
similarity index 72%
rename from okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java
rename to okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
index 4b34559e4c..973c70578b 100644
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
@@ -13,10 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.huc.HttpURLConnectionImpl;
-import com.squareup.okhttp.internal.huc.HttpsURLConnectionImpl;
+package okhttp3;
 
 import java.net.HttpURLConnection;
 import java.net.Proxy;
@@ -24,9 +21,18 @@
 import java.net.URLConnection;
 import java.net.URLStreamHandler;
 import java.net.URLStreamHandlerFactory;
+import okhttp3.internal.URLFilter;
+import okhttp3.internal.huc.HttpURLConnectionImpl;
+import okhttp3.internal.huc.HttpsURLConnectionImpl;
 
+/**
+ * @deprecated OkHttp will be dropping its ability to be used with {@link HttpURLConnection} in an
+ * upcoming release. Applications that need this should either downgrade to the system's built-in
+ * {@link HttpURLConnection} or upgrade to OkHttp's Request/Response API.
+ */
 public final class OkUrlFactory implements URLStreamHandlerFactory, Cloneable {
-  private final OkHttpClient client;
+  private OkHttpClient client;
+  private URLFilter urlFilter;
 
   public OkUrlFactory(OkHttpClient client) {
     this.client = client;
@@ -36,25 +42,35 @@ public OkHttpClient client() {
     return client;
   }
 
+  public OkUrlFactory setClient(OkHttpClient client) {
+    this.client = client;
+    return this;
+  }
+
+  void setUrlFilter(URLFilter filter) {
+    urlFilter = filter;
+  }
+
   /**
-   * Returns a copy of this stream handler factory that includes a shallow copy
-   * of the internal {@linkplain OkHttpClient HTTP client}.
+   * Returns a copy of this stream handler factory that includes a shallow copy of the internal
+   * {@linkplain OkHttpClient HTTP client}.
    */
   @Override public OkUrlFactory clone() {
-    return new OkUrlFactory(client.clone());
+    return new OkUrlFactory(client);
   }
 
   public HttpURLConnection open(URL url) {
-    return open(url, client.getProxy());
+    return open(url, client.proxy());
   }
 
   HttpURLConnection open(URL url, Proxy proxy) {
     String protocol = url.getProtocol();
-    OkHttpClient copy = client.copyWithDefaults();
-    copy.setProxy(proxy);
+    OkHttpClient copy = client.newBuilder()
+        .proxy(proxy)
+        .build();
 
-    if (protocol.equals("http")) return new HttpURLConnectionImpl(url, copy);
-    if (protocol.equals("https")) return new HttpsURLConnectionImpl(url, copy);
+    if (protocol.equals("http")) return new HttpURLConnectionImpl(url, copy, urlFilter);
+    if (protocol.equals("https")) return new HttpsURLConnectionImpl(url, copy, urlFilter);
     throw new IllegalArgumentException("Unexpected protocol: " + protocol);
   }
 
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
new file mode 100644
index 0000000000..0b7a02e1f9
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+import okhttp3.Headers;
+
+public final class JavaNetHeaders {
+  private JavaNetHeaders() {
+  }
+
+  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
+    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
+    @Override public int compare(String a, String b) {
+      if (a == b) {
+        return 0;
+      } else if (a == null) {
+        return -1;
+      } else if (b == null) {
+        return 1;
+      } else {
+        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
+      }
+    }
+  };
+
+  /**
+   * Returns an immutable map containing each field to its list of values.
+   *
+   * @param valueForNullKey the request line for requests, or the status line for responses. If
+   * non-null, this value is mapped to the null key.
+   */
+  public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
+    Map<String, List<String>> result = new TreeMap<>(FIELD_NAME_COMPARATOR);
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String fieldName = headers.name(i);
+      String value = headers.value(i);
+
+      List<String> allValues = new ArrayList<>();
+      List<String> otherValues = result.get(fieldName);
+      if (otherValues != null) {
+        allValues.addAll(otherValues);
+      }
+      allValues.add(value);
+      result.put(fieldName, Collections.unmodifiableList(allValues));
+    }
+    if (valueForNullKey != null) {
+      result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));
+    }
+    return Collections.unmodifiableMap(result);
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java
new file mode 100644
index 0000000000..e0c9523fb0
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/SystemPropertiesConnectionPool.java
@@ -0,0 +1,67 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.util.concurrent.TimeUnit;
+import okhttp3.ConnectionPool;
+
+/**
+ * A shared connection pool that uses system properties for tuning parameters:
+ *
+ * <ul>
+ *     <li>{@code http.keepAlive} true if HTTP and SPDY connections should be pooled at all. Default
+ *         is true.
+ *     <li>{@code http.maxConnections} maximum number of idle connections to each to keep in the
+ *         pool. Default is 5.
+ *     <li>{@code http.keepAliveDuration} Time in milliseconds to keep the connection alive in the
+ *         pool before closing it. Default is 5 minutes. This property isn't used by {@code
+ *         HttpURLConnection}.
+ * </ul>
+ *
+ * <p>The default instance <i>doesn't</i> adjust its configuration as system properties are changed.
+ * This assumes that the applications that set these parameters do so before making HTTP
+ * connections, and that this class is initialized lazily.
+ */
+public final class SystemPropertiesConnectionPool {
+  private static final long DEFAULT_KEEP_ALIVE_DURATION_MS = 5 * 60 * 1000; // 5 min
+
+  public static final ConnectionPool INSTANCE;
+  static {
+    String keepAlive = System.getProperty("http.keepAlive");
+    int maxIdleConnections;
+    if (keepAlive != null && !Boolean.parseBoolean(keepAlive)) {
+      maxIdleConnections = 0;
+    } else {
+      String maxIdleConnectionsString = System.getProperty("http.maxConnections");
+      if (maxIdleConnectionsString != null) {
+        maxIdleConnections = Integer.parseInt(maxIdleConnectionsString);
+      } else {
+        maxIdleConnections = 5;
+      }
+    }
+
+    String keepAliveDurationString = System.getProperty("http.keepAliveDuration");
+    long keepAliveDurationMs = keepAliveDurationString != null
+        ? Long.parseLong(keepAliveDurationString)
+        : DEFAULT_KEEP_ALIVE_DURATION_MS;
+
+    INSTANCE = new ConnectionPool(maxIdleConnections, keepAliveDurationMs, TimeUnit.MILLISECONDS);
+  }
+
+  private SystemPropertiesConnectionPool() {
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java
new file mode 100644
index 0000000000..3b077f8bc4
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+import java.io.IOException;
+import java.net.URL;
+
+/**
+ * Request filter based on the request's URL.
+ *
+ * @deprecated use {@link okhttp3.Interceptor} for non-HttpURLConnection filtering.
+ */
+public interface URLFilter {
+  /**
+   * Check whether request to the provided URL is permitted to be issued.
+   *
+   * @throws IOException if the request to the provided URL is not permitted.
+   */
+  void checkURLPermitted(URL url) throws IOException;
+}
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
similarity index 97%
rename from okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java
rename to okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
index 631a2ae03d..86f4aa7807 100644
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
@@ -14,9 +14,8 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.squareup.okhttp.internal.huc;
+package okhttp3.internal.huc;
 
-import com.squareup.okhttp.Handshake;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -32,10 +31,11 @@
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Handshake;
 
 /**
- * Implement an HTTPS connection by delegating to an HTTP connection for
- * everything but the HTTPS-specific stuff.
+ * Implement an HTTPS connection by delegating to an HTTP connection for everything but the
+ * HTTPS-specific stuff.
  */
 abstract class DelegatingHttpsURLConnection extends HttpsURLConnection {
   private final HttpURLConnection delegate;
@@ -57,7 +57,7 @@ public DelegatingHttpsURLConnection(HttpURLConnection delegate) {
 
   @Override public String getCipherSuite() {
     Handshake handshake = handshake();
-    return handshake != null ? handshake.cipherSuite() : null;
+    return handshake != null ? handshake.cipherSuite().javaName() : null;
   }
 
   @Override public Certificate[] getLocalCertificates() {
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
similarity index 74%
rename from okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
rename to okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
index 8db26d75fd..08f73710dd 100644
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
@@ -15,30 +15,8 @@
  *  limitations under the License.
  */
 
-package com.squareup.okhttp.internal.huc;
-
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.Handshake;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.Route;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.Version;
-import com.squareup.okhttp.internal.http.HttpDate;
-import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.HttpMethod;
-import com.squareup.okhttp.internal.http.OkHeaders;
-import com.squareup.okhttp.internal.http.RequestException;
-import com.squareup.okhttp.internal.http.RetryableSink;
-import com.squareup.okhttp.internal.http.RouteException;
-import com.squareup.okhttp.internal.http.StatusLine;
+package okhttp3.internal.huc;
+
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -46,10 +24,12 @@
 import java.net.HttpRetryException;
 import java.net.HttpURLConnection;
 import java.net.InetSocketAddress;
+import java.net.MalformedURLException;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.SocketPermission;
 import java.net.URL;
+import java.net.UnknownHostException;
 import java.security.Permission;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -60,27 +40,53 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
+import okhttp3.Connection;
+import okhttp3.Handshake;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.Route;
+import okhttp3.internal.Internal;
+import okhttp3.internal.JavaNetHeaders;
+import okhttp3.internal.Platform;
+import okhttp3.internal.URLFilter;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.internal.http.HttpDate;
+import okhttp3.internal.http.HttpEngine;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.http.RequestException;
+import okhttp3.internal.http.RetryableSink;
+import okhttp3.internal.http.RouteException;
+import okhttp3.internal.http.StatusLine;
+import okhttp3.internal.http.StreamAllocation;
 import okio.BufferedSink;
 import okio.Sink;
 
+import static okhttp3.internal.Platform.WARN;
+
 /**
- * This implementation uses HttpEngine to send requests and receive responses.
- * This class may use multiple HttpEngines to follow redirects, authentication
- * retries, etc. to retrieve the final response body.
+ * This implementation uses HttpEngine to send requests and receive responses. This class may use
+ * multiple HttpEngines to follow redirects, authentication retries, etc. to retrieve the final
+ * response body.
  *
- * <h3>What does 'connected' mean?</h3>
- * This class inherits a {@code connected} field from the superclass. That field
- * is <strong>not</strong> used to indicate not whether this URLConnection is
- * currently connected. Instead, it indicates whether a connection has ever been
- * attempted. Once a connection has been attempted, certain properties (request
- * header fields, request method, etc.) are immutable.
+ * <h3>What does 'connected' mean?</h3> This class inherits a {@code connected} field from the
+ * superclass. That field is <strong>not</strong> used to indicate whether this URLConnection is
+ * currently connected. Instead, it indicates whether a connection has ever been attempted. Once a
+ * connection has been attempted, certain properties (request header fields, request method, etc.)
+ * are immutable.
  */
 public class HttpURLConnectionImpl extends HttpURLConnection {
   private static final Set<String> METHODS = new LinkedHashSet<>(
       Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
   private static final RequestBody EMPTY_REQUEST_BODY = RequestBody.create(null, new byte[0]);
 
-  final OkHttpClient client;
+  OkHttpClient client;
 
   private Headers.Builder requestHeaders = new Headers.Builder();
 
@@ -93,22 +99,29 @@
   private Headers responseHeaders;
 
   /**
-   * The most recently attempted route. This will be null if we haven't sent a
-   * request yet, or if the response comes from a cache.
+   * The most recently attempted route. This will be null if we haven't sent a request yet, or if
+   * the response comes from a cache.
    */
   private Route route;
 
   /**
-   * The most recently received TLS handshake. This will be null if we haven't
-   * connected yet, or if the most recent connection was HTTP (and not HTTPS).
+   * The most recently received TLS handshake. This will be null if we haven't connected yet, or if
+   * the most recent connection was HTTP (and not HTTPS).
    */
   Handshake handshake;
 
+  private URLFilter urlFilter;
+
   public HttpURLConnectionImpl(URL url, OkHttpClient client) {
     super(url);
     this.client = client;
   }
 
+  public HttpURLConnectionImpl(URL url, OkHttpClient client, URLFilter urlFilter) {
+    this(url, client);
+    this.urlFilter = urlFilter;
+  }
+
   @Override public final void connect() throws IOException {
     initHttpEngine();
     boolean success;
@@ -121,7 +134,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
     // Calling disconnect() before a connection exists should have no effect.
     if (httpEngine == null) return;
 
-    httpEngine.disconnect();
+    httpEngine.cancel();
 
     // This doesn't close the stream because doing so would require all stream
     // access to be synchronized. It's expected that the thread using the
@@ -131,8 +144,8 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
   }
 
   /**
-   * Returns an input stream from the server in the case of error such as the
-   * requested file (txt, htm, html) is not found on the remote server.
+   * Returns an input stream from the server in the case of error such as the requested file (txt,
+   * htm, html) is not found on the remote server.
    */
   @Override public final InputStream getErrorStream() {
     try {
@@ -151,9 +164,9 @@ private Headers getHeaders() throws IOException {
     if (responseHeaders == null) {
       Response response = getResponse().getResponse();
       Headers headers = response.headers();
-
       responseHeaders = headers.newBuilder()
-          .add(Platform.get().getPrefix() + "-Response-Source", responseSourceHeader(response))
+          .add(OkHeaders.SELECTED_PROTOCOL, response.protocol().toString())
+          .add(OkHeaders.RESPONSE_SOURCE, responseSourceHeader(response))
           .build();
     }
     return responseHeaders;
@@ -173,21 +186,22 @@ private static String responseSourceHeader(Response response) {
   }
 
   /**
-   * Returns the value of the field at {@code position}. Returns null if there
-   * are fewer than {@code position} headers.
+   * Returns the value of the field at {@code position}. Returns null if there are fewer than {@code
+   * position} headers.
    */
   @Override public final String getHeaderField(int position) {
     try {
-      return getHeaders().value(position);
+      Headers headers = getHeaders();
+      if (position < 0 || position >= headers.size()) return null;
+      return headers.value(position);
     } catch (IOException e) {
       return null;
     }
   }
 
   /**
-   * Returns the value of the field corresponding to the {@code fieldName}, or
-   * null if there is no such field. If the field has multiple values, the
-   * last value is returned.
+   * Returns the value of the field corresponding to the {@code fieldName}, or null if there is no
+   * such field. If the field has multiple values, the last value is returned.
    */
   @Override public final String getHeaderField(String fieldName) {
     try {
@@ -201,7 +215,9 @@ private static String responseSourceHeader(Response response) {
 
   @Override public final String getHeaderFieldKey(int position) {
     try {
-      return getHeaders().name(position);
+      Headers headers = getHeaders();
+      if (position < 0 || position >= headers.size()) return null;
+      return headers.name(position);
     } catch (IOException e) {
       return null;
     }
@@ -209,7 +225,7 @@ private static String responseSourceHeader(Response response) {
 
   @Override public final Map<String, List<String>> getHeaderFields() {
     try {
-      return OkHeaders.toMultimap(getHeaders(),
+      return JavaNetHeaders.toMultimap(getHeaders(),
           StatusLine.get(getResponse().getResponse()).toString());
     } catch (IOException e) {
       return Collections.emptyMap();
@@ -222,7 +238,7 @@ private static String responseSourceHeader(Response response) {
           "Cannot access request header fields after connection is set");
     }
 
-    return OkHeaders.toMultimap(requestHeaders.build(), null);
+    return JavaNetHeaders.toMultimap(requestHeaders.build(), null);
   }
 
   @Override public final InputStream getInputStream() throws IOException {
@@ -258,16 +274,16 @@ private static String responseSourceHeader(Response response) {
 
   @Override public final Permission getPermission() throws IOException {
     URL url = getURL();
-    String hostName = url.getHost();
+    String hostname = url.getHost();
     int hostPort = url.getPort() != -1
         ? url.getPort()
         : HttpUrl.defaultPort(url.getProtocol());
     if (usingProxy()) {
-      InetSocketAddress proxyAddress = (InetSocketAddress) client.getProxy().address();
-      hostName = proxyAddress.getHostName();
+      InetSocketAddress proxyAddress = (InetSocketAddress) client.proxy().address();
+      hostname = proxyAddress.getHostName();
       hostPort = proxyAddress.getPort();
     }
-    return new SocketPermission(hostName + ":" + hostPort, "connect, resolve");
+    return new SocketPermission(hostname + ":" + hostPort, "connect, resolve");
   }
 
   @Override public final String getRequestProperty(String field) {
@@ -276,24 +292,34 @@ private static String responseSourceHeader(Response response) {
   }
 
   @Override public void setConnectTimeout(int timeoutMillis) {
-    client.setConnectTimeout(timeoutMillis, TimeUnit.MILLISECONDS);
+    client = client.newBuilder()
+        .connectTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
+        .build();
   }
 
   @Override
   public void setInstanceFollowRedirects(boolean followRedirects) {
-    client.setFollowRedirects(followRedirects);
+    client = client.newBuilder()
+        .followRedirects(followRedirects)
+        .build();
+  }
+
+  @Override public boolean getInstanceFollowRedirects() {
+    return client.followRedirects();
   }
 
   @Override public int getConnectTimeout() {
-    return client.getConnectTimeout();
+    return client.connectTimeoutMillis();
   }
 
   @Override public void setReadTimeout(int timeoutMillis) {
-    client.setReadTimeout(timeoutMillis, TimeUnit.MILLISECONDS);
+    client = client.newBuilder()
+        .readTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
+        .build();
   }
 
   @Override public int getReadTimeout() {
-    return client.getReadTimeout();
+    return client.readTimeoutMillis();
   }
 
   private void initHttpEngine() throws IOException {
@@ -321,14 +347,17 @@ private void initHttpEngine() throws IOException {
     }
   }
 
-  private HttpEngine newHttpEngine(String method, Connection connection,
-      RetryableSink requestBody, Response priorResponse) {
+  private HttpEngine newHttpEngine(String method, StreamAllocation streamAllocation,
+      RetryableSink requestBody, Response priorResponse)
+      throws MalformedURLException, UnknownHostException {
     // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
     RequestBody placeholderBody = HttpMethod.requiresRequestBody(method)
         ? EMPTY_REQUEST_BODY
         : null;
+    URL url = getURL();
+    HttpUrl httpUrl = Internal.instance.getHttpUrlChecked(url.toString());
     Request.Builder builder = new Request.Builder()
-        .url(getURL())
+        .url(httpUrl)
         .method(method, placeholderBody);
     Headers headers = requestHeaders.build();
     for (int i = 0, size = headers.size(); i < size; i++) {
@@ -361,10 +390,12 @@ private HttpEngine newHttpEngine(String method, Connection connection,
     // If we're currently not using caches, make sure the engine's client doesn't have one.
     OkHttpClient engineClient = client;
     if (Internal.instance.internalCache(engineClient) != null && !getUseCaches()) {
-      engineClient = client.clone().setCache(null);
+      engineClient = client.newBuilder()
+          .cache(null)
+          .build();
     }
 
-    return new HttpEngine(engineClient, request, bufferRequestBody, true, false, connection, null,
+    return new HttpEngine(engineClient, request, bufferRequestBody, true, false, streamAllocation,
         requestBody, priorResponse);
   }
 
@@ -374,9 +405,8 @@ private String defaultUserAgent() {
   }
 
   /**
-   * Aggressively tries to get the final HTTP response, potentially making
-   * many HTTP requests in the process in order to cope with redirects and
-   * authentication.
+   * Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the
+   * process in order to cope with redirects and authentication.
    */
   private HttpEngine getResponse() throws IOException {
     initHttpEngine();
@@ -394,7 +424,7 @@ private HttpEngine getResponse() throws IOException {
       Request followUp = httpEngine.followUpRequest();
 
       if (followUp == null) {
-        httpEngine.releaseConnection();
+        httpEngine.releaseStreamAllocation();
         return httpEngine;
       }
 
@@ -403,7 +433,7 @@ private HttpEngine getResponse() throws IOException {
       }
 
       // The first request was insufficient. Prepare for another...
-      url = followUp.url();
+      url = followUp.url().url();
       requestHeaders = followUp.headers().newBuilder();
 
       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect
@@ -418,31 +448,41 @@ private HttpEngine getResponse() throws IOException {
         throw new HttpRetryException("Cannot retry streamed HTTP body", responseCode);
       }
 
-      if (!httpEngine.sameConnection(followUp.httpUrl())) {
-        httpEngine.releaseConnection();
+      StreamAllocation streamAllocation = httpEngine.close();
+      if (!httpEngine.sameConnection(followUp.url())) {
+        streamAllocation.release();
+        streamAllocation = null;
       }
 
-      Connection connection = httpEngine.close();
-      httpEngine = newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,
+      httpEngine = newHttpEngine(followUp.method(), streamAllocation, (RetryableSink) requestBody,
           response);
     }
   }
 
   /**
-   * Sends a request and optionally reads a response. Returns true if the
-   * request was successfully executed, and false if the request can be
-   * retried. Throws an exception if the request failed permanently.
+   * Sends a request and optionally reads a response. Returns true if the request was successfully
+   * executed, and false if the request can be retried. Throws an exception if the request failed
+   * permanently.
    */
   private boolean execute(boolean readResponse) throws IOException {
+    boolean releaseConnection = true;
+    if (urlFilter != null) {
+      urlFilter.checkURLPermitted(httpEngine.getRequest().url().url());
+    }
     try {
       httpEngine.sendRequest();
-      route = httpEngine.getRoute();
-      handshake = httpEngine.getConnection() != null
-          ? httpEngine.getConnection().getHandshake()
-          : null;
+      Connection connection = httpEngine.getConnection();
+      if (connection != null) {
+        route = connection.route();
+        handshake = connection.handshake();
+      } else {
+        route = null;
+        handshake = null;
+      }
       if (readResponse) {
         httpEngine.readResponse();
       }
+      releaseConnection = false;
 
       return true;
     } catch (RequestException e) {
@@ -452,8 +492,9 @@ private boolean execute(boolean readResponse) throws IOException {
       throw toThrow;
     } catch (RouteException e) {
       // The attempt to connect via a route failed. The request will not have been sent.
-      HttpEngine retryEngine = httpEngine.recover(e);
+      HttpEngine retryEngine = httpEngine.recover(e.getLastConnectException(), true);
       if (retryEngine != null) {
+        releaseConnection = false;
         httpEngine = retryEngine;
         return false;
       }
@@ -464,8 +505,9 @@ private boolean execute(boolean readResponse) throws IOException {
       throw toThrow;
     } catch (IOException e) {
       // An attempt to communicate with a server failed. The request may have been sent.
-      HttpEngine retryEngine = httpEngine.recover(e);
+      HttpEngine retryEngine = httpEngine.recover(e, false);
       if (retryEngine != null) {
+        releaseConnection = false;
         httpEngine = retryEngine;
         return false;
       }
@@ -473,24 +515,31 @@ private boolean execute(boolean readResponse) throws IOException {
       // Give up; recovery is not possible.
       httpEngineFailure = e;
       throw e;
+    } finally {
+      // We're throwing an unchecked exception. Release any resources.
+      if (releaseConnection) {
+        StreamAllocation streamAllocation = httpEngine.close();
+        streamAllocation.release();
+      }
     }
   }
 
   /**
    * Returns true if either:
+   *
    * <ul>
    *   <li>A specific proxy was explicitly configured for this connection.
    *   <li>The response has already been retrieved, and a proxy was {@link
    *       java.net.ProxySelector selected} in order to get it.
    * </ul>
    *
-   * <p><strong>Warning:</strong> This method may return false before attempting
-   * to connect and true afterwards.
+   * <p><strong>Warning:</strong> This method may return false before attempting to connect and true
+   * afterwards.
    */
   @Override public final boolean usingProxy() {
     Proxy proxy = route != null
-        ? route.getProxy()
-        : client.getProxy();
+        ? route.proxy()
+        : client.proxy();
     return proxy != null && proxy.type() != Proxy.Type.DIRECT;
   }
 
@@ -515,7 +564,7 @@ private boolean execute(boolean readResponse) throws IOException {
       //
       // Some implementations send a malformed HTTP header when faced with
       // such requests, we respect the spec and ignore the header.
-      Platform.get().logW("Ignoring header " + field + " because its value was null.");
+      Platform.get().log(WARN, "Ignoring header " + field + " because its value was null.", null);
       return;
     }
 
@@ -549,7 +598,7 @@ private boolean execute(boolean readResponse) throws IOException {
       //
       // Some implementations send a malformed HTTP header when faced with
       // such requests, we respect the spec and ignore the header.
-      Platform.get().logW("Ignoring header " + field + " because its value was null.");
+      Platform.get().log(WARN, "Ignoring header " + field + " because its value was null.", null);
       return;
     }
 
@@ -570,7 +619,7 @@ private boolean execute(boolean readResponse) throws IOException {
   private void setProtocols(String protocolsString, boolean append) {
     List<Protocol> protocolsList = new ArrayList<>();
     if (append) {
-      protocolsList.addAll(client.getProtocols());
+      protocolsList.addAll(client.protocols());
     }
     for (String protocol : protocolsString.split(",", -1)) {
       try {
@@ -579,7 +628,9 @@ private void setProtocols(String protocolsString, boolean append) {
         throw new IllegalStateException(e);
       }
     }
-    client.setProtocols(protocolsList);
+    client = client.newBuilder()
+        .protocols(protocolsList)
+        .build();
   }
 
   @Override public void setRequestMethod(String method) throws ProtocolException {
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpsURLConnectionImpl.java
similarity index 80%
rename from okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java
rename to okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpsURLConnectionImpl.java
index 2aba0872a8..1bf1fa6566 100644
--- a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpsURLConnectionImpl.java
@@ -14,13 +14,14 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.squareup.okhttp.internal.huc;
+package okhttp3.internal.huc;
 
-import com.squareup.okhttp.Handshake;
-import com.squareup.okhttp.OkHttpClient;
 import java.net.URL;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Handshake;
+import okhttp3.OkHttpClient;
+import okhttp3.internal.URLFilter;
 
 public final class HttpsURLConnectionImpl extends DelegatingHttpsURLConnection {
   private final HttpURLConnectionImpl delegate;
@@ -29,6 +30,10 @@ public HttpsURLConnectionImpl(URL url, OkHttpClient client) {
     this(new HttpURLConnectionImpl(url, client));
   }
 
+  public HttpsURLConnectionImpl(URL url, OkHttpClient client, URLFilter filter) {
+    this(new HttpURLConnectionImpl(url, client, filter));
+  }
+
   public HttpsURLConnectionImpl(HttpURLConnectionImpl delegate) {
     super(delegate);
     this.delegate = delegate;
@@ -48,19 +53,23 @@ public HttpsURLConnectionImpl(HttpURLConnectionImpl delegate) {
   }
 
   @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
-    delegate.client.setHostnameVerifier(hostnameVerifier);
+    delegate.client = delegate.client.newBuilder()
+        .hostnameVerifier(hostnameVerifier)
+        .build();
   }
 
   @Override public HostnameVerifier getHostnameVerifier() {
-    return delegate.client.getHostnameVerifier();
+    return delegate.client.hostnameVerifier();
   }
 
   @Override public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
-    delegate.client.setSslSocketFactory(sslSocketFactory);
+    delegate.client = delegate.client.newBuilder()
+        .sslSocketFactory(sslSocketFactory)
+        .build();
   }
 
   @Override public SSLSocketFactory getSSLSocketFactory() {
-    return delegate.client.getSslSocketFactory();
+    return delegate.client.sslSocketFactory();
   }
 
   @Override public long getContentLengthLong() {
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
similarity index 53%
rename from okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java
rename to okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
index ab792b9906..39f6066805 100644
--- a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
@@ -1,19 +1,25 @@
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.io.FileSystem;
-import com.squareup.okhttp.internal.io.InMemoryFileSystem;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.File;
 import java.io.IOException;
 import java.net.HttpURLConnection;
+import java.net.URL;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
 import java.util.TimeZone;
 import java.util.concurrent.TimeUnit;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.URLFilter;
+import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.BufferedSource;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -26,24 +32,31 @@
 
 public class OkUrlFactoryTest {
   @Rule public MockWebServer server = new MockWebServer();
+  @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
-  private FileSystem fileSystem = new InMemoryFileSystem();
   private OkUrlFactory factory;
+  private Cache cache;
 
   @Before public void setUp() throws IOException {
-    OkHttpClient client = new OkHttpClient();
-    client.setCache(new Cache(new File("/cache/"), 10 * 1024 * 1024, fileSystem));
+    cache = new Cache(new File("/cache/"), 10 * 1024 * 1024, fileSystem);
+    OkHttpClient client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
     factory = new OkUrlFactory(client);
   }
 
+  @After public void tearDown() throws IOException {
+    cache.delete();
+  }
+
   /**
-   * Response code 407 should only come from proxy servers. Android's client
-   * throws if it is sent by an origin server.
+   * Response code 407 should only come from proxy servers. Android's client throws if it is sent by
+   * an origin server.
    */
   @Test public void originServerSends407() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(407));
 
-    HttpURLConnection conn = factory.open(server.getUrl("/"));
+    HttpURLConnection conn = factory.open(server.url("/").url());
     try {
       conn.getResponseCode();
       fail();
@@ -54,7 +67,7 @@
   @Test public void networkResponseSourceHeader() throws Exception {
     server.enqueue(new MockResponse().setBody("Isla Sorna"));
 
-    HttpURLConnection connection = factory.open(server.getUrl("/"));
+    HttpURLConnection connection = factory.open(server.url("/").url());
     assertResponseHeader(connection, "NETWORK 200");
     assertResponseBody(connection, "Isla Sorna");
   }
@@ -62,8 +75,9 @@
   @Test public void networkFailureResponseSourceHeader() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    HttpURLConnection connection = factory.open(server.getUrl("/"));
+    HttpURLConnection connection = factory.open(server.url("/").url());
     assertResponseHeader(connection, "NETWORK 404");
+    connection.getErrorStream().close();
   }
 
   @Test public void conditionalCacheHitResponseSourceHeaders() throws Exception {
@@ -73,11 +87,11 @@
         .setBody("Isla Nublar"));
     server.enqueue(new MockResponse().setResponseCode(304));
 
-    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    HttpURLConnection connection1 = factory.open(server.url("/").url());
     assertResponseHeader(connection1, "NETWORK 200");
     assertResponseBody(connection1, "Isla Nublar");
 
-    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    HttpURLConnection connection2 = factory.open(server.url("/").url());
     assertResponseHeader(connection2, "CONDITIONAL_CACHE 304");
     assertResponseBody(connection2, "Isla Nublar");
   }
@@ -89,11 +103,11 @@
         .setBody("Isla Nublar"));
     server.enqueue(new MockResponse().setBody("Isla Sorna"));
 
-    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    HttpURLConnection connection1 = factory.open(server.url("/").url());
     assertResponseHeader(connection1, "NETWORK 200");
     assertResponseBody(connection1, "Isla Nublar");
 
-    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    HttpURLConnection connection2 = factory.open(server.url("/").url());
     assertResponseHeader(connection2, "CONDITIONAL_CACHE 200");
     assertResponseBody(connection2, "Isla Sorna");
   }
@@ -103,11 +117,11 @@
         .addHeader("Expires: " + formatDate(2, TimeUnit.HOURS))
         .setBody("Isla Nublar"));
 
-    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    HttpURLConnection connection1 = factory.open(server.url("/").url());
     assertResponseHeader(connection1, "NETWORK 200");
     assertResponseBody(connection1, "Isla Nublar");
 
-    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    HttpURLConnection connection2 = factory.open(server.url("/").url());
     assertResponseHeader(connection2, "CACHE 200");
     assertResponseBody(connection2, "Isla Nublar");
   }
@@ -115,11 +129,11 @@
   @Test public void noneResponseSourceHeaders() throws Exception {
     server.enqueue(new MockResponse().setBody("Isla Nublar"));
 
-    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    HttpURLConnection connection1 = factory.open(server.url("/").url());
     assertResponseHeader(connection1, "NETWORK 200");
     assertResponseBody(connection1, "Isla Nublar");
 
-    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    HttpURLConnection connection2 = factory.open(server.url("/").url());
     connection2.setRequestProperty("Cache-Control", "only-if-cached");
     assertResponseHeader(connection2, "NONE");
   }
@@ -133,20 +147,81 @@ public void setInstanceFollowRedirectsFalse() throws Exception {
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    HttpURLConnection connection = factory.open(server.getUrl("/a"));
+    HttpURLConnection connection = factory.open(server.url("/a").url());
     connection.setInstanceFollowRedirects(false);
     assertResponseBody(connection, "A");
     assertResponseCode(connection, 302);
   }
 
+  @Test
+  public void testURLFilter() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+    final URL blockedURL = server.url("/a").url();
+    factory.setUrlFilter(new URLFilter() {
+      @Override
+      public void checkURLPermitted(URL url) throws IOException {
+        if (blockedURL.equals(url)) {
+          throw new IOException("Blocked");
+        }
+      }
+    });
+    try {
+      HttpURLConnection connection = factory.open(server.url("/a").url());
+      connection.getInputStream();
+      fail("Connection was successful");
+    } catch (IOException e) {
+      assertEquals("Blocked", e.getMessage());
+    }
+    HttpURLConnection connection = factory.open(server.url("/b").url());
+    assertResponseBody(connection, "B");
+  }
+
+  @Test
+  public void testURLFilterRedirect() throws Exception {
+    MockWebServer cleartextServer = new MockWebServer();
+    cleartextServer.enqueue(new MockResponse()
+        .setBody("Blocked!"));
+    final URL blockedURL = cleartextServer.url("/").url();
+
+    SSLContext context = SslContextBuilder.localhost();
+    server.useHttps(context.getSocketFactory(), false);
+    factory.setClient(factory.client().newBuilder()
+        .sslSocketFactory(context.getSocketFactory())
+        .followSslRedirects(true)
+        .build());
+    factory.setUrlFilter(new URLFilter() {
+      @Override
+      public void checkURLPermitted(URL url) throws IOException {
+        if (blockedURL.equals(url)) {
+          throw new IOException("Blocked");
+        }
+      }
+    });
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: " + blockedURL)
+        .setBody("This page has moved"));
+    URL destination = server.url("/").url();
+    try {
+      HttpsURLConnection httpsConnection = (HttpsURLConnection) factory.open(destination);
+      httpsConnection.getInputStream();
+      fail("Connection was successful");
+    } catch (IOException e) {
+      assertEquals("Blocked", e.getMessage());
+    }
+  }
+
   private void assertResponseBody(HttpURLConnection connection, String expected) throws Exception {
-    String actual = buffer(source(connection.getInputStream())).readString(US_ASCII);
+    BufferedSource source = buffer(source(connection.getInputStream()));
+    String actual = source.readString(US_ASCII);
+    source.close();
     assertEquals(expected, actual);
   }
 
   private void assertResponseHeader(HttpURLConnection connection, String expected) {
-    final String headerFieldPrefix = Platform.get().getPrefix();
-    assertEquals(expected, connection.getHeaderField(headerFieldPrefix + "-Response-Source"));
+    assertEquals(expected, connection.getHeaderField(OkHeaders.RESPONSE_SOURCE));
   }
 
   private void assertResponseCode(HttpURLConnection connection, int expected) throws IOException {
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
similarity index 76%
rename from okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
rename to okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
index 0af815b14e..a5b1107868 100644
--- a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
@@ -14,16 +14,8 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.io.FileSystem;
-import com.squareup.okhttp.internal.io.InMemoryFileSystem;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
+package okhttp3;
+
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -31,9 +23,7 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
-import java.net.CookieHandler;
 import java.net.CookieManager;
-import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.ResponseCache;
 import java.net.URL;
@@ -42,7 +32,6 @@
 import java.security.cert.Certificate;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
 import java.util.List;
@@ -53,6 +42,13 @@
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
+import okhttp3.internal.Internal;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.internal.Util;
+import okhttp3.internal.io.InMemoryFileSystem;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -62,7 +58,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 
-import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -81,27 +77,29 @@
 
   @Rule public MockWebServer server = new MockWebServer();
   @Rule public MockWebServer server2 = new MockWebServer();
+  @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
   private final SSLContext sslContext = SslContextBuilder.localhost();
-  private final FileSystem fileSystem = new InMemoryFileSystem();
-  private final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
+  private OkUrlFactory urlFactory = new OkUrlFactory(new OkHttpClient());
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
 
   @Before public void setUp() throws Exception {
     server.setProtocolNegotiationEnabled(false);
     cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-    client.client().setCache(cache);
-    CookieHandler.setDefault(cookieManager);
+    urlFactory = new OkUrlFactory(new OkHttpClient.Builder()
+        .cache(cache)
+        .cookieJar(new JavaNetCookieJar(cookieManager))
+        .build());
   }
 
   @After public void tearDown() throws Exception {
     ResponseCache.setDefault(null);
-    CookieHandler.setDefault(null);
+    cache.delete();
   }
 
   @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
-    assertSame(cache, client.client().getCache());
+    assertSame(cache, urlFactory.client().cache());
   }
 
   /**
@@ -109,60 +107,62 @@
    * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
    */
   @Test public void responseCachingByResponseCode() throws Exception {
-      // Test each documented HTTP/1.1 code, plus the first unused value in each range.
-      // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
-
-      // We can't test 100 because it's not really a response.
-      // assertCached(false, 100);
-      assertCached(false, 101);
-      assertCached(false, 102);
-      assertCached(true,  200);
-      assertCached(false, 201);
-      assertCached(false, 202);
-      assertCached(true,  203);
-      assertCached(true,  204);
-      assertCached(false, 205);
-      assertCached(false, 206); //Electing to not cache partial responses
-      assertCached(false, 207);
-      assertCached(true,  300);
-      assertCached(true,  301);
-      assertCached(true,  302);
-      assertCached(false, 303);
-      assertCached(false, 304);
-      assertCached(false, 305);
-      assertCached(false, 306);
-      assertCached(true,  307);
-      assertCached(true,  308);
-      assertCached(false, 400);
-      assertCached(false, 401);
-      assertCached(false, 402);
-      assertCached(false, 403);
-      assertCached(true,  404);
-      assertCached(true,  405);
-      assertCached(false, 406);
-      assertCached(false, 408);
-      assertCached(false, 409);
-      // the HTTP spec permits caching 410s, but the RI doesn't.
-      assertCached(true,  410);
-      assertCached(false, 411);
-      assertCached(false, 412);
-      assertCached(false, 413);
-      assertCached(true,  414);
-      assertCached(false, 415);
-      assertCached(false, 416);
-      assertCached(false, 417);
-      assertCached(false, 418);
-
-      assertCached(false, 500);
-      assertCached(true,  501);
-      assertCached(false, 502);
-      assertCached(false, 503);
-      assertCached(false, 504);
-      assertCached(false, 505);
-      assertCached(false, 506);
+    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
+    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
+
+    // We can't test 100 because it's not really a response.
+    // assertCached(false, 100);
+    assertCached(false, 101);
+    assertCached(false, 102);
+    assertCached(true, 200);
+    assertCached(false, 201);
+    assertCached(false, 202);
+    assertCached(true, 203);
+    assertCached(true, 204);
+    assertCached(false, 205);
+    assertCached(false, 206); //Electing to not cache partial responses
+    assertCached(false, 207);
+    assertCached(true, 300);
+    assertCached(true, 301);
+    assertCached(true, 302);
+    assertCached(false, 303);
+    assertCached(false, 304);
+    assertCached(false, 305);
+    assertCached(false, 306);
+    assertCached(true, 307);
+    assertCached(true, 308);
+    assertCached(false, 400);
+    assertCached(false, 401);
+    assertCached(false, 402);
+    assertCached(false, 403);
+    assertCached(true, 404);
+    assertCached(true, 405);
+    assertCached(false, 406);
+    assertCached(false, 408);
+    assertCached(false, 409);
+    // the HTTP spec permits caching 410s, but the RI doesn't.
+    assertCached(true, 410);
+    assertCached(false, 411);
+    assertCached(false, 412);
+    assertCached(false, 413);
+    assertCached(true, 414);
+    assertCached(false, 415);
+    assertCached(false, 416);
+    assertCached(false, 417);
+    assertCached(false, 418);
+
+    assertCached(false, 500);
+    assertCached(true, 501);
+    assertCached(false, 502);
+    assertCached(false, 503);
+    assertCached(false, 504);
+    assertCached(false, 505);
+    assertCached(false, 506);
   }
 
   private void assertCached(boolean shouldPut, int responseCode) throws Exception {
+    int expectedResponseCode = responseCode;
+
     server = new MockWebServer();
     MockResponse response = new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
@@ -176,11 +176,22 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
       response.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
     }
     server.enqueue(response);
+
+    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
+      // 408's are a bit of an outlier because we may repeat the request if we encounter this
+      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
+      // because of the retry. We just want to ensure the initial 408 isn't cached.
+      expectedResponseCode = 200;
+      server.enqueue(new MockResponse()
+          .addHeader("Cache-Control", "no-store")
+          .setBody("FGHIJ"));
+    }
+
     server.start();
 
-    URL url = server.getUrl("/");
-    HttpURLConnection conn = client.open(url);
-    assertEquals(responseCode, conn.getResponseCode());
+    URL url = server.url("/").url();
+    HttpURLConnection conn = urlFactory.open(url);
+    assertEquals(expectedResponseCode, conn.getResponseCode());
 
     // exhaust the content stream
     readAscii(conn);
@@ -220,17 +231,17 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(response);
 
     // Make sure that calling skip() doesn't omit bytes from the cache.
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    HttpURLConnection urlConnection = urlFactory.open(server.url("/").url());
     InputStream in = urlConnection.getInputStream();
     assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
     reliableSkip(in, "puppies but hate ".length());
     assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
     assertEquals(-1, in.read());
     in.close();
-    assertEquals(1, cache.getWriteSuccessCount());
-    assertEquals(0, cache.getWriteAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
+    assertEquals(0, cache.writeAbortCount());
 
-    urlConnection = client.open(server.getUrl("/")); // cached!
+    urlConnection = urlFactory.open(server.url("/").url()); // cached!
     in = urlConnection.getInputStream();
     assertEquals("I love puppies but hate spiders",
         readAscii(urlConnection, "I love puppies but hate spiders".length()));
@@ -239,10 +250,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
     assertEquals(-1, in.read());
     in.close();
-    assertEquals(1, cache.getWriteSuccessCount());
-    assertEquals(0, cache.getWriteAbortCount());
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(1, cache.writeSuccessCount());
+    assertEquals(0, cache.writeAbortCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.hitCount());
   }
 
   @Test public void secureResponseCaching() throws IOException {
@@ -251,7 +262,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
-    HttpsURLConnection c1 = (HttpsURLConnection) client.open(server.getUrl("/"));
+    HttpsURLConnection c1 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
     c1.setSSLSocketFactory(sslContext.getSocketFactory());
     c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     assertEquals("ABC", readAscii(c1));
@@ -263,14 +274,14 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Principal peerPrincipal = c1.getPeerPrincipal();
     Principal localPrincipal = c1.getLocalPrincipal();
 
-    HttpsURLConnection c2 = (HttpsURLConnection) client.open(server.getUrl("/")); // cached!
+    HttpsURLConnection c2 = (HttpsURLConnection) urlFactory.open(server.url("/").url()); // cached!
     c2.setSSLSocketFactory(sslContext.getSocketFactory());
     c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     assertEquals("ABC", readAscii(c2));
 
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(1, cache.hitCount());
 
     assertEquals(suite, c2.getCipherSuite());
     assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
@@ -289,15 +300,15 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("ABC", readAscii(connection));
 
-    connection = client.open(server.getUrl("/")); // cached!
+    connection = urlFactory.open(server.url("/").url()); // cached!
     assertEquals("ABC", readAscii(connection));
 
-    assertEquals(4, cache.getRequestCount()); // 2 requests + 2 redirects
-    assertEquals(2, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 requests + 2 redirects
+    assertEquals(2, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void redirectToCachedResult() throws Exception {
@@ -306,18 +317,18 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Location: /foo"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
-    assertEquals("ABC", readAscii(client.open(server.getUrl("/foo"))));
+    assertEquals("ABC", readAscii(urlFactory.open(server.url("/foo").url())));
     RecordedRequest request1 = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
     assertEquals(0, request1.getSequenceNumber());
 
-    assertEquals("ABC", readAscii(client.open(server.getUrl("/bar"))));
+    assertEquals("ABC", readAscii(urlFactory.open(server.url("/bar").url())));
     RecordedRequest request2 = server.takeRequest();
     assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
     assertEquals(1, request2.getSequenceNumber());
 
     // an unrelated request should reuse the pooled connection
-    assertEquals("DEF", readAscii(client.open(server.getUrl("/baz"))));
+    assertEquals("DEF", readAscii(urlFactory.open(server.url("/baz").url())));
     RecordedRequest request3 = server.takeRequest();
     assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
     assertEquals(2, request3.getSequenceNumber());
@@ -334,28 +345,29 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build());
 
-    HttpsURLConnection connection1 = (HttpsURLConnection) client.open(server.getUrl("/"));
+    HttpsURLConnection connection1 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
     assertEquals("ABC", readAscii(connection1));
     assertNotNull(connection1.getCipherSuite());
 
     // Cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) client.open(server.getUrl("/"));
+    HttpsURLConnection connection2 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
     assertEquals("ABC", readAscii(connection2));
     assertNotNull(connection2.getCipherSuite());
 
-    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.hitCount());
     assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
   }
 
   /**
-   * We've had bugs where caching and cross-protocol redirects yield class
-   * cast exceptions internal to the cache because we incorrectly assumed that
-   * HttpsURLConnection was always HTTPS and HttpURLConnection was always HTTP;
-   * in practice redirects mean that each can do either.
+   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
+   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
+   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
    *
    * https://github.com/square/okhttp/issues/214
    */
@@ -369,20 +381,22 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: " + server2.getUrl("/")));
+        .addHeader("Location: " + server2.url("/").url()));
 
-    client.client().setSslSocketFactory(sslContext.getSocketFactory());
-    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build());
 
-    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals("ABC", readAscii(connection1));
 
     // Cached!
-    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("ABC", readAscii(connection2));
 
-    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.getHitCount());
+    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
@@ -406,7 +420,7 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(new MockResponse().setBody("Request #2"));
 
     BufferedReader reader = new BufferedReader(
-        new InputStreamReader(client.open(server.getUrl("/")).getInputStream()));
+        new InputStreamReader(urlFactory.open(server.url("/").url()).getInputStream()));
     assertEquals("ABCDE", reader.readLine());
     try {
       reader.readLine();
@@ -416,12 +430,12 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
       reader.close();
     }
 
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(0, cache.getWriteSuccessCount());
-    URLConnection connection = client.open(server.getUrl("/"));
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(0, cache.writeSuccessCount());
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("Request #2", readAscii(connection));
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(1, cache.getWriteSuccessCount());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
   }
 
   @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
@@ -443,7 +457,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(response);
     server.enqueue(new MockResponse().setBody("Request #2"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     InputStream in = connection.getInputStream();
     assertEquals("ABCDE", readAscii(connection, 5));
     in.close();
@@ -453,12 +467,12 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     } catch (IOException expected) {
     }
 
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(0, cache.getWriteSuccessCount());
-    connection = client.open(server.getUrl("/"));
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(0, cache.writeSuccessCount());
+    connection = urlFactory.open(server.url("/").url());
     assertEquals("Request #2", readAscii(connection));
-    assertEquals(1, cache.getWriteAbortCount());
-    assertEquals(1, cache.getWriteSuccessCount());
+    assertEquals(1, cache.writeAbortCount());
+    assertEquals(1, cache.writeSuccessCount());
   }
 
   @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
@@ -471,9 +485,9 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
             .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
             .setBody("A"));
 
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(client.open(url)));
-    URLConnection connection = client.open(url);
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    URLConnection connection = urlFactory.open(url);
     assertEquals("A", readAscii(connection));
     assertNull(connection.getHeaderField("Warning"));
   }
@@ -499,8 +513,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
         .setBody("A"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    URLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection));
     assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
         connection.getHeaderField("Warning"));
@@ -513,9 +527,9 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/?foo=bar");
-    assertEquals("A", readAscii(client.open(url)));
-    assertEquals("B", readAscii(client.open(url)));
+    URL url = server.url("/?foo=bar").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("B", readAscii(urlFactory.open(url)));
   }
 
   @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
@@ -627,15 +641,15 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
         .addHeader("X-Response-ID: 1"));
     server.enqueue(new MockResponse().addHeader("X-Response-ID: 2"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
 
-    HttpURLConnection request1 = client.open(url);
+    HttpURLConnection request1 = urlFactory.open(url);
     request1.setRequestMethod(requestMethod);
     addRequestBodyIfNecessary(requestMethod, request1);
     request1.getInputStream().close();
     assertEquals("1", request1.getHeaderField("X-Response-ID"));
 
-    URLConnection request2 = client.open(url);
+    URLConnection request2 = urlFactory.open(url);
     request2.getInputStream().close();
     if (expectCached) {
       assertEquals("1", request2.getHeaderField("X-Response-ID"));
@@ -665,16 +679,16 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     server.enqueue(new MockResponse().setBody("B"));
     server.enqueue(new MockResponse().setBody("C"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
 
-    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
 
-    HttpURLConnection invalidate = client.open(url);
+    HttpURLConnection invalidate = urlFactory.open(url);
     invalidate.setRequestMethod(requestMethod);
     addRequestBodyIfNecessary(requestMethod, invalidate);
     assertEquals("B", readAscii(invalidate));
 
-    assertEquals("C", readAscii(client.open(url)));
+    assertEquals("C", readAscii(urlFactory.open(url)));
   }
 
   @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
@@ -686,16 +700,16 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     server.enqueue(new MockResponse().setBody("B").setResponseCode(500));
     server.enqueue(new MockResponse().setBody("C"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
 
-    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
 
-    HttpURLConnection invalidate = client.open(url);
+    HttpURLConnection invalidate = urlFactory.open(url);
     invalidate.setRequestMethod("POST");
     addRequestBodyIfNecessary("POST", invalidate);
     assertEquals("B", readAscii(invalidate));
 
-    assertEquals("C", readAscii(client.open(url)));
+    assertEquals("C", readAscii(urlFactory.open(url)));
   }
 
   @Test public void etag() throws Exception {
@@ -765,13 +779,13 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .addHeader("Content-Range: bytes 1000-1001/2000"));
     server.enqueue(new MockResponse().setBody("BB"));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
 
-    URLConnection range = client.open(url);
+    URLConnection range = urlFactory.open(url);
     range.addRequestProperty("Range", "bytes=1000-1001");
     assertEquals("AA", readAscii(range));
 
-    assertEquals("BB", readAscii(client.open(url)));
+    assertEquals("BB", readAscii(urlFactory.open(url)));
   }
 
   @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
@@ -781,10 +795,10 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     server.enqueue(new MockResponse().setBody("B")
         .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
 
-    assertEquals("A", readAscii(client.open(url)));
-    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
   }
 
   @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
@@ -808,9 +822,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     // At least three request/response pairs are required because after the first request is cached
     // a different execution path might be taken. Thus modifications to the cache applied during
     // the second request might not be visible until another request is performed.
-    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void notModifiedSpecifiesEncoding() throws Exception {
@@ -825,9 +839,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("DEFDEFDEF"));
 
-    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("DEFDEFDEF", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("DEFDEFDEF", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   /** https://github.com/square/okhttp/issues/947 */
@@ -839,8 +853,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=60"));
     server.enqueue(new MockResponse().setBody("FAIL"));
 
-    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
@@ -849,13 +863,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    ConnectionPool pool = ConnectionPool.getDefault();
-    pool.evictAll();
-    client.client().setConnectionPool(pool);
-
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals(1, client.client().getConnectionPool().getConnectionCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(1, urlFactory.client().connectionPool().idleConnectionCount());
   }
 
   @Test public void expiresDateBeforeModifiedDate() throws Exception {
@@ -871,9 +881,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "max-age=30");
     assertEquals("B", readAscii(connection));
   }
@@ -884,9 +894,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "min-fresh=120");
     assertEquals("B", readAscii(connection));
   }
@@ -897,9 +907,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "max-stale=180");
     assertEquals("A", readAscii(connection));
     assertEquals("110 HttpURLConnection \"Response is stale\"",
@@ -912,9 +922,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "max-stale=180");
     assertEquals("B", readAscii(connection));
   }
@@ -922,12 +932,12 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
     // (no responses enqueued)
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(0, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(1, cache.requestCount());
+    assertEquals(0, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
@@ -935,13 +945,13 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    URLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(1, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
@@ -949,25 +959,25 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals(2, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void requestCacheControlNoCache() throws Exception {
@@ -978,9 +988,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(client.open(url)));
-    URLConnection connection = client.open(url);
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    URLConnection connection = urlFactory.open(url);
     connection.setRequestProperty("Cache-Control", "no-cache");
     assertEquals("B", readAscii(connection));
   }
@@ -993,9 +1003,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(client.open(url)));
-    URLConnection connection = client.open(url);
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    URLConnection connection = urlFactory.open(url);
     connection.setRequestProperty("Pragma", "no-cache");
     assertEquals("B", readAscii(connection));
   }
@@ -1025,10 +1035,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(seed.setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(client.open(url)));
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
 
-    HttpURLConnection connection = client.open(url);
+    HttpURLConnection connection = urlFactory.open(url);
     connection.addRequestProperty(conditionName, conditionValue);
     assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
     assertEquals("", readAscii(connection));
@@ -1038,16 +1048,16 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   /**
-   * Confirm that {@link URLConnection#setIfModifiedSince} causes an
-   * If-Modified-Since header with a GMT timestamp.
+   * Confirm that {@link URLConnection#setIfModifiedSince} causes an If-Modified-Since header with a
+   * GMT timestamp.
    *
    * https://code.google.com/p/android/issues/detail?id=66135
    */
   @Test public void setIfModifiedSince() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
 
-    URL url = server.getUrl("/");
-    URLConnection connection = client.open(url);
+    URL url = server.url("/").url();
+    URLConnection connection = urlFactory.open(url);
     connection.setIfModifiedSince(1393666200000L);
     assertEquals("A", readAscii(connection));
     RecordedRequest request = server.takeRequest();
@@ -1056,8 +1066,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   /**
-   * For Last-Modified and Date headers, we should echo the date back in the
-   * exact format we were served.
+   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
+   * served.
    */
   @Test public void retainServedDateFormat() throws Exception {
     // Serve a response with a non-standard date format that OkHttp supports.
@@ -1076,8 +1086,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
 
     // The first request has no conditions.
     RecordedRequest request1 = server.takeRequest();
@@ -1091,7 +1101,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
     connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
     assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
@@ -1102,11 +1112,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    URLConnection connection = client.open(url);
+    URL url = server.url("/").url();
+    URLConnection connection = urlFactory.open(url);
     connection.addRequestProperty("Authorization", "password");
     assertEquals("A", readAscii(connection));
-    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
   }
 
   @Test public void contentLocationDoesNotPopulateCache() throws Exception {
@@ -1115,8 +1125,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/foo"))));
-    assertEquals("B", readAscii(client.open(server.getUrl("/bar"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/foo").url())));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/bar").url())));
   }
 
   @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
@@ -1124,10 +1134,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.setUseCaches(false);
     assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
@@ -1135,22 +1145,22 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    URLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.setUseCaches(false);
     assertEquals("B", readAscii(connection));
   }
 
   @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
     URL url = new URL("http://localhost/");
-    URLConnection c1 = client.open(url);
-    URLConnection c2 = client.open(url);
+    URLConnection c1 = urlFactory.open(url);
+    URLConnection c2 = urlFactory.open(url);
     assertTrue(c1.getDefaultUseCaches());
     c1.setDefaultUseCaches(false);
     try {
       assertTrue(c1.getUseCaches());
       assertTrue(c2.getUseCaches());
-      URLConnection c3 = client.open(url);
+      URLConnection c3 = urlFactory.open(url);
       assertFalse(c3.getUseCaches());
     } finally {
       c1.setDefaultUseCaches(true);
@@ -1164,9 +1174,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/a"))));
-    assertEquals("A", readAscii(client.open(server.getUrl("/a"))));
-    assertEquals("B", readAscii(client.open(server.getUrl("/b"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/a").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/a").url())));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/b").url())));
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
@@ -1180,15 +1190,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setBody("B"));
     server.enqueue(new MockResponse().setBody("C"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("C", readAscii(client.open(server.getUrl("/"))));
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(3, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("C", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(3, cache.requestCount());
+    assertEquals(3, cache.networkCount());
+    assertEquals(0, cache.hitCount());
   }
 
   @Test public void statisticsConditionalCacheHit() throws Exception {
@@ -1198,29 +1208,29 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(3, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(3, cache.requestCount());
+    assertEquals(3, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void statisticsFullCacheHit() throws Exception {
     server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(1, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(0, cache.hitCount());
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals(3, cache.requestCount());
+    assertEquals(1, cache.networkCount());
+    assertEquals(2, cache.hitCount());
   }
 
   @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
@@ -1229,12 +1239,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    HttpURLConnection frConnection = client.open(url);
+    URL url = server.url("/").url();
+    HttpURLConnection frConnection = urlFactory.open(url);
     frConnection.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(frConnection));
 
-    HttpURLConnection enConnection = client.open(url);
+    HttpURLConnection enConnection = urlFactory.open(url);
     enConnection.addRequestProperty("Accept-Language", "en-US");
     assertEquals("B", readAscii(enConnection));
   }
@@ -1245,11 +1255,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    URLConnection connection1 = client.open(url);
+    URL url = server.url("/").url();
+    URLConnection connection1 = urlFactory.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = client.open(url);
+    URLConnection connection2 = urlFactory.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(connection2));
   }
@@ -1260,8 +1270,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
@@ -1270,8 +1280,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    URLConnection fooConnection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection fooConnection = urlFactory.open(server.url("/").url());
     fooConnection.addRequestProperty("Foo", "bar");
     assertEquals("B", readAscii(fooConnection));
   }
@@ -1282,10 +1292,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URLConnection fooConnection = client.open(server.getUrl("/"));
+    URLConnection fooConnection = urlFactory.open(server.url("/").url());
     fooConnection.addRequestProperty("Foo", "bar");
     assertEquals("A", readAscii(fooConnection));
-    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void varyFieldsAreCaseInsensitive() throws Exception {
@@ -1294,11 +1304,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    URLConnection connection1 = client.open(url);
+    URL url = server.url("/").url();
+    URLConnection connection1 = urlFactory.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = client.open(url);
+    URLConnection connection2 = urlFactory.open(url);
     connection2.addRequestProperty("accept-language", "fr-CA");
     assertEquals("A", readAscii(connection2));
   }
@@ -1310,13 +1320,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    URLConnection connection1 = client.open(url);
+    URL url = server.url("/").url();
+    URLConnection connection1 = urlFactory.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA");
     connection1.addRequestProperty("Accept-Charset", "UTF-8");
     connection1.addRequestProperty("Accept-Encoding", "identity");
     assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = client.open(url);
+    URLConnection connection2 = urlFactory.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA");
     connection2.addRequestProperty("Accept-Charset", "UTF-8");
     connection2.addRequestProperty("Accept-Encoding", "identity");
@@ -1330,13 +1340,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    URLConnection frConnection = client.open(url);
+    URL url = server.url("/").url();
+    URLConnection frConnection = urlFactory.open(url);
     frConnection.addRequestProperty("Accept-Language", "fr-CA");
     frConnection.addRequestProperty("Accept-Charset", "UTF-8");
     frConnection.addRequestProperty("Accept-Encoding", "identity");
     assertEquals("A", readAscii(frConnection));
-    URLConnection enConnection = client.open(url);
+    URLConnection enConnection = urlFactory.open(url);
     enConnection.addRequestProperty("Accept-Language", "en-CA");
     enConnection.addRequestProperty("Accept-Charset", "UTF-8");
     enConnection.addRequestProperty("Accept-Encoding", "identity");
@@ -1349,13 +1359,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    URLConnection connection1 = client.open(url);
+    URL url = server.url("/").url();
+    URLConnection connection1 = urlFactory.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
-    URLConnection connection2 = client.open(url);
+    URLConnection connection2 = urlFactory.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
     connection2.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection2));
@@ -1367,13 +1377,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    URLConnection connection1 = client.open(url);
+    URL url = server.url("/").url();
+    URLConnection connection1 = urlFactory.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
-    URLConnection connection2 = client.open(url);
+    URLConnection connection2 = urlFactory.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA");
     connection2.addRequestProperty("Accept-Language", "en-US");
     assertEquals("B", readAscii(connection2));
@@ -1385,8 +1395,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
   }
 
   @Test public void varyAndHttps() throws Exception {
@@ -1396,14 +1406,14 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    HttpsURLConnection connection1 = (HttpsURLConnection) client.open(url);
+    URL url = server.url("/").url();
+    HttpsURLConnection connection1 = (HttpsURLConnection) urlFactory.open(url);
     connection1.setSSLSocketFactory(sslContext.getSocketFactory());
     connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
-    HttpsURLConnection connection2 = (HttpsURLConnection) client.open(url);
+    HttpsURLConnection connection2 = (HttpsURLConnection) urlFactory.open(url);
     connection2.setSSLSocketFactory(sslContext.getSocketFactory());
     connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     connection2.addRequestProperty("Accept-Language", "en-US");
@@ -1411,20 +1421,26 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void cachePlusCookies() throws Exception {
-    server.enqueue(new MockResponse().addHeader(
-        "Set-Cookie: a=FIRST; domain=" + server.getCookieDomain() + ";")
+    RecordingCookieJar cookieJar = new RecordingCookieJar();
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .cookieJar(cookieJar)
+        .build());
+
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie: a=FIRST")
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
-    server.enqueue(new MockResponse().addHeader(
-        "Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie: a=SECOND")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(client.open(url)));
-    assertCookies(url, "a=FIRST");
-    assertEquals("A", readAscii(client.open(url)));
-    assertCookies(url, "a=SECOND");
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    cookieJar.assertResponseCookies("a=FIRST; path=/");
+
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    cookieJar.assertResponseCookies("a=SECOND; path=/");
   }
 
   @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
@@ -1435,11 +1451,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD, PUT")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URLConnection connection1 = client.open(server.getUrl("/"));
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection1));
     assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
 
-    URLConnection connection2 = client.open(server.getUrl("/"));
+    URLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection2));
     assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
   }
@@ -1452,11 +1468,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse().addHeader("Transfer-Encoding: none")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URLConnection connection1 = client.open(server.getUrl("/"));
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection1));
     assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
 
-    URLConnection connection2 = client.open(server.getUrl("/"));
+    URLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection2));
     assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
   }
@@ -1468,11 +1484,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URLConnection connection1 = client.open(server.getUrl("/"));
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection1));
     assertEquals("199 test danger", connection1.getHeaderField("Warning"));
 
-    URLConnection connection2 = client.open(server.getUrl("/"));
+    URLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection2));
     assertEquals(null, connection2.getHeaderField("Warning"));
   }
@@ -1484,28 +1500,20 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URLConnection connection1 = client.open(server.getUrl("/"));
+    URLConnection connection1 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection1));
     assertEquals("299 test danger", connection1.getHeaderField("Warning"));
 
-    URLConnection connection2 = client.open(server.getUrl("/"));
+    URLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection2));
     assertEquals("299 test danger", connection2.getHeaderField("Warning"));
   }
 
-  public void assertCookies(URL url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<>();
-    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
-      actualCookies.add(cookie.toString());
-    }
-    assertEquals(Arrays.asList(expectedCookies), actualCookies);
-  }
-
   @Test public void cachePlusRange() throws Exception {
     assertNotCached(new MockResponse().setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-            .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-            .addHeader("Content-Range: bytes 100-100/200")
-            .addHeader("Cache-Control: max-age=60"));
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 100-100/200")
+        .addHeader("Cache-Control: max-age=60"));
   }
 
   @Test public void conditionalHitUpdatesCache() throws Exception {
@@ -1518,18 +1526,18 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse().setBody("B"));
 
     // cache miss; seed the cache
-    HttpURLConnection connection1 = client.open(server.getUrl("/a"));
+    HttpURLConnection connection1 = urlFactory.open(server.url("/a").url());
     assertEquals("A", readAscii(connection1));
     assertEquals(null, connection1.getHeaderField("Allow"));
 
     // conditional cache hit; update the cache
-    HttpURLConnection connection2 = client.open(server.getUrl("/a"));
+    HttpURLConnection connection2 = urlFactory.open(server.url("/a").url());
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertEquals("A", readAscii(connection2));
     assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
 
     // full cache hit
-    HttpURLConnection connection3 = client.open(server.getUrl("/a"));
+    HttpURLConnection connection3 = urlFactory.open(server.url("/a").url());
     assertEquals("A", readAscii(connection3));
     assertEquals("GET, HEAD", connection3.getHeaderField("Allow"));
 
@@ -1541,8 +1549,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    URLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
   }
@@ -1555,8 +1563,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("B", readAscii(connection));
   }
 
@@ -1566,15 +1574,15 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setResponseCode(304));
 
-    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection));
   }
 
   @Test public void responseSourceHeaderFetched() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("A", readAscii(connection));
   }
 
@@ -1584,15 +1592,15 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     Internal.instance.addLenient(headers, ": A");
     server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("A", connection.getHeaderField(""));
+    assertEquals("body", readAscii(connection));
   }
 
   /**
-   * Old implementations of OkHttp's response cache wrote header fields like
-   * ":status: 200 OK". This broke our cached response parser because it split
-   * on the first colon. This regression test exists to help us read these old
-   * bad cache entries.
+   * Old implementations of OkHttp's response cache wrote header fields like ":status: 200 OK". This
+   * broke our cached response parser because it split on the first colon. This regression test
+   * exists to help us read these old bad cache entries.
    *
    * https://github.com/square/okhttp/issues/227
    */
@@ -1602,7 +1610,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URL url = server.getUrl("/");
+    URL url = server.url("/").url();
     String urlKey = Util.md5Hex(url.toString());
     String entryMetadata = ""
         + "" + url + "\n"
@@ -1636,13 +1644,15 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         + "2\n"
         + "\n"
         + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.getDirectory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.getDirectory(), urlKey + ".1", entryBody);
-    writeFile(cache.getDirectory(), "journal", journalBody);
-    cache = new Cache(cache.getDirectory(), Integer.MAX_VALUE, fileSystem);
-    client.client().setCache(cache);
-
-    HttpURLConnection connection = client.open(url);
+    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.directory(), urlKey + ".1", entryBody);
+    writeFile(cache.directory(), "journal", journalBody);
+    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .cache(cache)
+        .build());
+
+    HttpURLConnection connection = urlFactory.open(url);
     assertEquals(entryBody, readAscii(connection));
     assertEquals("3", connection.getHeaderField("Content-Length"));
     assertEquals("foo", connection.getHeaderField("etag"));
@@ -1655,9 +1665,8 @@ private void writeFile(File directory, String file, String content) throws IOExc
   }
 
   /**
-   * @param delta the offset from the current date to use. Negative
-   * values yield dates in the past; positive values yield dates in the
-   * future.
+   * @param delta the offset from the current date to use. Negative values yield dates in the past;
+   * positive values yield dates in the future.
    */
   private String formatDate(long delta, TimeUnit timeUnit) {
     return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
@@ -1683,9 +1692,9 @@ private void assertNotCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
 
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(client.open(url)));
-    assertEquals("B", readAscii(client.open(url)));
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("B", readAscii(urlFactory.open(url)));
   }
 
   /** @return the request with the conditional get headers. */
@@ -1698,22 +1707,22 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
 
-    URL valid = server.getUrl("/valid");
-    HttpURLConnection connection1 = client.open(valid);
+    URL valid = server.url("/valid").url();
+    HttpURLConnection connection1 = urlFactory.open(valid);
     assertEquals("A", readAscii(connection1));
     assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
     assertEquals("A-OK", connection1.getResponseMessage());
-    HttpURLConnection connection2 = client.open(valid);
+    HttpURLConnection connection2 = urlFactory.open(valid);
     assertEquals("A", readAscii(connection2));
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertEquals("A-OK", connection2.getResponseMessage());
 
-    URL invalid = server.getUrl("/invalid");
-    HttpURLConnection connection3 = client.open(invalid);
+    URL invalid = server.url("/invalid").url();
+    HttpURLConnection connection3 = urlFactory.open(invalid);
     assertEquals("B", readAscii(connection3));
     assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
     assertEquals("B-OK", connection3.getResponseMessage());
-    HttpURLConnection connection4 = client.open(invalid);
+    HttpURLConnection connection4 = urlFactory.open(invalid);
     assertEquals("C", readAscii(connection4));
     assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
     assertEquals("C-OK", connection4.getResponseMessage());
@@ -1726,15 +1735,14 @@ private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(response.setBody("B"));
 
-    URL url = server.getUrl("/");
-    assertEquals("A", readAscii(client.open(url)));
-    assertEquals("A", readAscii(client.open(url)));
+    URL url = server.url("/").url();
+    assertEquals("A", readAscii(urlFactory.open(url)));
+    assertEquals("A", readAscii(urlFactory.open(url)));
   }
 
   /**
-   * Shortens the body of {@code response} but not the corresponding headers.
-   * Only useful to test how clients respond to the premature conclusion of
-   * the HTTP body.
+   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
+   * how clients respond to the premature conclusion of the HTTP body.
    */
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
     response.setSocketPolicy(DISCONNECT_AT_END);
@@ -1747,9 +1755,8 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
   }
 
   /**
-   * Reads {@code count} characters from the stream. If the stream is
-   * exhausted before {@code count} characters can be read, the remaining
-   * characters are returned and the stream is closed.
+   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
+   * characters can be read, the remaining characters are returned and the stream is closed.
    */
   private String readAscii(URLConnection connection, int count) throws IOException {
     HttpURLConnection httpConnection = (HttpURLConnection) connection;
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/URLEncodingTest.java b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
similarity index 77%
rename from okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/URLEncodingTest.java
rename to okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
index 5a4ed10ac2..1cc63d8f34 100644
--- a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/URLEncodingTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
@@ -14,41 +14,36 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.huc;
-
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkUrlFactory;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.InternalCache;
-import com.squareup.okhttp.internal.http.CacheRequest;
-import com.squareup.okhttp.internal.http.CacheStrategy;
+package okhttp3.internal.huc;
 
 import java.io.IOException;
-import java.net.CacheResponse;
 import java.net.HttpURLConnection;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
-import java.util.List;
-import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.OkHttpClient;
+import okhttp3.OkUrlFactory;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Internal;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.http.CacheRequest;
+import okhttp3.internal.http.CacheStrategy;
 import org.junit.Ignore;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 
 /**
- * Exercises HttpURLConnection to convert URL to a URI. Unlike URL#toURI,
- * HttpURLConnection recovers from URLs with unescaped but unsupported URI
- * characters like '{' and '|' by escaping these characters.
+ * Exercises HttpURLConnection to convert URL to a URI. Unlike URL#toURI, HttpURLConnection recovers
+ * from URLs with unescaped but unsupported URI characters like '{' and '|' by escaping these
+ * characters.
  */
 public final class URLEncodingTest {
   /**
-   * This test goes through the exhaustive set of interesting ASCII characters
-   * because most of those characters are interesting in some way according to
-   * RFC 2396 and RFC 2732. http://b/1158780
+   * This test goes through the exhaustive set of interesting ASCII characters because most of those
+   * characters are interesting in some way according to RFC 2396 and RFC 2732. http://b/1158780
    */
   @Test @Ignore public void lenientUrlToUri() throws Exception {
     // alphanum
@@ -128,42 +123,32 @@ private void testUrlToUriMapping(String string, String asAuthority, String asFil
   private URI backdoorUrlToUri(URL url) throws Exception {
     final AtomicReference<URI> uriReference = new AtomicReference<>();
 
-    OkHttpClient client = new OkHttpClient();
-    Internal.instance.setCache(client, new InternalCache() {
-      @Override
-      public Response get(Request request) throws IOException {
-        uriReference.set(request.uri());
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    Internal.instance.setCache(builder, new InternalCache() {
+      @Override public Response get(Request request) throws IOException {
+        uriReference.set(request.url().uri());
         throw new UnsupportedOperationException();
       }
 
-      @Override
-      public CacheRequest put(Response response) throws IOException {
+      @Override public CacheRequest put(Response response) throws IOException {
         return null;
       }
 
-      @Override
-      public void remove(Request request) throws IOException {
-
+      @Override public void remove(Request request) throws IOException {
       }
 
-      @Override
-      public void update(Response cached, Response network) throws IOException {
-
+      @Override public void update(Response cached, Response network) throws IOException {
       }
 
-      @Override
-      public void trackConditionalCacheHit() {
-
+      @Override public void trackConditionalCacheHit() {
       }
 
-      @Override
-      public void trackResponse(CacheStrategy cacheStrategy) {
-
+      @Override public void trackResponse(CacheStrategy cacheStrategy) {
       }
     });
 
     try {
-      HttpURLConnection connection = new OkUrlFactory(client).open(url);
+      HttpURLConnection connection = new OkUrlFactory(builder.build()).open(url);
       connection.getResponseCode();
     } catch (Exception expected) {
       if (expected.getCause() instanceof URISyntaxException) {
diff --git a/okhttp-ws-tests/fuzzingserver-config.json b/okhttp-ws-tests/fuzzingserver-config.json
new file mode 100644
index 0000000000..99e06abb51
--- /dev/null
+++ b/okhttp-ws-tests/fuzzingserver-config.json
@@ -0,0 +1,153 @@
+{
+  "url": "ws://127.0.0.1:9001",
+  "outdir": "./target/fuzzingserver-report",
+  "cases": ["*"],
+  "exclude-cases": [
+    "6.1.1",
+    "6.1.2",
+    "6.1.3",
+    "6.2.1",
+    "6.2.2",
+    "6.2.3",
+    "6.2.4",
+    "6.3.1",
+    "6.3.2",
+    "6.4.1",
+    "6.4.2",
+    "6.4.3",
+    "6.4.4",
+    "6.5.1",
+    "6.5.2",
+    "6.5.3",
+    "6.5.4",
+    "6.5.5",
+    "6.6.1",
+    "6.6.2",
+    "6.6.3",
+    "6.6.4",
+    "6.6.5",
+    "6.6.6",
+    "6.6.7",
+    "6.6.8",
+    "6.6.9",
+    "6.6.10",
+    "6.6.11",
+    "6.7.1",
+    "6.7.2",
+    "6.7.3",
+    "6.7.4",
+    "6.8.1",
+    "6.8.2",
+    "6.9.1",
+    "6.9.2",
+    "6.9.3",
+    "6.9.4",
+    "6.10.1",
+    "6.10.2",
+    "6.10.3",
+    "6.11.1",
+    "6.11.2",
+    "6.11.3",
+    "6.11.4",
+    "6.11.5",
+    "6.12.1",
+    "6.12.2",
+    "6.12.3",
+    "6.12.4",
+    "6.12.5",
+    "6.12.6",
+    "6.12.7",
+    "6.12.8",
+    "6.13.1",
+    "6.13.2",
+    "6.13.3",
+    "6.13.4",
+    "6.13.5",
+    "6.14.1",
+    "6.14.2",
+    "6.14.3",
+    "6.14.4",
+    "6.14.5",
+    "6.14.6",
+    "6.14.7",
+    "6.14.8",
+    "6.14.9",
+    "6.14.10",
+    "6.15.1",
+    "6.16.1",
+    "6.16.2",
+    "6.16.3",
+    "6.17.1",
+    "6.17.2",
+    "6.17.3",
+    "6.17.4",
+    "6.17.5",
+    "6.18.1",
+    "6.18.2",
+    "6.18.3",
+    "6.18.4",
+    "6.18.5",
+    "6.19.1",
+    "6.19.2",
+    "6.19.3",
+    "6.19.4",
+    "6.19.5",
+    "6.20.1",
+    "6.20.2",
+    "6.20.3",
+    "6.20.4",
+    "6.20.5",
+    "6.20.6",
+    "6.20.7",
+    "6.21.1",
+    "6.21.2",
+    "6.21.3",
+    "6.21.4",
+    "6.21.5",
+    "6.21.6",
+    "6.21.7",
+    "6.21.8",
+    "6.22.1",
+    "6.22.2",
+    "6.22.3",
+    "6.22.4",
+    "6.22.5",
+    "6.22.6",
+    "6.22.7",
+    "6.22.8",
+    "6.22.9",
+    "6.22.10",
+    "6.22.11",
+    "6.22.12",
+    "6.22.13",
+    "6.22.14",
+    "6.22.15",
+    "6.22.16",
+    "6.22.17",
+    "6.22.18",
+    "6.22.19",
+    "6.22.20",
+    "6.22.21",
+    "6.22.22",
+    "6.22.23",
+    "6.22.24",
+    "6.22.25",
+    "6.22.26",
+    "6.22.27",
+    "6.22.28",
+    "6.22.29",
+    "6.22.30",
+    "6.22.31",
+    "6.22.32",
+    "6.22.33",
+    "6.22.34",
+    "6.23.1",
+    "6.23.2",
+    "6.23.3",
+    "6.23.4",
+    "6.23.5",
+    "6.23.6",
+    "6.23.7"
+  ],
+  "exclude-agent-cases": {}
+}
diff --git a/okhttp-ws-tests/fuzzingserver-expected.txt b/okhttp-ws-tests/fuzzingserver-expected.txt
new file mode 100644
index 0000000000..f4a3305f79
--- /dev/null
+++ b/okhttp-ws-tests/fuzzingserver-expected.txt
@@ -0,0 +1,376 @@
+"1.1.1 OK"
+"1.1.2 OK"
+"1.1.3 OK"
+"1.1.4 OK"
+"1.1.5 OK"
+"1.1.6 OK"
+"1.1.7 OK"
+"1.1.8 OK"
+"1.2.1 OK"
+"1.2.2 OK"
+"1.2.3 OK"
+"1.2.4 OK"
+"1.2.5 OK"
+"1.2.6 OK"
+"1.2.7 OK"
+"1.2.8 OK"
+"10.1.1 OK"
+"12.1.1 UNIMPLEMENTED"
+"12.1.10 UNIMPLEMENTED"
+"12.1.11 UNIMPLEMENTED"
+"12.1.12 UNIMPLEMENTED"
+"12.1.13 UNIMPLEMENTED"
+"12.1.14 UNIMPLEMENTED"
+"12.1.15 UNIMPLEMENTED"
+"12.1.16 UNIMPLEMENTED"
+"12.1.17 UNIMPLEMENTED"
+"12.1.18 UNIMPLEMENTED"
+"12.1.2 UNIMPLEMENTED"
+"12.1.3 UNIMPLEMENTED"
+"12.1.4 UNIMPLEMENTED"
+"12.1.5 UNIMPLEMENTED"
+"12.1.6 UNIMPLEMENTED"
+"12.1.7 UNIMPLEMENTED"
+"12.1.8 UNIMPLEMENTED"
+"12.1.9 UNIMPLEMENTED"
+"12.2.1 UNIMPLEMENTED"
+"12.2.10 UNIMPLEMENTED"
+"12.2.11 UNIMPLEMENTED"
+"12.2.12 UNIMPLEMENTED"
+"12.2.13 UNIMPLEMENTED"
+"12.2.14 UNIMPLEMENTED"
+"12.2.15 UNIMPLEMENTED"
+"12.2.16 UNIMPLEMENTED"
+"12.2.17 UNIMPLEMENTED"
+"12.2.18 UNIMPLEMENTED"
+"12.2.2 UNIMPLEMENTED"
+"12.2.3 UNIMPLEMENTED"
+"12.2.4 UNIMPLEMENTED"
+"12.2.5 UNIMPLEMENTED"
+"12.2.6 UNIMPLEMENTED"
+"12.2.7 UNIMPLEMENTED"
+"12.2.8 UNIMPLEMENTED"
+"12.2.9 UNIMPLEMENTED"
+"12.3.1 UNIMPLEMENTED"
+"12.3.10 UNIMPLEMENTED"
+"12.3.11 UNIMPLEMENTED"
+"12.3.12 UNIMPLEMENTED"
+"12.3.13 UNIMPLEMENTED"
+"12.3.14 UNIMPLEMENTED"
+"12.3.15 UNIMPLEMENTED"
+"12.3.16 UNIMPLEMENTED"
+"12.3.17 UNIMPLEMENTED"
+"12.3.18 UNIMPLEMENTED"
+"12.3.2 UNIMPLEMENTED"
+"12.3.3 UNIMPLEMENTED"
+"12.3.4 UNIMPLEMENTED"
+"12.3.5 UNIMPLEMENTED"
+"12.3.6 UNIMPLEMENTED"
+"12.3.7 UNIMPLEMENTED"
+"12.3.8 UNIMPLEMENTED"
+"12.3.9 UNIMPLEMENTED"
+"12.4.1 UNIMPLEMENTED"
+"12.4.10 UNIMPLEMENTED"
+"12.4.11 UNIMPLEMENTED"
+"12.4.12 UNIMPLEMENTED"
+"12.4.13 UNIMPLEMENTED"
+"12.4.14 UNIMPLEMENTED"
+"12.4.15 UNIMPLEMENTED"
+"12.4.16 UNIMPLEMENTED"
+"12.4.17 UNIMPLEMENTED"
+"12.4.18 UNIMPLEMENTED"
+"12.4.2 UNIMPLEMENTED"
+"12.4.3 UNIMPLEMENTED"
+"12.4.4 UNIMPLEMENTED"
+"12.4.5 UNIMPLEMENTED"
+"12.4.6 UNIMPLEMENTED"
+"12.4.7 UNIMPLEMENTED"
+"12.4.8 UNIMPLEMENTED"
+"12.4.9 UNIMPLEMENTED"
+"12.5.1 UNIMPLEMENTED"
+"12.5.10 UNIMPLEMENTED"
+"12.5.11 UNIMPLEMENTED"
+"12.5.12 UNIMPLEMENTED"
+"12.5.13 UNIMPLEMENTED"
+"12.5.14 UNIMPLEMENTED"
+"12.5.15 UNIMPLEMENTED"
+"12.5.16 UNIMPLEMENTED"
+"12.5.17 UNIMPLEMENTED"
+"12.5.18 UNIMPLEMENTED"
+"12.5.2 UNIMPLEMENTED"
+"12.5.3 UNIMPLEMENTED"
+"12.5.4 UNIMPLEMENTED"
+"12.5.5 UNIMPLEMENTED"
+"12.5.6 UNIMPLEMENTED"
+"12.5.7 UNIMPLEMENTED"
+"12.5.8 UNIMPLEMENTED"
+"12.5.9 UNIMPLEMENTED"
+"13.1.1 UNIMPLEMENTED"
+"13.1.10 UNIMPLEMENTED"
+"13.1.11 UNIMPLEMENTED"
+"13.1.12 UNIMPLEMENTED"
+"13.1.13 UNIMPLEMENTED"
+"13.1.14 UNIMPLEMENTED"
+"13.1.15 UNIMPLEMENTED"
+"13.1.16 UNIMPLEMENTED"
+"13.1.17 UNIMPLEMENTED"
+"13.1.18 UNIMPLEMENTED"
+"13.1.2 UNIMPLEMENTED"
+"13.1.3 UNIMPLEMENTED"
+"13.1.4 UNIMPLEMENTED"
+"13.1.5 UNIMPLEMENTED"
+"13.1.6 UNIMPLEMENTED"
+"13.1.7 UNIMPLEMENTED"
+"13.1.8 UNIMPLEMENTED"
+"13.1.9 UNIMPLEMENTED"
+"13.2.1 UNIMPLEMENTED"
+"13.2.10 UNIMPLEMENTED"
+"13.2.11 UNIMPLEMENTED"
+"13.2.12 UNIMPLEMENTED"
+"13.2.13 UNIMPLEMENTED"
+"13.2.14 UNIMPLEMENTED"
+"13.2.15 UNIMPLEMENTED"
+"13.2.16 UNIMPLEMENTED"
+"13.2.17 UNIMPLEMENTED"
+"13.2.18 UNIMPLEMENTED"
+"13.2.2 UNIMPLEMENTED"
+"13.2.3 UNIMPLEMENTED"
+"13.2.4 UNIMPLEMENTED"
+"13.2.5 UNIMPLEMENTED"
+"13.2.6 UNIMPLEMENTED"
+"13.2.7 UNIMPLEMENTED"
+"13.2.8 UNIMPLEMENTED"
+"13.2.9 UNIMPLEMENTED"
+"13.3.1 UNIMPLEMENTED"
+"13.3.10 UNIMPLEMENTED"
+"13.3.11 UNIMPLEMENTED"
+"13.3.12 UNIMPLEMENTED"
+"13.3.13 UNIMPLEMENTED"
+"13.3.14 UNIMPLEMENTED"
+"13.3.15 UNIMPLEMENTED"
+"13.3.16 UNIMPLEMENTED"
+"13.3.17 UNIMPLEMENTED"
+"13.3.18 UNIMPLEMENTED"
+"13.3.2 UNIMPLEMENTED"
+"13.3.3 UNIMPLEMENTED"
+"13.3.4 UNIMPLEMENTED"
+"13.3.5 UNIMPLEMENTED"
+"13.3.6 UNIMPLEMENTED"
+"13.3.7 UNIMPLEMENTED"
+"13.3.8 UNIMPLEMENTED"
+"13.3.9 UNIMPLEMENTED"
+"13.4.1 UNIMPLEMENTED"
+"13.4.10 UNIMPLEMENTED"
+"13.4.11 UNIMPLEMENTED"
+"13.4.12 UNIMPLEMENTED"
+"13.4.13 UNIMPLEMENTED"
+"13.4.14 UNIMPLEMENTED"
+"13.4.15 UNIMPLEMENTED"
+"13.4.16 UNIMPLEMENTED"
+"13.4.17 UNIMPLEMENTED"
+"13.4.18 UNIMPLEMENTED"
+"13.4.2 UNIMPLEMENTED"
+"13.4.3 UNIMPLEMENTED"
+"13.4.4 UNIMPLEMENTED"
+"13.4.5 UNIMPLEMENTED"
+"13.4.6 UNIMPLEMENTED"
+"13.4.7 UNIMPLEMENTED"
+"13.4.8 UNIMPLEMENTED"
+"13.4.9 UNIMPLEMENTED"
+"13.5.1 UNIMPLEMENTED"
+"13.5.10 UNIMPLEMENTED"
+"13.5.11 UNIMPLEMENTED"
+"13.5.12 UNIMPLEMENTED"
+"13.5.13 UNIMPLEMENTED"
+"13.5.14 UNIMPLEMENTED"
+"13.5.15 UNIMPLEMENTED"
+"13.5.16 UNIMPLEMENTED"
+"13.5.17 UNIMPLEMENTED"
+"13.5.18 UNIMPLEMENTED"
+"13.5.2 UNIMPLEMENTED"
+"13.5.3 UNIMPLEMENTED"
+"13.5.4 UNIMPLEMENTED"
+"13.5.5 UNIMPLEMENTED"
+"13.5.6 UNIMPLEMENTED"
+"13.5.7 UNIMPLEMENTED"
+"13.5.8 UNIMPLEMENTED"
+"13.5.9 UNIMPLEMENTED"
+"13.6.1 UNIMPLEMENTED"
+"13.6.10 UNIMPLEMENTED"
+"13.6.11 UNIMPLEMENTED"
+"13.6.12 UNIMPLEMENTED"
+"13.6.13 UNIMPLEMENTED"
+"13.6.14 UNIMPLEMENTED"
+"13.6.15 UNIMPLEMENTED"
+"13.6.16 UNIMPLEMENTED"
+"13.6.17 UNIMPLEMENTED"
+"13.6.18 UNIMPLEMENTED"
+"13.6.2 UNIMPLEMENTED"
+"13.6.3 UNIMPLEMENTED"
+"13.6.4 UNIMPLEMENTED"
+"13.6.5 UNIMPLEMENTED"
+"13.6.6 UNIMPLEMENTED"
+"13.6.7 UNIMPLEMENTED"
+"13.6.8 UNIMPLEMENTED"
+"13.6.9 UNIMPLEMENTED"
+"13.7.1 UNIMPLEMENTED"
+"13.7.10 UNIMPLEMENTED"
+"13.7.11 UNIMPLEMENTED"
+"13.7.12 UNIMPLEMENTED"
+"13.7.13 UNIMPLEMENTED"
+"13.7.14 UNIMPLEMENTED"
+"13.7.15 UNIMPLEMENTED"
+"13.7.16 UNIMPLEMENTED"
+"13.7.17 UNIMPLEMENTED"
+"13.7.18 UNIMPLEMENTED"
+"13.7.2 UNIMPLEMENTED"
+"13.7.3 UNIMPLEMENTED"
+"13.7.4 UNIMPLEMENTED"
+"13.7.5 UNIMPLEMENTED"
+"13.7.6 UNIMPLEMENTED"
+"13.7.7 UNIMPLEMENTED"
+"13.7.8 UNIMPLEMENTED"
+"13.7.9 UNIMPLEMENTED"
+"2.1 OK"
+"2.10 OK"
+"2.11 OK"
+"2.2 OK"
+"2.3 OK"
+"2.4 OK"
+"2.5 OK"
+"2.6 OK"
+"2.7 OK"
+"2.8 OK"
+"2.9 OK"
+"3.1 OK"
+"3.2 NON-STRICT"
+"3.3 NON-STRICT"
+"3.4 NON-STRICT"
+"3.5 OK"
+"3.6 OK"
+"3.7 OK"
+"4.1.1 OK"
+"4.1.2 OK"
+"4.1.3 NON-STRICT"
+"4.1.4 NON-STRICT"
+"4.1.5 OK"
+"4.2.1 OK"
+"4.2.2 OK"
+"4.2.3 NON-STRICT"
+"4.2.4 NON-STRICT"
+"4.2.5 OK"
+"5.1 OK"
+"5.10 OK"
+"5.11 OK"
+"5.12 OK"
+"5.13 OK"
+"5.14 OK"
+"5.15 NON-STRICT"
+"5.16 OK"
+"5.17 OK"
+"5.18 OK"
+"5.19 OK"
+"5.2 OK"
+"5.20 OK"
+"5.3 OK"
+"5.4 OK"
+"5.5 OK"
+"5.6 OK"
+"5.7 OK"
+"5.8 OK"
+"5.9 OK"
+"7.1.1 OK"
+"7.1.2 OK"
+"7.1.3 OK"
+"7.1.4 OK"
+"7.1.5 FAILED"
+"7.1.6 INFORMATIONAL"
+"7.13.1 INFORMATIONAL"
+"7.13.2 INFORMATIONAL"
+"7.3.1 OK"
+"7.3.2 OK"
+"7.3.3 OK"
+"7.3.4 OK"
+"7.3.5 OK"
+"7.3.6 OK"
+"7.5.1 FAILED"
+"7.7.1 OK"
+"7.7.10 OK"
+"7.7.11 OK"
+"7.7.12 OK"
+"7.7.13 OK"
+"7.7.2 OK"
+"7.7.3 OK"
+"7.7.4 OK"
+"7.7.5 OK"
+"7.7.6 OK"
+"7.7.7 OK"
+"7.7.8 OK"
+"7.7.9 OK"
+"7.9.1 OK"
+"7.9.10 OK"
+"7.9.11 OK"
+"7.9.12 OK"
+"7.9.13 OK"
+"7.9.2 OK"
+"7.9.3 OK"
+"7.9.4 OK"
+"7.9.5 OK"
+"7.9.6 OK"
+"7.9.7 OK"
+"7.9.8 OK"
+"7.9.9 OK"
+"9.1.1 OK"
+"9.1.2 OK"
+"9.1.3 OK"
+"9.1.4 OK"
+"9.1.5 OK"
+"9.1.6 OK"
+"9.2.1 OK"
+"9.2.2 OK"
+"9.2.3 OK"
+"9.2.4 OK"
+"9.2.5 OK"
+"9.2.6 OK"
+"9.3.1 OK"
+"9.3.2 OK"
+"9.3.3 OK"
+"9.3.4 OK"
+"9.3.5 OK"
+"9.3.6 OK"
+"9.3.7 OK"
+"9.3.8 OK"
+"9.3.9 OK"
+"9.4.1 OK"
+"9.4.2 OK"
+"9.4.3 OK"
+"9.4.4 OK"
+"9.4.5 OK"
+"9.4.6 OK"
+"9.4.7 OK"
+"9.4.8 OK"
+"9.4.9 OK"
+"9.5.1 OK"
+"9.5.2 OK"
+"9.5.3 OK"
+"9.5.4 OK"
+"9.5.5 OK"
+"9.5.6 OK"
+"9.6.1 OK"
+"9.6.2 OK"
+"9.6.3 OK"
+"9.6.4 OK"
+"9.6.5 OK"
+"9.6.6 OK"
+"9.7.1 OK"
+"9.7.2 OK"
+"9.7.3 OK"
+"9.7.4 OK"
+"9.7.5 OK"
+"9.7.6 OK"
+"9.8.1 OK"
+"9.8.2 OK"
+"9.8.3 OK"
+"9.8.4 OK"
+"9.8.5 OK"
+"9.8.6 OK"
diff --git a/okhttp-ws-tests/fuzzingserver-test.sh b/okhttp-ws-tests/fuzzingserver-test.sh
new file mode 100755
index 0000000000..af89a42422
--- /dev/null
+++ b/okhttp-ws-tests/fuzzingserver-test.sh
@@ -0,0 +1,28 @@
+#!/usr/bin/env bash
+
+SCRIPT_DIR="$( cd "$( dirname "$0" )" && pwd )"
+cd "$SCRIPT_DIR"
+
+which wstest
+if [ $? != 0 ]; then
+  echo "Run 'pip install autobahntestsuite', maybe with 'sudo'."
+  exit 1
+fi
+which jq
+if [ $? != 0 ]; then
+  echo "Run 'brew install jq'"
+  exit 1
+fi
+
+trap 'kill $(jobs -pr)' SIGINT SIGTERM EXIT
+
+set -ex
+
+wstest -m fuzzingserver -s fuzzingserver-config.json &
+sleep 2 # wait for wstest to start
+
+java -jar target/okhttp-ws-tests-*-jar-with-dependencies.jar
+
+jq '.[] as $in | $in | keys[] | . + " " + $in[.].behavior' target/fuzzingserver-report/index.json > target/fuzzingserver-actual.txt
+
+diff fuzzingserver-expected.txt target/fuzzingserver-actual.txt
diff --git a/okhttp-ws-tests/fuzzingserver-update-expected.sh b/okhttp-ws-tests/fuzzingserver-update-expected.sh
new file mode 100755
index 0000000000..56592c95fe
--- /dev/null
+++ b/okhttp-ws-tests/fuzzingserver-update-expected.sh
@@ -0,0 +1,11 @@
+#!/usr/bin/env bash
+
+SCRIPT_DIR="$( cd "$( dirname "$0" )" && pwd )"
+cd "$SCRIPT_DIR"
+
+if [ ! -f target/fuzzingserver-actual.txt ]; then
+  echo "File not found. Did you run the Autobahn test script?"
+  exit 1
+fi
+
+cp target/fuzzingserver-actual.txt fuzzingserver-expected.txt
diff --git a/okhttp-ws-tests/pom.xml b/okhttp-ws-tests/pom.xml
index 870b99cd65..783385c8f2 100644
--- a/okhttp-ws-tests/pom.xml
+++ b/okhttp-ws-tests/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.5.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-ws-tests</artifactId>
@@ -14,15 +14,16 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-ws</artifactId>
       <version>${project.version}</version>
-      <scope>test</scope>
     </dependency>
+
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>okhttp-ws</artifactId>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
       <version>${project.version}</version>
+      <scope>test</scope>
     </dependency>
 
     <dependency>
@@ -31,7 +32,7 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>mockwebserver</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
@@ -40,6 +41,28 @@
 
   <build>
     <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <configuration>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
+          <archive>
+            <manifest>
+              <mainClass>okhttp3.ws.AutobahnTester</mainClass>
+            </manifest>
+          </archive>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
       <!-- Do not deploy this as an artifact to Maven central. -->
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/AutobahnTester.java b/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
similarity index 72%
rename from okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/AutobahnTester.java
rename to okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
index a592624c67..707f58c116 100644
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/AutobahnTester.java
+++ b/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
@@ -13,12 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.ws;
+package okhttp3.ws;
 
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.Version;
 import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
@@ -26,12 +22,21 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Version;
 import okio.Buffer;
 import okio.BufferedSource;
 
+import static okhttp3.ws.WebSocket.BINARY;
+import static okhttp3.ws.WebSocket.TEXT;
+
 /**
- * Exercises the web socket implementation against the
- * <a href="http://autobahn.ws/testsuite/">Autobahn Testsuite</a>.
+ * Exercises the web socket implementation against the <a
+ * href="http://autobahn.ws/testsuite/">Autobahn Testsuite</a>.
  */
 public final class AutobahnTester {
   private static final String HOST = "ws://localhost:9001";
@@ -58,34 +63,40 @@ public void run() throws IOException {
 
       updateReports();
     } finally {
-      client.getDispatcher().getExecutorService().shutdown();
+      client.dispatcher().executorService().shutdown();
     }
   }
 
   private void runTest(final long number, final long count) throws IOException {
     final CountDownLatch latch = new CountDownLatch(1);
-    newWebSocket("/runCase?case=" + number + "&agent=" + Version.userAgent()) //
+    final AtomicLong startNanos = new AtomicLong();
+    newWebSocket("/runCase?case=" + number + "&agent=okhttp") //
         .enqueue(new WebSocketListener() {
           private final ExecutorService sendExecutor = Executors.newSingleThreadExecutor();
           private WebSocket webSocket;
 
           @Override public void onOpen(WebSocket webSocket, Response response) {
-            System.out.println("Executing test case " + number + "/" + count);
             this.webSocket = webSocket;
-          }
 
-          @Override public void onMessage(BufferedSource payload, final WebSocket.PayloadType type)
-              throws IOException {
-            final Buffer buffer = new Buffer();
-            payload.readAll(buffer);
-            payload.close();
+            System.out.println("Executing test case " + number + "/" + count);
+            startNanos.set(System.nanoTime());
+          }
 
+          @Override public void onMessage(final ResponseBody message) throws IOException {
+            final RequestBody response;
+            if (message.contentType() == TEXT) {
+              response = RequestBody.create(TEXT, message.string());
+            } else {
+              BufferedSource source = message.source();
+              response = RequestBody.create(BINARY, source.readByteString());
+              source.close();
+            }
             sendExecutor.execute(new Runnable() {
               @Override public void run() {
                 try {
-                  webSocket.sendMessage(type, buffer);
+                  webSocket.sendMessage(response);
                 } catch (IOException e) {
-                  e.printStackTrace();
+                  e.printStackTrace(System.out);
                 }
               }
             });
@@ -100,16 +111,21 @@ private void runTest(final long number, final long count) throws IOException {
           }
 
           @Override public void onFailure(IOException e, Response response) {
+            e.printStackTrace(System.out);
             latch.countDown();
           }
         });
     try {
-      if (!latch.await(10, TimeUnit.SECONDS)) {
-        throw new IllegalStateException("Timed out waiting for count.");
+      if (!latch.await(30, TimeUnit.SECONDS)) {
+        throw new IllegalStateException("Timed out waiting for test " + number + " to finish.");
       }
     } catch (InterruptedException e) {
       throw new AssertionError();
     }
+
+    long endNanos = System.nanoTime();
+    long tookMs = TimeUnit.NANOSECONDS.toMillis(endNanos - startNanos.get());
+    System.out.println("Took " + tookMs + "ms");
   }
 
   private long getTestCount() throws IOException {
@@ -120,10 +136,9 @@ private long getTestCount() throws IOException {
       @Override public void onOpen(WebSocket webSocket, Response response) {
       }
 
-      @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type)
-          throws IOException {
-        countRef.set(payload.readDecimalLong());
-        payload.close();
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        countRef.set(message.source().readDecimalLong());
+        message.close();
       }
 
       @Override public void onPong(Buffer payload) {
@@ -158,8 +173,7 @@ private void updateReports() {
       @Override public void onOpen(WebSocket webSocket, Response response) {
       }
 
-      @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type)
-          throws IOException {
+      @Override public void onMessage(ResponseBody message) throws IOException {
       }
 
       @Override public void onPong(Buffer payload) {
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
deleted file mode 100644
index 241376d073..0000000000
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
+++ /dev/null
@@ -1,322 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.ws;
-
-import com.squareup.okhttp.ws.WebSocketRecorder;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class RealWebSocketTest {
-  // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
-  // zero effect on the behavior of the WebSocket API which is why tests are only written once
-  // from the perspective of a single peer.
-
-  private final Executor clientExecutor = Executors.newSingleThreadExecutor();
-  private RealWebSocket client;
-  private boolean clientConnectionCloseThrows;
-  private boolean clientConnectionClosed;
-  private final Buffer client2Server = new Buffer();
-  private final WebSocketRecorder clientListener = new WebSocketRecorder();
-
-  private final Executor serverExecutor = Executors.newSingleThreadExecutor();
-  private RealWebSocket server;
-  private final Buffer server2client = new Buffer();
-  private final WebSocketRecorder serverListener = new WebSocketRecorder();
-
-  @Before public void setUp() {
-    Random random = new Random(0);
-    String url = "http://example.com/websocket";
-
-    client = new RealWebSocket(true, server2client, client2Server, random, clientExecutor,
-        clientListener, url) {
-      @Override protected void closeConnection() throws IOException {
-        clientConnectionClosed = true;
-        if (clientConnectionCloseThrows) {
-          throw new IOException("Oops!");
-        }
-      }
-    };
-    server = new RealWebSocket(false, client2Server, server2client, random, serverExecutor,
-        serverListener, url) {
-      @Override protected void closeConnection() throws IOException {
-      }
-    };
-  }
-
-  @After public void tearDown() {
-    clientListener.assertExhausted();
-    serverListener.assertExhausted();
-  }
-
-  @Test public void textMessage() throws IOException {
-    client.sendMessage(TEXT, new Buffer().writeUtf8("Hello!"));
-    server.readMessage();
-    serverListener.assertTextMessage("Hello!");
-  }
-
-  @Test public void binaryMessage() throws IOException {
-    client.sendMessage(BINARY, new Buffer().writeUtf8("Hello!"));
-    server.readMessage();
-    serverListener.assertBinaryMessage(new byte[] { 'H', 'e', 'l', 'l', 'o', '!' });
-  }
-
-  @Test public void streamingMessage() throws IOException {
-    BufferedSink sink = client.newMessageSink(TEXT);
-    sink.writeUtf8("Hel").flush();
-    sink.writeUtf8("lo!").flush();
-    sink.close();
-    server.readMessage();
-    serverListener.assertTextMessage("Hello!");
-  }
-
-  @Test public void streamingMessageCanInterleavePing() throws IOException, InterruptedException {
-    BufferedSink sink = client.newMessageSink(TEXT);
-    sink.writeUtf8("Hel").flush();
-    client.sendPing(new Buffer().writeUtf8("Pong?"));
-    sink.writeUtf8("lo!").flush();
-    sink.close();
-    server.readMessage();
-    serverListener.assertTextMessage("Hello!");
-    waitForExecutor(serverExecutor); // Pong write happens asynchronously.
-    client.readMessage();
-    clientListener.assertPong(new Buffer().writeUtf8("Pong?"));
-  }
-
-  @Test public void pingWritesPong() throws IOException, InterruptedException {
-    client.sendPing(new Buffer().writeUtf8("Hello!"));
-    server.readMessage(); // Read the ping, write the pong.
-    waitForExecutor(serverExecutor); // Pong write happens asynchronously.
-    client.readMessage(); // Read the pong.
-    clientListener.assertPong(new Buffer().writeUtf8("Hello!"));
-  }
-
-  @Test public void unsolicitedPong() throws IOException {
-    client.sendPong(new Buffer().writeUtf8("Hello!"));
-    server.readMessage();
-    serverListener.assertPong(new Buffer().writeUtf8("Hello!"));
-  }
-
-  @Test public void close() throws IOException {
-    client.close(1000, "Hello!");
-    assertFalse(server.readMessage()); // This will trigger a close response.
-    serverListener.assertClose(1000, "Hello!");
-    assertFalse(client.readMessage());
-    clientListener.assertClose(1000, "Hello!");
-  }
-
-  @Test public void clientCloseThenMethodsThrow() throws IOException {
-    client.close(1000, "Hello!");
-
-    try {
-      client.sendPing(new Buffer().writeUtf8("Pong?"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.close(1000, "Hello!");
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.sendMessage(TEXT, new Buffer().writeUtf8("Hello!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.newMessageSink(TEXT);
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-  }
-
-  @Test public void serverCloseThenWritingThrows() throws IOException {
-    server.close(1000, "Hello!");
-    client.readMessage();
-    clientListener.assertClose(1000, "Hello!");
-
-    try {
-      client.sendPing(new Buffer().writeUtf8("Pong?"));
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.sendMessage(TEXT, new Buffer().writeUtf8("Hi!"));
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.close(1000, "Bye!");
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-  }
-
-  @Test public void serverCloseWhileWritingThrows() throws IOException {
-    // Start writing data.
-    BufferedSink sink = client.newMessageSink(TEXT);
-    sink.writeUtf8("Hel").flush();
-
-    server.close(1000, "Hello!");
-    client.readMessage();
-    clientListener.assertClose(1000, "Hello!");
-
-    try {
-      sink.writeUtf8("lo!").emit(); // No writing to the underlying sink.
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-      sink.buffer().clear();
-    }
-    try {
-      sink.flush(); // No flushing.
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      sink.close(); // No closing because this requires writing a frame.
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-  }
-
-  @Test public void clientCloseClosesConnection() throws IOException {
-    client.close(1000, "Hello!");
-    assertFalse(clientConnectionClosed);
-    server.readMessage(); // Read client close, send server close.
-    serverListener.assertClose(1000, "Hello!");
-
-    client.readMessage(); // Read server close.
-    waitForExecutor(clientExecutor); // Close happens asynchronously.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClose(1000, "Hello!");
-  }
-
-  @Test public void serverCloseClosesConnection() throws IOException {
-    server.close(1000, "Hello!");
-
-    client.readMessage(); // Read server close, send client close, close connection.
-    clientListener.assertClose(1000, "Hello!");
-    assertTrue(clientConnectionClosed);
-
-    server.readMessage();
-    serverListener.assertClose(1000, "Hello!");
-  }
-
-  @Test public void clientAndServerCloseClosesConnection() throws IOException {
-    // Send close from both sides at the same time.
-    server.close(1000, "Hello!");
-    client.close(1000, "Hi!");
-    assertFalse(clientConnectionClosed);
-
-    client.readMessage(); // Read close, should NOT send close.
-    waitForExecutor(clientExecutor); // Close happens asynchronously.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClose(1000, "Hello!");
-
-    server.readMessage();
-    serverListener.assertClose(1000, "Hi!");
-
-    serverListener.assertExhausted(); // Client should not have sent second close.
-    clientListener.assertExhausted(); // Server should not have sent second close.
-  }
-
-  @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
-    server.sendMessage(TEXT, new Buffer().writeUtf8("Hello!"));
-    server.close(1000, "Bye!");
-    assertTrue(client.readMessage());
-    clientListener.assertTextMessage("Hello!");
-    assertFalse(client.readMessage());
-    clientListener.assertClose(1000, "Bye!");
-  }
-
-  @Test public void protocolErrorBeforeCloseSendsClose() {
-    server2client.write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
-
-    client.readMessage(); // Detects error, send close.
-    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
-    assertTrue(clientConnectionClosed);
-
-    server.readMessage();
-    serverListener.assertClose(1002, "");
-  }
-
-  @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
-    client.close(1000, "Hello!");
-    server2client.write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
-
-    client.readMessage();
-    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
-    assertTrue(clientConnectionClosed);
-
-    server.readMessage();
-    serverListener.assertClose(1000, "Hello!");
-  }
-
-  @Test public void peerConnectionCloseThrowingDoesNotPropagate() throws IOException {
-    clientConnectionCloseThrows = true;
-
-    server.close(1000, "Bye!");
-    client.readMessage();
-    clientListener.assertClose(1000, "Bye!");
-    assertTrue(clientConnectionClosed);
-
-    server.readMessage();
-    serverListener.assertClose(1000, "Bye!");
-  }
-
-  private static void waitForExecutor(Executor executor) {
-    final CountDownLatch latch = new CountDownLatch(1);
-    executor.execute(new Runnable() {
-      @Override public void run() {
-        latch.countDown();
-      }
-    });
-    try {
-      if (!latch.await(10, TimeUnit.SECONDS)) {
-        throw new IllegalStateException("Timed out waiting for executor.");
-      }
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
-    }
-  }
-}
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java b/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
deleted file mode 100644
index a98e6bbf9d..0000000000
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
+++ /dev/null
@@ -1,331 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.ws;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Random;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-import org.junit.After;
-import org.junit.Test;
-
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-public final class WebSocketWriterTest {
-  private final Buffer data = new Buffer();
-  private final Random random = new Random(0);
-
-  // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
-  private final WebSocketWriter serverWriter = new WebSocketWriter(false, data, random);
-  private final WebSocketWriter clientWriter = new WebSocketWriter(true, data, random);
-
-  @After public void tearDown() throws IOException {
-    assertEquals("Data not empty", "", data.readByteString().hex());
-  }
-
-  @Test public void serverSendSimpleHello() throws IOException {
-    Buffer payload = new Buffer().writeUtf8("Hello");
-    serverWriter.sendMessage(TEXT, payload);
-    assertData("810548656c6c6f");
-  }
-
-  @Test public void clientSendSimpleHello() throws IOException {
-    Buffer payload = new Buffer().writeUtf8("Hello");
-    clientWriter.sendMessage(TEXT, payload);
-    assertData("818560b420bb28d14cd70f");
-  }
-
-  @Test public void serverStreamSimpleHello() throws IOException {
-    BufferedSink sink = serverWriter.newMessageSink(TEXT);
-
-    sink.writeUtf8("Hel").flush();
-    assertData("010348656c");
-
-    sink.writeUtf8("lo").flush();
-    assertData("00026c6f");
-
-    sink.close();
-    assertData("8000");
-  }
-
-  @Test public void serverStreamCloseFlushes() throws IOException {
-    BufferedSink sink = serverWriter.newMessageSink(TEXT);
-
-    sink.writeUtf8("Hel").flush();
-    assertData("010348656c");
-
-    sink.writeUtf8("lo").close();
-    assertData("00026c6f");
-    assertData("8000");
-  }
-
-  @Test public void clientStreamSimpleHello() throws IOException {
-    BufferedSink sink = clientWriter.newMessageSink(TEXT);
-
-    sink.writeUtf8("Hel").flush();
-    assertData("018360b420bb28d14c");
-
-    sink.writeUtf8("lo").flush();
-    assertData("00823851d9d4543e");
-
-    sink.close();
-    assertData("80807acb933d");
-  }
-
-  @Test public void serverSendBinary() throws IOException {
-    byte[] payload = binaryData(100);
-    serverWriter.sendMessage(BINARY, new Buffer().write(payload));
-    assertData("8264");
-    assertData(payload);
-  }
-
-  @Test public void serverSendBinaryShort() throws IOException {
-    byte[] payload = binaryData(0xffff);
-    serverWriter.sendMessage(BINARY, new Buffer().write(payload));
-    assertData("827effff");
-    assertData(payload);
-  }
-
-  @Test public void serverSendBinaryLong() throws IOException {
-    byte[] payload = binaryData(65537);
-    serverWriter.sendMessage(BINARY, new Buffer().write(payload));
-    assertData("827f0000000000010001");
-    assertData(payload);
-  }
-
-  @Test public void clientSendBinary() throws IOException {
-    byte[] payload = binaryData(100);
-    clientWriter.sendMessage(BINARY, new Buffer().write(payload));
-    assertData("82e4");
-
-    byte[] maskKey = new byte[4];
-    random.setSeed(0); // Reset the seed so we can mask the payload.
-    random.nextBytes(maskKey);
-    toggleMask(payload, payload.length, maskKey, 0);
-
-    assertData(maskKey);
-    assertData(payload);
-  }
-
-  @Test public void serverStreamBinary() throws IOException {
-    byte[] payload = binaryData(100);
-    BufferedSink sink = serverWriter.newMessageSink(BINARY);
-
-    sink.write(payload, 0, 50).flush();
-    assertData("0232");
-    assertData(Arrays.copyOfRange(payload, 0, 50));
-
-    sink.write(payload, 50, 50).flush();
-    assertData("0032");
-    assertData(Arrays.copyOfRange(payload, 50, 100));
-
-    sink.close();
-    assertData("8000");
-  }
-
-  @Test public void clientStreamBinary() throws IOException {
-    byte[] maskKey1 = new byte[4];
-    random.nextBytes(maskKey1);
-    byte[] maskKey2 = new byte[4];
-    random.nextBytes(maskKey2);
-    byte[] maskKey3 = new byte[4];
-    random.nextBytes(maskKey3);
-
-    random.setSeed(0); // Reset the seed so real data matches.
-
-    byte[] payload = binaryData(100);
-    BufferedSink sink = clientWriter.newMessageSink(BINARY);
-
-    sink.write(payload, 0, 50).flush();
-    byte[] part1 = Arrays.copyOfRange(payload, 0, 50);
-    toggleMask(part1, 50, maskKey1, 0);
-    assertData("02b2");
-    assertData(maskKey1);
-    assertData(part1);
-
-    sink.write(payload, 50, 50).flush();
-    byte[] part2 = Arrays.copyOfRange(payload, 50, 100);
-    toggleMask(part2, 50, maskKey2, 0);
-    assertData("00b2");
-    assertData(maskKey2);
-    assertData(part2);
-
-    sink.close();
-    assertData("8080");
-    assertData(maskKey3);
-  }
-
-  @Test public void serverEmptyClose() throws IOException {
-    serverWriter.writeClose(0, null);
-    assertData("8800");
-  }
-
-  @Test public void serverCloseWithCode() throws IOException {
-    serverWriter.writeClose(1005, null);
-    assertData("880203ed");
-  }
-
-  @Test public void serverCloseWithCodeAndReason() throws IOException {
-    serverWriter.writeClose(1005, "Hello");
-    assertData("880703ed48656c6c6f");
-  }
-
-  @Test public void clientEmptyClose() throws IOException {
-    clientWriter.writeClose(0, null);
-    assertData("888060b420bb");
-  }
-
-  @Test public void clientCloseWithCode() throws IOException {
-    clientWriter.writeClose(1005, null);
-    assertData("888260b420bb6359");
-  }
-
-  @Test public void clientCloseWithCodeAndReason() throws IOException {
-    clientWriter.writeClose(1005, "Hello");
-    assertData("888760b420bb635968de0cd84f");
-  }
-
-  @Test public void closeWithOnlyReasonThrows() throws IOException {
-    clientWriter.writeClose(0, "Hello");
-    assertData("888760b420bb60b468de0cd84f");
-  }
-
-  @Test public void closeCodeOutOfRangeThrows() throws IOException {
-    try {
-      clientWriter.writeClose(98724976, "Hello");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Code must be in range [1000,5000).", e.getMessage());
-    }
-  }
-
-  @Test public void serverEmptyPing() throws IOException {
-    serverWriter.writePing(null);
-    assertData("8900");
-  }
-
-  @Test public void clientEmptyPing() throws IOException {
-    clientWriter.writePing(null);
-    assertData("898060b420bb");
-  }
-
-  @Test public void serverPingWithPayload() throws IOException {
-    serverWriter.writePing(new Buffer().writeUtf8("Hello"));
-    assertData("890548656c6c6f");
-  }
-
-  @Test public void clientPingWithPayload() throws IOException {
-    clientWriter.writePing(new Buffer().writeUtf8("Hello"));
-    assertData("898560b420bb28d14cd70f");
-  }
-
-  @Test public void serverEmptyPong() throws IOException {
-    serverWriter.writePong(null);
-    assertData("8a00");
-  }
-
-  @Test public void clientEmptyPong() throws IOException {
-    clientWriter.writePong(null);
-    assertData("8a8060b420bb");
-  }
-
-  @Test public void serverPongWithPayload() throws IOException {
-    serverWriter.writePong(new Buffer().writeUtf8("Hello"));
-    assertData("8a0548656c6c6f");
-  }
-
-  @Test public void clientPongWithPayload() throws IOException {
-    clientWriter.writePong(new Buffer().writeUtf8("Hello"));
-    assertData("8a8560b420bb28d14cd70f");
-  }
-
-  @Test public void pingTooLongThrows() throws IOException {
-    try {
-      serverWriter.writePing(new Buffer().write(binaryData(1000)));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
-    }
-  }
-
-  @Test public void pongTooLongThrows() throws IOException {
-    try {
-      serverWriter.writePong(new Buffer().write(binaryData(1000)));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
-    }
-  }
-
-  @Test public void closeTooLongThrows() throws IOException {
-    try {
-      String longString = ByteString.of(binaryData(75)).hex();
-      serverWriter.writeClose(1000, longString);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
-    }
-  }
-
-  @Test public void twoWritersThrows() {
-    clientWriter.newMessageSink(TEXT);
-    try {
-      clientWriter.newMessageSink(TEXT);
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("Another message writer is active. Did you call close()?", e.getMessage());
-    }
-  }
-
-  @Test public void writeWhileWriterThrows() throws IOException {
-    clientWriter.newMessageSink(TEXT);
-    try {
-      clientWriter.sendMessage(TEXT, new Buffer());
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("A message writer is active. Did you call close()?", e.getMessage());
-    }
-  }
-
-  private void assertData(String hex) throws EOFException {
-    ByteString expected = ByteString.decodeHex(hex);
-    ByteString actual = data.readByteString(expected.size());
-    assertEquals(expected, actual);
-  }
-
-  private void assertData(byte[] data) throws IOException {
-    int byteCount = 16;
-    for (int i = 0; i < data.length; i += byteCount) {
-      int count = Math.min(byteCount, data.length - i);
-      Buffer expectedChunk = new Buffer();
-      expectedChunk.write(data, i, count);
-      assertEquals("At " + i, expectedChunk.readByteString(), this.data.readByteString(count));
-    }
-  }
-
-  private static byte[] binaryData(int length) {
-    byte[] junk = new byte[length];
-    new Random(0).nextBytes(junk);
-    return junk;
-  }
-}
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
new file mode 100644
index 0000000000..90a803ec14
--- /dev/null
+++ b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -0,0 +1,504 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.concurrent.Executor;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ws.WebSocketRecorder;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static okhttp3.ws.WebSocket.BINARY;
+import static okhttp3.ws.WebSocket.TEXT;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class RealWebSocketTest {
+  // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
+  // zero effect on the behavior of the WebSocket API which is why tests are only written once
+  // from the perspective of a single peer.
+
+  private final Executor clientExecutor = new SynchronousExecutor();
+  private RealWebSocket client;
+  private boolean clientConnectionCloseThrows;
+  private boolean clientConnectionClosed;
+  private final MemorySocket client2Server = new MemorySocket();
+  private final WebSocketRecorder clientListener = new WebSocketRecorder();
+
+  private final Executor serverExecutor = new SynchronousExecutor();
+  private RealWebSocket server;
+  private boolean serverConnectionClosed;
+  private final MemorySocket server2client = new MemorySocket();
+  private final WebSocketRecorder serverListener = new WebSocketRecorder();
+
+  @Before public void setUp() {
+    Random random = new Random(0);
+    String url = "http://example.com/websocket";
+
+    client = new RealWebSocket(true, server2client.source(), client2Server.sink(), random,
+        clientExecutor, clientListener, url) {
+      @Override protected void close() throws IOException {
+        if (clientConnectionClosed) {
+          throw new AssertionError("Already closed");
+        }
+        clientConnectionClosed = true;
+
+        if (clientConnectionCloseThrows) {
+          throw new IOException("Oops!");
+        }
+      }
+    };
+    server = new RealWebSocket(false, client2Server.source(), server2client.sink(), random,
+        serverExecutor, serverListener, url) {
+      @Override protected void close() throws IOException {
+        if (serverConnectionClosed) {
+          throw new AssertionError("Already closed");
+        }
+        serverConnectionClosed = true;
+      }
+    };
+  }
+
+  @After public void tearDown() {
+    clientListener.assertExhausted();
+    serverListener.assertExhausted();
+  }
+
+  @Test public void nullMessageThrows() throws IOException {
+    try {
+      client.sendMessage(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertEquals("message == null", e.getMessage());
+    }
+  }
+
+  @Test public void textMessage() throws IOException {
+    client.sendMessage(RequestBody.create(TEXT, "Hello!"));
+    server.readMessage();
+    serverListener.assertTextMessage("Hello!");
+  }
+
+  @Test public void binaryMessage() throws IOException {
+    client.sendMessage(RequestBody.create(BINARY, "Hello!"));
+    server.readMessage();
+    serverListener.assertBinaryMessage(new byte[] {'H', 'e', 'l', 'l', 'o', '!'});
+  }
+
+  @Test public void missingContentTypeThrows() throws IOException {
+    try {
+      client.sendMessage(RequestBody.create(null, "Hey!"));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.",
+          e.getMessage());
+    }
+  }
+
+  @Test public void unknownContentTypeThrows() throws IOException {
+    try {
+      client.sendMessage(RequestBody.create(MediaType.parse("text/plain"), "Hey!"));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals(
+          "Unknown message content type: text/plain. Must use WebSocket.TEXT or WebSocket.BINARY.",
+          e.getMessage());
+    }
+  }
+
+  @Test public void streamingMessage() throws IOException {
+    RequestBody message = new RequestBody() {
+      @Override public MediaType contentType() {
+        return TEXT;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Hel").flush();
+        sink.writeUtf8("lo!").flush();
+        sink.close();
+      }
+    };
+    client.sendMessage(message);
+    server.readMessage();
+    serverListener.assertTextMessage("Hello!");
+  }
+
+  @Test public void streamingMessageCanInterleavePing() throws IOException, InterruptedException {
+    RequestBody message = new RequestBody() {
+      @Override public MediaType contentType() {
+        return TEXT;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Hel").flush();
+        client.sendPing(new Buffer().writeUtf8("Pong?"));
+        sink.writeUtf8("lo!").flush();
+        sink.close();
+      }
+    };
+
+    client.sendMessage(message);
+    server.readMessage();
+    serverListener.assertTextMessage("Hello!");
+    client.readMessage();
+    clientListener.assertPong(new Buffer().writeUtf8("Pong?"));
+  }
+
+  @Test public void pingWritesPong() throws IOException, InterruptedException {
+    client.sendPing(new Buffer().writeUtf8("Hello!"));
+    server.readMessage(); // Read the ping, write the pong.
+    client.readMessage(); // Read the pong.
+    clientListener.assertPong(new Buffer().writeUtf8("Hello!"));
+  }
+
+  @Test public void unsolicitedPong() throws IOException {
+    client.sendPong(new Buffer().writeUtf8("Hello!"));
+    server.readMessage();
+    serverListener.assertPong(new Buffer().writeUtf8("Hello!"));
+  }
+
+  @Test public void close() throws IOException {
+    client.close(1000, "Hello!");
+    assertFalse(server.readMessage()); // This will trigger a close response.
+    serverListener.assertClose(1000, "Hello!");
+    assertFalse(client.readMessage());
+    clientListener.assertClose(1000, "Hello!");
+  }
+
+  @Test public void clientCloseThenMethodsThrow() throws IOException {
+    client.close(1000, "Hello!");
+
+    try {
+      client.sendPing(new Buffer().writeUtf8("Pong?"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("closed", e.getMessage());
+    }
+    try {
+      client.close(1000, "Hello!");
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("closed", e.getMessage());
+    }
+    try {
+      client.sendMessage(RequestBody.create(TEXT, "Hello!"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("closed", e.getMessage());
+    }
+  }
+
+  @Test public void socketClosedDuringPingKillsWebSocket() throws IOException {
+    client2Server.close();
+
+    try {
+      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      fail();
+    } catch (IOException ignored) {
+    }
+
+    // A failed write prevents further use of the WebSocket instance.
+    try {
+      client.sendMessage(RequestBody.create(TEXT, "Hello!"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("must call close()", e.getMessage());
+    }
+    try {
+      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("must call close()", e.getMessage());
+    }
+  }
+
+  @Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {
+    client2Server.close();
+
+    try {
+      client.sendMessage(RequestBody.create(TEXT, "Hello!"));
+      fail();
+    } catch (IOException ignored) {
+    }
+
+    // A failed write prevents further use of the WebSocket instance.
+    try {
+      client.sendMessage(RequestBody.create(TEXT, "Hello!"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("must call close()", e.getMessage());
+    }
+    try {
+      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("must call close()", e.getMessage());
+    }
+  }
+
+  @Test public void serverCloseThenWritingPingThrows() throws IOException {
+    server.close(1000, "Hello!");
+    client.readMessage();
+    clientListener.assertClose(1000, "Hello!");
+
+    try {
+      client.sendPing(new Buffer().writeUtf8("Pong?"));
+      fail();
+    } catch (IOException e) {
+      assertEquals("closed", e.getMessage());
+    }
+  }
+
+  @Test public void serverCloseThenWritingMessageThrows() throws IOException {
+    server.close(1000, "Hello!");
+    client.readMessage();
+    clientListener.assertClose(1000, "Hello!");
+
+    try {
+      client.sendMessage(RequestBody.create(TEXT, "Hi!"));
+      fail();
+    } catch (IOException e) {
+      assertEquals("closed", e.getMessage());
+    }
+  }
+
+  @Test public void serverCloseThenWritingCloseThrows() throws IOException {
+    server.close(1000, "Hello!");
+    client.readMessage();
+    clientListener.assertClose(1000, "Hello!");
+
+    try {
+      client.close(1000, "Bye!");
+      fail();
+    } catch (IOException e) {
+      assertEquals("closed", e.getMessage());
+    }
+  }
+
+  @Test public void serverCloseWhileWritingThrows() throws IOException {
+    RequestBody message = new RequestBody() {
+      @Override public MediaType contentType() {
+        return TEXT;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        // Start writing data.
+        sink.writeUtf8("Hel").flush();
+
+        server.close(1000, "Hello!");
+        client.readMessage();
+        clientListener.assertClose(1000, "Hello!");
+
+        try {
+          sink.flush(); // No flushing.
+          fail();
+        } catch (IOException e) {
+          assertEquals("closed", e.getMessage());
+        }
+        try {
+          sink.close(); // No closing because this requires writing a frame.
+          fail();
+        } catch (IOException e) {
+          assertEquals("closed", e.getMessage());
+        }
+      }
+    };
+    client.sendMessage(message);
+  }
+
+  @Test public void clientCloseClosesConnection() throws IOException {
+    client.close(1000, "Hello!");
+    assertFalse(clientConnectionClosed);
+    server.readMessage(); // Read client close, send server close.
+    serverListener.assertClose(1000, "Hello!");
+
+    client.readMessage(); // Read server close, close connection.
+    assertTrue(clientConnectionClosed);
+    clientListener.assertClose(1000, "Hello!");
+  }
+
+  @Test public void serverCloseClosesConnection() throws IOException {
+    server.close(1000, "Hello!");
+
+    client.readMessage(); // Read server close, send client close, close connection.
+    assertTrue(clientConnectionClosed);
+    clientListener.assertClose(1000, "Hello!");
+
+    server.readMessage();
+    serverListener.assertClose(1000, "Hello!");
+  }
+
+  @Test public void clientAndServerCloseClosesConnection() throws IOException {
+    // Send close from both sides at the same time.
+    server.close(1000, "Hello!");
+    client.close(1000, "Hi!");
+    assertFalse(clientConnectionClosed);
+
+    client.readMessage(); // Read close, close connection close.
+    assertTrue(clientConnectionClosed);
+    clientListener.assertClose(1000, "Hello!");
+
+    server.readMessage();
+    serverListener.assertClose(1000, "Hi!");
+
+    serverListener.assertExhausted(); // Client should not have sent second close.
+    clientListener.assertExhausted(); // Server should not have sent second close.
+  }
+
+  @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
+    server.sendMessage(RequestBody.create(TEXT, "Hello!"));
+    server.close(1000, "Bye!");
+    assertTrue(client.readMessage());
+    clientListener.assertTextMessage("Hello!");
+    assertFalse(client.readMessage());
+    clientListener.assertClose(1000, "Bye!");
+  }
+
+  @Test public void protocolErrorBeforeCloseSendsClose() throws IOException {
+    server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
+
+    client.readMessage(); // Detects error, send close, close connection.
+    assertTrue(clientConnectionClosed);
+    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
+
+    server.readMessage();
+    serverListener.assertClose(1002, "");
+  }
+
+  @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
+    client.close(1000, "Hello!");
+    assertFalse(clientConnectionClosed); // Not closed until close reply is received.
+    server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
+
+    client.readMessage(); // Detects error, closes connection immediately since close already sent.
+    assertTrue(clientConnectionClosed);
+    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
+
+    server.readMessage();
+    serverListener.assertClose(1000, "Hello!");
+
+    serverListener.assertExhausted(); // Client should not have sent second close.
+  }
+
+  @Test public void closeThrowingClosesConnection() {
+    client2Server.close();
+
+    try {
+      client.close(1000, null);
+      fail();
+    } catch (IOException ignored) {
+    }
+    assertTrue(clientConnectionClosed);
+  }
+
+  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {
+    client2Server.close();
+    clientConnectionCloseThrows = true;
+
+    try {
+      client.close(1000, "Bye!");
+      fail();
+    } catch (IOException e) {
+      assertNotEquals("Oops!", e.getMessage());
+    }
+    assertTrue(clientConnectionClosed);
+  }
+
+  @Test public void peerConnectionCloseThrowingDoesNotPropagate() throws IOException {
+    clientConnectionCloseThrows = true;
+
+    server.close(1000, "Bye!");
+    client.readMessage();
+    assertTrue(clientConnectionClosed);
+    clientListener.assertClose(1000, "Bye!");
+
+    server.readMessage();
+    serverListener.assertClose(1000, "Bye!");
+  }
+
+  static final class MemorySocket implements Closeable {
+    private final Buffer buffer = new Buffer();
+    private boolean closed;
+
+    @Override public void close() {
+      closed = true;
+    }
+
+    Buffer raw() {
+      return buffer;
+    }
+
+    BufferedSource source() {
+      return Okio.buffer(new Source() {
+        @Override public long read(Buffer sink, long byteCount) throws IOException {
+          if (closed) throw new IOException("closed");
+          return buffer.read(sink, byteCount);
+        }
+
+        @Override public Timeout timeout() {
+          return Timeout.NONE;
+        }
+
+        @Override public void close() throws IOException {
+          closed = true;
+        }
+      });
+    }
+
+    BufferedSink sink() {
+      return Okio.buffer(new Sink() {
+        @Override public void write(Buffer source, long byteCount) throws IOException {
+          if (closed) throw new IOException("closed");
+          buffer.write(source, byteCount);
+        }
+
+        @Override public void flush() throws IOException {
+        }
+
+        @Override public Timeout timeout() {
+          return Timeout.NONE;
+        }
+
+        @Override public void close() throws IOException {
+          closed = true;
+        }
+      });
+    }
+  }
+
+  static final class SynchronousExecutor implements Executor {
+    @Override public void execute(Runnable command) {
+      command.run();
+    }
+  }
+}
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
similarity index 79%
rename from okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
rename to okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index 1674511a43..6bb7ef86d8 100644
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -13,24 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package okhttp3.internal.ws;
 
-import com.squareup.okhttp.ws.WebSocketRecorder;
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.regex.Pattern;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Util;
+import okhttp3.ws.WebSocketRecorder;
+import okhttp3.ws.WebSocketRecorder.MessageDelegate;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
 import org.junit.After;
 import org.junit.Test;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType;
-import static com.squareup.okhttp.ws.WebSocketRecorder.MessageDelegate;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class WebSocketReaderTest {
@@ -151,11 +154,12 @@
 
     final Buffer sink = new Buffer();
     callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-        payload.readFully(sink, 3); // Read "Hel"
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        BufferedSource source = message.source();
+        source.readFully(sink, 3); // Read "Hel"
         data.write(ByteString.decodeHex("5158")); // lo
-        payload.readFully(sink, 2); // Read "lo"
-        payload.close();
+        source.readFully(sink, 2); // Read "lo"
+        source.close();
       }
     });
     serverReader.processNextFrame();
@@ -251,8 +255,8 @@
   @Test public void noCloseErrors() throws IOException {
     data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
     callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-        payload.readAll(new Buffer());
+      @Override public void onMessage(ResponseBody body) throws IOException {
+        body.source().readAll(new Buffer());
       }
     });
     try {
@@ -269,9 +273,9 @@
 
     final Buffer sink = new Buffer();
     callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-        payload.read(sink, 3);
-        payload.close();
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        message.source().read(sink, 3);
+        message.close();
       }
     });
 
@@ -291,9 +295,9 @@
 
     final Buffer sink = new Buffer();
     callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-        payload.read(sink, 2);
-        payload.close();
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        message.source().read(sink, 2);
+        message.close();
       }
     });
 
@@ -311,10 +315,10 @@
 
     final AtomicReference<Exception> exception = new AtomicReference<>();
     callback.setNextMessageDelegate(new MessageDelegate() {
-      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-        payload.close();
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        message.close();
         try {
-          payload.readAll(new Buffer());
+          message.source().readAll(new Buffer());
           fail();
         } catch (IllegalStateException e) {
           exception.set(e);
@@ -341,7 +345,17 @@
   @Test public void emptyCloseCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("8800")); // Empty close
     clientReader.processNextFrame();
-    callback.assertClose(0, "");
+    callback.assertClose(1000, "");
+  }
+
+  @Test public void closeLengthOfOneThrows() throws IOException {
+    data.write(ByteString.decodeHex("880100")); // Close with invalid 1-byte payload
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Malformed close payload length of 1.", e.getMessage());
+    }
   }
 
   @Test public void closeCallsCallback() throws IOException {
@@ -350,6 +364,44 @@
     callback.assertClose(1000, "Hello");
   }
 
+  @Test public void closeOutOfRangeThrows() throws IOException {
+    data.write(ByteString.decodeHex("88020001")); // Close with code 1
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Code must be in range [1000,5000): 1", e.getMessage());
+    }
+    data.write(ByteString.decodeHex("88021388")); // Close with code 5000
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Code must be in range [1000,5000): 5000", e.getMessage());
+    }
+  }
+
+  @Test public void closeReservedSetThrows() throws IOException {
+    data.write(ByteString.decodeHex("880203ec")); // Close with code 1004
+    data.write(ByteString.decodeHex("880203ed")); // Close with code 1005
+    data.write(ByteString.decodeHex("880203ee")); // Close with code 1006
+    for (int i = 1012; i <= 2999; i++) {
+      data.write(ByteString.decodeHex("8802" + Util.format("%04X", i))); // Close with code 'i'
+    }
+
+    int count = 0;
+    for (; !data.exhausted(); count++) {
+      try {
+        clientReader.processNextFrame();
+        fail();
+      } catch (ProtocolException e) {
+        String message = e.getMessage();
+        assertTrue(message, Pattern.matches("Code \\d+ is reserved and may not be used.", message));
+      }
+    }
+    assertEquals(1991, count);
+  }
+
   private byte[] binaryData(int length) {
     byte[] junk = new byte[length];
     random.nextBytes(junk);
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
new file mode 100644
index 0000000000..384151cf4a
--- /dev/null
+++ b/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -0,0 +1,407 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.Random;
+import okhttp3.RequestBody;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+import okio.Okio;
+import okio.Sink;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class WebSocketWriterTest {
+  private final Buffer data = new Buffer();
+  private final Random random = new Random(0);
+
+  /**
+   * Check all data as verified inside of the test. We do this in a rule instead of @After so that
+   * exceptions thrown from the test do not cause this check to fail.
+   */
+  @Rule public final TestRule noDataLeftBehind = new TestRule() {
+    @Override public Statement apply(final Statement base, Description description) {
+      return new Statement() {
+        @Override public void evaluate() throws Throwable {
+          base.evaluate();
+          assertEquals("Data not empty", "", data.readByteString().hex());
+        }
+      };
+    }
+  };
+
+  // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
+  private final WebSocketWriter serverWriter = new WebSocketWriter(false, data, random);
+  private final WebSocketWriter clientWriter = new WebSocketWriter(true, data, random);
+
+  @Test public void serverTextMessage() throws IOException {
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, -1));
+
+    sink.writeUtf8("Hel").flush();
+    assertData("010348656c");
+
+    sink.writeUtf8("lo").flush();
+    assertData("00026c6f");
+
+    sink.close();
+    assertData("8000");
+  }
+
+  @Test public void serverSmallBufferedPayloadWrittenAsOneFrame() throws IOException {
+    int length = 5;
+    byte[] bytes = binaryData(length);
+
+    RequestBody body = RequestBody.create(null, bytes);
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
+    body.writeTo(sink);
+    sink.close();
+
+    assertData("8105");
+    assertData(bytes);
+    assertTrue(data.exhausted());
+  }
+
+  @Test public void serverLargeBufferedPayloadWrittenAsOneFrame() throws IOException {
+    int length = 12345;
+    byte[] bytes = binaryData(length);
+
+    RequestBody body = RequestBody.create(null, bytes);
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
+    body.writeTo(sink);
+    sink.close();
+
+    assertData("817e");
+    assertData(Util.format("%04x", length));
+    assertData(bytes);
+    assertTrue(data.exhausted());
+  }
+
+  @Test public void serverLargeNonBufferedPayloadWrittenAsMultipleFrames() throws IOException {
+    int length = 100_000;
+    Buffer bytes = new Buffer().write(binaryData(length));
+
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
+    Buffer body = bytes.clone();
+    sink.write(body.readByteString(20_000));
+    sink.write(body.readByteString(20_000));
+    sink.write(body.readByteString(20_000));
+    sink.write(body.readByteString(20_000));
+    sink.write(body.readByteString(20_000));
+    sink.close();
+
+    assertData("017e4000");
+    assertData(bytes.readByteArray(16_384));
+    assertData("007e4000");
+    assertData(bytes.readByteArray(16_384));
+    assertData("007e6000");
+    assertData(bytes.readByteArray(24_576));
+    assertData("007e4000");
+    assertData(bytes.readByteArray(16_384));
+    assertData("007e6000");
+    assertData(bytes.readByteArray(24_576));
+    assertData("807e06a0");
+    assertData(bytes.readByteArray(1_696));
+    assertTrue(data.exhausted());
+  }
+
+  @Test public void closeFlushes() throws IOException {
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, -1));
+
+    sink.writeUtf8("Hel").flush();
+    assertData("010348656c");
+
+    sink.writeUtf8("lo").close();
+    assertData("80026c6f");
+  }
+
+  @Test public void noWritesAfterClose() throws IOException {
+    Sink sink = serverWriter.newMessageSink(OPCODE_TEXT, -1);
+
+    sink.close();
+    assertData("8100");
+
+    Buffer payload = new Buffer().writeUtf8("Hello");
+    try {
+      // Write to the unbuffered sink as BufferedSink keeps its own closed state.
+      sink.write(payload, payload.size());
+      fail();
+    } catch (IOException e) {
+      assertEquals("closed", e.getMessage());
+    }
+  }
+
+  @Test public void clientTextMessage() throws IOException {
+    BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_TEXT, -1));
+
+    sink.writeUtf8("Hel").flush();
+    assertData("018360b420bb28d14c");
+
+    sink.writeUtf8("lo").flush();
+    assertData("00823851d9d4543e");
+
+    sink.close();
+    assertData("80807acb933d");
+  }
+
+  @Test public void serverBinaryMessage() throws IOException {
+    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_BINARY, -1));
+
+    sink.write(binaryData(50)).flush();
+    assertData("0232");
+    assertData(binaryData(50));
+
+    sink.write(binaryData(50)).flush();
+    assertData("0032");
+    assertData(binaryData(50));
+
+    sink.close();
+    assertData("8000");
+  }
+
+  @Test public void serverMessageLengthShort() throws IOException {
+    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY, -1);
+
+    // Create a payload which will overflow the normal payload byte size.
+    Buffer payload = new Buffer();
+    while (payload.completeSegmentByteCount() <= PAYLOAD_BYTE_MAX) {
+      payload.writeByte('0');
+    }
+    long byteCount = payload.completeSegmentByteCount();
+
+    // Write directly to the unbuffered sink. This ensures it will become single frame.
+    sink.write(payload.clone(), byteCount);
+    assertData("027e"); // 'e' == 4-byte follow-up length.
+    assertData(Util.format("%04X", payload.completeSegmentByteCount()));
+    assertData(payload.readByteArray());
+
+    sink.close();
+    assertData("8000");
+  }
+
+  @Test public void serverMessageLengthLong() throws IOException {
+    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY, -1);
+
+    // Create a payload which will overflow the normal and short payload byte size.
+    Buffer payload = new Buffer();
+    while (payload.completeSegmentByteCount() <= PAYLOAD_SHORT_MAX) {
+      payload.writeByte('0');
+    }
+    long byteCount = payload.completeSegmentByteCount();
+
+    // Write directly to the unbuffered sink. This ensures it will become single frame.
+    sink.write(payload.clone(), byteCount);
+    assertData("027f"); // 'f' == 16-byte follow-up length.
+    assertData(Util.format("%016X", byteCount));
+    assertData(payload.readByteArray(byteCount));
+
+    sink.close();
+    assertData("8000");
+  }
+
+  @Test public void clientBinary() throws IOException {
+    byte[] maskKey1 = new byte[4];
+    random.nextBytes(maskKey1);
+    byte[] maskKey2 = new byte[4];
+    random.nextBytes(maskKey2);
+
+    random.setSeed(0); // Reset the seed so real data matches.
+
+    BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_BINARY, -1));
+
+    byte[] part1 = binaryData(50);
+    sink.write(part1).flush();
+    toggleMask(part1, 50, maskKey1, 0);
+    assertData("02b2");
+    assertData(maskKey1);
+    assertData(part1);
+
+    byte[] part2 = binaryData(50);
+    sink.write(part2).close();
+    toggleMask(part2, 50, maskKey2, 0);
+    assertData("80b2");
+    assertData(maskKey2);
+    assertData(part2);
+  }
+
+  @Test public void serverEmptyClose() throws IOException {
+    serverWriter.writeClose(0, null);
+    assertData("8800");
+  }
+
+  @Test public void serverCloseWithCode() throws IOException {
+    serverWriter.writeClose(1001, null);
+    assertData("880203e9");
+  }
+
+  @Test public void serverCloseWithCodeAndReason() throws IOException {
+    serverWriter.writeClose(1001, "Hello");
+    assertData("880703e948656c6c6f");
+  }
+
+  @Test public void clientEmptyClose() throws IOException {
+    clientWriter.writeClose(0, null);
+    assertData("888060b420bb");
+  }
+
+  @Test public void clientCloseWithCode() throws IOException {
+    clientWriter.writeClose(1001, null);
+    assertData("888260b420bb635d");
+  }
+
+  @Test public void clientCloseWithCodeAndReason() throws IOException {
+    clientWriter.writeClose(1001, "Hello");
+    assertData("888760b420bb635d68de0cd84f");
+  }
+
+  @Test public void closeWithOnlyReasonThrows() throws IOException {
+    clientWriter.writeClose(0, "Hello");
+    assertData("888760b420bb60b468de0cd84f");
+  }
+
+  @Test public void closeCodeOutOfRangeThrows() throws IOException {
+    try {
+      clientWriter.writeClose(98724976, "Hello");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Code must be in range [1000,5000): 98724976", e.getMessage());
+    }
+  }
+
+  @Test public void closeReservedThrows() throws IOException {
+    try {
+      clientWriter.writeClose(1005, "Hello");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Code 1005 is reserved and may not be used.", e.getMessage());
+    }
+  }
+
+  @Test public void serverEmptyPing() throws IOException {
+    serverWriter.writePing(null);
+    assertData("8900");
+  }
+
+  @Test public void clientEmptyPing() throws IOException {
+    clientWriter.writePing(null);
+    assertData("898060b420bb");
+  }
+
+  @Test public void serverPingWithPayload() throws IOException {
+    serverWriter.writePing(new Buffer().writeUtf8("Hello"));
+    assertData("890548656c6c6f");
+  }
+
+  @Test public void clientPingWithPayload() throws IOException {
+    clientWriter.writePing(new Buffer().writeUtf8("Hello"));
+    assertData("898560b420bb28d14cd70f");
+  }
+
+  @Test public void serverEmptyPong() throws IOException {
+    serverWriter.writePong(null);
+    assertData("8a00");
+  }
+
+  @Test public void clientEmptyPong() throws IOException {
+    clientWriter.writePong(null);
+    assertData("8a8060b420bb");
+  }
+
+  @Test public void serverPongWithPayload() throws IOException {
+    serverWriter.writePong(new Buffer().writeUtf8("Hello"));
+    assertData("8a0548656c6c6f");
+  }
+
+  @Test public void clientPongWithPayload() throws IOException {
+    clientWriter.writePong(new Buffer().writeUtf8("Hello"));
+    assertData("8a8560b420bb28d14cd70f");
+  }
+
+  @Test public void pingTooLongThrows() throws IOException {
+    try {
+      serverWriter.writePing(new Buffer().write(binaryData(1000)));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+    }
+  }
+
+  @Test public void pongTooLongThrows() throws IOException {
+    try {
+      serverWriter.writePong(new Buffer().write(binaryData(1000)));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+    }
+  }
+
+  @Test public void closeTooLongThrows() throws IOException {
+    try {
+      String longString = ByteString.of(binaryData(75)).hex();
+      serverWriter.writeClose(1000, longString);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+    }
+  }
+
+  @Test public void twoMessageSinksThrows() {
+    clientWriter.newMessageSink(OPCODE_TEXT, -1);
+    try {
+      clientWriter.newMessageSink(OPCODE_TEXT, -1);
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Another message writer is active. Did you call close()?", e.getMessage());
+    }
+  }
+
+  private void assertData(String hex) throws EOFException {
+    ByteString expected = ByteString.decodeHex(hex);
+    ByteString actual = data.readByteString(expected.size());
+    assertEquals(expected, actual);
+  }
+
+  private void assertData(byte[] data) throws IOException {
+    int byteCount = 16;
+    for (int i = 0; i < data.length; i += byteCount) {
+      int count = Math.min(byteCount, data.length - i);
+      Buffer expectedChunk = new Buffer();
+      expectedChunk.write(data, i, count);
+      assertEquals("At " + i, expectedChunk.readByteString(), this.data.readByteString(count));
+    }
+  }
+
+  private static byte[] binaryData(int length) {
+    byte[] junk = new byte[length];
+    new Random(0).nextBytes(junk);
+    return junk;
+  }
+}
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketCallTest.java b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
similarity index 75%
rename from okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketCallTest.java
rename to okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
index 895eb1f658..9315152093 100644
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketCallTest.java
+++ b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
@@ -13,15 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.ws;
-
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.testing.RecordingHostnameVerifier;
+package okhttp3.ws;
+
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
@@ -29,22 +22,29 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.SSLContext;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.SslContextBuilder;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.RecordingHostnameVerifier;
 import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
+import static okhttp3.ws.WebSocket.TEXT;
 
 public final class WebSocketCallTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
   private final SSLContext sslContext = SslContextBuilder.localhost();
   private final WebSocketRecorder listener = new WebSocketRecorder();
-  private final OkHttpClient client = new OkHttpClient();
   private final Random random = new Random(0);
+  private OkHttpClient client = new OkHttpClient();
 
   @After public void tearDown() {
     listener.assertExhausted();
@@ -64,7 +64,7 @@
     server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     WebSocket webSocket = awaitWebSocket();
-    webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello, WebSockets!"));
+    webSocket.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
     serverListener.assertTextMessage("Hello, WebSockets!");
   }
 
@@ -74,43 +74,7 @@
         new Thread() {
           @Override public void run() {
             try {
-              webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello, WebSockets!"));
-            } catch (IOException e) {
-              throw new AssertionError(e);
-            }
-          }
-        }.start();
-      }
-    };
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    awaitWebSocket();
-    listener.assertTextMessage("Hello, WebSockets!");
-  }
-
-  @Test public void clientStreamingMessage() throws IOException {
-    WebSocketRecorder serverListener = new WebSocketRecorder();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = awaitWebSocket();
-    BufferedSink sink = webSocket.newMessageSink(TEXT);
-    sink.writeUtf8("Hello, ").flush();
-    sink.writeUtf8("WebSockets!").flush();
-    sink.close();
-
-    serverListener.assertTextMessage("Hello, WebSockets!");
-  }
-
-  @Test public void serverStreamingMessage() throws IOException {
-    WebSocketListener serverListener = new EmptyWebSocketListener() {
-      @Override public void onOpen(final WebSocket webSocket, Response response) {
-        new Thread() {
-          @Override public void run() {
-            try {
-              BufferedSink sink = webSocket.newMessageSink(TEXT);
-              sink.writeUtf8("Hello, ").flush();
-              sink.writeUtf8("WebSockets!").flush();
-              sink.close();
+              webSocket.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
             } catch (IOException e) {
               throw new AssertionError(e);
             }
@@ -125,7 +89,7 @@
   }
 
   @Test public void okButNotOk() {
-    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse().setResponseCode(200));
     awaitWebSocket();
     listener.assertFailure(ProtocolException.class, "Expected HTTP 101 response but was '200 OK'");
   }
@@ -210,16 +174,20 @@
 
   @Test public void wssScheme() throws IOException {
     server.useHttps(sslContext.getSocketFactory(), false);
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
 
     websocketScheme("wss");
   }
 
   @Test public void httpsScheme() throws IOException {
     server.useHttps(sslContext.getSocketFactory(), false);
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client = client.newBuilder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
 
     websocketScheme("https");
   }
@@ -233,7 +201,7 @@ private void websocketScheme(String scheme) throws IOException {
         .build();
 
     WebSocket webSocket = awaitWebSocket(request1);
-    webSocket.sendMessage(TEXT, new Buffer().writeUtf8("abc"));
+    webSocket.sendMessage(RequestBody.create(TEXT, "abc"));
     serverListener.assertTextMessage("abc");
   }
 
@@ -255,9 +223,8 @@ private WebSocket awaitWebSocket(Request request) {
         latch.countDown();
       }
 
-      @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type)
-          throws IOException {
-        listener.onMessage(payload, type);
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        listener.onMessage(message);
       }
 
       @Override public void onPong(Buffer payload) {
@@ -290,8 +257,7 @@ private WebSocket awaitWebSocket(Request request) {
     @Override public void onOpen(WebSocket webSocket, Response response) {
     }
 
-    @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type)
-        throws IOException {
+    @Override public void onMessage(ResponseBody message) throws IOException {
     }
 
     @Override public void onPong(Buffer payload) {
diff --git a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketRecorder.java b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
similarity index 71%
rename from okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketRecorder.java
rename to okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
index 56b3810630..0f019c6b79 100644
--- a/okhttp-ws-tests/src/test/java/com/squareup/okhttp/ws/WebSocketRecorder.java
+++ b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
@@ -13,26 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.ws;
+package okhttp3.ws;
 
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.ws.WebSocketReader;
 import java.io.IOException;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
+import okhttp3.MediaType;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.ws.WebSocketReader;
 import okio.Buffer;
-import okio.BufferedSource;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
+import static okhttp3.ws.WebSocket.BINARY;
+import static okhttp3.ws.WebSocket.TEXT;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 public final class WebSocketRecorder implements WebSocketReader.FrameCallback, WebSocketListener {
   public interface MessageDelegate {
-    void onMessage(BufferedSource payload, WebSocket.PayloadType type) throws IOException;
+    void onMessage(ResponseBody message) throws IOException;
   }
 
   private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
@@ -46,16 +47,15 @@ public void setNextMessageDelegate(MessageDelegate delegate) {
   @Override public void onOpen(WebSocket webSocket, Response response) {
   }
 
-  @Override public void onMessage(BufferedSource source, WebSocket.PayloadType type)
-      throws IOException {
+  @Override public void onMessage(ResponseBody message) throws IOException {
     if (delegate != null) {
-      delegate.onMessage(source, type);
+      delegate.onMessage(message);
       delegate = null;
     } else {
-      Message message = new Message(type);
-      source.readAll(message.buffer);
-      source.close();
-      events.add(message);
+      Message event = new Message(message.contentType());
+      message.source().readAll(event.buffer);
+      message.close();
+      events.add(event);
     }
   }
 
@@ -87,28 +87,48 @@ private Object nextEvent() {
     }
   }
 
-  public void assertTextMessage(String payload) {
+  public void assertTextMessage(String payload) throws IOException {
     Message message = new Message(TEXT);
     message.buffer.writeUtf8(payload);
-    assertEquals(message, nextEvent());
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(message, actual);
   }
 
-  public void assertBinaryMessage(byte[] payload) {
+  public void assertBinaryMessage(byte[] payload) throws IOException {
     Message message = new Message(BINARY);
     message.buffer.write(payload);
-    assertEquals(message, nextEvent());
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(message, actual);
   }
 
-  public void assertPing(Buffer payload) {
-    assertEquals(new Ping(payload), nextEvent());
+  public void assertPing(Buffer payload) throws IOException {
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(new Ping(payload), actual);
   }
 
-  public void assertPong(Buffer payload) {
-    assertEquals(new Pong(payload), nextEvent());
+  public void assertPong(Buffer payload) throws IOException {
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(new Pong(payload), actual);
   }
 
-  public void assertClose(int code, String reason) {
-    assertEquals(new Close(code, reason), nextEvent());
+  public void assertClose(int code, String reason) throws IOException {
+    Object actual = nextEvent();
+    if (actual instanceof IOException) {
+      throw (IOException) actual;
+    }
+    assertEquals(new Close(code, reason), actual);
   }
 
   public void assertFailure(Class<? extends IOException> cls, String message) {
@@ -125,25 +145,25 @@ public void assertExhausted() {
   }
 
   private static class Message {
-    public final WebSocket.PayloadType type;
+    public final MediaType mediaType;
     public final Buffer buffer = new Buffer();
 
-    private Message(WebSocket.PayloadType type) {
-      this.type = type;
+    private Message(MediaType mediaType) {
+      this.mediaType = mediaType;
     }
 
     @Override public String toString() {
-      return "Message[" + type + " " + buffer + "]";
+      return "Message[" + mediaType + " " + buffer + "]";
     }
 
     @Override public int hashCode() {
-      return type.hashCode() * 37 + buffer.hashCode();
+      return mediaType.hashCode() * 37 + buffer.hashCode();
     }
 
     @Override public boolean equals(Object obj) {
       if (obj instanceof Message) {
         Message other = (Message) obj;
-        return type == other.type && buffer.equals(other.buffer);
+        return mediaType.equals(other.mediaType) && buffer.equals(other.buffer);
       }
       return false;
     }
diff --git a/okhttp-ws/pom.xml b/okhttp-ws/pom.xml
index 80561c1eef..e6dbdb5472 100644
--- a/okhttp-ws/pom.xml
+++ b/okhttp-ws/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.5.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-ws</artifactId>
@@ -14,7 +14,7 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
@@ -26,7 +26,7 @@
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
-          <excludePackageNames>com.squareup.okhttp.internal.*</excludePackageNames>
+          <excludePackageNames>okhttp3.internal.*</excludePackageNames>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
           </links>
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
deleted file mode 100644
index 8d6b7c498b..0000000000
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
+++ /dev/null
@@ -1,189 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.ws;
-
-import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.ws.WebSocket;
-import com.squareup.okhttp.ws.WebSocketListener;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.concurrent.Executor;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-
-import static com.squareup.okhttp.internal.ws.WebSocketReader.FrameCallback;
-
-public abstract class RealWebSocket implements WebSocket {
-  /** A close code which indicates that the peer encountered a protocol exception. */
-  private static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
-
-  private final WebSocketWriter writer;
-  private final WebSocketReader reader;
-  private final WebSocketListener listener;
-
-  /** True after calling {@link #close(int, String)}. No writes are allowed afterward. */
-  private volatile boolean writerSentClose;
-  /** True after a close frame was read by the reader. No frames will follow it. */
-  private volatile boolean readerSentClose;
-  /** Lock required to negotiate closing the connection. */
-  private final Object closeLock = new Object();
-
-  public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random,
-      final Executor replyExecutor, final WebSocketListener listener, final String url) {
-    this.listener = listener;
-
-    writer = new WebSocketWriter(isClient, sink, random);
-    reader = new WebSocketReader(isClient, source, new FrameCallback() {
-      @Override public void onMessage(BufferedSource source, PayloadType type) throws IOException {
-        listener.onMessage(source, type);
-      }
-
-      @Override public void onPing(final Buffer buffer) {
-        replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Pong Reply", url) {
-          @Override protected void execute() {
-            try {
-              writer.writePong(buffer);
-            } catch (IOException ignored) {
-            }
-          }
-        });
-      }
-
-      @Override public void onPong(Buffer buffer) {
-        listener.onPong(buffer);
-      }
-
-      @Override public void onClose(final int code, final String reason) {
-        final boolean writeCloseResponse;
-        synchronized (closeLock) {
-          readerSentClose = true;
-
-          // If the writer has not indicated a desire to close we will write a close response.
-          writeCloseResponse = !writerSentClose;
-        }
-
-        replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Close Reply", url) {
-          @Override protected void execute() {
-            peerClose(code, reason, writeCloseResponse);
-          }
-        });
-      }
-    });
-  }
-
-  /**
-   * Read a single message from the web socket and deliver it to the listener. This method should
-   * be called in a loop with the return value indicating whether looping should continue.
-   */
-  public boolean readMessage() {
-    try {
-      reader.processNextFrame();
-      return !readerSentClose;
-    } catch (IOException e) {
-      readerErrorClose(e);
-      return false;
-    }
-  }
-
-  @Override public BufferedSink newMessageSink(PayloadType type) {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    return writer.newMessageSink(type);
-  }
-
-  @Override public void sendMessage(PayloadType type, Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    writer.sendMessage(type, payload);
-  }
-
-  @Override public void sendPing(Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    writer.writePing(payload);
-  }
-
-  /** Send an unsolicited pong with the specified payload. */
-  public void sendPong(Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    writer.writePong(payload);
-  }
-
-  @Override public void close(int code, String reason) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-
-    boolean closeConnection;
-    synchronized (closeLock) {
-      writerSentClose = true;
-
-      // If the reader has also indicated a desire to close we will close the connection.
-      closeConnection = readerSentClose;
-    }
-
-    writer.writeClose(code, reason);
-
-    if (closeConnection) {
-      closeConnection();
-    }
-  }
-
-  /** Replies and closes this web socket when a close frame is read from the peer. */
-  private void peerClose(int code, String reason, boolean writeCloseResponse) {
-    if (writeCloseResponse) {
-      try {
-        writer.writeClose(code, reason);
-      } catch (IOException ignored) {
-      }
-    }
-
-    try {
-      closeConnection();
-    } catch (IOException ignored) {
-    }
-
-    listener.onClose(code, reason);
-  }
-
-  /** Called on the reader thread when an error occurs. */
-  private void readerErrorClose(IOException e) {
-    boolean writeCloseResponse;
-    synchronized (closeLock) {
-      readerSentClose = true;
-
-      // If the writer has not closed we will close the connection.
-      writeCloseResponse = !writerSentClose;
-    }
-
-    if (writeCloseResponse) {
-      if (e instanceof ProtocolException) {
-        // For protocol exceptions, try to inform the server of such.
-        try {
-          writer.writeClose(CLOSE_PROTOCOL_EXCEPTION, null);
-        } catch (IOException ignored) {
-        }
-      }
-    }
-
-    try {
-      closeConnection();
-    } catch (IOException ignored) {
-    }
-
-    listener.onFailure(e, null);
-  }
-
-  /** Perform any tear-down work on the connection (close the socket, recycle, etc.). */
-  protected abstract void closeConnection() throws IOException;
-}
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java b/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
deleted file mode 100644
index fc5de753a1..0000000000
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
+++ /dev/null
@@ -1,292 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.ws;
-
-import java.io.IOException;
-import java.util.Random;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Timeout;
-
-import static com.squareup.okhttp.ws.WebSocket.PayloadType;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_BINARY;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_TEXT;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_MAX;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
-
-/**
- * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
- * <p>
- * This class is partially thread safe. Only a single "main" thread should be sending messages via
- * calls to {@link #newMessageSink} or {@link #sendMessage} as well as any calls to
- * {@link #writePing} or {@link #writeClose}. Other threads may call {@link #writePing},
- * {@link #writePong}, or {@link #writeClose} which will interleave on the wire with frames from
- * the main thread.
- */
-public final class WebSocketWriter {
-  private final boolean isClient;
-  /** Writes must be guarded by synchronizing on this instance! */
-  private final BufferedSink sink;
-  private final Random random;
-
-  private final FrameSink frameSink = new FrameSink();
-
-  private boolean closed;
-  private boolean activeWriter;
-
-  private final byte[] maskKey;
-  private final byte[] maskBuffer;
-
-  public WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
-    if (sink == null) throw new NullPointerException("sink == null");
-    if (random == null) throw new NullPointerException("random == null");
-    this.isClient = isClient;
-    this.sink = sink;
-    this.random = random;
-
-    // Masks are only a concern for client writers.
-    maskKey = isClient ? new byte[4] : null;
-    maskBuffer = isClient ? new byte[2048] : null;
-  }
-
-  /** Send a ping with the supplied {@code payload}. Payload may be {@code null} */
-  public void writePing(Buffer payload) throws IOException {
-    synchronized (sink) {
-      writeControlFrame(OPCODE_CONTROL_PING, payload);
-    }
-  }
-
-  /** Send a pong with the supplied {@code payload}. Payload may be {@code null} */
-  public void writePong(Buffer payload) throws IOException {
-    synchronized (sink) {
-      writeControlFrame(OPCODE_CONTROL_PONG, payload);
-    }
-  }
-
-  /**
-   * Send a close frame with optional code and reason.
-   *
-   * @param code Status code as defined by
-   * <a href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or
-   * {@code 0}.
-   * @param reason Reason for shutting down or {@code null}.
-   */
-  public void writeClose(int code, String reason) throws IOException {
-    Buffer payload = null;
-    if (code != 0 || reason != null) {
-      if (code != 0 && (code < 1000 || code >= 5000)) {
-        throw new IllegalArgumentException("Code must be in range [1000,5000).");
-      }
-      payload = new Buffer();
-      payload.writeShort(code);
-      if (reason != null) {
-        payload.writeUtf8(reason);
-      }
-    }
-
-    synchronized (sink) {
-      writeControlFrame(OPCODE_CONTROL_CLOSE, payload);
-      closed = true;
-    }
-  }
-
-  private void writeControlFrame(int opcode, Buffer payload) throws IOException {
-    if (closed) throw new IOException("closed");
-
-    int length = 0;
-    if (payload != null) {
-      length = (int) payload.size();
-      if (length > PAYLOAD_MAX) {
-        throw new IllegalArgumentException(
-            "Payload size must be less than or equal to " + PAYLOAD_MAX);
-      }
-    }
-
-    int b0 = B0_FLAG_FIN | opcode;
-    sink.writeByte(b0);
-
-    int b1 = length;
-    if (isClient) {
-      b1 |= B1_FLAG_MASK;
-      sink.writeByte(b1);
-
-      random.nextBytes(maskKey);
-      sink.write(maskKey);
-
-      if (payload != null) {
-        writeAllMasked(payload, length);
-      }
-    } else {
-      sink.writeByte(b1);
-
-      if (payload != null) {
-        sink.writeAll(payload);
-      }
-    }
-
-    sink.flush();
-  }
-
-  /**
-   * Stream a message payload as a series of frames. This allows control frames to be interleaved
-   * between parts of the message.
-   */
-  public BufferedSink newMessageSink(PayloadType type) {
-    if (type == null) throw new NullPointerException("type == null");
-    if (activeWriter) {
-      throw new IllegalStateException("Another message writer is active. Did you call close()?");
-    }
-    activeWriter = true;
-
-    frameSink.payloadType = type;
-    frameSink.isFirstFrame = true;
-    return Okio.buffer(frameSink);
-  }
-
-  /**
-   * Send a message payload as a single frame. This will block any control frames that need sent
-   * until it is completed.
-   */
-  public void sendMessage(PayloadType type, Buffer payload) throws IOException {
-    if (type == null) throw new NullPointerException("type == null");
-    if (payload == null) throw new NullPointerException("payload == null");
-    if (activeWriter) {
-      throw new IllegalStateException("A message writer is active. Did you call close()?");
-    }
-    writeFrame(type, payload, payload.size(), true /* first frame */, true /* final */);
-  }
-
-  private void writeFrame(PayloadType payloadType, Buffer source, long byteCount,
-      boolean isFirstFrame, boolean isFinal) throws IOException {
-    if (closed) throw new IOException("closed");
-
-    int opcode = OPCODE_CONTINUATION;
-    if (isFirstFrame) {
-      switch (payloadType) {
-        case TEXT:
-          opcode = OPCODE_TEXT;
-          break;
-        case BINARY:
-          opcode = OPCODE_BINARY;
-          break;
-        default:
-          throw new IllegalStateException("Unknown payload type: " + payloadType);
-      }
-    }
-
-    synchronized (sink) {
-      int b0 = opcode;
-      if (isFinal) {
-        b0 |= B0_FLAG_FIN;
-      }
-      sink.writeByte(b0);
-
-      int b1 = 0;
-      if (isClient) {
-        b1 |= B1_FLAG_MASK;
-        random.nextBytes(maskKey);
-      }
-      if (byteCount <= PAYLOAD_MAX) {
-        b1 |= (int) byteCount;
-        sink.writeByte(b1);
-      } else if (byteCount <= 0xffffL) { // Unsigned short.
-        b1 |= PAYLOAD_SHORT;
-        sink.writeByte(b1);
-        sink.writeShort((int) byteCount);
-      } else {
-        b1 |= PAYLOAD_LONG;
-        sink.writeByte(b1);
-        sink.writeLong(byteCount);
-      }
-
-      if (isClient) {
-        sink.write(maskKey);
-        writeAllMasked(source, byteCount);
-      } else {
-        sink.write(source, byteCount);
-      }
-
-      sink.flush();
-    }
-  }
-
-  private void writeAllMasked(BufferedSource source, long byteCount) throws IOException {
-    long written = 0;
-    while (written < byteCount) {
-      int toRead = (int) Math.min(byteCount, maskBuffer.length);
-      int read = source.read(maskBuffer, 0, toRead);
-      if (read == -1) throw new AssertionError();
-      toggleMask(maskBuffer, read, maskKey, written);
-      sink.write(maskBuffer, 0, read);
-      written += read;
-    }
-  }
-
-  private final class FrameSink implements Sink {
-    private PayloadType payloadType;
-    private boolean isFirstFrame;
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      writeFrame(payloadType, source, byteCount, isFirstFrame, false /* final */);
-      isFirstFrame = false;
-    }
-
-    @Override public void flush() throws IOException {
-      if (closed) throw new IOException("closed");
-
-      synchronized (sink) {
-        sink.flush();
-      }
-    }
-
-    @Override public Timeout timeout() {
-      return sink.timeout();
-    }
-
-    @SuppressWarnings("PointlessBitwiseExpression")
-    @Override public void close() throws IOException {
-      if (closed) throw new IOException("closed");
-
-      int length = 0;
-
-      synchronized (sink) {
-        sink.writeByte(B0_FLAG_FIN | OPCODE_CONTINUATION);
-
-        if (isClient) {
-          sink.writeByte(B1_FLAG_MASK | length);
-          random.nextBytes(maskKey);
-          sink.write(maskKey);
-        } else {
-          sink.writeByte(length);
-        }
-        sink.flush();
-      }
-
-      activeWriter = false;
-    }
-  }
-}
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java b/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
deleted file mode 100644
index 4cf2f42d6f..0000000000
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocket.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.ws;
-
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSink;
-
-/** Blocking interface to connect and write to a web socket. */
-public interface WebSocket {
-  /** The format of a message payload. */
-  enum PayloadType {
-    /** UTF8-encoded text data. */
-    TEXT,
-    /** Arbitrary binary data. */
-    BINARY
-  }
-
-  /**
-   * Stream a message payload to the server of the specified {code type}.
-   * <p>
-   * You must call {@link BufferedSink#close() close()} to complete the message. Calls to
-   * {@link BufferedSink#flush() flush()} write a frame fragment. The message may be empty.
-   *
-   * @throws IllegalStateException if not connected, already closed, or another writer is active.
-   */
-  BufferedSink newMessageSink(WebSocket.PayloadType type);
-
-  /**
-   * Send a message payload to the server of the specified {@code type}.
-   *
-   * @throws IllegalStateException if not connected, already closed, or another writer is active.
-   */
-  void sendMessage(WebSocket.PayloadType type, Buffer payload) throws IOException;
-
-  /**
-   * Send a ping to the server with optional payload.
-   *
-   * @throws IllegalStateException if already closed.
-   */
-  void sendPing(Buffer payload) throws IOException;
-
-  /**
-   * Send a close frame to the server.
-   * <p>
-   * The corresponding {@link WebSocketListener} will continue to get messages until its
-   * {@link WebSocketListener#onClose onClose()} method is called.
-   * <p>
-   * It is an error to call this method before calling close on an active writer. Calling this
-   * method more than once has no effect.
-   *
-   * @throws IllegalStateException if already closed.
-   */
-  void close(int code, String reason) throws IOException;
-}
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java
new file mode 100644
index 0000000000..b9af6bdd65
--- /dev/null
+++ b/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.ws.WebSocket;
+import okhttp3.ws.WebSocketListener;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static okhttp3.internal.ws.WebSocketReader.FrameCallback;
+
+public abstract class RealWebSocket implements WebSocket {
+  private static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
+
+  private final WebSocketWriter writer;
+  private final WebSocketReader reader;
+  private final WebSocketListener listener;
+
+  /** True after calling {@link #close(int, String)}. No writes are allowed afterward. */
+  private volatile boolean writerSentClose;
+  /** True after {@link IOException}. {@link #close(int, String)} becomes only valid call. */
+  private boolean writerWantsClose;
+  /** True after a close frame was read by the reader. No frames will follow it. */
+  private boolean readerSentClose;
+
+  /** True after calling {@link #close()} to free connection resources. */
+  private final AtomicBoolean connectionClosed = new AtomicBoolean();
+
+  public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random,
+      final Executor replyExecutor, final WebSocketListener listener, final String url) {
+    this.listener = listener;
+
+    writer = new WebSocketWriter(isClient, sink, random);
+    reader = new WebSocketReader(isClient, source, new FrameCallback() {
+      @Override public void onMessage(ResponseBody message) throws IOException {
+        listener.onMessage(message);
+      }
+
+      @Override public void onPing(final Buffer buffer) {
+        replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Pong Reply", url) {
+          @Override protected void execute() {
+            try {
+              writer.writePong(buffer);
+            } catch (IOException ignored) {
+            }
+          }
+        });
+      }
+
+      @Override public void onPong(Buffer buffer) {
+        listener.onPong(buffer);
+      }
+
+      @Override public void onClose(final int code, final String reason) {
+        readerSentClose = true;
+        replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Close Reply", url) {
+          @Override protected void execute() {
+            peerClose(code, reason);
+          }
+        });
+      }
+    });
+  }
+
+  /**
+   * Read a single message from the web socket and deliver it to the listener. This method should be
+   * called in a loop with the return value indicating whether looping should continue.
+   */
+  public boolean readMessage() {
+    try {
+      reader.processNextFrame();
+      return !readerSentClose;
+    } catch (IOException e) {
+      readerErrorClose(e);
+      return false;
+    }
+  }
+
+  @Override public void sendMessage(RequestBody message) throws IOException {
+    if (message == null) throw new NullPointerException("message == null");
+    if (writerSentClose) throw new IllegalStateException("closed");
+    if (writerWantsClose) throw new IllegalStateException("must call close()");
+
+    MediaType contentType = message.contentType();
+    if (contentType == null) {
+      throw new IllegalArgumentException(
+          "Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.");
+    }
+    String contentSubtype = contentType.subtype();
+
+    int formatOpcode;
+    if (WebSocket.TEXT.subtype().equals(contentSubtype)) {
+      formatOpcode = OPCODE_TEXT;
+    } else if (WebSocket.BINARY.subtype().equals(contentSubtype)) {
+      formatOpcode = OPCODE_BINARY;
+    } else {
+      throw new IllegalArgumentException("Unknown message content type: "
+          + contentType.type() + "/" + contentType.subtype() // Omit any implicitly added charset.
+          + ". Must use WebSocket.TEXT or WebSocket.BINARY.");
+    }
+
+    BufferedSink sink = Okio.buffer(writer.newMessageSink(formatOpcode, message.contentLength()));
+    try {
+      message.writeTo(sink);
+      sink.close();
+    } catch (IOException e) {
+      writerWantsClose = true;
+      throw e;
+    }
+  }
+
+  @Override public void sendPing(Buffer payload) throws IOException {
+    if (writerSentClose) throw new IllegalStateException("closed");
+    if (writerWantsClose) throw new IllegalStateException("must call close()");
+
+    try {
+      writer.writePing(payload);
+    } catch (IOException e) {
+      writerWantsClose = true;
+      throw e;
+    }
+  }
+
+  /** Send an unsolicited pong with the specified payload. */
+  public void sendPong(Buffer payload) throws IOException {
+    if (writerSentClose) throw new IllegalStateException("closed");
+    if (writerWantsClose) throw new IllegalStateException("must call close()");
+
+    try {
+      writer.writePong(payload);
+    } catch (IOException e) {
+      writerWantsClose = true;
+      throw e;
+    }
+  }
+
+  @Override public void close(int code, String reason) throws IOException {
+    if (writerSentClose) throw new IllegalStateException("closed");
+    writerSentClose = true;
+
+    try {
+      writer.writeClose(code, reason);
+    } catch (IOException e) {
+      if (connectionClosed.compareAndSet(false, true)) {
+        // Try to close the connection without masking the original exception.
+        try {
+          close();
+        } catch (IOException ignored) {
+        }
+      }
+      throw e;
+    }
+  }
+
+  /** Replies and closes this web socket when a close frame is read from the peer. */
+  private void peerClose(int code, String reason) {
+    if (!writerSentClose) {
+      try {
+        writer.writeClose(code, reason);
+      } catch (IOException ignored) {
+      }
+    }
+
+    if (connectionClosed.compareAndSet(false, true)) {
+      try {
+        close();
+      } catch (IOException ignored) {
+      }
+    }
+
+    listener.onClose(code, reason);
+  }
+
+  /** Called on the reader thread when an error occurs. */
+  private void readerErrorClose(IOException e) {
+    // For protocol exceptions, try to inform the server of such.
+    if (!writerSentClose && e instanceof ProtocolException) {
+      try {
+        writer.writeClose(CLOSE_PROTOCOL_EXCEPTION, null);
+      } catch (IOException ignored) {
+      }
+    }
+
+    if (connectionClosed.compareAndSet(false, true)) {
+      try {
+        close();
+      } catch (IOException ignored) {
+      }
+    }
+
+    listener.onFailure(e, null);
+  }
+
+  /** Perform any tear-down work (close the connection, shutdown executors). */
+  protected abstract void close() throws IOException;
+}
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
similarity index 69%
rename from okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
rename to okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
index 2b93398fa5..0a1126a147 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketProtocol.java
+++ b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
@@ -13,7 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package okhttp3.internal.ws;
+
+import java.net.ProtocolException;
 
 public final class WebSocketProtocol {
   /** Magic value which must be appended to the key in a response header. */
@@ -45,17 +47,15 @@
   static final int OPCODE_FLAG_CONTROL = 0b00001000;
 
   /**
-   * Byte 1 flag for whether the payload data is masked.
-   * <p>
-   * If this flag is set, the next four bytes represent the mask key. These bytes appear after
-   * any additional bytes specified by {@link #B1_MASK_LENGTH}.
+   * Byte 1 flag for whether the payload data is masked. <p> If this flag is set, the next four
+   * bytes represent the mask key. These bytes appear after any additional bytes specified by {@link
+   * #B1_MASK_LENGTH}.
    */
   static final int B1_FLAG_MASK = 0b10000000;
   /**
-   * Byte 1 mask for the payload length.
-   * <p>
-   * If this value is {@link #PAYLOAD_SHORT}, the next two bytes represent the length.
-   * If this value is {@link #PAYLOAD_LONG}, the next eight bytes represent the length.
+   * Byte 1 mask for the payload length. <p> If this value is {@link #PAYLOAD_SHORT}, the next two
+   * bytes represent the length. If this value is {@link #PAYLOAD_LONG}, the next eight bytes
+   * represent the length.
    */
   static final int B1_MASK_LENGTH = 0b01111111;
 
@@ -68,14 +68,16 @@
   static final int OPCODE_CONTROL_PONG = 0xa;
 
   /**
-   * Maximum length of frame payload. Larger payloads, if supported, can use the special values
-   * {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
+   * Maximum length of frame payload. Larger payloads, if supported by the frame type, can use the
+   * special values {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
    */
-  static final int PAYLOAD_MAX = 125;
+  static final long PAYLOAD_BYTE_MAX = 125L;
   /**
    * Value for {@link #B1_MASK_LENGTH} which indicates the next two bytes are the unsigned length.
    */
   static final int PAYLOAD_SHORT = 126;
+  /** Maximum length of a frame payload to be denoted as {@link #PAYLOAD_SHORT}. */
+  static final long PAYLOAD_SHORT_MAX = 0xffffL;
   /**
    * Value for {@link #B1_MASK_LENGTH} which indicates the next eight bytes are the unsigned
    * length.
@@ -90,6 +92,21 @@ static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameByte
     }
   }
 
+  static void validateCloseCode(int code, boolean argument) throws ProtocolException {
+    String message = null;
+    if (code < 1000 || code >= 5000) {
+      message = "Code must be in range [1000,5000): " + code;
+    } else if ((code >= 1004 && code <= 1006) || (code >= 1012 && code <= 2999)) {
+      message = "Code " + code + " is reserved and may not be used.";
+    }
+    if (message != null) {
+      if (argument) {
+        throw new IllegalArgumentException(message);
+      }
+      throw new ProtocolException(message);
+    }
+  }
+
   private WebSocketProtocol() {
     throw new AssertionError("No instances.");
   }
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java
similarity index 73%
rename from okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
rename to okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java
index ce548b17ea..8be28a2c5a 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
+++ b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java
@@ -13,46 +13,52 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.ws;
+package okhttp3.internal.ws;
 
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
+import okhttp3.MediaType;
+import okhttp3.ResponseBody;
+import okhttp3.ws.WebSocket;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV1;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV2;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_FLAG_RSV3;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B0_MASK_OPCODE;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.B1_MASK_LENGTH;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_BINARY;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_FLAG_CONTROL;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.OPCODE_TEXT;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_MAX;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
-import static com.squareup.okhttp.internal.ws.WebSocketProtocol.toggleMask;
 import static java.lang.Integer.toHexString;
+import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
+import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV1;
+import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV2;
+import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV3;
+import static okhttp3.internal.ws.WebSocketProtocol.B0_MASK_OPCODE;
+import static okhttp3.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
+import static okhttp3.internal.ws.WebSocketProtocol.B1_MASK_LENGTH;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_FLAG_CONTROL;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
+import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
+import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame reader.
  */
 public final class WebSocketReader {
   public interface FrameCallback {
-    void onMessage(BufferedSource source, PayloadType type) throws IOException;
+    void onMessage(ResponseBody body) throws IOException;
+
     void onPing(Buffer buffer);
+
     void onPong(Buffer buffer);
+
     void onClose(int code, String reason);
   }
 
@@ -74,7 +80,7 @@
   private boolean isMasked;
 
   private final byte[] maskKey = new byte[4];
-  private final byte[] maskBuffer = new byte[2048];
+  private final byte[] maskBuffer = new byte[8192];
 
   public WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
     if (source == null) throw new NullPointerException("source == null");
@@ -86,11 +92,12 @@ public WebSocketReader(boolean isClient, BufferedSource source, FrameCallback fr
 
   /**
    * Process the next protocol frame.
+   *
    * <ul>
-   * <li>If it is a control frame this will result in a single call to {@link FrameCallback}.</li>
-   * <li>If it is a message frame this will result in a single call to {@link
-   * FrameCallback#onMessage}. If the message spans multiple frames, each interleaved control
-   * frame will result in a corresponding call to {@link FrameCallback}.
+   *     <li>If it is a control frame this will result in a single call to {@link FrameCallback}.
+   *     <li>If it is a message frame this will result in a single call to {@link
+   *         FrameCallback#onMessage}. If the message spans multiple frames, each interleaved
+   *         control frame will result in a corresponding call to {@link FrameCallback}.
    * </ul>
    */
   public void processNextFrame() throws IOException {
@@ -145,8 +152,8 @@ private void readHeader() throws IOException {
     }
     frameBytesRead = 0;
 
-    if (isControlFrame && frameLength > PAYLOAD_MAX) {
-      throw new ProtocolException("Control frame must be less than " + PAYLOAD_MAX + "B.");
+    if (isControlFrame && frameLength > PAYLOAD_BYTE_MAX) {
+      throw new ProtocolException("Control frame must be less than " + PAYLOAD_BYTE_MAX + "B.");
     }
 
     if (isMasked) {
@@ -182,18 +189,18 @@ private void readControlFrame() throws IOException {
         frameCallback.onPong(buffer);
         break;
       case OPCODE_CONTROL_CLOSE:
-        int code = 0;
+        int code = 1000;
         String reason = "";
         if (buffer != null) {
-          if (buffer.size() < 2) {
-            throw new ProtocolException("Close payload must be at least two bytes.");
+          long bufferSize = buffer.size();
+          if (bufferSize == 1) {
+            throw new ProtocolException("Malformed close payload length of 1.");
+          } else if (bufferSize != 0) {
+            code = buffer.readShort();
+            validateCloseCode(code, false);
+
+            reason = buffer.readUtf8();
           }
-          code = buffer.readShort();
-          if (code < 1000 || code >= 5000) {
-            throw new ProtocolException("Code must be in range [1000,5000): " + code);
-          }
-
-          reason = buffer.readUtf8();
         }
         frameCallback.onClose(code, reason);
         closed = true;
@@ -204,20 +211,35 @@ private void readControlFrame() throws IOException {
   }
 
   private void readMessageFrame() throws IOException {
-    PayloadType type;
+    final MediaType type;
     switch (opcode) {
       case OPCODE_TEXT:
-        type = PayloadType.TEXT;
+        type = WebSocket.TEXT;
         break;
       case OPCODE_BINARY:
-        type = PayloadType.BINARY;
+        type = WebSocket.BINARY;
         break;
       default:
         throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
     }
 
+    final BufferedSource source = Okio.buffer(framedMessageSource);
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return type;
+      }
+
+      @Override public long contentLength() {
+        return -1;
+      }
+
+      @Override public BufferedSource source() {
+        return source;
+      }
+    };
+
     messageClosed = false;
-    frameCallback.onMessage(Okio.buffer(framedMessageSource), type);
+    frameCallback.onMessage(body);
     if (!messageClosed) {
       throw new IllegalStateException("Listener failed to call close on message payload.");
     }
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
new file mode 100644
index 0000000000..6ce0cfdd0a
--- /dev/null
+++ b/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -0,0 +1,277 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.IOException;
+import java.util.Random;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Sink;
+import okio.Timeout;
+
+import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
+import static okhttp3.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
+import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
+import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
+import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
+
+/**
+ * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
+ *
+ * <p>This class is partially thread safe. Only a single "main" thread should be sending messages
+ * via calls to {@link #newMessageSink}, {@link #writePing}, or {@link #writeClose}. Other threads
+ * may call {@link #writePing}, {@link #writePong}, or {@link #writeClose} which will interleave on
+ * the wire with frames from the "main" sending thread.
+ */
+public final class WebSocketWriter {
+  private final boolean isClient;
+  private final Random random;
+
+  /** Writes must be guarded by synchronizing on 'this'. */
+  private final BufferedSink sink;
+  /** Access must be guarded by synchronizing on 'this'. */
+  private boolean writerClosed;
+
+  private final Buffer buffer = new Buffer();
+  private final FrameSink frameSink = new FrameSink();
+
+  private boolean activeWriter;
+
+  private final byte[] maskKey;
+  private final byte[] maskBuffer;
+
+  public WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
+    if (sink == null) throw new NullPointerException("sink == null");
+    if (random == null) throw new NullPointerException("random == null");
+    this.isClient = isClient;
+    this.sink = sink;
+    this.random = random;
+
+    // Masks are only a concern for client writers.
+    maskKey = isClient ? new byte[4] : null;
+    maskBuffer = isClient ? new byte[8192] : null;
+  }
+
+  /** Send a ping with the supplied {@code payload}. Payload may be {@code null} */
+  public void writePing(Buffer payload) throws IOException {
+    synchronized (this) {
+      writeControlFrameSynchronized(OPCODE_CONTROL_PING, payload);
+    }
+  }
+
+  /** Send a pong with the supplied {@code payload}. Payload may be {@code null} */
+  public void writePong(Buffer payload) throws IOException {
+    synchronized (this) {
+      writeControlFrameSynchronized(OPCODE_CONTROL_PONG, payload);
+    }
+  }
+
+  /**
+   * Send a close frame with optional code and reason.
+   *
+   * @param code Status code as defined by <a
+   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
+   * @param reason Reason for shutting down or {@code null}.
+   */
+  public void writeClose(int code, String reason) throws IOException {
+    Buffer payload = null;
+    if (code != 0 || reason != null) {
+      if (code != 0) {
+        validateCloseCode(code, true);
+      }
+      payload = new Buffer();
+      payload.writeShort(code);
+      if (reason != null) {
+        payload.writeUtf8(reason);
+      }
+    }
+
+    synchronized (this) {
+      writeControlFrameSynchronized(OPCODE_CONTROL_CLOSE, payload);
+      writerClosed = true;
+    }
+  }
+
+  private void writeControlFrameSynchronized(int opcode, Buffer payload) throws IOException {
+    assert Thread.holdsLock(this);
+
+    if (writerClosed) throw new IOException("closed");
+
+    int length = 0;
+    if (payload != null) {
+      length = (int) payload.size();
+      if (length > PAYLOAD_BYTE_MAX) {
+        throw new IllegalArgumentException(
+            "Payload size must be less than or equal to " + PAYLOAD_BYTE_MAX);
+      }
+    }
+
+    int b0 = B0_FLAG_FIN | opcode;
+    sink.writeByte(b0);
+
+    int b1 = length;
+    if (isClient) {
+      b1 |= B1_FLAG_MASK;
+      sink.writeByte(b1);
+
+      random.nextBytes(maskKey);
+      sink.write(maskKey);
+
+      if (payload != null) {
+        writeMaskedSynchronized(payload, length);
+      }
+    } else {
+      sink.writeByte(b1);
+
+      if (payload != null) {
+        sink.writeAll(payload);
+      }
+    }
+
+    sink.emit();
+  }
+
+  /**
+   * Stream a message payload as a series of frames. This allows control frames to be interleaved
+   * between parts of the message.
+   */
+  public Sink newMessageSink(int formatOpcode, long contentLength) {
+    if (activeWriter) {
+      throw new IllegalStateException("Another message writer is active. Did you call close()?");
+    }
+    activeWriter = true;
+
+    // Reset FrameSink state for a new writer.
+    frameSink.formatOpcode = formatOpcode;
+    frameSink.contentLength = contentLength;
+    frameSink.isFirstFrame = true;
+    frameSink.closed = false;
+
+    return frameSink;
+  }
+
+  private void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isFirstFrame,
+      boolean isFinal) throws IOException {
+    assert Thread.holdsLock(this);
+
+    if (writerClosed) throw new IOException("closed");
+
+    int b0 = isFirstFrame ? formatOpcode : OPCODE_CONTINUATION;
+    if (isFinal) {
+      b0 |= B0_FLAG_FIN;
+    }
+    sink.writeByte(b0);
+
+    int b1 = 0;
+    if (isClient) {
+      b1 |= B1_FLAG_MASK;
+      random.nextBytes(maskKey);
+    }
+    if (byteCount <= PAYLOAD_BYTE_MAX) {
+      b1 |= (int) byteCount;
+      sink.writeByte(b1);
+    } else if (byteCount <= PAYLOAD_SHORT_MAX) {
+      b1 |= PAYLOAD_SHORT;
+      sink.writeByte(b1);
+      sink.writeShort((int) byteCount);
+    } else {
+      b1 |= PAYLOAD_LONG;
+      sink.writeByte(b1);
+      sink.writeLong(byteCount);
+    }
+
+    if (isClient) {
+      sink.write(maskKey);
+      writeMaskedSynchronized(buffer, byteCount);
+    } else {
+      sink.write(buffer, byteCount);
+    }
+
+    sink.emit();
+  }
+
+  private void writeMaskedSynchronized(BufferedSource source, long byteCount) throws IOException {
+    assert Thread.holdsLock(this);
+
+    long written = 0;
+    while (written < byteCount) {
+      int toRead = (int) Math.min(byteCount, maskBuffer.length);
+      int read = source.read(maskBuffer, 0, toRead);
+      if (read == -1) throw new AssertionError();
+      toggleMask(maskBuffer, read, maskKey, written);
+      sink.write(maskBuffer, 0, read);
+      written += read;
+    }
+  }
+
+  private final class FrameSink implements Sink {
+    private int formatOpcode;
+    private long contentLength;
+    private boolean isFirstFrame;
+    private boolean closed;
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      if (closed) throw new IOException("closed");
+
+      buffer.write(source, byteCount);
+
+      // Determine if this is a buffered write which we can defer until close() flushes.
+      boolean deferWrite = isFirstFrame
+          && contentLength != -1
+          && buffer.size() > contentLength - 8192 /* segment size */;
+
+      long emitCount = buffer.completeSegmentByteCount();
+      if (emitCount > 0 && !deferWrite) {
+        synchronized (WebSocketWriter.this) {
+          writeMessageFrameSynchronized(formatOpcode, emitCount, isFirstFrame, false /* final */);
+        }
+        isFirstFrame = false;
+      }
+    }
+
+    @Override public void flush() throws IOException {
+      if (closed) throw new IOException("closed");
+
+      synchronized (WebSocketWriter.this) {
+        writeMessageFrameSynchronized(formatOpcode, buffer.size(), isFirstFrame, false /* final */);
+      }
+      isFirstFrame = false;
+    }
+
+    @Override public Timeout timeout() {
+      return sink.timeout();
+    }
+
+    @SuppressWarnings("PointlessBitwiseExpression")
+    @Override public void close() throws IOException {
+      if (closed) throw new IOException("closed");
+
+      synchronized (WebSocketWriter.this) {
+        writeMessageFrameSynchronized(formatOpcode, buffer.size(), isFirstFrame, true /* final */);
+      }
+      closed = true;
+      activeWriter = false;
+    }
+  }
+}
diff --git a/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java b/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java
new file mode 100644
index 0000000000..7435c01d7f
--- /dev/null
+++ b/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.ws;
+
+import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okio.Buffer;
+
+/** Blocking interface to connect and write to a web socket. */
+public interface WebSocket {
+  /** A {@link MediaType} indicating UTF-8 text frames should be used when sending the message. */
+  MediaType TEXT = MediaType.parse("application/vnd.okhttp.websocket+text; charset=utf-8");
+  /** A {@link MediaType} indicating binary frames should be used when sending the message. */
+  MediaType BINARY = MediaType.parse("application/vnd.okhttp.websocket+binary");
+
+  /**
+   * Send a message payload to the server.
+   *
+   * <p>The {@linkplain RequestBody#contentType() content type} of {@code message} should be either
+   * {@link #TEXT} or {@link #BINARY}.
+   *
+   * @throws IOException if unable to write the message. Clients must call {@link #close} when this
+   * happens to ensure resources are cleaned up.
+   * @throws IllegalStateException if not connected, already closed, or another writer is active.
+   */
+  void sendMessage(RequestBody message) throws IOException;
+
+  /**
+   * Send a ping to the server with optional payload.
+   *
+   * @throws IOException if unable to write the ping.  Clients must call {@link #close} when this
+   * happens to ensure resources are cleaned up.
+   * @throws IllegalStateException if already closed.
+   */
+  void sendPing(Buffer payload) throws IOException;
+
+  /**
+   * Send a close frame to the server.
+   *
+   * <p>The corresponding {@link WebSocketListener} will continue to get messages until its {@link
+   * WebSocketListener#onClose onClose()} method is called.
+   *
+   * <p>It is an error to call this method before calling close on an active writer. Calling this
+   * method more than once has no effect.
+   *
+   * @throws IOException if unable to write the close message. Resources will still be freed.
+   * @throws IllegalStateException if already closed.
+   */
+  void close(int code, String reason) throws IOException;
+}
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketCall.java b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
similarity index 58%
rename from okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketCall.java
rename to okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
index 46ee8a133e..46f8181036 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketCall.java
+++ b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
@@ -13,28 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.ws;
-
-import com.squareup.okhttp.Call;
-import com.squareup.okhttp.Callback;
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.ws.RealWebSocket;
-import com.squareup.okhttp.internal.ws.WebSocketProtocol;
+package okhttp3.ws;
+
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.security.SecureRandom;
 import java.util.Collections;
 import java.util.Random;
-import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.ThreadPoolExecutor;
-import okio.BufferedSink;
-import okio.BufferedSource;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.ws.RealWebSocket;
+import okhttp3.internal.ws.WebSocketProtocol;
 import okio.ByteString;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
@@ -47,7 +46,6 @@ public static WebSocketCall create(OkHttpClient client, Request request) {
     return new WebSocketCall(client, request);
   }
 
-  private final Request request;
   private final Call call;
   private final Random random;
   private final String key;
@@ -66,11 +64,9 @@ public static WebSocketCall create(OkHttpClient client, Request request) {
     random.nextBytes(nonce);
     key = ByteString.of(nonce).base64();
 
-    // Copy the client. Otherwise changes (socket factory, redirect policy,
-    // etc.) may incorrectly be reflected in the request when it is executed.
-    client = client.clone();
-    // Force HTTP/1.1 until the WebSocket over HTTP/2 version is finalized.
-    client.setProtocols(Collections.singletonList(com.squareup.okhttp.Protocol.HTTP_1_1));
+    client = client.newBuilder()
+        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
+        .build();
 
     request = request.newBuilder()
         .header("Upgrade", "websocket")
@@ -78,7 +74,6 @@ public static WebSocketCall create(OkHttpClient client, Request request) {
         .header("Sec-WebSocket-Key", key)
         .header("Sec-WebSocket-Version", "13")
         .build();
-    this.request = request;
 
     call = client.newCall(request);
   }
@@ -86,8 +81,8 @@ public static WebSocketCall create(OkHttpClient client, Request request) {
   /**
    * Schedules the request to be executed at some point in the future.
    *
-   * <p>The {@link OkHttpClient#getDispatcher dispatcher} defines when the request will run:
-   * usually immediately unless there are several other requests currently being executed.
+   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
+   * immediately unless there are several other requests currently being executed.
    *
    * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
    * failure exception. If you {@link #cancel} a request before it completes the callback will not
@@ -97,7 +92,7 @@ public static WebSocketCall create(OkHttpClient client, Request request) {
    */
   public void enqueue(final WebSocketListener listener) {
     Callback responseCallback = new Callback() {
-      @Override public void onResponse(Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) throws IOException {
         try {
           createWebSocket(response, listener);
         } catch (IOException e) {
@@ -105,7 +100,7 @@ public void enqueue(final WebSocketListener listener) {
         }
       }
 
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(Call call, IOException e) {
         listener.onFailure(e, null);
       }
     };
@@ -118,11 +113,9 @@ public void cancel() {
     call.cancel();
   }
 
-  private void createWebSocket(Response response, WebSocketListener listener)
-      throws IOException {
+  private void createWebSocket(Response response, WebSocketListener listener) throws IOException {
     if (response.code() != 101) {
-      // TODO call.engine.releaseConnection();
-      Internal.instance.callEngineReleaseConnection(call);
+      Util.closeQuietly(response.body());
       throw new ProtocolException("Expected HTTP 101 response but was '"
           + response.code()
           + " "
@@ -150,21 +143,9 @@ private void createWebSocket(Response response, WebSocketListener listener)
           + "'");
     }
 
-    // TODO connection = call.engine.getConnection();
-    Connection connection = Internal.instance.callEngineGetConnection(call);
-    // TODO if (!connection.clearOwner()) {
-    if (!Internal.instance.clearOwner(connection)) {
-      throw new IllegalStateException("Unable to take ownership of connection.");
-    }
-
-    BufferedSource source = Internal.instance.connectionRawSource(connection);
-    BufferedSink sink = Internal.instance.connectionRawSink(connection);
-
-    final RealWebSocket webSocket =
-        ConnectionWebSocket.create(response, connection, source, sink, random, listener);
-
-    // TODO connection.setOwner(webSocket);
-    Internal.instance.connectionSetOwner(connection, webSocket);
+    StreamAllocation streamAllocation = Internal.instance.callEngineGetStreamAllocation(call);
+    RealWebSocket webSocket = StreamWebSocket.create(
+        streamAllocation, response, random, listener);
 
     listener.onOpen(webSocket, response);
 
@@ -173,30 +154,33 @@ private void createWebSocket(Response response, WebSocketListener listener)
   }
 
   // Keep static so that the WebSocketCall instance can be garbage collected.
-  private static class ConnectionWebSocket extends RealWebSocket {
-    static RealWebSocket create(Response response, Connection connection, BufferedSource source,
-        BufferedSink sink, Random random, WebSocketListener listener) {
-      String url = response.request().urlString();
+  private static class StreamWebSocket extends RealWebSocket {
+    static RealWebSocket create(StreamAllocation streamAllocation, Response response,
+        Random random, WebSocketListener listener) {
+      String url = response.request().url().toString();
       ThreadPoolExecutor replyExecutor =
           new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-              Util.threadFactory(String.format("OkHttp %s WebSocket", url), true));
+              Util.threadFactory(Util.format("OkHttp %s WebSocket", url), true));
       replyExecutor.allowCoreThreadTimeOut(true);
 
-      return new ConnectionWebSocket(connection, source, sink, random, replyExecutor, listener,
-          url);
+      return new StreamWebSocket(streamAllocation, random, replyExecutor, listener, url);
     }
 
-    private final Connection connection;
+    private final StreamAllocation streamAllocation;
+    private final ExecutorService replyExecutor;
 
-    private ConnectionWebSocket(Connection connection, BufferedSource source, BufferedSink sink,
-        Random random, Executor replyExecutor, WebSocketListener listener, String url) {
-      super(true /* is client */, source, sink, random, replyExecutor, listener, url);
-      this.connection = connection;
+    private StreamWebSocket(StreamAllocation streamAllocation,
+        Random random, ExecutorService replyExecutor, WebSocketListener listener, String url) {
+      super(true /* is client */, streamAllocation.connection().source,
+          streamAllocation.connection().sink, random, replyExecutor, listener, url);
+      this.streamAllocation = streamAllocation;
+      this.replyExecutor = replyExecutor;
     }
 
-    @Override protected void closeConnection() throws IOException {
-      // TODO connection.closeIfOwnedBy(this);
-      Internal.instance.closeIfOwnedBy(connection, this);
+    @Override protected void close() throws IOException {
+      replyExecutor.shutdown();
+      streamAllocation.noNewStreams();
+      streamAllocation.streamFinished(true, streamAllocation.stream());
     }
   }
 }
diff --git a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java
similarity index 71%
rename from okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
rename to okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java
index 8941b7443b..12d5e66aab 100644
--- a/okhttp-ws/src/main/java/com/squareup/okhttp/ws/WebSocketListener.java
+++ b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java
@@ -13,24 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.ws;
+package okhttp3.ws;
 
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
 import okio.Buffer;
-import okio.BufferedSource;
-
-import static com.squareup.okhttp.ws.WebSocket.PayloadType;
 
 /** Listener for server-initiated messages on a connected {@link WebSocket}. */
 public interface WebSocketListener {
   /**
    * Called when the request has successfully been upgraded to a web socket. This method is called
-   * on the message reading thread to allow setting up any state before the
-   * {@linkplain #onMessage message}, {@linkplain #onPong pong}, and {@link #onClose close}
-   * callbacks start.
-   * <p>
-   * <b>Do not</b> use this callback to write to the web socket. Start a new thread or use
+   * on the message reading thread to allow setting up any state before the {@linkplain #onMessage
+   * message}, {@linkplain #onPong pong}, and {@link #onClose close} callbacks start.
+   *
+   * <p><b>Do not</b> use this callback to write to the web socket. Start a new thread or use
    * another thread in your application.
    */
   void onOpen(WebSocket webSocket, Response response);
@@ -44,14 +41,17 @@
   void onFailure(IOException e, Response response);
 
   /**
-   * Called when a server message is received. The {@code type} indicates whether the
-   * {@code payload} should be interpreted as UTF-8 text or binary data.
+   * Called when a server message is received. The {@code type} indicates whether the {@code
+   * payload} should be interpreted as UTF-8 text or binary data.
    *
    * <p>Implementations <strong>must</strong> call {@code source.close()} before returning. This
-   * indicates completion of parsing the message payload and will consume any remaining bytes in
-   * the message.
+   * indicates completion of parsing the message payload and will consume any remaining bytes in the
+   * message.
+   *
+   * <p>The {@linkplain ResponseBody#contentType() content type} of {@code message} will be either
+   * {@link WebSocket#TEXT} or {@link WebSocket#BINARY} which indicates the format of the message.
    */
-  void onMessage(BufferedSource payload, PayloadType type) throws IOException;
+  void onMessage(ResponseBody message) throws IOException;
 
   /**
    * Called when a server pong is received. This is usually a result of calling {@link
@@ -60,9 +60,8 @@
   void onPong(Buffer payload);
 
   /**
-   * Called when the server sends a close message. This may have been initiated
-   * from a call to {@link WebSocket#close(int, String) close()} or as an unprompted
-   * message from the server.
+   * Called when the server sends a close message. This may have been initiated from a call to
+   * {@link WebSocket#close(int, String) close()} or as an unprompted message from the server.
    *
    * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC-compliant</a>
    * status code.
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 8d8b5244fa..0db4e1a85e 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.5.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
@@ -17,6 +17,11 @@
       <groupId>com.squareup.okio</groupId>
       <artifactId>okio</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.android</groupId>
+      <artifactId>android</artifactId>
+      <scope>provided</scope>
+    </dependency>
   </dependencies>
 
   <build>
@@ -37,7 +42,7 @@
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
-          <excludePackageNames>com.squareup.okhttp.internal:com.squareup.okhttp.internal.*</excludePackageNames>
+          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
           <links>
             <link>http://square.github.io/okio/</link>
           </links>
diff --git a/okhttp/src/main/java-templates/com/squareup/okhttp/internal/Version.java b/okhttp/src/main/java-templates/okhttp3/internal/Version.java
similarity index 95%
rename from okhttp/src/main/java-templates/com/squareup/okhttp/internal/Version.java
rename to okhttp/src/main/java-templates/okhttp3/internal/Version.java
index 59fece92bf..fce1c067c0 100644
--- a/okhttp/src/main/java-templates/com/squareup/okhttp/internal/Version.java
+++ b/okhttp/src/main/java-templates/okhttp3/internal/Version.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
 public final class Version {
   public static String userAgent() {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java b/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java
deleted file mode 100644
index cb66dc6249..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import java.io.IOException;
-import java.net.Proxy;
-
-/**
- * Responds to authentication challenges from the remote web or proxy server.
- */
-public interface Authenticator {
-  /**
-   * Returns a request that includes a credential to satisfy an authentication
-   * challenge in {@code response}. Returns null if the challenge cannot be
-   * satisfied. This method is called in response to an HTTP 401 unauthorized
-   * status code sent by the origin server.
-   *
-   * <p>Typical implementations will look up a credential and create a request
-   * derived from the initial request by setting the "Authorization" header.
-   * <pre>   {@code
-   *
-   *    String credential = Credentials.basic(...)
-   *    return response.request().newBuilder()
-   *        .header("Authorization", credential)
-   *        .build();
-   * }</pre>
-   */
-  Request authenticate(Proxy proxy, Response response) throws IOException;
-
-  /**
-   * Returns a request that includes a credential to satisfy an authentication
-   * challenge made by {@code response}. Returns null if the challenge cannot be
-   * satisfied. This method is called in response to an HTTP 407 unauthorized
-   * status code sent by the proxy server.
-   *
-   * <p>Typical implementations will look up a credential and create a request
-   * derived from the initial request by setting the "Proxy-Authorization"
-   * header. <pre>   {@code
-   *
-   *    String credential = Credentials.basic(...)
-   *    return response.request().newBuilder()
-   *        .header("Proxy-Authorization", credential)
-   *        .build();
-   * }</pre>
-   */
-  Request authenticateProxy(Proxy proxy, Response response) throws IOException;
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java b/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java
deleted file mode 100644
index 15a29527dc..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java
+++ /dev/null
@@ -1,272 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Util;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.Arrays;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import okio.ByteString;
-
-import static java.util.Collections.unmodifiableSet;
-
-/**
- * Constrains which certificates are trusted. Pinning certificates defends
- * against attacks on certificate authorities. It also prevents connections
- * through man-in-the-middle certificate authorities either known or unknown to
- * the application's user.
- *
- * <p>This class currently pins a certificate's Subject Public Key Info as
- * described on <a href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins
- * are base-64 SHA-1 hashes, consistent with the format Chromium uses for <a
- * href="http://goo.gl/XDh6je">static certificates</a>. See Chromium's <a
- * href="http://goo.gl/4CCnGs">pinsets</a> for hostnames that are pinned in that
- * browser.
- *
- * <h3>Setting up Certificate Pinning</h3>
- * The easiest way to pin a host is turn on pinning with a broken configuration
- * and read the expected configuration when the connection fails. Be sure to
- * do this on a trusted network, and without man-in-the-middle tools like <a
- * href="http://charlesproxy.com">Charles</a> or <a
- * href="http://fiddlertool.com">Fiddler</a>.
- *
- * <p>For example, to pin {@code https://publicobject.com}, start with a broken
- * configuration: <pre>   {@code
- *
- *     String hostname = "publicobject.com";
- *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
- *         .add(hostname, "sha1/BOGUSPIN")
- *         .build();
- *     OkHttpClient client = new OkHttpClient();
- *     client.setCertificatePinner(certificatePinner);
- *
- *     Request request = new Request.Builder()
- *         .url("https://" + hostname)
- *         .build();
- *     client.newCall(request).execute();
- * }</pre>
- *
- * As expected, this fails with a certificate pinning exception: <pre>   {@code
- *
- * javax.net.ssl.SSLPeerUnverifiedException: Certificate pinning failure!
- *   Peer certificate chain:
- *     sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=: CN=publicobject.com, OU=PositiveSSL
- *     sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=: CN=COMODO RSA Domain Validation Secure Server CA
- *     sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=: CN=COMODO RSA Certification Authority
- *     sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=: CN=AddTrust External CA Root
- *   Pinned certificates for publicobject.com:
- *     sha1/BOGUSPIN
- *   at com.squareup.okhttp.CertificatePinner.check(CertificatePinner.java)
- *   at com.squareup.okhttp.Connection.upgradeToTls(Connection.java)
- *   at com.squareup.okhttp.Connection.connect(Connection.java)
- *   at com.squareup.okhttp.Connection.connectAndSetOwner(Connection.java)
- * }</pre>
- *
- * Follow up by pasting the public key hashes from the exception into the
- * certificate pinner's configuration: <pre>   {@code
- *
- *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
- *       .add("publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
- *       .add("publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
- *       .add("publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
- *       .add("publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
- *       .build();
- * }</pre>
- *
- * Pinning is per-hostname and/or per-wildcard pattern. To pin both
- * {@code publicobject.com} and {@code www.publicobject.com}, you must
- * configure both hostnames.
- *
- * <p>Wildcard pattern rules:
- * <ol>
- *   <li>Asterisk {@code *} is only permitted in the left-most
- *       domain name label and must be the only character in that label
- *       (i.e., must match the whole left-most label). For example,
- *       {@code *.example.com} is permitted, while {@code *a.example.com},
- *       {@code a*.example.com}, {@code a*b.example.com}, {@code a.*.example.com}
- *       are not permitted.
- *   <li>Asterisk {@code *} cannot match across domain name labels.
- *       For example, {@code *.example.com} matches {@code test.example.com}
- *       but does not match {@code sub.test.example.com}.
- *   <li>Wildcard patterns for single-label domain names are not permitted.
- * </ol>
- *
- * If hostname pinned directly and via wildcard pattern, both
- * direct and wildcard pins will be used. For example: {@code *.example.com} pinned
- * with {@code pin1} and {@code a.example.com} pinned with {@code pin2},
- * to check {@code a.example.com} both {@code pin1} and {@code pin2} will be used.
- *
- * <h3>Warning: Certificate Pinning is Dangerous!</h3>
- * Pinning certificates limits your server team's abilities to update their TLS
- * certificates. By pinning certificates, you take on additional operational
- * complexity and limit your ability to migrate between certificate authorities.
- * Do not use certificate pinning without the blessing of your server's TLS
- * administrator!
- *
- * <h4>Note about self-signed certificates</h4>
- * {@link CertificatePinner} can not be used to pin self-signed certificate
- * if such certificate is not accepted by {@link javax.net.ssl.TrustManager}.
- *
- * @see <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning">
- *     OWASP: Certificate and Public Key Pinning</a>
- */
-public final class CertificatePinner {
-  public static final CertificatePinner DEFAULT = new Builder().build();
-
-  private final Map<String, Set<ByteString>> hostnameToPins;
-
-  private CertificatePinner(Builder builder) {
-    hostnameToPins = Util.immutableMap(builder.hostnameToPins);
-  }
-
-  /**
-   * Confirms that at least one of the certificates pinned for {@code hostname}
-   * is in {@code peerCertificates}. Does nothing if there are no certificates
-   * pinned for {@code hostname}. OkHttp calls this after a successful TLS
-   * handshake, but before the connection is used.
-   *
-   * @throws SSLPeerUnverifiedException if {@code peerCertificates} don't match
-   *     the certificates pinned for {@code hostname}.
-   */
-  public void check(String hostname, List<Certificate> peerCertificates)
-      throws SSLPeerUnverifiedException {
-
-    Set<ByteString> pins = findMatchingPins(hostname);
-
-    if (pins == null) return;
-
-    for (int i = 0, size = peerCertificates.size(); i < size; i++) {
-      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
-      if (pins.contains(sha1(x509Certificate))) return; // Success!
-    }
-
-    // If we couldn't find a matching pin, format a nice exception.
-    StringBuilder message = new StringBuilder()
-        .append("Certificate pinning failure!")
-        .append("\n  Peer certificate chain:");
-    for (int i = 0, size = peerCertificates.size(); i < size; i++) {
-      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
-      message.append("\n    ").append(pin(x509Certificate))
-          .append(": ").append(x509Certificate.getSubjectDN().getName());
-    }
-    message.append("\n  Pinned certificates for ").append(hostname).append(":");
-    for (ByteString pin : pins) {
-      message.append("\n    sha1/").append(pin.base64());
-    }
-    throw new SSLPeerUnverifiedException(message.toString());
-  }
-
-  /** @deprecated replaced with {@link #check(String, List)}. */
-  public void check(String hostname, Certificate... peerCertificates)
-      throws SSLPeerUnverifiedException {
-    check(hostname, Arrays.asList(peerCertificates));
-  }
-
-  /**
-   * Returns list of matching certificates' pins for the hostname
-   * or {@code null} if hostname does not have pinned certificates.
-   */
-  Set<ByteString> findMatchingPins(String hostname) {
-    Set<ByteString> directPins   = hostnameToPins.get(hostname);
-    Set<ByteString> wildcardPins = null;
-
-    int indexOfFirstDot = hostname.indexOf('.');
-    int indexOfLastDot  = hostname.lastIndexOf('.');
-
-    // Skip hostnames with one dot symbol for wildcard pattern search
-    //   example.com   will  be skipped
-    //   a.example.com won't be skipped
-    if (indexOfFirstDot != indexOfLastDot) {
-      // a.example.com -> search for wildcard pattern *.example.com
-      wildcardPins = hostnameToPins.get("*." + hostname.substring(indexOfFirstDot + 1));
-    }
-
-    if (directPins == null && wildcardPins == null) return null;
-
-    if (directPins != null && wildcardPins != null) {
-      Set<ByteString> pins = new LinkedHashSet<>();
-      pins.addAll(directPins);
-      pins.addAll(wildcardPins);
-      return pins;
-    }
-
-    if (directPins != null) return directPins;
-
-    return wildcardPins;
-  }
-
-  /**
-   * Returns the SHA-1 of {@code certificate}'s public key. This uses the
-   * mechanism Moxie Marlinspike describes in <a
-   * href="https://github.com/moxie0/AndroidPinning">Android Pinning</a>.
-   */
-  public static String pin(Certificate certificate) {
-    if (!(certificate instanceof X509Certificate)) {
-      throw new IllegalArgumentException("Certificate pinning requires X509 certificates");
-    }
-    return "sha1/" + sha1((X509Certificate) certificate).base64();
-  }
-
-  private static ByteString sha1(X509Certificate x509Certificate) {
-    return Util.sha1(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
-  }
-
-  /** Builds a configured certificate pinner. */
-  public static final class Builder {
-    private final Map<String, Set<ByteString>> hostnameToPins = new LinkedHashMap<>();
-
-    /**
-     * Pins certificates for {@code hostname}.
-     *
-     * @param hostname lower-case host name or wildcard pattern such as {@code *.example.com}.
-     * @param pins SHA-1 hashes. Each pin is a SHA-1 hash of a
-     *     certificate's Subject Public Key Info, base64-encoded and prefixed with
-     *     {@code sha1/}.
-     */
-    public Builder add(String hostname, String... pins) {
-      if (hostname == null) throw new IllegalArgumentException("hostname == null");
-
-      Set<ByteString> hostPins = new LinkedHashSet<>();
-      Set<ByteString> previousPins = hostnameToPins.put(hostname, unmodifiableSet(hostPins));
-      if (previousPins != null) {
-        hostPins.addAll(previousPins);
-      }
-
-      for (String pin : pins) {
-        if (!pin.startsWith("sha1/")) {
-          throw new IllegalArgumentException("pins must start with 'sha1/': " + pin);
-        }
-        ByteString decodedPin = ByteString.decodeBase64(pin.substring("sha1/".length()));
-        if (decodedPin == null) {
-          throw new IllegalArgumentException("pins must be base64: " + pin);
-        }
-        hostPins.add(decodedPin);
-      }
-
-      return this;
-    }
-
-    public CertificatePinner build() {
-      return new CertificatePinner(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
deleted file mode 100644
index b184b8a8b3..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ /dev/null
@@ -1,512 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.ConnectionSpecSelector;
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.framed.FramedConnection;
-import com.squareup.okhttp.internal.http.FramedTransport;
-import com.squareup.okhttp.internal.http.HttpConnection;
-import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.HttpTransport;
-import com.squareup.okhttp.internal.http.OkHeaders;
-import com.squareup.okhttp.internal.http.RouteException;
-import com.squareup.okhttp.internal.http.Transport;
-import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
-import java.io.IOException;
-import java.net.Proxy;
-import java.net.Socket;
-import java.net.UnknownServiceException;
-import java.security.cert.X509Certificate;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Source;
-
-import static com.squareup.okhttp.internal.Util.closeQuietly;
-import static java.net.HttpURLConnection.HTTP_OK;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
-
-/**
- * The sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection. May be
- * used for multiple HTTP request/response exchanges. Connections may be direct
- * to the origin server or via a proxy.
- *
- * <p>Typically instances of this class are created, connected and exercised
- * automatically by the HTTP client. Applications may use this class to monitor
- * HTTP connections as members of a {@linkplain ConnectionPool connection pool}.
- *
- * <p>Do not confuse this class with the misnamed {@code HttpURLConnection},
- * which isn't so much a connection as a single request/response exchange.
- *
- * <h3>Modern TLS</h3>
- * There are tradeoffs when selecting which options to include when negotiating
- * a secure connection to a remote host. Newer TLS options are quite useful:
- * <ul>
- *   <li>Server Name Indication (SNI) enables one IP address to negotiate secure
- *       connections for multiple domain names.
- *   <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port
- *       (443) to be used for different HTTP and SPDY protocols.
- * </ul>
- * Unfortunately, older HTTPS servers refuse to connect when such options are
- * presented. Rather than avoiding these options entirely, this class allows a
- * connection to be attempted with modern options and then retried without them
- * should the attempt fail.
- */
-public final class Connection {
-  private final ConnectionPool pool;
-  private final Route route;
-
-  private Socket socket;
-  private boolean connected = false;
-  private HttpConnection httpConnection;
-  private FramedConnection framedConnection;
-  private Protocol protocol = Protocol.HTTP_1_1;
-  private long idleStartTimeNs;
-  private Handshake handshake;
-  private int recycleCount;
-
-  /**
-   * The object that owns this connection. Null if it is shared (for SPDY),
-   * belongs to a pool, or has been discarded. Guarded by {@code pool}, which
-   * clears the owner when an incoming connection is recycled.
-   */
-  private Object owner;
-
-  public Connection(ConnectionPool pool, Route route) {
-    this.pool = pool;
-    this.route = route;
-  }
-
-  Object getOwner() {
-    synchronized (pool) {
-      return owner;
-    }
-  }
-
-  void setOwner(Object owner) {
-    if (isFramed()) return; // Framed connections are shared.
-    synchronized (pool) {
-      if (this.owner != null) throw new IllegalStateException("Connection already has an owner!");
-      this.owner = owner;
-    }
-  }
-
-  /**
-   * Attempts to clears the owner of this connection. Returns true if the owner
-   * was cleared and the connection can be pooled or reused. This will return
-   * false if the connection cannot be pooled or reused, such as if it was
-   * closed with {@link #closeIfOwnedBy}.
-   */
-  boolean clearOwner() {
-    synchronized (pool) {
-      if (owner == null) {
-        // No owner? Don't reuse this connection.
-        return false;
-      }
-
-      owner = null;
-      return true;
-    }
-  }
-
-  /**
-   * Closes this connection if it is currently owned by {@code owner}. This also
-   * strips the ownership of the connection so it cannot be pooled or reused.
-   */
-  void closeIfOwnedBy(Object owner) throws IOException {
-    if (isFramed()) throw new IllegalStateException();
-    synchronized (pool) {
-      if (this.owner != owner) {
-        return; // Wrong owner. Perhaps a late disconnect?
-      }
-
-      this.owner = null; // Drop the owner so the connection won't be reused.
-    }
-
-    // Don't close() inside the synchronized block.
-    if (socket != null) {
-      socket.close();
-    }
-  }
-
-  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request,
-      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {
-    if (connected) throw new IllegalStateException("already connected");
-
-    RouteException routeException = null;
-    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
-    Proxy proxy = route.getProxy();
-    Address address = route.getAddress();
-
-    if (route.address.getSslSocketFactory() == null
-        && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
-      throw new RouteException(new UnknownServiceException(
-          "CLEARTEXT communication not supported: " + connectionSpecs));
-    }
-
-    while (!connected) {
-      try {
-        socket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP
-            ? address.getSocketFactory().createSocket()
-            : new Socket(proxy);
-        connectSocket(connectTimeout, readTimeout, writeTimeout, request,
-            connectionSpecSelector);
-        connected = true; // Success!
-      } catch (IOException e) {
-        Util.closeQuietly(socket);
-        socket = null;
-
-        if (routeException == null) {
-          routeException = new RouteException(e);
-        } else {
-          routeException.addConnectException(e);
-        }
-
-        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {
-          throw routeException;
-        }
-      }
-    }
-  }
-
-  /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
-  private void connectSocket(int connectTimeout, int readTimeout, int writeTimeout,
-      Request request, ConnectionSpecSelector connectionSpecSelector) throws IOException {
-    socket.setSoTimeout(readTimeout);
-    Platform.get().connectSocket(socket, route.getSocketAddress(), connectTimeout);
-
-    if (route.address.getSslSocketFactory() != null) {
-      connectTls(readTimeout, writeTimeout, request, connectionSpecSelector);
-    }
-
-    if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
-      socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.
-      framedConnection = new FramedConnection.Builder(route.address.uriHost, true, socket)
-          .protocol(protocol).build();
-      framedConnection.sendConnectionPreface();
-    } else {
-      httpConnection = new HttpConnection(pool, this, socket);
-    }
-  }
-
-  private void connectTls(int readTimeout, int writeTimeout, Request request,
-      ConnectionSpecSelector connectionSpecSelector) throws IOException {
-    if (route.requiresTunnel()) {
-      createTunnel(readTimeout, writeTimeout, request);
-    }
-
-    Address address = route.getAddress();
-    SSLSocketFactory sslSocketFactory = address.getSslSocketFactory();
-    boolean success = false;
-    SSLSocket sslSocket = null;
-    try {
-      // Create the wrapper over the connected socket.
-      sslSocket = (SSLSocket) sslSocketFactory.createSocket(
-          socket, address.getUriHost(), address.getUriPort(), true /* autoClose */);
-
-      // Configure the socket's ciphers, TLS versions, and extensions.
-      ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
-      if (connectionSpec.supportsTlsExtensions()) {
-        Platform.get().configureTlsExtensions(
-            sslSocket, address.getUriHost(), address.getProtocols());
-      }
-
-      // Force handshake. This can throw!
-      sslSocket.startHandshake();
-      Handshake unverifiedHandshake = Handshake.get(sslSocket.getSession());
-
-      // Verify that the socket's certificates are acceptable for the target host.
-      if (!address.getHostnameVerifier().verify(address.getUriHost(), sslSocket.getSession())) {
-        X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0);
-        throw new SSLPeerUnverifiedException("Hostname " + address.getUriHost() + " not verified:"
-            + "\n    certificate: " + CertificatePinner.pin(cert)
-            + "\n    DN: " + cert.getSubjectDN().getName()
-            + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
-      }
-
-      // Check that the certificate pinner is satisfied by the certificates presented.
-      address.getCertificatePinner().check(address.getUriHost(),
-          unverifiedHandshake.peerCertificates());
-
-      // Success! Save the handshake and the ALPN protocol.
-      String maybeProtocol = connectionSpec.supportsTlsExtensions()
-          ? Platform.get().getSelectedProtocol(sslSocket)
-          : null;
-      protocol = maybeProtocol != null
-          ? Protocol.get(maybeProtocol)
-          : Protocol.HTTP_1_1;
-      handshake = unverifiedHandshake;
-      socket = sslSocket;
-      success = true;
-    } finally {
-      if (sslSocket != null) {
-        Platform.get().afterHandshake(sslSocket);
-      }
-      if (!success) {
-        closeQuietly(sslSocket);
-      }
-    }
-  }
-
-  /**
-   * To make an HTTPS connection over an HTTP proxy, send an unencrypted
-   * CONNECT request to create the proxy connection. This may need to be
-   * retried if the proxy requires authorization.
-   */
-  private void createTunnel(int readTimeout, int writeTimeout, Request request) throws IOException {
-    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
-    Request tunnelRequest = createTunnelRequest(request);
-    HttpConnection tunnelConnection = new HttpConnection(pool, this, socket);
-    tunnelConnection.setTimeouts(readTimeout, writeTimeout);
-    HttpUrl url = tunnelRequest.httpUrl();
-    String requestLine = "CONNECT " + url.host() + ":" + url.port() + " HTTP/1.1";
-    while (true) {
-      tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
-      tunnelConnection.flush();
-      Response response = tunnelConnection.readResponse().request(tunnelRequest).build();
-      // The response body from a CONNECT should be empty, but if it is not then we should consume
-      // it before proceeding.
-      long contentLength = OkHeaders.contentLength(response);
-      if (contentLength == -1L) {
-        contentLength = 0L;
-      }
-      Source body = tunnelConnection.newFixedLengthSource(contentLength);
-      Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
-      body.close();
-
-      switch (response.code()) {
-        case HTTP_OK:
-          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
-          // that happens, then we will have buffered bytes that are needed by the SSLSocket!
-          // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
-          // that it will almost certainly fail because the proxy has sent unexpected data.
-          if (tunnelConnection.bufferSize() > 0) {
-            throw new IOException("TLS tunnel buffered too many bytes!");
-          }
-          return;
-
-        case HTTP_PROXY_AUTH:
-          tunnelRequest = OkHeaders.processAuthHeader(
-              route.getAddress().getAuthenticator(), response, route.getProxy());
-          if (tunnelRequest != null) continue;
-          throw new IOException("Failed to authenticate with proxy");
-
-        default:
-          throw new IOException(
-              "Unexpected response code for CONNECT: " + response.code());
-      }
-    }
-  }
-
-  /**
-   * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if
-   * no tunnel is necessary. Everything in the tunnel request is sent
-   * unencrypted to the proxy server, so tunnels include only the minimum set of
-   * headers. This avoids sending potentially sensitive data like HTTP cookies
-   * to the proxy unencrypted.
-   */
-  private Request createTunnelRequest(Request request) throws IOException {
-    HttpUrl tunnelUrl = new HttpUrl.Builder()
-        .scheme("https")
-        .host(request.httpUrl().host())
-        .port(request.httpUrl().port())
-        .build();
-    Request.Builder result = new Request.Builder()
-        .url(tunnelUrl)
-        .header("Host", Util.hostHeader(tunnelUrl))
-        .header("Proxy-Connection", "Keep-Alive"); // For HTTP/1.0 proxies like Squid.
-
-    // Copy over the User-Agent header if it exists.
-    String userAgent = request.header("User-Agent");
-    if (userAgent != null) {
-      result.header("User-Agent", userAgent);
-    }
-
-    // Copy over the Proxy-Authorization header if it exists.
-    String proxyAuthorization = request.header("Proxy-Authorization");
-    if (proxyAuthorization != null) {
-      result.header("Proxy-Authorization", proxyAuthorization);
-    }
-
-    return result.build();
-  }
-
-  /**
-   * Connects this connection if it isn't already. This creates tunnels, shares
-   * the connection with the connection pool, and configures timeouts.
-   */
-  void connectAndSetOwner(OkHttpClient client, Object owner, Request request)
-      throws RouteException {
-    setOwner(owner);
-
-    if (!isConnected()) {
-      List<ConnectionSpec> connectionSpecs = route.address.getConnectionSpecs();
-      connect(client.getConnectTimeout(), client.getReadTimeout(), client.getWriteTimeout(),
-          request, connectionSpecs, client.getRetryOnConnectionFailure());
-      if (isFramed()) {
-        client.getConnectionPool().share(this);
-      }
-      client.routeDatabase().connected(getRoute());
-    }
-
-    setTimeouts(client.getReadTimeout(), client.getWriteTimeout());
-  }
-
-  /** Returns true if {@link #connect} has been attempted on this connection. */
-  boolean isConnected() {
-    return connected;
-  }
-
-  /** Returns the route used by this connection. */
-  public Route getRoute() {
-    return route;
-  }
-
-  /**
-   * Returns the socket that this connection uses, or null if the connection
-   * is not currently connected.
-   */
-  public Socket getSocket() {
-    return socket;
-  }
-
-  BufferedSource rawSource() {
-    if (httpConnection == null) throw new UnsupportedOperationException();
-    return httpConnection.rawSource();
-  }
-
-  BufferedSink rawSink() {
-    if (httpConnection == null) throw new UnsupportedOperationException();
-    return httpConnection.rawSink();
-  }
-
-  /** Returns true if this connection is alive. */
-  boolean isAlive() {
-    return !socket.isClosed() && !socket.isInputShutdown() && !socket.isOutputShutdown();
-  }
-
-  /**
-   * Returns true if we are confident that we can read data from this
-   * connection. This is more expensive and more accurate than {@link
-   * #isAlive()}; callers should check {@link #isAlive()} first.
-   */
-  boolean isReadable() {
-    if (httpConnection != null) return httpConnection.isReadable();
-    return true; // Framed connections, and connections before connect() are both optimistic.
-  }
-
-  void resetIdleStartTime() {
-    if (framedConnection != null) throw new IllegalStateException("framedConnection != null");
-    this.idleStartTimeNs = System.nanoTime();
-  }
-
-  /** Returns true if this connection is idle. */
-  boolean isIdle() {
-    return framedConnection == null || framedConnection.isIdle();
-  }
-
-  /**
-   * Returns the time in ns when this connection became idle. Undefined if
-   * this connection is not idle.
-   */
-  long getIdleStartTimeNs() {
-    return framedConnection == null ? idleStartTimeNs : framedConnection.getIdleStartTimeNs();
-  }
-
-  public Handshake getHandshake() {
-    return handshake;
-  }
-
-  /** Returns the transport appropriate for this connection. */
-  Transport newTransport(HttpEngine httpEngine) throws IOException {
-    return (framedConnection != null)
-        ? new FramedTransport(httpEngine, framedConnection)
-        : new HttpTransport(httpEngine, httpConnection);
-  }
-
-  /**
-   * Returns true if this is a SPDY connection. Such connections can be used
-   * in multiple HTTP requests simultaneously.
-   */
-  boolean isFramed() {
-    return framedConnection != null;
-  }
-
-  /**
-   * Returns the protocol negotiated by this connection, or {@link
-   * Protocol#HTTP_1_1} if no protocol has been negotiated.
-   */
-  public Protocol getProtocol() {
-    return protocol;
-  }
-
-  /**
-   * Sets the protocol negotiated by this connection. Typically this is used
-   * when an HTTP/1.1 request is sent and an HTTP/1.0 response is received.
-   */
-  void setProtocol(Protocol protocol) {
-    if (protocol == null) throw new IllegalArgumentException("protocol == null");
-    this.protocol = protocol;
-  }
-
-  void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis)
-      throws RouteException {
-    if (!connected) throw new IllegalStateException("setTimeouts - not connected");
-
-    // Don't set timeouts on shared SPDY connections.
-    if (httpConnection != null) {
-      try {
-        socket.setSoTimeout(readTimeoutMillis);
-      } catch (IOException e) {
-        throw new RouteException(e);
-      }
-      httpConnection.setTimeouts(readTimeoutMillis, writeTimeoutMillis);
-    }
-  }
-
-  void incrementRecycleCount() {
-    recycleCount++;
-  }
-
-  /**
-   * Returns the number of times this connection has been returned to the
-   * connection pool.
-   */
-  int recycleCount() {
-    return recycleCount;
-  }
-
-  @Override public String toString() {
-    return "Connection{"
-        + route.address.uriHost + ":" + route.address.uriPort
-        + ", proxy="
-        + route.proxy
-        + " hostAddress="
-        + route.inetSocketAddress.getAddress().getHostAddress()
-        + " cipherSuite="
-        + (handshake != null ? handshake.cipherSuite() : "none")
-        + " protocol="
-        + protocol
-        + '}';
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
deleted file mode 100644
index da3ac73c4d..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ /dev/null
@@ -1,337 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
-import java.net.SocketException;
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.ListIterator;
-import java.util.concurrent.Executor;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-
-/**
- * Manages reuse of HTTP and SPDY connections for reduced network latency. HTTP
- * requests that share the same {@link com.squareup.okhttp.Address} may share a
- * {@link com.squareup.okhttp.Connection}. This class implements the policy of
- * which connections to keep open for future use.
- *
- * <p>The {@link #getDefault() system-wide default} uses system properties for
- * tuning parameters:
- * <ul>
- *     <li>{@code http.keepAlive} true if HTTP and SPDY connections should be
- *         pooled at all. Default is true.
- *     <li>{@code http.maxConnections} maximum number of idle connections to
- *         each to keep in the pool. Default is 5.
- *     <li>{@code http.keepAliveDuration} Time in milliseconds to keep the
- *         connection alive in the pool before closing it. Default is 5 minutes.
- *         This property isn't used by {@code HttpURLConnection}.
- * </ul>
- *
- * <p>The default instance <i>doesn't</i> adjust its configuration as system
- * properties are changed. This assumes that the applications that set these
- * parameters do so before making HTTP connections, and that this class is
- * initialized lazily.
- */
-public final class ConnectionPool {
-  private static final long DEFAULT_KEEP_ALIVE_DURATION_MS = 5 * 60 * 1000; // 5 min
-
-  private static final ConnectionPool systemDefault;
-
-  static {
-    String keepAlive = System.getProperty("http.keepAlive");
-    String keepAliveDuration = System.getProperty("http.keepAliveDuration");
-    String maxIdleConnections = System.getProperty("http.maxConnections");
-    long keepAliveDurationMs = keepAliveDuration != null ? Long.parseLong(keepAliveDuration)
-        : DEFAULT_KEEP_ALIVE_DURATION_MS;
-    if (keepAlive != null && !Boolean.parseBoolean(keepAlive)) {
-      systemDefault = new ConnectionPool(0, keepAliveDurationMs);
-    } else if (maxIdleConnections != null) {
-      systemDefault = new ConnectionPool(Integer.parseInt(maxIdleConnections), keepAliveDurationMs);
-    } else {
-      systemDefault = new ConnectionPool(5, keepAliveDurationMs);
-    }
-  }
-
-  /** The maximum number of idle connections for each address. */
-  private final int maxIdleConnections;
-  private final long keepAliveDurationNs;
-
-  private final LinkedList<Connection> connections = new LinkedList<>();
-
-  /**
-   * A background thread is used to cleanup expired connections. There will be, at most, a single
-   * thread running per connection pool.
-   *
-   * <p>A {@link ThreadPoolExecutor} is used and not a
-   * {@link java.util.concurrent.ScheduledThreadPoolExecutor}; ScheduledThreadPoolExecutors do not
-   * shrink. This executor shrinks the thread pool after a period of inactivity, and starts threads
-   * as needed. Delays are instead handled by the {@link #connectionsCleanupRunnable}. It is
-   * important that the {@link #connectionsCleanupRunnable} stops eventually, otherwise it will pin
-   * the thread, and thus the connection pool, in memory.
-   */
-  private Executor executor = new ThreadPoolExecutor(
-      0 /* corePoolSize */, 1 /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
-      new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
-
-  private final Runnable connectionsCleanupRunnable = new Runnable() {
-    @Override public void run() {
-      runCleanupUntilPoolIsEmpty();
-    }
-  };
-
-  public ConnectionPool(int maxIdleConnections, long keepAliveDurationMs) {
-    this.maxIdleConnections = maxIdleConnections;
-    this.keepAliveDurationNs = keepAliveDurationMs * 1000 * 1000;
-  }
-
-  public static ConnectionPool getDefault() {
-    return systemDefault;
-  }
-
-  /** Returns total number of connections in the pool. */
-  public synchronized int getConnectionCount() {
-    return connections.size();
-  }
-
-  /** @deprecated Use {@link #getMultiplexedConnectionCount()}. */
-  @Deprecated
-  public synchronized int getSpdyConnectionCount() {
-    return getMultiplexedConnectionCount();
-  }
-
-  /** Returns total number of multiplexed connections in the pool. */
-  public synchronized int getMultiplexedConnectionCount() {
-    int total = 0;
-    for (Connection connection : connections) {
-      if (connection.isFramed()) total++;
-    }
-    return total;
-  }
-
-  /** Returns total number of http connections in the pool. */
-  public synchronized int getHttpConnectionCount() {
-    return connections.size() - getMultiplexedConnectionCount();
-  }
-
-  /** Returns a recycled connection to {@code address}, or null if no such connection exists. */
-  public synchronized Connection get(Address address) {
-    Connection foundConnection = null;
-    for (ListIterator<Connection> i = connections.listIterator(connections.size());
-        i.hasPrevious(); ) {
-      Connection connection = i.previous();
-      if (!connection.getRoute().getAddress().equals(address)
-          || !connection.isAlive()
-          || System.nanoTime() - connection.getIdleStartTimeNs() >= keepAliveDurationNs) {
-        continue;
-      }
-      i.remove();
-      if (!connection.isFramed()) {
-        try {
-          Platform.get().tagSocket(connection.getSocket());
-        } catch (SocketException e) {
-          Util.closeQuietly(connection.getSocket());
-          // When unable to tag, skip recycling and close
-          Platform.get().logW("Unable to tagSocket(): " + e);
-          continue;
-        }
-      }
-      foundConnection = connection;
-      break;
-    }
-
-    if (foundConnection != null && foundConnection.isFramed()) {
-      connections.addFirst(foundConnection); // Add it back after iteration.
-    }
-
-    return foundConnection;
-  }
-
-  /**
-   * Gives {@code connection} to the pool. The pool may store the connection,
-   * or close it, as its policy describes.
-   *
-   * <p>It is an error to use {@code connection} after calling this method.
-   */
-  void recycle(Connection connection) {
-    if (connection.isFramed()) {
-      return;
-    }
-
-    if (!connection.clearOwner()) {
-      return; // This connection isn't eligible for reuse.
-    }
-
-    if (!connection.isAlive()) {
-      Util.closeQuietly(connection.getSocket());
-      return;
-    }
-
-    try {
-      Platform.get().untagSocket(connection.getSocket());
-    } catch (SocketException e) {
-      // When unable to remove tagging, skip recycling and close.
-      Platform.get().logW("Unable to untagSocket(): " + e);
-      Util.closeQuietly(connection.getSocket());
-      return;
-    }
-
-    synchronized (this) {
-      addConnection(connection);
-      connection.incrementRecycleCount();
-      connection.resetIdleStartTime();
-    }
-  }
-
-  private void addConnection(Connection connection) {
-    boolean empty = connections.isEmpty();
-    connections.addFirst(connection);
-    if (empty) {
-      executor.execute(connectionsCleanupRunnable);
-    } else {
-      notifyAll();
-    }
-  }
-
-  /**
-   * Shares the SPDY connection with the pool. Callers to this method may
-   * continue to use {@code connection}.
-   */
-  void share(Connection connection) {
-    if (!connection.isFramed()) throw new IllegalArgumentException();
-    if (!connection.isAlive()) return;
-    synchronized (this) {
-      addConnection(connection);
-    }
-  }
-
-  /** Close and remove all connections in the pool. */
-  public void evictAll() {
-    List<Connection> toEvict;
-    synchronized (this) {
-      toEvict = new ArrayList<>(connections);
-      connections.clear();
-      notifyAll();
-    }
-
-    for (int i = 0, size = toEvict.size(); i < size; i++) {
-      Util.closeQuietly(toEvict.get(i).getSocket());
-    }
-  }
-
-  private void runCleanupUntilPoolIsEmpty() {
-    while (true) {
-      if (!performCleanup()) return; // Halt cleanup.
-    }
-  }
-
-  /**
-   * Attempts to make forward progress on connection eviction. There are three possible outcomes:
-   *
-   * <h3>The pool is empty.</h3>
-   * In this case, this method returns false and the eviction job should exit because there are no
-   * further cleanup tasks coming. (If additional connections are added to the pool, another cleanup
-   * job must be enqueued.)
-   *
-   * <h3>Connections were evicted.</h3>
-   * At least one connections was eligible for immediate eviction and was evicted. The method
-   * returns true and cleanup should continue.
-   *
-   * <h3>We waited to evict.</h3>
-   * None of the pooled connections were eligible for immediate eviction. Instead, we waited until
-   * either a connection became eligible for eviction, or the connections list changed. In either
-   * case, the method returns true and cleanup should continue.
-   */
-  // VisibleForTesting
-  boolean performCleanup() {
-    List<Connection> evictableConnections;
-
-    synchronized (this) {
-      if (connections.isEmpty()) return false; // Halt cleanup.
-
-      evictableConnections = new ArrayList<>();
-      int idleConnectionCount = 0;
-      long now = System.nanoTime();
-      long nanosUntilNextEviction = keepAliveDurationNs;
-
-      // Collect connections eligible for immediate eviction.
-      for (ListIterator<Connection> i = connections.listIterator(connections.size());
-          i.hasPrevious(); ) {
-        Connection connection = i.previous();
-        long nanosUntilEviction = connection.getIdleStartTimeNs() + keepAliveDurationNs - now;
-        if (nanosUntilEviction <= 0 || !connection.isAlive()) {
-          i.remove();
-          evictableConnections.add(connection);
-        } else if (connection.isIdle()) {
-          idleConnectionCount++;
-          nanosUntilNextEviction = Math.min(nanosUntilNextEviction, nanosUntilEviction);
-        }
-      }
-
-      // If the pool has too many idle connections, gather more! Oldest to newest.
-      for (ListIterator<Connection> i = connections.listIterator(connections.size());
-          i.hasPrevious() && idleConnectionCount > maxIdleConnections; ) {
-        Connection connection = i.previous();
-        if (connection.isIdle()) {
-          evictableConnections.add(connection);
-          i.remove();
-          --idleConnectionCount;
-        }
-      }
-
-      // If there's nothing to evict, wait. (This will be interrupted if connections are added.)
-      if (evictableConnections.isEmpty()) {
-        try {
-          long millisUntilNextEviction = nanosUntilNextEviction / (1000 * 1000);
-          long remainderNanos = nanosUntilNextEviction - millisUntilNextEviction * (1000 * 1000);
-          this.wait(millisUntilNextEviction, (int) remainderNanos);
-          return true; // Cleanup continues.
-        } catch (InterruptedException ignored) {
-        }
-      }
-    }
-
-    // Actually do the eviction. Note that we avoid synchronized() when closing sockets.
-    for (int i = 0, size = evictableConnections.size(); i < size; i++) {
-      Connection expiredConnection = evictableConnections.get(i);
-      Util.closeQuietly(expiredConnection.getSocket());
-    }
-
-    return true; // Cleanup continues.
-  }
-
-  /**
-   * Replace the default {@link Executor} with a different one. Only use in tests.
-   */
-  // VisibleForTesting
-  void replaceCleanupExecutorForTests(Executor cleanupExecutor) {
-    this.executor = cleanupExecutor;
-  }
-
-  /**
-   * Returns a snapshot of the connections in this pool, ordered from newest to
-   * oldest. Only use in tests.
-   */
-  // VisibleForTesting
-  synchronized List<Connection> getConnections() {
-    return new ArrayList<>(connections);
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
deleted file mode 100644
index a9346701fb..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.Call.AsyncCall;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HttpEngine;
-import java.util.ArrayDeque;
-import java.util.Deque;
-import java.util.Iterator;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-
-/**
- * Policy on when async requests are executed.
- *
- * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you
- * supply your own executor, it should be able to run {@linkplain #getMaxRequests the
- * configured maximum} number of calls concurrently.
- */
-public final class Dispatcher {
-  private int maxRequests = 64;
-  private int maxRequestsPerHost = 5;
-
-  /** Executes calls. Created lazily. */
-  private ExecutorService executorService;
-
-  /** Ready calls in the order they'll be run. */
-  private final Deque<AsyncCall> readyCalls = new ArrayDeque<>();
-
-  /** Running calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<AsyncCall> runningCalls = new ArrayDeque<>();
-
-  /** In-flight synchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<Call> executedCalls = new ArrayDeque<>();
-
-  public Dispatcher(ExecutorService executorService) {
-    this.executorService = executorService;
-  }
-
-  public Dispatcher() {
-  }
-
-  public synchronized ExecutorService getExecutorService() {
-    if (executorService == null) {
-      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
-          new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
-    }
-    return executorService;
-  }
-
-  /**
-   * Set the maximum number of requests to execute concurrently. Above this
-   * requests queue in memory, waiting for the running calls to complete.
-   *
-   * <p>If more than {@code maxRequests} requests are in flight when this is
-   * invoked, those requests will remain in flight.
-   */
-  public synchronized void setMaxRequests(int maxRequests) {
-    if (maxRequests < 1) {
-      throw new IllegalArgumentException("max < 1: " + maxRequests);
-    }
-    this.maxRequests = maxRequests;
-    promoteCalls();
-  }
-
-  public synchronized int getMaxRequests() {
-    return maxRequests;
-  }
-
-  /**
-   * Set the maximum number of requests for each host to execute concurrently.
-   * This limits requests by the URL's host name. Note that concurrent requests
-   * to a single IP address may still exceed this limit: multiple hostnames may
-   * share an IP address or be routed through the same HTTP proxy.
-   *
-   * <p>If more than {@code maxRequestsPerHost} requests are in flight when this
-   * is invoked, those requests will remain in flight.
-   */
-  public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
-    if (maxRequestsPerHost < 1) {
-      throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
-    }
-    this.maxRequestsPerHost = maxRequestsPerHost;
-    promoteCalls();
-  }
-
-  public synchronized int getMaxRequestsPerHost() {
-    return maxRequestsPerHost;
-  }
-
-  synchronized void enqueue(AsyncCall call) {
-    if (runningCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
-      runningCalls.add(call);
-      getExecutorService().execute(call);
-    } else {
-      readyCalls.add(call);
-    }
-  }
-
-  /** Cancel all calls with the tag {@code tag}. */
-  public synchronized void cancel(Object tag) {
-    for (AsyncCall call : readyCalls) {
-      if (Util.equal(tag, call.tag())) {
-        call.cancel();
-      }
-    }
-
-    for (AsyncCall call : runningCalls) {
-      if (Util.equal(tag, call.tag())) {
-        call.get().canceled = true;
-        HttpEngine engine = call.get().engine;
-        if (engine != null) engine.disconnect();
-      }
-    }
-
-    for (Call call : executedCalls) {
-      if (Util.equal(tag, call.tag())) {
-        call.cancel();
-      }
-    }
-  }
-
-  /** Used by {@code AsyncCall#run} to signal completion. */
-  synchronized void finished(AsyncCall call) {
-    if (!runningCalls.remove(call)) throw new AssertionError("AsyncCall wasn't running!");
-    promoteCalls();
-  }
-
-  private void promoteCalls() {
-    if (runningCalls.size() >= maxRequests) return; // Already running max capacity.
-    if (readyCalls.isEmpty()) return; // No ready calls to promote.
-
-    for (Iterator<AsyncCall> i = readyCalls.iterator(); i.hasNext(); ) {
-      AsyncCall call = i.next();
-
-      if (runningCallsForHost(call) < maxRequestsPerHost) {
-        i.remove();
-        runningCalls.add(call);
-        getExecutorService().execute(call);
-      }
-
-      if (runningCalls.size() >= maxRequests) return; // Reached max capacity.
-    }
-  }
-
-  /** Returns the number of running calls that share a host with {@code call}. */
-  private int runningCallsForHost(AsyncCall call) {
-    int result = 0;
-    for (AsyncCall c : runningCalls) {
-      if (c.host().equals(call.host())) result++;
-    }
-    return result;
-  }
-
-  /** Used by {@code Call#execute} to signal it is in-flight. */
-  synchronized void executed(Call call) {
-    executedCalls.add(call);
-  }
-
-  /** Used by {@code Call#execute} to signal completion. */
-  synchronized void finished(Call call) {
-    if (!executedCalls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
-  }
-
-  public synchronized int getRunningCallCount() {
-    return runningCalls.size();
-  }
-
-  public synchronized int getQueuedCallCount() {
-    return readyCalls.size();
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
deleted file mode 100644
index 6f4b93c179..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import okio.Buffer;
-
-/**
- * Fluent API to build <a href="http://www.w3.org/MarkUp/html-spec/html-spec_8.html#SEC8.2.1">HTML
- * 2.0</a>-compliant form data.
- */
-public final class FormEncodingBuilder {
-  private static final MediaType CONTENT_TYPE =
-      MediaType.parse("application/x-www-form-urlencoded");
-
-  private final Buffer content = new Buffer();
-
-  /** Add new key-value pair. */
-  public FormEncodingBuilder add(String name, String value) {
-    if (content.size() > 0) {
-      content.writeByte('&');
-    }
-    HttpUrl.canonicalize(content, name, 0, name.length(),
-        HttpUrl.FORM_ENCODE_SET, false, true);
-    content.writeByte('=');
-    HttpUrl.canonicalize(content, value, 0, value.length(),
-        HttpUrl.FORM_ENCODE_SET, false, true);
-    return this;
-  }
-
-  /** Add new key-value pair. */
-  public FormEncodingBuilder addEncoded(String name, String value) {
-    if (content.size() > 0) {
-      content.writeByte('&');
-    }
-    HttpUrl.canonicalize(content, name, 0, name.length(),
-        HttpUrl.FORM_ENCODE_SET, true, true);
-    content.writeByte('=');
-    HttpUrl.canonicalize(content, value, 0, value.length(),
-        HttpUrl.FORM_ENCODE_SET, true, true);
-    return this;
-  }
-
-  public RequestBody build() {
-    return RequestBody.create(CONTENT_TYPE, content.snapshot());
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
deleted file mode 100644
index 5b160b6741..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
+++ /dev/null
@@ -1,300 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.UUID;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-
-/**
- * Fluent API to build <a href="http://www.ietf.org/rfc/rfc2387.txt">RFC
- * 2387</a>-compliant request bodies.
- */
-public final class MultipartBuilder {
-  /**
-   * The "mixed" subtype of "multipart" is intended for use when the body
-   * parts are independent and need to be bundled in a particular order. Any
-   * "multipart" subtypes that an implementation does not recognize must be
-   * treated as being of subtype "mixed".
-   */
-  public static final MediaType MIXED = MediaType.parse("multipart/mixed");
-
-  /**
-   * The "multipart/alternative" type is syntactically identical to
-   * "multipart/mixed", but the semantics are different. In particular, each
-   * of the body parts is an "alternative" version of the same information.
-   */
-  public static final MediaType ALTERNATIVE = MediaType.parse("multipart/alternative");
-
-  /**
-   * This type is syntactically identical to "multipart/mixed", but the
-   * semantics are different. In particular, in a digest, the default {@code
-   * Content-Type} value for a body part is changed from "text/plain" to
-   * "message/rfc822".
-   */
-  public static final MediaType DIGEST = MediaType.parse("multipart/digest");
-
-  /**
-   * This type is syntactically identical to "multipart/mixed", but the
-   * semantics are different. In particular, in a parallel entity, the order
-   * of body parts is not significant.
-   */
-  public static final MediaType PARALLEL = MediaType.parse("multipart/parallel");
-
-  /**
-   * The media-type multipart/form-data follows the rules of all multipart
-   * MIME data streams as outlined in RFC 2046. In forms, there are a series
-   * of fields to be supplied by the user who fills out the form. Each field
-   * has a name. Within a given form, the names are unique.
-   */
-  public static final MediaType FORM = MediaType.parse("multipart/form-data");
-
-  private static final byte[] COLONSPACE = { ':', ' ' };
-  private static final byte[] CRLF = { '\r', '\n' };
-  private static final byte[] DASHDASH = { '-', '-' };
-
-  private final ByteString boundary;
-  private MediaType type = MIXED;
-
-  // Parallel lists of nullable headers and non-null bodies.
-  private final List<Headers> partHeaders = new ArrayList<>();
-  private final List<RequestBody> partBodies = new ArrayList<>();
-
-  /** Creates a new multipart builder that uses a random boundary token. */
-  public MultipartBuilder() {
-    this(UUID.randomUUID().toString());
-  }
-
-  /**
-   * Creates a new multipart builder that uses {@code boundary} to separate
-   * parts. Prefer the no-argument constructor to defend against injection
-   * attacks.
-   */
-  public MultipartBuilder(String boundary) {
-    this.boundary = ByteString.encodeUtf8(boundary);
-  }
-
-  /**
-   * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the
-   * default), {@link #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and
-   * {@link #FORM}.
-   */
-  public MultipartBuilder type(MediaType type) {
-    if (type == null) {
-      throw new NullPointerException("type == null");
-    }
-    if (!type.type().equals("multipart")) {
-      throw new IllegalArgumentException("multipart != " + type);
-    }
-    this.type = type;
-    return this;
-  }
-
-  /** Add a part to the body. */
-  public MultipartBuilder addPart(RequestBody body) {
-    return addPart(null, body);
-  }
-
-  /** Add a part to the body. */
-  public MultipartBuilder addPart(Headers headers, RequestBody body) {
-    if (body == null) {
-      throw new NullPointerException("body == null");
-    }
-    if (headers != null && headers.get("Content-Type") != null) {
-      throw new IllegalArgumentException("Unexpected header: Content-Type");
-    }
-    if (headers != null && headers.get("Content-Length") != null) {
-      throw new IllegalArgumentException("Unexpected header: Content-Length");
-    }
-
-    partHeaders.add(headers);
-    partBodies.add(body);
-    return this;
-  }
-
-  /**
-   * Appends a quoted-string to a StringBuilder.
-   *
-   * <p>RFC 2388 is rather vague about how one should escape special characters
-   * in form-data parameters, and as it turns out Firefox and Chrome actually
-   * do rather different things, and both say in their comments that they're
-   * not really sure what the right approach is. We go with Chrome's behavior
-   * (which also experimentally seems to match what IE does), but if you
-   * actually want to have a good chance of things working, please avoid
-   * double-quotes, newlines, percent signs, and the like in your field names.
-   */
-  private static StringBuilder appendQuotedString(StringBuilder target, String key) {
-    target.append('"');
-    for (int i = 0, len = key.length(); i < len; i++) {
-      char ch = key.charAt(i);
-      switch (ch) {
-        case '\n':
-          target.append("%0A");
-          break;
-        case '\r':
-          target.append("%0D");
-          break;
-        case '"':
-          target.append("%22");
-          break;
-        default:
-          target.append(ch);
-          break;
-      }
-    }
-    target.append('"');
-    return target;
-  }
-
-  /** Add a form data part to the body. */
-  public MultipartBuilder addFormDataPart(String name, String value) {
-    return addFormDataPart(name, null, RequestBody.create(null, value));
-  }
-
-  /** Add a form data part to the body. */
-  public MultipartBuilder addFormDataPart(String name, String filename, RequestBody value) {
-    if (name == null) {
-      throw new NullPointerException("name == null");
-    }
-    StringBuilder disposition = new StringBuilder("form-data; name=");
-    appendQuotedString(disposition, name);
-
-    if (filename != null) {
-      disposition.append("; filename=");
-      appendQuotedString(disposition, filename);
-    }
-
-    return addPart(Headers.of("Content-Disposition", disposition.toString()), value);
-  }
-
-  /** Assemble the specified parts into a request body. */
-  public RequestBody build() {
-    if (partHeaders.isEmpty()) {
-      throw new IllegalStateException("Multipart body must have at least one part.");
-    }
-    return new MultipartRequestBody(type, boundary, partHeaders, partBodies);
-  }
-
-  private static final class MultipartRequestBody extends RequestBody {
-    private final ByteString boundary;
-    private final MediaType contentType;
-    private final List<Headers> partHeaders;
-    private final List<RequestBody> partBodies;
-    private long contentLength = -1L;
-
-    public MultipartRequestBody(MediaType type, ByteString boundary, List<Headers> partHeaders,
-        List<RequestBody> partBodies) {
-      if (type == null) throw new NullPointerException("type == null");
-
-      this.boundary = boundary;
-      this.contentType = MediaType.parse(type + "; boundary=" + boundary.utf8());
-      this.partHeaders = Util.immutableList(partHeaders);
-      this.partBodies = Util.immutableList(partBodies);
-    }
-
-    @Override public MediaType contentType() {
-      return contentType;
-    }
-
-    @Override public long contentLength() throws IOException {
-      long result = contentLength;
-      if (result != -1L) return result;
-      return contentLength = writeOrCountBytes(null, true);
-    }
-
-    /**
-     * Either writes this request to {@code sink} or measures its content length. We have one method
-     * do double-duty to make sure the counting and content are consistent, particularly when it
-     * comes to awkward operations like measuring the encoded length of header strings, or the
-     * length-in-digits of an encoded integer.
-     */
-    private long writeOrCountBytes(BufferedSink sink, boolean countBytes) throws IOException {
-      long byteCount = 0L;
-
-      Buffer byteCountBuffer = null;
-      if (countBytes) {
-        sink = byteCountBuffer = new Buffer();
-      }
-
-      for (int p = 0, partCount = partHeaders.size(); p < partCount; p++) {
-        Headers headers = partHeaders.get(p);
-        RequestBody body = partBodies.get(p);
-
-        sink.write(DASHDASH);
-        sink.write(boundary);
-        sink.write(CRLF);
-
-        if (headers != null) {
-          for (int h = 0, headerCount = headers.size(); h < headerCount; h++) {
-            sink.writeUtf8(headers.name(h))
-                .write(COLONSPACE)
-                .writeUtf8(headers.value(h))
-                .write(CRLF);
-          }
-        }
-
-        MediaType contentType = body.contentType();
-        if (contentType != null) {
-          sink.writeUtf8("Content-Type: ")
-              .writeUtf8(contentType.toString())
-              .write(CRLF);
-        }
-
-        long contentLength = body.contentLength();
-        if (contentLength != -1) {
-          sink.writeUtf8("Content-Length: ")
-              .writeDecimalLong(contentLength)
-              .write(CRLF);
-        } else if (countBytes) {
-          // We can't measure the body's size without the sizes of its components.
-          byteCountBuffer.clear();
-          return -1L;
-        }
-
-        sink.write(CRLF);
-
-        if (countBytes) {
-          byteCount += contentLength;
-        } else {
-          partBodies.get(p).writeTo(sink);
-        }
-
-        sink.write(CRLF);
-      }
-
-      sink.write(DASHDASH);
-      sink.write(boundary);
-      sink.write(DASHDASH);
-      sink.write(CRLF);
-
-      if (countBytes) {
-        byteCount += byteCountBuffer.size();
-        byteCountBuffer.clear();
-      }
-
-      return byteCount;
-    }
-
-    @Override public void writeTo(BufferedSink sink) throws IOException {
-      writeOrCountBytes(sink, false);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
deleted file mode 100644
index 1ef79b0f67..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ /dev/null
@@ -1,677 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.InternalCache;
-import com.squareup.okhttp.internal.Network;
-import com.squareup.okhttp.internal.RouteDatabase;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
-import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.RouteException;
-import com.squareup.okhttp.internal.http.Transport;
-import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
-import java.io.IOException;
-import java.net.CookieHandler;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.URLConnection;
-import java.security.GeneralSecurityException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import javax.net.SocketFactory;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import okio.BufferedSink;
-import okio.BufferedSource;
-
-/**
- * Configures and creates HTTP connections. Most applications can use a single
- * OkHttpClient for all of their HTTP requests - benefiting from a shared
- * response cache, thread pool, connection re-use, etc.
- *
- * <p>Instances of OkHttpClient are intended to be fully configured before they're
- * shared - once shared they should be treated as immutable and can safely be used
- * to concurrently open new connections. If required, threads can call
- * {@link #clone()} to make a shallow copy of the OkHttpClient that can be
- * safely modified with further configuration changes.
- */
-public class OkHttpClient implements Cloneable {
-  private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
-      Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
-
-  private static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
-      ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, ConnectionSpec.CLEARTEXT);
-
-  static {
-    Internal.instance = new Internal() {
-      @Override public Transport newTransport(
-          Connection connection, HttpEngine httpEngine) throws IOException {
-        return connection.newTransport(httpEngine);
-      }
-
-      @Override public boolean clearOwner(Connection connection) {
-        return connection.clearOwner();
-      }
-
-      @Override public void closeIfOwnedBy(Connection connection, Object owner) throws IOException {
-        connection.closeIfOwnedBy(owner);
-      }
-
-      @Override public int recycleCount(Connection connection) {
-        return connection.recycleCount();
-      }
-
-      @Override public void setProtocol(Connection connection, Protocol protocol) {
-        connection.setProtocol(protocol);
-      }
-
-      @Override public void setOwner(Connection connection, HttpEngine httpEngine) {
-        connection.setOwner(httpEngine);
-      }
-
-      @Override public boolean isReadable(Connection pooled) {
-        return pooled.isReadable();
-      }
-
-      @Override public void addLenient(Headers.Builder builder, String line) {
-        builder.addLenient(line);
-      }
-
-      @Override public void addLenient(Headers.Builder builder, String name, String value) {
-        builder.addLenient(name, value);
-      }
-
-      @Override public void setCache(OkHttpClient client, InternalCache internalCache) {
-        client.setInternalCache(internalCache);
-      }
-
-      @Override public InternalCache internalCache(OkHttpClient client) {
-        return client.internalCache();
-      }
-
-      @Override public void recycle(ConnectionPool pool, Connection connection) {
-        pool.recycle(connection);
-      }
-
-      @Override public RouteDatabase routeDatabase(OkHttpClient client) {
-        return client.routeDatabase();
-      }
-
-      @Override public Network network(OkHttpClient client) {
-        return client.network;
-      }
-
-      @Override public void setNetwork(OkHttpClient client, Network network) {
-        client.network = network;
-      }
-
-      @Override public void connectAndSetOwner(OkHttpClient client, Connection connection,
-          HttpEngine owner, Request request) throws RouteException {
-        connection.connectAndSetOwner(client, owner, request);
-      }
-
-      @Override
-      public void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket) {
-        call.enqueue(responseCallback, forWebSocket);
-      }
-
-      @Override public void callEngineReleaseConnection(Call call) throws IOException {
-        call.engine.releaseConnection();
-      }
-
-      @Override public Connection callEngineGetConnection(Call call) {
-        return call.engine.getConnection();
-      }
-
-      @Override public BufferedSource connectionRawSource(Connection connection) {
-        return connection.rawSource();
-      }
-
-      @Override public BufferedSink connectionRawSink(Connection connection) {
-        return connection.rawSink();
-      }
-
-      @Override public void connectionSetOwner(Connection connection, Object owner) {
-        connection.setOwner(owner);
-      }
-
-      @Override
-      public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
-        tlsConfiguration.apply(sslSocket, isFallback);
-      }
-    };
-  }
-
-  /** Lazily-initialized. */
-  private static SSLSocketFactory defaultSslSocketFactory;
-
-  private final RouteDatabase routeDatabase;
-  private Dispatcher dispatcher;
-  private Proxy proxy;
-  private List<Protocol> protocols;
-  private List<ConnectionSpec> connectionSpecs;
-  private final List<Interceptor> interceptors = new ArrayList<>();
-  private final List<Interceptor> networkInterceptors = new ArrayList<>();
-  private ProxySelector proxySelector;
-  private CookieHandler cookieHandler;
-
-  /** Non-null if this client is caching; possibly by {@code cache}. */
-  private InternalCache internalCache;
-  private Cache cache;
-
-  private SocketFactory socketFactory;
-  private SSLSocketFactory sslSocketFactory;
-  private HostnameVerifier hostnameVerifier;
-  private CertificatePinner certificatePinner;
-  private Authenticator authenticator;
-  private ConnectionPool connectionPool;
-  private Network network;
-  private boolean followSslRedirects = true;
-  private boolean followRedirects = true;
-  private boolean retryOnConnectionFailure = true;
-  private int connectTimeout = 10_000;
-  private int readTimeout = 10_000;
-  private int writeTimeout = 10_000;
-
-  public OkHttpClient() {
-    routeDatabase = new RouteDatabase();
-    dispatcher = new Dispatcher();
-  }
-
-  private OkHttpClient(OkHttpClient okHttpClient) {
-    this.routeDatabase = okHttpClient.routeDatabase;
-    this.dispatcher = okHttpClient.dispatcher;
-    this.proxy = okHttpClient.proxy;
-    this.protocols = okHttpClient.protocols;
-    this.connectionSpecs = okHttpClient.connectionSpecs;
-    this.interceptors.addAll(okHttpClient.interceptors);
-    this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
-    this.proxySelector = okHttpClient.proxySelector;
-    this.cookieHandler = okHttpClient.cookieHandler;
-    this.cache = okHttpClient.cache;
-    this.internalCache = cache != null ? cache.internalCache : okHttpClient.internalCache;
-    this.socketFactory = okHttpClient.socketFactory;
-    this.sslSocketFactory = okHttpClient.sslSocketFactory;
-    this.hostnameVerifier = okHttpClient.hostnameVerifier;
-    this.certificatePinner = okHttpClient.certificatePinner;
-    this.authenticator = okHttpClient.authenticator;
-    this.connectionPool = okHttpClient.connectionPool;
-    this.network = okHttpClient.network;
-    this.followSslRedirects = okHttpClient.followSslRedirects;
-    this.followRedirects = okHttpClient.followRedirects;
-    this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
-    this.connectTimeout = okHttpClient.connectTimeout;
-    this.readTimeout = okHttpClient.readTimeout;
-    this.writeTimeout = okHttpClient.writeTimeout;
-  }
-
-  /**
-   * Sets the default connect timeout for new connections. A value of 0 means no timeout, otherwise
-   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-   *
-   * @see URLConnection#setConnectTimeout(int)
-   */
-  public void setConnectTimeout(long timeout, TimeUnit unit) {
-    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-    if (unit == null) throw new IllegalArgumentException("unit == null");
-    long millis = unit.toMillis(timeout);
-    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-    connectTimeout = (int) millis;
-  }
-
-  /** Default connect timeout (in milliseconds). */
-  public int getConnectTimeout() {
-    return connectTimeout;
-  }
-
-  /**
-   * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-   *
-   * @see URLConnection#setReadTimeout(int)
-   */
-  public void setReadTimeout(long timeout, TimeUnit unit) {
-    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-    if (unit == null) throw new IllegalArgumentException("unit == null");
-    long millis = unit.toMillis(timeout);
-    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-    readTimeout = (int) millis;
-  }
-
-  /** Default read timeout (in milliseconds). */
-  public int getReadTimeout() {
-    return readTimeout;
-  }
-
-  /**
-   * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-   * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-   */
-  public void setWriteTimeout(long timeout, TimeUnit unit) {
-    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-    if (unit == null) throw new IllegalArgumentException("unit == null");
-    long millis = unit.toMillis(timeout);
-    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-    if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-    writeTimeout = (int) millis;
-  }
-
-  /** Default write timeout (in milliseconds). */
-  public int getWriteTimeout() {
-    return writeTimeout;
-  }
-
-  /**
-   * Sets the HTTP proxy that will be used by connections created by this
-   * client. This takes precedence over {@link #setProxySelector}, which is
-   * only honored when this proxy is null (which it is by default). To disable
-   * proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
-   */
-  public OkHttpClient setProxy(Proxy proxy) {
-    this.proxy = proxy;
-    return this;
-  }
-
-  public Proxy getProxy() {
-    return proxy;
-  }
-
-  /**
-   * Sets the proxy selection policy to be used if no {@link #setProxy proxy}
-   * is specified explicitly. The proxy selector may return multiple proxies;
-   * in that case they will be tried in sequence until a successful connection
-   * is established.
-   *
-   * <p>If unset, the {@link ProxySelector#getDefault() system-wide default}
-   * proxy selector will be used.
-   */
-  public OkHttpClient setProxySelector(ProxySelector proxySelector) {
-    this.proxySelector = proxySelector;
-    return this;
-  }
-
-  public ProxySelector getProxySelector() {
-    return proxySelector;
-  }
-
-  /**
-   * Sets the cookie handler to be used to read outgoing cookies and write
-   * incoming cookies.
-   *
-   * <p>If unset, the {@link CookieHandler#getDefault() system-wide default}
-   * cookie handler will be used.
-   */
-  public OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
-    this.cookieHandler = cookieHandler;
-    return this;
-  }
-
-  public CookieHandler getCookieHandler() {
-    return cookieHandler;
-  }
-
-  /** Sets the response cache to be used to read and write cached responses. */
-  void setInternalCache(InternalCache internalCache) {
-    this.internalCache = internalCache;
-    this.cache = null;
-  }
-
-  InternalCache internalCache() {
-    return internalCache;
-  }
-
-  public OkHttpClient setCache(Cache cache) {
-    this.cache = cache;
-    this.internalCache = null;
-    return this;
-  }
-
-  public Cache getCache() {
-    return cache;
-  }
-
-  /**
-   * Sets the socket factory used to create connections. OkHttp only uses
-   * the parameterless {@link SocketFactory#createSocket() createSocket()}
-   * method to create unconnected sockets. Overriding this method,
-   * e. g., allows the socket to be bound to a specific local address.
-   *
-   * <p>If unset, the {@link SocketFactory#getDefault() system-wide default}
-   * socket factory will be used.
-   */
-  public OkHttpClient setSocketFactory(SocketFactory socketFactory) {
-    this.socketFactory = socketFactory;
-    return this;
-  }
-
-  public SocketFactory getSocketFactory() {
-    return socketFactory;
-  }
-
-  /**
-   * Sets the socket factory used to secure HTTPS connections.
-   *
-   * <p>If unset, a lazily created SSL socket factory will be used.
-   */
-  public OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
-    this.sslSocketFactory = sslSocketFactory;
-    return this;
-  }
-
-  public SSLSocketFactory getSslSocketFactory() {
-    return sslSocketFactory;
-  }
-
-  /**
-   * Sets the verifier used to confirm that response certificates apply to
-   * requested hostnames for HTTPS connections.
-   *
-   * <p>If unset, a default hostname verifier will be used.
-   */
-  public OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
-    this.hostnameVerifier = hostnameVerifier;
-    return this;
-  }
-
-  public HostnameVerifier getHostnameVerifier() {
-    return hostnameVerifier;
-  }
-
-  /**
-   * Sets the certificate pinner that constrains which certificates are trusted.
-   * By default HTTPS connections rely on only the {@link #setSslSocketFactory
-   * SSL socket factory} to establish trust. Pinning certificates avoids the
-   * need to trust certificate authorities.
-   */
-  public OkHttpClient setCertificatePinner(CertificatePinner certificatePinner) {
-    this.certificatePinner = certificatePinner;
-    return this;
-  }
-
-  public CertificatePinner getCertificatePinner() {
-    return certificatePinner;
-  }
-
-  /**
-   * Sets the authenticator used to respond to challenges from the remote web
-   * server or proxy server.
-   *
-   * <p>If unset, the {@link java.net.Authenticator#setDefault system-wide default}
-   * authenticator will be used.
-   */
-  public OkHttpClient setAuthenticator(Authenticator authenticator) {
-    this.authenticator = authenticator;
-    return this;
-  }
-
-  public Authenticator getAuthenticator() {
-    return authenticator;
-  }
-
-  /**
-   * Sets the connection pool used to recycle HTTP and HTTPS connections.
-   *
-   * <p>If unset, the {@link ConnectionPool#getDefault() system-wide
-   * default} connection pool will be used.
-   */
-  public OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
-    this.connectionPool = connectionPool;
-    return this;
-  }
-
-  public ConnectionPool getConnectionPool() {
-    return connectionPool;
-  }
-
-  /**
-   * Configure this client to follow redirects from HTTPS to HTTP and from HTTP
-   * to HTTPS.
-   *
-   * <p>If unset, protocol redirects will be followed. This is different than
-   * the built-in {@code HttpURLConnection}'s default.
-   */
-  public OkHttpClient setFollowSslRedirects(boolean followProtocolRedirects) {
-    this.followSslRedirects = followProtocolRedirects;
-    return this;
-  }
-
-  public boolean getFollowSslRedirects() {
-    return followSslRedirects;
-  }
-
-  /** Configure this client to follow redirects. If unset, redirects be followed. */
-  public void setFollowRedirects(boolean followRedirects) {
-    this.followRedirects = followRedirects;
-  }
-
-  public boolean getFollowRedirects() {
-    return followRedirects;
-  }
-
-  /**
-   * Configure this client to retry or not when a connectivity problem is encountered. By default,
-   * this client silently recovers from the following problems:
-   *
-   * <ul>
-   *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
-   *       failure to reach any individual IP address doesn't fail the overall request. This can
-   *       increase availability of multi-homed services.
-   *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
-   *       to decrease request latency, but these connections will occasionally time out.
-   *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
-   *       attempt multiple proxy servers in sequence, eventually falling back to a direct
-   *       connection.
-   * </ul>
-   *
-   * Set this to false to avoid retrying requests when doing so is destructive. In this case the
-   * calling application should do its own recovery of connectivity failures.
-   */
-  public void setRetryOnConnectionFailure(boolean retryOnConnectionFailure) {
-    this.retryOnConnectionFailure = retryOnConnectionFailure;
-  }
-
-  public boolean getRetryOnConnectionFailure() {
-    return retryOnConnectionFailure;
-  }
-
-  RouteDatabase routeDatabase() {
-    return routeDatabase;
-  }
-
-  /**
-   * Sets the dispatcher used to set policy and execute asynchronous requests.
-   * Must not be null.
-   */
-  public OkHttpClient setDispatcher(Dispatcher dispatcher) {
-    if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
-    this.dispatcher = dispatcher;
-    return this;
-  }
-
-  public Dispatcher getDispatcher() {
-    return dispatcher;
-  }
-
-  /**
-   * Configure the protocols used by this client to communicate with remote
-   * servers. By default this client will prefer the most efficient transport
-   * available, falling back to more ubiquitous protocols. Applications should
-   * only call this method to avoid specific compatibility problems, such as web
-   * servers that behave incorrectly when SPDY is enabled.
-   *
-   * <p>The following protocols are currently supported:
-   * <ul>
-   *   <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-   *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
-   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
-   * </ul>
-   *
-   * <p><strong>This is an evolving set.</strong> Future releases include
-   * support for transitional protocols. The http/1.1 transport will never be
-   * dropped.
-   *
-   * <p>If multiple protocols are specified, <a
-   * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
-   * will be used to negotiate a transport.
-   *
-   * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are
-   * initiated with {@code HTTP/1.1} only. If the server responds with {@code
-   * HTTP/1.0}, that will be exposed by {@link Response#protocol()}.
-   *
-   * @param protocols the protocols to use, in order of preference. The list
-   *     must contain {@link Protocol#HTTP_1_1}. It must not contain null or
-   *     {@link Protocol#HTTP_1_0}.
-   */
-  public OkHttpClient setProtocols(List<Protocol> protocols) {
-    protocols = Util.immutableList(protocols);
-    if (!protocols.contains(Protocol.HTTP_1_1)) {
-      throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
-    }
-    if (protocols.contains(Protocol.HTTP_1_0)) {
-      throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
-    }
-    if (protocols.contains(null)) {
-      throw new IllegalArgumentException("protocols must not contain null");
-    }
-    this.protocols = Util.immutableList(protocols);
-    return this;
-  }
-
-  public List<Protocol> getProtocols() {
-    return protocols;
-  }
-
-  public OkHttpClient setConnectionSpecs(List<ConnectionSpec> connectionSpecs) {
-    this.connectionSpecs = Util.immutableList(connectionSpecs);
-    return this;
-  }
-
-  public List<ConnectionSpec> getConnectionSpecs() {
-    return connectionSpecs;
-  }
-
-  /**
-   * Returns a modifiable list of interceptors that observe the full span of each call: from before
-   * the connection is established (if any) until after the response source is selected (either the
-   * origin server, cache, or both).
-   */
-  public List<Interceptor> interceptors() {
-    return interceptors;
-  }
-
-  /**
-   * Returns a modifiable list of interceptors that observe a single network request and response.
-   * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
-   * a network interceptor to short-circuit or repeat a network request.
-   */
-  public List<Interceptor> networkInterceptors() {
-    return networkInterceptors;
-  }
-
-  /**
-   * Prepares the {@code request} to be executed at some point in the future.
-   */
-  public Call newCall(Request request) {
-    return new Call(this, request);
-  }
-
-  /**
-   * Cancels all scheduled or in-flight calls tagged with {@code tag}. Requests
-   * that are already complete cannot be canceled.
-   */
-  public OkHttpClient cancel(Object tag) {
-    getDispatcher().cancel(tag);
-    return this;
-  }
-
-  /**
-   * Returns a shallow copy of this OkHttpClient that uses the system-wide
-   * default for each field that hasn't been explicitly configured.
-   */
-  OkHttpClient copyWithDefaults() {
-    OkHttpClient result = new OkHttpClient(this);
-    if (result.proxySelector == null) {
-      result.proxySelector = ProxySelector.getDefault();
-    }
-    if (result.cookieHandler == null) {
-      result.cookieHandler = CookieHandler.getDefault();
-    }
-    if (result.socketFactory == null) {
-      result.socketFactory = SocketFactory.getDefault();
-    }
-    if (result.sslSocketFactory == null) {
-      result.sslSocketFactory = getDefaultSSLSocketFactory();
-    }
-    if (result.hostnameVerifier == null) {
-      result.hostnameVerifier = OkHostnameVerifier.INSTANCE;
-    }
-    if (result.certificatePinner == null) {
-      result.certificatePinner = CertificatePinner.DEFAULT;
-    }
-    if (result.authenticator == null) {
-      result.authenticator = AuthenticatorAdapter.INSTANCE;
-    }
-    if (result.connectionPool == null) {
-      result.connectionPool = ConnectionPool.getDefault();
-    }
-    if (result.protocols == null) {
-      result.protocols = DEFAULT_PROTOCOLS;
-    }
-    if (result.connectionSpecs == null) {
-      result.connectionSpecs = DEFAULT_CONNECTION_SPECS;
-    }
-    if (result.network == null) {
-      result.network = Network.DEFAULT;
-    }
-    return result;
-  }
-
-  /**
-   * Java and Android programs default to using a single global SSL context,
-   * accessible to HTTP clients as {@link SSLSocketFactory#getDefault()}. If we
-   * used the shared SSL context, when OkHttp enables ALPN for its SPDY-related
-   * stuff, it would also enable ALPN for other usages, which might crash them
-   * because ALPN is enabled when it isn't expected to be.
-   *
-   * <p>This code avoids that by defaulting to an OkHttp-created SSL context.
-   * The drawback of this approach is that apps that customize the global SSL
-   * context will lose these customizations.
-   */
-  private synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
-    if (defaultSslSocketFactory == null) {
-      try {
-        SSLContext sslContext = SSLContext.getInstance("TLS");
-        sslContext.init(null, null, null);
-        defaultSslSocketFactory = sslContext.getSocketFactory();
-      } catch (GeneralSecurityException e) {
-        throw new AssertionError(); // The system has no TLS. Just give up.
-      }
-    }
-    return defaultSslSocketFactory;
-  }
-
-  /** Returns a shallow copy of this OkHttpClient. */
-  @Override public OkHttpClient clone() {
-    return new OkHttpClient(this);
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
deleted file mode 100644
index 1e583ba1b3..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import com.squareup.okhttp.Call;
-import com.squareup.okhttp.Callback;
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.ConnectionSpec;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.RouteException;
-import com.squareup.okhttp.internal.http.Transport;
-import java.io.IOException;
-import java.util.logging.Logger;
-import javax.net.ssl.SSLSocket;
-import okio.BufferedSink;
-import okio.BufferedSource;
-
-/**
- * Escalate internal APIs in {@code com.squareup.okhttp} so they can be used
- * from OkHttp's implementation packages. The only implementation of this
- * interface is in {@link com.squareup.okhttp.OkHttpClient}.
- */
-public abstract class Internal {
-  public static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
-
-  public static void initializeInstanceForTests() {
-    // Needed in tests to ensure that the instance is actually pointing to something.
-    new OkHttpClient();
-  }
-
-  public static Internal instance;
-
-  public abstract Transport newTransport(Connection connection, HttpEngine httpEngine)
-      throws IOException;
-
-  public abstract boolean clearOwner(Connection connection);
-
-  public abstract void closeIfOwnedBy(Connection connection, Object owner) throws IOException;
-
-  public abstract int recycleCount(Connection connection);
-
-  public abstract void setProtocol(Connection connection, Protocol protocol);
-
-  public abstract void setOwner(Connection connection, HttpEngine httpEngine);
-
-  public abstract boolean isReadable(Connection pooled);
-
-  public abstract void addLenient(Headers.Builder builder, String line);
-
-  public abstract void addLenient(Headers.Builder builder, String name, String value);
-
-  public abstract void setCache(OkHttpClient client, InternalCache internalCache);
-
-  public abstract InternalCache internalCache(OkHttpClient client);
-
-  public abstract void recycle(ConnectionPool pool, Connection connection);
-
-  public abstract RouteDatabase routeDatabase(OkHttpClient client);
-
-  public abstract Network network(OkHttpClient client);
-
-  public abstract void setNetwork(OkHttpClient client, Network network);
-
-  public abstract void connectAndSetOwner(OkHttpClient client, Connection connection,
-      HttpEngine owner, Request request) throws RouteException;
-
-  public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
-      boolean isFallback);
-
-  // TODO delete the following when web sockets move into the main package.
-  public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
-  public abstract void callEngineReleaseConnection(Call call) throws IOException;
-  public abstract Connection callEngineGetConnection(Call call);
-  public abstract BufferedSource connectionRawSource(Connection connection);
-  public abstract BufferedSink connectionRawSink(Connection connection);
-  public abstract void connectionSetOwner(Connection connection, Object owner);
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Network.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Network.java
deleted file mode 100644
index a0070651b2..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Network.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-
-/**
- * Services specific to the host device's network interface. Prefer this over {@link
- * InetAddress#getAllByName} to make code more testable.
- */
-public interface Network {
-  Network DEFAULT = new Network() {
-    @Override public InetAddress[] resolveInetAddresses(String host) throws UnknownHostException {
-      if (host == null) throw new UnknownHostException("host == null");
-      return InetAddress.getAllByName(host);
-    }
-  };
-
-  InetAddress[] resolveInetAddresses(String host) throws UnknownHostException;
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
deleted file mode 100644
index b9064959e0..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ /dev/null
@@ -1,371 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import com.squareup.okhttp.Protocol;
-import java.io.IOException;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.net.SocketException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.logging.Level;
-import javax.net.ssl.SSLSocket;
-import okio.Buffer;
-
-import static com.squareup.okhttp.internal.Internal.logger;
-
-/**
- * Access to platform-specific features.
- *
- * <h3>Server name indication (SNI)</h3>
- * Supported on Android 2.3+.
- *
- * <h3>Session Tickets</h3>
- * Supported on Android 2.3+.
- *
- * <h3>Android Traffic Stats (Socket Tagging)</h3>
- * Supported on Android 4.0+.
- *
- * <h3>ALPN (Application Layer Protocol Negotiation)</h3>
- * Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
- * unstable.
- *
- * Supported on OpenJDK 7 and 8 (via the JettyALPN-boot library).
- */
-public class Platform {
-  private static final Platform PLATFORM = findPlatform();
-
-  public static Platform get() {
-    return PLATFORM;
-  }
-
-  /** Prefix used on custom headers. */
-  public String getPrefix() {
-    return "OkHttp";
-  }
-
-  public void logW(String warning) {
-    System.out.println(warning);
-  }
-
-  public void tagSocket(Socket socket) throws SocketException {
-  }
-
-  public void untagSocket(Socket socket) throws SocketException {
-  }
-
-  /**
-   * Configure TLS extensions on {@code sslSocket} for {@code route}.
-   *
-   * @param hostname non-null for client-side handshakes; null for
-   *     server-side handshakes.
-   */
-  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
-      List<Protocol> protocols) {
-  }
-
-  /**
-   * Called after the TLS handshake to release resources allocated by {@link
-   * #configureTlsExtensions}.
-   */
-  public void afterHandshake(SSLSocket sslSocket) {
-  }
-
-  /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  public String getSelectedProtocol(SSLSocket socket) {
-    return null;
-  }
-
-  public void connectSocket(Socket socket, InetSocketAddress address,
-      int connectTimeout) throws IOException {
-    socket.connect(address, connectTimeout);
-  }
-
-  /** Attempt to match the host runtime to a capable Platform implementation. */
-  private static Platform findPlatform() {
-    // Attempt to find Android 2.3+ APIs.
-    try {
-      try {
-        Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl");
-      } catch (ClassNotFoundException e) {
-        // Older platform before being unbundled.
-        Class.forName("org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl");
-      }
-
-      OptionalMethod<Socket> setUseSessionTickets
-          = new OptionalMethod<>(null, "setUseSessionTickets", boolean.class);
-      OptionalMethod<Socket> setHostname
-          = new OptionalMethod<>(null, "setHostname", String.class);
-      Method trafficStatsTagSocket = null;
-      Method trafficStatsUntagSocket = null;
-      OptionalMethod<Socket> getAlpnSelectedProtocol = null;
-      OptionalMethod<Socket> setAlpnProtocols = null;
-
-      // Attempt to find Android 4.0+ APIs.
-      try {
-        Class<?> trafficStats = Class.forName("android.net.TrafficStats");
-        trafficStatsTagSocket = trafficStats.getMethod("tagSocket", Socket.class);
-        trafficStatsUntagSocket = trafficStats.getMethod("untagSocket", Socket.class);
-
-        // Attempt to find Android 5.0+ APIs.
-        try {
-          Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
-          getAlpnSelectedProtocol = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
-          setAlpnProtocols = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
-        } catch (ClassNotFoundException ignored) {
-        }
-      } catch (ClassNotFoundException | NoSuchMethodException ignored) {
-      }
-
-      return new Android(setUseSessionTickets, setHostname, trafficStatsTagSocket,
-          trafficStatsUntagSocket, getAlpnSelectedProtocol, setAlpnProtocols);
-    } catch (ClassNotFoundException ignored) {
-      // This isn't an Android runtime.
-    }
-
-    // Find Jetty's ALPN extension for OpenJDK.
-    try {
-      String negoClassName = "org.eclipse.jetty.alpn.ALPN";
-      Class<?> negoClass = Class.forName(negoClassName);
-      Class<?> providerClass = Class.forName(negoClassName + "$Provider");
-      Class<?> clientProviderClass = Class.forName(negoClassName + "$ClientProvider");
-      Class<?> serverProviderClass = Class.forName(negoClassName + "$ServerProvider");
-      Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
-      Method getMethod = negoClass.getMethod("get", SSLSocket.class);
-      Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
-      return new JdkWithJettyBootPlatform(
-          putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
-    } catch (ClassNotFoundException | NoSuchMethodException ignored) {
-    }
-
-    return new Platform();
-  }
-
-  /** Android 2.3 or better. */
-  private static class Android extends Platform {
-    private final OptionalMethod<Socket> setUseSessionTickets;
-    private final OptionalMethod<Socket> setHostname;
-
-    // Non-null on Android 4.0+.
-    private final Method trafficStatsTagSocket;
-    private final Method trafficStatsUntagSocket;
-
-    // Non-null on Android 5.0+.
-    private final OptionalMethod<Socket> getAlpnSelectedProtocol;
-    private final OptionalMethod<Socket> setAlpnProtocols;
-
-    public Android(OptionalMethod<Socket> setUseSessionTickets, OptionalMethod<Socket> setHostname,
-        Method trafficStatsTagSocket, Method trafficStatsUntagSocket,
-        OptionalMethod<Socket> getAlpnSelectedProtocol, OptionalMethod<Socket> setAlpnProtocols) {
-      this.setUseSessionTickets = setUseSessionTickets;
-      this.setHostname = setHostname;
-      this.trafficStatsTagSocket = trafficStatsTagSocket;
-      this.trafficStatsUntagSocket = trafficStatsUntagSocket;
-      this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
-      this.setAlpnProtocols = setAlpnProtocols;
-    }
-
-    @Override public void connectSocket(Socket socket, InetSocketAddress address,
-        int connectTimeout) throws IOException {
-      try {
-        socket.connect(address, connectTimeout);
-      } catch (SecurityException se) {
-        // Before android 4.3, socket.connect could throw a SecurityException
-        // if opening a socket resulted in an EACCES error.
-        IOException ioException = new IOException("Exception in connect");
-        ioException.initCause(se);
-        throw ioException;
-      }
-    }
-
-    @Override public void configureTlsExtensions(
-        SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-      // Enable SNI and session tickets.
-      if (hostname != null) {
-        setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, true);
-        setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);
-      }
-
-      // Enable ALPN.
-      if (setAlpnProtocols != null && setAlpnProtocols.isSupported(sslSocket)) {
-        Object[] parameters = { concatLengthPrefixed(protocols) };
-        setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
-      }
-    }
-
-    @Override public String getSelectedProtocol(SSLSocket socket) {
-      if (getAlpnSelectedProtocol == null) return null;
-      if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
-
-      byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);
-      return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
-    }
-
-    @Override public void tagSocket(Socket socket) throws SocketException {
-      if (trafficStatsTagSocket == null) return;
-
-      try {
-        trafficStatsTagSocket.invoke(null, socket);
-      } catch (IllegalAccessException e) {
-        throw new RuntimeException(e);
-      } catch (InvocationTargetException e) {
-        throw new RuntimeException(e.getCause());
-      }
-    }
-
-    @Override public void untagSocket(Socket socket) throws SocketException {
-      if (trafficStatsUntagSocket == null) return;
-
-      try {
-        trafficStatsUntagSocket.invoke(null, socket);
-      } catch (IllegalAccessException e) {
-        throw new RuntimeException(e);
-      } catch (InvocationTargetException e) {
-        throw new RuntimeException(e.getCause());
-      }
-    }
-  }
-
-  /**
-   * OpenJDK 7+ with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
-   */
-  private static class JdkWithJettyBootPlatform extends Platform {
-    private final Method putMethod;
-    private final Method getMethod;
-    private final Method removeMethod;
-    private final Class<?> clientProviderClass;
-    private final Class<?> serverProviderClass;
-
-    public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
-        Class<?> clientProviderClass, Class<?> serverProviderClass) {
-      this.putMethod = putMethod;
-      this.getMethod = getMethod;
-      this.removeMethod = removeMethod;
-      this.clientProviderClass = clientProviderClass;
-      this.serverProviderClass = serverProviderClass;
-    }
-
-    @Override public void configureTlsExtensions(
-        SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-      List<String> names = new ArrayList<>(protocols.size());
-      for (int i = 0, size = protocols.size(); i < size; i++) {
-        Protocol protocol = protocols.get(i);
-        if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
-        names.add(protocol.toString());
-      }
-      try {
-        Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
-            new Class[] { clientProviderClass, serverProviderClass }, new JettyNegoProvider(names));
-        putMethod.invoke(null, sslSocket, provider);
-      } catch (InvocationTargetException | IllegalAccessException e) {
-        throw new AssertionError(e);
-      }
-    }
-
-    @Override public void afterHandshake(SSLSocket sslSocket) {
-      try {
-        removeMethod.invoke(null, sslSocket);
-      } catch (IllegalAccessException | InvocationTargetException ignored) {
-        throw new AssertionError();
-      }
-    }
-
-    @Override public String getSelectedProtocol(SSLSocket socket) {
-      try {
-        JettyNegoProvider provider =
-            (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
-        if (!provider.unsupported && provider.selected == null) {
-          logger.log(Level.INFO, "ALPN callback dropped: SPDY and HTTP/2 are disabled. "
-              + "Is alpn-boot on the boot class path?");
-          return null;
-        }
-        return provider.unsupported ? null : provider.selected;
-      } catch (InvocationTargetException | IllegalAccessException e) {
-        throw new AssertionError();
-      }
-    }
-  }
-
-  /**
-   * Handle the methods of ALPN's ClientProvider and ServerProvider
-   * without a compile-time dependency on those interfaces.
-   */
-  private static class JettyNegoProvider implements InvocationHandler {
-    /** This peer's supported protocols. */
-    private final List<String> protocols;
-    /** Set when remote peer notifies ALPN is unsupported. */
-    private boolean unsupported;
-    /** The protocol the server selected. */
-    private String selected;
-
-    public JettyNegoProvider(List<String> protocols) {
-      this.protocols = protocols;
-    }
-
-    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-      String methodName = method.getName();
-      Class<?> returnType = method.getReturnType();
-      if (args == null) {
-        args = Util.EMPTY_STRING_ARRAY;
-      }
-      if (methodName.equals("supports") && boolean.class == returnType) {
-        return true; // ALPN is supported.
-      } else if (methodName.equals("unsupported") && void.class == returnType) {
-        this.unsupported = true; // Peer doesn't support ALPN.
-        return null;
-      } else if (methodName.equals("protocols") && args.length == 0) {
-        return protocols; // Client advertises these protocols.
-      } else if ((methodName.equals("selectProtocol") || methodName.equals("select"))
-          && String.class == returnType && args.length == 1 && args[0] instanceof List) {
-        List<String> peerProtocols = (List) args[0];
-        // Pick the first known protocol the peer advertises.
-        for (int i = 0, size = peerProtocols.size(); i < size; i++) {
-          if (protocols.contains(peerProtocols.get(i))) {
-            return selected = peerProtocols.get(i);
-          }
-        }
-        return selected = protocols.get(0); // On no intersection, try peer's first protocol.
-      } else if ((methodName.equals("protocolSelected") || methodName.equals("selected"))
-          && args.length == 1) {
-        this.selected = (String) args[0]; // Server selected this protocol.
-        return null;
-      } else {
-        return method.invoke(this, args);
-      }
-    }
-  }
-
-  /**
-   * Returns the concatenation of 8-bit, length prefixed protocol names.
-   * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
-   */
-  static byte[] concatLengthPrefixed(List<Protocol> protocols) {
-    Buffer result = new Buffer();
-    for (int i = 0, size = protocols.size(); i < size; i++) {
-      Protocol protocol = protocols.get(i);
-      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
-      result.writeByte(protocol.toString().length());
-      result.writeUtf8(protocol.toString());
-    }
-    return result.readByteArray();
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/IncomingStreamHandler.java b/okhttp/src/main/java/com/squareup/okhttp/internal/framed/IncomingStreamHandler.java
deleted file mode 100644
index 57863df113..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/IncomingStreamHandler.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.framed;
-
-import java.io.IOException;
-
-/** Listener to be notified when a connected peer creates a new stream. */
-public interface IncomingStreamHandler {
-  IncomingStreamHandler REFUSE_INCOMING_STREAMS = new IncomingStreamHandler() {
-    @Override public void receive(FramedStream stream) throws IOException {
-      stream.close(ErrorCode.REFUSED_STREAM);
-    }
-  };
-
-  /**
-   * Handle a new stream from this connection's peer. Implementations should
-   * respond by either {@link FramedStream#reply replying to the stream} or
-   * {@link FramedStream#close closing it}. This response does not need to be
-   * synchronous.
-   */
-  void receive(FramedStream stream) throws IOException;
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
deleted file mode 100644
index 8d884105d0..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Authenticator;
-import com.squareup.okhttp.Challenge;
-import com.squareup.okhttp.Credentials;
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import java.io.IOException;
-import java.net.Authenticator.RequestorType;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.PasswordAuthentication;
-import java.net.Proxy;
-import java.util.List;
-
-/** Adapts {@link java.net.Authenticator} to {@link com.squareup.okhttp.Authenticator}. */
-public final class AuthenticatorAdapter implements Authenticator {
-  /** Uses the global authenticator to get the password. */
-  public static final Authenticator INSTANCE = new AuthenticatorAdapter();
-
-  @Override public Request authenticate(Proxy proxy, Response response) throws IOException {
-    List<Challenge> challenges = response.challenges();
-    Request request = response.request();
-    HttpUrl url = request.httpUrl();
-    for (int i = 0, size = challenges.size(); i < size; i++) {
-      Challenge challenge = challenges.get(i);
-      if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
-
-      PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
-          url.host(), getConnectToInetAddress(proxy, url), url.port(), url.scheme(),
-          challenge.getRealm(), challenge.getScheme(), url.url(), RequestorType.SERVER);
-      if (auth == null) continue;
-
-      String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
-      return request.newBuilder()
-          .header("Authorization", credential)
-          .build();
-    }
-    return null;
-
-  }
-
-  @Override public Request authenticateProxy(Proxy proxy, Response response) throws IOException {
-    List<Challenge> challenges = response.challenges();
-    Request request = response.request();
-    HttpUrl url = request.httpUrl();
-    for (int i = 0, size = challenges.size(); i < size; i++) {
-      Challenge challenge = challenges.get(i);
-      if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
-
-      InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
-      PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
-          proxyAddress.getHostName(), getConnectToInetAddress(proxy, url), proxyAddress.getPort(),
-          url.scheme(), challenge.getRealm(), challenge.getScheme(), url.url(),
-          RequestorType.PROXY);
-      if (auth == null) continue;
-
-      String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
-      return request.newBuilder()
-          .header("Proxy-Authorization", credential)
-          .build();
-    }
-    return null;
-  }
-
-  private InetAddress getConnectToInetAddress(Proxy proxy, HttpUrl url) throws IOException {
-    return (proxy != null && proxy.type() != Proxy.Type.DIRECT)
-        ? ((InetSocketAddress) proxy.address()).getAddress()
-        : InetAddress.getByName(url.host());
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/FramedTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/FramedTransport.java
deleted file mode 100644
index abeaf869e8..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/FramedTransport.java
+++ /dev/null
@@ -1,232 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.framed.ErrorCode;
-import com.squareup.okhttp.internal.framed.FramedConnection;
-import com.squareup.okhttp.internal.framed.FramedStream;
-import com.squareup.okhttp.internal.framed.Header;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.ArrayList;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import okio.ByteString;
-import okio.Okio;
-import okio.Sink;
-
-import static com.squareup.okhttp.internal.framed.Header.RESPONSE_STATUS;
-import static com.squareup.okhttp.internal.framed.Header.TARGET_AUTHORITY;
-import static com.squareup.okhttp.internal.framed.Header.TARGET_HOST;
-import static com.squareup.okhttp.internal.framed.Header.TARGET_METHOD;
-import static com.squareup.okhttp.internal.framed.Header.TARGET_PATH;
-import static com.squareup.okhttp.internal.framed.Header.TARGET_SCHEME;
-import static com.squareup.okhttp.internal.framed.Header.VERSION;
-
-public final class FramedTransport implements Transport {
-  /** See http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1#TOC-3.2.1-Request. */
-  private static final List<ByteString> SPDY_3_PROHIBITED_HEADERS = Util.immutableList(
-      ByteString.encodeUtf8("connection"),
-      ByteString.encodeUtf8("host"),
-      ByteString.encodeUtf8("keep-alive"),
-      ByteString.encodeUtf8("proxy-connection"),
-      ByteString.encodeUtf8("transfer-encoding"));
-
-  /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
-  private static final List<ByteString> HTTP_2_PROHIBITED_HEADERS = Util.immutableList(
-      ByteString.encodeUtf8("connection"),
-      ByteString.encodeUtf8("host"),
-      ByteString.encodeUtf8("keep-alive"),
-      ByteString.encodeUtf8("proxy-connection"),
-      ByteString.encodeUtf8("te"),
-      ByteString.encodeUtf8("transfer-encoding"),
-      ByteString.encodeUtf8("encoding"),
-      ByteString.encodeUtf8("upgrade"));
-
-  private final HttpEngine httpEngine;
-  private final FramedConnection framedConnection;
-  private FramedStream stream;
-
-  public FramedTransport(HttpEngine httpEngine, FramedConnection framedConnection) {
-    this.httpEngine = httpEngine;
-    this.framedConnection = framedConnection;
-  }
-
-  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
-    return stream.getSink();
-  }
-
-  @Override public void writeRequestHeaders(Request request) throws IOException {
-    if (stream != null) return;
-
-    httpEngine.writingRequestHeaders();
-    boolean permitsRequestBody = httpEngine.permitsRequestBody();
-    boolean hasResponseBody = true;
-    String version = RequestLine.version(httpEngine.getConnection().getProtocol());
-    stream = framedConnection.newStream(
-        writeNameValueBlock(request, framedConnection.getProtocol(), version), permitsRequestBody,
-        hasResponseBody);
-    stream.readTimeout().timeout(httpEngine.client.getReadTimeout(), TimeUnit.MILLISECONDS);
-  }
-
-  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
-    requestBody.writeToSocket(stream.getSink());
-  }
-
-  @Override public void finishRequest() throws IOException {
-    stream.getSink().close();
-  }
-
-  @Override public Response.Builder readResponseHeaders() throws IOException {
-    return readNameValueBlock(stream.getResponseHeaders(), framedConnection.getProtocol());
-  }
-
-  /**
-   * Returns a list of alternating names and values containing a SPDY request.
-   * Names are all lowercase. No names are repeated. If any name has multiple
-   * values, they are concatenated using "\0" as a delimiter.
-   */
-  public static List<Header> writeNameValueBlock(Request request, Protocol protocol,
-      String version) {
-    Headers headers = request.headers();
-    List<Header> result = new ArrayList<>(headers.size() + 10);
-    result.add(new Header(TARGET_METHOD, request.method()));
-    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.httpUrl())));
-    String host = Util.hostHeader(request.httpUrl());
-    if (Protocol.SPDY_3 == protocol) {
-      result.add(new Header(VERSION, version));
-      result.add(new Header(TARGET_HOST, host));
-    } else if (Protocol.HTTP_2 == protocol) {
-      result.add(new Header(TARGET_AUTHORITY, host)); // Optional in HTTP/2
-    } else {
-      throw new AssertionError();
-    }
-    result.add(new Header(TARGET_SCHEME, request.httpUrl().scheme()));
-
-    Set<ByteString> names = new LinkedHashSet<ByteString>();
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      // header names must be lowercase.
-      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
-      String value = headers.value(i);
-
-      // Drop headers that are forbidden when layering HTTP over SPDY.
-      if (isProhibitedHeader(protocol, name)) continue;
-
-      // They shouldn't be set, but if they are, drop them. We've already written them!
-      if (name.equals(TARGET_METHOD)
-          || name.equals(TARGET_PATH)
-          || name.equals(TARGET_SCHEME)
-          || name.equals(TARGET_AUTHORITY)
-          || name.equals(TARGET_HOST)
-          || name.equals(VERSION)) {
-        continue;
-      }
-
-      // If we haven't seen this name before, add the pair to the end of the list...
-      if (names.add(name)) {
-        result.add(new Header(name, value));
-        continue;
-      }
-
-      // ...otherwise concatenate the existing values and this value.
-      for (int j = 0; j < result.size(); j++) {
-        if (result.get(j).name.equals(name)) {
-          String concatenated = joinOnNull(result.get(j).value.utf8(), value);
-          result.set(j, new Header(name, concatenated));
-          break;
-        }
-      }
-    }
-    return result;
-  }
-
-  private static String joinOnNull(String first, String second) {
-    return new StringBuilder(first).append('\0').append(second).toString();
-  }
-
-  /** Returns headers for a name value block containing a SPDY response. */
-  public static Response.Builder readNameValueBlock(List<Header> headerBlock,
-      Protocol protocol) throws IOException {
-    String status = null;
-    String version = "HTTP/1.1"; // :version present only in spdy/3.
-
-    Headers.Builder headersBuilder = new Headers.Builder();
-    headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.toString());
-    for (int i = 0, size = headerBlock.size(); i < size; i++) {
-      ByteString name = headerBlock.get(i).name;
-      String values = headerBlock.get(i).value.utf8();
-      for (int start = 0; start < values.length(); ) {
-        int end = values.indexOf('\0', start);
-        if (end == -1) {
-          end = values.length();
-        }
-        String value = values.substring(start, end);
-        if (name.equals(RESPONSE_STATUS)) {
-          status = value;
-        } else if (name.equals(VERSION)) {
-          version = value;
-        } else if (!isProhibitedHeader(protocol, name)) { // Don't write forbidden headers!
-          headersBuilder.add(name.utf8(), value);
-        }
-        start = end + 1;
-      }
-    }
-    if (status == null) throw new ProtocolException("Expected ':status' header not present");
-
-    StatusLine statusLine = StatusLine.parse(version + " " + status);
-    return new Response.Builder()
-        .protocol(protocol)
-        .code(statusLine.code)
-        .message(statusLine.message)
-        .headers(headersBuilder.build());
-  }
-
-  @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    return new RealResponseBody(response.headers(), Okio.buffer(stream.getSource()));
-  }
-
-  @Override public void releaseConnectionOnIdle() {
-  }
-
-  @Override public void disconnect(HttpEngine engine) throws IOException {
-    if (stream != null) stream.close(ErrorCode.CANCEL);
-  }
-
-  @Override public boolean canReuseConnection() {
-    return true; // TODO: framedConnection.isClosed() ?
-  }
-
-  /** When true, this header should not be emitted or consumed. */
-  private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
-    if (protocol == Protocol.SPDY_3) {
-      return SPDY_3_PROHIBITED_HEADERS.contains(name);
-    } else if (protocol == Protocol.HTTP_2) {
-      return HTTP_2_PROHIBITED_HEADERS.contains(name);
-    } else {
-      throw new AssertionError(protocol);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
deleted file mode 100644
index d02e1e56d1..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-
-public final class HttpTransport implements Transport {
-  private final HttpEngine httpEngine;
-  private final HttpConnection httpConnection;
-
-  public HttpTransport(HttpEngine httpEngine, HttpConnection httpConnection) {
-    this.httpEngine = httpEngine;
-    this.httpConnection = httpConnection;
-  }
-
-  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
-    if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
-      // Stream a request body of unknown length.
-      return httpConnection.newChunkedSink();
-    }
-
-    if (contentLength != -1) {
-      // Stream a request body of a known length.
-      return httpConnection.newFixedLengthSink(contentLength);
-    }
-
-    throw new IllegalStateException(
-        "Cannot stream a request body without chunked encoding or a known content length!");
-  }
-
-  @Override public void finishRequest() throws IOException {
-    httpConnection.flush();
-  }
-
-  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
-    httpConnection.writeRequestBody(requestBody);
-  }
-
-  /**
-   * Prepares the HTTP headers and sends them to the server.
-   *
-   * <p>For streaming requests with a body, headers must be prepared
-   * <strong>before</strong> the output stream has been written to. Otherwise
-   * the body would need to be buffered!
-   *
-   * <p>For non-streaming requests with a body, headers must be prepared
-   * <strong>after</strong> the output stream has been written to and closed.
-   * This ensures that the {@code Content-Length} header field receives the
-   * proper value.
-   */
-  public void writeRequestHeaders(Request request) throws IOException {
-    httpEngine.writingRequestHeaders();
-    String requestLine = RequestLine.get(request,
-        httpEngine.getConnection().getRoute().getProxy().type(),
-        httpEngine.getConnection().getProtocol());
-    httpConnection.writeRequest(request.headers(), requestLine);
-  }
-
-  @Override public Response.Builder readResponseHeaders() throws IOException {
-    return httpConnection.readResponse();
-  }
-
-  @Override public void releaseConnectionOnIdle() throws IOException {
-    if (canReuseConnection()) {
-      httpConnection.poolOnIdle();
-    } else {
-      httpConnection.closeOnIdle();
-    }
-  }
-
-  @Override public boolean canReuseConnection() {
-    // If the request specified that the connection shouldn't be reused, don't reuse it.
-    if ("close".equalsIgnoreCase(httpEngine.getRequest().header("Connection"))) {
-      return false;
-    }
-
-    // If the response specified that the connection shouldn't be reused, don't reuse it.
-    if ("close".equalsIgnoreCase(httpEngine.getResponse().header("Connection"))) {
-      return false;
-    }
-
-    if (httpConnection.isClosed()) {
-      return false;
-    }
-
-    return true;
-  }
-
-  @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    Source source = getTransferStream(response);
-    return new RealResponseBody(response.headers(), Okio.buffer(source));
-  }
-
-  private Source getTransferStream(Response response) throws IOException {
-    if (!HttpEngine.hasBody(response)) {
-      return httpConnection.newFixedLengthSource(0);
-    }
-
-    if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      return httpConnection.newChunkedSource(httpEngine);
-    }
-
-    long contentLength = OkHeaders.contentLength(response);
-    if (contentLength != -1) {
-      return httpConnection.newFixedLengthSource(contentLength);
-    }
-
-    // Wrap the input stream from the connection (rather than just returning
-    // "socketIn" directly here), so that we can control its use after the
-    // reference escapes.
-    return httpConnection.newUnknownLengthSource();
-  }
-
-  @Override public void disconnect(HttpEngine engine) throws IOException {
-    httpConnection.closeIfOwnedBy(engine);
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
deleted file mode 100644
index d22be27011..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import java.net.HttpURLConnection;
-import java.net.Proxy;
-
-public final class RequestLine {
-  private RequestLine() {
-  }
-
-  /**
-   * Returns the request status line, like "GET / HTTP/1.1". This is exposed
-   * to the application by {@link HttpURLConnection#getHeaderFields}, so it
-   * needs to be set even if the transport is SPDY.
-   */
-  static String get(Request request, Proxy.Type proxyType, Protocol protocol) {
-    StringBuilder result = new StringBuilder();
-    result.append(request.method());
-    result.append(' ');
-
-    if (includeAuthorityInRequestLine(request, proxyType)) {
-      result.append(request.httpUrl());
-    } else {
-      result.append(requestPath(request.httpUrl()));
-    }
-
-    result.append(' ');
-    result.append(version(protocol));
-    return result.toString();
-  }
-
-  /**
-   * Returns true if the request line should contain the full URL with host
-   * and port (like "GET http://android.com/foo HTTP/1.1") or only the path
-   * (like "GET /foo HTTP/1.1").
-   */
-  private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type proxyType) {
-    return !request.isHttps() && proxyType == Proxy.Type.HTTP;
-  }
-
-  /**
-   * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty,
-   * even if the request URL is. Includes the query component if it exists.
-   */
-  public static String requestPath(HttpUrl url) {
-    String path = url.encodedPath();
-    String query = url.encodedQuery();
-    return query != null ? (path + '?' + query) : path;
-  }
-
-  public static String version(Protocol protocol) {
-    return protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1";
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Address.java b/okhttp/src/main/java/okhttp3/Address.java
similarity index 51%
rename from okhttp/src/main/java/com/squareup/okhttp/Address.java
rename to okhttp/src/main/java/okhttp3/Address.java
index 6f6ce08d5f..4fd97764a3 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Address.java
+++ b/okhttp/src/main/java/okhttp3/Address.java
@@ -13,168 +13,171 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.Util;
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.util.List;
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.internal.Util;
 
-import static com.squareup.okhttp.internal.Util.equal;
+import static okhttp3.internal.Util.equal;
 
 /**
- * A specification for a connection to an origin server. For simple connections,
- * this is the server's hostname and port. If an explicit proxy is requested (or
- * {@linkplain Proxy#NO_PROXY no proxy} is explicitly requested), this also includes
- * that proxy information. For secure connections the address also includes the
- * SSL socket factory and hostname verifier.
+ * A specification for a connection to an origin server. For simple connections, this is the
+ * server's hostname and port. If an explicit proxy is requested (or {@linkplain Proxy#NO_PROXY no
+ * proxy} is explicitly requested), this also includes that proxy information. For secure
+ * connections the address also includes the SSL socket factory, hostname verifier, and certificate
+ * pinner.
  *
- * <p>HTTP requests that share the same {@code Address} may also share the same
- * {@link Connection}.
+ * <p>HTTP requests that share the same {@code Address} may also share the same {@link Connection}.
  */
 public final class Address {
-  final Proxy proxy;
-  final String uriHost;
-  final int uriPort;
+  final HttpUrl url;
+  final Dns dns;
   final SocketFactory socketFactory;
-  final SSLSocketFactory sslSocketFactory;
-  final HostnameVerifier hostnameVerifier;
-  final CertificatePinner certificatePinner;
-  final Authenticator authenticator;
+  final Authenticator proxyAuthenticator;
   final List<Protocol> protocols;
   final List<ConnectionSpec> connectionSpecs;
   final ProxySelector proxySelector;
+  final Proxy proxy;
+  final SSLSocketFactory sslSocketFactory;
+  final HostnameVerifier hostnameVerifier;
+  final CertificatePinner certificatePinner;
 
-  public Address(String uriHost, int uriPort, SocketFactory socketFactory,
+  public Address(String uriHost, int uriPort, Dns dns, SocketFactory socketFactory,
       SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier,
-      CertificatePinner certificatePinner, Authenticator authenticator, Proxy proxy,
+      CertificatePinner certificatePinner, Authenticator proxyAuthenticator, Proxy proxy,
       List<Protocol> protocols, List<ConnectionSpec> connectionSpecs, ProxySelector proxySelector) {
-    if (uriHost == null) throw new NullPointerException("uriHost == null");
-    if (uriPort <= 0) throw new IllegalArgumentException("uriPort <= 0: " + uriPort);
-    if (authenticator == null) throw new IllegalArgumentException("authenticator == null");
-    if (protocols == null) throw new IllegalArgumentException("protocols == null");
-    if (proxySelector == null) throw new IllegalArgumentException("proxySelector == null");
-    this.proxy = proxy;
-    this.uriHost = uriHost;
-    this.uriPort = uriPort;
+    this.url = new HttpUrl.Builder()
+        .scheme(sslSocketFactory != null ? "https" : "http")
+        .host(uriHost)
+        .port(uriPort)
+        .build();
+
+    if (dns == null) throw new NullPointerException("dns == null");
+    this.dns = dns;
+
+    if (socketFactory == null) throw new NullPointerException("socketFactory == null");
     this.socketFactory = socketFactory;
-    this.sslSocketFactory = sslSocketFactory;
-    this.hostnameVerifier = hostnameVerifier;
-    this.certificatePinner = certificatePinner;
-    this.authenticator = authenticator;
+
+    if (proxyAuthenticator == null) {
+      throw new NullPointerException("proxyAuthenticator == null");
+    }
+    this.proxyAuthenticator = proxyAuthenticator;
+
+    if (protocols == null) throw new NullPointerException("protocols == null");
     this.protocols = Util.immutableList(protocols);
+
+    if (connectionSpecs == null) throw new NullPointerException("connectionSpecs == null");
     this.connectionSpecs = Util.immutableList(connectionSpecs);
+
+    if (proxySelector == null) throw new NullPointerException("proxySelector == null");
     this.proxySelector = proxySelector;
-  }
 
-  /** Returns the hostname of the origin server. */
-  public String getUriHost() {
-    return uriHost;
+    this.proxy = proxy;
+    this.sslSocketFactory = sslSocketFactory;
+    this.hostnameVerifier = hostnameVerifier;
+    this.certificatePinner = certificatePinner;
   }
 
   /**
-   * Returns the port of the origin server; typically 80 or 443. Unlike
-   * may {@code getPort()} accessors, this method never returns -1.
+   * Returns a URL with the hostname and port of the origin server. The path, query, and fragment of
+   * this URL are always empty, since they are not significant for planning a route.
    */
-  public int getUriPort() {
-    return uriPort;
+  public HttpUrl url() {
+    return url;
   }
 
-  /** Returns the socket factory for new connections. */
-  public SocketFactory getSocketFactory() {
-    return socketFactory;
-  }
-
-  /**
-   * Returns the SSL socket factory, or null if this is not an HTTPS
-   * address.
-   */
-  public SSLSocketFactory getSslSocketFactory() {
-    return sslSocketFactory;
+  /** Returns the service that will be used to resolve IP addresses for hostnames. */
+  public Dns dns() {
+    return dns;
   }
 
-  /**
-   * Returns the hostname verifier, or null if this is not an HTTPS
-   * address.
-   */
-  public HostnameVerifier getHostnameVerifier() {
-    return hostnameVerifier;
+  /** Returns the socket factory for new connections. */
+  public SocketFactory socketFactory() {
+    return socketFactory;
   }
 
-  /**
-   * Returns the client's authenticator. This method never returns null.
-   */
-  public Authenticator getAuthenticator() {
-    return authenticator;
+  /** Returns the client's proxy authenticator. */
+  public Authenticator proxyAuthenticator() {
+    return proxyAuthenticator;
   }
 
   /**
-   * Returns the protocols the client supports. This method always returns a
-   * non-null list that contains minimally {@link Protocol#HTTP_1_1}.
+   * Returns the protocols the client supports. This method always returns a non-null list that
+   * contains minimally {@link Protocol#HTTP_1_1}.
    */
-  public List<Protocol> getProtocols() {
+  public List<Protocol> protocols() {
     return protocols;
   }
 
-  public List<ConnectionSpec> getConnectionSpecs() {
+  public List<ConnectionSpec> connectionSpecs() {
     return connectionSpecs;
   }
 
-  /**
-   * Returns this address's explicitly-specified HTTP proxy, or null to
-   * delegate to the {@linkplain #getProxySelector proxy selector}.
-   */
-  public Proxy getProxy() {
-    return proxy;
-  }
-
   /**
    * Returns this address's proxy selector. Only used if the proxy is null. If none of this
    * selector's proxies are reachable, a direct connection will be attempted.
    */
-  public ProxySelector getProxySelector() {
+  public ProxySelector proxySelector() {
     return proxySelector;
   }
 
   /**
-   * Returns this address's certificate pinner. Only used for secure connections.
+   * Returns this address's explicitly-specified HTTP proxy, or null to delegate to the {@linkplain
+   * #proxySelector proxy selector}.
    */
-  public CertificatePinner getCertificatePinner() {
+  public Proxy proxy() {
+    return proxy;
+  }
+
+  /** Returns the SSL socket factory, or null if this is not an HTTPS address. */
+  public SSLSocketFactory sslSocketFactory() {
+    return sslSocketFactory;
+  }
+
+  /** Returns the hostname verifier, or null if this is not an HTTPS address. */
+  public HostnameVerifier hostnameVerifier() {
+    return hostnameVerifier;
+  }
+
+  /** Returns this address's certificate pinner, or null if this is not an HTTPS address. */
+  public CertificatePinner certificatePinner() {
     return certificatePinner;
   }
 
   @Override public boolean equals(Object other) {
     if (other instanceof Address) {
       Address that = (Address) other;
-      return equal(this.proxy, that.proxy)
-          && this.uriHost.equals(that.uriHost)
-          && this.uriPort == that.uriPort
+      return this.url.equals(that.url)
+          && this.dns.equals(that.dns)
+          && this.proxyAuthenticator.equals(that.proxyAuthenticator)
+          && this.protocols.equals(that.protocols)
+          && this.connectionSpecs.equals(that.connectionSpecs)
+          && this.proxySelector.equals(that.proxySelector)
+          && equal(this.proxy, that.proxy)
           && equal(this.sslSocketFactory, that.sslSocketFactory)
           && equal(this.hostnameVerifier, that.hostnameVerifier)
-          && equal(this.certificatePinner, that.certificatePinner)
-          && equal(this.authenticator, that.authenticator)
-          && equal(this.protocols, that.protocols)
-          && equal(this.connectionSpecs, that.connectionSpecs)
-          && equal(this.proxySelector, that.proxySelector);
+          && equal(this.certificatePinner, that.certificatePinner);
     }
     return false;
   }
 
   @Override public int hashCode() {
     int result = 17;
+    result = 31 * result + url.hashCode();
+    result = 31 * result + dns.hashCode();
+    result = 31 * result + proxyAuthenticator.hashCode();
+    result = 31 * result + protocols.hashCode();
+    result = 31 * result + connectionSpecs.hashCode();
+    result = 31 * result + proxySelector.hashCode();
     result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
-    result = 31 * result + uriHost.hashCode();
-    result = 31 * result + uriPort;
     result = 31 * result + (sslSocketFactory != null ? sslSocketFactory.hashCode() : 0);
     result = 31 * result + (hostnameVerifier != null ? hostnameVerifier.hashCode() : 0);
     result = 31 * result + (certificatePinner != null ? certificatePinner.hashCode() : 0);
-    result = 31 * result + authenticator.hashCode();
-    result = 31 * result + protocols.hashCode();
-    result = 31 * result + connectionSpecs.hashCode();
-    result = 31 * result + proxySelector.hashCode();
     return result;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
new file mode 100644
index 0000000000..ede539805f
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Authenticator.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+
+/**
+ * Responds to an authentication challenge from either a remote web server or a proxy server.
+ * Implementations may either attempt to satisfy the challenge by returning a request that includes
+ * an authorization header, or they may refuse the challenge by returning null. In this case the
+ * unauthenticated response will be returned to the caller that triggered it.
+ *
+ * <p>When authentication is requested by an origin server, the response code is 401 and the
+ * implementation should respond with a new request that sets the "Authorization" header.
+ * <pre>   {@code
+ *
+ *    String credential = Credentials.basic(...)
+ *    return response.request().newBuilder()
+ *        .header("Authorization", credential)
+ *        .build();
+ * }</pre>
+ *
+ * <p>Whn authentication is requested by a proxy server, the response code is 407 and the
+ * implementation should respond with a new request that sets the "Proxy-Authorization" header.
+ * <pre>   {@code
+ *
+ *    String credential = Credentials.basic(...)
+ *    return response.request().newBuilder()
+ *        .header("Proxy-Authorization", credential)
+ *        .build();
+ * }</pre>
+ *
+ * <p>Applications may configure OkHttp with an authenticator for origin servers, or proxy servers,
+ * or both.
+ */
+public interface Authenticator {
+  /** An authenticator that knows no credentials and makes no attempt to authenticate. */
+  Authenticator NONE = new Authenticator() {
+    @Override public Request authenticate(Route route, Response response) {
+      return null;
+    }
+  };
+
+  /**
+   * Returns a request that includes a credential to satisfy an authentication challenge in {@code
+   * response}. Returns null if the challenge cannot be satisfied.
+   */
+  Request authenticate(Route route, Response response) throws IOException;
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
similarity index 76%
rename from okhttp/src/main/java/com/squareup/okhttp/Cache.java
rename to okhttp/src/main/java/okhttp3/Cache.java
index 5461e40ead..7473edef75 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -13,19 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package okhttp3;
 
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.DiskLruCache;
-import com.squareup.okhttp.internal.InternalCache;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.CacheRequest;
-import com.squareup.okhttp.internal.http.CacheStrategy;
-import com.squareup.okhttp.internal.http.HttpMethod;
-import com.squareup.okhttp.internal.http.OkHeaders;
-import com.squareup.okhttp.internal.http.StatusLine;
-import com.squareup.okhttp.internal.io.FileSystem;
+import java.io.Closeable;
 import java.io.File;
+import java.io.Flushable;
 import java.io.IOException;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateEncodingException;
@@ -36,6 +28,15 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
+import okhttp3.internal.DiskLruCache;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.CacheRequest;
+import okhttp3.internal.http.CacheStrategy;
+import okhttp3.internal.http.HttpMethod;
+import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.http.StatusLine;
+import okhttp3.internal.io.FileSystem;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -51,14 +52,15 @@
  * bandwidth.
  *
  * <h3>Cache Optimization</h3>
- * To measure cache effectiveness, this class tracks three statistics:
+ *
+ * <p>To measure cache effectiveness, this class tracks three statistics:
  * <ul>
- *   <li><strong>{@linkplain #getRequestCount() Request Count:}</strong> the number of HTTP
- *     requests issued since this cache was created.
- *   <li><strong>{@linkplain #getNetworkCount() Network Count:}</strong> the number of those
- *     requests that required network use.
- *   <li><strong>{@linkplain #getHitCount() Hit Count:}</strong> the number of those requests whose
- *     responses were served by the cache.
+ *     <li><strong>{@linkplain #requestCount() Request Count:}</strong> the number of HTTP
+ *         requests issued since this cache was created.
+ *     <li><strong>{@linkplain #networkCount() Network Count:}</strong> the number of those
+ *         requests that required network use.
+ *     <li><strong>{@linkplain #hitCount() Hit Count:}</strong> the number of those requests
+ *         whose responses were served by the cache.
  * </ul>
  *
  * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
@@ -72,8 +74,9 @@
  * partial responses.
  *
  * <h3>Force a Network Response</h3>
- * In some situations, such as after a user clicks a 'refresh' button, it may be necessary to skip
- * the cache, and fetch data directly from the server. To force a full refresh, add the {@code
+ *
+ * <p>In some situations, such as after a user clicks a 'refresh' button, it may be necessary to
+ * skip the cache, and fetch data directly from the server. To force a full refresh, add the {@code
  * no-cache} directive: <pre>   {@code
  *
  *   Request request = new Request.Builder()
@@ -94,7 +97,8 @@
  * }</pre>
  *
  * <h3>Force a Cache Response</h3>
- * Sometimes you'll want to show resources if they are available immediately, but not otherwise.
+ *
+ * <p>Sometimes you'll want to show resources if they are available immediately, but not otherwise.
  * This can be used so your application can show <i>something</i> while waiting for the latest data
  * to be downloaded. To restrict a request to locally-cached resources, add the {@code
  * only-if-cached} directive: <pre>   {@code
@@ -128,7 +132,7 @@
  * caching directives. It even offers convenient constants {@link CacheControl#FORCE_NETWORK} and
  * {@link CacheControl#FORCE_CACHE} that address the use cases above.
  */
-public final class Cache {
+public final class Cache implements Closeable, Flushable {
   private static final int VERSION = 201105;
   private static final int ENTRY_METADATA = 0;
   private static final int ENTRY_BODY = 1;
@@ -138,18 +142,23 @@
     @Override public Response get(Request request) throws IOException {
       return Cache.this.get(request);
     }
+
     @Override public CacheRequest put(Response response) throws IOException {
       return Cache.this.put(response);
     }
+
     @Override public void remove(Request request) throws IOException {
       Cache.this.remove(request);
     }
+
     @Override public void update(Response cached, Response network) throws IOException {
       Cache.this.update(cached, network);
     }
+
     @Override public void trackConditionalCacheHit() {
       Cache.this.trackConditionalCacheHit();
     }
+
     @Override public void trackResponse(CacheStrategy cacheStrategy) {
       Cache.this.trackResponse(cacheStrategy);
     }
@@ -173,7 +182,7 @@ public Cache(File directory, long maxSize) {
   }
 
   private static String urlToKey(Request request) {
-    return Util.md5Hex(request.urlString());
+    return Util.md5Hex(request.url().toString());
   }
 
   Response get(Request request) {
@@ -197,7 +206,7 @@ Response get(Request request) {
       return null;
     }
 
-    Response response = entry.response(request, snapshot);
+    Response response = entry.response(snapshot);
 
     if (!entry.matches(request, response)) {
       Util.closeQuietly(response.body());
@@ -274,34 +283,31 @@ private void abortQuietly(DiskLruCache.Editor editor) {
   }
 
   /**
-   * Initialize the cache. This will include reading the journal files from
-   * the storage and building up the necessary in-memory cache information.
-   * <p>
-   * The initialization time may vary depending on the journal file size and
-   * the current actual cache size. The application needs to be aware of calling
-   * this function during the initialization phase and preferrably in a background
-   * worker thread.
-   * <p>
-   * Note that if the application chooses to not call this method to initialize
-   * the cache. By default, the okhttp will perform lazy initialization upon the
-   * first usage of the cache.
+   * Initialize the cache. This will include reading the journal files from the storage and building
+   * up the necessary in-memory cache information.
+   *
+   * <p>The initialization time may vary depending on the journal file size and the current actual
+   * cache size. The application needs to be aware of calling this function during the
+   * initialization phase and preferably in a background worker thread.
+   *
+   * <p>Note that if the application chooses to not call this method to initialize the cache. By
+   * default, the okhttp will perform lazy initialization upon the first usage of the cache.
    */
   public void initialize() throws IOException {
     cache.initialize();
   }
 
   /**
-   * Closes the cache and deletes all of its stored values. This will delete
-   * all files in the cache directory including files that weren't created by
-   * the cache.
+   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
+   * directory including files that weren't created by the cache.
    */
   public void delete() throws IOException {
     cache.delete();
   }
 
   /**
-   * Deletes all values stored in the cache. In-flight writes to the cache will
-   * complete normally, but the corresponding responses will not be stored.
+   * Deletes all values stored in the cache. In-flight writes to the cache will complete normally,
+   * but the corresponding responses will not be stored.
    */
   public void evictAll() throws IOException {
     cache.evictAll();
@@ -359,31 +365,31 @@ public void evictAll() throws IOException {
     };
   }
 
-  public synchronized int getWriteAbortCount() {
+  public synchronized int writeAbortCount() {
     return writeAbortCount;
   }
 
-  public synchronized int getWriteSuccessCount() {
+  public synchronized int writeSuccessCount() {
     return writeSuccessCount;
   }
 
-  public long getSize() throws IOException {
+  public long size() throws IOException {
     return cache.size();
   }
 
-  public long getMaxSize() {
+  public long maxSize() {
     return cache.getMaxSize();
   }
 
-  public void flush() throws IOException {
+  @Override public void flush() throws IOException {
     cache.flush();
   }
 
-  public void close() throws IOException {
+  @Override public void close() throws IOException {
     cache.close();
   }
 
-  public File getDirectory() {
+  public File directory() {
     return cache.getDirectory();
   }
 
@@ -397,7 +403,6 @@ private synchronized void trackResponse(CacheStrategy cacheStrategy) {
     if (cacheStrategy.networkRequest != null) {
       // If this is a conditional request, we'll increment hitCount if/when it hits.
       networkCount++;
-
     } else if (cacheStrategy.cacheResponse != null) {
       // This response uses the cache and not the network. That's a cache hit.
       hitCount++;
@@ -408,15 +413,15 @@ private synchronized void trackConditionalCacheHit() {
     hitCount++;
   }
 
-  public synchronized int getNetworkCount() {
+  public synchronized int networkCount() {
     return networkCount;
   }
 
-  public synchronized int getHitCount() {
+  public synchronized int hitCount() {
     return hitCount;
   }
 
-  public synchronized int getRequestCount() {
+  public synchronized int requestCount() {
     return requestCount;
   }
 
@@ -473,6 +478,8 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
     private final String message;
     private final Headers responseHeaders;
     private final Handshake handshake;
+    private final long sentRequestMillis;
+    private final long receivedResponseMillis;
 
     /**
      * Reads an entry from an input stream. A typical entry looks like this:
@@ -507,21 +514,20 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
      *   base64-encoded peerCertificate[0]
      *   base64-encoded peerCertificate[1]
      *   -1
+     *   TLSv1.2
      * }</pre>
-     * The file is newline separated. The first two lines are the URL and
-     * the request method. Next is the number of HTTP Vary request header
-     * lines, followed by those lines.
+     * The file is newline separated. The first two lines are the URL and the request method. Next
+     * is the number of HTTP Vary request header lines, followed by those lines.
      *
-     * <p>Next is the response status line, followed by the number of HTTP
-     * response header lines, followed by those lines.
+     * <p>Next is the response status line, followed by the number of HTTP response header lines,
+     * followed by those lines.
      *
-     * <p>HTTPS responses also contain SSL session information. This begins
-     * with a blank line, and then a line containing the cipher suite. Next
-     * is the length of the peer certificate chain. These certificates are
-     * base64-encoded and appear each on their own line. The next line
-     * contains the length of the local certificate chain. These
-     * certificates are also base64-encoded and appear each on their own
-     * line. A length of -1 is used to encode a null array.
+     * <p>HTTPS responses also contain SSL session information. This begins with a blank line, and
+     * then a line containing the cipher suite. Next is the length of the peer certificate chain.
+     * These certificates are base64-encoded and appear each on their own line. The next line
+     * contains the length of the local certificate chain. These certificates are also
+     * base64-encoded and appear each on their own line. A length of -1 is used to encode a null
+     * array. The last line is optional. If present, it contains the TLS version.
      */
     public Entry(Source in) throws IOException {
       try {
@@ -544,6 +550,16 @@ public Entry(Source in) throws IOException {
         for (int i = 0; i < responseHeaderLineCount; i++) {
           responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
         }
+        String sendRequestMillisString = responseHeadersBuilder.get(OkHeaders.SENT_MILLIS);
+        String receivedResponseMillisString = responseHeadersBuilder.get(OkHeaders.RECEIVED_MILLIS);
+        responseHeadersBuilder.removeAll(OkHeaders.SENT_MILLIS);
+        responseHeadersBuilder.removeAll(OkHeaders.RECEIVED_MILLIS);
+        sentRequestMillis = sendRequestMillisString != null
+            ? Long.parseLong(sendRequestMillisString)
+            : 0L;
+        receivedResponseMillis = receivedResponseMillisString != null
+            ? Long.parseLong(receivedResponseMillisString)
+            : 0L;
         responseHeaders = responseHeadersBuilder.build();
 
         if (isHttps()) {
@@ -551,10 +567,14 @@ public Entry(Source in) throws IOException {
           if (blank.length() > 0) {
             throw new IOException("expected \"\" but was \"" + blank + "\"");
           }
-          String cipherSuite = source.readUtf8LineStrict();
+          String cipherSuiteString = source.readUtf8LineStrict();
+          CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
           List<Certificate> peerCertificates = readCertificateList(source);
           List<Certificate> localCertificates = readCertificateList(source);
-          handshake = Handshake.get(cipherSuite, peerCertificates, localCertificates);
+          TlsVersion tlsVersion = !source.exhausted()
+              ? TlsVersion.forJavaName(source.readUtf8LineStrict())
+              : null;
+          handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);
         } else {
           handshake = null;
         }
@@ -564,7 +584,7 @@ public Entry(Source in) throws IOException {
     }
 
     public Entry(Response response) {
-      this.url = response.request().urlString();
+      this.url = response.request().url().toString();
       this.varyHeaders = OkHeaders.varyHeaders(response);
       this.requestMethod = response.request().method();
       this.protocol = response.protocol();
@@ -572,41 +592,56 @@ public Entry(Response response) {
       this.message = response.message();
       this.responseHeaders = response.headers();
       this.handshake = response.handshake();
+      this.sentRequestMillis = response.sentRequestAtMillis();
+      this.receivedResponseMillis = response.receivedResponseAtMillis();
     }
 
     public void writeTo(DiskLruCache.Editor editor) throws IOException {
       BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
 
-      sink.writeUtf8(url);
-      sink.writeByte('\n');
-      sink.writeUtf8(requestMethod);
-      sink.writeByte('\n');
-      sink.writeDecimalLong(varyHeaders.size());
-      sink.writeByte('\n');
+      sink.writeUtf8(url)
+          .writeByte('\n');
+      sink.writeUtf8(requestMethod)
+          .writeByte('\n');
+      sink.writeDecimalLong(varyHeaders.size())
+          .writeByte('\n');
       for (int i = 0, size = varyHeaders.size(); i < size; i++) {
-        sink.writeUtf8(varyHeaders.name(i));
-        sink.writeUtf8(": ");
-        sink.writeUtf8(varyHeaders.value(i));
-        sink.writeByte('\n');
+        sink.writeUtf8(varyHeaders.name(i))
+            .writeUtf8(": ")
+            .writeUtf8(varyHeaders.value(i))
+            .writeByte('\n');
       }
 
-      sink.writeUtf8(new StatusLine(protocol, code, message).toString());
-      sink.writeByte('\n');
-      sink.writeDecimalLong(responseHeaders.size());
-      sink.writeByte('\n');
+      sink.writeUtf8(new StatusLine(protocol, code, message).toString())
+          .writeByte('\n');
+      sink.writeDecimalLong(responseHeaders.size() + 2)
+          .writeByte('\n');
       for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-        sink.writeUtf8(responseHeaders.name(i));
-        sink.writeUtf8(": ");
-        sink.writeUtf8(responseHeaders.value(i));
-        sink.writeByte('\n');
+        sink.writeUtf8(responseHeaders.name(i))
+            .writeUtf8(": ")
+            .writeUtf8(responseHeaders.value(i))
+            .writeByte('\n');
       }
+      sink.writeUtf8(OkHeaders.SENT_MILLIS)
+          .writeUtf8(": ")
+          .writeDecimalLong(sentRequestMillis)
+          .writeByte('\n');
+      sink.writeUtf8(OkHeaders.RECEIVED_MILLIS)
+          .writeUtf8(": ")
+          .writeDecimalLong(receivedResponseMillis)
+          .writeByte('\n');
 
       if (isHttps()) {
         sink.writeByte('\n');
-        sink.writeUtf8(handshake.cipherSuite());
-        sink.writeByte('\n');
+        sink.writeUtf8(handshake.cipherSuite().javaName())
+            .writeByte('\n');
         writeCertList(sink, handshake.peerCertificates());
         writeCertList(sink, handshake.localCertificates());
+        // The handshake’s TLS version is null on HttpsURLConnection and on older cached responses.
+        if (handshake.tlsVersion() != null) {
+          sink.writeUtf8(handshake.tlsVersion().javaName())
+              .writeByte('\n');
+        }
       }
       sink.close();
     }
@@ -637,13 +672,13 @@ private boolean isHttps() {
     private void writeCertList(BufferedSink sink, List<Certificate> certificates)
         throws IOException {
       try {
-        sink.writeDecimalLong(certificates.size());
-        sink.writeByte('\n');
+        sink.writeDecimalLong(certificates.size())
+            .writeByte('\n');
         for (int i = 0, size = certificates.size(); i < size; i++) {
           byte[] bytes = certificates.get(i).getEncoded();
           String line = ByteString.of(bytes).base64();
-          sink.writeUtf8(line);
-          sink.writeByte('\n');
+          sink.writeUtf8(line)
+              .writeByte('\n');
         }
       } catch (CertificateEncodingException e) {
         throw new IOException(e.getMessage());
@@ -651,12 +686,12 @@ private void writeCertList(BufferedSink sink, List<Certificate> certificates)
     }
 
     public boolean matches(Request request, Response response) {
-      return url.equals(request.urlString())
+      return url.equals(request.url().toString())
           && requestMethod.equals(request.method())
           && OkHeaders.varyMatches(response, varyHeaders, request);
     }
 
-    public Response response(Request request, DiskLruCache.Snapshot snapshot) {
+    public Response response(DiskLruCache.Snapshot snapshot) {
       String contentType = responseHeaders.get("Content-Type");
       String contentLength = responseHeaders.get("Content-Length");
       Request cacheRequest = new Request.Builder()
@@ -672,6 +707,8 @@ public Response response(Request request, DiskLruCache.Snapshot snapshot) {
           .headers(responseHeaders)
           .body(new CacheResponseBody(snapshot, contentType, contentLength))
           .handshake(handshake)
+          .sentRequestAtMillis(sentRequestMillis)
+          .receivedResponseAtMillis(receivedResponseMillis)
           .build();
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java b/okhttp/src/main/java/okhttp3/CacheControl.java
similarity index 83%
rename from okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
rename to okhttp/src/main/java/okhttp3/CacheControl.java
index 2ee8982b0c..d8eb446149 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
+++ b/okhttp/src/main/java/okhttp3/CacheControl.java
@@ -1,29 +1,26 @@
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.http.HeaderParser;
 import java.util.concurrent.TimeUnit;
+import okhttp3.internal.http.HeaderParser;
 
 /**
- * A Cache-Control header with cache directives from a server or client. These
- * directives set policy on what responses can be stored, and which requests can
- * be satisfied by those stored responses.
+ * A Cache-Control header with cache directives from a server or client. These directives set policy
+ * on what responses can be stored, and which requests can be satisfied by those stored responses.
  *
- * <p>See <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">RFC
- * 2616, 14.9</a>.
+ * <p>See <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">RFC 2616,
+ * 14.9</a>.
  */
 public final class CacheControl {
   /**
-   * Cache control request directives that require network validation of
-   * responses. Note that such requests may be assisted by the cache via
-   * conditional GET requests.
+   * Cache control request directives that require network validation of responses. Note that such
+   * requests may be assisted by the cache via conditional GET requests.
    */
   public static final CacheControl FORCE_NETWORK = new Builder().noCache().build();
 
   /**
-   * Cache control request directives that uses the cache only, even if the
-   * cached response is stale. If the response isn't available in the cache or
-   * requires server validation, the call will fail with a {@code 504
-   * Unsatisfiable Request}.
+   * Cache control request directives that uses the cache only, even if the cached response is
+   * stale. If the response isn't available in the cache or requires server validation, the call
+   * will fail with a {@code 504 Unsatisfiable Request}.
    */
   public static final CacheControl FORCE_CACHE = new Builder()
       .onlyIfCached()
@@ -42,7 +39,7 @@
   private final boolean onlyIfCached;
   private final boolean noTransform;
 
-  String headerValue; // Lazily computed, if absent.
+  String headerValue; // Lazily computed, null if absent.
 
   private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
       boolean isPrivate, boolean isPublic, boolean mustRevalidate, int maxStaleSeconds,
@@ -76,10 +73,9 @@ private CacheControl(Builder builder) {
   }
 
   /**
-   * In a response, this field's name "no-cache" is misleading. It doesn't
-   * prevent us from caching the response; it only means we have to validate the
-   * response with the origin server before returning it. We can do this with a
-   * conditional GET.
+   * In a response, this field's name "no-cache" is misleading. It doesn't prevent us from caching
+   * the response; it only means we have to validate the response with the origin server before
+   * returning it. We can do this with a conditional GET.
    *
    * <p>In a request, it means do not use a cache to satisfy the request.
    */
@@ -93,17 +89,15 @@ public boolean noStore() {
   }
 
   /**
-   * The duration past the response's served date that it can be served without
-   * validation.
+   * The duration past the response's served date that it can be served without validation.
    */
   public int maxAgeSeconds() {
     return maxAgeSeconds;
   }
 
   /**
-   * The "s-maxage" directive is the max age for shared caches. Not to be
-   * confused with "max-age" for non-shared caches, As in Firefox and Chrome,
-   * this directive is not honored by this cache.
+   * The "s-maxage" directive is the max age for shared caches. Not to be confused with "max-age"
+   * for non-shared caches, As in Firefox and Chrome, this directive is not honored by this cache.
    */
   public int sMaxAgeSeconds() {
     return sMaxAgeSeconds;
@@ -130,11 +124,10 @@ public int minFreshSeconds() {
   }
 
   /**
-   * This field's name "only-if-cached" is misleading. It actually means "do
-   * not use the network". It is set by a client who only wants to make a
-   * request if it can be fully satisfied by the cache. Cached responses that
-   * would require validation (ie. conditional gets) are not permitted if this
-   * header is set.
+   * This field's name "only-if-cached" is misleading. It actually means "do not use the network".
+   * It is set by a client who only wants to make a request if it can be fully satisfied by the
+   * cache. Cached responses that would require validation (ie. conditional gets) are not permitted
+   * if this header is set.
    */
   public boolean onlyIfCached() {
     return onlyIfCached;
@@ -145,8 +138,8 @@ public boolean noTransform() {
   }
 
   /**
-   * Returns the cache directives of {@code headers}. This honors both
-   * Cache-Control and Pragma headers if they are present.
+   * Returns the cache directives of {@code headers}. This honors both Cache-Control and Pragma
+   * headers if they are present.
    */
   public static CacheControl parse(Headers headers) {
     boolean noCache = false;
@@ -291,12 +284,11 @@ public Builder noStore() {
     }
 
     /**
-     * Sets the maximum age of a cached response. If the cache response's age
-     * exceeds {@code maxAge}, it will not be used and a network request will
-     * be made.
+     * Sets the maximum age of a cached response. If the cache response's age exceeds {@code
+     * maxAge}, it will not be used and a network request will be made.
      *
-     * @param maxAge a non-negative integer. This is stored and transmitted with
-     *     {@link TimeUnit#SECONDS} precision; finer precision will be lost.
+     * @param maxAge a non-negative integer. This is stored and transmitted with {@link
+     * TimeUnit#SECONDS} precision; finer precision will be lost.
      */
     public Builder maxAge(int maxAge, TimeUnit timeUnit) {
       if (maxAge < 0) throw new IllegalArgumentException("maxAge < 0: " + maxAge);
@@ -308,13 +300,11 @@ public Builder maxAge(int maxAge, TimeUnit timeUnit) {
     }
 
     /**
-     * Accept cached responses that have exceeded their freshness lifetime by
-     * up to {@code maxStale}. If unspecified, stale cache responses will not be
-     * used.
+     * Accept cached responses that have exceeded their freshness lifetime by up to {@code
+     * maxStale}. If unspecified, stale cache responses will not be used.
      *
-     * @param maxStale a non-negative integer. This is stored and transmitted
-     *     with {@link TimeUnit#SECONDS} precision; finer precision will be
-     *     lost.
+     * @param maxStale a non-negative integer. This is stored and transmitted with {@link
+     * TimeUnit#SECONDS} precision; finer precision will be lost.
      */
     public Builder maxStale(int maxStale, TimeUnit timeUnit) {
       if (maxStale < 0) throw new IllegalArgumentException("maxStale < 0: " + maxStale);
@@ -326,14 +316,12 @@ public Builder maxStale(int maxStale, TimeUnit timeUnit) {
     }
 
     /**
-     * Sets the minimum number of seconds that a response will continue to be
-     * fresh for. If the response will be stale when {@code minFresh} have
-     * elapsed, the cached response will not be used and a network request will
-     * be made.
+     * Sets the minimum number of seconds that a response will continue to be fresh for. If the
+     * response will be stale when {@code minFresh} have elapsed, the cached response will not be
+     * used and a network request will be made.
      *
-     * @param minFresh a non-negative integer. This is stored and transmitted
-     *     with {@link TimeUnit#SECONDS} precision; finer precision will be
-     *     lost.
+     * @param minFresh a non-negative integer. This is stored and transmitted with {@link
+     * TimeUnit#SECONDS} precision; finer precision will be lost.
      */
     public Builder minFresh(int minFresh, TimeUnit timeUnit) {
       if (minFresh < 0) throw new IllegalArgumentException("minFresh < 0: " + minFresh);
@@ -345,8 +333,8 @@ public Builder minFresh(int minFresh, TimeUnit timeUnit) {
     }
 
     /**
-     * Only accept the response if it is in the cache. If the response isn't
-     * cached, a {@code 504 Unsatisfiable Request} response will be returned.
+     * Only accept the response if it is in the cache. If the response isn't cached, a {@code 504
+     * Unsatisfiable Request} response will be returned.
      */
     public Builder onlyIfCached() {
       this.onlyIfCached = true;
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
new file mode 100644
index 0000000000..58506d1376
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+
+/**
+ * A call is a request that has been prepared for execution. A call can be canceled. As this object
+ * represents a single request/response pair (stream), it cannot be executed twice.
+ */
+public interface Call {
+  /** Returns the original request that initiated this call. */
+  Request request();
+
+  /**
+   * Invokes the request immediately, and blocks until the response can be processed or is in
+   * error.
+   *
+   * <p>The caller may read the response body with the response's {@link Response#body} method.  To
+   * facilitate connection recycling, callers should always {@link ResponseBody#close() close the
+   * response body}.
+   *
+   * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
+   * not necessarily indicate application-layer success: {@code response} may still indicate an
+   * unhappy HTTP response code like 404 or 500.
+   *
+   * @throws IOException if the request could not be executed due to cancellation, a connectivity
+   * problem or timeout. Because networks can fail during an exchange, it is possible that the
+   * remote server accepted the request before the failure.
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  Response execute() throws IOException;
+
+  /**
+   * Schedules the request to be executed at some point in the future.
+   *
+   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
+   * immediately unless there are several other requests currently being executed.
+   *
+   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
+   * failure exception.
+   *
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  void enqueue(Callback responseCallback);
+
+  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
+  void cancel();
+
+  /**
+   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
+   * #enqueue(Callback) enqueued}. It is an error to execute a call more than once.
+   */
+  boolean isExecuted();
+
+  boolean isCanceled();
+
+  interface Factory {
+    Call newCall(Request request);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Callback.java b/okhttp/src/main/java/okhttp3/Callback.java
similarity index 55%
rename from okhttp/src/main/java/com/squareup/okhttp/Callback.java
rename to okhttp/src/main/java/okhttp3/Callback.java
index d86960fe05..42a8a109b2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Callback.java
+++ b/okhttp/src/main/java/okhttp3/Callback.java
@@ -13,30 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 
 public interface Callback {
   /**
-   * Called when the request could not be executed due to cancellation, a
-   * connectivity problem or timeout. Because networks can fail during an
-   * exchange, it is possible that the remote server accepted the request
-   * before the failure.
+   * Called when the request could not be executed due to cancellation, a connectivity problem or
+   * timeout. Because networks can fail during an exchange, it is possible that the remote server
+   * accepted the request before the failure.
    */
-  void onFailure(Request request, IOException e);
+  void onFailure(Call call, IOException e);
 
   /**
-   * Called when the HTTP response was successfully returned by the remote
-   * server. The callback may proceed to read the response body with {@link
-   * Response#body}. The response is still live until its response body is
-   * closed with {@code response.body().close()}. The recipient of the callback
+   * Called when the HTTP response was successfully returned by the remote server. The callback may
+   * proceed to read the response body with {@link Response#body}. The response is still live until
+   * its response body is closed with {@code response.body().close()}. The recipient of the callback
    * may even consume the response body on another thread.
    *
-   * <p>Note that transport-layer success (receiving a HTTP response code,
-   * headers and body) does not necessarily indicate application-layer
-   * success: {@code response} may still indicate an unhappy HTTP response
-   * code like 404 or 500.
+   * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
+   * not necessarily indicate application-layer success: {@code response} may still indicate an
+   * unhappy HTTP response code like 404 or 500.
    */
-  void onResponse(Response response) throws IOException;
+  void onResponse(Call call, Response response) throws IOException;
 }
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
new file mode 100644
index 0000000000..2d90224922
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -0,0 +1,317 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.internal.Util;
+import okhttp3.internal.tls.CertificateChainCleaner;
+import okio.ByteString;
+
+/**
+ * Constrains which certificates are trusted. Pinning certificates defends against attacks on
+ * certificate authorities. It also prevents connections through man-in-the-middle certificate
+ * authorities either known or unknown to the application's user.
+ *
+ * <p>This class currently pins a certificate's Subject Public Key Info as described on <a
+ * href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins are either base64 SHA-256 hashes as
+ * in <a href="http://tools.ietf.org/html/rfc7469">HTTP Public Key Pinning (HPKP)</a> or SHA-1
+ * base64 hashes as in Chromium's <a href="http://goo.gl/XDh6je">static certificates</a>.
+ *
+ * <h3>Setting up Certificate Pinning</h3>
+ *
+ * <p>The easiest way to pin a host is turn on pinning with a broken configuration and read the
+ * expected configuration when the connection fails. Be sure to do this on a trusted network, and
+ * without man-in-the-middle tools like <a href="http://charlesproxy.com">Charles</a> or <a
+ * href="http://fiddlertool.com">Fiddler</a>.
+ *
+ * <p>For example, to pin {@code https://publicobject.com}, start with a broken
+ * configuration: <pre>   {@code
+ *
+ *     String hostname = "publicobject.com";
+ *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
+ *         .add(hostname, "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
+ *         .build();
+ *     OkHttpClient client = OkHttpClient.Builder()
+ *         .certificatePinner(certificatePinner)
+ *         .build();
+ *
+ *     Request request = new Request.Builder()
+ *         .url("https://" + hostname)
+ *         .build();
+ *     client.newCall(request).execute();
+ * }</pre>
+ *
+ * As expected, this fails with a certificate pinning exception: <pre>   {@code
+ *
+ * javax.net.ssl.SSLPeerUnverifiedException: Certificate pinning failure!
+ *   Peer certificate chain:
+ *     sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=: CN=publicobject.com, OU=PositiveSSL
+ *     sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=: CN=COMODO RSA Secure Server CA
+ *     sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=: CN=COMODO RSA Certification Authority
+ *     sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=: CN=AddTrust External CA Root
+ *   Pinned certificates for publicobject.com:
+ *     sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
+ *   at okhttp3.CertificatePinner.check(CertificatePinner.java)
+ *   at okhttp3.Connection.upgradeToTls(Connection.java)
+ *   at okhttp3.Connection.connect(Connection.java)
+ *   at okhttp3.Connection.connectAndSetOwner(Connection.java)
+ * }</pre>
+ *
+ * Follow up by pasting the public key hashes from the exception into the
+ * certificate pinner's configuration: <pre>   {@code
+ *
+ *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
+ *       .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+ *       .add("publicobject.com", "sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=")
+ *       .add("publicobject.com", "sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=")
+ *       .add("publicobject.com", "sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=")
+ *       .build();
+ * }</pre>
+ *
+ * Pinning is per-hostname and/or per-wildcard pattern. To pin both {@code publicobject.com} and
+ * {@code www.publicobject.com}, you must configure both hostnames.
+ *
+ * <p>Wildcard pattern rules:
+ * <ol>
+ *     <li>Asterisk {@code *} is only permitted in the left-most domain name label and must be the
+ *         only character in that label (i.e., must match the whole left-most label). For example,
+ *         {@code *.example.com} is permitted, while {@code *a.example.com}, {@code a*.example.com},
+ *         {@code a*b.example.com}, {@code a.*.example.com} are not permitted.
+ *     <li>Asterisk {@code *} cannot match across domain name labels. For example,
+ *         {@code *.example.com} matches {@code test.example.com} but does not match
+ *         {@code sub.test.example.com}.
+ *     <li>Wildcard patterns for single-label domain names are not permitted.
+ * </ol>
+ *
+ * If hostname pinned directly and via wildcard pattern, both direct and wildcard pins will be used.
+ * For example: {@code *.example.com} pinned with {@code pin1} and {@code a.example.com} pinned with
+ * {@code pin2}, to check {@code a.example.com} both {@code pin1} and {@code pin2} will be used.
+ *
+ * <h3>Warning: Certificate Pinning is Dangerous!</h3>
+ *
+ * <p>Pinning certificates limits your server team's abilities to update their TLS certificates. By
+ * pinning certificates, you take on additional operational complexity and limit your ability to
+ * migrate between certificate authorities. Do not use certificate pinning without the blessing of
+ * your server's TLS administrator!
+ *
+ * <h4>Note about self-signed certificates</h4>
+ *
+ * <p>{@link CertificatePinner} can not be used to pin self-signed certificate if such certificate
+ * is not accepted by {@link javax.net.ssl.TrustManager}.
+ *
+ * @see <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning"> OWASP:
+ * Certificate and Public Key Pinning</a>
+ */
+public final class CertificatePinner {
+  public static final CertificatePinner DEFAULT = new Builder().build();
+
+  private final List<Pin> pins;
+  private final CertificateChainCleaner certificateChainCleaner;
+
+  private CertificatePinner(List<Pin> pins, CertificateChainCleaner certificateChainCleaner) {
+    this.pins = pins;
+    this.certificateChainCleaner = certificateChainCleaner;
+  }
+
+  /**
+   * Confirms that at least one of the certificates pinned for {@code hostname} is in {@code
+   * peerCertificates}. Does nothing if there are no certificates pinned for {@code hostname}.
+   * OkHttp calls this after a successful TLS handshake, but before the connection is used.
+   *
+   * @throws SSLPeerUnverifiedException if {@code peerCertificates} don't match the certificates
+   * pinned for {@code hostname}.
+   */
+  public void check(String hostname, List<Certificate> peerCertificates)
+      throws SSLPeerUnverifiedException {
+    List<Pin> pins = findMatchingPins(hostname);
+    if (pins.isEmpty()) return;
+
+    if (certificateChainCleaner != null) {
+      peerCertificates = certificateChainCleaner.clean(peerCertificates, hostname);
+    }
+
+    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
+      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
+
+      // Lazily compute the hashes for each certificate.
+      ByteString sha1 = null;
+      ByteString sha256 = null;
+
+      for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
+        Pin pin = pins.get(p);
+        if (pin.hashAlgorithm.equals("sha256/")) {
+          if (sha256 == null) sha256 = sha256(x509Certificate);
+          if (pin.hash.equals(sha256)) return; // Success!
+        } else if (pin.hashAlgorithm.equals("sha1/")) {
+          if (sha1 == null) sha1 = sha1(x509Certificate);
+          if (pin.hash.equals(sha1)) return; // Success!
+        } else {
+          throw new AssertionError();
+        }
+      }
+    }
+
+    // If we couldn't find a matching pin, format a nice exception.
+    StringBuilder message = new StringBuilder()
+        .append("Certificate pinning failure!")
+        .append("\n  Peer certificate chain:");
+    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
+      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
+      message.append("\n    ").append(pin(x509Certificate))
+          .append(": ").append(x509Certificate.getSubjectDN().getName());
+    }
+    message.append("\n  Pinned certificates for ").append(hostname).append(":");
+    for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
+      Pin pin = pins.get(p);
+      message.append("\n    ").append(pin);
+    }
+    throw new SSLPeerUnverifiedException(message.toString());
+  }
+
+  /** @deprecated replaced with {@link #check(String, List)}. */
+  public void check(String hostname, Certificate... peerCertificates)
+      throws SSLPeerUnverifiedException {
+    check(hostname, Arrays.asList(peerCertificates));
+  }
+
+  /**
+   * Returns list of matching certificates' pins for the hostname. Returns an empty list if the
+   * hostname does not have pinned certificates.
+   */
+  List<Pin> findMatchingPins(String hostname) {
+    List<Pin> result = Collections.emptyList();
+    for (Pin pin : pins) {
+      if (pin.matches(hostname)) {
+        if (result.isEmpty()) result = new ArrayList<>();
+        result.add(pin);
+      }
+    }
+    return result;
+  }
+
+  /** Returns a certificate pinner that uses {@code certificateChainCleaner}. */
+  CertificatePinner withCertificateChainCleaner(CertificateChainCleaner certificateChainCleaner) {
+    return this.certificateChainCleaner != certificateChainCleaner
+        ? new CertificatePinner(pins, certificateChainCleaner)
+        : this;
+  }
+
+  /**
+   * Returns the SHA-256 of {@code certificate}'s public key.
+   *
+   * <p>In OkHttp 3.1.2 and earlier, this returned a SHA-1 hash of the public key. Both types are
+   * supported, but SHA-256 is preferred.
+   */
+  public static String pin(Certificate certificate) {
+    if (!(certificate instanceof X509Certificate)) {
+      throw new IllegalArgumentException("Certificate pinning requires X509 certificates");
+    }
+    return "sha256/" + sha256((X509Certificate) certificate).base64();
+  }
+
+  static ByteString sha1(X509Certificate x509Certificate) {
+    return Util.sha1(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
+  }
+
+  static ByteString sha256(X509Certificate x509Certificate) {
+    return Util.sha256(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
+  }
+
+  static final class Pin {
+    /** A hostname like {@code example.com} or a pattern like {@code *.example.com}. */
+    final String pattern;
+    /** Either {@code sha1/} or {@code sha256/}. */
+    final String hashAlgorithm;
+    /** The hash of the pinned certificate using {@link #hashAlgorithm}. */
+    final ByteString hash;
+
+    Pin(String pattern, String pin) {
+      this.pattern = pattern;
+      if (pin.startsWith("sha1/")) {
+        this.hashAlgorithm = "sha1/";
+        this.hash = ByteString.decodeBase64(pin.substring("sha1/".length()));
+      } else if (pin.startsWith("sha256/")) {
+        this.hashAlgorithm = "sha256/";
+        this.hash = ByteString.decodeBase64(pin.substring("sha256/".length()));
+      } else {
+        throw new IllegalArgumentException("pins must start with 'sha256/' or 'sha1/': " + pin);
+      }
+
+      if (this.hash == null) {
+        throw new IllegalArgumentException("pins must be base64: " + pin);
+      }
+    }
+
+    boolean matches(String hostname) {
+      if (pattern.equals(hostname)) return true;
+
+      int firstDot = hostname.indexOf('.');
+      return pattern.startsWith("*.")
+          && hostname.regionMatches(false, firstDot + 1, pattern, 2, pattern.length() - 2);
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Pin
+          && pattern.equals(((Pin) other).pattern)
+          && hashAlgorithm.equals(((Pin) other).hashAlgorithm)
+          && hash.equals(((Pin) other).hash);
+    }
+
+    @Override public int hashCode() {
+      int result = 17;
+      result = 31 * result + pattern.hashCode();
+      result = 31 * result + hashAlgorithm.hashCode();
+      result = 31 * result + hash.hashCode();
+      return result;
+    }
+
+    @Override public String toString() {
+      return hashAlgorithm + hash.base64();
+    }
+  }
+
+  /** Builds a configured certificate pinner. */
+  public static final class Builder {
+    private final List<Pin> pins = new ArrayList<>();
+
+    /**
+     * Pins certificates for {@code pattern}.
+     *
+     * @param pattern lower-case host name or wildcard pattern such as {@code *.example.com}.
+     * @param pins SHA-256 or SHA-1 hashes. Each pin is a hash of a certificate's Subject Public Key
+     * Info, base64-encoded and prefixed with either {@code sha256/} or {@code sha1/}.
+     */
+    public Builder add(String pattern, String... pins) {
+      if (pattern == null) throw new NullPointerException("pattern == null");
+
+      for (String pin : pins) {
+        this.pins.add(new Pin(pattern, pin));
+      }
+
+      return this;
+    }
+
+    public CertificatePinner build() {
+      return new CertificatePinner(Util.immutableList(pins), null);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Challenge.java b/okhttp/src/main/java/okhttp3/Challenge.java
similarity index 85%
rename from okhttp/src/main/java/com/squareup/okhttp/Challenge.java
rename to okhttp/src/main/java/okhttp3/Challenge.java
index a1ef7145a0..f4bb369c45 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Challenge.java
+++ b/okhttp/src/main/java/okhttp3/Challenge.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import static com.squareup.okhttp.internal.Util.equal;
+import okhttp3.internal.Util;
 
 /** An RFC 2617 challenge. */
 public final class Challenge {
@@ -28,19 +28,19 @@ public Challenge(String scheme, String realm) {
   }
 
   /** Returns the authentication scheme, like {@code Basic}. */
-  public String getScheme() {
+  public String scheme() {
     return scheme;
   }
 
   /** Returns the protection space. */
-  public String getRealm() {
+  public String realm() {
     return realm;
   }
 
   @Override public boolean equals(Object o) {
     return o instanceof Challenge
-        && equal(scheme, ((Challenge) o).scheme)
-        && equal(realm, ((Challenge) o).realm);
+        && Util.equal(scheme, ((Challenge) o).scheme)
+        && Util.equal(realm, ((Challenge) o).realm);
   }
 
   @Override public int hashCode() {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java b/okhttp/src/main/java/okhttp3/CipherSuite.java
similarity index 98%
rename from okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java
rename to okhttp/src/main/java/okhttp3/CipherSuite.java
index 13344578be..6697cad846 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java
+++ b/okhttp/src/main/java/okhttp3/CipherSuite.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import static java.lang.Integer.MAX_VALUE;
 
@@ -356,7 +356,7 @@
 
   /**
    * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
-   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
+   * for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
    * @param value the integer identifier for this cipher suite. (Documentation only.)
    * @param rfc the RFC describing this cipher suite. (Documentation only.)
    * @param sinceJavaVersion the first major Java release supporting this cipher suite.
@@ -367,6 +367,15 @@ private CipherSuite(
     this.javaName = javaName;
   }
 
+  /**
+   * Returns the Java name of this cipher suite. For some older cipher suites the Java name has the
+   * prefix {@code SSL_}, causing the Java name to be different from the {@linkplain #name() enum
+   * name} which is always prefixed {@code TLS_}.
+   */
+  public String javaName() {
+    return javaName;
+  }
+
   public static CipherSuite forJavaName(String javaName) {
     return javaName.startsWith("SSL_")
         ? valueOf("TLS_" + javaName.substring(4))
diff --git a/okhttp/src/main/java/okhttp3/Connection.java b/okhttp/src/main/java/okhttp3/Connection.java
new file mode 100644
index 0000000000..de3c22d98b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Connection.java
@@ -0,0 +1,93 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3;
+
+import java.net.Socket;
+
+/**
+ * The sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection. May be used for multiple
+ * HTTP request/response exchanges. Connections may be direct to the origin server or via a proxy.
+ *
+ * <p>Typically instances of this class are created, connected and exercised automatically by the
+ * HTTP client. Applications may use this class to monitor HTTP connections as members of a
+ * {@linkplain ConnectionPool connection pool}.
+ *
+ * <p>Do not confuse this class with the misnamed {@code HttpURLConnection}, which isn't so much a
+ * connection as a single request/response exchange.
+ *
+ * <h3>Modern TLS</h3>
+ *
+ * <p>There are tradeoffs when selecting which options to include when negotiating a secure
+ * connection to a remote host. Newer TLS options are quite useful:
+ *
+ * <ul>
+ *     <li>Server Name Indication (SNI) enables one IP address to negotiate secure connections for
+ *         multiple domain names.
+ *     <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used for
+ *         different HTTP and SPDY protocols.
+ * </ul>
+ *
+ * <p>Unfortunately, older HTTPS servers refuse to connect when such options are presented. Rather
+ * than avoiding these options entirely, this class allows a connection to be attempted with modern
+ * options and then retried without them should the attempt fail.
+ *
+ * <h3>Connection Reuse</h3>
+ *
+ * <p>Each connection can carry a varying number streams, depending on the underlying protocol being
+ * used. HTTP/1.x connections can carry either zero or one streams. HTTP/2 connections can carry any
+ * number of streams, dynamically configured with {@code SETTINGS_MAX_CONCURRENT_STREAMS}. A
+ * connection currently carrying zero streams is an idle stream. We keep it alive because reusing an
+ * existing connection is typically faster than establishing a new one.
+ *
+ * <p>When a single logical call requires multiple streams due to redirects or authorization
+ * challenges, we prefer to use the same physical connection for all streams in the sequence. There
+ * are potential performance and behavior consequences to this preference. To support this feature,
+ * this class separates <i>allocations</i> from <i>streams</i>. An allocation is created by a call,
+ * used for one or more streams, and then released. An allocated connection won't be stolen by other
+ * calls while a redirect or authorization challenge is being handled.
+ *
+ * <p>When the maximum concurrent streams limit is reduced, some allocations will be rescinded.
+ * Attempting to create new streams on these allocations will fail.
+ *
+ * <p>Note that an allocation may be released before its stream is completed. This is intended to
+ * make bookkeeping easier for the caller: releasing the allocation as soon as the terminal stream
+ * has been found. But only complete the stream once its data stream has been exhausted.
+ */
+public interface Connection {
+  /** Returns the route used by this connection. */
+  Route route();
+
+  /**
+   * Returns the socket that this connection is using. Returns an {@linkplain
+   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2 or SPDY
+   * connection the socket may be shared by multiple concurrent calls.
+   */
+  Socket socket();
+
+  /**
+   * Returns the TLS handshake used to establish this connection, or null if the connection is not
+   * HTTPS.
+   */
+  Handshake handshake();
+
+  /**
+   * Returns the protocol negotiated by this connection, or {@link Protocol#HTTP_1_1} if no protocol
+   * has been negotiated. This method returns {@link Protocol#HTTP_1_1} even if the remote peer is
+   * using {@link Protocol#HTTP_1_0}.
+   */
+  Protocol protocol();
+}
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
new file mode 100644
index 0000000000..d6391c3f83
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -0,0 +1,263 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3;
+
+import java.lang.ref.Reference;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.Executor;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import okhttp3.internal.Platform;
+import okhttp3.internal.RouteDatabase;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.io.RealConnection;
+
+import static okhttp3.internal.Platform.WARN;
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * Manages reuse of HTTP and SPDY connections for reduced network latency. HTTP requests that share
+ * the same {@link Address} may share a {@link Connection}. This class implements the policy of
+ * which connections to keep open for future use.
+ */
+public final class ConnectionPool {
+  /**
+   * Background threads are used to cleanup expired connections. There will be at most a single
+   * thread running per connection pool. The thread pool executor permits the pool itself to be
+   * garbage collected.
+   */
+  private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,
+      Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
+      new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
+
+  /** The maximum number of idle connections for each address. */
+  private final int maxIdleConnections;
+  private final long keepAliveDurationNs;
+  private final Runnable cleanupRunnable = new Runnable() {
+    @Override public void run() {
+      while (true) {
+        long waitNanos = cleanup(System.nanoTime());
+        if (waitNanos == -1) return;
+        if (waitNanos > 0) {
+          long waitMillis = waitNanos / 1000000L;
+          waitNanos -= (waitMillis * 1000000L);
+          synchronized (ConnectionPool.this) {
+            try {
+              ConnectionPool.this.wait(waitMillis, (int) waitNanos);
+            } catch (InterruptedException ignored) {
+            }
+          }
+        }
+      }
+    }
+  };
+
+  private final Deque<RealConnection> connections = new ArrayDeque<>();
+  final RouteDatabase routeDatabase = new RouteDatabase();
+  boolean cleanupRunning;
+
+  /**
+   * Create a new connection pool with tuning parameters appropriate for a single-user application.
+   * The tuning parameters in this pool are subject to change in future OkHttp releases. Currently
+   * this pool holds up to 5 idle connections which will be evicted after 5 minutes of inactivity.
+   */
+  public ConnectionPool() {
+    this(5, 5, TimeUnit.MINUTES);
+  }
+
+  public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) {
+    this.maxIdleConnections = maxIdleConnections;
+    this.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);
+
+    // Put a floor on the keep alive duration, otherwise cleanup will spin loop.
+    if (keepAliveDuration <= 0) {
+      throw new IllegalArgumentException("keepAliveDuration <= 0: " + keepAliveDuration);
+    }
+  }
+
+  /** Returns the number of idle connections in the pool. */
+  public synchronized int idleConnectionCount() {
+    int total = 0;
+    for (RealConnection connection : connections) {
+      if (connection.allocations.isEmpty()) total++;
+    }
+    return total;
+  }
+
+  /**
+   * Returns total number of connections in the pool. Note that prior to OkHttp 2.7 this included
+   * only idle connections and SPDY connections. Since OkHttp 2.7 this includes all connections,
+   * both active and inactive. Use {@link #idleConnectionCount()} to count connections not currently
+   * in use.
+   */
+  public synchronized int connectionCount() {
+    return connections.size();
+  }
+
+  /** Returns a recycled connection to {@code address}, or null if no such connection exists. */
+  RealConnection get(Address address, StreamAllocation streamAllocation) {
+    assert (Thread.holdsLock(this));
+    for (RealConnection connection : connections) {
+      if (connection.allocations.size() < connection.allocationLimit
+          && address.equals(connection.route().address)
+          && !connection.noNewStreams) {
+        streamAllocation.acquire(connection);
+        return connection;
+      }
+    }
+    return null;
+  }
+
+  void put(RealConnection connection) {
+    assert (Thread.holdsLock(this));
+    if (!cleanupRunning) {
+      cleanupRunning = true;
+      executor.execute(cleanupRunnable);
+    }
+    connections.add(connection);
+  }
+
+  /**
+   * Notify this pool that {@code connection} has become idle. Returns true if the connection has
+   * been removed from the pool and should be closed.
+   */
+  boolean connectionBecameIdle(RealConnection connection) {
+    assert (Thread.holdsLock(this));
+    if (connection.noNewStreams || maxIdleConnections == 0) {
+      connections.remove(connection);
+      return true;
+    } else {
+      notifyAll(); // Awake the cleanup thread: we may have exceeded the idle connection limit.
+      return false;
+    }
+  }
+
+  /** Close and remove all idle connections in the pool. */
+  public void evictAll() {
+    List<RealConnection> evictedConnections = new ArrayList<>();
+    synchronized (this) {
+      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
+        RealConnection connection = i.next();
+        if (connection.allocations.isEmpty()) {
+          connection.noNewStreams = true;
+          evictedConnections.add(connection);
+          i.remove();
+        }
+      }
+    }
+
+    for (RealConnection connection : evictedConnections) {
+      closeQuietly(connection.socket());
+    }
+  }
+
+  /**
+   * Performs maintenance on this pool, evicting the connection that has been idle the longest if
+   * either it has exceeded the keep alive limit or the idle connections limit.
+   *
+   * <p>Returns the duration in nanos to sleep until the next scheduled call to this method. Returns
+   * -1 if no further cleanups are required.
+   */
+  long cleanup(long now) {
+    int inUseConnectionCount = 0;
+    int idleConnectionCount = 0;
+    RealConnection longestIdleConnection = null;
+    long longestIdleDurationNs = Long.MIN_VALUE;
+
+    // Find either a connection to evict, or the time that the next eviction is due.
+    synchronized (this) {
+      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
+        RealConnection connection = i.next();
+
+        // If the connection is in use, keep searching.
+        if (pruneAndGetAllocationCount(connection, now) > 0) {
+          inUseConnectionCount++;
+          continue;
+        }
+
+        idleConnectionCount++;
+
+        // If the connection is ready to be evicted, we're done.
+        long idleDurationNs = now - connection.idleAtNanos;
+        if (idleDurationNs > longestIdleDurationNs) {
+          longestIdleDurationNs = idleDurationNs;
+          longestIdleConnection = connection;
+        }
+      }
+
+      if (longestIdleDurationNs >= this.keepAliveDurationNs
+          || idleConnectionCount > this.maxIdleConnections) {
+        // We've found a connection to evict. Remove it from the list, then close it below (outside
+        // of the synchronized block).
+        connections.remove(longestIdleConnection);
+      } else if (idleConnectionCount > 0) {
+        // A connection will be ready to evict soon.
+        return keepAliveDurationNs - longestIdleDurationNs;
+      } else if (inUseConnectionCount > 0) {
+        // All connections are in use. It'll be at least the keep alive duration 'til we run again.
+        return keepAliveDurationNs;
+      } else {
+        // No connections, idle or in use.
+        cleanupRunning = false;
+        return -1;
+      }
+    }
+
+    closeQuietly(longestIdleConnection.socket());
+
+    // Cleanup again immediately.
+    return 0;
+  }
+
+  /**
+   * Prunes any leaked allocations and then returns the number of remaining live allocations on
+   * {@code connection}. Allocations are leaked if the connection is tracking them but the
+   * application code has abandoned them. Leak detection is imprecise and relies on garbage
+   * collection.
+   */
+  private int pruneAndGetAllocationCount(RealConnection connection, long now) {
+    List<Reference<StreamAllocation>> references = connection.allocations;
+    for (int i = 0; i < references.size(); ) {
+      Reference<StreamAllocation> reference = references.get(i);
+
+      if (reference.get() != null) {
+        i++;
+        continue;
+      }
+
+      // We've discovered a leaked allocation. This is an application bug.
+      Platform.get().log(WARN, "A connection to " + connection.route().address().url()
+          + " was leaked. Did you forget to close a response body?", null);
+      references.remove(i);
+      connection.noNewStreams = true;
+
+      // If this was the last allocation, the connection is eligible for immediate eviction.
+      if (references.isEmpty()) {
+        connection.idleAtNanos = now - keepAliveDurationNs;
+        return 0;
+      }
+    }
+
+    return references.size();
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
similarity index 63%
rename from okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
rename to okhttp/src/main/java/okhttp3/ConnectionSpec.java
index 5e0f7d868a..8c99932f9e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -13,21 +13,32 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.Util;
 import java.util.Arrays;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
 
+import static okhttp3.internal.Util.concat;
+import static okhttp3.internal.Util.contains;
+import static okhttp3.internal.Util.immutableList;
+import static okhttp3.internal.Util.intersect;
+
 /**
  * Specifies configuration for the socket connection that HTTP traffic travels through. For {@code
  * https:} URLs, this includes the TLS version and cipher suites to use when negotiating a secure
  * connection.
+ *
+ * <p>The TLS versions configured in a connection spec are only be used if they are also enabled in
+ * the SSL socket. For example, if an SSL socket does not have TLS 1.2 enabled, it will not be used
+ * even if it is present on the connection spec. The same policy also applies to cipher suites.
+ *
+ * <p>Use {@link Builder#allEnabledTlsVersions()} and {@link Builder#allEnabledCipherSuites} to
+ * defer all feature selection to the underlying SSL socket.
  */
 public final class ConnectionSpec {
 
-  // This is a subset of the cipher suites supported in Chrome 37, current as of 2014-10-5.
+  // This is a subset of the cipher suites supported in Chrome 46, current as of 2015-11-05.
   // All of these suites are available on Android 5.0; earlier releases support a subset of
   // these suites. https://github.com/square/okhttp/issues/330
   private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
@@ -43,7 +54,6 @@
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
       CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
@@ -67,19 +77,11 @@
   /** Unencrypted, unauthenticated connections for {@code http:} URLs. */
   public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
 
-  final boolean tls;
-
-  /**
-   * Used if tls == true. The cipher suites to set on the SSLSocket. {@code null} means "use
-   * default set".
-   */
+  private final boolean tls;
+  private final boolean supportsTlsExtensions;
   private final String[] cipherSuites;
-
-  /** Used if tls == true. The TLS protocol versions to use. */
   private final String[] tlsVersions;
 
-  final boolean supportsTlsExtensions;
-
   private ConnectionSpec(Builder builder) {
     this.tls = builder.tls;
     this.cipherSuites = builder.cipherSuites;
@@ -92,26 +94,31 @@ public boolean isTls() {
   }
 
   /**
-   * Returns the cipher suites to use for a connection. This method can return {@code null} if the
-   * cipher suites enabled by default should be used.
+   * Returns the cipher suites to use for a connection. Returns {@code null} if all of the SSL
+   * socket's enabled cipher suites should be used.
    */
   public List<CipherSuite> cipherSuites() {
-    if (cipherSuites == null) {
-      return null;
-    }
+    if (cipherSuites == null) return null;
+
     CipherSuite[] result = new CipherSuite[cipherSuites.length];
     for (int i = 0; i < cipherSuites.length; i++) {
       result[i] = CipherSuite.forJavaName(cipherSuites[i]);
     }
-    return Util.immutableList(result);
+    return immutableList(result);
   }
 
+  /**
+   * Returns the TLS versions to use when negotiating a connection. Returns {@code null} if all of
+   * the SSL socket's enabled TLS versions should be used.
+   */
   public List<TlsVersion> tlsVersions() {
+    if (tlsVersions == null) return null;
+
     TlsVersion[] result = new TlsVersion[tlsVersions.length];
     for (int i = 0; i < tlsVersions.length; i++) {
       result[i] = TlsVersion.forJavaName(tlsVersions[i]);
     }
-    return Util.immutableList(result);
+    return immutableList(result);
   }
 
   public boolean supportsTlsExtensions() {
@@ -122,58 +129,41 @@ public boolean supportsTlsExtensions() {
   void apply(SSLSocket sslSocket, boolean isFallback) {
     ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);
 
-    sslSocket.setEnabledProtocols(specToApply.tlsVersions);
-
-    String[] cipherSuitesToEnable = specToApply.cipherSuites;
-    // null means "use default set".
-    if (cipherSuitesToEnable != null) {
-      sslSocket.setEnabledCipherSuites(cipherSuitesToEnable);
+    if (specToApply.tlsVersions != null) {
+      sslSocket.setEnabledProtocols(specToApply.tlsVersions);
+    }
+    if (specToApply.cipherSuites != null) {
+      sslSocket.setEnabledCipherSuites(specToApply.cipherSuites);
     }
   }
 
   /**
-   * Returns a copy of this that omits cipher suites and TLS versions not enabled by
-   * {@code sslSocket}.
+   * Returns a copy of this that omits cipher suites and TLS versions not enabled by {@code
+   * sslSocket}.
    */
   private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
-    String[] cipherSuitesToEnable = null;
-    if (cipherSuites != null) {
-      String[] cipherSuitesToSelectFrom = sslSocket.getEnabledCipherSuites();
-      cipherSuitesToEnable =
-          Util.intersect(String.class, cipherSuites, cipherSuitesToSelectFrom);
+    String[] cipherSuitesIntersection = cipherSuites != null
+        ? intersect(String.class, cipherSuites, sslSocket.getEnabledCipherSuites())
+        : sslSocket.getEnabledCipherSuites();
+    String[] tlsVersionsIntersection = tlsVersions != null
+        ? intersect(String.class, tlsVersions, sslSocket.getEnabledProtocols())
+        : sslSocket.getEnabledProtocols();
+
+    // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
+    // the SCSV cipher is added to signal that a protocol fallback has taken place.
+    if (isFallback && contains(sslSocket.getSupportedCipherSuites(), "TLS_FALLBACK_SCSV")) {
+      cipherSuitesIntersection = concat(cipherSuitesIntersection, "TLS_FALLBACK_SCSV");
     }
 
-    if (isFallback) {
-      // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
-      // the SCSV cipher is added to signal that a protocol fallback has taken place.
-      final String fallbackScsv = "TLS_FALLBACK_SCSV";
-      boolean socketSupportsFallbackScsv =
-          Arrays.asList(sslSocket.getSupportedCipherSuites()).contains(fallbackScsv);
-
-      if (socketSupportsFallbackScsv) {
-        // Add the SCSV cipher to the set of enabled cipher suites iff it is supported.
-        String[] oldEnabledCipherSuites = cipherSuitesToEnable != null
-            ? cipherSuitesToEnable
-            : sslSocket.getEnabledCipherSuites();
-        String[] newEnabledCipherSuites = new String[oldEnabledCipherSuites.length + 1];
-        System.arraycopy(oldEnabledCipherSuites, 0,
-            newEnabledCipherSuites, 0, oldEnabledCipherSuites.length);
-        newEnabledCipherSuites[newEnabledCipherSuites.length - 1] = fallbackScsv;
-        cipherSuitesToEnable = newEnabledCipherSuites;
-      }
-    }
-
-    String[] protocolsToSelectFrom = sslSocket.getEnabledProtocols();
-    String[] protocolsToEnable = Util.intersect(String.class, tlsVersions, protocolsToSelectFrom);
     return new Builder(this)
-        .cipherSuites(cipherSuitesToEnable)
-        .tlsVersions(protocolsToEnable)
+        .cipherSuites(cipherSuitesIntersection)
+        .tlsVersions(tlsVersionsIntersection)
         .build();
   }
 
   /**
-   * Returns {@code true} if the socket, as currently configured, supports this ConnectionSpec.
-   * In order for a socket to be compatible the enabled cipher suites and protocols must intersect.
+   * Returns {@code true} if the socket, as currently configured, supports this connection spec. In
+   * order for a socket to be compatible the enabled cipher suites and protocols must intersect.
    *
    * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
    * match the socket's enabled cipher suites. If there are no required cipher suites the socket
@@ -187,26 +177,23 @@ public boolean isCompatible(SSLSocket socket) {
       return false;
     }
 
-    String[] enabledProtocols = socket.getEnabledProtocols();
-    boolean requiredProtocolsEnabled = nonEmptyIntersection(tlsVersions, enabledProtocols);
-    if (!requiredProtocolsEnabled) {
+    if (tlsVersions != null
+        && !nonEmptyIntersection(tlsVersions, socket.getEnabledProtocols())) {
       return false;
     }
 
-    boolean requiredCiphersEnabled;
-    if (cipherSuites == null) {
-      requiredCiphersEnabled = socket.getEnabledCipherSuites().length > 0;
-    } else {
-      String[] enabledCipherSuites = socket.getEnabledCipherSuites();
-      requiredCiphersEnabled = nonEmptyIntersection(cipherSuites, enabledCipherSuites);
+    if (cipherSuites != null
+        && !nonEmptyIntersection(cipherSuites, socket.getEnabledCipherSuites())) {
+      return false;
     }
-    return requiredCiphersEnabled;
+
+    return true;
   }
 
   /**
-   * An N*M intersection that terminates if any intersection is found. The sizes of both
-   * arguments are assumed to be so small, and the likelihood of an intersection so great, that it
-   * is not worth the CPU cost of sorting or the memory cost of hashing.
+   * An N*M intersection that terminates if any intersection is found. The sizes of both arguments
+   * are assumed to be so small, and the likelihood of an intersection so great, that it is not
+   * worth the CPU cost of sorting or the memory cost of hashing.
    */
   private static boolean nonEmptyIntersection(String[] a, String[] b) {
     if (a == null || b == null || a.length == 0 || b.length == 0) {
@@ -220,15 +207,6 @@ private static boolean nonEmptyIntersection(String[] a, String[] b) {
     return false;
   }
 
-  private static <T> boolean contains(T[] array, T value) {
-    for (T arrayValue : array) {
-      if (Util.equal(value, arrayValue)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
   @Override public boolean equals(Object other) {
     if (!(other instanceof ConnectionSpec)) return false;
     if (other == this) return true;
@@ -256,16 +234,17 @@ private static boolean nonEmptyIntersection(String[] a, String[] b) {
   }
 
   @Override public String toString() {
-    if (tls) {
-      List<CipherSuite> cipherSuites = cipherSuites();
-      String cipherSuitesString = cipherSuites == null ? "[use default]" : cipherSuites.toString();
-      return "ConnectionSpec(cipherSuites=" + cipherSuitesString
-          + ", tlsVersions=" + tlsVersions()
-          + ", supportsTlsExtensions=" + supportsTlsExtensions
-          + ")";
-    } else {
+    if (!tls) {
       return "ConnectionSpec()";
     }
+
+    String cipherSuitesString = cipherSuites != null ? cipherSuites().toString() : "[all enabled]";
+    String tlsVersionsString = tlsVersions != null ? tlsVersions().toString() : "[all enabled]";
+    return "ConnectionSpec("
+        + "cipherSuites=" + cipherSuitesString
+        + ", tlsVersions=" + tlsVersionsString
+        + ", supportsTlsExtensions=" + supportsTlsExtensions
+        + ")";
   }
 
   public static final class Builder {
@@ -285,56 +264,58 @@ public Builder(ConnectionSpec connectionSpec) {
       this.supportsTlsExtensions = connectionSpec.supportsTlsExtensions;
     }
 
+    public Builder allEnabledCipherSuites() {
+      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+      this.cipherSuites = null;
+      return this;
+    }
+
     public Builder cipherSuites(CipherSuite... cipherSuites) {
       if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
 
-      // Convert enums to the string names Java wants. This makes a defensive copy!
       String[] strings = new String[cipherSuites.length];
       for (int i = 0; i < cipherSuites.length; i++) {
         strings[i] = cipherSuites[i].javaName;
       }
-      this.cipherSuites = strings;
-      return this;
+      return cipherSuites(strings);
     }
 
     public Builder cipherSuites(String... cipherSuites) {
       if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
 
-      if (cipherSuites == null) {
-        this.cipherSuites = null;
-      } else {
-        // This makes a defensive copy!
-        this.cipherSuites = cipherSuites.clone();
+      if (cipherSuites.length == 0) {
+        throw new IllegalArgumentException("At least one cipher suite is required");
       }
 
+      this.cipherSuites = cipherSuites.clone(); // Defensive copy.
+      return this;
+    }
+
+    public Builder allEnabledTlsVersions() {
+      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+      this.tlsVersions = null;
       return this;
     }
 
     public Builder tlsVersions(TlsVersion... tlsVersions) {
       if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
-      if (tlsVersions.length == 0) {
-        throw new IllegalArgumentException("At least one TlsVersion is required");
-      }
 
-      // Convert enums to the string names Java wants. This makes a defensive copy!
       String[] strings = new String[tlsVersions.length];
       for (int i = 0; i < tlsVersions.length; i++) {
         strings[i] = tlsVersions[i].javaName;
       }
-      this.tlsVersions = strings;
-      return this;
+
+      return tlsVersions(strings);
     }
 
     public Builder tlsVersions(String... tlsVersions) {
       if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
 
-      if (tlsVersions == null) {
-        this.tlsVersions = null;
-      } else {
-        // This makes a defensive copy!
-        this.tlsVersions = tlsVersions.clone();
+      if (tlsVersions.length == 0) {
+        throw new IllegalArgumentException("At least one TLS version is required");
       }
 
+      this.tlsVersions = tlsVersions.clone(); // Defensive copy.
       return this;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
new file mode 100644
index 0000000000..29a4bf84d1
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -0,0 +1,590 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collections;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.List;
+import java.util.Locale;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpDate;
+
+import static okhttp3.internal.Util.UTC;
+import static okhttp3.internal.Util.delimiterOffset;
+import static okhttp3.internal.Util.domainToAscii;
+import static okhttp3.internal.Util.trimSubstring;
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
+/**
+ * An <a href="http://tools.ietf.org/html/rfc6265">RFC 6265</a> Cookie.
+ *
+ * <p>This class doesn't support additional attributes on cookies, like <a
+ * href="https://code.google.com/p/chromium/issues/detail?id=232693">Chromium's Priority=HIGH
+ * extension</a>.
+ */
+public final class Cookie {
+  private static final Pattern YEAR_PATTERN
+      = Pattern.compile("(\\d{2,4})[^\\d]*");
+  private static final Pattern MONTH_PATTERN
+      = Pattern.compile("(?i)(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec).*");
+  private static final Pattern DAY_OF_MONTH_PATTERN
+      = Pattern.compile("(\\d{1,2})[^\\d]*");
+  private static final Pattern TIME_PATTERN
+      = Pattern.compile("(\\d{1,2}):(\\d{1,2}):(\\d{1,2})[^\\d]*");
+
+  private final String name;
+  private final String value;
+  private final long expiresAt;
+  private final String domain;
+  private final String path;
+  private final boolean secure;
+  private final boolean httpOnly;
+
+  private final boolean persistent; // True if 'expires' or 'max-age' is present.
+  private final boolean hostOnly; // True unless 'domain' is present.
+
+  private Cookie(String name, String value, long expiresAt, String domain, String path,
+      boolean secure, boolean httpOnly, boolean hostOnly, boolean persistent) {
+    this.name = name;
+    this.value = value;
+    this.expiresAt = expiresAt;
+    this.domain = domain;
+    this.path = path;
+    this.secure = secure;
+    this.httpOnly = httpOnly;
+    this.hostOnly = hostOnly;
+    this.persistent = persistent;
+  }
+
+  private Cookie(Builder builder) {
+    if (builder.name == null) throw new NullPointerException("builder.name == null");
+    if (builder.value == null) throw new NullPointerException("builder.value == null");
+    if (builder.domain == null) throw new NullPointerException("builder.domain == null");
+
+    this.name = builder.name;
+    this.value = builder.value;
+    this.expiresAt = builder.expiresAt;
+    this.domain = builder.domain;
+    this.path = builder.path;
+    this.secure = builder.secure;
+    this.httpOnly = builder.httpOnly;
+    this.persistent = builder.persistent;
+    this.hostOnly = builder.hostOnly;
+  }
+
+  /** Returns a non-empty string with this cookie's name. */
+  public String name() {
+    return name;
+  }
+
+  /** Returns a possibly-empty string with this cookie's value. */
+  public String value() {
+    return value;
+  }
+
+  /** Returns true if this cookie expires at the end of the current session. */
+  public boolean persistent() {
+    return persistent;
+  }
+
+  /**
+   * Returns the time that this cookie expires, in the same format as {@link
+   * System#currentTimeMillis()}. This is December 31, 9999 if the cookie is {@linkplain
+   * #persistent() not persistent}, in which case it will expire at the end of the current session.
+   *
+   * <p>This may return a value less than the current time, in which case the cookie is already
+   * expired. Webservers may return expired cookies as a mechanism to delete previously set cookies
+   * that may or may not themselves be expired.
+   */
+  public long expiresAt() {
+    return expiresAt;
+  }
+
+  /**
+   * Returns true if this cookie's domain should be interpreted as a single host name, or false if
+   * it should be interpreted as a pattern. This flag will be false if its {@code Set-Cookie} header
+   * included a {@code domain} attribute.
+   *
+   * <p>For example, suppose the cookie's domain is {@code example.com}. If this flag is true it
+   * matches <strong>only</strong> {@code example.com}. If this flag is false it matches {@code
+   * example.com} and all subdomains including {@code api.example.com}, {@code www.example.com}, and
+   * {@code beta.api.example.com}.
+   */
+  public boolean hostOnly() {
+    return hostOnly;
+  }
+
+  /**
+   * Returns the cookie's domain. If {@link #hostOnly()} returns true this is the only domain that
+   * matches this cookie; otherwise it matches this domain and all subdomains.
+   */
+  public String domain() {
+    return domain;
+  }
+
+  /**
+   * Returns this cookie's path. This cookie matches URLs prefixed with path segments that match
+   * this path's segments. For example, if this path is {@code /foo} this cookie matches requests to
+   * {@code /foo} and {@code /foo/bar}, but not {@code /} or {@code /football}.
+   */
+  public String path() {
+    return path;
+  }
+
+  /**
+   * Returns true if this cookie should be limited to only HTTP APIs. In web browsers this prevents
+   * the cookie from being accessible to scripts.
+   */
+  public boolean httpOnly() {
+    return httpOnly;
+  }
+
+  /** Returns true if this cookie should be limited to only HTTPS requests. */
+  public boolean secure() {
+    return secure;
+  }
+
+  /**
+   * Returns true if this cookie should be included on a request to {@code url}. In addition to this
+   * check callers should also confirm that this cookie has not expired.
+   */
+  public boolean matches(HttpUrl url) {
+    boolean domainMatch = hostOnly
+        ? url.host().equals(domain)
+        : domainMatch(url, domain);
+    if (!domainMatch) return false;
+
+    if (!pathMatch(url, path)) return false;
+
+    if (secure && !url.isHttps()) return false;
+
+    return true;
+  }
+
+  private static boolean domainMatch(HttpUrl url, String domain) {
+    String urlHost = url.host();
+
+    if (urlHost.equals(domain)) {
+      return true; // As in 'example.com' matching 'example.com'.
+    }
+
+    if (urlHost.endsWith(domain)
+        && urlHost.charAt(urlHost.length() - domain.length() - 1) == '.'
+        && !verifyAsIpAddress(urlHost)) {
+      return true; // As in 'example.com' matching 'www.example.com'.
+    }
+
+    return false;
+  }
+
+  private static boolean pathMatch(HttpUrl url, String path) {
+    String urlPath = url.encodedPath();
+
+    if (urlPath.equals(path)) {
+      return true; // As in '/foo' matching '/foo'.
+    }
+
+    if (urlPath.startsWith(path)) {
+      if (path.endsWith("/")) return true; // As in '/' matching '/foo'.
+      if (urlPath.charAt(path.length()) == '/') return true; // As in '/foo' matching '/foo/bar'.
+    }
+
+    return false;
+  }
+
+  /**
+   * Attempt to parse a {@code Set-Cookie} HTTP header value {@code setCookie} as a cookie. Returns
+   * null if {@code setCookie} is not a well-formed cookie.
+   */
+  public static Cookie parse(HttpUrl url, String setCookie) {
+    return parse(System.currentTimeMillis(), url, setCookie);
+  }
+
+  static Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
+    int pos = 0;
+    int limit = setCookie.length();
+    int cookiePairEnd = delimiterOffset(setCookie, pos, limit, ';');
+
+    int pairEqualsSign = delimiterOffset(setCookie, pos, cookiePairEnd, '=');
+    if (pairEqualsSign == cookiePairEnd) return null;
+
+    String cookieName = trimSubstring(setCookie, pos, pairEqualsSign);
+    if (cookieName.isEmpty()) return null;
+
+    String cookieValue = trimSubstring(setCookie, pairEqualsSign + 1, cookiePairEnd);
+
+    long expiresAt = HttpDate.MAX_DATE;
+    long deltaSeconds = -1L;
+    String domain = null;
+    String path = null;
+    boolean secureOnly = false;
+    boolean httpOnly = false;
+    boolean hostOnly = true;
+    boolean persistent = false;
+
+    pos = cookiePairEnd + 1;
+    while (pos < limit) {
+      int attributePairEnd = delimiterOffset(setCookie, pos, limit, ';');
+
+      int attributeEqualsSign = delimiterOffset(setCookie, pos, attributePairEnd, '=');
+      String attributeName = trimSubstring(setCookie, pos, attributeEqualsSign);
+      String attributeValue = attributeEqualsSign < attributePairEnd
+          ? trimSubstring(setCookie, attributeEqualsSign + 1, attributePairEnd)
+          : "";
+
+      if (attributeName.equalsIgnoreCase("expires")) {
+        try {
+          expiresAt = parseExpires(attributeValue, 0, attributeValue.length());
+          persistent = true;
+        } catch (IllegalArgumentException e) {
+          // Ignore this attribute, it isn't recognizable as a date.
+        }
+      } else if (attributeName.equalsIgnoreCase("max-age")) {
+        try {
+          deltaSeconds = parseMaxAge(attributeValue);
+          persistent = true;
+        } catch (NumberFormatException e) {
+          // Ignore this attribute, it isn't recognizable as a max age.
+        }
+      } else if (attributeName.equalsIgnoreCase("domain")) {
+        try {
+          domain = parseDomain(attributeValue);
+          hostOnly = false;
+        } catch (IllegalArgumentException e) {
+          // Ignore this attribute, it isn't recognizable as a domain.
+        }
+      } else if (attributeName.equalsIgnoreCase("path")) {
+        path = attributeValue;
+      } else if (attributeName.equalsIgnoreCase("secure")) {
+        secureOnly = true;
+      } else if (attributeName.equalsIgnoreCase("httponly")) {
+        httpOnly = true;
+      }
+
+      pos = attributePairEnd + 1;
+    }
+
+    // If 'Max-Age' is present, it takes precedence over 'Expires', regardless of the order the two
+    // attributes are declared in the cookie string.
+    if (deltaSeconds == Long.MIN_VALUE) {
+      expiresAt = Long.MIN_VALUE;
+    } else if (deltaSeconds != -1L) {
+      long deltaMilliseconds = deltaSeconds <= (Long.MAX_VALUE / 1000)
+          ? deltaSeconds * 1000
+          : Long.MAX_VALUE;
+      expiresAt = currentTimeMillis + deltaMilliseconds;
+      if (expiresAt < currentTimeMillis || expiresAt > HttpDate.MAX_DATE) {
+        expiresAt = HttpDate.MAX_DATE; // Handle overflow & limit the date range.
+      }
+    }
+
+    // If the domain is present, it must domain match. Otherwise we have a host-only cookie.
+    if (domain == null) {
+      domain = url.host();
+    } else if (!domainMatch(url, domain)) {
+      return null; // No domain match? This is either incompetence or malice!
+    }
+
+    // If the path is absent or didn't start with '/', use the default path. It's a string like
+    // '/foo/bar' for a URL like 'http://example.com/foo/bar/baz'. It always starts with '/'.
+    if (path == null || !path.startsWith("/")) {
+      String encodedPath = url.encodedPath();
+      int lastSlash = encodedPath.lastIndexOf('/');
+      path = lastSlash != 0 ? encodedPath.substring(0, lastSlash) : "/";
+    }
+
+    return new Cookie(cookieName, cookieValue, expiresAt, domain, path, secureOnly, httpOnly,
+        hostOnly, persistent);
+  }
+
+  /** Parse a date as specified in RFC 6265, section 5.1.1. */
+  private static long parseExpires(String s, int pos, int limit) {
+    pos = dateCharacterOffset(s, pos, limit, false);
+
+    int hour = -1;
+    int minute = -1;
+    int second = -1;
+    int dayOfMonth = -1;
+    int month = -1;
+    int year = -1;
+    Matcher matcher = TIME_PATTERN.matcher(s);
+
+    while (pos < limit) {
+      int end = dateCharacterOffset(s, pos + 1, limit, true);
+      matcher.region(pos, end);
+
+      if (hour == -1 && matcher.usePattern(TIME_PATTERN).matches()) {
+        hour = Integer.parseInt(matcher.group(1));
+        minute = Integer.parseInt(matcher.group(2));
+        second = Integer.parseInt(matcher.group(3));
+      } else if (dayOfMonth == -1 && matcher.usePattern(DAY_OF_MONTH_PATTERN).matches()) {
+        dayOfMonth = Integer.parseInt(matcher.group(1));
+      } else if (month == -1 && matcher.usePattern(MONTH_PATTERN).matches()) {
+        String monthString = matcher.group(1).toLowerCase(Locale.US);
+        month = MONTH_PATTERN.pattern().indexOf(monthString) / 4; // Sneaky! jan=1, dec=12.
+      } else if (year == -1 && matcher.usePattern(YEAR_PATTERN).matches()) {
+        year = Integer.parseInt(matcher.group(1));
+      }
+
+      pos = dateCharacterOffset(s, end + 1, limit, false);
+    }
+
+    // Convert two-digit years into four-digit years. 99 becomes 1999, 15 becomes 2015.
+    if (year >= 70 && year <= 99) year += 1900;
+    if (year >= 0 && year <= 69) year += 2000;
+
+    // If any partial is omitted or out of range, return -1. The date is impossible. Note that leap
+    // seconds are not supported by this syntax.
+    if (year < 1601) throw new IllegalArgumentException();
+    if (month == -1) throw new IllegalArgumentException();
+    if (dayOfMonth < 1 || dayOfMonth > 31) throw new IllegalArgumentException();
+    if (hour < 0 || hour > 23) throw new IllegalArgumentException();
+    if (minute < 0 || minute > 59) throw new IllegalArgumentException();
+    if (second < 0 || second > 59) throw new IllegalArgumentException();
+
+    Calendar calendar = new GregorianCalendar(UTC);
+    calendar.setLenient(false);
+    calendar.set(Calendar.YEAR, year);
+    calendar.set(Calendar.MONTH, month - 1);
+    calendar.set(Calendar.DAY_OF_MONTH, dayOfMonth);
+    calendar.set(Calendar.HOUR_OF_DAY, hour);
+    calendar.set(Calendar.MINUTE, minute);
+    calendar.set(Calendar.SECOND, second);
+    calendar.set(Calendar.MILLISECOND, 0);
+    return calendar.getTimeInMillis();
+  }
+
+  /**
+   * Returns the index of the next date character in {@code input}, or if {@code invert} the index
+   * of the next non-date character in {@code input}.
+   */
+  private static int dateCharacterOffset(String input, int pos, int limit, boolean invert) {
+    for (int i = pos; i < limit; i++) {
+      int c = input.charAt(i);
+      boolean dateCharacter = (c < ' ' && c != '\t') || (c >= '\u007f')
+          || (c >= '0' && c <= '9')
+          || (c >= 'a' && c <= 'z')
+          || (c >= 'A' && c <= 'Z')
+          || (c == ':');
+      if (dateCharacter == !invert) return i;
+    }
+    return limit;
+  }
+
+  /**
+   * Returns the positive value if {@code attributeValue} is positive, or {@link Long#MIN_VALUE} if
+   * it is either 0 or negative. If the value is positive but out of range, this returns {@link
+   * Long#MAX_VALUE}.
+   *
+   * @throws NumberFormatException if {@code s} is not an integer of any precision.
+   */
+  private static long parseMaxAge(String s) {
+    try {
+      long parsed = Long.parseLong(s);
+      return parsed <= 0L ? Long.MIN_VALUE : parsed;
+    } catch (NumberFormatException e) {
+      // Check if the value is an integer (positive or negative) that's too big for a long.
+      if (s.matches("-?\\d+")) {
+        return s.startsWith("-") ? Long.MIN_VALUE : Long.MAX_VALUE;
+      }
+      throw e;
+    }
+  }
+
+  /**
+   * Returns a domain string like {@code example.com} for an input domain like {@code EXAMPLE.COM}
+   * or {@code .example.com}.
+   */
+  private static String parseDomain(String s) {
+    if (s.endsWith(".")) {
+      throw new IllegalArgumentException();
+    }
+    if (s.startsWith(".")) {
+      s = s.substring(1);
+    }
+    String canonicalDomain = domainToAscii(s);
+    if (canonicalDomain == null) {
+      throw new IllegalArgumentException();
+    }
+    return canonicalDomain;
+  }
+
+  /** Returns all of the cookies from a set of HTTP response headers. */
+  public static List<Cookie> parseAll(HttpUrl url, Headers headers) {
+    List<String> cookieStrings = headers.values("Set-Cookie");
+    List<Cookie> cookies = null;
+
+    for (int i = 0, size = cookieStrings.size(); i < size; i++) {
+      Cookie cookie = Cookie.parse(url, cookieStrings.get(i));
+      if (cookie == null) continue;
+      if (cookies == null) cookies = new ArrayList<>();
+      cookies.add(cookie);
+    }
+
+    return cookies != null
+        ? Collections.unmodifiableList(cookies)
+        : Collections.<Cookie>emptyList();
+  }
+
+  /**
+   * Builds a cookie. The {@linkplain #name() name}, {@linkplain #value() value}, and {@linkplain
+   * #domain() domain} values must all be set before calling {@link #build}.
+   */
+  public static final class Builder {
+    String name;
+    String value;
+    long expiresAt = HttpDate.MAX_DATE;
+    String domain;
+    String path = "/";
+    boolean secure;
+    boolean httpOnly;
+    boolean persistent;
+    boolean hostOnly;
+
+    public Builder name(String name) {
+      if (name == null) throw new NullPointerException("name == null");
+      if (!name.trim().equals(name)) throw new IllegalArgumentException("name is not trimmed");
+      this.name = name;
+      return this;
+    }
+
+    public Builder value(String value) {
+      if (value == null) throw new NullPointerException("value == null");
+      if (!value.trim().equals(value)) throw new IllegalArgumentException("value is not trimmed");
+      this.value = value;
+      return this;
+    }
+
+    public Builder expiresAt(long expiresAt) {
+      if (expiresAt <= 0) expiresAt = Long.MIN_VALUE;
+      if (expiresAt > HttpDate.MAX_DATE) expiresAt = HttpDate.MAX_DATE;
+      this.expiresAt = expiresAt;
+      this.persistent = true;
+      return this;
+    }
+
+    /**
+     * Set the domain pattern for this cookie. The cookie will match {@code domain} and all of its
+     * subdomains.
+     */
+    public Builder domain(String domain) {
+      return domain(domain, false);
+    }
+
+    /**
+     * Set the host-only domain for this cookie. The cookie will match {@code domain} but none of
+     * its subdomains.
+     */
+    public Builder hostOnlyDomain(String domain) {
+      return domain(domain, true);
+    }
+
+    private Builder domain(String domain, boolean hostOnly) {
+      if (domain == null) throw new NullPointerException("domain == null");
+      String canonicalDomain = Util.domainToAscii(domain);
+      if (canonicalDomain == null) {
+        throw new IllegalArgumentException("unexpected domain: " + domain);
+      }
+      this.domain = canonicalDomain;
+      this.hostOnly = hostOnly;
+      return this;
+    }
+
+    public Builder path(String path) {
+      if (!path.startsWith("/")) throw new IllegalArgumentException("path must start with '/'");
+      this.path = path;
+      return this;
+    }
+
+    public Builder secure() {
+      this.secure = true;
+      return this;
+    }
+
+    public Builder httpOnly() {
+      this.httpOnly = true;
+      return this;
+    }
+
+    public Cookie build() {
+      return new Cookie(this);
+    }
+  }
+
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder();
+    result.append(name);
+    result.append('=');
+    result.append(value);
+
+    if (persistent) {
+      if (expiresAt == Long.MIN_VALUE) {
+        result.append("; max-age=0");
+      } else {
+        result.append("; expires=").append(HttpDate.format(new Date(expiresAt)));
+      }
+    }
+
+    if (!hostOnly) {
+      result.append("; domain=").append(domain);
+    }
+
+    result.append("; path=").append(path);
+
+    if (secure) {
+      result.append("; secure");
+    }
+
+    if (httpOnly) {
+      result.append("; httponly");
+    }
+
+    return result.toString();
+  }
+
+  @Override public boolean equals(Object other) {
+    if (!(other instanceof Cookie)) return false;
+    Cookie that = (Cookie) other;
+    return that.name.equals(name)
+        && that.value.equals(value)
+        && that.domain.equals(domain)
+        && that.path.equals(path)
+        && that.expiresAt == expiresAt
+        && that.secure == secure
+        && that.httpOnly == httpOnly
+        && that.persistent == persistent
+        && that.hostOnly == hostOnly;
+  }
+
+  @Override public int hashCode() {
+    int hash = 17;
+    hash = 31 * hash + name.hashCode();
+    hash = 31 * hash + value.hashCode();
+    hash = 31 * hash + domain.hashCode();
+    hash = 31 * hash + path.hashCode();
+    hash = 31 * hash + (int) (expiresAt ^ (expiresAt >>> 32));
+    hash = 31 * hash + (secure ? 0 : 1);
+    hash = 31 * hash + (httpOnly ? 0 : 1);
+    hash = 31 * hash + (persistent ? 0 : 1);
+    hash = 31 * hash + (hostOnly ? 0 : 1);
+    return hash;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/CookieJar.java b/okhttp/src/main/java/okhttp3/CookieJar.java
new file mode 100644
index 0000000000..d2cdfce22a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CookieJar.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Provides <strong>policy</strong> and <strong>persistence</strong> for HTTP cookies.
+ *
+ * <p>As policy, implementations of this interface are responsible for selecting which cookies to
+ * accept and which to reject. A reasonable policy is to reject all cookies, though that may be
+ * interfere with session-based authentication schemes that require cookies.
+ *
+ * <p>As persistence, implementations of this interface must also provide storage of cookies. Simple
+ * implementations may store cookies in memory; sophisticated ones may use the file system or
+ * database to hold accepted cookies. The <a
+ * href="https://tools.ietf.org/html/rfc6265#section-5.3">cookie storage model</a> specifies
+ * policies for updating and expiring cookies.
+ */
+public interface CookieJar {
+  /** A cookie jar that never accepts any cookies. */
+  CookieJar NO_COOKIES = new CookieJar() {
+    @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
+    }
+
+    @Override public List<Cookie> loadForRequest(HttpUrl url) {
+      return Collections.emptyList();
+    }
+  };
+
+  /**
+   * Saves {@code cookies} from an HTTP response to this store according to this jar's policy.
+   *
+   * <p>Note that this method may be called a second time for a single HTTP response if the response
+   * includes a trailer. For this obscure HTTP feature, {@code cookies} contains only the trailer's
+   * cookies.
+   */
+  void saveFromResponse(HttpUrl url, List<Cookie> cookies);
+
+  /**
+   * Load cookies from the jar for an HTTP request to {@code url}. This method returns a possibly
+   * empty list of cookies for the network request.
+   *
+   * <p>Simple implementations will return the accepted cookies that have not yet expired and that
+   * {@linkplain Cookie#matches match} {@code url}.
+   */
+  List<Cookie> loadForRequest(HttpUrl url);
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Credentials.java b/okhttp/src/main/java/okhttp3/Credentials.java
similarity index 97%
rename from okhttp/src/main/java/com/squareup/okhttp/Credentials.java
rename to okhttp/src/main/java/okhttp3/Credentials.java
index 92c128f568..9be4e6a22f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Credentials.java
+++ b/okhttp/src/main/java/okhttp3/Credentials.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.UnsupportedEncodingException;
 import okio.ByteString;
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
new file mode 100644
index 0000000000..5a135b325d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import okhttp3.RealCall.AsyncCall;
+import okhttp3.internal.Util;
+
+/**
+ * Policy on when async requests are executed.
+ *
+ * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you supply your
+ * own executor, it should be able to run {@linkplain #getMaxRequests the configured maximum} number
+ * of calls concurrently.
+ */
+public final class Dispatcher {
+  private int maxRequests = 64;
+  private int maxRequestsPerHost = 5;
+
+  /** Executes calls. Created lazily. */
+  private ExecutorService executorService;
+
+  /** Ready async calls in the order they'll be run. */
+  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
+
+  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
+  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
+
+  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
+  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
+
+  public Dispatcher(ExecutorService executorService) {
+    this.executorService = executorService;
+  }
+
+  public Dispatcher() {
+  }
+
+  public synchronized ExecutorService executorService() {
+    if (executorService == null) {
+      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
+          new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
+    }
+    return executorService;
+  }
+
+  /**
+   * Set the maximum number of requests to execute concurrently. Above this requests queue in
+   * memory, waiting for the running calls to complete.
+   *
+   * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
+   * will remain in flight.
+   */
+  public synchronized void setMaxRequests(int maxRequests) {
+    if (maxRequests < 1) {
+      throw new IllegalArgumentException("max < 1: " + maxRequests);
+    }
+    this.maxRequests = maxRequests;
+    promoteCalls();
+  }
+
+  public synchronized int getMaxRequests() {
+    return maxRequests;
+  }
+
+  /**
+   * Set the maximum number of requests for each host to execute concurrently. This limits requests
+   * by the URL's host name. Note that concurrent requests to a single IP address may still exceed
+   * this limit: multiple hostnames may share an IP address or be routed through the same HTTP
+   * proxy.
+   *
+   * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those
+   * requests will remain in flight.
+   */
+  public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
+    if (maxRequestsPerHost < 1) {
+      throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
+    }
+    this.maxRequestsPerHost = maxRequestsPerHost;
+    promoteCalls();
+  }
+
+  public synchronized int getMaxRequestsPerHost() {
+    return maxRequestsPerHost;
+  }
+
+  synchronized void enqueue(AsyncCall call) {
+    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
+      runningAsyncCalls.add(call);
+      executorService().execute(call);
+    } else {
+      readyAsyncCalls.add(call);
+    }
+  }
+
+  /**
+   * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain
+   * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.
+   */
+  public synchronized void cancelAll() {
+    for (AsyncCall call : readyAsyncCalls) {
+      call.cancel();
+    }
+
+    for (AsyncCall call : runningAsyncCalls) {
+      call.cancel();
+    }
+
+    for (RealCall call : runningSyncCalls) {
+      call.cancel();
+    }
+  }
+
+  /** Used by {@code AsyncCall#run} to signal completion. */
+  synchronized void finished(AsyncCall call) {
+    if (!runningAsyncCalls.remove(call)) throw new AssertionError("AsyncCall wasn't running!");
+    promoteCalls();
+  }
+
+  private void promoteCalls() {
+    if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.
+    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.
+
+    for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
+      AsyncCall call = i.next();
+
+      if (runningCallsForHost(call) < maxRequestsPerHost) {
+        i.remove();
+        runningAsyncCalls.add(call);
+        executorService().execute(call);
+      }
+
+      if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.
+    }
+  }
+
+  /** Returns the number of running calls that share a host with {@code call}. */
+  private int runningCallsForHost(AsyncCall call) {
+    int result = 0;
+    for (AsyncCall c : runningAsyncCalls) {
+      if (c.host().equals(call.host())) result++;
+    }
+    return result;
+  }
+
+  /** Used by {@code Call#execute} to signal it is in-flight. */
+  synchronized void executed(RealCall call) {
+    runningSyncCalls.add(call);
+  }
+
+  /** Used by {@code Call#execute} to signal completion. */
+  synchronized void finished(Call call) {
+    if (!runningSyncCalls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
+  }
+
+  /** Returns a snapshot of the calls currently awaiting execution. */
+  public synchronized List<Call> queuedCalls() {
+    List<Call> result = new ArrayList<>();
+    for (AsyncCall asyncCall : readyAsyncCalls) {
+      result.add(asyncCall.get());
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  /** Returns a snapshot of the calls currently being executed. */
+  public synchronized List<Call> runningCalls() {
+    List<Call> result = new ArrayList<>();
+    result.addAll(runningSyncCalls);
+    for (AsyncCall asyncCall : runningAsyncCalls) {
+      result.add(asyncCall.get());
+    }
+    return Collections.unmodifiableList(result);
+  }
+
+  public synchronized int queuedCallsCount() {
+    return readyAsyncCalls.size();
+  }
+
+  public synchronized int runningCallsCount() {
+    return runningAsyncCalls.size() + runningSyncCalls.size();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Dns.java b/okhttp/src/main/java/okhttp3/Dns.java
new file mode 100644
index 0000000000..a2e6db591c
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Dns.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * A domain name service that resolves IP addresses for host names. Most applications will use the
+ * {@linkplain #SYSTEM system DNS service}, which is the default. Some applications may provide
+ * their own implementation to use a different DNS server, to prefer IPv6 addresses, to prefer IPv4
+ * addresses, or to force a specific known IP address.
+ *
+ * <p>Implementations of this interface must be safe for concurrent use.
+ */
+public interface Dns {
+  /**
+   * A DNS that uses {@link InetAddress#getAllByName} to ask the underlying operating system to
+   * lookup IP addresses. Most custom {@link Dns} implementations should delegate to this instance.
+   */
+  Dns SYSTEM = new Dns() {
+    @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+      if (hostname == null) throw new UnknownHostException("hostname == null");
+      return Arrays.asList(InetAddress.getAllByName(hostname));
+    }
+  };
+
+  /**
+   * Returns the IP addresses of {@code hostname}, in the order they will be attempted by OkHttp. If
+   * a connection to an address fails, OkHttp will retry the connection with the next address until
+   * either a connection is made, the set of IP addresses is exhausted, or a limit is exceeded.
+   */
+  List<InetAddress> lookup(String hostname) throws UnknownHostException;
+}
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
new file mode 100644
index 0000000000..95181b1f76
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/FormBody.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSink;
+
+import static okhttp3.HttpUrl.FORM_ENCODE_SET;
+import static okhttp3.HttpUrl.percentDecode;
+
+public final class FormBody extends RequestBody {
+  private static final MediaType CONTENT_TYPE =
+      MediaType.parse("application/x-www-form-urlencoded");
+
+  private final List<String> encodedNames;
+  private final List<String> encodedValues;
+
+  private FormBody(List<String> encodedNames, List<String> encodedValues) {
+    this.encodedNames = Util.immutableList(encodedNames);
+    this.encodedValues = Util.immutableList(encodedValues);
+  }
+
+  /** The number of key-value pairs in this form-encoded body. */
+  public int size() {
+    return encodedNames.size();
+  }
+
+  public String encodedName(int index) {
+    return encodedNames.get(index);
+  }
+
+  public String name(int index) {
+    return percentDecode(encodedName(index), true);
+  }
+
+  public String encodedValue(int index) {
+    return encodedValues.get(index);
+  }
+
+  public String value(int index) {
+    return percentDecode(encodedValue(index), true);
+  }
+
+  @Override public MediaType contentType() {
+    return CONTENT_TYPE;
+  }
+
+  @Override public long contentLength() {
+    return writeOrCountBytes(null, true);
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    writeOrCountBytes(sink, false);
+  }
+
+  /**
+   * Either writes this request to {@code sink} or measures its content length. We have one method
+   * do double-duty to make sure the counting and content are consistent, particularly when it comes
+   * to awkward operations like measuring the encoded length of header strings, or the
+   * length-in-digits of an encoded integer.
+   */
+  private long writeOrCountBytes(BufferedSink sink, boolean countBytes) {
+    long byteCount = 0L;
+
+    Buffer buffer;
+    if (countBytes) {
+      buffer = new Buffer();
+    } else {
+      buffer = sink.buffer();
+    }
+
+    for (int i = 0, size = encodedNames.size(); i < size; i++) {
+      if (i > 0) buffer.writeByte('&');
+      buffer.writeUtf8(encodedNames.get(i));
+      buffer.writeByte('=');
+      buffer.writeUtf8(encodedValues.get(i));
+    }
+
+    if (countBytes) {
+      byteCount = buffer.size();
+      buffer.clear();
+    }
+
+    return byteCount;
+  }
+
+  public static final class Builder {
+    private final List<String> names = new ArrayList<>();
+    private final List<String> values = new ArrayList<>();
+
+    public Builder add(String name, String value) {
+      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true));
+      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true));
+      return this;
+    }
+
+    public Builder addEncoded(String name, String value) {
+      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true));
+      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true));
+      return this;
+    }
+
+    public FormBody build() {
+      return new FormBody(names, values);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Handshake.java b/okhttp/src/main/java/okhttp3/Handshake.java
similarity index 65%
rename from okhttp/src/main/java/com/squareup/okhttp/Handshake.java
rename to okhttp/src/main/java/okhttp3/Handshake.java
index d9f5366757..d2c08be57e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Handshake.java
+++ b/okhttp/src/main/java/okhttp3/Handshake.java
@@ -13,10 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package okhttp3;
 
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Util;
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
@@ -24,29 +22,37 @@
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSession;
+import okhttp3.internal.Util;
 
 /**
- * A record of a TLS handshake. For HTTPS clients, the client is <i>local</i>
- * and the remote server is its <i>peer</i>.
+ * A record of a TLS handshake. For HTTPS clients, the client is <i>local</i> and the remote server
+ * is its <i>peer</i>.
  *
- * <p>This value object describes a completed handshake. Use {@link
- * javax.net.ssl.SSLSocketFactory} to set policy for new handshakes.
+ * <p>This value object describes a completed handshake. Use {@link ConnectionSpec} to set policy
+ * for new handshakes.
  */
 public final class Handshake {
-  private final String cipherSuite;
+  private final TlsVersion tlsVersion;
+  private final CipherSuite cipherSuite;
   private final List<Certificate> peerCertificates;
   private final List<Certificate> localCertificates;
 
-  private Handshake(
-      String cipherSuite, List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+  private Handshake(TlsVersion tlsVersion, CipherSuite cipherSuite,
+      List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+    this.tlsVersion = tlsVersion;
     this.cipherSuite = cipherSuite;
     this.peerCertificates = peerCertificates;
     this.localCertificates = localCertificates;
   }
 
   public static Handshake get(SSLSession session) {
-    String cipherSuite = session.getCipherSuite();
-    if (cipherSuite == null) throw new IllegalStateException("cipherSuite == null");
+    String cipherSuiteString = session.getCipherSuite();
+    if (cipherSuiteString == null) throw new IllegalStateException("cipherSuite == null");
+    CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
+
+    String tlsVersionString = session.getProtocol();
+    if (tlsVersionString == null) throw new IllegalStateException("tlsVersion == null");
+    TlsVersion tlsVersion = TlsVersion.forJavaName(tlsVersionString);
 
     Certificate[] peerCertificates;
     try {
@@ -63,18 +69,26 @@ public static Handshake get(SSLSession session) {
         ? Util.immutableList(localCertificates)
         : Collections.<Certificate>emptyList();
 
-    return new Handshake(cipherSuite, peerCertificatesList, localCertificatesList);
+    return new Handshake(tlsVersion, cipherSuite, peerCertificatesList, localCertificatesList);
   }
 
-  public static Handshake get(
-      String cipherSuite, List<Certificate> peerCertificates, List<Certificate> localCertificates) {
-    if (cipherSuite == null) throw new IllegalArgumentException("cipherSuite == null");
-    return new Handshake(cipherSuite, Util.immutableList(peerCertificates),
+  public static Handshake get(TlsVersion tlsVersion, CipherSuite cipherSuite,
+      List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+    if (cipherSuite == null) throw new NullPointerException("cipherSuite == null");
+    return new Handshake(tlsVersion, cipherSuite, Util.immutableList(peerCertificates),
         Util.immutableList(localCertificates));
   }
 
-  /** Returns a cipher suite name like "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA". */
-  public String cipherSuite() {
+  /**
+   * Returns the TLS version used for this connection. May return null if the response was cached
+   * with a version of OkHttp prior to 3.0.
+   */
+  public TlsVersion tlsVersion() {
+    return tlsVersion;
+  }
+
+  /** Returns the cipher suite used for the connection. */
+  public CipherSuite cipherSuite() {
     return cipherSuite;
   }
 
@@ -105,13 +119,15 @@ public Principal localPrincipal() {
   @Override public boolean equals(Object other) {
     if (!(other instanceof Handshake)) return false;
     Handshake that = (Handshake) other;
-    return cipherSuite.equals(that.cipherSuite)
+    return Util.equal(cipherSuite, that.cipherSuite)
+        && cipherSuite.equals(that.cipherSuite)
         && peerCertificates.equals(that.peerCertificates)
         && localCertificates.equals(that.localCertificates);
   }
 
   @Override public int hashCode() {
     int result = 17;
+    result = 31 * result + (tlsVersion != null ? tlsVersion.hashCode() : 0);
     result = 31 * result + cipherSuite.hashCode();
     result = 31 * result + peerCertificates.hashCode();
     result = 31 * result + localCertificates.hashCode();
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
similarity index 74%
rename from okhttp/src/main/java/com/squareup/okhttp/Headers.java
rename to okhttp/src/main/java/okhttp3/Headers.java
index 0dca4281ec..5080883af7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -15,35 +15,36 @@
  *  limitations under the License.
  */
 
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.http.HttpDate;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
 import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpDate;
 
 /**
- * The header fields of a single HTTP message. Values are uninterpreted strings;
- * use {@code Request} and {@code Response} for interpreted headers. This class
- * maintains the order of the header fields within the HTTP message.
+ * The header fields of a single HTTP message. Values are uninterpreted strings; use {@code Request}
+ * and {@code Response} for interpreted headers. This class maintains the order of the header fields
+ * within the HTTP message.
  *
- * <p>This class tracks header values line-by-line. A field with multiple comma-
- * separated values on the same line will be treated as a field with a single
- * value by this class. It is the caller's responsibility to detect and split
- * on commas if their field permits multiple values. This simplifies use of
- * single-valued fields whose values routinely contain commas, such as cookies
- * or dates.
+ * <p>This class tracks header values line-by-line. A field with multiple comma- separated values on
+ * the same line will be treated as a field with a single value by this class. It is the caller's
+ * responsibility to detect and split on commas if their field permits multiple values. This
+ * simplifies use of single-valued fields whose values routinely contain commas, such as cookies or
+ * dates.
  *
- * <p>This class trims whitespace from values. It never returns values with
- * leading or trailing whitespace.
+ * <p>This class trims whitespace from values. It never returns values with leading or trailing
+ * whitespace.
  *
- * <p>Instances of this class are immutable. Use {@link Builder} to create
- * instances.
+ * <p>Instances of this class are immutable. Use {@link Builder} to create instances.
  */
 public final class Headers {
   private final String[] namesAndValues;
@@ -62,9 +63,8 @@ public String get(String name) {
   }
 
   /**
-   * Returns the last value corresponding to the specified field parsed as an
-   * HTTP date, or null if either the field is absent or cannot be parsed as a
-   * date.
+   * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
+   * either the field is absent or cannot be parsed as a date.
    */
   public Date getDate(String name) {
     String value = get(name);
@@ -76,22 +76,14 @@ public int size() {
     return namesAndValues.length / 2;
   }
 
-  /** Returns the field at {@code position} or null if that is out of range. */
+  /** Returns the field at {@code position}. */
   public String name(int index) {
-    int nameIndex = index * 2;
-    if (nameIndex < 0 || nameIndex >= namesAndValues.length) {
-      return null;
-    }
-    return namesAndValues[nameIndex];
+    return namesAndValues[index * 2];
   }
 
-  /** Returns the value at {@code index} or null if that is out of range. */
+  /** Returns the value at {@code index}. */
   public String value(int index) {
-    int valueIndex = index * 2 + 1;
-    if (valueIndex < 0 || valueIndex >= namesAndValues.length) {
-      return null;
-    }
-    return namesAndValues[valueIndex];
+    return namesAndValues[index * 2 + 1];
   }
 
   /** Returns an immutable case-insensitive set of header names. */
@@ -123,6 +115,41 @@ public Builder newBuilder() {
     return result;
   }
 
+  /**
+   * Returns true if {@code other} is a {@code Headers} object with the same headers, with the same
+   * casing, in the same order. Note that two headers instances may be <i>semantically</i> equal
+   * but not equal according to this method. In particular, none of the following sets of headers
+   * are equal according to this method: <pre>   {@code
+   *
+   *   1. Original
+   *   Content-Type: text/html
+   *   Content-Length: 50
+   *
+   *   2. Different order
+   *   Content-Length: 50
+   *   Content-Type: text/html
+   *
+   *   3. Different case
+   *   content-type: text/html
+   *   content-length: 50
+   *
+   *   4. Different values
+   *   Content-Type: text/html
+   *   Content-Length: 050
+   * }</pre>
+   *
+   * Applications that require semantically equal headers should convert them into a canonical form
+   * before comparing them for equality.
+   */
+  @Override public boolean equals(Object other) {
+    return other instanceof Headers
+        && Arrays.equals(((Headers) other).namesAndValues, namesAndValues);
+  }
+
+  @Override public int hashCode() {
+    return Arrays.hashCode(namesAndValues);
+  }
+
   @Override public String toString() {
     StringBuilder result = new StringBuilder();
     for (int i = 0, size = size(); i < size; i++) {
@@ -132,9 +159,9 @@ public Builder newBuilder() {
   }
 
   public Map<String, List<String>> toMultimap() {
-    Map<String, List<String>> result = new LinkedHashMap<String, List<String>>();
+    Map<String, List<String>> result = new LinkedHashMap<>();
     for (int i = 0, size = size(); i < size; i++) {
-      String name = name(i);
+      String name = name(i).toLowerCase(Locale.US);
       List<String> values = result.get(name);
       if (values == null) {
         values = new ArrayList<>(2);
@@ -155,12 +182,12 @@ private static String get(String[] namesAndValues, String name) {
   }
 
   /**
-   * Returns headers for the alternating header names and values. There must be
-   * an even number of arguments, and they must alternate between header names
-   * and values.
+   * Returns headers for the alternating header names and values. There must be an even number of
+   * arguments, and they must alternate between header names and values.
    */
   public static Headers of(String... namesAndValues) {
-    if (namesAndValues == null || namesAndValues.length % 2 != 0) {
+    if (namesAndValues == null) throw new NullPointerException("namesAndValues == null");
+    if (namesAndValues.length % 2 != 0) {
       throw new IllegalArgumentException("Expected alternating header names and values");
     }
 
@@ -187,9 +214,7 @@ public static Headers of(String... namesAndValues) {
    * Returns headers for the header names and values in the {@link Map}.
    */
   public static Headers of(Map<String, String> headers) {
-    if (headers == null) {
-      throw new IllegalArgumentException("Expected map with header names and values");
-    }
+    if (headers == null) throw new NullPointerException("headers == null");
 
     // Make a defensive copy and clean it up.
     String[] namesAndValues = new String[headers.size() * 2];
@@ -247,8 +272,8 @@ public Builder add(String name, String value) {
     }
 
     /**
-     * Add a field with the specified value without any validation. Only
-     * appropriate for headers from the remote peer or cache.
+     * Add a field with the specified value without any validation. Only appropriate for headers
+     * from the remote peer or cache.
      */
     Builder addLenient(String name, String value) {
       namesAndValues.add(name);
@@ -268,8 +293,8 @@ public Builder removeAll(String name) {
     }
 
     /**
-     * Set a field with the specified value. If the field is not found, it is
-     * added. If the field is found, the existing values are replaced.
+     * Set a field with the specified value. If the field is not found, it is added. If the field is
+     * found, the existing values are replaced.
      */
     public Builder set(String name, String value) {
       checkNameAndValue(name, value);
@@ -279,21 +304,21 @@ public Builder set(String name, String value) {
     }
 
     private void checkNameAndValue(String name, String value) {
-      if (name == null) throw new IllegalArgumentException("name == null");
+      if (name == null) throw new NullPointerException("name == null");
       if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
       for (int i = 0, length = name.length(); i < length; i++) {
         char c = name.charAt(i);
         if (c <= '\u001f' || c >= '\u007f') {
-          throw new IllegalArgumentException(String.format(
+          throw new IllegalArgumentException(Util.format(
               "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
         }
       }
-      if (value == null) throw new IllegalArgumentException("value == null");
+      if (value == null) throw new NullPointerException("value == null");
       for (int i = 0, length = value.length(); i < length; i++) {
         char c = value.charAt(i);
         if (c <= '\u001f' || c >= '\u007f') {
-          throw new IllegalArgumentException(String.format(
-              "Unexpected char %#04x at %d in header value: %s", (int) c, i, value));
+          throw new IllegalArgumentException(Util.format(
+              "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
         }
       }
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
similarity index 74%
rename from okhttp/src/main/java/com/squareup/okhttp/HttpUrl.java
rename to okhttp/src/main/java/okhttp3/HttpUrl.java
index dc8c7f2e08..45effb8f6d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -13,9 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import java.net.IDN;
 import java.net.InetAddress;
 import java.net.MalformedURLException;
 import java.net.URI;
@@ -27,10 +26,14 @@
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Locale;
 import java.util.Set;
 import okio.Buffer;
 
+import static okhttp3.internal.Util.delimiterOffset;
+import static okhttp3.internal.Util.domainToAscii;
+import static okhttp3.internal.Util.skipLeadingAsciiWhitespace;
+import static okhttp3.internal.Util.skipTrailingAsciiWhitespace;
+
 /**
  * A uniform resource locator (URL) with a scheme of either {@code http} or {@code https}. Use this
  * class to compose and decompose Internet addresses. For example, this code will compose and print
@@ -84,58 +87,67 @@
  * A URL has several components.
  *
  * <h4>Scheme</h4>
- * Sometimes referred to as <i>protocol</i>, A URL's scheme describes what mechanism should be used
- * to retrieve the resource. Although URLs have many schemes ({@code mailto}, {@code file}, {@code
- * ftp}), this class only supports {@code http} and {@code https}. Use {@link URI java.net.URI} for
- * URLs with arbitrary schemes.
+ *
+ * <p>Sometimes referred to as <i>protocol</i>, A URL's scheme describes what mechanism should be
+ * used to retrieve the resource. Although URLs have many schemes ({@code mailto}, {@code file},
+ * {@code ftp}), this class only supports {@code http} and {@code https}. Use {@link URI
+ * java.net.URI} for URLs with arbitrary schemes.
  *
  * <h4>Username and Password</h4>
- * Username and password are either present, or the empty string {@code ""} if absent. This class
+ *
+ * <p>Username and password are either present, or the empty string {@code ""} if absent. This class
  * offers no mechanism to differentiate empty from absent. Neither of these components are popular
  * in practice. Typically HTTP applications use other mechanisms for user identification and
  * authentication.
  *
  * <h4>Host</h4>
- * The host identifies the webserver that serves the URL's resource. It is either a hostname like
+ *
+ * <p>The host identifies the webserver that serves the URL's resource. It is either a hostname like
  * {@code square.com} or {@code localhost}, an IPv4 address like {@code 192.168.0.1}, or an IPv6
  * address like {@code ::1}.
  *
  * <p>Usually a webserver is reachable with multiple identifiers: its IP addresses, registered
  * domain names, and even {@code localhost} when connecting from the server itself. Each of a
- * webserver's names is a distinct URL and they are not interchangeable. For example, even if
- * {@code http://square.github.io/dagger} and {@code http://google.github.io/dagger} are served by
- * the same IP address, the two URLs identify different resources.
+ * webserver's names is a distinct URL and they are not interchangeable. For example, even if {@code
+ * http://square.github.io/dagger} and {@code http://google.github.io/dagger} are served by the same
+ * IP address, the two URLs identify different resources.
  *
  * <h4>Port</h4>
- * The port used to connect to the webserver. By default this is 80 for HTTP and 443 for HTTPS. This
- * class never returns -1 for the port: if no port is explicitly specified in the URL then the
+ *
+ * <p>The port used to connect to the webserver. By default this is 80 for HTTP and 443 for HTTPS.
+ * This class never returns -1 for the port: if no port is explicitly specified in the URL then the
  * scheme's default is used.
  *
  * <h4>Path</h4>
- * The path identifies a specific resource on the host. Paths have a hierarchical structure like
+ *
+ * <p>The path identifies a specific resource on the host. Paths have a hierarchical structure like
  * "/square/okhttp/issues/1486". Each path segment is prefixed with "/". This class offers methods
  * to compose and decompose paths by segment. If a path's last segment is the empty string, then the
  * path ends with "/". This class always builds non-empty paths: if the path is omitted it defaults
  * to "/", which is a path whose only segment is the empty string.
  *
  * <h4>Query</h4>
- * The query is optional: it can be null, empty, or non-empty. For many HTTP URLs the query string
- * is subdivided into a collection of name-value parameters. This class offers methods to set the
- * query as the single string, or as individual name-value parameters. With name-value parameters
- * the values are optional and names may be repeated.
+ *
+ * <p>The query is optional: it can be null, empty, or non-empty. For many HTTP URLs the query
+ * string is subdivided into a collection of name-value parameters. This class offers methods to set
+ * the query as the single string, or as individual name-value parameters. With name-value
+ * parameters the values are optional and names may be repeated.
  *
  * <h4>Fragment</h4>
- * The fragment is optional: it can be null, empty, or non-empty. Unlike host, port, path, and query
- * the fragment is not sent to the webserver: it's private to the client.
+ *
+ * <p>The fragment is optional: it can be null, empty, or non-empty. Unlike host, port, path, and
+ * query the fragment is not sent to the webserver: it's private to the client.
  *
  * <h3>Encoding</h3>
- * Each component must be encoded before it is embedded in the complete URL. As we saw above, the
+ *
+ * <p>Each component must be encoded before it is embedded in the complete URL. As we saw above, the
  * string {@code cute #puppies} is encoded as {@code cute%20%23puppies} when used as a query
  * parameter value.
  *
  * <h4>Percent encoding</h4>
- * Percent encoding replaces a character (like {@code \ud83c\udf69}) with its UTF-8 hex bytes (like
- * {@code %F0%9F%8D%A9}). This approach works for whitespace characters, control characters,
+ *
+ * <p>Percent encoding replaces a character (like {@code \ud83c\udf69}) with its UTF-8 hex bytes
+ * (like {@code %F0%9F%8D%A9}). This approach works for whitespace characters, control characters,
  * non-ASCII characters, and characters that already have another meaning in a particular context.
  *
  * <p>Percent encoding is used in every URL component except for the hostname. But the set of
@@ -161,11 +173,12 @@
  * the offending characters.
  *
  * <h4>IDNA Mapping and Punycode encoding</h4>
- * Hostnames have different requirements and use a different encoding scheme. It consists of IDNA
+ *
+ * <p>Hostnames have different requirements and use a different encoding scheme. It consists of IDNA
  * mapping and Punycode encoding.
  *
- * <p>In order to avoid confusion and discourage phishing attacks,
- * <a href="http://www.unicode.org/reports/tr46/#ToASCII">IDNA Mapping</a> transforms names to avoid
+ * <p>In order to avoid confusion and discourage phishing attacks, <a
+ * href="http://www.unicode.org/reports/tr46/#ToASCII">IDNA Mapping</a> transforms names to avoid
  * confusing characters. This includes basic case folding: transforming shouting {@code SQUARE.COM}
  * into cool and casual {@code square.com}. It also handles more exotic characters. For example, the
  * Unicode trademark sign (™) could be confused for the letters "TM" in {@code http://ho™mail.com}.
@@ -174,21 +187,25 @@
  * not mapped and cannot be used in a hostname.
  *
  * <p><a href="http://ietf.org/rfc/rfc3492.txt">Punycode</a> converts a Unicode string to an ASCII
- * string to make international domain names work everywhere. For example, "σ" encodes as
- * "xn--4xa". The encoded string is not human readable, but can be used with classes like {@link
- * InetAddress} to establish connections.
+ * string to make international domain names work everywhere. For example, "σ" encodes as "xn--4xa".
+ * The encoded string is not human readable, but can be used with classes like {@link InetAddress}
+ * to establish connections.
  *
  * <h3>Why another URL model?</h3>
- * Java includes both {@link URL java.net.URL} and {@link URI java.net.URI}. We offer a new URL
+ *
+ * <p>Java includes both {@link URL java.net.URL} and {@link URI java.net.URI}. We offer a new URL
  * model to address problems that the others don't.
  *
  * <h4>Different URLs should be different</h4>
- * Although they have different content, {@code java.net.URL} considers the following two URLs
+ *
+ * <p>Although they have different content, {@code java.net.URL} considers the following two URLs
  * equal, and the {@link Object#equals equals()} method between them returns true:
+ *
  * <ul>
  *   <li>http://square.github.io/
  *   <li>http://google.github.io/
  * </ul>
+ *
  * This is because those two hosts share the same IP address. This is an old, bad design decision
  * that makes {@code java.net.URL} unusable for many things. It shouldn't be used as a {@link
  * java.util.Map Map} key or in a {@link Set}. Doing so is both inefficient because equality may
@@ -196,11 +213,14 @@
  * hosted.
  *
  * <h4>Equal URLs should be equal</h4>
- * These two URLs are semantically identical, but {@code java.net.URI} disagrees:
+ *
+ * <p>These two URLs are semantically identical, but {@code java.net.URI} disagrees:
+ *
  * <ul>
  *   <li>http://host:80/
  *   <li>http://host
  * </ul>
+ *
  * Both the unnecessary port specification ({@code :80}) and the absent trailing slash ({@code /})
  * cause URI to bucket the two URLs separately. This harms URI's usefulness in collections. Any
  * application that stores information-per-URL will need to either canonicalize manually, or suffer
@@ -226,21 +246,24 @@
  * }</pre>
  *
  * <h4>If it works on the web, it should work in your application</h4>
- * The {@code java.net.URI} class is strict around what URLs it accepts. It rejects URLs like
+ *
+ * <p>The {@code java.net.URI} class is strict around what URLs it accepts. It rejects URLs like
  * "http://example.com/abc|def" because the '|' character is unsupported. This class is more
  * forgiving: it will automatically percent-encode the '|', yielding "http://example.com/abc%7Cdef".
  * This kind behavior is consistent with web browsers. {@code HttpUrl} prefers consistency with
  * major web browsers over consistency with obsolete specifications.
  *
  * <h4>Paths and Queries should decompose</h4>
- * Neither of the built-in URL models offer direct access to path segments or query parameters.
+ *
+ * <p>Neither of the built-in URL models offer direct access to path segments or query parameters.
  * Manually using {@code StringBuilder} to assemble these components is cumbersome: do '+'
  * characters get silently replaced with spaces? If a query parameter contains a '&amp;', does that
  * get escaped? By offering methods to read and write individual query parameters directly,
  * application developers are saved from the hassles of encoding and decoding.
  *
  * <h4>Plus a modern API</h4>
- * The URL (JDK1.0) and URI (Java 1.4) classes predate builders and instead use telescoping
+ *
+ * <p>The URL (JDK1.0) and URI (Java 1.4) classes predate builders and instead use telescoping
  * constructors. For example, there's no API to compose a URI with a custom port without also
  * providing a query and fragment.
  *
@@ -254,14 +277,17 @@
  */
 public final class HttpUrl {
   private static final char[] HEX_DIGITS =
-      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
+      {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
   static final String USERNAME_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
   static final String PASSWORD_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
   static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
+  static final String PATH_SEGMENT_ENCODE_SET_URI = "[]";
   static final String QUERY_ENCODE_SET = " \"'<>#";
   static final String QUERY_COMPONENT_ENCODE_SET = " \"'<>#&=";
+  static final String QUERY_COMPONENT_ENCODE_SET_URI = "\\^`{|}";
   static final String FORM_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#&!$(),~";
   static final String FRAGMENT_ENCODE_SET = "";
+  static final String FRAGMENT_ENCODE_SET_URI = " \"#<>\\^`{|}";
 
   /** Either "http" or "https". */
   private final String scheme;
@@ -279,9 +305,9 @@
   private final int port;
 
   /**
-   * A list of canonical path segments. This list always contains at least one element, which may
-   * be the empty string. Each segment is formatted with a leading '/', so if path segments were
-   * ["a", "b", ""], then the encoded path would be "/a/b/".
+   * A list of canonical path segments. This list always contains at least one element, which may be
+   * the empty string. Each segment is formatted with a leading '/', so if path segments were ["a",
+   * "b", ""], then the encoded path would be "/a/b/".
    */
   private final List<String> pathSegments;
 
@@ -300,16 +326,16 @@
 
   private HttpUrl(Builder builder) {
     this.scheme = builder.scheme;
-    this.username = percentDecode(builder.encodedUsername);
-    this.password = percentDecode(builder.encodedPassword);
+    this.username = percentDecode(builder.encodedUsername, false);
+    this.password = percentDecode(builder.encodedPassword, false);
     this.host = builder.host;
     this.port = builder.effectivePort();
-    this.pathSegments = percentDecode(builder.encodedPathSegments);
+    this.pathSegments = percentDecode(builder.encodedPathSegments, false);
     this.queryNamesAndValues = builder.encodedQueryNamesAndValues != null
-        ? percentDecode(builder.encodedQueryNamesAndValues)
+        ? percentDecode(builder.encodedQueryNamesAndValues, true)
         : null;
     this.fragment = builder.encodedFragment != null
-        ? percentDecode(builder.encodedFragment)
+        ? percentDecode(builder.encodedFragment, false)
         : null;
     this.url = builder.toString();
   }
@@ -324,16 +350,30 @@ public URL url() {
   }
 
   /**
-   * Attempt to convert this URL to a {@link URI java.net.URI}. This method throws an unchecked
-   * {@link IllegalStateException} if the URL it holds isn't valid by URI's overly-stringent
-   * standard. For example, URI rejects paths containing the '[' character. Consult that class for
-   * the exact rules of what URLs are permitted.
+   * Returns this URL as a {@link URI java.net.URI}. Because {@code URI} is more strict than this
+   * class, the returned URI may be semantically different from this URL:
+   *
+   * <ul>
+   *     <li>Characters forbidden by URI like {@code [} and {@code |} will be escaped.
+   *     <li>Invalid percent-encoded sequences like {@code %xx} will be encoded like {@code %25xx}.
+   *     <li>Whitespace and control characters in the fragment will be stripped.
+   * </ul>
+   *
+   * <p>These differences may have a significant consequence when the URI is interpretted by a
+   * webserver. For this reason the {@linkplain URI URI class} and this method should be avoided.
    */
   public URI uri() {
+    String uri = newBuilder().reencodeForUri().toString();
     try {
-      return new URI(url);
+      return new URI(uri);
     } catch (URISyntaxException e) {
-      throw new IllegalStateException("not valid as a java.net.URI: " + url);
+      // Unlikely edge case: the URI has a forbidden character in the fragment. Strip it & retry.
+      try {
+        String stripped = uri.replaceAll("[\\u0000-\\u001F\\u007F-\\u009F\\p{javaWhitespace}]", "");
+        return URI.create(stripped);
+      } catch (Exception e1) {
+        throw new RuntimeException(e); // Unexpected!
+      }
     }
   }
 
@@ -374,6 +414,7 @@ public String password() {
   /**
    * Returns the host address suitable for use with {@link InetAddress#getAllByName(String)}. May
    * be:
+   *
    * <ul>
    *   <li>A regular host name, like {@code android.com}.
    *   <li>An IPv4 address, like {@code 127.0.0.1}.
@@ -413,8 +454,8 @@ public int pathSize() {
   }
 
   /**
-   * Returns the entire path of this URL, encoded for use in HTTP resource resolution. The
-   * returned path is always nonempty and is prefixed with {@code /}.
+   * Returns the entire path of this URL, encoded for use in HTTP resource resolution. The returned
+   * path is always nonempty and is prefixed with {@code /}.
    */
   public String encodedPath() {
     int pathStart = url.indexOf('/', scheme.length() + 3); // "://".length() == 3.
@@ -435,7 +476,7 @@ static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
     List<String> result = new ArrayList<>();
     for (int i = pathStart; i < pathEnd; ) {
       i++; // Skip the '/'.
-      int segmentEnd = delimiterOffset(url, i, pathEnd, "/");
+      int segmentEnd = delimiterOffset(url, i, pathEnd, '/');
       result.add(url.substring(i, segmentEnd));
       i = segmentEnd;
     }
@@ -454,7 +495,7 @@ static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
   public String encodedQuery() {
     if (queryNamesAndValues == null) return null; // No query.
     int queryStart = url.indexOf('?') + 1;
-    int queryEnd = delimiterOffset(url, queryStart + 1, url.length(), "#");
+    int queryEnd = delimiterOffset(url, queryStart + 1, url.length(), '#');
     return url.substring(queryStart, queryEnd);
   }
 
@@ -472,10 +513,10 @@ static void namesAndValuesToQueryString(StringBuilder out, List<String> namesAnd
   }
 
   /**
-   * Cuts {@code encodedQuery} up into alternating parameter names and values. This divides a
-   * query string like {@code subject=math&easy&problem=5-2=3} into the list {@code ["subject",
-   * "math", "easy", null, "problem", "5-2=3"]}. Note that values may be null and may contain
-   * '=' characters.
+   * Cuts {@code encodedQuery} up into alternating parameter names and values. This divides a query
+   * string like {@code subject=math&easy&problem=5-2=3} into the list {@code ["subject", "math",
+   * "easy", null, "problem", "5-2=3"]}. Note that values may be null and may contain '='
+   * characters.
    */
   static List<String> queryStringToNamesAndValues(String encodedQuery) {
     List<String> result = new ArrayList<>();
@@ -559,9 +600,13 @@ public String fragment() {
     return fragment;
   }
 
-  /** Returns the URL that would be retrieved by following {@code link} from this URL. */
+  /**
+   * Returns the URL that would be retrieved by following {@code link} from this URL, or null if
+   * the resulting URL is not well-formed.
+   */
   public HttpUrl resolve(String link) {
-    return new Builder().parse(this, link);
+    Builder builder = newBuilder(link);
+    return builder != null ? builder.build() : null;
   }
 
   public Builder newBuilder() {
@@ -570,12 +615,8 @@ public Builder newBuilder() {
     result.encodedUsername = encodedUsername();
     result.encodedPassword = encodedPassword();
     result.host = host;
-    // If we're set to a default port, unset it, in case of a scheme change.
-    if (port == defaultPort(scheme)) {
-      result.port = -1;
-    } else {
-      result.port = port;
-    }
+    // If we're set to a default port, unset it in case of a scheme change.
+    result.port = port != defaultPort(scheme) ? port : -1;
     result.encodedPathSegments.clear();
     result.encodedPathSegments.addAll(encodedPathSegments());
     result.encodedQuery(encodedQuery());
@@ -584,11 +625,23 @@ public Builder newBuilder() {
   }
 
   /**
-   * Returns a new {@code OkUrl} representing {@code url} if it is a well-formed HTTP or HTTPS URL,
-   * or null if it isn't.
+   * Returns a builder for the URL that would be retrieved by following {@code link} from this URL,
+   * or null if the resulting URL is not well-formed.
+   */
+  public Builder newBuilder(String link) {
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(this, link);
+    return result == Builder.ParseResult.SUCCESS ? builder : null;
+  }
+
+  /**
+   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
+   * URL, or null if it isn't.
    */
   public static HttpUrl parse(String url) {
-    return new Builder().parse(null, url);
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(null, url);
+    return result == Builder.ParseResult.SUCCESS ? builder.build() : null;
   }
 
   /**
@@ -599,6 +652,29 @@ public static HttpUrl get(URL url) {
     return parse(url.toString());
   }
 
+  /**
+   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
+   * URL, or throws an exception if it isn't.
+   *
+   * @throws MalformedURLException if there was a non-host related URL issue
+   * @throws UnknownHostException if the host was invalid
+   */
+  static HttpUrl getChecked(String url) throws MalformedURLException, UnknownHostException {
+    Builder builder = new Builder();
+    Builder.ParseResult result = builder.parse(null, url);
+    switch (result) {
+      case SUCCESS:
+        return builder.build();
+      case INVALID_HOST:
+        throw new UnknownHostException("Invalid host: " + url);
+      case UNSUPPORTED_SCHEME:
+      case MISSING_SCHEME:
+      case INVALID_PORT:
+      default:
+        throw new MalformedURLException("Invalid URL: " + result + " for " + url);
+    }
+  }
+
   public static HttpUrl get(URI uri) {
     return parse(uri.toString());
   }
@@ -631,7 +707,7 @@ public Builder() {
 
     public Builder scheme(String scheme) {
       if (scheme == null) {
-        throw new IllegalArgumentException("scheme == null");
+        throw new NullPointerException("scheme == null");
       } else if (scheme.equalsIgnoreCase("http")) {
         this.scheme = "http";
       } else if (scheme.equalsIgnoreCase("https")) {
@@ -643,35 +719,37 @@ public Builder scheme(String scheme) {
     }
 
     public Builder username(String username) {
-      if (username == null) throw new IllegalArgumentException("username == null");
-      this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, false, false);
+      if (username == null) throw new NullPointerException("username == null");
+      this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, false, false, false, true);
       return this;
     }
 
     public Builder encodedUsername(String encodedUsername) {
-      if (encodedUsername == null) throw new IllegalArgumentException("encodedUsername == null");
-      this.encodedUsername = canonicalize(encodedUsername, USERNAME_ENCODE_SET, true, false);
+      if (encodedUsername == null) throw new NullPointerException("encodedUsername == null");
+      this.encodedUsername = canonicalize(
+          encodedUsername, USERNAME_ENCODE_SET, true, false, false, true);
       return this;
     }
 
     public Builder password(String password) {
-      if (password == null) throw new IllegalArgumentException("password == null");
-      this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, false, false);
+      if (password == null) throw new NullPointerException("password == null");
+      this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, false, false, false, true);
       return this;
     }
 
     public Builder encodedPassword(String encodedPassword) {
-      if (encodedPassword == null) throw new IllegalArgumentException("encodedPassword == null");
-      this.encodedPassword = canonicalize(encodedPassword, PASSWORD_ENCODE_SET, true, false);
+      if (encodedPassword == null) throw new NullPointerException("encodedPassword == null");
+      this.encodedPassword = canonicalize(
+          encodedPassword, PASSWORD_ENCODE_SET, true, false, false, true);
       return this;
     }
 
     /**
      * @param host either a regular hostname, International Domain Name, IPv4 address, or IPv6
-     *     address.
+     * address.
      */
     public Builder host(String host) {
-      if (host == null) throw new IllegalArgumentException("host == null");
+      if (host == null) throw new NullPointerException("host == null");
       String encoded = canonicalizeHost(host, 0, host.length());
       if (encoded == null) throw new IllegalArgumentException("unexpected host: " + host);
       this.host = encoded;
@@ -689,23 +767,55 @@ int effectivePort() {
     }
 
     public Builder addPathSegment(String pathSegment) {
-      if (pathSegment == null) throw new IllegalArgumentException("pathSegment == null");
+      if (pathSegment == null) throw new NullPointerException("pathSegment == null");
       push(pathSegment, 0, pathSegment.length(), false, false);
       return this;
     }
 
+    /**
+     * Adds a set of path segments separated by a slash (either {@code \} or {@code /}). If
+     * {@code pathSegments} starts with a slash, the resulting URL will have empty path segment.
+     */
+    public Builder addPathSegments(String pathSegments) {
+      if (pathSegments == null) throw new NullPointerException("pathSegments == null");
+      return addPathSegments(pathSegments, false);
+    }
+
     public Builder addEncodedPathSegment(String encodedPathSegment) {
       if (encodedPathSegment == null) {
-        throw new IllegalArgumentException("encodedPathSegment == null");
+        throw new NullPointerException("encodedPathSegment == null");
       }
       push(encodedPathSegment, 0, encodedPathSegment.length(), false, true);
       return this;
     }
 
+    /**
+     * Adds a set of encoded path segments separated by a slash (either {@code \} or {@code /}). If
+     * {@code encodedPathSegments} starts with a slash, the resulting URL will have empty path
+     * segment.
+     */
+    public Builder addEncodedPathSegments(String encodedPathSegments) {
+      if (encodedPathSegments == null) {
+        throw new NullPointerException("encodedPathSegments == null");
+      }
+      return addPathSegments(encodedPathSegments, true);
+    }
+
+    private Builder addPathSegments(String pathSegments, boolean alreadyEncoded) {
+      int offset = 0;
+      do {
+        int segmentEnd = delimiterOffset(pathSegments, offset, pathSegments.length(), "/\\");
+        boolean addTrailingSlash = segmentEnd < pathSegments.length();
+        push(pathSegments, offset, segmentEnd, addTrailingSlash, alreadyEncoded);
+        offset = segmentEnd + 1;
+      } while (offset <= pathSegments.length());
+      return this;
+    }
+
     public Builder setPathSegment(int index, String pathSegment) {
-      if (pathSegment == null) throw new IllegalArgumentException("pathSegment == null");
+      if (pathSegment == null) throw new NullPointerException("pathSegment == null");
       String canonicalPathSegment = canonicalize(
-          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false);
+          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false, false, true);
       if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
         throw new IllegalArgumentException("unexpected path segment: " + pathSegment);
       }
@@ -715,10 +825,10 @@ public Builder setPathSegment(int index, String pathSegment) {
 
     public Builder setEncodedPathSegment(int index, String encodedPathSegment) {
       if (encodedPathSegment == null) {
-        throw new IllegalArgumentException("encodedPathSegment == null");
+        throw new NullPointerException("encodedPathSegment == null");
       }
       String canonicalPathSegment = canonicalize(encodedPathSegment,
-          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false);
+          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false, false, true);
       encodedPathSegments.set(index, canonicalPathSegment);
       if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
         throw new IllegalArgumentException("unexpected path segment: " + encodedPathSegment);
@@ -735,7 +845,7 @@ public Builder removePathSegment(int index) {
     }
 
     public Builder encodedPath(String encodedPath) {
-      if (encodedPath == null) throw new IllegalArgumentException("encodedPath == null");
+      if (encodedPath == null) throw new NullPointerException("encodedPath == null");
       if (!encodedPath.startsWith("/")) {
         throw new IllegalArgumentException("unexpected encodedPath: " + encodedPath);
       }
@@ -745,37 +855,40 @@ public Builder encodedPath(String encodedPath) {
 
     public Builder query(String query) {
       this.encodedQueryNamesAndValues = query != null
-          ? queryStringToNamesAndValues(canonicalize(query, QUERY_ENCODE_SET, false, true))
+          ? queryStringToNamesAndValues(canonicalize(
+          query, QUERY_ENCODE_SET, false, false, true, true))
           : null;
       return this;
     }
 
     public Builder encodedQuery(String encodedQuery) {
       this.encodedQueryNamesAndValues = encodedQuery != null
-          ? queryStringToNamesAndValues(canonicalize(encodedQuery, QUERY_ENCODE_SET, true, true))
+          ? queryStringToNamesAndValues(
+          canonicalize(encodedQuery, QUERY_ENCODE_SET, true, false, true, true))
           : null;
       return this;
     }
 
     /** Encodes the query parameter using UTF-8 and adds it to this URL's query string. */
     public Builder addQueryParameter(String name, String value) {
-      if (name == null) throw new IllegalArgumentException("name == null");
+      if (name == null) throw new NullPointerException("name == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
-      encodedQueryNamesAndValues.add(canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, true));
+      encodedQueryNamesAndValues.add(
+          canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true));
       encodedQueryNamesAndValues.add(value != null
-          ? canonicalize(value, QUERY_COMPONENT_ENCODE_SET, false, true)
+          ? canonicalize(value, QUERY_COMPONENT_ENCODE_SET, false, false, true, true)
           : null);
       return this;
     }
 
     /** Adds the pre-encoded query parameter to this URL's query string. */
     public Builder addEncodedQueryParameter(String encodedName, String encodedValue) {
-      if (encodedName == null) throw new IllegalArgumentException("encodedName == null");
+      if (encodedName == null) throw new NullPointerException("encodedName == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
-          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, true));
+          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
       encodedQueryNamesAndValues.add(encodedValue != null
-          ? canonicalize(encodedValue, QUERY_COMPONENT_ENCODE_SET, true, true)
+          ? canonicalize(encodedValue, QUERY_COMPONENT_ENCODE_SET, true, false, true, true)
           : null);
       return this;
     }
@@ -793,18 +906,19 @@ public Builder setEncodedQueryParameter(String encodedName, String encodedValue)
     }
 
     public Builder removeAllQueryParameters(String name) {
-      if (name == null) throw new IllegalArgumentException("name == null");
+      if (name == null) throw new NullPointerException("name == null");
       if (encodedQueryNamesAndValues == null) return this;
-      String nameToRemove = canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, true);
+      String nameToRemove = canonicalize(
+          name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true);
       removeAllCanonicalQueryParameters(nameToRemove);
       return this;
     }
 
     public Builder removeAllEncodedQueryParameters(String encodedName) {
-      if (encodedName == null) throw new IllegalArgumentException("encodedName == null");
+      if (encodedName == null) throw new NullPointerException("encodedName == null");
       if (encodedQueryNamesAndValues == null) return this;
       removeAllCanonicalQueryParameters(
-          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, true));
+          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
       return this;
     }
 
@@ -822,14 +936,42 @@ private void removeAllCanonicalQueryParameters(String canonicalName) {
     }
 
     public Builder fragment(String fragment) {
-      if (fragment == null) throw new IllegalArgumentException("fragment == null");
-      this.encodedFragment = canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false);
+      this.encodedFragment = fragment != null
+          ? canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false, false, false)
+          : null;
       return this;
     }
 
     public Builder encodedFragment(String encodedFragment) {
-      if (encodedFragment == null) throw new IllegalArgumentException("encodedFragment == null");
-      this.encodedFragment = canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false);
+      this.encodedFragment = encodedFragment != null
+          ? canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false, false, false)
+          : null;
+      return this;
+    }
+
+    /**
+     * Re-encodes the components of this URL so that it satisfies (obsolete) RFC 2396, which is
+     * particularly strict for certain components.
+     */
+    Builder reencodeForUri() {
+      for (int i = 0, size = encodedPathSegments.size(); i < size; i++) {
+        String pathSegment = encodedPathSegments.get(i);
+        encodedPathSegments.set(i,
+            canonicalize(pathSegment, PATH_SEGMENT_ENCODE_SET_URI, true, true, false, true));
+      }
+      if (encodedQueryNamesAndValues != null) {
+        for (int i = 0, size = encodedQueryNamesAndValues.size(); i < size; i++) {
+          String component = encodedQueryNamesAndValues.get(i);
+          if (component != null) {
+            encodedQueryNamesAndValues.set(i,
+                canonicalize(component, QUERY_COMPONENT_ENCODE_SET_URI, true, true, true, true));
+          }
+        }
+      }
+      if (encodedFragment != null) {
+        encodedFragment = canonicalize(
+            encodedFragment, FRAGMENT_ENCODE_SET_URI, true, true, false, false);
+      }
       return this;
     }
 
@@ -883,7 +1025,15 @@ public HttpUrl build() {
       return result.toString();
     }
 
-    HttpUrl parse(HttpUrl base, String input) {
+    enum ParseResult {
+      SUCCESS,
+      MISSING_SCHEME,
+      UNSUPPORTED_SCHEME,
+      INVALID_PORT,
+      INVALID_HOST,
+    }
+
+    ParseResult parse(HttpUrl base, String input) {
       int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
       int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
 
@@ -897,12 +1047,12 @@ HttpUrl parse(HttpUrl base, String input) {
           this.scheme = "http";
           pos += "http:".length();
         } else {
-          return null; // Not an HTTP scheme.
+          return ParseResult.UNSUPPORTED_SCHEME; // Not an HTTP scheme.
         }
       } else if (base != null) {
         this.scheme = base.scheme;
       } else {
-        return null; // No scheme.
+        return ParseResult.MISSING_SCHEME; // No scheme.
       }
 
       // Authority.
@@ -931,21 +1081,21 @@ HttpUrl parse(HttpUrl base, String input) {
               // User info precedes.
               if (!hasPassword) {
                 int passwordColonOffset = delimiterOffset(
-                    input, pos, componentDelimiterOffset, ":");
+                    input, pos, componentDelimiterOffset, ':');
                 String canonicalUsername = canonicalize(
-                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false);
+                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false, false, true);
                 this.encodedUsername = hasUsername
                     ? this.encodedUsername + "%40" + canonicalUsername
                     : canonicalUsername;
                 if (passwordColonOffset != componentDelimiterOffset) {
                   hasPassword = true;
                   this.encodedPassword = canonicalize(input, passwordColonOffset + 1,
-                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false);
+                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true);
                 }
                 hasUsername = true;
               } else {
-                this.encodedPassword = this.encodedPassword + "%40" + canonicalize(
-                    input, pos, componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false);
+                this.encodedPassword = this.encodedPassword + "%40" + canonicalize(input, pos,
+                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true);
               }
               pos = componentDelimiterOffset + 1;
               break;
@@ -960,12 +1110,12 @@ HttpUrl parse(HttpUrl base, String input) {
               if (portColonOffset + 1 < componentDelimiterOffset) {
                 this.host = canonicalizeHost(input, pos, portColonOffset);
                 this.port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
-                if (this.port == -1) return null; // Invalid port.
+                if (this.port == -1) return ParseResult.INVALID_PORT; // Invalid port.
               } else {
                 this.host = canonicalizeHost(input, pos, portColonOffset);
                 this.port = defaultPort(this.scheme);
               }
-              if (this.host == null) return null; // Invalid host.
+              if (this.host == null) return ParseResult.INVALID_HOST; // Invalid host.
               pos = componentDelimiterOffset;
               break authority;
           }
@@ -990,19 +1140,19 @@ HttpUrl parse(HttpUrl base, String input) {
 
       // Query.
       if (pos < limit && input.charAt(pos) == '?') {
-        int queryDelimiterOffset = delimiterOffset(input, pos, limit, "#");
+        int queryDelimiterOffset = delimiterOffset(input, pos, limit, '#');
         this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
-            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, true));
+            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true));
         pos = queryDelimiterOffset;
       }
 
       // Fragment.
       if (pos < limit && input.charAt(pos) == '#') {
         this.encodedFragment = canonicalize(
-            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false);
+            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false);
       }
 
-      return build();
+      return ParseResult.SUCCESS;
     }
 
     private void resolvePath(String input, int pos, int limit) {
@@ -1036,7 +1186,7 @@ private void resolvePath(String input, int pos, int limit) {
     private void push(String input, int pos, int limit, boolean addTrailingSlash,
         boolean alreadyEncoded) {
       String segment = canonicalize(
-          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false);
+          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false, false, true);
       if (isDot(segment)) {
         return; // Skip '.' path segments.
       }
@@ -1069,8 +1219,8 @@ private boolean isDotDot(String input) {
      * Removes a path segment. When this method returns the last segment is always "", which means
      * the encoded path will have a trailing '/'.
      *
-     * <p>Popping "/a/b/c/" yields "/a/b/". In this case the list of path segments goes from
-     * ["a", "b", "c", ""] to ["a", "b", ""].
+     * <p>Popping "/a/b/c/" yields "/a/b/". In this case the list of path segments goes from ["a",
+     * "b", "c", ""] to ["a", "b", ""].
      *
      * <p>Popping "/a/b/c" also yields "/a/b/". The list of path segments goes from ["a", "b", "c"]
      * to ["a", "b", ""].
@@ -1086,46 +1236,6 @@ private void pop() {
       }
     }
 
-    /**
-     * Increments {@code pos} until {@code input[pos]} is not ASCII whitespace. Stops at {@code
-     * limit}.
-     */
-    private int skipLeadingAsciiWhitespace(String input, int pos, int limit) {
-      for (int i = pos; i < limit; i++) {
-        switch (input.charAt(i)) {
-          case '\t':
-          case '\n':
-          case '\f':
-          case '\r':
-          case ' ':
-            continue;
-          default:
-            return i;
-        }
-      }
-      return limit;
-    }
-
-    /**
-     * Decrements {@code limit} until {@code input[limit - 1]} is not ASCII whitespace. Stops at
-     * {@code pos}.
-     */
-    private int skipTrailingAsciiWhitespace(String input, int pos, int limit) {
-      for (int i = limit - 1; i >= pos; i--) {
-        switch (input.charAt(i)) {
-          case '\t':
-          case '\n':
-          case '\f':
-          case '\r':
-          case ' ':
-            continue;
-          default:
-            return i + 1;
-        }
-      }
-      return pos;
-    }
-
     /**
      * Returns the index of the ':' in {@code input} that is after scheme characters. Returns -1 if
      * {@code input} does not have a scheme that starts at {@code pos}.
@@ -1141,6 +1251,7 @@ private static int schemeDelimiterOffset(String input, int pos, int limit) {
 
         if ((c >= 'a' && c <= 'z')
             || (c >= 'A' && c <= 'Z')
+            || (c >= '0' && c <= '9')
             || c == '+'
             || c == '-'
             || c == '.') {
@@ -1189,28 +1300,21 @@ private static int portColonOffset(String input, int pos, int limit) {
     private static String canonicalizeHost(String input, int pos, int limit) {
       // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
       // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
-      String percentDecoded = percentDecode(input, pos, limit);
-
-      // If the input is encased in square braces "[...]", drop 'em. We have an IPv6 address.
-      if (percentDecoded.startsWith("[") && percentDecoded.endsWith("]")) {
-        InetAddress inetAddress = decodeIpv6(percentDecoded, 1, percentDecoded.length() - 1);
+      String percentDecoded = percentDecode(input, pos, limit, false);
+
+      // If the input contains a :, it’s an IPv6 address.
+      if (percentDecoded.contains(":")) {
+        // If the input is encased in square braces "[...]", drop 'em.
+        InetAddress inetAddress = percentDecoded.startsWith("[") && percentDecoded.endsWith("]")
+            ? decodeIpv6(percentDecoded, 1, percentDecoded.length() - 1)
+            : decodeIpv6(percentDecoded, 0, percentDecoded.length());
         if (inetAddress == null) return null;
         byte[] address = inetAddress.getAddress();
         if (address.length == 16) return inet6AddressToAscii(address);
         throw new AssertionError();
       }
 
-      // Do IDN decoding. This converts {@code ☃.net} to {@code xn--n3h.net}.
-      String idnDecoded = domainToAscii(percentDecoded);
-      if (idnDecoded == null) return null;
-
-      // Confirm that the decoded result doesn't contain any illegal characters.
-      int length = idnDecoded.length();
-      if (delimiterOffset(idnDecoded, 0, length, "\u0000\t\n\r #%/:?@[\\]") != length) {
-        return null;
-      }
-
-      return idnDecoded;
+      return domainToAscii(percentDecoded);
     }
 
     /** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
@@ -1319,17 +1423,6 @@ private static boolean decodeIpv4Suffix(
       return true; // Success.
     }
 
-    private static String domainToAscii(String input) {
-      try {
-        String result = IDN.toASCII(input).toLowerCase(Locale.US);
-        if (result.isEmpty()) return null;
-        // TODO: implement all label limits.
-        return result;
-      } catch (IllegalArgumentException e) {
-        return null;
-      }
-    }
-
     private static String inet6AddressToAscii(byte[] address) {
       // Go through the address looking for the longest run of 0s. Each group is 2-bytes.
       int longestRunOffset = -1;
@@ -1366,7 +1459,7 @@ private static String inet6AddressToAscii(byte[] address) {
     private static int parsePort(String input, int pos, int limit) {
       try {
         // Canonicalize the port string to skip '\n' etc.
-        String portString = canonicalize(input, pos, limit, "", false, false);
+        String portString = canonicalize(input, pos, limit, "", false, false, false, true);
         int i = Integer.parseInt(portString);
         if (i > 0 && i <= 65535) return i;
         return -1;
@@ -1376,37 +1469,26 @@ private static int parsePort(String input, int pos, int limit) {
     }
   }
 
-  /**
-   * Returns the index of the first character in {@code input} that contains a character in {@code
-   * delimiters}. Returns limit if there is no such character.
-   */
-  private static int delimiterOffset(String input, int pos, int limit, String delimiters) {
-    for (int i = pos; i < limit; i++) {
-      if (delimiters.indexOf(input.charAt(i)) != -1) return i;
-    }
-    return limit;
-  }
-
-  static String percentDecode(String encoded) {
-    return percentDecode(encoded, 0, encoded.length());
+  static String percentDecode(String encoded, boolean plusIsSpace) {
+    return percentDecode(encoded, 0, encoded.length(), plusIsSpace);
   }
 
-  private List<String> percentDecode(List<String> list) {
+  private List<String> percentDecode(List<String> list, boolean plusIsSpace) {
     List<String> result = new ArrayList<>(list.size());
     for (String s : list) {
-      result.add(s != null ? percentDecode(s) : null);
+      result.add(s != null ? percentDecode(s, plusIsSpace) : null);
     }
     return Collections.unmodifiableList(result);
   }
 
-  static String percentDecode(String encoded, int pos, int limit) {
+  static String percentDecode(String encoded, int pos, int limit, boolean plusIsSpace) {
     for (int i = pos; i < limit; i++) {
       char c = encoded.charAt(i);
-      if (c == '%') {
+      if (c == '%' || (c == '+' && plusIsSpace)) {
         // Slow path: the character at i requires decoding!
         Buffer out = new Buffer();
         out.writeUtf8(encoded, pos, i);
-        percentDecode(out, encoded, i, limit);
+        percentDecode(out, encoded, i, limit, plusIsSpace);
         return out.readUtf8();
       }
     }
@@ -1415,7 +1497,7 @@ static String percentDecode(String encoded, int pos, int limit) {
     return encoded.substring(pos, limit);
   }
 
-  static void percentDecode(Buffer out, String encoded, int pos, int limit) {
+  static void percentDecode(Buffer out, String encoded, int pos, int limit, boolean plusIsSpace) {
     int codePoint;
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
       codePoint = encoded.codePointAt(i);
@@ -1427,11 +1509,21 @@ static void percentDecode(Buffer out, String encoded, int pos, int limit) {
           i += 2;
           continue;
         }
+      } else if (codePoint == '+' && plusIsSpace) {
+        out.writeByte(' ');
+        continue;
       }
       out.writeUtf8CodePoint(codePoint);
     }
   }
 
+  static boolean percentEncoded(String encoded, int pos, int limit) {
+    return pos + 2 < limit
+        && encoded.charAt(pos) == '%'
+        && decodeHexDigit(encoded.charAt(pos + 1)) != -1
+        && decodeHexDigit(encoded.charAt(pos + 2)) != -1;
+  }
+
   static int decodeHexDigit(char c) {
     if (c >= '0' && c <= '9') return c - '0';
     if (c >= 'a' && c <= 'f') return c - 'a' + 10;
@@ -1451,22 +1543,26 @@ static int decodeHexDigit(char c) {
    * </ul>
    *
    * @param alreadyEncoded true to leave '%' as-is; false to convert it to '%25'.
-   * @param query true if to encode ' ' as '+', and '+' as "%2B".
+   * @param strict true to encode '%' if it is not the prefix of a valid percent encoding.
+   * @param plusIsSpace true to encode '+' as "%2B" if it is not already encoded.
+   * @param asciiOnly true to encode all non-ASCII codepoints.
    */
   static String canonicalize(String input, int pos, int limit, String encodeSet,
-      boolean alreadyEncoded, boolean query) {
+      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly) {
     int codePoint;
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
       codePoint = input.codePointAt(i);
       if (codePoint < 0x20
-          || codePoint >= 0x7f
+          || codePoint == 0x7f
+          || codePoint >= 0x80 && asciiOnly
           || encodeSet.indexOf(codePoint) != -1
-          || (codePoint == '%' && !alreadyEncoded)
-          || (query && codePoint == '+')) {
+          || codePoint == '%' && (!alreadyEncoded || strict && !percentEncoded(input, i, limit))
+          || codePoint == '+' && plusIsSpace) {
         // Slow path: the character at i requires encoding!
         Buffer out = new Buffer();
         out.writeUtf8(input, pos, i);
-        canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, query);
+        canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, strict, plusIsSpace,
+            asciiOnly);
         return out.readUtf8();
       }
     }
@@ -1475,8 +1571,8 @@ static String canonicalize(String input, int pos, int limit, String encodeSet,
     return input.substring(pos, limit);
   }
 
-  static void canonicalize(Buffer out, String input, int pos, int limit,
-      String encodeSet, boolean alreadyEncoded, boolean query) {
+  static void canonicalize(Buffer out, String input, int pos, int limit, String encodeSet,
+      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly) {
     Buffer utf8Buffer = null; // Lazily allocated.
     int codePoint;
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
@@ -1484,13 +1580,14 @@ static void canonicalize(Buffer out, String input, int pos, int limit,
       if (alreadyEncoded
           && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
         // Skip this character.
-      } else if (query && codePoint == '+') {
-        // HTML permits space to be encoded as '+'. We use '%20' to avoid special cases.
-        out.writeUtf8(alreadyEncoded ? "%20" : "%2B");
+      } else if (codePoint == '+' && plusIsSpace) {
+        // Encode '+' as '%2B' since we permit ' ' to be encoded as either '+' or '%20'.
+        out.writeUtf8(alreadyEncoded ? "+" : "%2B");
       } else if (codePoint < 0x20
-          || codePoint >= 0x7f
+          || codePoint == 0x7f
+          || codePoint >= 0x80 && asciiOnly
           || encodeSet.indexOf(codePoint) != -1
-          || (codePoint == '%' && !alreadyEncoded)) {
+          || codePoint == '%' && (!alreadyEncoded || strict && !percentEncoded(input, i, limit))) {
         // Percent encode this character.
         if (utf8Buffer == null) {
           utf8Buffer = new Buffer();
@@ -1509,8 +1606,9 @@ static void canonicalize(Buffer out, String input, int pos, int limit,
     }
   }
 
-  static String canonicalize(
-      String input, String encodeSet, boolean alreadyEncoded, boolean query) {
-    return canonicalize(input, 0, input.length(), encodeSet, alreadyEncoded, query);
+  static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
+      boolean plusIsSpace, boolean asciiOnly) {
+    return canonicalize(
+        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly);
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Interceptor.java b/okhttp/src/main/java/okhttp3/Interceptor.java
similarity index 85%
rename from okhttp/src/main/java/com/squareup/okhttp/Interceptor.java
rename to okhttp/src/main/java/okhttp3/Interceptor.java
index 03325be973..c1f8840a3c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Interceptor.java
+++ b/okhttp/src/main/java/okhttp3/Interceptor.java
@@ -13,21 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 
 /**
  * Observes, modifies, and potentially short-circuits requests going out and the corresponding
- * requests coming back in. Typically interceptors will be used to add, remove, or transform headers
- * on the request or response.
+ * responses coming back in. Typically interceptors add, remove, or transform headers on the request
+ * or response.
  */
 public interface Interceptor {
   Response intercept(Chain chain) throws IOException;
 
   interface Chain {
     Request request();
+
     Response proceed(Request request) throws IOException;
+
     Connection connection();
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/MediaType.java b/okhttp/src/main/java/okhttp3/MediaType.java
similarity index 90%
rename from okhttp/src/main/java/com/squareup/okhttp/MediaType.java
rename to okhttp/src/main/java/okhttp3/MediaType.java
index 4d2f1fcf44..bbdcedf686 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
+++ b/okhttp/src/main/java/okhttp3/MediaType.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.nio.charset.Charset;
 import java.util.Locale;
@@ -21,8 +21,8 @@
 import java.util.regex.Pattern;
 
 /**
- * An <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a> Media Type,
- * appropriate to describe the content type of an HTTP request or response body.
+ * An <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a> Media Type, appropriate to describe
+ * the content type of an HTTP request or response body.
  */
 public final class MediaType {
   private static final String TOKEN = "([a-zA-Z0-9-!#$%&'*+.^_`{|}~]+)";
@@ -44,8 +44,8 @@ private MediaType(String mediaType, String type, String subtype, String charset)
   }
 
   /**
-   * Returns a media type for {@code string}, or null if {@code string} is not a
-   * well-formed media type.
+   * Returns a media type for {@code string}, or null if {@code string} is not a well-formed media
+   * type.
    */
   public static MediaType parse(String string) {
     Matcher typeSubtype = TYPE_SUBTYPE.matcher(string);
@@ -74,40 +74,38 @@ public static MediaType parse(String string) {
   }
 
   /**
-   * Returns the high-level media type, such as "text", "image", "audio",
-   * "video", or "application".
+   * Returns the high-level media type, such as "text", "image", "audio", "video", or
+   * "application".
    */
   public String type() {
     return type;
   }
 
   /**
-   * Returns a specific media subtype, such as "plain" or "png", "mpeg",
-   * "mp4" or "xml".
+   * Returns a specific media subtype, such as "plain" or "png", "mpeg", "mp4" or "xml".
    */
   public String subtype() {
     return subtype;
   }
 
   /**
-   * Returns the charset of this media type, or null if this media type doesn't
-   * specify a charset.
+   * Returns the charset of this media type, or null if this media type doesn't specify a charset.
    */
   public Charset charset() {
     return charset != null ? Charset.forName(charset) : null;
   }
 
   /**
-   * Returns the charset of this media type, or {@code defaultValue} if this
-   * media type doesn't specify a charset.
+   * Returns the charset of this media type, or {@code defaultValue} if this media type doesn't
+   * specify a charset.
    */
   public Charset charset(Charset defaultValue) {
     return charset != null ? Charset.forName(charset) : defaultValue;
   }
 
   /**
-   * Returns the encoded media type, like "text/plain; charset=utf-8",
-   * appropriate for use in a Content-Type header.
+   * Returns the encoded media type, like "text/plain; charset=utf-8", appropriate for use in a
+   * Content-Type header.
    */
   @Override public String toString() {
     return mediaType;
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.java b/okhttp/src/main/java/okhttp3/MultipartBody.java
new file mode 100644
index 0000000000..7ac584d1d9
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.java
@@ -0,0 +1,332 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+
+/** An <a href="http://www.ietf.org/rfc/rfc2387.txt">RFC 2387</a>-compliant request body. */
+public final class MultipartBody extends RequestBody {
+  /**
+   * The "mixed" subtype of "multipart" is intended for use when the body parts are independent and
+   * need to be bundled in a particular order. Any "multipart" subtypes that an implementation does
+   * not recognize must be treated as being of subtype "mixed".
+   */
+  public static final MediaType MIXED = MediaType.parse("multipart/mixed");
+
+  /**
+   * The "multipart/alternative" type is syntactically identical to "multipart/mixed", but the
+   * semantics are different. In particular, each of the body parts is an "alternative" version of
+   * the same information.
+   */
+  public static final MediaType ALTERNATIVE = MediaType.parse("multipart/alternative");
+
+  /**
+   * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
+   * particular, in a digest, the default {@code Content-Type} value for a body part is changed from
+   * "text/plain" to "message/rfc822".
+   */
+  public static final MediaType DIGEST = MediaType.parse("multipart/digest");
+
+  /**
+   * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
+   * particular, in a parallel entity, the order of body parts is not significant.
+   */
+  public static final MediaType PARALLEL = MediaType.parse("multipart/parallel");
+
+  /**
+   * The media-type multipart/form-data follows the rules of all multipart MIME data streams as
+   * outlined in RFC 2046. In forms, there are a series of fields to be supplied by the user who
+   * fills out the form. Each field has a name. Within a given form, the names are unique.
+   */
+  public static final MediaType FORM = MediaType.parse("multipart/form-data");
+
+  private static final byte[] COLONSPACE = {':', ' '};
+  private static final byte[] CRLF = {'\r', '\n'};
+  private static final byte[] DASHDASH = {'-', '-'};
+
+  private final ByteString boundary;
+  private final MediaType originalType;
+  private final MediaType contentType;
+  private final List<Part> parts;
+  private long contentLength = -1L;
+
+  MultipartBody(ByteString boundary, MediaType type, List<Part> parts) {
+    this.boundary = boundary;
+    this.originalType = type;
+    this.contentType = MediaType.parse(type + "; boundary=" + boundary.utf8());
+    this.parts = Util.immutableList(parts);
+  }
+
+  public MediaType type() {
+    return originalType;
+  }
+
+  public String boundary() {
+    return boundary.utf8();
+  }
+
+  /** The number of parts in this multipart body. */
+  public int size() {
+    return parts.size();
+  }
+
+  public List<Part> parts() {
+    return parts;
+  }
+
+  public Part part(int index) {
+    return parts.get(index);
+  }
+
+  /** A combination of {@link #type()} and {@link #boundary()}. */
+  @Override public MediaType contentType() {
+    return contentType;
+  }
+
+  @Override public long contentLength() throws IOException {
+    long result = contentLength;
+    if (result != -1L) return result;
+    return contentLength = writeOrCountBytes(null, true);
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    writeOrCountBytes(sink, false);
+  }
+
+  /**
+   * Either writes this request to {@code sink} or measures its content length. We have one method
+   * do double-duty to make sure the counting and content are consistent, particularly when it comes
+   * to awkward operations like measuring the encoded length of header strings, or the
+   * length-in-digits of an encoded integer.
+   */
+  private long writeOrCountBytes(BufferedSink sink, boolean countBytes) throws IOException {
+    long byteCount = 0L;
+
+    Buffer byteCountBuffer = null;
+    if (countBytes) {
+      sink = byteCountBuffer = new Buffer();
+    }
+
+    for (int p = 0, partCount = parts.size(); p < partCount; p++) {
+      Part part = parts.get(p);
+      Headers headers = part.headers;
+      RequestBody body = part.body;
+
+      sink.write(DASHDASH);
+      sink.write(boundary);
+      sink.write(CRLF);
+
+      if (headers != null) {
+        for (int h = 0, headerCount = headers.size(); h < headerCount; h++) {
+          sink.writeUtf8(headers.name(h))
+              .write(COLONSPACE)
+              .writeUtf8(headers.value(h))
+              .write(CRLF);
+        }
+      }
+
+      MediaType contentType = body.contentType();
+      if (contentType != null) {
+        sink.writeUtf8("Content-Type: ")
+            .writeUtf8(contentType.toString())
+            .write(CRLF);
+      }
+
+      long contentLength = body.contentLength();
+      if (contentLength != -1) {
+        sink.writeUtf8("Content-Length: ")
+            .writeDecimalLong(contentLength)
+            .write(CRLF);
+      } else if (countBytes) {
+        // We can't measure the body's size without the sizes of its components.
+        byteCountBuffer.clear();
+        return -1L;
+      }
+
+      sink.write(CRLF);
+
+      if (countBytes) {
+        byteCount += contentLength;
+      } else {
+        body.writeTo(sink);
+      }
+
+      sink.write(CRLF);
+    }
+
+    sink.write(DASHDASH);
+    sink.write(boundary);
+    sink.write(DASHDASH);
+    sink.write(CRLF);
+
+    if (countBytes) {
+      byteCount += byteCountBuffer.size();
+      byteCountBuffer.clear();
+    }
+
+    return byteCount;
+  }
+
+  /**
+   * Appends a quoted-string to a StringBuilder.
+   *
+   * <p>RFC 2388 is rather vague about how one should escape special characters in form-data
+   * parameters, and as it turns out Firefox and Chrome actually do rather different things, and
+   * both say in their comments that they're not really sure what the right approach is. We go with
+   * Chrome's behavior (which also experimentally seems to match what IE does), but if you actually
+   * want to have a good chance of things working, please avoid double-quotes, newlines, percent
+   * signs, and the like in your field names.
+   */
+  static StringBuilder appendQuotedString(StringBuilder target, String key) {
+    target.append('"');
+    for (int i = 0, len = key.length(); i < len; i++) {
+      char ch = key.charAt(i);
+      switch (ch) {
+        case '\n':
+          target.append("%0A");
+          break;
+        case '\r':
+          target.append("%0D");
+          break;
+        case '"':
+          target.append("%22");
+          break;
+        default:
+          target.append(ch);
+          break;
+      }
+    }
+    target.append('"');
+    return target;
+  }
+
+  public static final class Part {
+    public static Part create(RequestBody body) {
+      return create(null, body);
+    }
+
+    public static Part create(Headers headers, RequestBody body) {
+      if (body == null) {
+        throw new NullPointerException("body == null");
+      }
+      if (headers != null && headers.get("Content-Type") != null) {
+        throw new IllegalArgumentException("Unexpected header: Content-Type");
+      }
+      if (headers != null && headers.get("Content-Length") != null) {
+        throw new IllegalArgumentException("Unexpected header: Content-Length");
+      }
+      return new Part(headers, body);
+    }
+
+    public static Part createFormData(String name, String value) {
+      return createFormData(name, null, RequestBody.create(null, value));
+    }
+
+    public static Part createFormData(String name, String filename, RequestBody body) {
+      if (name == null) {
+        throw new NullPointerException("name == null");
+      }
+      StringBuilder disposition = new StringBuilder("form-data; name=");
+      appendQuotedString(disposition, name);
+
+      if (filename != null) {
+        disposition.append("; filename=");
+        appendQuotedString(disposition, filename);
+      }
+
+      return create(Headers.of("Content-Disposition", disposition.toString()), body);
+    }
+
+    private final Headers headers;
+    private final RequestBody body;
+
+    private Part(Headers headers, RequestBody body) {
+      this.headers = headers;
+      this.body = body;
+    }
+  }
+
+  public static final class Builder {
+    private final ByteString boundary;
+    private MediaType type = MIXED;
+    private final List<Part> parts = new ArrayList<>();
+
+    public Builder() {
+      this(UUID.randomUUID().toString());
+    }
+
+    public Builder(String boundary) {
+      this.boundary = ByteString.encodeUtf8(boundary);
+    }
+
+    /**
+     * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the default), {@link
+     * #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and {@link #FORM}.
+     */
+    public Builder setType(MediaType type) {
+      if (type == null) {
+        throw new NullPointerException("type == null");
+      }
+      if (!type.type().equals("multipart")) {
+        throw new IllegalArgumentException("multipart != " + type);
+      }
+      this.type = type;
+      return this;
+    }
+
+    /** Add a part to the body. */
+    public Builder addPart(RequestBody body) {
+      return addPart(Part.create(body));
+    }
+
+    /** Add a part to the body. */
+    public Builder addPart(Headers headers, RequestBody body) {
+      return addPart(Part.create(headers, body));
+    }
+
+    /** Add a form data part to the body. */
+    public Builder addFormDataPart(String name, String value) {
+      return addPart(Part.createFormData(name, value));
+    }
+
+    /** Add a form data part to the body. */
+    public Builder addFormDataPart(String name, String filename, RequestBody body) {
+      return addPart(Part.createFormData(name, filename, body));
+    }
+
+    /** Add a part to the body. */
+    public Builder addPart(Part part) {
+      if (part == null) throw new NullPointerException("part == null");
+      parts.add(part);
+      return this;
+    }
+
+    /** Assemble the specified parts into a request body. */
+    public MultipartBody build() {
+      if (parts.isEmpty()) {
+        throw new IllegalStateException("Multipart body must have at least one part.");
+      }
+      return new MultipartBody(boundary, type, parts);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
new file mode 100644
index 0000000000..b23e6a2212
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -0,0 +1,791 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.MalformedURLException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.UnknownHostException;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import javax.net.SocketFactory;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.internal.Internal;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.Platform;
+import okhttp3.internal.RouteDatabase;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.io.RealConnection;
+import okhttp3.internal.tls.CertificateChainCleaner;
+import okhttp3.internal.tls.OkHostnameVerifier;
+
+/**
+ * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
+ * responses. Most applications can use a single OkHttpClient for all of their HTTP requests,
+ * benefiting from a shared response cache, thread pool, connection re-use, etc.
+ *
+ * <p>To create an {@code OkHttpClient} with the default settings, use the {@linkplain
+ * #OkHttpClient() default constructor}. Or create a configured instance with {@link
+ * OkHttpClient.Builder}. To adjust an existing client before making a request, use {@link
+ * #newBuilder()}. This example shows a call with a 30 second timeout:
+ * <pre>   {@code
+ *
+ *   OkHttpClient client = ...
+ *   OkHttpClient clientWith30sTimeout = client.newBuilder()
+ *       .readTimeout(30, TimeUnit.SECONDS)
+ *       .build();
+ *   Response response = clientWith30sTimeout.newCall(request).execute();
+ * }</pre>
+ */
+public class OkHttpClient implements Cloneable, Call.Factory {
+  private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
+      Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
+
+  private static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS;
+
+  static {
+    List<ConnectionSpec> connSpecs = new ArrayList<>(Arrays.asList(ConnectionSpec.MODERN_TLS,
+        ConnectionSpec.COMPATIBLE_TLS));
+    if (Platform.get().isCleartextTrafficPermitted()) {
+      connSpecs.add(ConnectionSpec.CLEARTEXT);
+    }
+    DEFAULT_CONNECTION_SPECS = Util.immutableList(connSpecs);
+
+    Internal.instance = new Internal() {
+      @Override public void addLenient(Headers.Builder builder, String line) {
+        builder.addLenient(line);
+      }
+
+      @Override public void addLenient(Headers.Builder builder, String name, String value) {
+        builder.addLenient(name, value);
+      }
+
+      @Override public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) {
+        builder.setInternalCache(internalCache);
+      }
+
+      @Override public InternalCache internalCache(OkHttpClient client) {
+        return client.internalCache();
+      }
+
+      @Override public boolean connectionBecameIdle(
+          ConnectionPool pool, RealConnection connection) {
+        return pool.connectionBecameIdle(connection);
+      }
+
+      @Override public RealConnection get(
+          ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
+        return pool.get(address, streamAllocation);
+      }
+
+      @Override public void put(ConnectionPool pool, RealConnection connection) {
+        pool.put(connection);
+      }
+
+      @Override public RouteDatabase routeDatabase(ConnectionPool connectionPool) {
+        return connectionPool.routeDatabase;
+      }
+
+      @Override
+      public void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket) {
+        ((RealCall) call).enqueue(responseCallback, forWebSocket);
+      }
+
+      @Override public StreamAllocation callEngineGetStreamAllocation(Call call) {
+        return ((RealCall) call).engine.streamAllocation;
+      }
+
+      @Override
+      public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
+        tlsConfiguration.apply(sslSocket, isFallback);
+      }
+
+      @Override public HttpUrl getHttpUrlChecked(String url)
+          throws MalformedURLException, UnknownHostException {
+        return HttpUrl.getChecked(url);
+      }
+    };
+  }
+
+  final Dispatcher dispatcher;
+  final Proxy proxy;
+  final List<Protocol> protocols;
+  final List<ConnectionSpec> connectionSpecs;
+  final List<Interceptor> interceptors;
+  final List<Interceptor> networkInterceptors;
+  final ProxySelector proxySelector;
+  final CookieJar cookieJar;
+  final Cache cache;
+  final InternalCache internalCache;
+  final SocketFactory socketFactory;
+  final SSLSocketFactory sslSocketFactory;
+  final CertificateChainCleaner certificateChainCleaner;
+  final HostnameVerifier hostnameVerifier;
+  final CertificatePinner certificatePinner;
+  final Authenticator proxyAuthenticator;
+  final Authenticator authenticator;
+  final ConnectionPool connectionPool;
+  final Dns dns;
+  final boolean followSslRedirects;
+  final boolean followRedirects;
+  final boolean retryOnConnectionFailure;
+  final int connectTimeout;
+  final int readTimeout;
+  final int writeTimeout;
+
+  public OkHttpClient() {
+    this(new Builder());
+  }
+
+  private OkHttpClient(Builder builder) {
+    this.dispatcher = builder.dispatcher;
+    this.proxy = builder.proxy;
+    this.protocols = builder.protocols;
+    this.connectionSpecs = builder.connectionSpecs;
+    this.interceptors = Util.immutableList(builder.interceptors);
+    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
+    this.proxySelector = builder.proxySelector;
+    this.cookieJar = builder.cookieJar;
+    this.cache = builder.cache;
+    this.internalCache = builder.internalCache;
+    this.socketFactory = builder.socketFactory;
+
+    boolean isTLS = false;
+    for (ConnectionSpec spec : connectionSpecs) {
+      isTLS = isTLS || spec.isTls();
+    }
+
+    if (builder.sslSocketFactory != null || !isTLS) {
+      this.sslSocketFactory = builder.sslSocketFactory;
+      this.certificateChainCleaner = builder.certificateChainCleaner;
+    } else {
+      X509TrustManager trustManager = systemDefaultTrustManager();
+      this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);
+      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+    }
+
+    this.hostnameVerifier = builder.hostnameVerifier;
+    this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
+        certificateChainCleaner);
+    this.proxyAuthenticator = builder.proxyAuthenticator;
+    this.authenticator = builder.authenticator;
+    this.connectionPool = builder.connectionPool;
+    this.dns = builder.dns;
+    this.followSslRedirects = builder.followSslRedirects;
+    this.followRedirects = builder.followRedirects;
+    this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
+    this.connectTimeout = builder.connectTimeout;
+    this.readTimeout = builder.readTimeout;
+    this.writeTimeout = builder.writeTimeout;
+  }
+
+  private X509TrustManager systemDefaultTrustManager() {
+    try {
+      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+          TrustManagerFactory.getDefaultAlgorithm());
+      trustManagerFactory.init((KeyStore) null);
+      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+        throw new IllegalStateException("Unexpected default trust managers:"
+            + Arrays.toString(trustManagers));
+      }
+      return (X509TrustManager) trustManagers[0];
+    } catch (GeneralSecurityException e) {
+      throw new AssertionError(); // The system has no TLS. Just give up.
+    }
+  }
+
+  private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustManager) {
+    try {
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(null, new TrustManager[] { trustManager }, null);
+      return sslContext.getSocketFactory();
+    } catch (GeneralSecurityException e) {
+      throw new AssertionError(); // The system has no TLS. Just give up.
+    }
+  }
+
+  /** Default connect timeout (in milliseconds). */
+  public int connectTimeoutMillis() {
+    return connectTimeout;
+  }
+
+  /** Default read timeout (in milliseconds). */
+  public int readTimeoutMillis() {
+    return readTimeout;
+  }
+
+  /** Default write timeout (in milliseconds). */
+  public int writeTimeoutMillis() {
+    return writeTimeout;
+  }
+
+  public Proxy proxy() {
+    return proxy;
+  }
+
+  public ProxySelector proxySelector() {
+    return proxySelector;
+  }
+
+  public CookieJar cookieJar() {
+    return cookieJar;
+  }
+
+  public Cache cache() {
+    return cache;
+  }
+
+  InternalCache internalCache() {
+    return cache != null ? cache.internalCache : internalCache;
+  }
+
+  public Dns dns() {
+    return dns;
+  }
+
+  public SocketFactory socketFactory() {
+    return socketFactory;
+  }
+
+  public SSLSocketFactory sslSocketFactory() {
+    return sslSocketFactory;
+  }
+
+  public HostnameVerifier hostnameVerifier() {
+    return hostnameVerifier;
+  }
+
+  public CertificatePinner certificatePinner() {
+    return certificatePinner;
+  }
+
+  public Authenticator authenticator() {
+    return authenticator;
+  }
+
+  public Authenticator proxyAuthenticator() {
+    return proxyAuthenticator;
+  }
+
+  public ConnectionPool connectionPool() {
+    return connectionPool;
+  }
+
+  public boolean followSslRedirects() {
+    return followSslRedirects;
+  }
+
+  public boolean followRedirects() {
+    return followRedirects;
+  }
+
+  public boolean retryOnConnectionFailure() {
+    return retryOnConnectionFailure;
+  }
+
+  public Dispatcher dispatcher() {
+    return dispatcher;
+  }
+
+  public List<Protocol> protocols() {
+    return protocols;
+  }
+
+  public List<ConnectionSpec> connectionSpecs() {
+    return connectionSpecs;
+  }
+
+  /**
+   * Returns an immutable list of interceptors that observe the full span of each call: from before
+   * the connection is established (if any) until after the response source is selected (either the
+   * origin server, cache, or both).
+   */
+  public List<Interceptor> interceptors() {
+    return interceptors;
+  }
+
+  /**
+   * Returns an immutable list of interceptors that observe a single network request and response.
+   * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
+   * a network interceptor to short-circuit or repeat a network request.
+   */
+  public List<Interceptor> networkInterceptors() {
+    return networkInterceptors;
+  }
+
+  /**
+   * Prepares the {@code request} to be executed at some point in the future.
+   */
+  @Override public Call newCall(Request request) {
+    return new RealCall(this, request);
+  }
+
+  public Builder newBuilder() {
+    return new Builder(this);
+  }
+
+  public static final class Builder {
+    Dispatcher dispatcher;
+    Proxy proxy;
+    List<Protocol> protocols;
+    List<ConnectionSpec> connectionSpecs;
+    final List<Interceptor> interceptors = new ArrayList<>();
+    final List<Interceptor> networkInterceptors = new ArrayList<>();
+    ProxySelector proxySelector;
+    CookieJar cookieJar;
+    Cache cache;
+    InternalCache internalCache;
+    SocketFactory socketFactory;
+    SSLSocketFactory sslSocketFactory;
+    CertificateChainCleaner certificateChainCleaner;
+    HostnameVerifier hostnameVerifier;
+    CertificatePinner certificatePinner;
+    Authenticator proxyAuthenticator;
+    Authenticator authenticator;
+    ConnectionPool connectionPool;
+    Dns dns;
+    boolean followSslRedirects;
+    boolean followRedirects;
+    boolean retryOnConnectionFailure;
+    int connectTimeout;
+    int readTimeout;
+    int writeTimeout;
+
+    public Builder() {
+      dispatcher = new Dispatcher();
+      protocols = DEFAULT_PROTOCOLS;
+      connectionSpecs = DEFAULT_CONNECTION_SPECS;
+      proxySelector = ProxySelector.getDefault();
+      cookieJar = CookieJar.NO_COOKIES;
+      socketFactory = SocketFactory.getDefault();
+      hostnameVerifier = OkHostnameVerifier.INSTANCE;
+      certificatePinner = CertificatePinner.DEFAULT;
+      proxyAuthenticator = Authenticator.NONE;
+      authenticator = Authenticator.NONE;
+      connectionPool = new ConnectionPool();
+      dns = Dns.SYSTEM;
+      followSslRedirects = true;
+      followRedirects = true;
+      retryOnConnectionFailure = true;
+      connectTimeout = 10_000;
+      readTimeout = 10_000;
+      writeTimeout = 10_000;
+    }
+
+    Builder(OkHttpClient okHttpClient) {
+      this.dispatcher = okHttpClient.dispatcher;
+      this.proxy = okHttpClient.proxy;
+      this.protocols = okHttpClient.protocols;
+      this.connectionSpecs = okHttpClient.connectionSpecs;
+      this.interceptors.addAll(okHttpClient.interceptors);
+      this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
+      this.proxySelector = okHttpClient.proxySelector;
+      this.cookieJar = okHttpClient.cookieJar;
+      this.internalCache = okHttpClient.internalCache;
+      this.cache = okHttpClient.cache;
+      this.socketFactory = okHttpClient.socketFactory;
+      this.sslSocketFactory = okHttpClient.sslSocketFactory;
+      this.certificateChainCleaner = okHttpClient.certificateChainCleaner;
+      this.hostnameVerifier = okHttpClient.hostnameVerifier;
+      this.certificatePinner = okHttpClient.certificatePinner;
+      this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
+      this.authenticator = okHttpClient.authenticator;
+      this.connectionPool = okHttpClient.connectionPool;
+      this.dns = okHttpClient.dns;
+      this.followSslRedirects = okHttpClient.followSslRedirects;
+      this.followRedirects = okHttpClient.followRedirects;
+      this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
+      this.connectTimeout = okHttpClient.connectTimeout;
+      this.readTimeout = okHttpClient.readTimeout;
+      this.writeTimeout = okHttpClient.writeTimeout;
+    }
+
+    /**
+     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
+     * milliseconds.
+     */
+    public Builder connectTimeout(long timeout, TimeUnit unit) {
+      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+      if (unit == null) throw new NullPointerException("unit == null");
+      long millis = unit.toMillis(timeout);
+      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
+      connectTimeout = (int) millis;
+      return this;
+    }
+
+    /**
+     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     */
+    public Builder readTimeout(long timeout, TimeUnit unit) {
+      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+      if (unit == null) throw new NullPointerException("unit == null");
+      long millis = unit.toMillis(timeout);
+      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
+      readTimeout = (int) millis;
+      return this;
+    }
+
+    /**
+     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     */
+    public Builder writeTimeout(long timeout, TimeUnit unit) {
+      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+      if (unit == null) throw new NullPointerException("unit == null");
+      long millis = unit.toMillis(timeout);
+      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
+      writeTimeout = (int) millis;
+      return this;
+    }
+
+    /**
+     * Sets the HTTP proxy that will be used by connections created by this client. This takes
+     * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
+     * it is by default). To disable proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
+     */
+    public Builder proxy(Proxy proxy) {
+      this.proxy = proxy;
+      return this;
+    }
+
+    /**
+     * Sets the proxy selection policy to be used if no {@link #proxy proxy} is specified
+     * explicitly. The proxy selector may return multiple proxies; in that case they will be tried
+     * in sequence until a successful connection is established.
+     *
+     * <p>If unset, the {@link ProxySelector#getDefault() system-wide default} proxy selector will
+     * be used.
+     */
+    public Builder proxySelector(ProxySelector proxySelector) {
+      this.proxySelector = proxySelector;
+      return this;
+    }
+
+    /**
+     * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
+     * outgoing HTTP requests.
+     *
+     * <p>If unset, {@linkplain CookieJar#NO_COOKIES no cookies} will be accepted nor provided.
+     */
+    public Builder cookieJar(CookieJar cookieJar) {
+      if (cookieJar == null) throw new NullPointerException("cookieJar == null");
+      this.cookieJar = cookieJar;
+      return this;
+    }
+
+    /** Sets the response cache to be used to read and write cached responses. */
+    void setInternalCache(InternalCache internalCache) {
+      this.internalCache = internalCache;
+      this.cache = null;
+    }
+
+    public Builder cache(Cache cache) {
+      this.cache = cache;
+      this.internalCache = null;
+      return this;
+    }
+
+    /**
+     * Sets the DNS service used to lookup IP addresses for hostnames.
+     *
+     * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.
+     */
+    public Builder dns(Dns dns) {
+      if (dns == null) throw new NullPointerException("dns == null");
+      this.dns = dns;
+      return this;
+    }
+
+    /**
+     * Sets the socket factory used to create connections. OkHttp only uses the parameterless {@link
+     * SocketFactory#createSocket() createSocket()} method to create unconnected sockets. Overriding
+     * this method, e. g., allows the socket to be bound to a specific local address.
+     *
+     * <p>If unset, the {@link SocketFactory#getDefault() system-wide default} socket factory will
+     * be used.
+     */
+    public Builder socketFactory(SocketFactory socketFactory) {
+      if (socketFactory == null) throw new NullPointerException("socketFactory == null");
+      this.socketFactory = socketFactory;
+      return this;
+    }
+
+    /**
+     * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
+     * be used.
+     *
+     * @deprecated {@code SSLSocketFactory} does not expose its {@link X509TrustManager}, which is
+     *     a field that OkHttp needs to build a clean certificate chain. This method instead must
+     *     use reflection to extract the trust manager. Applications should prefer to call {@link
+     *     #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.
+     */
+    public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
+      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
+      X509TrustManager trustManager = Platform.get().trustManager(sslSocketFactory);
+      if (trustManager == null) {
+        throw new IllegalStateException("Unable to extract the trust manager on " + Platform.get()
+            + ", sslSocketFactory is " + sslSocketFactory.getClass());
+      }
+      this.sslSocketFactory = sslSocketFactory;
+      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+      return this;
+    }
+
+    /**
+     * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
+     * system defaults will be used.
+     *
+     * <p>Most applications should not call this method, and instead use the system defaults. Those
+     * classes include special optimizations that can be lost if the implementations are decorated.
+     *
+     * <p>If necessary, you can create and configure the defaults yourself with the following code:
+     *
+     * <pre>   {@code
+     *
+     *   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+     *       TrustManagerFactory.getDefaultAlgorithm());
+     *   trustManagerFactory.init((KeyStore) null);
+     *   TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+     *   if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+     *     throw new IllegalStateException("Unexpected default trust managers:"
+     *         + Arrays.toString(trustManagers));
+     *   }
+     *   X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
+     *
+     *   SSLContext sslContext = SSLContext.getInstance("TLS");
+     *   sslContext.init(null, new TrustManager[] { trustManager }, null);
+     *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+     *
+     *   OkHttpClient client = new OkHttpClient.Builder()
+     *       .sslSocketFactory(sslSocketFactory, trustManager);
+     *       .build();
+     * }</pre>
+     */
+    public Builder sslSocketFactory(
+        SSLSocketFactory sslSocketFactory, X509TrustManager trustManager) {
+      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
+      if (trustManager == null) throw new NullPointerException("trustManager == null");
+      this.sslSocketFactory = sslSocketFactory;
+      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+      return this;
+    }
+
+    /**
+     * Sets the verifier used to confirm that response certificates apply to requested hostnames for
+     * HTTPS connections.
+     *
+     * <p>If unset, a default hostname verifier will be used.
+     */
+    public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
+      if (hostnameVerifier == null) throw new NullPointerException("hostnameVerifier == null");
+      this.hostnameVerifier = hostnameVerifier;
+      return this;
+    }
+
+    /**
+     * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
+     * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish trust.
+     * Pinning certificates avoids the need to trust certificate authorities.
+     */
+    public Builder certificatePinner(CertificatePinner certificatePinner) {
+      if (certificatePinner == null) throw new NullPointerException("certificatePinner == null");
+      this.certificatePinner = certificatePinner;
+      return this;
+    }
+
+    /**
+     * Sets the authenticator used to respond to challenges from origin servers. Use {@link
+     * #proxyAuthenticator} to set the authenticator for proxy servers.
+     *
+     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
+     */
+    public Builder authenticator(Authenticator authenticator) {
+      if (authenticator == null) throw new NullPointerException("authenticator == null");
+      this.authenticator = authenticator;
+      return this;
+    }
+
+    /**
+     * Sets the authenticator used to respond to challenges from proxy servers. Use {@link
+     * #authenticator} to set the authenticator for origin servers.
+     *
+     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
+     */
+    public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {
+      if (proxyAuthenticator == null) throw new NullPointerException("proxyAuthenticator == null");
+      this.proxyAuthenticator = proxyAuthenticator;
+      return this;
+    }
+
+    /**
+     * Sets the connection pool used to recycle HTTP and HTTPS connections.
+     *
+     * <p>If unset, a new connection pool will be used.
+     */
+    public Builder connectionPool(ConnectionPool connectionPool) {
+      if (connectionPool == null) throw new NullPointerException("connectionPool == null");
+      this.connectionPool = connectionPool;
+      return this;
+    }
+
+    /**
+     * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
+     *
+     * <p>If unset, protocol redirects will be followed. This is different than the built-in {@code
+     * HttpURLConnection}'s default.
+     */
+    public Builder followSslRedirects(boolean followProtocolRedirects) {
+      this.followSslRedirects = followProtocolRedirects;
+      return this;
+    }
+
+    /** Configure this client to follow redirects. If unset, redirects be followed. */
+    public Builder followRedirects(boolean followRedirects) {
+      this.followRedirects = followRedirects;
+      return this;
+    }
+
+    /**
+     * Configure this client to retry or not when a connectivity problem is encountered. By default,
+     * this client silently recovers from the following problems:
+     *
+     * <ul>
+     *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
+     *       failure to reach any individual IP address doesn't fail the overall request. This can
+     *       increase availability of multi-homed services.
+     *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
+     *       to decrease request latency, but these connections will occasionally time out.
+     *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
+     *       attempt multiple proxy servers in sequence, eventually falling back to a direct
+     *       connection.
+     * </ul>
+     *
+     * Set this to false to avoid retrying requests when doing so is destructive. In this case the
+     * calling application should do its own recovery of connectivity failures.
+     */
+    public Builder retryOnConnectionFailure(boolean retryOnConnectionFailure) {
+      this.retryOnConnectionFailure = retryOnConnectionFailure;
+      return this;
+    }
+
+    /**
+     * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
+     */
+    public Builder dispatcher(Dispatcher dispatcher) {
+      if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
+      this.dispatcher = dispatcher;
+      return this;
+    }
+
+    /**
+     * Configure the protocols used by this client to communicate with remote servers. By default
+     * this client will prefer the most efficient transport available, falling back to more
+     * ubiquitous protocols. Applications should only call this method to avoid specific
+     * compatibility problems, such as web servers that behave incorrectly when SPDY is enabled.
+     *
+     * <p>The following protocols are currently supported:
+     *
+     * <ul>
+     *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
+     *     <li><a
+     *         href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
+     *     <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
+     * </ul>
+     *
+     * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
+     * protocols. The http/1.1 transport will never be dropped.
+     *
+     * <p>If multiple protocols are specified, <a
+     * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
+     * negotiate a transport.
+     *
+     * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
+     * HTTP/1.1} only. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
+     * Response#protocol()}.
+     *
+     * @param protocols the protocols to use, in order of preference. The list must contain {@link
+     * Protocol#HTTP_1_1}. It must not contain null or {@link Protocol#HTTP_1_0}.
+     */
+    public Builder protocols(List<Protocol> protocols) {
+      protocols = Util.immutableList(protocols);
+      if (!protocols.contains(Protocol.HTTP_1_1)) {
+        throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
+      }
+      if (protocols.contains(Protocol.HTTP_1_0)) {
+        throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
+      }
+      if (protocols.contains(null)) {
+        throw new IllegalArgumentException("protocols must not contain null");
+      }
+      this.protocols = Util.immutableList(protocols);
+      return this;
+    }
+
+    public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
+      this.connectionSpecs = Util.immutableList(connectionSpecs);
+      return this;
+    }
+
+    /**
+     * Returns a modifiable list of interceptors that observe the full span of each call: from
+     * before the connection is established (if any) until after the response source is selected
+     * (either the origin server, cache, or both).
+     */
+    public List<Interceptor> interceptors() {
+      return interceptors;
+    }
+
+    public Builder addInterceptor(Interceptor interceptor) {
+      interceptors.add(interceptor);
+      return this;
+    }
+
+    /**
+     * Returns a modifiable list of interceptors that observe a single network request and response.
+     * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error
+     * for a network interceptor to short-circuit or repeat a network request.
+     */
+    public List<Interceptor> networkInterceptors() {
+      return networkInterceptors;
+    }
+
+    public Builder addNetworkInterceptor(Interceptor interceptor) {
+      networkInterceptors.add(interceptor);
+      return this;
+    }
+
+    public OkHttpClient build() {
+      return new OkHttpClient(this);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/okhttp3/Protocol.java
similarity index 65%
rename from okhttp/src/main/java/com/squareup/okhttp/Protocol.java
rename to okhttp/src/main/java/okhttp3/Protocol.java
index 6b02098133..eec1c1219c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp/src/main/java/okhttp3/Protocol.java
@@ -13,58 +13,51 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.io.IOException;
 
 /**
  * Protocols that OkHttp implements for <a
- * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
- * selection.
+ * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> selection.
  *
- * <h3>Protocol vs Scheme</h3>
- * Despite its name, {@link java.net.URL#getProtocol()} returns the
- * {@linkplain java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not
- * the protocol (http/1.1, spdy/3.1, etc.). OkHttp uses the word <i>protocol</i>
- * to identify how HTTP messages are framed.
+ * <h3>Protocol vs Scheme</h3> Despite its name, {@link java.net.URL#getProtocol()} returns the
+ * {@linkplain java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not the protocol
+ * (http/1.1, spdy/3.1, etc.). OkHttp uses the word <i>protocol</i> to identify how HTTP messages
+ * are framed.
  */
 public enum Protocol {
   /**
-   * An obsolete plaintext framing that does not use persistent sockets by
-   * default.
+   * An obsolete plaintext framing that does not use persistent sockets by default.
    */
   HTTP_1_0("http/1.0"),
 
   /**
    * A plaintext framing that includes persistent connections.
    *
-   * <p>This version of OkHttp implements <a
-   * href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>, and tracks
-   * revisions to that spec.
+   * <p>This version of OkHttp implements <a href="http://www.ietf.org/rfc/rfc2616.txt">RFC
+   * 2616</a>, and tracks revisions to that spec.
    */
   HTTP_1_1("http/1.1"),
 
   /**
-   * Chromium's binary-framed protocol that includes header compression,
-   * multiplexing multiple requests on the same socket, and server-push.
-   * HTTP/1.1 semantics are layered on SPDY/3.
+   * Chromium's binary-framed protocol that includes header compression, multiplexing multiple
+   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on SPDY/3.
    *
    * <p>This version of OkHttp implements SPDY 3 <a
-   * href="http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">draft
-   * 3.1</a>. Future releases of OkHttp may use this identifier for a newer draft
-   * of the SPDY spec.
+   * href="http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">draft 3.1</a>. Future
+   * releases of OkHttp may use this identifier for a newer draft of the SPDY spec.
    */
   SPDY_3("spdy/3.1"),
 
   /**
-   * The IETF's binary-framed protocol that includes header compression,
-   * multiplexing multiple requests on the same socket, and server-push.
-   * HTTP/1.1 semantics are layered on HTTP/2.
+   * The IETF's binary-framed protocol that includes header compression, multiplexing multiple
+   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on HTTP/2.
    *
-   * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support
-   * {@linkplain com.squareup.okhttp.CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256}
-   * , present in Java 8+ and Android 5+. Servers that enforce this may send an
-   * exception message including the string {@code INADEQUATE_SECURITY}.
+   * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support {@linkplain
+   * CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256} , present in Java 8+ and Android 5+. Servers
+   * that enforce this may send an exception message including the string {@code
+   * INADEQUATE_SECURITY}.
    */
   HTTP_2("h2");
 
@@ -76,6 +69,7 @@
 
   /**
    * Returns the protocol identified by {@code protocol}.
+   *
    * @throws IOException if {@code protocol} is unknown.
    */
   public static Protocol get(String protocol) throws IOException {
@@ -88,8 +82,8 @@ public static Protocol get(String protocol) throws IOException {
   }
 
   /**
-   * Returns the string used to identify this protocol for ALPN, like
-   * "http/1.1", "spdy/3.1" or "h2".
+   * Returns the string used to identify this protocol for ALPN, like "http/1.1", "spdy/3.1" or
+   * "h2".
    */
   @Override public String toString() {
     return protocol;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/okhttp3/RealCall.java
similarity index 60%
rename from okhttp/src/main/java/com/squareup/okhttp/Call.java
rename to okhttp/src/main/java/okhttp3/RealCall.java
index 33561ba24e..d2ecfdcbdd 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -13,25 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.RequestException;
-import com.squareup.okhttp.internal.http.RouteException;
 import java.io.IOException;
 import java.net.ProtocolException;
-import java.util.logging.Level;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Platform;
+import okhttp3.internal.http.HttpEngine;
+import okhttp3.internal.http.RequestException;
+import okhttp3.internal.http.RouteException;
+import okhttp3.internal.http.StreamAllocation;
 
-import static com.squareup.okhttp.internal.Internal.logger;
-import static com.squareup.okhttp.internal.http.HttpEngine.MAX_FOLLOW_UPS;
+import static okhttp3.internal.Platform.INFO;
+import static okhttp3.internal.http.HttpEngine.MAX_FOLLOW_UPS;
 
-/**
- * A call is a request that has been prepared for execution. A call can be
- * canceled. As this object represents a single request/response pair (stream),
- * it cannot be executed twice.
- */
-public class Call {
+final class RealCall implements Call {
   private final OkHttpClient client;
 
   // Guarded by this.
@@ -42,45 +38,27 @@
   Request originalRequest;
   HttpEngine engine;
 
-  protected Call(OkHttpClient client, Request originalRequest) {
-    // Copy the client. Otherwise changes (socket factory, redirect policy,
-    // etc.) may incorrectly be reflected in the request when it is executed.
-    this.client = client.copyWithDefaults();
+  protected RealCall(OkHttpClient client, Request originalRequest) {
+    this.client = client;
     this.originalRequest = originalRequest;
   }
 
-  /**
-   * Invokes the request immediately, and blocks until the response can be
-   * processed or is in error.
-   *
-   * <p>The caller may read the response body with the response's
-   * {@link Response#body} method.  To facilitate connection recycling, callers
-   * should always {@link ResponseBody#close() close the response body}.
-   *
-   * <p>Note that transport-layer success (receiving a HTTP response code,
-   * headers and body) does not necessarily indicate application-layer success:
-   * {@code response} may still indicate an unhappy HTTP response code like 404
-   * or 500.
-   *
-   * @throws IOException if the request could not be executed due to
-   *     cancellation, a connectivity problem or timeout. Because networks can
-   *     fail during an exchange, it is possible that the remote server
-   *     accepted the request before the failure.
-   *
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  public Response execute() throws IOException {
+  @Override public Request request() {
+    return originalRequest;
+  }
+
+  @Override public Response execute() throws IOException {
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
     try {
-      client.getDispatcher().executed(this);
+      client.dispatcher().executed(this);
       Response result = getResponseWithInterceptorChain(false);
       if (result == null) throw new IOException("Canceled");
       return result;
     } finally {
-      client.getDispatcher().finished(this);
+      client.dispatcher().finished(this);
     }
   }
 
@@ -88,20 +66,7 @@ Object tag() {
     return originalRequest.tag();
   }
 
-  /**
-   * Schedules the request to be executed at some point in the future.
-   *
-   * <p>The {@link OkHttpClient#getDispatcher dispatcher} defines when the
-   * request will run: usually immediately unless there are several other
-   * requests currently being executed.
-   *
-   * <p>This client will later call back {@code responseCallback} with either
-   * an HTTP response or a failure exception. If you {@link #cancel} a request
-   * before it completes the callback will not be invoked.
-   *
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  public void enqueue(Callback responseCallback) {
+  @Override public void enqueue(Callback responseCallback) {
     enqueue(responseCallback, false);
   }
 
@@ -110,19 +75,19 @@ void enqueue(Callback responseCallback, boolean forWebSocket) {
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
-    client.getDispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));
+    client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));
   }
 
-  /**
-   * Cancels the request, if possible. Requests that are already complete
-   * cannot be canceled.
-   */
-  public void cancel() {
+  @Override public void cancel() {
     canceled = true;
-    if (engine != null) engine.disconnect();
+    if (engine != null) engine.cancel();
+  }
+
+  @Override public synchronized boolean isExecuted() {
+    return executed;
   }
 
-  public boolean isCanceled() {
+  @Override public boolean isCanceled() {
     return canceled;
   }
 
@@ -131,13 +96,13 @@ public boolean isCanceled() {
     private final boolean forWebSocket;
 
     private AsyncCall(Callback responseCallback, boolean forWebSocket) {
-      super("OkHttp %s", originalRequest.urlString());
+      super("OkHttp %s", redactedUrl().toString());
       this.responseCallback = responseCallback;
       this.forWebSocket = forWebSocket;
     }
 
     String host() {
-      return originalRequest.httpUrl().host();
+      return originalRequest.url().host();
     }
 
     Request request() {
@@ -149,11 +114,11 @@ Object tag() {
     }
 
     void cancel() {
-      Call.this.cancel();
+      RealCall.this.cancel();
     }
 
-    Call get() {
-      return Call.this;
+    RealCall get() {
+      return RealCall.this;
     }
 
     @Override protected void execute() {
@@ -162,20 +127,20 @@ Call get() {
         Response response = getResponseWithInterceptorChain(forWebSocket);
         if (canceled) {
           signalledCallback = true;
-          responseCallback.onFailure(originalRequest, new IOException("Canceled"));
+          responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
         } else {
           signalledCallback = true;
-          responseCallback.onResponse(response);
+          responseCallback.onResponse(RealCall.this, response);
         }
       } catch (IOException e) {
         if (signalledCallback) {
           // Do not signal the callback twice!
-          logger.log(Level.INFO, "Callback failure for " + toLoggableString(), e);
+          Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
         } else {
-          responseCallback.onFailure(engine.getRequest(), e);
+          responseCallback.onFailure(RealCall.this, e);
         }
       } finally {
-        client.getDispatcher().finished(this);
+        client.dispatcher().finished(this);
       }
     }
   }
@@ -186,8 +151,11 @@ Call get() {
    */
   private String toLoggableString() {
     String string = canceled ? "canceled call" : "call";
-    HttpUrl redactedUrl = originalRequest.httpUrl().resolve("/...");
-    return string + " to " + redactedUrl;
+    return string + " to " + redactedUrl();
+  }
+
+  HttpUrl redactedUrl() {
+    return originalRequest.url().resolve("/...");
   }
 
   private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException {
@@ -215,20 +183,27 @@ private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IO
     }
 
     @Override public Response proceed(Request request) throws IOException {
+      // If there's another interceptor in the chain, call that.
       if (index < client.interceptors().size()) {
-        // There's another interceptor in the chain. Call that.
         Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);
-        return client.interceptors().get(index).intercept(chain);
-      } else {
-        // No more interceptors. Do HTTP.
-        return getResponse(request, forWebSocket);
+        Interceptor interceptor = client.interceptors().get(index);
+        Response interceptedResponse = interceptor.intercept(chain);
+
+        if (interceptedResponse == null) {
+          throw new NullPointerException("application interceptor " + interceptor
+              + " returned null");
+        }
+
+        return interceptedResponse;
       }
+
+      // No more interceptors. Do HTTP.
+      return getResponse(request, forWebSocket);
     }
   }
 
   /**
-   * Performs the request and returns the response. May return null if this
-   * call was canceled.
+   * Performs the request and returns the response. May return null if this call was canceled.
    */
   Response getResponse(Request request, boolean forWebSocket) throws IOException {
     // Copy body metadata to the appropriate request headers.
@@ -254,25 +229,28 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
     }
 
     // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
-    engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null, null);
+    engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null);
 
     int followUpCount = 0;
     while (true) {
       if (canceled) {
-        engine.releaseConnection();
+        engine.releaseStreamAllocation();
         throw new IOException("Canceled");
       }
 
+      boolean releaseConnection = true;
       try {
         engine.sendRequest();
         engine.readResponse();
+        releaseConnection = false;
       } catch (RequestException e) {
         // The attempt to interpret the request failed. Give up.
         throw e.getCause();
       } catch (RouteException e) {
         // The attempt to connect via a route failed. The request will not have been sent.
-        HttpEngine retryEngine = engine.recover(e);
+        HttpEngine retryEngine = engine.recover(e.getLastConnectException(), true, null);
         if (retryEngine != null) {
+          releaseConnection = false;
           engine = retryEngine;
           continue;
         }
@@ -280,14 +258,21 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
         throw e.getLastConnectException();
       } catch (IOException e) {
         // An attempt to communicate with a server failed. The request may have been sent.
-        HttpEngine retryEngine = engine.recover(e, null);
+        HttpEngine retryEngine = engine.recover(e, false, null);
         if (retryEngine != null) {
+          releaseConnection = false;
           engine = retryEngine;
           continue;
         }
 
         // Give up; recovery is not possible.
         throw e;
+      } finally {
+        // We're throwing an unchecked exception. Release any resources.
+        if (releaseConnection) {
+          StreamAllocation streamAllocation = engine.close();
+          streamAllocation.release();
+        }
       }
 
       Response response = engine.getResponse();
@@ -295,22 +280,25 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
 
       if (followUp == null) {
         if (!forWebSocket) {
-          engine.releaseConnection();
+          engine.releaseStreamAllocation();
         }
         return response;
       }
 
+      StreamAllocation streamAllocation = engine.close();
+
       if (++followUpCount > MAX_FOLLOW_UPS) {
+        streamAllocation.release();
         throw new ProtocolException("Too many follow-up requests: " + followUpCount);
       }
 
-      if (!engine.sameConnection(followUp.httpUrl())) {
-        engine.releaseConnection();
+      if (!engine.sameConnection(followUp.url())) {
+        streamAllocation.release();
+        streamAllocation = null;
       }
 
-      Connection connection = engine.close();
       request = followUp;
-      engine = new HttpEngine(client, request, false, false, forWebSocket, connection, null, null,
+      engine = new HttpEngine(client, request, false, false, forWebSocket, streamAllocation, null,
           response);
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/okhttp3/Request.java
similarity index 77%
rename from okhttp/src/main/java/com/squareup/okhttp/Request.java
rename to okhttp/src/main/java/okhttp3/Request.java
index 2417c132aa..89188ec587 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -13,17 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.http.HttpMethod;
-import java.io.IOException;
-import java.net.URI;
 import java.net.URL;
 import java.util.List;
+import okhttp3.internal.http.HttpMethod;
 
 /**
- * An HTTP request. Instances of this class are immutable if their {@link #body}
- * is null or itself immutable.
+ * An HTTP request. Instances of this class are immutable if their {@link #body} is null or itself
+ * immutable.
  */
 public final class Request {
   private final HttpUrl url;
@@ -32,8 +30,6 @@
   private final RequestBody body;
   private final Object tag;
 
-  private volatile URL javaNetUrl; // Lazily initialized.
-  private volatile URI javaNetUri; // Lazily initialized.
   private volatile CacheControl cacheControl; // Lazily initialized.
 
   private Request(Builder builder) {
@@ -44,28 +40,10 @@ private Request(Builder builder) {
     this.tag = builder.tag != null ? builder.tag : this;
   }
 
-  public HttpUrl httpUrl() {
+  public HttpUrl url() {
     return url;
   }
 
-  public URL url() {
-    URL result = javaNetUrl;
-    return result != null ? result : (javaNetUrl = url.url());
-  }
-
-  public URI uri() throws IOException {
-    try {
-      URI result = javaNetUri;
-      return result != null ? result : (javaNetUri = url.uri());
-    } catch (IllegalStateException e) {
-      throw new IOException(e.getMessage());
-    }
-  }
-
-  public String urlString() {
-    return url.toString();
-  }
-
   public String method() {
     return method;
   }
@@ -95,8 +73,8 @@ public Builder newBuilder() {
   }
 
   /**
-   * Returns the cache control directives for this response. This is never null,
-   * even if this response contains no {@code Cache-Control} header.
+   * Returns the cache control directives for this response. This is never null, even if this
+   * response contains no {@code Cache-Control} header.
    */
   public CacheControl cacheControl() {
     CacheControl result = cacheControl;
@@ -138,7 +116,7 @@ private Builder(Request request) {
     }
 
     public Builder url(HttpUrl url) {
-      if (url == null) throw new IllegalArgumentException("url == null");
+      if (url == null) throw new NullPointerException("url == null");
       this.url = url;
       return this;
     }
@@ -147,10 +125,10 @@ public Builder url(HttpUrl url) {
      * Sets the URL target of this request.
      *
      * @throws IllegalArgumentException if {@code url} is not a valid HTTP or HTTPS URL. Avoid this
-     *     exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs.
+     * exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs.
      */
     public Builder url(String url) {
-      if (url == null) throw new IllegalArgumentException("url == null");
+      if (url == null) throw new NullPointerException("url == null");
 
       // Silently replace websocket URLs with HTTP URLs.
       if (url.regionMatches(true, 0, "ws:", 0, 3)) {
@@ -168,18 +146,18 @@ public Builder url(String url) {
      * Sets the URL target of this request.
      *
      * @throws IllegalArgumentException if the scheme of {@code url} is not {@code http} or {@code
-     *     https}.
+     * https}.
      */
     public Builder url(URL url) {
-      if (url == null) throw new IllegalArgumentException("url == null");
+      if (url == null) throw new NullPointerException("url == null");
       HttpUrl parsed = HttpUrl.get(url);
       if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
       return url(parsed);
     }
 
     /**
-     * Sets the header named {@code name} to {@code value}. If this request
-     * already has any headers with that name, they are all replaced.
+     * Sets the header named {@code name} to {@code value}. If this request already has any headers
+     * with that name, they are all replaced.
      */
     public Builder header(String name, String value) {
       headers.set(name, value);
@@ -187,8 +165,11 @@ public Builder header(String name, String value) {
     }
 
     /**
-     * Adds a header with {@code name} and {@code value}. Prefer this method for
-     * multiply-valued headers like "Cookie".
+     * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
+     * headers like "Cookie".
+     *
+     * <p>Note that for some headers including {@code Content-Length} and {@code Content-Encoding},
+     * OkHttp may replace {@code value} with a header derived from the request body.
      */
     public Builder addHeader(String name, String value) {
       headers.add(name, value);
@@ -207,9 +188,9 @@ public Builder headers(Headers headers) {
     }
 
     /**
-     * Sets this request's {@code Cache-Control} header, replacing any cache
-     * control headers already present. If {@code cacheControl} doesn't define
-     * any directives, this clears this request's cache-control headers.
+     * Sets this request's {@code Cache-Control} header, replacing any cache control headers already
+     * present. If {@code cacheControl} doesn't define any directives, this clears this request's
+     * cache-control headers.
      */
     public Builder cacheControl(CacheControl cacheControl) {
       String value = cacheControl.toString();
@@ -246,9 +227,8 @@ public Builder patch(RequestBody body) {
     }
 
     public Builder method(String method, RequestBody body) {
-      if (method == null || method.length() == 0) {
-        throw new IllegalArgumentException("method == null || method.length() == 0");
-      }
+      if (method == null) throw new NullPointerException("method == null");
+      if (method.length() == 0) throw new IllegalArgumentException("method.length() == 0");
       if (body != null && !HttpMethod.permitsRequestBody(method)) {
         throw new IllegalArgumentException("method " + method + " must not have a request body.");
       }
@@ -261,9 +241,8 @@ public Builder method(String method, RequestBody body) {
     }
 
     /**
-     * Attaches {@code tag} to the request. It can be used later to cancel the
-     * request. If the tag is unspecified or null, the request is canceled by
-     * using the request itself as the tag.
+     * Attaches {@code tag} to the request. It can be used later to cancel the request. If the tag
+     * is unspecified or null, the request is canceled by using the request itself as the tag.
      */
     public Builder tag(Object tag) {
       this.tag = tag;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java b/okhttp/src/main/java/okhttp3/RequestBody.java
similarity index 94%
rename from okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
rename to okhttp/src/main/java/okhttp3/RequestBody.java
index 50933f71fd..136cfdc4e3 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
+++ b/okhttp/src/main/java/okhttp3/RequestBody.java
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.File;
 import java.io.IOException;
 import java.nio.charset.Charset;
+import okhttp3.internal.Util;
 import okio.BufferedSink;
 import okio.ByteString;
 import okio.Okio;
@@ -29,8 +29,8 @@
   public abstract MediaType contentType();
 
   /**
-   * Returns the number of bytes that will be written to {@code out} in a call
-   * to {@link #writeTo}, or -1 if that count is unknown.
+   * Returns the number of bytes that will be written to {@code out} in a call to {@link #writeTo},
+   * or -1 if that count is unknown.
    */
   public long contentLength() throws IOException {
     return -1;
@@ -40,8 +40,8 @@ public long contentLength() throws IOException {
   public abstract void writeTo(BufferedSink sink) throws IOException;
 
   /**
-   * Returns a new request body that transmits {@code content}. If {@code
-   * contentType} is non-null and lacks a charset, this will use UTF-8.
+   * Returns a new request body that transmits {@code content}. If {@code contentType} is non-null
+   * and lacks a charset, this will use UTF-8.
    */
   public static RequestBody create(MediaType contentType, String content) {
     Charset charset = Util.UTF_8;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/okhttp3/Response.java
similarity index 67%
rename from okhttp/src/main/java/com/squareup/okhttp/Response.java
rename to okhttp/src/main/java/okhttp3/Response.java
index bf52795341..eb0cf4a7fb 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -13,25 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.http.OkHeaders;
+import java.io.IOException;
 import java.util.Collections;
 import java.util.List;
+import okhttp3.internal.http.OkHeaders;
+import okio.Buffer;
+import okio.BufferedSource;
 
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
 import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
 import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
 import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
 /**
- * An HTTP response. Instances of this class are not immutable: the response
- * body is a one-shot value that may be consumed only once. All other properties
- * are immutable.
+ * An HTTP response. Instances of this class are not immutable: the response body is a one-shot
+ * value that may be consumed only once. All other properties are immutable.
  */
 public final class Response {
   private final Request request;
@@ -44,6 +46,8 @@
   private Response networkResponse;
   private Response cacheResponse;
   private final Response priorResponse;
+  private final long sentRequestAtMillis;
+  private final long receivedResponseAtMillis;
 
   private volatile CacheControl cacheControl; // Lazily initialized.
 
@@ -58,11 +62,14 @@ private Response(Builder builder) {
     this.networkResponse = builder.networkResponse;
     this.cacheResponse = builder.cacheResponse;
     this.priorResponse = builder.priorResponse;
+    this.sentRequestAtMillis = builder.sentRequestAtMillis;
+    this.receivedResponseAtMillis = builder.receivedResponseAtMillis;
   }
 
   /**
    * The wire-level request that initiated this HTTP response. This is not
    * necessarily the same request issued by the application:
+   *
    * <ul>
    *     <li>It may be transformed by the HTTP client. For example, the client
    *         may copy headers like {@code Content-Length} from the request body.
@@ -76,8 +83,7 @@ public Request request() {
   }
 
   /**
-   * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link
-   * Protocol#HTTP_1_0}.
+   * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link Protocol#HTTP_1_0}.
    */
   public Protocol protocol() {
     return protocol;
@@ -89,8 +95,8 @@ public int code() {
   }
 
   /**
-   * Returns true if the code is in [200..300), which means the request was
-   * successfully received, understood, and accepted.
+   * Returns true if the code is in [200..300), which means the request was successfully received,
+   * understood, and accepted.
    */
   public boolean isSuccessful() {
     return code >= 200 && code < 300;
@@ -102,8 +108,8 @@ public String message() {
   }
 
   /**
-   * Returns the TLS handshake of the connection that carried this response, or
-   * null if the response was received without TLS.
+   * Returns the TLS handshake of the connection that carried this response, or null if the response
+   * was received without TLS.
    */
   public Handshake handshake() {
     return handshake;
@@ -126,6 +132,38 @@ public Headers headers() {
     return headers;
   }
 
+  /**
+   * Peeks up to {@code byteCount} bytes from the response body and returns them as a new response
+   * body. If fewer than {@code byteCount} bytes are in the response body, the full response body is
+   * returned. If more than {@code byteCount} bytes are in the response body, the returned value
+   * will be truncated to {@code byteCount} bytes.
+   *
+   * <p>It is an error to call this method after the body has been consumed.
+   *
+   * <p><strong>Warning:</strong> this method loads the requested bytes into memory. Most
+   * applications should set a modest limit on {@code byteCount}, such as 1 MiB.
+   */
+  public ResponseBody peekBody(long byteCount) throws IOException {
+    BufferedSource source = body.source();
+    source.request(byteCount);
+    Buffer copy = source.buffer().clone();
+
+    // There may be more than byteCount bytes in source.buffer(). If there is, return a prefix.
+    Buffer result;
+    if (copy.size() > byteCount) {
+      result = new Buffer();
+      result.write(copy, byteCount);
+      copy.clear();
+    } else {
+      result = copy;
+    }
+
+    return ResponseBody.create(body.contentType(), result.size(), result);
+  }
+
+  /**
+   * Never {@code null}, must be closed after consumption, can be consumed only once.
+   */
   public ResponseBody body() {
     return body;
   }
@@ -150,40 +188,38 @@ public boolean isRedirect() {
   }
 
   /**
-   * Returns the raw response received from the network. Will be null if this
-   * response didn't use the network, such as when the response is fully cached.
-   * The body of the returned response should not be read.
+   * Returns the raw response received from the network. Will be null if this response didn't use
+   * the network, such as when the response is fully cached. The body of the returned response
+   * should not be read.
    */
   public Response networkResponse() {
     return networkResponse;
   }
 
   /**
-   * Returns the raw response received from the cache. Will be null if this
-   * response didn't use the cache. For conditional get requests the cache
-   * response and network response may both be non-null. The body of the
-   * returned response should not be read.
+   * Returns the raw response received from the cache. Will be null if this response didn't use the
+   * cache. For conditional get requests the cache response and network response may both be
+   * non-null. The body of the returned response should not be read.
    */
   public Response cacheResponse() {
     return cacheResponse;
   }
 
   /**
-   * Returns the response for the HTTP redirect or authorization challenge that
-   * triggered this response, or null if this response wasn't triggered by an
-   * automatic retry. The body of the returned response should not be read
-   * because it has already been consumed by the redirecting client.
+   * Returns the response for the HTTP redirect or authorization challenge that triggered this
+   * response, or null if this response wasn't triggered by an automatic retry. The body of the
+   * returned response should not be read because it has already been consumed by the redirecting
+   * client.
    */
   public Response priorResponse() {
     return priorResponse;
   }
 
   /**
-   * Returns the authorization challenges appropriate for this response's code.
-   * If the response code is 401 unauthorized, this returns the
-   * "WWW-Authenticate" challenges. If the response code is 407 proxy
-   * unauthorized, this returns the "Proxy-Authenticate" challenges. Otherwise
-   * this returns an empty list of challenges.
+   * Returns the authorization challenges appropriate for this response's code. If the response code
+   * is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the response code is
+   * 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges. Otherwise this
+   * returns an empty list of challenges.
    */
   public List<Challenge> challenges() {
     String responseField;
@@ -198,14 +234,32 @@ public Response priorResponse() {
   }
 
   /**
-   * Returns the cache control directives for this response. This is never null,
-   * even if this response contains no {@code Cache-Control} header.
+   * Returns the cache control directives for this response. This is never null, even if this
+   * response contains no {@code Cache-Control} header.
    */
   public CacheControl cacheControl() {
     CacheControl result = cacheControl;
     return result != null ? result : (cacheControl = CacheControl.parse(headers));
   }
 
+  /**
+   * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately before OkHttp
+   * transmitted the initiating request over the network. If this response is being served from the
+   * cache then this is the timestamp of the original request.
+   */
+  public long sentRequestAtMillis() {
+    return sentRequestAtMillis;
+  }
+
+  /**
+   * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately after OkHttp
+   * received this response's headers from the network. If this response is being served from the
+   * cache then this is the timestamp of the original response.
+   */
+  public long receivedResponseAtMillis() {
+    return receivedResponseAtMillis;
+  }
+
   @Override public String toString() {
     return "Response{protocol="
         + protocol
@@ -214,7 +268,7 @@ public CacheControl cacheControl() {
         + ", message="
         + message
         + ", url="
-        + request.urlString()
+        + request.url()
         + '}';
   }
 
@@ -229,6 +283,8 @@ public CacheControl cacheControl() {
     private Response networkResponse;
     private Response cacheResponse;
     private Response priorResponse;
+    private long sentRequestAtMillis;
+    private long receivedResponseAtMillis;
 
     public Builder() {
       headers = new Headers.Builder();
@@ -245,6 +301,8 @@ private Builder(Response response) {
       this.networkResponse = response.networkResponse;
       this.cacheResponse = response.cacheResponse;
       this.priorResponse = response.priorResponse;
+      this.sentRequestAtMillis = response.sentRequestAtMillis;
+      this.receivedResponseAtMillis = response.receivedResponseAtMillis;
     }
 
     public Builder request(Request request) {
@@ -273,8 +331,8 @@ public Builder handshake(Handshake handshake) {
     }
 
     /**
-     * Sets the header named {@code name} to {@code value}. If this request
-     * already has any headers with that name, they are all replaced.
+     * Sets the header named {@code name} to {@code value}. If this request already has any headers
+     * with that name, they are all replaced.
      */
     public Builder header(String name, String value) {
       headers.set(name, value);
@@ -282,8 +340,8 @@ public Builder header(String name, String value) {
     }
 
     /**
-     * Adds a header with {@code name} and {@code value}. Prefer this method for
-     * multiply-valued headers like "Set-Cookie".
+     * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
+     * headers like "Set-Cookie".
      */
     public Builder addHeader(String name, String value) {
       headers.add(name, value);
@@ -342,6 +400,16 @@ private void checkPriorResponse(Response response) {
       }
     }
 
+    public Builder sentRequestAtMillis(long sentRequestAtMillis) {
+      this.sentRequestAtMillis = sentRequestAtMillis;
+      return this;
+    }
+
+    public Builder receivedResponseAtMillis(long receivedResponseAtMillis) {
+      this.receivedResponseAtMillis = receivedResponseAtMillis;
+      return this;
+    }
+
     public Response build() {
       if (request == null) throw new IllegalStateException("request == null");
       if (protocol == null) throw new IllegalStateException("protocol == null");
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
similarity index 59%
rename from okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
rename to okhttp/src/main/java/okhttp3/ResponseBody.java
index bdd98b4c69..98223bbad1 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.java
@@ -13,20 +13,46 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
-import com.squareup.okhttp.internal.Util;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
 import java.nio.charset.Charset;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
 
-import static com.squareup.okhttp.internal.Util.UTF_8;
+import static okhttp3.internal.Util.UTF_8;
 
+/**
+ * A one-shot stream from the origin server to the client application with the raw bytes of the
+ * response body. Each response body is supported by an active connection to the webserver. This
+ * imposes both obligations and limits on the client application.
+ *
+ * <h3>The response body must be closed.</h3>
+ *
+ * <p>Each response body is backed by a limited resource like a socket (live network responses) or
+ * an open file (for cached responses). Failing to close the response body will leak these resources
+ * and may ultimately cause the application to slow down or crash. Close the response body by
+ * calling either {@link ResponseBody#close close()}, {@link InputStream#close()
+ * byteStream().close()}, or {@link Reader#close() reader().close()}. The {@link #bytes()} and
+ * {@link #string()} methods both close the response body automatically.
+ *
+ * <h3>The response body can be consumed only once.</h3>
+ *
+ * <p>This class may be used to stream very large responses. For example, it is possible to use this
+ * class to read a response that is larger than the entire memory allocated to the current process.
+ * It can even stream a response larger than the total storage on the current device, which is a
+ * common requirement for video streaming applications.
+ *
+ * <p>Because this class does not buffer the full response in memory, the application may not
+ * re-read the bytes of the response. Use this one shot to read the entire response into memory with
+ * {@link #bytes()} or {@link #string()}. Or stream the response with either {@link #source()},
+ * {@link #byteStream()}, or {@link #charStream()}.
+ */
 public abstract class ResponseBody implements Closeable {
   /** Multiple calls to {@link #charStream()} must return the same instance. */
   private Reader reader;
@@ -34,16 +60,16 @@
   public abstract MediaType contentType();
 
   /**
-   * Returns the number of bytes in that will returned by {@link #bytes}, or
-   * {@link #byteStream}, or -1 if unknown.
+   * Returns the number of bytes in that will returned by {@link #bytes}, or {@link #byteStream}, or
+   * -1 if unknown.
    */
-  public abstract long contentLength() throws IOException;
+  public abstract long contentLength();
 
-  public final InputStream byteStream() throws IOException {
+  public final InputStream byteStream() {
     return source().inputStream();
   }
 
-  public abstract BufferedSource source() throws IOException;
+  public abstract BufferedSource source();
 
   public final byte[] bytes() throws IOException {
     long contentLength = contentLength();
@@ -65,19 +91,19 @@ public final InputStream byteStream() throws IOException {
   }
 
   /**
-   * Returns the response as a character stream decoded with the charset
-   * of the Content-Type header. If that header is either absent or lacks a
-   * charset, this will attempt to decode the response body as UTF-8.
+   * Returns the response as a character stream decoded with the charset of the Content-Type header.
+   * If that header is either absent or lacks a charset, this will attempt to decode the response
+   * body as UTF-8.
    */
-  public final Reader charStream() throws IOException {
+  public final Reader charStream() {
     Reader r = reader;
     return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
   }
 
   /**
-   * Returns the response as a string decoded with the charset of the
-   * Content-Type header. If that header is either absent or lacks a charset,
-   * this will attempt to decode the response body as UTF-8.
+   * Returns the response as a string decoded with the charset of the Content-Type header. If that
+   * header is either absent or lacks a charset, this will attempt to decode the response body as
+   * UTF-8.
    */
   public final String string() throws IOException {
     return new String(bytes(), charset().name());
@@ -88,20 +114,20 @@ private Charset charset() {
     return contentType != null ? contentType.charset(UTF_8) : UTF_8;
   }
 
-  @Override public void close() throws IOException {
-    source().close();
+  @Override public void close() {
+    Util.closeQuietly(source());
   }
 
   /**
-   * Returns a new response body that transmits {@code content}. If {@code
-   * contentType} is non-null and lacks a charset, this will use UTF-8.
+   * Returns a new response body that transmits {@code content}. If {@code contentType} is non-null
+   * and lacks a charset, this will use UTF-8.
    */
   public static ResponseBody create(MediaType contentType, String content) {
-    Charset charset = Util.UTF_8;
+    Charset charset = UTF_8;
     if (contentType != null) {
       charset = contentType.charset();
       if (charset == null) {
-        charset = Util.UTF_8;
+        charset = UTF_8;
         contentType = MediaType.parse(contentType + "; charset=utf-8");
       }
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Route.java b/okhttp/src/main/java/okhttp3/Route.java
similarity index 74%
rename from okhttp/src/main/java/com/squareup/okhttp/Route.java
rename to okhttp/src/main/java/okhttp3/Route.java
index 2d27a03090..8aaa0f5b85 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Route.java
+++ b/okhttp/src/main/java/okhttp3/Route.java
@@ -13,23 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package okhttp3;
 
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 
 /**
- * The concrete route used by a connection to reach an abstract origin server.
- * When creating a connection the client has many options:
+ * The concrete route used by a connection to reach an abstract origin server. When creating a
+ * connection the client has many options:
+ *
  * <ul>
- *   <li><strong>HTTP proxy:</strong> a proxy server may be explicitly
- *       configured for the client. Otherwise the {@linkplain java.net.ProxySelector
- *       proxy selector} is used. It may return multiple proxies to attempt.
- *   <li><strong>IP address:</strong> whether connecting directly to an origin
- *       server or a proxy, opening a socket requires an IP address. The DNS
- *       server may return multiple IP addresses to attempt.
+ *     <li><strong>HTTP proxy:</strong> a proxy server may be explicitly configured for the client.
+ *         Otherwise the {@linkplain java.net.ProxySelector proxy selector} is used. It may return
+ *         multiple proxies to attempt.
+ *     <li><strong>IP address:</strong> whether connecting directly to an origin server or a proxy,
+ *         opening a socket requires an IP address. The DNS server may return multiple IP addresses
+ *         to attempt.
  * </ul>
- * Each route is a specific selection of these options.
+ *
+ * <p>Each route is a specific selection of these options.
  */
 public final class Route {
   final Address address;
@@ -51,22 +53,21 @@ public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress)
     this.inetSocketAddress = inetSocketAddress;
   }
 
-  public Address getAddress() {
+  public Address address() {
     return address;
   }
 
   /**
    * Returns the {@link Proxy} of this route.
    *
-   * <strong>Warning:</strong> This may disagree with {@link Address#getProxy}
-   * when it is null. When the address's proxy is null, the proxy selector is
-   * used.
+   * <strong>Warning:</strong> This may disagree with {@link Address#proxy} when it is null. When
+   * the address's proxy is null, the proxy selector is used.
    */
-  public Proxy getProxy() {
+  public Proxy proxy() {
     return proxy;
   }
 
-  public InetSocketAddress getSocketAddress() {
+  public InetSocketAddress socketAddress() {
     return inetSocketAddress;
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java b/okhttp/src/main/java/okhttp3/TlsVersion.java
similarity index 78%
rename from okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
rename to okhttp/src/main/java/okhttp3/TlsVersion.java
index bfa95c410b..668cd9732b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
+++ b/okhttp/src/main/java/okhttp3/TlsVersion.java
@@ -13,13 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
-
-import javax.net.ssl.SSLSocket;
+package okhttp3;
 
 /**
- * Versions of TLS that can be offered when negotiating a secure socket. See
- * {@link SSLSocket#setEnabledProtocols}.
+ * Versions of TLS that can be offered when negotiating a secure socket. See {@link
+ * javax.net.ssl.SSLSocket#setEnabledProtocols}.
  */
 public enum TlsVersion {
   TLS_1_2("TLSv1.2"), // 2008.
@@ -30,16 +28,20 @@
 
   final String javaName;
 
-  private TlsVersion(String javaName) {
+  TlsVersion(String javaName) {
     this.javaName = javaName;
   }
 
   public static TlsVersion forJavaName(String javaName) {
     switch (javaName) {
-      case "TLSv1.2": return TLS_1_2;
-      case "TLSv1.1": return TLS_1_1;
-      case "TLSv1": return TLS_1_0;
-      case "SSLv3": return SSL_3_0;
+      case "TLSv1.2":
+        return TLS_1_2;
+      case "TLSv1.1":
+        return TLS_1_1;
+      case "TLSv1":
+        return TLS_1_0;
+      case "SSLv3":
+        return SSL_3_0;
     }
     throw new IllegalArgumentException("Unexpected TLS version: " + javaName);
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/AndroidPlatform.java b/okhttp/src/main/java/okhttp3/internal/AndroidPlatform.java
new file mode 100644
index 0000000000..65e97020b2
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/AndroidPlatform.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import android.util.Log;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.util.List;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.Protocol;
+
+/** Android 2.3 or better. */
+class AndroidPlatform extends Platform {
+  private static final int MAX_LOG_LENGTH = 4000;
+
+  private final Class<?> sslParametersClass;
+  private final OptionalMethod<Socket> setUseSessionTickets;
+  private final OptionalMethod<Socket> setHostname;
+
+  // Non-null on Android 5.0+.
+  private final OptionalMethod<Socket> getAlpnSelectedProtocol;
+  private final OptionalMethod<Socket> setAlpnProtocols;
+
+  public AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSessionTickets,
+      OptionalMethod<Socket> setHostname, OptionalMethod<Socket> getAlpnSelectedProtocol,
+      OptionalMethod<Socket> setAlpnProtocols) {
+    this.sslParametersClass = sslParametersClass;
+    this.setUseSessionTickets = setUseSessionTickets;
+    this.setHostname = setHostname;
+    this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
+    this.setAlpnProtocols = setAlpnProtocols;
+  }
+
+  @Override public void connectSocket(Socket socket, InetSocketAddress address,
+      int connectTimeout) throws IOException {
+    try {
+      socket.connect(address, connectTimeout);
+    } catch (AssertionError e) {
+      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
+      throw e;
+    } catch (SecurityException e) {
+      // Before android 4.3, socket.connect could throw a SecurityException
+      // if opening a socket resulted in an EACCES error.
+      IOException ioException = new IOException("Exception in connect");
+      ioException.initCause(e);
+      throw ioException;
+    }
+  }
+
+  @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+    Object context = readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters");
+    if (context == null) {
+      // If that didn't work, try the Google Play Services SSL provider before giving up. This
+      // must be loaded by the SSLSocketFactory's class loader.
+      try {
+        Class<?> gmsSslParametersClass = Class.forName(
+            "com.google.android.gms.org.conscrypt.SSLParametersImpl", false,
+            sslSocketFactory.getClass().getClassLoader());
+        context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass, "sslParameters");
+      } catch (ClassNotFoundException e) {
+        return super.trustManager(sslSocketFactory);
+      }
+    }
+
+    X509TrustManager x509TrustManager = readFieldOrNull(
+        context, X509TrustManager.class, "x509TrustManager");
+    if (x509TrustManager != null) return x509TrustManager;
+
+    return readFieldOrNull(context, X509TrustManager.class, "trustManager");
+  }
+
+  @Override public void configureTlsExtensions(
+      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+    // Enable SNI and session tickets.
+    if (hostname != null) {
+      setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, true);
+      setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);
+    }
+
+    // Enable ALPN.
+    if (setAlpnProtocols != null && setAlpnProtocols.isSupported(sslSocket)) {
+      Object[] parameters = {concatLengthPrefixed(protocols)};
+      setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
+    }
+  }
+
+  @Override public String getSelectedProtocol(SSLSocket socket) {
+    if (getAlpnSelectedProtocol == null) return null;
+    if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
+
+    byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);
+    return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
+  }
+
+  @Override public void log(int level, String message, Throwable t) {
+    int logLevel = level == WARN ? Log.WARN : Log.DEBUG;
+    if (t != null) message = message + '\n' + Log.getStackTraceString(t);
+
+    // Split by line, then ensure each line can fit into Log's maximum length.
+    for (int i = 0, length = message.length(); i < length; i++) {
+      int newline = message.indexOf('\n', i);
+      newline = newline != -1 ? newline : length;
+      do {
+        int end = Math.min(newline, i + MAX_LOG_LENGTH);
+        Log.println(logLevel, "OkHttp", message.substring(i, end));
+        i = end;
+      } while (i < newline);
+    }
+  }
+
+  @Override public boolean isCleartextTrafficPermitted() {
+    try {
+      Class<?> networkPolicyClass = Class.forName("android.security.NetworkSecurityPolicy");
+      Method getInstanceMethod = networkPolicyClass.getMethod("getInstance");
+      Object networkSecurityPolicy = getInstanceMethod.invoke(null);
+      Method isCleartextTrafficPermittedMethod = networkPolicyClass
+          .getMethod("isCleartextTrafficPermitted");
+      boolean cleartextPermitted = (boolean) isCleartextTrafficPermittedMethod
+          .invoke(networkSecurityPolicy);
+      return cleartextPermitted;
+    } catch (ClassNotFoundException e) {
+      return super.isCleartextTrafficPermitted();
+    } catch (NoSuchMethodException | IllegalAccessException | IllegalArgumentException
+        | InvocationTargetException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public static Platform buildIfSupported() {
+    // Attempt to find Android 2.3+ APIs.
+    try {
+      Class<?> sslParametersClass;
+      try {
+        sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl");
+      } catch (ClassNotFoundException e) {
+        // Older platform before being unbundled.
+        sslParametersClass = Class.forName(
+            "org.apache.harmony.xnet.provider.jsse.SSLParametersImpl");
+      }
+
+      OptionalMethod<Socket> setUseSessionTickets = new OptionalMethod<>(
+          null, "setUseSessionTickets", boolean.class);
+      OptionalMethod<Socket> setHostname = new OptionalMethod<>(
+          null, "setHostname", String.class);
+      OptionalMethod<Socket> getAlpnSelectedProtocol = null;
+      OptionalMethod<Socket> setAlpnProtocols = null;
+
+      // Attempt to find Android 5.0+ APIs.
+      try {
+        Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
+        getAlpnSelectedProtocol = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
+        setAlpnProtocols = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
+      } catch (ClassNotFoundException ignored) {
+      }
+
+      return new AndroidPlatform(sslParametersClass, setUseSessionTickets, setHostname,
+          getAlpnSelectedProtocol, setAlpnProtocols);
+    } catch (ClassNotFoundException ignored) {
+      // This isn't an Android runtime.
+    }
+
+    return null;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ConnectionSpecSelector.java b/okhttp/src/main/java/okhttp3/internal/ConnectionSpecSelector.java
similarity index 85%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/ConnectionSpecSelector.java
rename to okhttp/src/main/java/okhttp3/internal/ConnectionSpecSelector.java
index e6833a8262..1393910b1b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/ConnectionSpecSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/ConnectionSpecSelector.java
@@ -13,10 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package okhttp3.internal;
 
-package com.squareup.okhttp.internal;
-
-import com.squareup.okhttp.ConnectionSpec;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.ProtocolException;
@@ -28,11 +26,12 @@
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLProtocolException;
 import javax.net.ssl.SSLSocket;
+import okhttp3.ConnectionSpec;
 
 /**
- * Handles the connection spec fallback strategy: When a secure socket connection fails
- * due to a handshake / protocol problem the connection may be retried with different protocols.
- * Instances are stateful and should be created and used for a single connection attempt.
+ * Handles the connection spec fallback strategy: When a secure socket connection fails due to a
+ * handshake / protocol problem the connection may be retried with different protocols. Instances
+ * are stateful and should be created and used for a single connection attempt.
  */
 public final class ConnectionSpecSelector {
 
@@ -81,23 +80,28 @@ public ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOExcept
   }
 
   /**
-   * Reports a failure to complete a connection. Determines the next {@link ConnectionSpec} to
-   * try, if any.
+   * Reports a failure to complete a connection. Determines the next {@link ConnectionSpec} to try,
+   * if any.
    *
-   * @return {@code true} if the connection should be retried using
-   *     {@link #configureSecureSocket(SSLSocket)} or {@code false} if not
+   * @return {@code true} if the connection should be retried using {@link
+   * #configureSecureSocket(SSLSocket)} or {@code false} if not
    */
   public boolean connectionFailed(IOException e) {
     // Any future attempt to connect using this strategy will be a fallback attempt.
     isFallback = true;
 
-    // TODO(nfuller): This is the same logic as in HttpEngine.
+    if (!isFallbackPossible) {
+      return false;
+    }
+
     // If there was a protocol problem, don't recover.
     if (e instanceof ProtocolException) {
       return false;
     }
 
-    // If there was an interruption or timeout, don't recover.
+    // If there was an interruption or timeout (SocketTimeoutException), don't recover.
+    // For the socket connect timeout case we do not try the same host with a different
+    // ConnectionSpec: we assume it is unreachable.
     if (e instanceof InterruptedIOException) {
       return false;
     }
@@ -115,13 +119,10 @@ public boolean connectionFailed(IOException e) {
       // e.g. a certificate pinning error.
       return false;
     }
-    // TODO(nfuller): End of common code.
-
 
     // On Android, SSLProtocolExceptions can be caused by TLS_FALLBACK_SCSV failures, which means we
     // retry those when we probably should not.
-    return ((e instanceof SSLHandshakeException || e instanceof SSLProtocolException))
-        && isFallbackPossible;
+    return (e instanceof SSLHandshakeException || e instanceof SSLProtocolException);
   }
 
   /**
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
similarity index 81%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
rename to okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
index b940168957..097686bf28 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/DiskLruCache.java
@@ -13,14 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package okhttp3.internal;
 
-package com.squareup.okhttp.internal;
-
-import com.squareup.okhttp.internal.io.FileSystem;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.File;
 import java.io.FileNotFoundException;
+import java.io.Flushable;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -33,6 +32,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import okhttp3.internal.io.FileSystem;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -41,51 +41,49 @@
 import okio.Source;
 import okio.Timeout;
 
+import static okhttp3.internal.Platform.WARN;
+
 /**
- * A cache that uses a bounded amount of space on a filesystem. Each cache
- * entry has a string key and a fixed number of values. Each key must match
- * the regex <strong>[a-z0-9_-]{1,64}</strong>. Values are byte sequences,
- * accessible as streams or files. Each value must be between {@code 0} and
- * {@code Integer.MAX_VALUE} bytes in length.
+ * A cache that uses a bounded amount of space on a filesystem. Each cache entry has a string key
+ * and a fixed number of values. Each key must match the regex <strong>[a-z0-9_-]{1,64}</strong>.
+ * Values are byte sequences, accessible as streams or files. Each value must be between {@code 0}
+ * and {@code Integer.MAX_VALUE} bytes in length.
+ *
+ * <p>The cache stores its data in a directory on the filesystem. This directory must be exclusive
+ * to the cache; the cache may delete or overwrite files from its directory. It is an error for
+ * multiple processes to use the same cache directory at the same time.
  *
- * <p>The cache stores its data in a directory on the filesystem. This
- * directory must be exclusive to the cache; the cache may delete or overwrite
- * files from its directory. It is an error for multiple processes to use the
- * same cache directory at the same time.
+ * <p>This cache limits the number of bytes that it will store on the filesystem. When the number of
+ * stored bytes exceeds the limit, the cache will remove entries in the background until the limit
+ * is satisfied. The limit is not strict: the cache may temporarily exceed it while waiting for
+ * files to be deleted. The limit does not include filesystem overhead or the cache journal so
+ * space-sensitive applications should set a conservative limit.
  *
- * <p>This cache limits the number of bytes that it will store on the
- * filesystem. When the number of stored bytes exceeds the limit, the cache will
- * remove entries in the background until the limit is satisfied. The limit is
- * not strict: the cache may temporarily exceed it while waiting for files to be
- * deleted. The limit does not include filesystem overhead or the cache
- * journal so space-sensitive applications should set a conservative limit.
+ * <p>Clients call {@link #edit} to create or update the values of an entry. An entry may have only
+ * one editor at one time; if a value is not available to be edited then {@link #edit} will return
+ * null.
  *
- * <p>Clients call {@link #edit} to create or update the values of an entry. An
- * entry may have only one editor at one time; if a value is not available to be
- * edited then {@link #edit} will return null.
  * <ul>
- *     <li>When an entry is being <strong>created</strong> it is necessary to
- *         supply a full set of values; the empty value should be used as a
- *         placeholder if necessary.
- *     <li>When an entry is being <strong>edited</strong>, it is not necessary
- *         to supply data for every value; values default to their previous
- *         value.
+ *     <li>When an entry is being <strong>created</strong> it is necessary to supply a full set of
+ *         values; the empty value should be used as a placeholder if necessary.
+ *     <li>When an entry is being <strong>edited</strong>, it is not necessary to supply data for
+ *         every value; values default to their previous value.
  * </ul>
- * Every {@link #edit} call must be matched by a call to {@link Editor#commit}
- * or {@link Editor#abort}. Committing is atomic: a read observes the full set
- * of values as they were before or after the commit, but never a mix of values.
  *
- * <p>Clients call {@link #get} to read a snapshot of an entry. The read will
- * observe the value at the time that {@link #get} was called. Updates and
- * removals after the call do not impact ongoing reads.
+ * <p>Every {@link #edit} call must be matched by a call to {@link Editor#commit} or {@link
+ * Editor#abort}. Committing is atomic: a read observes the full set of values as they were before
+ * or after the commit, but never a mix of values.
  *
- * <p>This class is tolerant of some I/O errors. If files are missing from the
- * filesystem, the corresponding entries will be dropped from the cache. If
- * an error occurs while writing a cache value, the edit will fail silently.
- * Callers should handle other problems by catching {@code IOException} and
- * responding appropriately.
+ * <p>Clients call {@link #get} to read a snapshot of an entry. The read will observe the value at
+ * the time that {@link #get} was called. Updates and removals after the call do not impact ongoing
+ * reads.
+ *
+ * <p>This class is tolerant of some I/O errors. If files are missing from the filesystem, the
+ * corresponding entries will be dropped from the cache. If an error occurs while writing a cache
+ * value, the edit will fail silently. Callers should handle other problems by catching {@code
+ * IOException} and responding appropriately.
  */
-public final class DiskLruCache implements Closeable {
+public final class DiskLruCache implements Closeable, Flushable {
   static final String JOURNAL_FILE = "journal";
   static final String JOURNAL_FILE_TEMP = "journal.tmp";
   static final String JOURNAL_FILE_BACKUP = "journal.bkp";
@@ -155,11 +153,13 @@
   // Must be read and written when synchronized on 'this'.
   private boolean initialized;
   private boolean closed;
+  private boolean mostRecentTrimFailed;
+  private boolean mostRecentRebuildFailed;
 
   /**
-   * To differentiate between old and current snapshots, each entry is given
-   * a sequence number each time an edit is committed. A snapshot is stale if
-   * its sequence number is not equal to its entry's sequence number.
+   * To differentiate between old and current snapshots, each entry is given a sequence number each
+   * time an edit is committed. A snapshot is stale if its sequence number is not equal to its
+   * entry's sequence number.
    */
   private long nextSequenceNumber = 0;
 
@@ -171,14 +171,21 @@ public void run() {
         if (!initialized | closed) {
           return; // Nothing to do
         }
+
         try {
           trimToSize();
+        } catch (IOException ignored) {
+          mostRecentTrimFailed = true;
+        }
+
+        try {
           if (journalRebuildRequired()) {
             rebuildJournal();
             redundantOpCount = 0;
           }
         } catch (IOException e) {
-          throw new RuntimeException(e);
+          mostRecentRebuildFailed = true;
+          journalWriter = Okio.buffer(NULL_SINK);
         }
       }
     }
@@ -222,8 +229,8 @@ public synchronized void initialize() throws IOException {
         initialized = true;
         return;
       } catch (IOException journalIsCorrupt) {
-        Platform.get().logW("DiskLruCache " + directory + " is corrupt: "
-            + journalIsCorrupt.getMessage() + ", removing");
+        Platform.get().log(WARN, "DiskLruCache " + directory + " is corrupt: "
+            + journalIsCorrupt.getMessage() + ", removing", journalIsCorrupt);
         delete();
         closed = false;
       }
@@ -348,8 +355,8 @@ private void readJournalLine(String line) throws IOException {
   }
 
   /**
-   * Computes the initial size and collects garbage as a part of opening the
-   * cache. Dirty entries are assumed to be inconsistent and will be deleted.
+   * Computes the initial size and collects garbage as a part of opening the cache. Dirty entries
+   * are assumed to be inconsistent and will be deleted.
    */
   private void processJournal() throws IOException {
     fileSystem.delete(journalFileTmp);
@@ -371,8 +378,8 @@ private void processJournal() throws IOException {
   }
 
   /**
-   * Creates a new journal that omits redundant information. This replaces the
-   * current journal if it exists.
+   * Creates a new journal that omits redundant information. This replaces the current journal if it
+   * exists.
    */
   private synchronized void rebuildJournal() throws IOException {
     if (journalWriter != null) {
@@ -411,12 +418,12 @@ private synchronized void rebuildJournal() throws IOException {
 
     journalWriter = newJournalWriter();
     hasJournalErrors = false;
+    mostRecentRebuildFailed = false;
   }
 
   /**
-   * Returns a snapshot of the entry named {@code key}, or null if it doesn't
-   * exist is not currently readable. If a value is returned, it is moved to
-   * the head of the LRU queue.
+   * Returns a snapshot of the entry named {@code key}, or null if it doesn't exist is not currently
+   * readable. If a value is returned, it is moved to the head of the LRU queue.
    */
   public synchronized Snapshot get(String key) throws IOException {
     initialize();
@@ -439,8 +446,7 @@ public synchronized Snapshot get(String key) throws IOException {
   }
 
   /**
-   * Returns an editor for the entry named {@code key}, or null if another
-   * edit is in progress.
+   * Returns an editor for the entry named {@code key}, or null if another edit is in progress.
    */
   public Editor edit(String key) throws IOException {
     return edit(key, ANY_SEQUENCE_NUMBER);
@@ -459,6 +465,15 @@ private synchronized Editor edit(String key, long expectedSequenceNumber) throws
     if (entry != null && entry.currentEditor != null) {
       return null; // Another edit is in progress.
     }
+    if (mostRecentTrimFailed || mostRecentRebuildFailed) {
+      // The OS has become our enemy! If the trim job failed, it means we are storing more data than
+      // requested by the user. Do not allow edits so we do not go over that limit any further. If
+      // the journal rebuild failed, the journal writer will not be active, meaning we will not be
+      // able to record the edit, causing file leaks. In both cases, we want to retry the clean up
+      // so we can get out of this state!
+      executor.execute(cleanupRunnable);
+      return null;
+    }
 
     // Flush the journal before creating files to prevent file leaks.
     journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
@@ -483,16 +498,15 @@ public File getDirectory() {
   }
 
   /**
-   * Returns the maximum number of bytes that this cache should use to store
-   * its data.
+   * Returns the maximum number of bytes that this cache should use to store its data.
    */
   public synchronized long getMaxSize() {
     return maxSize;
   }
 
   /**
-   * Changes the maximum number of bytes the cache can store and queues a job
-   * to trim the existing store, if necessary.
+   * Changes the maximum number of bytes the cache can store and queues a job to trim the existing
+   * store, if necessary.
    */
   public synchronized void setMaxSize(long maxSize) {
     this.maxSize = maxSize;
@@ -502,9 +516,8 @@ public synchronized void setMaxSize(long maxSize) {
   }
 
   /**
-   * Returns the number of bytes currently being used to store the values in
-   * this cache. This may be greater than the max size if a background
-   * deletion is pending.
+   * Returns the number of bytes currently being used to store the values in this cache. This may be
+   * greater than the max size if a background deletion is pending.
    */
   public synchronized long size() throws IOException {
     initialize();
@@ -572,8 +585,8 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
   }
 
   /**
-   * We only rebuild the journal when it will halve the size of the journal
-   * and eliminate at least 2000 ops.
+   * We only rebuild the journal when it will halve the size of the journal and eliminate at least
+   * 2000 ops.
    */
   private boolean journalRebuildRequired() {
     final int redundantOpCompactThreshold = 2000;
@@ -582,9 +595,8 @@ private boolean journalRebuildRequired() {
   }
 
   /**
-   * Drops the entry for {@code key} if it exists and can be removed. If the
-   * entry for {@code key} is currently being edited, that edit will complete
-   * normally but its value will not be stored.
+   * Drops the entry for {@code key} if it exists and can be removed. If the entry for {@code key}
+   * is currently being edited, that edit will complete normally but its value will not be stored.
    *
    * @return true if an entry was removed.
    */
@@ -595,12 +607,14 @@ public synchronized boolean remove(String key) throws IOException {
     validateKey(key);
     Entry entry = lruEntries.get(key);
     if (entry == null) return false;
-    return removeEntry(entry);
+    boolean removed = removeEntry(entry);
+    if (removed && size <= maxSize) mostRecentTrimFailed = false;
+    return removed;
   }
 
   private boolean removeEntry(Entry entry) throws IOException {
     if (entry.currentEditor != null) {
-      entry.currentEditor.hasErrors = true; // Prevent the edit from completing normally.
+      entry.currentEditor.detach(); // Prevent the edit from completing normally.
     }
 
     for (int i = 0; i < valueCount; i++) {
@@ -632,7 +646,7 @@ private synchronized void checkNotClosed() {
   }
 
   /** Force buffered operations to the filesystem. */
-  public synchronized void flush() throws IOException {
+  @Override public synchronized void flush() throws IOException {
     if (!initialized) return;
 
     checkNotClosed();
@@ -641,7 +655,7 @@ public synchronized void flush() throws IOException {
   }
 
   /** Closes this cache. Stored values will remain on the filesystem. */
-  public synchronized void close() throws IOException {
+  @Override public synchronized void close() throws IOException {
     if (!initialized || closed) {
       closed = true;
       return;
@@ -663,12 +677,12 @@ private void trimToSize() throws IOException {
       Entry toEvict = lruEntries.values().iterator().next();
       removeEntry(toEvict);
     }
+    mostRecentTrimFailed = false;
   }
 
   /**
-   * Closes the cache and deletes all of its stored values. This will delete
-   * all files in the cache directory including files that weren't created by
-   * the cache.
+   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
+   * directory including files that weren't created by the cache.
    */
   public void delete() throws IOException {
     close();
@@ -676,8 +690,8 @@ public void delete() throws IOException {
   }
 
   /**
-   * Deletes all stored values from the cache. In-flight edits will complete
-   * normally but their values will not be stored.
+   * Deletes all stored values from the cache. In-flight edits will complete normally but their
+   * values will not be stored.
    */
   public synchronized void evictAll() throws IOException {
     initialize();
@@ -685,6 +699,7 @@ public synchronized void evictAll() throws IOException {
     for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
       removeEntry(entry);
     }
+    mostRecentTrimFailed = false;
   }
 
   private void validateKey(String key) {
@@ -781,9 +796,8 @@ public String key() {
     }
 
     /**
-     * Returns an editor for this snapshot's entry, or null if either the
-     * entry has changed since this snapshot was created or if another edit
-     * is in progress.
+     * Returns an editor for this snapshot's entry, or null if either the entry has changed since
+     * this snapshot was created or if another edit is in progress.
      */
     public Editor edit() throws IOException {
       return DiskLruCache.this.edit(key, sequenceNumber);
@@ -826,8 +840,7 @@ public void close() {
   public final class Editor {
     private final Entry entry;
     private final boolean[] written;
-    private boolean hasErrors;
-    private boolean committed;
+    private boolean done;
 
     private Editor(Entry entry) {
       this.entry = entry;
@@ -835,15 +848,34 @@ private Editor(Entry entry) {
     }
 
     /**
-     * Returns an unbuffered input stream to read the last committed value,
-     * or null if no value has been committed.
+     * Prevents this editor from completing normally. This is necessary either when the edit causes
+     * an I/O error, or if the target entry is evicted while this editor is active. In either case
+     * we delete the editor's created files and prevent new files from being created. Note that once
+     * an editor has been detached it is possible for another editor to edit the entry.
+     */
+    void detach() {
+      if (entry.currentEditor == this) {
+        for (int i = 0; i < valueCount; i++) {
+          try {
+            fileSystem.delete(entry.dirtyFiles[i]);
+          } catch (IOException e) {
+            // This file is potentially leaked. Not much we can do about that.
+          }
+        }
+        entry.currentEditor = null;
+      }
+    }
+
+    /**
+     * Returns an unbuffered input stream to read the last committed value, or null if no value has
+     * been committed.
      */
     public Source newSource(int index) throws IOException {
       synchronized (DiskLruCache.this) {
-        if (entry.currentEditor != this) {
+        if (done) {
           throw new IllegalStateException();
         }
-        if (!entry.readable) {
+        if (!entry.readable || entry.currentEditor != this) {
           return null;
         }
         try {
@@ -855,17 +887,18 @@ public Source newSource(int index) throws IOException {
     }
 
     /**
-     * Returns a new unbuffered output stream to write the value at
-     * {@code index}. If the underlying output stream encounters errors
-     * when writing to the filesystem, this edit will be aborted when
-     * {@link #commit} is called. The returned output stream does not throw
-     * IOExceptions.
+     * Returns a new unbuffered output stream to write the value at {@code index}. If the underlying
+     * output stream encounters errors when writing to the filesystem, this edit will be aborted
+     * when {@link #commit} is called. The returned output stream does not throw IOExceptions.
      */
     public Sink newSink(int index) throws IOException {
       synchronized (DiskLruCache.this) {
-        if (entry.currentEditor != this) {
+        if (done) {
           throw new IllegalStateException();
         }
+        if (entry.currentEditor != this) {
+          return NULL_SINK;
+        }
         if (!entry.readable) {
           written[index] = true;
         }
@@ -879,7 +912,7 @@ public Sink newSink(int index) throws IOException {
         return new FaultHidingSink(sink) {
           @Override protected void onException(IOException e) {
             synchronized (DiskLruCache.this) {
-              hasErrors = true;
+              detach();
             }
           }
         };
@@ -887,34 +920,40 @@ public Sink newSink(int index) throws IOException {
     }
 
     /**
-     * Commits this edit so it is visible to readers.  This releases the
-     * edit lock so another edit may be started on the same key.
+     * Commits this edit so it is visible to readers.  This releases the edit lock so another edit
+     * may be started on the same key.
      */
     public void commit() throws IOException {
       synchronized (DiskLruCache.this) {
-        if (hasErrors) {
-          completeEdit(this, false);
-          removeEntry(entry); // The previous entry is stale.
-        } else {
+        if (done) {
+          throw new IllegalStateException();
+        }
+        if (entry.currentEditor == this) {
           completeEdit(this, true);
         }
-        committed = true;
+        done = true;
       }
     }
 
     /**
-     * Aborts this edit. This releases the edit lock so another edit may be
-     * started on the same key.
+     * Aborts this edit. This releases the edit lock so another edit may be started on the same
+     * key.
      */
     public void abort() throws IOException {
       synchronized (DiskLruCache.this) {
-        completeEdit(this, false);
+        if (done) {
+          throw new IllegalStateException();
+        }
+        if (entry.currentEditor == this) {
+          completeEdit(this, false);
+        }
+        done = true;
       }
     }
 
     public void abortUnlessCommitted() {
       synchronized (DiskLruCache.this) {
-        if (!committed) {
+        if (!done && entry.currentEditor == this) {
           try {
             completeEdit(this, false);
           } catch (IOException ignored) {
@@ -1010,6 +1049,12 @@ Snapshot snapshot() {
             break;
           }
         }
+        // Since the entry is no longer valid, remove it so the metadata is accurate (i.e. the cache
+        // size.)
+        try {
+          removeEntry(this);
+        } catch (IOException ignored) {
+        }
         return null;
       }
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java b/okhttp/src/main/java/okhttp3/internal/FaultHidingSink.java
similarity index 62%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java
rename to okhttp/src/main/java/okhttp3/internal/FaultHidingSink.java
index 91e990db8d..e77f6bb448 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/FaultHidingSink.java
+++ b/okhttp/src/main/java/okhttp3/internal/FaultHidingSink.java
@@ -1,4 +1,19 @@
-package com.squareup.okhttp.internal;
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
 
 import java.io.IOException;
 import okio.Buffer;
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
new file mode 100644
index 0000000000..5ed594eacf
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.net.MalformedURLException;
+import java.net.UnknownHostException;
+import javax.net.ssl.SSLSocket;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.ConnectionPool;
+import okhttp3.ConnectionSpec;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.io.RealConnection;
+
+/**
+ * Escalate internal APIs in {@code okhttp3} so they can be used from OkHttp's implementation
+ * packages. The only implementation of this interface is in {@link OkHttpClient}.
+ */
+public abstract class Internal {
+
+  public static void initializeInstanceForTests() {
+    // Needed in tests to ensure that the instance is actually pointing to something.
+    new OkHttpClient();
+  }
+
+  public static Internal instance;
+
+  public abstract void addLenient(Headers.Builder builder, String line);
+
+  public abstract void addLenient(Headers.Builder builder, String name, String value);
+
+  public abstract void setCache(OkHttpClient.Builder builder, InternalCache internalCache);
+
+  public abstract InternalCache internalCache(OkHttpClient client);
+
+  public abstract RealConnection get(
+      ConnectionPool pool, Address address, StreamAllocation streamAllocation);
+
+  public abstract void put(ConnectionPool pool, RealConnection connection);
+
+  public abstract boolean connectionBecameIdle(ConnectionPool pool, RealConnection connection);
+
+  public abstract RouteDatabase routeDatabase(ConnectionPool connectionPool);
+
+  public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
+      boolean isFallback);
+
+  public abstract HttpUrl getHttpUrlChecked(String url)
+      throws MalformedURLException, UnknownHostException;
+
+  // TODO delete the following when web sockets move into the main package.
+  public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
+
+  public abstract StreamAllocation callEngineGetStreamAllocation(Call call);
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java b/okhttp/src/main/java/okhttp3/internal/InternalCache.java
similarity index 70%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java
rename to okhttp/src/main/java/okhttp3/internal/InternalCache.java
index 4925358225..9752002bc5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/InternalCache.java
@@ -13,17 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.http.CacheRequest;
-import com.squareup.okhttp.internal.http.CacheStrategy;
 import java.io.IOException;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.http.CacheRequest;
+import okhttp3.internal.http.CacheStrategy;
 
 /**
- * OkHttp's internal cache interface. Applications shouldn't implement this:
- * instead use {@link com.squareup.okhttp.Cache}.
+ * OkHttp's internal cache interface. Applications shouldn't implement this: instead use {@link
+ * okhttp3.Cache}.
  */
 public interface InternalCache {
   Response get(Request request) throws IOException;
@@ -31,16 +31,15 @@
   CacheRequest put(Response response) throws IOException;
 
   /**
-   * Remove any cache entries for the supplied {@code request}. This is invoked
-   * when the client invalidates the cache, such as when making POST requests.
+   * Remove any cache entries for the supplied {@code request}. This is invoked when the client
+   * invalidates the cache, such as when making POST requests.
    */
   void remove(Request request) throws IOException;
 
   /**
-   * Handles a conditional request hit by updating the stored cache response
-   * with the headers from {@code network}. The cached response body is not
-   * updated. If the stored response has changed since {@code cached} was
-   * returned, this does nothing.
+   * Handles a conditional request hit by updating the stored cache response with the headers from
+   * {@code network}. The cached response body is not updated. If the stored response has changed
+   * since {@code cached} was returned, this does nothing.
    */
   void update(Response cached, Response network) throws IOException;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/Jdk9Platform.java b/okhttp/src/main/java/okhttp3/internal/Jdk9Platform.java
new file mode 100644
index 0000000000..94677ebe22
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/Jdk9Platform.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.List;
+import javax.net.ssl.SSLParameters;
+import javax.net.ssl.SSLSocket;
+import okhttp3.Protocol;
+
+/**
+ * OpenJDK 9+.
+ */
+final class Jdk9Platform extends Platform {
+  final Method setProtocolMethod;
+  final Method getProtocolMethod;
+
+  public Jdk9Platform(Method setProtocolMethod, Method getProtocolMethod) {
+    this.setProtocolMethod = setProtocolMethod;
+    this.getProtocolMethod = getProtocolMethod;
+  }
+
+  @Override
+  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
+                                     List<Protocol> protocols) {
+    try {
+      SSLParameters sslParameters = sslSocket.getSSLParameters();
+
+      List<String> names = alpnProtocolNames(protocols);
+
+      setProtocolMethod.invoke(sslParameters,
+          new Object[]{names.toArray(new String[names.size()])});
+
+      sslSocket.setSSLParameters(sslParameters);
+    } catch (IllegalAccessException | InvocationTargetException e) {
+      throw new AssertionError();
+    }
+  }
+
+  @Override
+  public String getSelectedProtocol(SSLSocket socket) {
+    try {
+      String protocol = (String) getProtocolMethod.invoke(socket);
+
+      // SSLSocket.getApplicationProtocol returns "" if application protocols values will not
+      // be used. Observed if you didn't specify SSLParameters.setApplicationProtocols
+      if (protocol == null || protocol.equals("")) {
+        return null;
+      }
+
+      return protocol;
+    } catch (IllegalAccessException | InvocationTargetException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public static Jdk9Platform buildIfSupported() {
+    // Find JDK 9 new methods
+    try {
+      Method setProtocolMethod =
+          SSLParameters.class.getMethod("setApplicationProtocols", String[].class);
+      Method getProtocolMethod = SSLSocket.class.getMethod("getApplicationProtocol");
+
+      return new Jdk9Platform(setProtocolMethod, getProtocolMethod);
+    } catch (NoSuchMethodException ignored) {
+      // pre JDK 9
+    }
+
+    return null;
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/JdkWithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/JdkWithJettyBootPlatform.java
new file mode 100644
index 0000000000..5e5e5a43f6
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/JdkWithJettyBootPlatform.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.util.List;
+import javax.net.ssl.SSLSocket;
+import okhttp3.Protocol;
+
+/**
+ * OpenJDK 7 or OpenJDK 8 with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
+ */
+class JdkWithJettyBootPlatform extends Platform {
+  private final Method putMethod;
+  private final Method getMethod;
+  private final Method removeMethod;
+  private final Class<?> clientProviderClass;
+  private final Class<?> serverProviderClass;
+
+  public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
+      Class<?> clientProviderClass, Class<?> serverProviderClass) {
+    this.putMethod = putMethod;
+    this.getMethod = getMethod;
+    this.removeMethod = removeMethod;
+    this.clientProviderClass = clientProviderClass;
+    this.serverProviderClass = serverProviderClass;
+  }
+
+  @Override public void configureTlsExtensions(
+      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+    List<String> names = alpnProtocolNames(protocols);
+
+    try {
+      Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
+          new Class[] {clientProviderClass, serverProviderClass}, new JettyNegoProvider(names));
+      putMethod.invoke(null, sslSocket, provider);
+    } catch (InvocationTargetException | IllegalAccessException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  @Override public void afterHandshake(SSLSocket sslSocket) {
+    try {
+      removeMethod.invoke(null, sslSocket);
+    } catch (IllegalAccessException | InvocationTargetException ignored) {
+      throw new AssertionError();
+    }
+  }
+
+  @Override public String getSelectedProtocol(SSLSocket socket) {
+    try {
+      JettyNegoProvider provider =
+          (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
+      if (!provider.unsupported && provider.selected == null) {
+        Platform.get().log(INFO, "ALPN callback dropped: SPDY and HTTP/2 are disabled. "
+            + "Is alpn-boot on the boot class path?", null);
+        return null;
+      }
+      return provider.unsupported ? null : provider.selected;
+    } catch (InvocationTargetException | IllegalAccessException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public static Platform buildIfSupported() {
+    // Find Jetty's ALPN extension for OpenJDK.
+    try {
+      String negoClassName = "org.eclipse.jetty.alpn.ALPN";
+      Class<?> negoClass = Class.forName(negoClassName);
+      Class<?> providerClass = Class.forName(negoClassName + "$Provider");
+      Class<?> clientProviderClass = Class.forName(negoClassName + "$ClientProvider");
+      Class<?> serverProviderClass = Class.forName(negoClassName + "$ServerProvider");
+      Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
+      Method getMethod = negoClass.getMethod("get", SSLSocket.class);
+      Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
+      return new JdkWithJettyBootPlatform(
+          putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
+    } catch (ClassNotFoundException | NoSuchMethodException ignored) {
+    }
+
+    return null;
+  }
+
+  /**
+   * Handle the methods of ALPN's ClientProvider and ServerProvider without a compile-time
+   * dependency on those interfaces.
+   */
+  private static class JettyNegoProvider implements InvocationHandler {
+    /** This peer's supported protocols. */
+    private final List<String> protocols;
+    /** Set when remote peer notifies ALPN is unsupported. */
+    private boolean unsupported;
+    /** The protocol the server selected. */
+    private String selected;
+
+    public JettyNegoProvider(List<String> protocols) {
+      this.protocols = protocols;
+    }
+
+    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+      String methodName = method.getName();
+      Class<?> returnType = method.getReturnType();
+      if (args == null) {
+        args = Util.EMPTY_STRING_ARRAY;
+      }
+      if (methodName.equals("supports") && boolean.class == returnType) {
+        return true; // ALPN is supported.
+      } else if (methodName.equals("unsupported") && void.class == returnType) {
+        this.unsupported = true; // Peer doesn't support ALPN.
+        return null;
+      } else if (methodName.equals("protocols") && args.length == 0) {
+        return protocols; // Client advertises these protocols.
+      } else if ((methodName.equals("selectProtocol") || methodName.equals("select"))
+          && String.class == returnType && args.length == 1 && args[0] instanceof List) {
+        List<String> peerProtocols = (List) args[0];
+        // Pick the first known protocol the peer advertises.
+        for (int i = 0, size = peerProtocols.size(); i < size; i++) {
+          if (protocols.contains(peerProtocols.get(i))) {
+            return selected = peerProtocols.get(i);
+          }
+        }
+        return selected = protocols.get(0); // On no intersection, try peer's first protocol.
+      } else if ((methodName.equals("protocolSelected") || methodName.equals("selected"))
+          && args.length == 1) {
+        this.selected = (String) args[0]; // Server selected this protocol.
+        return null;
+      } else {
+        return method.invoke(this, args);
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java b/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
similarity index 92%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
rename to okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
index 7a02ecfbde..ff9729e2af 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
+++ b/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
@@ -13,8 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
 /**
  * Runnable implementation which always sets its thread name.
@@ -23,7 +22,7 @@
   protected final String name;
 
   public NamedRunnable(String format, Object... args) {
-    this.name = String.format(format, args);
+    this.name = Util.format(format, args);
   }
 
   @Override public final void run() {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/OptionalMethod.java b/okhttp/src/main/java/okhttp3/internal/OptionalMethod.java
similarity index 88%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/OptionalMethod.java
rename to okhttp/src/main/java/okhttp3/internal/OptionalMethod.java
index 21b31cc491..108ec292d1 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/OptionalMethod.java
+++ b/okhttp/src/main/java/okhttp3/internal/OptionalMethod.java
@@ -15,7 +15,7 @@
  *  limitations under the License.
  */
 
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -57,8 +57,7 @@ public boolean isSupported(T target) {
 
   /**
    * Invokes the method on {@code target} with {@code args}. If the method does not exist or is not
-   * public then {@code null} is returned. See also
-   * {@link #invokeOptionalWithoutCheckedException(Object, Object...)}.
+   * public then {@code null} is returned. See also {@link #invokeOptionalWithoutCheckedException}.
    *
    * @throws IllegalArgumentException if the arguments are invalid
    * @throws InvocationTargetException if the invocation throws an exception
@@ -76,9 +75,9 @@ public Object invokeOptional(T target, Object... args) throws InvocationTargetEx
   }
 
   /**
-   * Invokes the method on {@code target}.  If the method does not exist or is not
-   * public then {@code null} is returned. Any RuntimeException thrown by the method is thrown,
-   * checked exceptions are wrapped in an {@link AssertionError}.
+   * Invokes the method on {@code target}.  If the method does not exist or is not public then
+   * {@code null} is returned. Any RuntimeException thrown by the method is thrown, checked
+   * exceptions are wrapped in an {@link AssertionError}.
    *
    * @throws IllegalArgumentException if the arguments are invalid
    */
@@ -120,8 +119,8 @@ public Object invoke(T target, Object... args) throws InvocationTargetException
 
   /**
    * Invokes the method on {@code target}. Throws an error if the method is not supported. Any
-   * RuntimeException thrown by the method is thrown, checked exceptions are wrapped in
-   * an {@link AssertionError}.
+   * RuntimeException thrown by the method is thrown, checked exceptions are wrapped in an {@link
+   * AssertionError}.
    *
    * @throws IllegalArgumentException if the arguments are invalid
    */
@@ -140,10 +139,9 @@ public Object invokeWithoutCheckedException(T target, Object... args) {
   }
 
   /**
-   * Perform a lookup for the method. No caching.
-   * In order to return a method the method name and arguments must match those specified when
-   * the {@link OptionalMethod} was created. If the return type is specified (i.e. non-null) it
-   * must also be compatible. The method must also be public.
+   * Perform a lookup for the method. No caching. In order to return a method the method name and
+   * arguments must match those specified when the {@link OptionalMethod} was created. If the return
+   * type is specified (i.e. non-null) it must also be compatible. The method must also be public.
    */
   private Method getMethod(Class<?> clazz) {
     Method method = null;
diff --git a/okhttp/src/main/java/okhttp3/internal/Platform.java b/okhttp/src/main/java/okhttp3/internal/Platform.java
new file mode 100644
index 0000000000..34da83c0d2
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/Platform.java
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okio.Buffer;
+
+/**
+ * Access to platform-specific features.
+ *
+ * <h3>Server name indication (SNI)</h3>
+ *
+ * <p>Supported on Android 2.3+.
+ *
+ * Supported on OpenJDK 7+
+ *
+ * <h3>Session Tickets</h3>
+ *
+ * <p>Supported on Android 2.3+.
+ *
+ * <h3>Android Traffic Stats (Socket Tagging)</h3>
+ *
+ * <p>Supported on Android 4.0+.
+ *
+ * <h3>ALPN (Application Layer Protocol Negotiation)</h3>
+ *
+ * <p>Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
+ * unstable.
+ *
+ * Supported on OpenJDK 7 and 8 (via the JettyALPN-boot library).
+ *
+ * Supported on OpenJDK 9 via SSLParameters and SSLSocket features.
+ *
+ * <h3>Trust Manager Extraction</h3>
+ *
+ * <p>Supported on Android 2.3+ and OpenJDK 7+. There are no public APIs to recover the trust
+ * manager that was used to create an {@link SSLSocketFactory}.
+ *
+ * <h3>Android Cleartext Permit Detection</h3>
+ *
+ * <p>Supported on Android 6.0+ via {@code NetworkSecurityPolicy}.
+ */
+public class Platform {
+  private static final Platform PLATFORM = findPlatform();
+  public static final int INFO = 4;
+  public static final int WARN = 5;
+  private static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+
+  public static Platform get() {
+    return PLATFORM;
+  }
+
+  /** Prefix used on custom headers. */
+  public String getPrefix() {
+    return "OkHttp";
+  }
+
+  public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+    // Attempt to get the trust manager from an OpenJDK socket factory. We attempt this on all
+    // platforms in order to support Robolectric, which mixes classes from both Android and the
+    // Oracle JDK. Note that we don't support HTTP/2 or other nice features on Robolectric.
+    try {
+      Class<?> sslContextClass = Class.forName("sun.security.ssl.SSLContextImpl");
+      Object context = readFieldOrNull(sslSocketFactory, sslContextClass, "context");
+      if (context == null) return null;
+      return readFieldOrNull(context, X509TrustManager.class, "trustManager");
+    } catch (ClassNotFoundException e) {
+      return null;
+    }
+  }
+
+  /**
+   * Configure TLS extensions on {@code sslSocket} for {@code route}.
+   *
+   * @param hostname non-null for client-side handshakes; null for server-side handshakes.
+   */
+  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
+      List<Protocol> protocols) {
+  }
+
+  /**
+   * Called after the TLS handshake to release resources allocated by {@link
+   * #configureTlsExtensions}.
+   */
+  public void afterHandshake(SSLSocket sslSocket) {
+  }
+
+  /** Returns the negotiated protocol, or null if no protocol was negotiated. */
+  public String getSelectedProtocol(SSLSocket socket) {
+    return null;
+  }
+
+  public void connectSocket(Socket socket, InetSocketAddress address,
+      int connectTimeout) throws IOException {
+    socket.connect(address, connectTimeout);
+  }
+
+  public void log(int level, String message, Throwable t) {
+    Level logLevel = level == WARN ? Level.WARNING : Level.INFO;
+    logger.log(logLevel, message, t);
+  }
+
+  public boolean isCleartextTrafficPermitted() {
+    return true;
+  }
+
+  public static List<String> alpnProtocolNames(List<Protocol> protocols) {
+    List<String> names = new ArrayList<>(protocols.size());
+    for (int i = 0, size = protocols.size(); i < size; i++) {
+      Protocol protocol = protocols.get(i);
+      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
+      names.add(protocol.toString());
+    }
+    return names;
+  }
+
+  /** Attempt to match the host runtime to a capable Platform implementation. */
+  private static Platform findPlatform() {
+    Platform android = AndroidPlatform.buildIfSupported();
+
+    if (android != null) {
+      return android;
+    }
+
+    Platform jdk9 = Jdk9Platform.buildIfSupported();
+
+    if (jdk9 != null) {
+      return jdk9;
+    }
+
+    Platform jdkWithJettyBoot = JdkWithJettyBootPlatform.buildIfSupported();
+
+    if (jdkWithJettyBoot != null) {
+      return jdkWithJettyBoot;
+    }
+
+    // Probably an Oracle JDK like OpenJDK.
+    return new Platform();
+  }
+
+  /**
+   * Returns the concatenation of 8-bit, length prefixed protocol names.
+   * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
+   */
+  static byte[] concatLengthPrefixed(List<Protocol> protocols) {
+    Buffer result = new Buffer();
+    for (int i = 0, size = protocols.size(); i < size; i++) {
+      Protocol protocol = protocols.get(i);
+      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
+      result.writeByte(protocol.toString().length());
+      result.writeUtf8(protocol.toString());
+    }
+    return result.readByteArray();
+  }
+
+  static <T> T readFieldOrNull(Object instance, Class<T> fieldType, String fieldName) {
+    for (Class<?> c = instance.getClass(); c != Object.class; c = c.getSuperclass()) {
+      try {
+        Field field = c.getDeclaredField(fieldName);
+        field.setAccessible(true);
+        Object value = field.get(instance);
+        if (value == null || !fieldType.isInstance(value)) return null;
+        return fieldType.cast(value);
+      } catch (NoSuchFieldException ignored) {
+      } catch (IllegalAccessException e) {
+        throw new AssertionError();
+      }
+    }
+
+    // Didn't find the field we wanted. As a last gasp attempt, try to find the value on a delegate.
+    if (!fieldName.equals("delegate")) {
+      Object delegate = readFieldOrNull(instance, Object.class, "delegate");
+      if (delegate != null) return readFieldOrNull(delegate, fieldType, fieldName);
+    }
+
+    return null;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java b/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
similarity index 81%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
rename to okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
index 1c96c7f6b2..613e0bf215 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
@@ -13,17 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package okhttp3.internal;
 
-import com.squareup.okhttp.Route;
 import java.util.LinkedHashSet;
 import java.util.Set;
+import okhttp3.Route;
 
 /**
- * A blacklist of failed routes to avoid when creating a new connection to a
- * target address. This is used so that OkHttp can learn from its mistakes: if
- * there was a failure attempting to connect to a specific IP address or proxy
- * server, that failure is remembered and alternate routes are preferred.
+ * A blacklist of failed routes to avoid when creating a new connection to a target address. This is
+ * used so that OkHttp can learn from its mistakes: if there was a failure attempting to connect to
+ * a specific IP address or proxy server, that failure is remembered and alternate routes are
+ * preferred.
  */
 public final class RouteDatabase {
   private final Set<Route> failedRoutes = new LinkedHashSet<>();
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
similarity index 54%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
rename to okhttp/src/main/java/okhttp3/internal/Util.java
index d44972d278..0d72116405 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -13,15 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package okhttp3.internal;
 
-package com.squareup.okhttp.internal;
-
-import com.squareup.okhttp.HttpUrl;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Array;
+import java.net.IDN;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.nio.charset.Charset;
@@ -32,9 +31,13 @@
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
+import java.util.TimeZone;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
+import java.util.regex.Pattern;
+import okhttp3.HttpUrl;
 import okio.Buffer;
 import okio.ByteString;
 import okio.Source;
@@ -47,6 +50,22 @@
   /** A cheap and type-safe constant for the UTF-8 Charset. */
   public static final Charset UTF_8 = Charset.forName("UTF-8");
 
+  /** GMT and UTC are equivalent for our purposes. */
+  public static final TimeZone UTC = TimeZone.getTimeZone("GMT");
+
+  /**
+   * Quick and dirty pattern to differentiate IP addresses from hostnames. This is an approximation
+   * of Android's private InetAddress#isNumeric API.
+   *
+   * <p>This matches IPv6 addresses as a hex string containing at least one colon, and possibly
+   * including dots after the first colon. It matches IPv4 addresses as strings containing only
+   * decimal digits and dots. This pattern matches strings like "a:.23" and "54" that are neither IP
+   * addresses nor hostnames; they will be verified as IP addresses (which is a more strict
+   * verification).
+   */
+  private static final Pattern VERIFY_AS_IP_ADDRESS = Pattern.compile(
+      "([0-9a-fA-F]*:[0-9a-fA-F:.]*)|([\\d.]+)");
+
   private Util() {
   }
 
@@ -62,8 +81,8 @@ public static boolean equal(Object a, Object b) {
   }
 
   /**
-   * Closes {@code closeable}, ignoring any checked exceptions. Does nothing
-   * if {@code closeable} is null.
+   * Closes {@code closeable}, ignoring any checked exceptions. Does nothing if {@code closeable} is
+   * null.
    */
   public static void closeQuietly(Closeable closeable) {
     if (closeable != null) {
@@ -77,13 +96,15 @@ public static void closeQuietly(Closeable closeable) {
   }
 
   /**
-   * Closes {@code socket}, ignoring any checked exceptions. Does nothing if
-   * {@code socket} is null.
+   * Closes {@code socket}, ignoring any checked exceptions. Does nothing if {@code socket} is
+   * null.
    */
   public static void closeQuietly(Socket socket) {
     if (socket != null) {
       try {
         socket.close();
+      } catch (AssertionError e) {
+        if (!isAndroidGetsocknameError(e)) throw e;
       } catch (RuntimeException rethrown) {
         throw rethrown;
       } catch (Exception ignored) {
@@ -92,8 +113,8 @@ public static void closeQuietly(Socket socket) {
   }
 
   /**
-   * Closes {@code serverSocket}, ignoring any checked exceptions. Does nothing if
-   * {@code serverSocket} is null.
+   * Closes {@code serverSocket}, ignoring any checked exceptions. Does nothing if {@code
+   * serverSocket} is null.
    */
   public static void closeQuietly(ServerSocket serverSocket) {
     if (serverSocket != null) {
@@ -107,8 +128,8 @@ public static void closeQuietly(ServerSocket serverSocket) {
   }
 
   /**
-   * Closes {@code a} and {@code b}. If either close fails, this completes
-   * the other close and rethrows the first encountered exception.
+   * Closes {@code a} and {@code b}. If either close fails, this completes the other close and
+   * rethrows the first encountered exception.
    */
   public static void closeAll(Closeable a, Closeable b) throws IOException {
     Throwable thrown = null;
@@ -130,8 +151,8 @@ public static void closeAll(Closeable a, Closeable b) throws IOException {
   }
 
   /**
-   * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading
-   * a complete source is helpful, such as when doing so completes a cache body or frees a socket
+   * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading a
+   * complete source is helpful, such as when doing so completes a cache body or frees a socket
    * connection for reuse.
    */
   public static boolean discard(Source source, int timeout, TimeUnit timeUnit) {
@@ -154,7 +175,7 @@ public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) th
     source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));
     try {
       Buffer skipBuffer = new Buffer();
-      while (source.read(skipBuffer, 2048) != -1) {
+      while (source.read(skipBuffer, 8192) != -1) {
         skipBuffer.clear();
       }
       return true; // Success! The source has been exhausted.
@@ -202,6 +223,17 @@ public static ByteString sha1(ByteString s) {
     }
   }
 
+  /** Returns a SHA-256 hash of {@code s}. */
+  public static ByteString sha256(ByteString s) {
+    try {
+      MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
+      byte[] sha1Bytes = messageDigest.digest(s.toByteArray());
+      return ByteString.of(sha1Bytes);
+    } catch (NoSuchAlgorithmException e) {
+      throw new AssertionError(e);
+    }
+  }
+
   /** Returns an immutable copy of {@code list}. */
   public static <T> List<T> immutableList(List<T> list) {
     return Collections.unmodifiableList(new ArrayList<>(list));
@@ -228,8 +260,8 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
   }
 
   /**
-   * Returns an array containing containing only elements found in {@code first}  and also in
-   * {@code second}. The returned elements are in the same order as in {@code first}.
+   * Returns an array containing containing only elements found in {@code first}  and also in {@code
+   * second}. The returned elements are in the same order as in {@code first}.
    */
   @SuppressWarnings("unchecked")
   public static <T> T[] intersect(Class<T> arrayType, T[] first, T[] second) {
@@ -238,8 +270,8 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
   }
 
   /**
-   * Returns a list containing containing only elements found in {@code first}  and also in
-   * {@code second}. The returned elements are in the same order as in {@code first}.
+   * Returns a list containing containing only elements found in {@code first}  and also in {@code
+   * second}. The returned elements are in the same order as in {@code first}.
    */
   private static <T> List<T> intersect(T[] first, T[] second) {
     List<T> result = new ArrayList<>();
@@ -254,11 +286,13 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
     return result;
   }
 
-  public static String hostHeader(HttpUrl url) {
-    // TODO: square braces for IPv6 ?
-    return url.port() != HttpUrl.defaultPort(url.scheme())
-        ? url.host() + ":" + url.port()
+  public static String hostHeader(HttpUrl url, boolean includeDefaultPort) {
+    String host = url.host().contains(":")
+        ? "[" + url.host() + "]"
         : url.host();
+    return includeDefaultPort || url.port() != HttpUrl.defaultPort(url.scheme())
+        ? host + ":" + url.port()
+        : host;
   }
 
   /** Returns {@code s} with control characters and non-ASCII characters replaced with '?'. */
@@ -277,4 +311,144 @@ public static String toHumanReadableAscii(String s) {
     }
     return s;
   }
+
+  /**
+   * Returns true if {@code e} is due to a firmware bug fixed after Android 4.2.2.
+   * https://code.google.com/p/android/issues/detail?id=54072
+   */
+  public static boolean isAndroidGetsocknameError(AssertionError e) {
+    return e.getCause() != null && e.getMessage() != null
+        && e.getMessage().contains("getsockname failed");
+  }
+
+  public static boolean contains(String[] array, String value) {
+    return Arrays.asList(array).contains(value);
+  }
+
+  public static String[] concat(String[] array, String value) {
+    String[] result = new String[array.length + 1];
+    System.arraycopy(array, 0, result, 0, array.length);
+    result[result.length - 1] = value;
+    return result;
+  }
+
+  /**
+   * Increments {@code pos} until {@code input[pos]} is not ASCII whitespace. Stops at {@code
+   * limit}.
+   */
+  public static int skipLeadingAsciiWhitespace(String input, int pos, int limit) {
+    for (int i = pos; i < limit; i++) {
+      switch (input.charAt(i)) {
+        case '\t':
+        case '\n':
+        case '\f':
+        case '\r':
+        case ' ':
+          continue;
+        default:
+          return i;
+      }
+    }
+    return limit;
+  }
+
+  /**
+   * Decrements {@code limit} until {@code input[limit - 1]} is not ASCII whitespace. Stops at
+   * {@code pos}.
+   */
+  public static int skipTrailingAsciiWhitespace(String input, int pos, int limit) {
+    for (int i = limit - 1; i >= pos; i--) {
+      switch (input.charAt(i)) {
+        case '\t':
+        case '\n':
+        case '\f':
+        case '\r':
+        case ' ':
+          continue;
+        default:
+          return i + 1;
+      }
+    }
+    return pos;
+  }
+
+  /** Equivalent to {@code string.substring(pos, limit).trim()}. */
+  public static String trimSubstring(String string, int pos, int limit) {
+    int start = skipLeadingAsciiWhitespace(string, pos, limit);
+    int end = skipTrailingAsciiWhitespace(string, start, limit);
+    return string.substring(start, end);
+  }
+
+  /**
+   * Returns the index of the first character in {@code input} that contains a character in {@code
+   * delimiters}. Returns limit if there is no such character.
+   */
+  public static int delimiterOffset(String input, int pos, int limit, String delimiters) {
+    for (int i = pos; i < limit; i++) {
+      if (delimiters.indexOf(input.charAt(i)) != -1) return i;
+    }
+    return limit;
+  }
+
+  /**
+   * Returns the index of the first character in {@code input} that is {@code delimiter}. Returns
+   * limit if there is no such character.
+   */
+  public static int delimiterOffset(String input, int pos, int limit, char delimiter) {
+    for (int i = pos; i < limit; i++) {
+      if (input.charAt(i) == delimiter) return i;
+    }
+    return limit;
+  }
+
+  /**
+   * Performs IDN ToASCII encoding and canonicalize the result to lowercase. e.g. This converts
+   * {@code ☃.net} to {@code xn--n3h.net}, and {@code WwW.GoOgLe.cOm} to {@code www.google.com}.
+   * {@code null} will be returned if the input cannot be ToASCII encoded or if the result
+   * contains unsupported ASCII characters.
+   */
+  public static String domainToAscii(String input) {
+    try {
+      String result = IDN.toASCII(input).toLowerCase(Locale.US);
+      if (result.isEmpty()) return null;
+
+      // Confirm that the IDN ToASCII result doesn't contain any illegal characters.
+      if (containsInvalidHostnameAsciiCodes(result)) {
+        return null;
+      }
+      // TODO: implement all label limits.
+      return result;
+    } catch (IllegalArgumentException e) {
+      return null;
+    }
+  }
+
+  private static boolean containsInvalidHostnameAsciiCodes(String hostnameAscii) {
+    for (int i = 0; i < hostnameAscii.length(); i++) {
+      char c = hostnameAscii.charAt(i);
+      // The WHATWG Host parsing rules accepts some character codes which are invalid by
+      // definition for OkHttp's host header checks (and the WHATWG Host syntax definition). Here
+      // we rule out characters that would cause problems in host headers.
+      if (c <= '\u001f' || c >= '\u007f') {
+        return true;
+      }
+      // Check for the characters mentioned in the WHATWG Host parsing spec:
+      // U+0000, U+0009, U+000A, U+000D, U+0020, "#", "%", "/", ":", "?", "@", "[", "\", and "]"
+      // (excluding the characters covered above).
+      if (" #%/:?@[\\]".indexOf(c) != -1) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /** Returns true if {@code host} is not a host name and might be an IP address. */
+  public static boolean verifyAsIpAddress(String host) {
+    return VERIFY_AS_IP_ADDRESS.matcher(host).matches();
+  }
+
+  /** Returns a {@link Locale#US} formatted {@link String}. */
+  public static String format(String format, Object... args) {
+    return String.format(Locale.US, format, args);
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/ErrorCode.java b/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java
similarity index 98%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/framed/ErrorCode.java
rename to okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java
index 0edd5ef74f..1142319d7e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/ErrorCode.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/ErrorCode.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
 // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-7
 public enum ErrorCode {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameReader.java b/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java
similarity index 62%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameReader.java
rename to okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java
index 9f7f0868b2..741a568c0d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FrameReader.java
@@ -13,8 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -25,6 +24,7 @@
 /** Reads transport frames for SPDY/3 or HTTP/2. */
 public interface FrameReader extends Closeable {
   void readConnectionPreface() throws IOException;
+
   boolean nextFrame(Handler handler) throws IOException;
 
   interface Handler {
@@ -32,100 +32,92 @@ void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException;
 
     /**
-     * Create or update incoming headers, creating the corresponding streams
-     * if necessary. Frames that trigger this are SPDY SYN_STREAM, HEADERS, and
-     * SYN_REPLY, and HTTP/2 HEADERS and PUSH_PROMISE.
+     * Create or update incoming headers, creating the corresponding streams if necessary. Frames
+     * that trigger this are SPDY SYN_STREAM, HEADERS, and SYN_REPLY, and HTTP/2 HEADERS and
+     * PUSH_PROMISE.
      *
      * @param outFinished true if the receiver should not send further frames.
      * @param inFinished true if the sender will not send further frames.
      * @param streamId the stream owning these headers.
-     * @param associatedStreamId the stream that triggered the sender to create
-     *     this stream.
+     * @param associatedStreamId the stream that triggered the sender to create this stream.
      */
     void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
         List<Header> headerBlock, HeadersMode headersMode);
+
     void rstStream(int streamId, ErrorCode errorCode);
+
     void settings(boolean clearPrevious, Settings settings);
 
     /** HTTP/2 only. */
     void ackSettings();
 
     /**
-     *  Read a connection-level ping from the peer.  {@code ack} indicates this
-     *  is a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
-     *  <p>
-     *  In SPDY/3, only the first {@code payload1} parameter is set.  If the
-     *  reader is a client, it is an unsigned even number.  Likewise, a server
-     *  will receive an odd number.
-     *  <p>
-     *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
-     *  set. The data is opaque binary, and there are no rules on the content.
+     * Read a connection-level ping from the peer.  {@code ack} indicates this is a reply.  Payload
+     * parameters are different between SPDY/3 and HTTP/2.
+     *
+     * <p>In SPDY/3, only the first {@code payload1} parameter is set.  If the reader is a client,
+     * it is an unsigned even number. Likewise, a server will receive an odd number.
+     *
+     * <p>In HTTP/2, both {@code payload1} and {@code payload2} parameters are set. The data is
+     * opaque binary, and there are no rules on the content.
      */
     void ping(boolean ack, int payload1, int payload2);
 
     /**
-     * The peer tells us to stop creating streams.  It is safe to replay
-     * streams with {@code ID > lastGoodStreamId} on a new connection.  In-
-     * flight streams with {@code ID <= lastGoodStreamId} can only be replayed
-     * on a new connection if they are idempotent.
+     * The peer tells us to stop creating streams.  It is safe to replay streams with {@code ID >
+     * lastGoodStreamId} on a new connection.  In- flight streams with {@code ID <=
+     * lastGoodStreamId} can only be replayed on a new connection if they are idempotent.
      *
-     * @param lastGoodStreamId the last stream ID the peer processed before
-     *     sending this message. If {@code lastGoodStreamId} is zero, the peer
-     *     processed no frames.
+     * @param lastGoodStreamId the last stream ID the peer processed before sending this message. If
+     * {@code lastGoodStreamId} is zero, the peer processed no frames.
      * @param errorCode reason for closing the connection.
      * @param debugData only valid for HTTP/2; opaque debug data to send.
      */
     void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData);
 
     /**
-     * Notifies that an additional {@code windowSizeIncrement} bytes can be
-     * sent on {@code streamId}, or the connection if {@code streamId} is zero.
+     * Notifies that an additional {@code windowSizeIncrement} bytes can be sent on {@code
+     * streamId}, or the connection if {@code streamId} is zero.
      */
     void windowUpdate(int streamId, long windowSizeIncrement);
 
     /**
-     * Called when reading a headers or priority frame. This may be used to
-     * change the stream's weight from the default (16) to a new value.
+     * Called when reading a headers or priority frame. This may be used to change the stream's
+     * weight from the default (16) to a new value.
      *
      * @param streamId stream which has a priority change.
      * @param streamDependency the stream ID this stream is dependent on.
      * @param weight relative proportion of priority in [1..256].
-     * @param exclusive inserts this stream ID as the sole child of
-     *     {@code streamDependency}.
+     * @param exclusive inserts this stream ID as the sole child of {@code streamDependency}.
      */
     void priority(int streamId, int streamDependency, int weight, boolean exclusive);
 
     /**
-     * HTTP/2 only. Receive a push promise header block.
-     * <p>
-     * A push promise contains all the headers that pertain to a server-initiated
-     * request, and a {@code promisedStreamId} to which response frames will be
-     * delivered. Push promise frames are sent as a part of the response to
-     * {@code streamId}.
+     * HTTP/2 only. Receive a push promise header block. <p> A push promise contains all the headers
+     * that pertain to a server-initiated request, and a {@code promisedStreamId} to which response
+     * frames will be delivered. Push promise frames are sent as a part of the response to {@code
+     * streamId}.
      *
      * @param streamId client-initiated stream ID.  Must be an odd number.
-     * @param promisedStreamId server-initiated stream ID.  Must be an even
-     * number.
-     * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
-     * {@code :authority}, and (@code :path}.
+     * @param promisedStreamId server-initiated stream ID.  Must be an even number.
+     * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code
+     * :authority}, and (@code :path}.
      */
     void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
         throws IOException;
 
     /**
-     * HTTP/2 only. Expresses that resources for the connection or a client-
-     * initiated stream are available from a different network location or
-     * protocol configuration.
+     * HTTP/2 only. Expresses that resources for the connection or a client- initiated stream are
+     * available from a different network location or protocol configuration.
      *
      * <p>See <a href="http://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>
      *
-     * @param streamId when a client-initiated stream ID (odd number), the
-     *     origin of this alternate service is the origin of the stream. When
-     *     zero, the origin is specified in the {@code origin} parameter.
-     * @param origin when present, the
-     *     <a href="http://tools.ietf.org/html/rfc6454">origin</a> is typically
-     *     represented as a combination of scheme, host and port. When empty,
-     *     the origin is that of the {@code streamId}.
+     * @param streamId when a client-initiated stream ID (odd number), the origin of this alternate
+     * service is the origin of the stream. When zero, the origin is specified in the {@code origin}
+     * parameter.
+     * @param origin when present, the <a href="http://tools.ietf.org/html/rfc6454">origin</a> is
+     * typically represented as a combination of scheme, host and port. When empty, the origin is
+     * that of the {@code streamId}.
      * @param protocol an ALPN protocol, such as {@code h2}.
      * @param host an IP address or hostname.
      * @param port the IP port associated with the service.
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameWriter.java b/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java
similarity index 71%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameWriter.java
rename to okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java
index dcaaf3ac90..5e8c7ebef9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FrameWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FrameWriter.java
@@ -13,8 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -25,34 +24,37 @@
 public interface FrameWriter extends Closeable {
   /** HTTP/2 only. */
   void connectionPreface() throws IOException;
+
   /** Informs the peer that we've applied its latest settings. */
   void ackSettings(Settings peerSettings) throws IOException;
 
   /**
    * HTTP/2 only. Send a push promise header block.
-   * <p>
-   * A push promise contains all the headers that pertain to a server-initiated
-   * request, and a {@code promisedStreamId} to which response frames will be
-   * delivered. Push promise frames are sent as a part of the response to
-   * {@code streamId}.  The {@code promisedStreamId} has a priority of one
-   * greater than {@code streamId}.
+   *
+   * <p>A push promise contains all the headers that pertain to a server-initiated request, and a
+   * {@code promisedStreamId} to which response frames will be delivered. Push promise frames are
+   * sent as a part of the response to {@code streamId}. The {@code promisedStreamId} has a priority
+   * of one greater than {@code streamId}.
    *
    * @param streamId client-initiated stream ID.  Must be an odd number.
-   * @param promisedStreamId server-initiated stream ID.  Must be an even
-   * number.
-   * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
-   * {@code :authority}, and (@code :path}.
+   * @param promisedStreamId server-initiated stream ID.  Must be an even number.
+   * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
+   * and (@code :path}.
    */
   void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
       throws IOException;
 
   /** SPDY/3 only. */
   void flush() throws IOException;
+
   void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
       List<Header> headerBlock) throws IOException;
+
   void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
       throws IOException;
+
   void headers(int streamId, List<Header> headerBlock) throws IOException;
+
   void rstStream(int streamId, ErrorCode errorCode) throws IOException;
 
   /** The maximum size of bytes that may be sent in a single call to {@link #data}. */
@@ -63,8 +65,8 @@ void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
    * Implementations must send multiple frames as necessary.
    *
    * @param source the buffer to draw bytes from. May be null if byteCount is 0.
-   * @param byteCount must be between 0 and the minimum of {code source.length}
-   * and {@link #maxDataLength}.
+   * @param byteCount must be between 0 and the minimum of {code source.length} and {@link
+   * #maxDataLength}.
    */
   void data(boolean outFinished, int streamId, Buffer source, int byteCount) throws IOException;
 
@@ -72,32 +74,30 @@ void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
   void settings(Settings okHttpSettings) throws IOException;
 
   /**
-   *  Send a connection-level ping to the peer.  {@code ack} indicates this is
-   *  a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
-   *  <p>
-   *  In SPDY/3, only the first {@code payload1} parameter is sent.  If the
-   *  sender is a client, it is an unsigned odd number.  Likewise, a server
-   *  will send an even number.
-   *  <p>
-   *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
-   *  sent.  The data is opaque binary, and there are no rules on the content.
+   * Send a connection-level ping to the peer.  {@code ack} indicates this is a reply.  Payload
+   * parameters are different between SPDY/3 and HTTP/2.
+   *
+   * <p>In SPDY/3, only the first {@code payload1} parameter is sent.  If the sender is a client, it
+   * is an unsigned odd number. Likewise, a server will send an even number.
+   *
+   * <p>In HTTP/2, both {@code payload1} and {@code payload2} parameters are sent.  The data is
+   * opaque binary, and there are no rules on the content.
    */
   void ping(boolean ack, int payload1, int payload2) throws IOException;
 
   /**
-   * Tell the peer to stop creating streams and that we last processed
-   * {@code lastGoodStreamId}, or zero if no streams were processed.
+   * Tell the peer to stop creating streams and that we last processed {@code lastGoodStreamId}, or
+   * zero if no streams were processed.
    *
-   * @param lastGoodStreamId the last stream ID processed, or zero if no
-   * streams were processed.
+   * @param lastGoodStreamId the last stream ID processed, or zero if no streams were processed.
    * @param errorCode reason for closing the connection.
    * @param debugData only valid for HTTP/2; opaque debug data to send.
    */
   void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) throws IOException;
 
   /**
-   * Inform peer that an additional {@code windowSizeIncrement} bytes can be
-   * sent on {@code streamId}, or the connection if {@code streamId} is zero.
+   * Inform peer that an additional {@code windowSizeIncrement} bytes can be sent on {@code
+   * streamId}, or the connection if {@code streamId} is zero.
    */
   void windowUpdate(int streamId, long windowSizeIncrement) throws IOException;
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java b/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
similarity index 81%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java
rename to okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
index a86924b897..7e1a582be0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FramedConnection.java
@@ -13,11 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.internal.Util;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
@@ -33,23 +30,27 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
+import okhttp3.Protocol;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Platform;
+import okhttp3.internal.Util;
 import okio.Buffer;
+import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Okio;
 
-import static com.squareup.okhttp.internal.Internal.logger;
-import static com.squareup.okhttp.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.Platform.INFO;
+import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 
 /**
- * A socket connection to a remote peer. A connection hosts streams which can
- * send and receive data.
+ * A socket connection to a remote peer. A connection hosts streams which can send and receive
+ * data.
  *
- * <p>Many methods in this API are <strong>synchronous:</strong> the call is
- * completed before the method returns. This is typical for Java but atypical
- * for SPDY. This is motivated by exception transparency: an IOException that
- * was triggered by a certain caller can be caught and handled by that caller.
+ * <p>Many methods in this API are <strong>synchronous:</strong> the call is completed before the
+ * method returns. This is typical for Java but atypical for SPDY. This is motivated by exception
+ * transparency: an IOException that was triggered by a certain caller can be caught and handled by
+ * that caller.
  */
 public final class FramedConnection implements Closeable {
 
@@ -69,19 +70,19 @@
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
       Util.threadFactory("OkHttp FramedConnection", true));
 
-  /** The protocol variant, like {@link com.squareup.okhttp.internal.framed.Spdy3}. */
+  /** The protocol variant, like {@link Spdy3}. */
   final Protocol protocol;
 
   /** True if this peer initiated the connection. */
   final boolean client;
 
   /**
-   * User code to run in response to an incoming stream. Callbacks must not be
-   * run on the callback executor.
+   * User code to run in response to incoming streams or settings. Calls to this are always invoked
+   * on {@link #executor}.
    */
-  private final IncomingStreamHandler handler;
+  private final Listener listener;
   private final Map<Integer, FramedStream> streams = new HashMap<>();
-  private final String hostName;
+  private final String hostname;
   private int lastGoodStreamId;
   private int nextStreamId;
   private boolean shutdown;
@@ -97,23 +98,21 @@
   private int nextPingId;
 
   /**
-   * The total number of bytes consumed by the application, but not yet
-   * acknowledged by sending a {@code WINDOW_UPDATE} frame on this connection.
+   * The total number of bytes consumed by the application, but not yet acknowledged by sending a
+   * {@code WINDOW_UPDATE} frame on this connection.
    */
   // Visible for testing
   long unacknowledgedBytesRead = 0;
 
   /**
-   * Count of bytes that can be written on the connection before receiving a
-   * window update.
+   * Count of bytes that can be written on the connection before receiving a window update.
    */
   // Visible for testing
   long bytesLeftInWriteWindow;
 
   /** Settings we communicate to the peer. */
-  // TODO: Do we want to dynamically adjust settings, or KISS and only set once?
-  final Settings okHttpSettings = new Settings();
-      // okHttpSettings.set(Settings.MAX_CONCURRENT_STREAMS, 0, max);
+  Settings okHttpSettings = new Settings();
+
   private static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
 
   /** Settings we receive from the peer. */
@@ -132,7 +131,7 @@ private FramedConnection(Builder builder) throws IOException {
     protocol = builder.protocol;
     pushObserver = builder.pushObserver;
     client = builder.client;
-    handler = builder.handler;
+    listener = builder.listener;
     // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-5.1.1
     nextStreamId = builder.client ? 1 : 2;
     if (builder.client && protocol == Protocol.HTTP_2) {
@@ -149,14 +148,14 @@ private FramedConnection(Builder builder) throws IOException {
       okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, OKHTTP_CLIENT_WINDOW_SIZE);
     }
 
-    hostName = builder.hostName;
+    hostname = builder.hostname;
 
     if (protocol == Protocol.HTTP_2) {
       variant = new Http2();
       // Like newSingleThreadExecutor, except lazy creates the thread.
       pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
           new LinkedBlockingQueue<Runnable>(),
-          Util.threadFactory(String.format("OkHttp %s Push Observer", hostName), true));
+          Util.threadFactory(Util.format("OkHttp %s Push Observer", hostname), true));
       // 1 less than SPDY http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-6.9.2
       peerSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
       peerSettings.set(Settings.MAX_FRAME_SIZE, 0, Http2.INITIAL_MAX_FRAME_SIZE);
@@ -168,10 +167,9 @@ private FramedConnection(Builder builder) throws IOException {
     }
     bytesLeftInWriteWindow = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
     socket = builder.socket;
-    frameWriter = variant.newWriter(Okio.buffer(Okio.sink(builder.socket)), client);
+    frameWriter = variant.newWriter(builder.sink, client);
 
-    readerRunnable = new Reader();
-    new Thread(readerRunnable).start(); // Not a daemon thread.
+    readerRunnable = new Reader(variant.newReader(builder.source, client));
   }
 
   /** The protocol as selected using ALPN. */
@@ -180,8 +178,7 @@ public Protocol getProtocol() {
   }
 
   /**
-   * Returns the number of {@link FramedStream#isOpen() open streams} on this
-   * connection.
+   * Returns the number of {@link FramedStream#isOpen() open streams} on this connection.
    */
   public synchronized int openStreamCount() {
     return streams.size();
@@ -209,9 +206,13 @@ public synchronized boolean isIdle() {
     return idleStartTimeNs != Long.MAX_VALUE;
   }
 
+  public synchronized int maxConcurrentStreams() {
+    return peerSettings.getMaxConcurrentStreams(Integer.MAX_VALUE);
+  }
+
   /**
-   * Returns the time in ns when this connection became idle or Long.MAX_VALUE
-   * if connection is not idle.
+   * Returns the time in ns when this connection became idle or Long.MAX_VALUE if connection is not
+   * idle.
    */
   public synchronized long getIdleStartTimeNs() {
     return idleStartTimeNs;
@@ -220,10 +221,9 @@ public synchronized long getIdleStartTimeNs() {
   /**
    * Returns a new server-initiated stream.
    *
-   * @param associatedStreamId the stream that triggered the sender to create
-   *     this stream.
-   * @param out true to create an output stream that we can use to send data
-   *     to the remote peer. Corresponds to {@code FLAG_FIN}.
+   * @param associatedStreamId the stream that triggered the sender to create this stream.
+   * @param out true to create an output stream that we can use to send data to the remote peer.
+   * Corresponds to {@code FLAG_FIN}.
    */
   public FramedStream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
       throws IOException {
@@ -236,9 +236,9 @@ public FramedStream pushStream(int associatedStreamId, List<Header> requestHeade
    * Returns a new locally-initiated stream.
    *
    * @param out true to create an output stream that we can use to send data to the remote peer.
-   *     Corresponds to {@code FLAG_FIN}.
+   * Corresponds to {@code FLAG_FIN}.
    * @param in true to create an input stream that the remote peer can use to send data to us.
-   *     Corresponds to {@code FLAG_UNIDIRECTIONAL}.
+   * Corresponds to {@code FLAG_UNIDIRECTIONAL}.
    */
   public FramedStream newStream(List<Header> requestHeaders, boolean out, boolean in)
       throws IOException {
@@ -333,8 +333,7 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
   }
 
   /**
-   * {@code delta} will be negative if a settings frame initial window is
-   * smaller than the last.
+   * {@code delta} will be negative if a settings frame initial window is smaller than the last.
    */
   void addBytesToWriteWindow(long delta) {
     bytesLeftInWriteWindow += delta;
@@ -342,7 +341,7 @@ void addBytesToWriteWindow(long delta) {
   }
 
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
-    executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
+    executor.submit(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
       @Override public void execute() {
         try {
           writeSynReset(streamId, errorCode);
@@ -357,7 +356,7 @@ void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
   }
 
   void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
-    executor.execute(new NamedRunnable("OkHttp Window Update %s stream %d", hostName, streamId) {
+    executor.execute(new NamedRunnable("OkHttp Window Update %s stream %d", hostname, streamId) {
       @Override public void execute() {
         try {
           frameWriter.windowUpdate(streamId, unacknowledgedBytesRead);
@@ -368,8 +367,8 @@ void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRe
   }
 
   /**
-   * Sends a ping frame to the peer. Use the returned object to await the
-   * ping's response and observe its round trip time.
+   * Sends a ping frame to the peer. Use the returned object to await the ping's response and
+   * observe its round trip time.
    */
   public Ping ping() throws IOException {
     Ping ping = new Ping();
@@ -390,7 +389,7 @@ public Ping ping() throws IOException {
   private void writePingLater(
       final boolean reply, final int payload1, final int payload2, final Ping ping) {
     executor.execute(new NamedRunnable("OkHttp %s ping %08x%08x",
-        hostName, payload1, payload2) {
+        hostname, payload1, payload2) {
       @Override public void execute() {
         try {
           writePing(reply, payload1, payload2, ping);
@@ -417,10 +416,9 @@ public void flush() throws IOException {
   }
 
   /**
-   * Degrades this connection such that new streams can neither be created
-   * locally, nor accepted from the remote peer. Existing streams are not
-   * impacted. This is intended to permit an endpoint to gracefully stop
-   * accepting new requests without harming previously established streams.
+   * Degrades this connection such that new streams can neither be created locally, nor accepted
+   * from the remote peer. Existing streams are not impacted. This is intended to permit an endpoint
+   * to gracefully stop accepting new requests without harming previously established streams.
    */
   public void shutdown(ErrorCode statusCode) throws IOException {
     synchronized (frameWriter) {
@@ -438,9 +436,8 @@ public void shutdown(ErrorCode statusCode) throws IOException {
   }
 
   /**
-   * Closes this connection. This cancels all open streams and unanswered
-   * pings. It closes the underlying input and output streams and shuts down
-   * internal executor services.
+   * Closes this connection. This cancels all open streams and unanswered pings. It closes the
+   * underlying input and output streams and shuts down internal executor services.
    */
   @Override public void close() throws IOException {
     close(ErrorCode.NO_ERROR, ErrorCode.CANCEL);
@@ -503,42 +500,76 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
   }
 
   /**
-   * Sends a connection header if the current variant requires it. This should
-   * be called after {@link Builder#build} for all new connections.
+   * Sends any initial frames and starts reading frames from the remote peer. This should be called
+   * after {@link Builder#build} for all new connections.
    */
-  public void sendConnectionPreface() throws IOException {
-    frameWriter.connectionPreface();
-    frameWriter.settings(okHttpSettings);
-    int windowSize = okHttpSettings.getInitialWindowSize(Settings.DEFAULT_INITIAL_WINDOW_SIZE);
-    if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) {
-      frameWriter.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+  public void start() throws IOException {
+    start(true);
+  }
+
+  /**
+   * @param sendConnectionPreface true to send connection preface frames. This should always be true
+   *     except for in tests that don't check for a connection preface.
+   */
+  void start(boolean sendConnectionPreface) throws IOException {
+    if (sendConnectionPreface) {
+      frameWriter.connectionPreface();
+      frameWriter.settings(okHttpSettings);
+      int windowSize = okHttpSettings.getInitialWindowSize(Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+      if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) {
+        frameWriter.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+      }
+    }
+    new Thread(readerRunnable).start(); // Not a daemon thread.
+  }
+
+  /** Merges {@code settings} into this peer's settings and sends them to the remote peer. */
+  public void setSettings(Settings settings) throws IOException {
+    synchronized (frameWriter) {
+      synchronized (this) {
+        if (shutdown) {
+          throw new IOException("shutdown");
+        }
+        okHttpSettings.merge(settings);
+        frameWriter.settings(settings);
+      }
     }
   }
 
   public static class Builder {
-    private String hostName;
     private Socket socket;
-    private IncomingStreamHandler handler = IncomingStreamHandler.REFUSE_INCOMING_STREAMS;
+    private String hostname;
+    private BufferedSource source;
+    private BufferedSink sink;
+    private Listener listener = Listener.REFUSE_INCOMING_STREAMS;
     private Protocol protocol = Protocol.SPDY_3;
     private PushObserver pushObserver = PushObserver.CANCEL;
     private boolean client;
 
-    public Builder(boolean client, Socket socket) throws IOException {
-      this(((InetSocketAddress) socket.getRemoteSocketAddress()).getHostName(), client, socket);
-    }
-
     /**
-     * @param client true if this peer initiated the connection; false if this
-     *     peer accepted the connection.
+     * @param client true if this peer initiated the connection; false if this peer accepted the
+     * connection.
      */
-    public Builder(String hostName, boolean client, Socket socket) throws IOException {
-      this.hostName = hostName;
+    public Builder(boolean client) throws IOException {
       this.client = client;
+    }
+
+    public Builder socket(Socket socket) throws IOException {
+      return socket(socket, ((InetSocketAddress) socket.getRemoteSocketAddress()).getHostName(),
+          Okio.buffer(Okio.source(socket)), Okio.buffer(Okio.sink(socket)));
+    }
+
+    public Builder socket(
+        Socket socket, String hostname, BufferedSource source, BufferedSink sink) {
       this.socket = socket;
+      this.hostname = hostname;
+      this.source = source;
+      this.sink = sink;
+      return this;
     }
 
-    public Builder handler(IncomingStreamHandler handler) {
-      this.handler = handler;
+    public Builder listener(Listener listener) {
+      this.listener = listener;
       return this;
     }
 
@@ -558,21 +589,21 @@ public FramedConnection build() throws IOException {
   }
 
   /**
-   * Methods in this class must not lock FrameWriter.  If a method needs to
-   * write a frame, create an async task to do so.
+   * Methods in this class must not lock FrameWriter.  If a method needs to write a frame, create an
+   * async task to do so.
    */
   class Reader extends NamedRunnable implements FrameReader.Handler {
-    FrameReader frameReader;
+    final FrameReader frameReader;
 
-    private Reader() {
-      super("OkHttp %s", hostName);
+    private Reader(FrameReader frameReader) {
+      super("OkHttp %s", hostname);
+      this.frameReader = frameReader;
     }
 
     @Override protected void execute() {
       ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
       ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
       try {
-        frameReader = variant.newReader(Okio.buffer(Okio.source(socket)), client);
         if (!client) {
           frameReader.readConnectionPreface();
         }
@@ -642,12 +673,12 @@ private Reader() {
               inFinished, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
-          executor.execute(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
+          executor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
             @Override public void execute() {
               try {
-                handler.receive(newStream);
+                listener.onStream(newStream);
               } catch (IOException e) {
-                logger.log(Level.INFO, "StreamHandler failure for " + hostName, e);
+                Platform.get().log(INFO, "FramedConnection.Listener failure for " + hostname, e);
                 try {
                   newStream.close(ErrorCode.PROTOCOL_ERROR);
                 } catch (IOException ignored) {
@@ -703,6 +734,11 @@ private Reader() {
             streamsToNotify = streams.values().toArray(new FramedStream[streams.size()]);
           }
         }
+        executor.execute(new NamedRunnable("OkHttp %s settings", hostname) {
+          @Override public void execute() {
+            listener.onSettings(FramedConnection.this);
+          }
+        });
       }
       if (streamsToNotify != null && delta != 0) {
         for (FramedStream stream : streamsToNotify) {
@@ -714,7 +750,7 @@ private Reader() {
     }
 
     private void ackSettingsLater(final Settings peerSettings) {
-      executor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostName) {
+      executor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostname) {
         @Override public void execute() {
           try {
             frameWriter.ackSettings(peerSettings);
@@ -808,7 +844,7 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
       }
       currentPushRequests.add(streamId);
     }
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Request[%s]", hostname, streamId) {
       @Override public void execute() {
         boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
         try {
@@ -826,7 +862,7 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
 
   private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
       final boolean inFinished) {
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostname, streamId) {
       @Override public void execute() {
         boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
         try {
@@ -852,7 +888,7 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
     source.require(byteCount); // Eagerly read the frame before firing client thread.
     source.read(buffer, byteCount);
     if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Data[%s]", hostname, streamId) {
       @Override public void execute() {
         try {
           boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
@@ -869,7 +905,7 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
   }
 
   private void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
+    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostname, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
         synchronized (FramedConnection.this) {
@@ -878,4 +914,31 @@ private void pushResetLater(final int streamId, final ErrorCode errorCode) {
       }
     });
   }
+
+  /** Listener of streams and settings initiated by the peer. */
+  public abstract static class Listener {
+    public static final Listener REFUSE_INCOMING_STREAMS = new Listener() {
+      @Override public void onStream(FramedStream stream) throws IOException {
+        stream.close(ErrorCode.REFUSED_STREAM);
+      }
+    };
+
+    /**
+     * Handle a new stream from this connection's peer. Implementations should respond by either
+     * {@linkplain FramedStream#reply replying to the stream} or {@linkplain FramedStream#close
+     * closing it}. This response does not need to be synchronous.
+     */
+    public abstract void onStream(FramedStream stream) throws IOException;
+
+    /**
+     * Notification that the connection's peer's settings may have changed. Implementations should
+     * take appropriate action to handle the updated settings.
+     *
+     * <p>It is the implementation's responsibility to handle concurrent calls to this method. A
+     * remote peer that sends multiple settings frames will trigger multiple calls to this method,
+     * and those calls are not necessarily serialized.
+     */
+    public void onSettings(FramedConnection connection) {
+    }
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedStream.java b/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
similarity index 90%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedStream.java
rename to okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
index a47b12e627..c94a8449ec 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/FramedStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/FramedStream.java
@@ -13,8 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
 import java.io.EOFException;
 import java.io.IOException;
@@ -29,7 +28,7 @@
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static okhttp3.internal.framed.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 
 /** A logical bidirectional stream. */
 public final class FramedStream {
@@ -37,17 +36,16 @@
   // blocking operations are performed while the lock is held.
 
   /**
-   * The total number of bytes consumed by the application (with {@link
-   * FramedDataSource#read}), but not yet acknowledged by sending a {@code
-   * WINDOW_UPDATE} frame on this stream.
+   * The total number of bytes consumed by the application (with {@link FramedDataSource#read}), but
+   * not yet acknowledged by sending a {@code WINDOW_UPDATE} frame on this stream.
    */
   // Visible for testing
   long unacknowledgedBytesRead = 0;
 
   /**
-   * Count of bytes that can be written on the stream before receiving a
-   * window update. Even if this is positive, writes will block until there
-   * available bytes in {@code connection.bytesLeftInWriteWindow}.
+   * Count of bytes that can be written on the stream before receiving a window update. Even if this
+   * is positive, writes will block until there available bytes in {@code
+   * connection.bytesLeftInWriteWindow}.
    */
   // guarded by this
   long bytesLeftInWriteWindow;
@@ -67,9 +65,9 @@
   private final StreamTimeout writeTimeout = new StreamTimeout();
 
   /**
-   * The reason why this stream was abnormally closed. If there are multiple
-   * reasons to abnormally close this stream (such as both peers closing it
-   * near-simultaneously) then this is the first reason known to this peer.
+   * The reason why this stream was abnormally closed. If there are multiple reasons to abnormally
+   * close this stream (such as both peers closing it near-simultaneously) then this is the first
+   * reason known to this peer.
    */
   private ErrorCode errorCode = null;
 
@@ -95,13 +93,14 @@ public int getId() {
 
   /**
    * Returns true if this stream is open. A stream is open until either:
+   *
    * <ul>
-   * <li>A {@code SYN_RESET} frame abnormally terminates the stream.
-   * <li>Both input and output streams have transmitted all data and
-   * headers.
+   *     <li>A {@code SYN_RESET} frame abnormally terminates the stream.
+   *     <li>Both input and output streams have transmitted all data and headers.
    * </ul>
-   * Note that the input stream may continue to yield data even after a stream
-   * reports itself as not open. This is because input data is buffered.
+   *
+   * <p>Note that the input stream may continue to yield data even after a stream reports itself as
+   * not open. This is because input data is buffered.
    */
   public synchronized boolean isOpen() {
     if (errorCode != null) {
@@ -130,8 +129,8 @@ public FramedConnection getConnection() {
   }
 
   /**
-   * Returns the stream's response headers, blocking if necessary if they
-   * have not been received yet.
+   * Returns the stream's response headers, blocking if necessary if they have not been received
+   * yet.
    */
   public synchronized List<Header> getResponseHeaders() throws IOException {
     readTimeout.enter();
@@ -147,8 +146,8 @@ public FramedConnection getConnection() {
   }
 
   /**
-   * Returns the reason why this stream was closed, or null if it closed
-   * normally or has not yet been closed.
+   * Returns the reason why this stream was closed, or null if it closed normally or has not yet
+   * been closed.
    */
   public synchronized ErrorCode getErrorCode() {
     return errorCode;
@@ -157,8 +156,8 @@ public synchronized ErrorCode getErrorCode() {
   /**
    * Sends a reply to an incoming stream.
    *
-   * @param out true to create an output stream that we can use to send data
-   * to the remote peer. Corresponds to {@code FLAG_FIN}.
+   * @param out true to create an output stream that we can use to send data to the remote peer.
+   * Corresponds to {@code FLAG_FIN}.
    */
   public void reply(List<Header> responseHeaders, boolean out) throws IOException {
     assert (!Thread.holdsLock(FramedStream.this));
@@ -199,8 +198,8 @@ public Source getSource() {
   /**
    * Returns a sink that can be used to write data to the peer.
    *
-   * @throws IllegalStateException if this stream was initiated by the peer
-   *     and a {@link #reply} has not yet been sent.
+   * @throws IllegalStateException if this stream was initiated by the peer and a {@link #reply} has
+   * not yet been sent.
    */
   public Sink getSink() {
     synchronized (this) {
@@ -212,8 +211,8 @@ public Sink getSink() {
   }
 
   /**
-   * Abnormally terminate this stream. This blocks until the {@code RST_STREAM}
-   * frame has been transmitted.
+   * Abnormally terminate this stream. This blocks until the {@code RST_STREAM} frame has been
+   * transmitted.
    */
   public void close(ErrorCode rstStatusCode) throws IOException {
     if (!closeInternal(rstStatusCode)) {
@@ -223,8 +222,8 @@ public void close(ErrorCode rstStatusCode) throws IOException {
   }
 
   /**
-   * Abnormally terminate this stream. This enqueues a {@code RST_STREAM}
-   * frame and returns immediately.
+   * Abnormally terminate this stream. This enqueues a {@code RST_STREAM} frame and returns
+   * immediately.
    */
   public void closeLater(ErrorCode errorCode) {
     if (!closeInternal(errorCode)) {
@@ -307,9 +306,9 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
   }
 
   /**
-   * A source that reads the incoming data frames of a stream. Although this
-   * class uses synchronization to safely receive incoming data frames, it is
-   * not intended for use by multiple readers.
+   * A source that reads the incoming data frames of a stream. Although this class uses
+   * synchronization to safely receive incoming data frames, it is not intended for use by multiple
+   * readers.
    */
   private final class FramedDataSource implements Source {
     /** Buffer to receive data from the network into. Only accessed by the reader thread. */
@@ -325,8 +324,8 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     private boolean closed;
 
     /**
-     * True if either side has cleanly shut down this stream. We will
-     * receive no more bytes beyond those already in the buffer.
+     * True if either side has cleanly shut down this stream. We will receive no more bytes beyond
+     * those already in the buffer.
      */
     private boolean finished;
 
@@ -464,23 +463,21 @@ private void cancelStreamIfNecessary() throws IOException {
   }
 
   /**
-   * A sink that writes outgoing data frames of a stream. This class is not
-   * thread safe.
+   * A sink that writes outgoing data frames of a stream. This class is not thread safe.
    */
   final class FramedDataSink implements Sink {
     private static final long EMIT_BUFFER_SIZE = 16384;
 
     /**
-     * Buffer of outgoing data. This batches writes of small writes into this sink as larges
-     * frames written to the outgoing connection. Batching saves the (small) framing overhead.
+     * Buffer of outgoing data. This batches writes of small writes into this sink as larges frames
+     * written to the outgoing connection. Batching saves the (small) framing overhead.
      */
     private final Buffer sendBuffer = new Buffer();
 
     private boolean closed;
 
     /**
-     * True if either side has cleanly shut down this stream. We shall send
-     * no more bytes.
+     * True if either side has cleanly shut down this stream. We shall send no more bytes.
      */
     private boolean finished;
 
@@ -561,8 +558,7 @@ private void emitDataFrame(boolean outFinished) throws IOException {
   }
 
   /**
-   * {@code delta} will be negative if a settings frame initial window is
-   * smaller than the last.
+   * {@code delta} will be negative if a settings frame initial window is smaller than the last.
    */
   void addBytesToWriteWindow(long delta) {
     bytesLeftInWriteWindow += delta;
@@ -580,8 +576,8 @@ private void checkOutNotClosed() throws IOException {
   }
 
   /**
-   * Like {@link #wait}, but throws an {@code InterruptedIOException} when
-   * interrupted instead of the more awkward {@link InterruptedException}.
+   * Like {@link #wait}, but throws an {@code InterruptedIOException} when interrupted instead of
+   * the more awkward {@link InterruptedException}.
    */
   private void waitForIo() throws InterruptedIOException {
     try {
@@ -592,9 +588,8 @@ private void waitForIo() throws InterruptedIOException {
   }
 
   /**
-   * The Okio timeout watchdog will call {@link #timedOut} if the timeout is
-   * reached. In that case we close the stream (asynchronously) which will
-   * notify the waiting thread.
+   * The Okio timeout watchdog will call {@link #timedOut} if the timeout is reached. In that case
+   * we close the stream (asynchronously) which will notify the waiting thread.
    */
   class StreamTimeout extends AsyncTimeout {
     @Override protected void timedOut() {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Header.java b/okhttp/src/main/java/okhttp3/internal/framed/Header.java
similarity index 72%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/framed/Header.java
rename to okhttp/src/main/java/okhttp3/internal/framed/Header.java
index af5594f614..866edc2591 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Header.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Header.java
@@ -1,5 +1,21 @@
-package com.squareup.okhttp.internal.framed;
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.framed;
 
+import okhttp3.internal.Util;
 import okio.ByteString;
 
 /** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
@@ -51,6 +67,6 @@ public Header(ByteString name, ByteString value) {
   }
 
   @Override public String toString() {
-    return String.format("%s: %s", name.utf8(), value.utf8());
+    return Util.format("%s: %s", name.utf8(), value.utf8());
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/HeadersMode.java b/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java
similarity index 92%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/framed/HeadersMode.java
rename to okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java
index b42915b610..bc851ed784 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/HeadersMode.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/HeadersMode.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
 public enum HeadersMode {
   SPDY_SYN_STREAM,
@@ -32,16 +32,14 @@ public boolean failIfStreamPresent() {
   }
 
   /**
-   * Returns true if it is an error these headers to be the initial headers of a
-   * response.
+   * Returns true if it is an error these headers to be the initial headers of a response.
    */
   public boolean failIfHeadersAbsent() {
     return this == SPDY_HEADERS;
   }
 
   /**
-   * Returns true if it is an error these headers to be update existing headers
-   * of a response.
+   * Returns true if it is an error these headers to be update existing headers of a response.
    */
   public boolean failIfHeadersPresent() {
     return this == SPDY_REPLY;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Hpack.java b/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
similarity index 96%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/framed/Hpack.java
rename to okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
index 171516f7af..2b49784e9b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Hpack.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -33,9 +33,9 @@
  *
  * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12
  *
- * This implementation uses an array for the dynamic table and a list for
- * indexed entries.  Dynamic entries are added to the array, starting in the
- * last position moving forward.  When the array fills, it is doubled.
+ * This implementation uses an array for the dynamic table and a list for indexed entries.  Dynamic
+ * entries are added to the array, starting in the last position moving forward.  When the array
+ * fills, it is doubled.
  */
 final class Hpack {
   private static final int PREFIX_4_BITS = 0x0f;
@@ -136,11 +136,11 @@ int maxDynamicTableByteCount() {
     }
 
     /**
-     * Called by the reader when the peer sent {@link Settings#HEADER_TABLE_SIZE}.
-     * While this establishes the maximum dynamic table size, the
-     * {@link #maxDynamicTableByteCount} set during processing may limit the
-     * table size to a smaller amount.
-     * <p> Evicts entries or clears the table as needed.
+     * Called by the reader when the peer sent {@link Settings#HEADER_TABLE_SIZE}. While this
+     * establishes the maximum dynamic table size, the {@link #maxDynamicTableByteCount} set during
+     * processing may limit the table size to a smaller amount.
+     *
+     * <p>Evicts entries or clears the table as needed.
      */
     void headerTableSizeSetting(int headerTableSizeSetting) {
       this.headerTableSizeSetting = headerTableSizeSetting;
@@ -185,8 +185,8 @@ private int evictToRecoverBytes(int bytesToRecover) {
     }
 
     /**
-     * Read {@code byteCount} bytes of headers from the source stream. This
-     * implementation does not propagate the never indexed flag of a header.
+     * Read {@code byteCount} bytes of headers from the source stream. This implementation does not
+     * propagate the never indexed flag of a header.
      */
     void readHeaders() throws IOException {
       while (!source.exhausted()) {
@@ -420,8 +420,8 @@ void writeByteString(ByteString data) throws IOException {
   }
 
   /**
-   * An HTTP/2 response cannot contain uppercase header characters and must
-   * be treated as malformed.
+   * An HTTP/2 response cannot contain uppercase header characters and must be treated as
+   * malformed.
    */
   private static ByteString checkLowercase(ByteString name) throws IOException {
     for (int i = 0, length = name.size(); i < length; i++) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Http2.java b/okhttp/src/main/java/okhttp3/internal/framed/Http2.java
similarity index 95%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/framed/Http2.java
rename to okhttp/src/main/java/okhttp3/internal/framed/Http2.java
index fb05b5bd50..8ad6c5224e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Http2.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Http2.java
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.Protocol;
 import java.io.IOException;
 import java.util.List;
 import java.util.logging.Logger;
+import okhttp3.Protocol;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -26,18 +26,17 @@
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.framed.Http2.FrameLogger.formatHeader;
-import static java.lang.String.format;
 import static java.util.logging.Level.FINE;
+import static okhttp3.internal.Util.format;
+import static okhttp3.internal.framed.Http2.FrameLogger.formatHeader;
 import static okio.ByteString.EMPTY;
 
 /**
  * Read and write HTTP/2 frames.
- * <p>
- * This implementation assumes we do not send an increased
- * {@link Settings#getMaxFrameSize frame size setting} to the peer. Hence, we
- * expect all frames to have a max length of {@link #INITIAL_MAX_FRAME_SIZE}.
- * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-17
+ *
+ * <p>This implementation assumes we do not send an increased {@link Settings#getMaxFrameSize frame
+ * size setting} to the peer. Hence, we expect all frames to have a max length of {@link
+ * #INITIAL_MAX_FRAME_SIZE}. <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-17
  */
 public final class Http2 implements Variant {
   private static final Logger logger = Logger.getLogger(FrameLogger.class.getName());
@@ -73,8 +72,7 @@
   static final byte FLAG_COMPRESSED = 0x20; // Used for data.
 
   /**
-   * Creates a frame reader with max header table size of 4096 and data frame
-   * compression disabled.
+   * Creates a frame reader with max header table size of 4096 and data frame compression disabled.
    */
   @Override public FrameReader newReader(BufferedSource source, boolean client) {
     return new Reader(source, 4096, client);
@@ -296,7 +294,7 @@ private void readSettings(Handler handler, int length, byte flags, int streamId)
           case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
             break; // Advisory only, so ignored.
           default:
-            throw ioException("PROTOCOL_ERROR invalid settings id: %s", id);
+            break; // Must ignore setting with unknown id.
         }
         settings.set(id, 0, value);
       }
@@ -425,7 +423,6 @@ private void readWindowUpdate(Handler handler, int length, byte flags, int strea
     @Override public synchronized void pushPromise(int streamId, int promisedStreamId,
         List<Header> requestHeaders) throws IOException {
       if (closed) throw new IOException("closed");
-      if (hpackBuffer.size() != 0) throw new IllegalStateException();
       hpackWriter.writeHeaders(requestHeaders);
 
       long byteCount = hpackBuffer.size();
@@ -441,7 +438,6 @@ private void readWindowUpdate(Handler handler, int length, byte flags, int strea
 
     void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
       if (closed) throw new IOException("closed");
-      if (hpackBuffer.size() != 0) throw new IllegalStateException();
       hpackWriter.writeHeaders(headerBlock);
 
       long byteCount = hpackBuffer.size();
@@ -507,8 +503,11 @@ void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IO
       for (int i = 0; i < Settings.COUNT; i++) {
         if (!settings.isSet(i)) continue;
         int id = i;
-        if (id == 4) id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
-        else if (id == 7) id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
+        if (id == 4) {
+          id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
+        } else if (id == 7) {
+          id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
+        }
         sink.writeShort(id);
         sink.writeInt(settings.get(i));
       }
@@ -587,9 +586,8 @@ private static IOException ioException(String message, Object... args) throws IO
   }
 
   /**
-   * Decompression of the header block occurs above the framing layer. This
-   * class lazily reads continuation frames as they are needed by {@link
-   * Hpack.Reader#readHeaders()}.
+   * Decompression of the header block occurs above the framing layer. This class lazily reads
+   * continuation frames as they are needed by {@link Hpack.Reader#readHeaders()}.
    */
   static final class ContinuationSource implements Source {
     private final BufferedSource source;
@@ -659,8 +657,7 @@ private static int lengthWithoutPadding(int length, byte flags, short padding)
    * </pre>
    * Where direction is {@code <<} for inbound and {@code >>} for outbound.
    *
-   * <p> For example, the following would indicate a HEAD request sent from
-   * the client.
+   * <p>For example, the following would indicate a HEAD request sent from the client.
    * <pre>
    * {@code
    *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
@@ -677,8 +674,8 @@ static String formatHeader(boolean inbound, int streamId, int length, byte type,
     }
 
     /**
-     * Looks up valid string representing flags from the table. Invalid
-     * combinations are represented in binary.
+     * Looks up valid string representing flags from the table. Invalid combinations are represented
+     * in binary.
      */
     // Visible for testing.
     static String formatFlags(byte type, byte flags) {
@@ -718,8 +715,8 @@ static String formatFlags(byte type, byte flags) {
     };
 
     /**
-     * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid
-     * combinations are represented in binary.
+     * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid combinations are
+     * represented in binary.
      */
     private static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
     private static final String[] BINARY = new String[256];
@@ -736,7 +733,7 @@ static String formatFlags(byte type, byte flags) {
 
       FLAGS[FLAG_PADDED] = "PADDED";
       for (int prefixFlag : prefixFlags) {
-         FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
+        FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
       }
 
       FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
@@ -761,13 +758,13 @@ static String formatFlags(byte type, byte flags) {
 
   private static int readMedium(BufferedSource source) throws IOException {
     return (source.readByte() & 0xff) << 16
-        |  (source.readByte() & 0xff) <<  8
-        |  (source.readByte() & 0xff);
+        | (source.readByte() & 0xff) << 8
+        | (source.readByte() & 0xff);
   }
 
   private static void writeMedium(BufferedSink sink, int i) throws IOException {
     sink.writeByte((i >>> 16) & 0xff);
-    sink.writeByte((i >>>  8) & 0xff);
-    sink.writeByte(i          & 0xff);
+    sink.writeByte((i >>> 8) & 0xff);
+    sink.writeByte(i & 0xff);
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Huffman.java b/okhttp/src/main/java/okhttp3/internal/framed/Huffman.java
similarity index 96%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/framed/Huffman.java
rename to okhttp/src/main/java/okhttp3/internal/framed/Huffman.java
index f21a16ded0..0c7f3012a7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Huffman.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Huffman.java
@@ -13,19 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 
 /**
- * This class was originally composed from the following classes in
- * <a href="https://github.com/twitter/hpack">Twitter Hpack</a>.
+ * This class was originally composed from the following classes in <a
+ * href="https://github.com/twitter/hpack">Twitter Hpack</a>.
+ *
  * <ul>
- * <li>{@code com.twitter.hpack.HuffmanEncoder}</li>
- * <li>{@code com.twitter.hpack.HuffmanDecoder}</li>
- * <li>{@code com.twitter.hpack.HpackUtil}</li>
+ *     <li>{@code com.twitter.hpack.HuffmanEncoder}</li>
+ *     <li>{@code com.twitter.hpack.HuffmanDecoder}</li>
+ *     <li>{@code com.twitter.hpack.HpackUtil}</li>
  * </ul>
  */
 class Huffman {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/NameValueBlockReader.java b/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
similarity index 93%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/framed/NameValueBlockReader.java
rename to okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
index d9554a361b..75cd9594f7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/NameValueBlockReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/NameValueBlockReader.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -29,18 +29,17 @@
 import okio.Source;
 
 /**
- * Reads a SPDY/3 Name/Value header block. This class is made complicated by the
- * requirement that we're strict with which bytes we put in the compressed bytes
- * buffer. We need to put all compressed bytes into that buffer -- but no other
- * bytes.
+ * Reads a SPDY/3 Name/Value header block. This class is made complicated by the requirement that
+ * we're strict with which bytes we put in the compressed bytes buffer. We need to put all
+ * compressed bytes into that buffer -- but no other bytes.
  */
 class NameValueBlockReader {
   /** This source transforms compressed bytes into uncompressed bytes. */
   private final InflaterSource inflaterSource;
 
   /**
-   * How many compressed bytes must be read into inflaterSource before
-   * {@link #readNameValueBlock} returns.
+   * How many compressed bytes must be read into inflaterSource before {@link #readNameValueBlock}
+   * returns.
    */
   private int compressedLimit;
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Ping.java b/okhttp/src/main/java/okhttp3/internal/framed/Ping.java
similarity index 87%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/framed/Ping.java
rename to okhttp/src/main/java/okhttp3/internal/framed/Ping.java
index 35f9cf5be6..d3e0b428d6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Ping.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Ping.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
@@ -47,9 +47,8 @@ void cancel() {
   }
 
   /**
-   * Returns the round trip time for this ping in nanoseconds, waiting for the
-   * response to arrive if necessary. Returns -1 if the response was
-   * canceled.
+   * Returns the round trip time for this ping in nanoseconds, waiting for the response to arrive if
+   * necessary. Returns -1 if the response was canceled.
    */
   public long roundTripTime() throws InterruptedException {
     latch.await();
@@ -57,9 +56,8 @@ public long roundTripTime() throws InterruptedException {
   }
 
   /**
-   * Returns the round trip time for this ping in nanoseconds, or -1 if the
-   * response was canceled, or -2 if the timeout elapsed before the round
-   * trip completed.
+   * Returns the round trip time for this ping in nanoseconds, or -1 if the response was canceled,
+   * or -2 if the timeout elapsed before the round trip completed.
    */
   public long roundTripTime(long timeout, TimeUnit unit) throws InterruptedException {
     if (latch.await(timeout, unit)) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/PushObserver.java b/okhttp/src/main/java/okhttp3/internal/framed/PushObserver.java
similarity index 76%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/framed/PushObserver.java
rename to okhttp/src/main/java/okhttp3/internal/framed/PushObserver.java
index 33ebc617e3..95dd41a5b9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/PushObserver.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/PushObserver.java
@@ -13,44 +13,44 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
 import java.io.IOException;
 import java.util.List;
+import okhttp3.Protocol;
 import okio.BufferedSource;
 
 /**
- * {@link com.squareup.okhttp.Protocol#HTTP_2 HTTP/2} only.
- * Processes server-initiated HTTP requests on the client. Implementations must
- * quickly dispatch callbacks to avoid creating a bottleneck.
+ * {@link Protocol#HTTP_2 HTTP/2} only. Processes server-initiated HTTP requests on the client.
+ * Implementations must quickly dispatch callbacks to avoid creating a bottleneck.
+ *
+ * <p>While {@link #onReset} may occur at any time, the following callbacks are expected in order,
+ * correlated by stream ID.
  *
- * <p>While {@link #onReset} may occur at any time, the following callbacks are
- * expected in order, correlated by stream ID.
  * <ul>
- *   <li>{@link #onRequest}</li>
- *   <li>{@link #onHeaders} (unless canceled)</li>
- *   <li>{@link #onData} (optional sequence of data frames)</li>
+ *     <li>{@link #onRequest}</li> <li>{@link #onHeaders} (unless canceled)
+ *     <li>{@link #onData} (optional sequence of data frames)
  * </ul>
  *
- * <p>As a stream ID is scoped to a single HTTP/2 connection, implementations
- * which target multiple connections should expect repetition of stream IDs.
+ * <p>As a stream ID is scoped to a single HTTP/2 connection, implementations which target multiple
+ * connections should expect repetition of stream IDs.
  *
- * <p>Return true to request cancellation of a pushed stream.  Note that this
- * does not guarantee future frames won't arrive on the stream ID.
+ * <p>Return true to request cancellation of a pushed stream.  Note that this does not guarantee
+ * future frames won't arrive on the stream ID.
  */
 public interface PushObserver {
   /**
    * Describes the request that the server intends to push a response for.
    *
    * @param streamId server-initiated stream ID: an even number.
-   * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
-   * {@code :authority}, and (@code :path}.
+   * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
+   * and (@code :path}.
    */
   boolean onRequest(int streamId, List<Header> requestHeaders);
 
   /**
-   * The response headers corresponding to a pushed request.  When {@code last}
-   * is true, there are no data frames to follow.
+   * The response headers corresponding to a pushed request.  When {@code last} is true, there are
+   * no data frames to follow.
    *
    * @param streamId server-initiated stream ID: an even number.
    * @param responseHeaders minimally includes {@code :status}.
@@ -59,8 +59,8 @@
   boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last);
 
   /**
-   * A chunk of response data corresponding to a pushed request.  This data
-   * must either be read or skipped.
+   * A chunk of response data corresponding to a pushed request.  This data must either be read or
+   * skipped.
    *
    * @param streamId server-initiated stream ID: an even number.
    * @param source location of data corresponding with this stream ID.
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Settings.java b/okhttp/src/main/java/okhttp3/internal/framed/Settings.java
similarity index 96%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/framed/Settings.java
rename to okhttp/src/main/java/okhttp3/internal/framed/Settings.java
index 935d489045..f4eab01731 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Settings.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Settings.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
 import java.util.Arrays;
 
@@ -23,8 +23,8 @@
  */
 public final class Settings {
   /**
-   * From the SPDY/3 and HTTP/2 specs, the default initial window size for all
-   * streams is 64 KiB. (Chrome 25 uses 10 MiB).
+   * From the SPDY/3 and HTTP/2 specs, the default initial window size for all streams is 64 KiB.
+   * (Chrome 25 uses 10 MiB).
    */
   static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
 
@@ -212,8 +212,8 @@ boolean isFlowControlDisabled() {
   }
 
   /**
-   * Returns true if this user agent should use this setting in future spdy/3
-   * connections to the same host.
+   * Returns true if this user agent should use this setting in future spdy/3 connections to the
+   * same host.
    */
   boolean persistValue(int id) {
     int bit = 1 << id;
@@ -227,8 +227,8 @@ boolean isPersisted(int id) {
   }
 
   /**
-   * Writes {@code other} into this. If any setting is populated by this and
-   * {@code other}, the value and flags from {@code other} will be kept.
+   * Writes {@code other} into this. If any setting is populated by this and {@code other}, the
+   * value and flags from {@code other} will be kept.
    */
   void merge(Settings other) {
     for (int i = 0; i < COUNT; i++) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Spdy3.java b/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java
similarity index 97%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/framed/Spdy3.java
rename to okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java
index cdb82c2a10..37e1796c5c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Spdy3.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Spdy3.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.net.ProtocolException;
 import java.util.List;
 import java.util.zip.Deflater;
+import okhttp3.Protocol;
+import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -30,8 +30,7 @@
 import okio.Okio;
 
 /**
- * Read and write spdy/3.1 frames.
- * http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1
+ * Read and write spdy/3.1 frames. http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1
  */
 public final class Spdy3 implements Variant {
 
@@ -55,6 +54,7 @@
   static final int VERSION = 3;
 
   static final byte[] DICTIONARY;
+
   static {
     try {
       DICTIONARY = ("\u0000\u0000\u0000\u0007options\u0000\u0000\u0000\u0004hea"
@@ -119,8 +119,8 @@
     }
 
     /**
-     * Send the next frame to {@code handler}. Returns true unless there are no
-     * more frames on the stream.
+     * Send the next frame to {@code handler}. Returns true unless there are no more frames on the
+     * stream.
      */
     @Override public boolean nextFrame(Handler handler) throws IOException {
       int w1;
@@ -275,7 +275,7 @@ private void readSettings(Handler handler, int flags, int length) throws IOExcep
     }
 
     private static IOException ioException(String message, Object... args) throws IOException {
-      throw new IOException(String.format(message, args));
+      throw new IOException(Util.format(message, args));
     }
 
     @Override public void close() throws IOException {
@@ -406,7 +406,6 @@ void sendDataFrame(int streamId, int flags, Buffer buffer, int byteCount)
     }
 
     private void writeNameValueBlockToBuffer(List<Header> headerBlock) throws IOException {
-      if (headerBlockBuffer.size() != 0) throw new IllegalStateException();
       headerBlockOut.writeInt(headerBlock.size());
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
         ByteString name = headerBlock.get(i).name;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Variant.java b/okhttp/src/main/java/okhttp3/internal/framed/Variant.java
similarity index 93%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/framed/Variant.java
rename to okhttp/src/main/java/okhttp3/internal/framed/Variant.java
index 0782ba1a86..4ff3794007 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/framed/Variant.java
+++ b/okhttp/src/main/java/okhttp3/internal/framed/Variant.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.framed;
+package okhttp3.internal.framed;
 
-import com.squareup.okhttp.Protocol;
+import okhttp3.Protocol;
 import okio.BufferedSink;
 import okio.BufferedSource;
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java b/okhttp/src/main/java/okhttp3/internal/http/CacheRequest.java
similarity index 94%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java
rename to okhttp/src/main/java/okhttp3/internal/http/CacheRequest.java
index b8153e4f07..12c3134e8a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CacheRequest.java
@@ -13,12 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
 import java.io.IOException;
 import okio.Sink;
 
 public interface CacheRequest {
   Sink body() throws IOException;
+
   void abort();
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java
similarity index 83%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
rename to okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java
index aee0dae500..7aa8af1a4b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java
@@ -1,13 +1,26 @@
-package com.squareup.okhttp.internal.http;
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
 
-import com.squareup.okhttp.CacheControl;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.util.Date;
+import okhttp3.CacheControl;
+import okhttp3.Headers;
+import okhttp3.Request;
+import okhttp3.Response;
 
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 import static java.net.HttpURLConnection.HTTP_BAD_METHOD;
 import static java.net.HttpURLConnection.HTTP_GONE;
 import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
@@ -22,12 +35,12 @@
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 /**
- * Given a request and cached response, this figures out whether to use the
- * network, the cache, or both.
+ * Given a request and cached response, this figures out whether to use the network, the cache, or
+ * both.
  *
- * <p>Selecting a cache strategy may add conditions to the request (like the
- * "If-Modified-Since" header for conditional GETs) or warnings to the cached
- * response (if the cached data is potentially stale).
+ * <p>Selecting a cache strategy may add conditions to the request (like the "If-Modified-Since"
+ * header for conditional GETs) or warnings to the cached response (if the cached data is
+ * potentially stale).
  */
 public final class CacheStrategy {
   /** The request to send on the network, or null if this call doesn't use the network. */
@@ -41,10 +54,7 @@ private CacheStrategy(Request networkRequest, Response cacheResponse) {
     this.cacheResponse = cacheResponse;
   }
 
-  /**
-   * Returns true if {@code response} can be stored to later serve another
-   * request.
-   */
+  /** Returns true if {@code response} can be stored to later serve another request. */
   public static boolean isCacheable(Response response, Request request) {
     // Always go to network for uncacheable response codes (RFC 7231 section 6.1),
     // This implementation doesn't support caching partial content.
@@ -59,12 +69,12 @@ public static boolean isCacheable(Response response, Request request) {
       case HTTP_GONE:
       case HTTP_REQ_TOO_LONG:
       case HTTP_NOT_IMPLEMENTED:
-      case HTTP_PERM_REDIRECT:
-      // These codes can be cached unless headers forbid it.
-      break;
+      case StatusLine.HTTP_PERM_REDIRECT:
+        // These codes can be cached unless headers forbid it.
+        break;
 
       case HTTP_MOVED_TEMP:
-      case HTTP_TEMP_REDIRECT:
+      case StatusLine.HTTP_TEMP_REDIRECT:
         // These codes can only be cached with the right response headers.
         // http://tools.ietf.org/html/rfc7234#section-3
         // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.
@@ -99,20 +109,20 @@ public static boolean isCacheable(Response response, Request request) {
     private String lastModifiedString;
 
     /**
-     * The expiration date of the cached response, if known. If both this field
-     * and the max age are set, the max age is preferred.
+     * The expiration date of the cached response, if known. If both this field and the max age are
+     * set, the max age is preferred.
      */
     private Date expires;
 
     /**
-     * Extension header set by OkHttp specifying the timestamp when the cached
-     * HTTP request was first initiated.
+     * Extension header set by OkHttp specifying the timestamp when the cached HTTP request was
+     * first initiated.
      */
     private long sentRequestMillis;
 
     /**
-     * Extension header set by OkHttp specifying the timestamp when the cached
-     * HTTP response was first received.
+     * Extension header set by OkHttp specifying the timestamp when the cached HTTP response was
+     * first received.
      */
     private long receivedResponseMillis;
 
@@ -128,6 +138,8 @@ public Factory(long nowMillis, Request request, Response cacheResponse) {
       this.cacheResponse = cacheResponse;
 
       if (cacheResponse != null) {
+        this.sentRequestMillis = cacheResponse.sentRequestAtMillis();
+        this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();
         Headers headers = cacheResponse.headers();
         for (int i = 0, size = headers.size(); i < size; i++) {
           String fieldName = headers.name(i);
@@ -144,18 +156,13 @@ public Factory(long nowMillis, Request request, Response cacheResponse) {
             etag = value;
           } else if ("Age".equalsIgnoreCase(fieldName)) {
             ageSeconds = HeaderParser.parseSeconds(value, -1);
-          } else if (OkHeaders.SENT_MILLIS.equalsIgnoreCase(fieldName)) {
-            sentRequestMillis = Long.parseLong(value);
-          } else if (OkHeaders.RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
-            receivedResponseMillis = Long.parseLong(value);
           }
         }
       }
     }
 
     /**
-     * Returns a strategy to satisfy {@code request} using the a cached response
-     * {@code response}.
+     * Returns a strategy to satisfy {@code request} using the a cached response {@code response}.
      */
     public CacheStrategy get() {
       CacheStrategy candidate = getCandidate();
@@ -239,8 +246,8 @@ private CacheStrategy getCandidate() {
     }
 
     /**
-     * Returns the number of milliseconds that the response was fresh for,
-     * starting from the served date.
+     * Returns the number of milliseconds that the response was fresh for, starting from the served
+     * date.
      */
     private long computeFreshnessLifetime() {
       CacheControl responseCaching = cacheResponse.cacheControl();
@@ -253,7 +260,7 @@ private long computeFreshnessLifetime() {
         long delta = expires.getTime() - servedMillis;
         return delta > 0 ? delta : 0;
       } else if (lastModified != null
-          && cacheResponse.request().httpUrl().query() == null) {
+          && cacheResponse.request().url().query() == null) {
         // As recommended by the HTTP RFC and implemented in Firefox, the
         // max age of a document should be defaulted to 10% of the
         // document's age at the time it was served. Default expiration
@@ -268,8 +275,8 @@ private long computeFreshnessLifetime() {
     }
 
     /**
-     * Returns the current age of the response, in milliseconds. The calculation
-     * is specified by RFC 2616, 13.2.3 Age Calculations.
+     * Returns the current age of the response, in milliseconds. The calculation is specified by RFC
+     * 2616, 13.2.3 Age Calculations.
      */
     private long cacheResponseAge() {
       long apparentReceivedAge = servedDate != null
@@ -284,18 +291,17 @@ private long cacheResponseAge() {
     }
 
     /**
-     * Returns true if computeFreshnessLifetime used a heuristic. If we used a
-     * heuristic to serve a cached response older than 24 hours, we are required
-     * to attach a warning.
+     * Returns true if computeFreshnessLifetime used a heuristic. If we used a heuristic to serve a
+     * cached response older than 24 hours, we are required to attach a warning.
      */
     private boolean isFreshnessLifetimeHeuristic() {
       return cacheResponse.cacheControl().maxAgeSeconds() == -1 && expires == null;
     }
 
     /**
-     * Returns true if the request contains conditions that save the server from
-     * sending a response that the client has locally. When a request is enqueued
-     * with its own conditions, the built-in response cache won't be used.
+     * Returns true if the request contains conditions that save the server from sending a response
+     * that the client has locally. When a request is enqueued with its own conditions, the built-in
+     * response cache won't be used.
      */
     private static boolean hasConditions(Request request) {
       return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java b/okhttp/src/main/java/okhttp3/internal/http/HeaderParser.java
similarity index 83%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
rename to okhttp/src/main/java/okhttp3/internal/http/HeaderParser.java
index 55f82ada47..1e27c988c4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HeaderParser.java
@@ -13,14 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
 public final class HeaderParser {
   /**
-   * Returns the next index in {@code input} at or after {@code pos} that
-   * contains a character from {@code characters}. Returns the input length if
-   * none of the requested characters can be found.
+   * Returns the next index in {@code input} at or after {@code pos} that contains a character from
+   * {@code characters}. Returns the input length if none of the requested characters can be found.
    */
   public static int skipUntil(String input, int pos, String characters) {
     for (; pos < input.length(); pos++) {
@@ -32,8 +30,8 @@ public static int skipUntil(String input, int pos, String characters) {
   }
 
   /**
-   * Returns the next non-whitespace character in {@code input} that is white
-   * space. Result is undefined if input contains newline characters.
+   * Returns the next non-whitespace character in {@code input} that is white space. Result is
+   * undefined if input contains newline characters.
    */
   public static int skipWhitespace(String input, int pos) {
     for (; pos < input.length(); pos++) {
@@ -46,8 +44,8 @@ public static int skipWhitespace(String input, int pos) {
   }
 
   /**
-   * Returns {@code value} as a positive integer, or 0 if it is negative, or
-   * {@code defaultValue} if it cannot be parsed.
+   * Returns {@code value} as a positive integer, or 0 if it is negative, or {@code defaultValue} if
+   * it cannot be parsed.
    */
   public static int parseSeconds(String value, int defaultValue) {
     try {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
similarity index 64%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
rename to okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
index 1bbde80b48..320788755b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
@@ -13,20 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package okhttp3.internal.http;
 
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.Util;
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
-import java.net.Socket;
-import java.net.SocketTimeoutException;
+import okhttp3.Headers;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.io.RealConnection;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -36,31 +34,31 @@
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
-import static com.squareup.okhttp.internal.http.Transport.DISCARD_STREAM_TIMEOUT_MILLIS;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.checkOffsetAndCount;
+import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
 
 /**
- * A socket connection that can be used to send HTTP/1.1 messages. This class
- * strictly enforces the following lifecycle:
+ * A socket connection that can be used to send HTTP/1.1 messages. This class strictly enforces the
+ * following lifecycle:
+ *
  * <ol>
- *   <li>{@link #writeRequest Send request headers}.
- *   <li>Open a sink to write the request body. Either {@link
- *       #newFixedLengthSink fixed-length} or {@link #newChunkedSink chunked}.
- *   <li>Write to and then close that sink.
- *   <li>{@link #readResponse Read response headers}.
- *   <li>Open a source to read the response body. Either {@link
- *       #newFixedLengthSource fixed-length}, {@link #newChunkedSource chunked}
- *       or {@link #newUnknownLengthSource unknown length}.
- *   <li>Read from and close that source.
+ *     <li>{@linkplain #writeRequest Send request headers}.
+ *     <li>Open a sink to write the request body. Either {@linkplain #newFixedLengthSink
+ *         fixed-length} or {@link #newChunkedSink chunked}.
+ *     <li>Write to and then close that sink.
+ *     <li>{@linkplain #readResponse Read response headers}.
+ *     <li>Open a source to read the response body. Either {@linkplain #newFixedLengthSource
+ *         fixed-length}, {@linkplain #newChunkedSource chunked} or {@linkplain
+ *         #newUnknownLengthSource unknown length}.
+ *     <li>Read from and close that source.
  * </ol>
- * <p>Exchanges that do not have a request body may skip creating and closing
- * the request body. Exchanges that do not have a response body can call {@link
- * #newFixedLengthSource(long) newFixedLengthSource(0)} and may skip reading and
- * closing that source.
+ *
+ * <p>Exchanges that do not have a request body may skip creating and closing the request body.
+ * Exchanges that do not have a response body can call {@link #newFixedLengthSource(long)
+ * newFixedLengthSource(0)} and may skip reading and closing that source.
  */
-public final class HttpConnection {
+public final class Http1xStream implements HttpStream {
   private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
   private static final int STATE_OPEN_REQUEST_BODY = 1;
   private static final int STATE_WRITING_REQUEST_BODY = 2;
@@ -69,63 +67,87 @@
   private static final int STATE_READING_RESPONSE_BODY = 5;
   private static final int STATE_CLOSED = 6;
 
-  private static final int ON_IDLE_HOLD = 0;
-  private static final int ON_IDLE_POOL = 1;
-  private static final int ON_IDLE_CLOSE = 2;
-
-  private final ConnectionPool pool;
-  private final Connection connection;
-  private final Socket socket;
+  /** The stream allocation that owns this stream. May be null for HTTPS proxy tunnels. */
+  private final StreamAllocation streamAllocation;
   private final BufferedSource source;
   private final BufferedSink sink;
-
+  private HttpEngine httpEngine;
   private int state = STATE_IDLE;
-  private int onIdle = ON_IDLE_HOLD;
-
-  public HttpConnection(ConnectionPool pool, Connection connection, Socket socket)
-      throws IOException {
-    this.pool = pool;
-    this.connection = connection;
-    this.socket = socket;
-    this.source = Okio.buffer(Okio.source(socket));
-    this.sink = Okio.buffer(Okio.sink(socket));
+
+  public Http1xStream(StreamAllocation streamAllocation, BufferedSource source, BufferedSink sink) {
+    this.streamAllocation = streamAllocation;
+    this.source = source;
+    this.sink = sink;
   }
 
-  public void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) {
-    if (readTimeoutMillis != 0) {
-      source.timeout().timeout(readTimeoutMillis, MILLISECONDS);
+  @Override public void setHttpEngine(HttpEngine httpEngine) {
+    this.httpEngine = httpEngine;
+  }
+
+  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
+    if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
+      // Stream a request body of unknown length.
+      return newChunkedSink();
     }
-    if (writeTimeoutMillis != 0) {
-      sink.timeout().timeout(writeTimeoutMillis, MILLISECONDS);
+
+    if (contentLength != -1) {
+      // Stream a request body of a known length.
+      return newFixedLengthSink(contentLength);
     }
+
+    throw new IllegalStateException(
+        "Cannot stream a request body without chunked encoding or a known content length!");
+  }
+
+  @Override public void cancel() {
+    RealConnection connection = streamAllocation.connection();
+    if (connection != null) connection.cancel();
   }
 
   /**
-   * Configure this connection to put itself back into the connection pool when
-   * the HTTP response body is exhausted.
+   * Prepares the HTTP headers and sends them to the server.
+   *
+   * <p>For streaming requests with a body, headers must be prepared <strong>before</strong> the
+   * output stream has been written to. Otherwise the body would need to be buffered!
+   *
+   * <p>For non-streaming requests with a body, headers must be prepared <strong>after</strong> the
+   * output stream has been written to and closed. This ensures that the {@code Content-Length}
+   * header field receives the proper value.
    */
-  public void poolOnIdle() {
-    onIdle = ON_IDLE_POOL;
+  @Override public void writeRequestHeaders(Request request) throws IOException {
+    httpEngine.writingRequestHeaders();
+    String requestLine = RequestLine.get(
+        request, httpEngine.getConnection().route().proxy().type());
+    writeRequest(request.headers(), requestLine);
+  }
 
-    // If we're already idle, go to the pool immediately.
-    if (state == STATE_IDLE) {
-      onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
-      Internal.instance.recycle(pool, connection);
-    }
+  @Override public Response.Builder readResponseHeaders() throws IOException {
+    return readResponse();
   }
 
-  /**
-   * Configure this connection to close itself when the HTTP response body is
-   * exhausted.
-   */
-  public void closeOnIdle() throws IOException {
-    onIdle = ON_IDLE_CLOSE;
+  @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    Source source = getTransferStream(response);
+    return new RealResponseBody(response.headers(), Okio.buffer(source));
+  }
 
-    // If we're already idle, close immediately.
-    if (state == STATE_IDLE) {
-      state = STATE_CLOSED;
-      connection.getSocket().close();
+  private Source getTransferStream(Response response) throws IOException {
+    if (!HttpEngine.hasBody(response)) {
+      return newFixedLengthSource(0);
+    }
+
+    if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
+      return newChunkedSource(httpEngine);
+    }
+
+    long contentLength = OkHeaders.contentLength(response);
+    if (contentLength != -1) {
+      return newFixedLengthSource(contentLength);
     }
+
+    // Wrap the input stream from the connection (rather than just returning
+    // "socketIn" directly here), so that we can control its use after the
+    // reference escapes.
+    return newUnknownLengthSource();
   }
 
   /** Returns true if this connection is closed. */
@@ -133,44 +155,15 @@ public boolean isClosed() {
     return state == STATE_CLOSED;
   }
 
-  public void closeIfOwnedBy(Object owner) throws IOException {
-    Internal.instance.closeIfOwnedBy(connection, owner);
-  }
-
-  public void flush() throws IOException {
+  @Override public void finishRequest() throws IOException {
     sink.flush();
   }
 
-  /** Returns the number of buffered bytes immediately readable. */
-  public long bufferSize() {
-    return source.buffer().size();
-  }
-
-  /** Test for a stale socket. */
-  public boolean isReadable() {
-    try {
-      int readTimeout = socket.getSoTimeout();
-      try {
-        socket.setSoTimeout(1);
-        if (source.exhausted()) {
-          return false; // Stream is exhausted; socket is closed.
-        }
-        return true;
-      } finally {
-        socket.setSoTimeout(readTimeout);
-      }
-    } catch (SocketTimeoutException ignored) {
-      return true; // Read timed out; socket is good.
-    } catch (IOException e) {
-      return false; // Couldn't read; socket is closed.
-    }
-  }
-
   /** Returns bytes of a request header for sending on an HTTP transport. */
   public void writeRequest(Headers headers, String requestLine) throws IOException {
     if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
     sink.writeUtf8(requestLine).writeUtf8("\r\n");
-    for (int i = 0, size = headers.size(); i < size; i ++) {
+    for (int i = 0, size = headers.size(); i < size; i++) {
       sink.writeUtf8(headers.name(i))
           .writeUtf8(": ")
           .writeUtf8(headers.value(i))
@@ -193,12 +186,8 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
         Response.Builder responseBuilder = new Response.Builder()
             .protocol(statusLine.protocol)
             .code(statusLine.code)
-            .message(statusLine.message);
-
-        Headers.Builder headersBuilder = new Headers.Builder();
-        readHeaders(headersBuilder);
-        headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.protocol.toString());
-        responseBuilder.headers(headersBuilder.build());
+            .message(statusLine.message)
+            .headers(readHeaders());
 
         if (statusLine.code != HTTP_CONTINUE) {
           state = STATE_OPEN_RESPONSE_BODY;
@@ -207,19 +196,20 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
       }
     } catch (EOFException e) {
       // Provide more context if the server ends the stream before sending a response.
-      IOException exception = new IOException("unexpected end of stream on " + connection
-          + " (recycle count=" + Internal.instance.recycleCount(connection) + ")");
+      IOException exception = new IOException("unexpected end of stream on " + streamAllocation);
       exception.initCause(e);
       throw exception;
     }
   }
 
-  /** Reads headers or trailers into {@code builder}. */
-  public void readHeaders(Headers.Builder builder) throws IOException {
+  /** Reads headers or trailers. */
+  public Headers readHeaders() throws IOException {
+    Headers.Builder headers = new Headers.Builder();
     // parse the result headers until the first blank line
     for (String line; (line = source.readUtf8LineStrict()).length() != 0; ) {
-      Internal.instance.addLenient(builder, line);
+      Internal.instance.addLenient(headers, line);
     }
+    return headers.build();
   }
 
   public Sink newChunkedSink() {
@@ -234,7 +224,7 @@ public Sink newFixedLengthSink(long contentLength) {
     return new FixedLengthSink(contentLength);
   }
 
-  public void writeRequestBody(RetryableSink requestBody) throws IOException {
+  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
     if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_READ_RESPONSE_HEADERS;
     requestBody.writeToSocket(sink);
@@ -254,18 +244,12 @@ public Source newChunkedSource(HttpEngine httpEngine) throws IOException {
 
   public Source newUnknownLengthSource() throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+    if (streamAllocation == null) throw new IllegalStateException("streamAllocation == null");
     state = STATE_READING_RESPONSE_BODY;
+    streamAllocation.noNewStreams();
     return new UnknownLengthSource();
   }
 
-  public BufferedSink rawSink() {
-    return sink;
-  }
-
-  public BufferedSource rawSource() {
-    return source;
-  }
-
   /**
    * Sets the delegate of {@code timeout} to {@link Timeout#NONE} and resets its underlying timeout
    * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
@@ -318,9 +302,8 @@ private FixedLengthSink(long bytesRemaining) {
   }
 
   /**
-   * An HTTP body with alternating chunk sizes and chunk bodies. It is the
-   * caller's responsibility to buffer chunks; typically by using a buffered
-   * sink with this sink.
+   * An HTTP body with alternating chunk sizes and chunk bodies. It is the caller's responsibility
+   * to buffer chunks; typically by using a buffered sink with this sink.
    */
   private final class ChunkedSink implements Sink {
     private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
@@ -363,39 +346,19 @@ private FixedLengthSink(long bytesRemaining) {
     }
 
     /**
-     * Closes the cache entry and makes the socket available for reuse. This
-     * should be invoked when the end of the body has been reached.
+     * Closes the cache entry and makes the socket available for reuse. This should be invoked when
+     * the end of the body has been reached.
      */
-    protected final void endOfInput(boolean recyclable) throws IOException {
+    protected final void endOfInput(boolean reuseConnection) throws IOException {
+      if (state == STATE_CLOSED) return;
       if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
 
       detachTimeout(timeout);
 
-      state = STATE_IDLE;
-      if (recyclable && onIdle == ON_IDLE_POOL) {
-        onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
-        Internal.instance.recycle(pool, connection);
-      } else if (onIdle == ON_IDLE_CLOSE) {
-        state = STATE_CLOSED;
-        connection.getSocket().close();
-      }
-    }
-
-    /**
-     * Calls abort on the cache entry and disconnects the socket. This
-     * should be invoked when the connection is closed unexpectedly to
-     * invalidate the cache entry and to prevent the HTTP connection from
-     * being reused. HTTP messages are sent in serial so whenever a message
-     * cannot be read to completion, subsequent messages cannot be read
-     * either and the connection must be discarded.
-     *
-     * <p>An earlier implementation skipped the remaining bytes, but this
-     * requires that the entire transfer be completed. If the intention was
-     * to cancel the transfer, closing the connection is the only solution.
-     */
-    protected final void unexpectedEndOfInput() {
-      Util.closeQuietly(connection.getSocket());
       state = STATE_CLOSED;
+      if (streamAllocation != null) {
+        streamAllocation.streamFinished(!reuseConnection, Http1xStream.this);
+      }
     }
   }
 
@@ -417,7 +380,7 @@ public FixedLengthSource(long length) throws IOException {
 
       long read = source.read(sink, Math.min(bytesRemaining, byteCount));
       if (read == -1) {
-        unexpectedEndOfInput(); // The server didn't supply the promised content length.
+        endOfInput(false); // The server didn't supply the promised content length.
         throw new ProtocolException("unexpected end of stream");
       }
 
@@ -431,9 +394,8 @@ public FixedLengthSource(long length) throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
 
-      if (bytesRemaining != 0
-          && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        unexpectedEndOfInput();
+      if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+        endOfInput(false);
       }
 
       closed = true;
@@ -463,7 +425,7 @@ public FixedLengthSource(long length) throws IOException {
 
       long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
       if (read == -1) {
-        unexpectedEndOfInput(); // The server didn't supply the promised chunk length.
+        endOfInput(false); // The server didn't supply the promised chunk length.
         throw new ProtocolException("unexpected end of stream");
       }
       bytesRemainingInChunk -= read;
@@ -487,9 +449,7 @@ private void readChunkSize() throws IOException {
       }
       if (bytesRemainingInChunk == 0L) {
         hasMoreChunks = false;
-        Headers.Builder trailersBuilder = new Headers.Builder();
-        readHeaders(trailersBuilder);
-        httpEngine.receiveHeaders(trailersBuilder.build());
+        httpEngine.receiveHeaders(readHeaders());
         endOfInput(true);
       }
     }
@@ -497,7 +457,7 @@ private void readChunkSize() throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
       if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        unexpectedEndOfInput();
+        endOfInput(false);
       }
       closed = true;
     }
@@ -516,7 +476,7 @@ private void readChunkSize() throws IOException {
       long read = source.read(sink, byteCount);
       if (read == -1) {
         inputExhausted = true;
-        endOfInput(false);
+        endOfInput(true);
         return -1;
       }
       return read;
@@ -525,7 +485,7 @@ private void readChunkSize() throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
       if (!inputExhausted) {
-        unexpectedEndOfInput();
+        endOfInput(false);
       }
       closed = true;
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
new file mode 100644
index 0000000000..99151f8371
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
@@ -0,0 +1,295 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Headers;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Util;
+import okhttp3.internal.framed.ErrorCode;
+import okhttp3.internal.framed.FramedConnection;
+import okhttp3.internal.framed.FramedStream;
+import okhttp3.internal.framed.Header;
+import okio.ByteString;
+import okio.ForwardingSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+import static okhttp3.internal.framed.Header.RESPONSE_STATUS;
+import static okhttp3.internal.framed.Header.TARGET_AUTHORITY;
+import static okhttp3.internal.framed.Header.TARGET_HOST;
+import static okhttp3.internal.framed.Header.TARGET_METHOD;
+import static okhttp3.internal.framed.Header.TARGET_PATH;
+import static okhttp3.internal.framed.Header.TARGET_SCHEME;
+import static okhttp3.internal.framed.Header.VERSION;
+
+/** An HTTP stream for HTTP/2 and SPDY. */
+public final class Http2xStream implements HttpStream {
+  private static final ByteString CONNECTION = ByteString.encodeUtf8("connection");
+  private static final ByteString HOST = ByteString.encodeUtf8("host");
+  private static final ByteString KEEP_ALIVE = ByteString.encodeUtf8("keep-alive");
+  private static final ByteString PROXY_CONNECTION = ByteString.encodeUtf8("proxy-connection");
+  private static final ByteString TRANSFER_ENCODING = ByteString.encodeUtf8("transfer-encoding");
+  private static final ByteString TE = ByteString.encodeUtf8("te");
+  private static final ByteString ENCODING = ByteString.encodeUtf8("encoding");
+  private static final ByteString UPGRADE = ByteString.encodeUtf8("upgrade");
+
+  /** See http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1#TOC-3.2.1-Request. */
+  private static final List<ByteString> SPDY_3_SKIPPED_REQUEST_HEADERS = Util.immutableList(
+      CONNECTION,
+      HOST,
+      KEEP_ALIVE,
+      PROXY_CONNECTION,
+      TRANSFER_ENCODING,
+      TARGET_METHOD,
+      TARGET_PATH,
+      TARGET_SCHEME,
+      TARGET_AUTHORITY,
+      TARGET_HOST,
+      VERSION);
+  private static final List<ByteString> SPDY_3_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
+      CONNECTION,
+      HOST,
+      KEEP_ALIVE,
+      PROXY_CONNECTION,
+      TRANSFER_ENCODING);
+
+  /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
+  private static final List<ByteString> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
+      CONNECTION,
+      HOST,
+      KEEP_ALIVE,
+      PROXY_CONNECTION,
+      TE,
+      TRANSFER_ENCODING,
+      ENCODING,
+      UPGRADE,
+      TARGET_METHOD,
+      TARGET_PATH,
+      TARGET_SCHEME,
+      TARGET_AUTHORITY,
+      TARGET_HOST,
+      VERSION);
+  private static final List<ByteString> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
+      CONNECTION,
+      HOST,
+      KEEP_ALIVE,
+      PROXY_CONNECTION,
+      TE,
+      TRANSFER_ENCODING,
+      ENCODING,
+      UPGRADE);
+
+  private final StreamAllocation streamAllocation;
+  private final FramedConnection framedConnection;
+  private HttpEngine httpEngine;
+  private FramedStream stream;
+
+  public Http2xStream(StreamAllocation streamAllocation, FramedConnection framedConnection) {
+    this.streamAllocation = streamAllocation;
+    this.framedConnection = framedConnection;
+  }
+
+  @Override public void setHttpEngine(HttpEngine httpEngine) {
+    this.httpEngine = httpEngine;
+  }
+
+  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
+    return stream.getSink();
+  }
+
+  @Override public void writeRequestHeaders(Request request) throws IOException {
+    if (stream != null) return;
+
+    httpEngine.writingRequestHeaders();
+    boolean permitsRequestBody = httpEngine.permitsRequestBody(request);
+    List<Header> requestHeaders = framedConnection.getProtocol() == Protocol.HTTP_2
+        ? http2HeadersList(request)
+        : spdy3HeadersList(request);
+    boolean hasResponseBody = true;
+    stream = framedConnection.newStream(requestHeaders, permitsRequestBody, hasResponseBody);
+    stream.readTimeout().timeout(httpEngine.client.readTimeoutMillis(), TimeUnit.MILLISECONDS);
+    stream.writeTimeout().timeout(httpEngine.client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
+  }
+
+  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
+    requestBody.writeToSocket(stream.getSink());
+  }
+
+  @Override public void finishRequest() throws IOException {
+    stream.getSink().close();
+  }
+
+  @Override public Response.Builder readResponseHeaders() throws IOException {
+    return framedConnection.getProtocol() == Protocol.HTTP_2
+        ? readHttp2HeadersList(stream.getResponseHeaders())
+        : readSpdy3HeadersList(stream.getResponseHeaders());
+  }
+
+  /**
+   * Returns a list of alternating names and values containing a SPDY request. Names are all
+   * lowercase. No names are repeated. If any name has multiple values, they are concatenated using
+   * "\0" as a delimiter.
+   */
+  public static List<Header> spdy3HeadersList(Request request) {
+    Headers headers = request.headers();
+    List<Header> result = new ArrayList<>(headers.size() + 5);
+    result.add(new Header(TARGET_METHOD, request.method()));
+    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
+    result.add(new Header(VERSION, "HTTP/1.1"));
+    result.add(new Header(TARGET_HOST, Util.hostHeader(request.url(), false)));
+    result.add(new Header(TARGET_SCHEME, request.url().scheme()));
+
+    Set<ByteString> names = new LinkedHashSet<>();
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      // header names must be lowercase.
+      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
+
+      // Drop headers that are forbidden when layering HTTP over SPDY.
+      if (SPDY_3_SKIPPED_REQUEST_HEADERS.contains(name)) continue;
+
+      // If we haven't seen this name before, add the pair to the end of the list...
+      String value = headers.value(i);
+      if (names.add(name)) {
+        result.add(new Header(name, value));
+        continue;
+      }
+
+      // ...otherwise concatenate the existing values and this value.
+      for (int j = 0; j < result.size(); j++) {
+        if (result.get(j).name.equals(name)) {
+          String concatenated = joinOnNull(result.get(j).value.utf8(), value);
+          result.set(j, new Header(name, concatenated));
+          break;
+        }
+      }
+    }
+    return result;
+  }
+
+  private static String joinOnNull(String first, String second) {
+    return new StringBuilder(first).append('\0').append(second).toString();
+  }
+
+  public static List<Header> http2HeadersList(Request request) {
+    Headers headers = request.headers();
+    List<Header> result = new ArrayList<>(headers.size() + 4);
+    result.add(new Header(TARGET_METHOD, request.method()));
+    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
+    result.add(new Header(TARGET_AUTHORITY, Util.hostHeader(request.url(), false))); // Optional.
+    result.add(new Header(TARGET_SCHEME, request.url().scheme()));
+
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      // header names must be lowercase.
+      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
+      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name)) {
+        result.add(new Header(name, headers.value(i)));
+      }
+    }
+    return result;
+  }
+
+  /** Returns headers for a name value block containing a SPDY response. */
+  public static Response.Builder readSpdy3HeadersList(List<Header> headerBlock) throws IOException {
+    String status = null;
+    String version = "HTTP/1.1";
+    Headers.Builder headersBuilder = new Headers.Builder();
+    for (int i = 0, size = headerBlock.size(); i < size; i++) {
+      ByteString name = headerBlock.get(i).name;
+
+      String values = headerBlock.get(i).value.utf8();
+      for (int start = 0; start < values.length(); ) {
+        int end = values.indexOf('\0', start);
+        if (end == -1) {
+          end = values.length();
+        }
+        String value = values.substring(start, end);
+        if (name.equals(RESPONSE_STATUS)) {
+          status = value;
+        } else if (name.equals(VERSION)) {
+          version = value;
+        } else if (!SPDY_3_SKIPPED_RESPONSE_HEADERS.contains(name)) {
+          headersBuilder.add(name.utf8(), value);
+        }
+        start = end + 1;
+      }
+    }
+    if (status == null) throw new ProtocolException("Expected ':status' header not present");
+
+    StatusLine statusLine = StatusLine.parse(version + " " + status);
+    return new Response.Builder()
+        .protocol(Protocol.SPDY_3)
+        .code(statusLine.code)
+        .message(statusLine.message)
+        .headers(headersBuilder.build());
+  }
+
+  /** Returns headers for a name value block containing an HTTP/2 response. */
+  public static Response.Builder readHttp2HeadersList(List<Header> headerBlock) throws IOException {
+    String status = null;
+
+    Headers.Builder headersBuilder = new Headers.Builder();
+    for (int i = 0, size = headerBlock.size(); i < size; i++) {
+      ByteString name = headerBlock.get(i).name;
+
+      String value = headerBlock.get(i).value.utf8();
+      if (name.equals(RESPONSE_STATUS)) {
+        status = value;
+      } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
+        headersBuilder.add(name.utf8(), value);
+      }
+    }
+    if (status == null) throw new ProtocolException("Expected ':status' header not present");
+
+    StatusLine statusLine = StatusLine.parse("HTTP/1.1 " + status);
+    return new Response.Builder()
+        .protocol(Protocol.HTTP_2)
+        .code(statusLine.code)
+        .message(statusLine.message)
+        .headers(headersBuilder.build());
+  }
+
+  @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    Source source = new StreamFinishingSource(stream.getSource());
+    return new RealResponseBody(response.headers(), Okio.buffer(source));
+  }
+
+  @Override public void cancel() {
+    if (stream != null) stream.closeLater(ErrorCode.CANCEL);
+  }
+
+  class StreamFinishingSource extends ForwardingSource {
+    public StreamFinishingSource(Source delegate) {
+      super(delegate);
+    }
+
+    @Override public void close() throws IOException {
+      streamAllocation.streamFinished(false, Http2xStream.this);
+      super.close();
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java b/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
similarity index 93%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
rename to okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
index 27511b37ca..2991dd7b51 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
@@ -13,22 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
 import java.text.DateFormat;
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
-import java.util.TimeZone;
+
+import static okhttp3.internal.Util.UTC;
 
 /**
  * Best-effort parser for HTTP dates.
  */
 public final class HttpDate {
-
-  private static final TimeZone GMT = TimeZone.getTimeZone("GMT");
+  /** The last four-digit year: "Fri, 31 Dec 9999 23:59:59 GMT". */
+  public static final long MAX_DATE = 253402300799999L;
 
   /**
    * Most websites serve cookies in the blessed format. Eagerly create the parser to ensure such
@@ -40,7 +40,7 @@
           // RFC 2616 specified: RFC 822, updated by RFC 1123 format with fixed GMT.
           DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US);
           rfc1123.setLenient(false);
-          rfc1123.setTimeZone(GMT);
+          rfc1123.setTimeZone(UTC);
           return rfc1123;
         }
       };
@@ -51,7 +51,7 @@
       "EEE, dd MMM yyyy HH:mm:ss zzz", // RFC 822, updated by RFC 1123 with any TZ
       "EEEE, dd-MMM-yy HH:mm:ss zzz", // RFC 850, obsoleted by RFC 1036 with any TZ.
       "EEE MMM d HH:mm:ss yyyy", // ANSI C's asctime() format
-       // Alternative formats.
+      // Alternative formats.
       "EEE, dd-MMM-yyyy HH:mm:ss z",
       "EEE, dd-MMM-yyyy HH-mm-ss z",
       "EEE, dd MMM yy HH:mm:ss z",
@@ -91,7 +91,7 @@ public static Date parse(String value) {
           format = new SimpleDateFormat(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS[i], Locale.US);
           // Set the timezone to use when interpreting formats that don't have a timezone. GMT is
           // specified by RFC 2616.
-          format.setTimeZone(GMT);
+          format.setTimeZone(UTC);
           BROWSER_COMPATIBLE_DATE_FORMATS[i] = format;
         }
         position.setIndex(0);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
similarity index 58%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
rename to okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
index fbd6603ac6..17ee87a4a4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
@@ -14,40 +14,33 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
+package okhttp3.internal.http;
 
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Address;
-import com.squareup.okhttp.CertificatePinner;
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.Route;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.InternalCache;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.Version;
 import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.CookieHandler;
 import java.net.ProtocolException;
 import java.net.Proxy;
-import java.security.cert.CertificateException;
 import java.util.Date;
 import java.util.List;
-import java.util.Map;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Address;
+import okhttp3.CertificatePinner;
+import okhttp3.Connection;
+import okhttp3.Cookie;
+import okhttp3.CookieJar;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.Route;
+import okhttp3.internal.Internal;
+import okhttp3.internal.InternalCache;
+import okhttp3.internal.Version;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -57,10 +50,7 @@
 import okio.Source;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.Util.closeQuietly;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static java.net.HttpURLConnection.HTTP_CLIENT_TIMEOUT;
 import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
 import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
 import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
@@ -70,24 +60,23 @@
 import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
 import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.internal.Util.discard;
+import static okhttp3.internal.Util.hostHeader;
+import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
+import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
 /**
- * Handles a single HTTP request/response pair. Each HTTP engine follows this
- * lifecycle:
- * <ol>
- * <li>It is created.
- * <li>The HTTP request message is sent with sendRequest(). Once the request
- * is sent it is an error to modify the request headers. After
- * sendRequest() has been called the request body can be written to if
- * it exists.
- * <li>The HTTP response message is read with readResponse(). After the
- * response has been read the response headers and body can be read.
- * All responses have a response body input stream, though in some
- * instances this stream is empty.
- * </ol>
+ * Handles a single HTTP request/response pair. Each HTTP engine follows this lifecycle: <ol> <li>It
+ * is created. <li>The HTTP request message is sent with sendRequest(). Once the request is sent it
+ * is an error to modify the request headers. After sendRequest() has been called the request body
+ * can be written to if it exists. <li>The HTTP response message is read with readResponse(). After
+ * the response has been read the response headers and body can be read. All responses have a
+ * response body input stream, though in some instances this stream is empty. </ol>
  *
- * <p>The request and response may be served by the HTTP response cache, by the
- * network, or by both in the event of a conditional GET.
+ * <p>The request and response may be served by the HTTP response cache, by the network, or by both
+ * in the event of a conditional GET.
  */
 public final class HttpEngine {
   /**
@@ -100,9 +89,11 @@
     @Override public MediaType contentType() {
       return null;
     }
+
     @Override public long contentLength() {
       return 0;
     }
+
     @Override public BufferedSource source() {
       return new Buffer();
     }
@@ -110,55 +101,48 @@
 
   final OkHttpClient client;
 
-  private Connection connection;
-  private Address address;
-  private RouteSelector routeSelector;
-  private Route route;
+  public final StreamAllocation streamAllocation;
   private final Response priorResponse;
-
-  private Transport transport;
+  private HttpStream httpStream;
 
   /** The time when the request headers were written, or -1 if they haven't been written yet. */
   long sentRequestMillis = -1;
 
   /**
-   * True if this client added an "Accept-Encoding: gzip" header field and is
-   * therefore responsible for also decompressing the transfer stream.
+   * True if this client added an "Accept-Encoding: gzip" header field and is therefore responsible
+   * for also decompressing the transfer stream.
    */
   private boolean transparentGzip;
 
   /**
-   * True if the request body must be completely buffered before transmission;
-   * false if it can be streamed. Buffering has two advantages: we don't need
-   * the content-length in advance and we can retransmit if necessary. The
-   * upside of streaming is that we can save memory.
+   * True if the request body must be completely buffered before transmission; false if it can be
+   * streamed. Buffering has two advantages: we don't need the content-length in advance and we can
+   * retransmit if necessary. The upside of streaming is that we can save memory.
    */
   public final boolean bufferRequestBody;
 
   /**
-   * The original application-provided request. Never modified by OkHttp. When
-   * follow-up requests are necessary, they are derived from this request.
+   * The original application-provided request. Never modified by OkHttp. When follow-up requests
+   * are necessary, they are derived from this request.
    */
   private final Request userRequest;
 
   /**
-   * The request to send on the network, or null for no network request. This is
-   * derived from the user request, and customized to support OkHttp features
-   * like compression and caching.
+   * The request to send on the network, or null for no network request. This is derived from the
+   * user request, and customized to support OkHttp features like compression and caching.
    */
   private Request networkRequest;
 
   /**
-   * The cached response, or null if the cache doesn't exist or cannot be used
-   * for this request. Conditional caching means this may be non-null even when
-   * the network request is non-null. Never modified by OkHttp.
+   * The cached response, or null if the cache doesn't exist or cannot be used for this request.
+   * Conditional caching means this may be non-null even when the network request is non-null. Never
+   * modified by OkHttp.
    */
   private Response cacheResponse;
 
   /**
-   * The user-visible response. This is derived from either the network
-   * response, cache response, or both. It is customized to support OkHttp
-   * features like compression and caching.
+   * The user-visible response. This is derived from either the network response, cache response, or
+   * both. It is customized to support OkHttp features like compression and caching.
    */
   private Response userResponse;
 
@@ -173,51 +157,39 @@
 
   /**
    * @param request the HTTP request without a body. The body must be written via the engine's
-   *     request body stream.
-   * @param callerWritesRequestBody true for the {@code HttpURLConnection}-style interaction
-   *     model where control flow is returned to the calling application to write the request body
-   *     before the response body is readable.
-   * @param connection the connection used for an intermediate response immediately prior to this
-   *     request/response pair, such as a same-host redirect. This engine assumes ownership of the
-   *     connection and must release it when it is unneeded.
-   * @param routeSelector the route selector used for a failed attempt immediately preceding this
+   * request body stream.
+   * @param callerWritesRequestBody true for the {@code HttpURLConnection}-style interaction model
+   * where control flow is returned to the calling application to write the request body before the
+   * response body is readable.
    */
   public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
-      boolean callerWritesRequestBody, boolean forWebSocket, Connection connection,
-      RouteSelector routeSelector, RetryableSink requestBodyOut, Response priorResponse) {
+      boolean callerWritesRequestBody, boolean forWebSocket, StreamAllocation streamAllocation,
+      RetryableSink requestBodyOut, Response priorResponse) {
     this.client = client;
     this.userRequest = request;
     this.bufferRequestBody = bufferRequestBody;
     this.callerWritesRequestBody = callerWritesRequestBody;
     this.forWebSocket = forWebSocket;
-    this.connection = connection;
-    this.routeSelector = routeSelector;
+    this.streamAllocation = streamAllocation != null
+        ? streamAllocation
+        : new StreamAllocation(client.connectionPool(), createAddress(client, request));
     this.requestBodyOut = requestBodyOut;
     this.priorResponse = priorResponse;
-
-    if (connection != null) {
-      Internal.instance.setOwner(connection, this);
-      this.route = connection.getRoute();
-    } else {
-      this.route = null;
-    }
   }
 
   /**
-   * Figures out what the response source will be, and opens a socket to that
-   * source if necessary. Prepares the request headers and gets ready to start
-   * writing the request body if it exists.
+   * Figures out what the response source will be, and opens a socket to that source if necessary.
+   * Prepares the request headers and gets ready to start writing the request body if it exists.
    *
    * @throws RequestException if there was a problem with request setup. Unrecoverable.
    * @throws RouteException if the was a problem during connection via a specific route. Sometimes
-   *     recoverable. See {@link #recover(RouteException)}.
+   * recoverable. See {@link #recover}.
    * @throws IOException if there was a problem while making a request. Sometimes recoverable. See
-   *     {@link #recover(IOException)}.
-   *
+   * {@link #recover(IOException, boolean)}.
    */
   public void sendRequest() throws RequestException, RouteException, IOException {
     if (cacheStrategy != null) return; // Already sent.
-    if (transport != null) throw new IllegalStateException();
+    if (httpStream != null) throw new IllegalStateException();
 
     Request request = networkRequest(userRequest);
 
@@ -239,19 +211,39 @@ public void sendRequest() throws RequestException, RouteException, IOException {
       closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
     }
 
-    if (networkRequest != null) {
-      // Open a connection unless we inherited one from a redirect.
-      if (connection == null) {
-        connect();
-      }
+    // If we're forbidden from using the network and the cache is insufficient, fail.
+    if (networkRequest == null && cacheResponse == null) {
+      userResponse = new Response.Builder()
+          .request(userRequest)
+          .priorResponse(stripBody(priorResponse))
+          .protocol(Protocol.HTTP_1_1)
+          .code(504)
+          .message("Unsatisfiable Request (only-if-cached)")
+          .body(EMPTY_BODY)
+          .sentRequestAtMillis(sentRequestMillis)
+          .receivedResponseAtMillis(System.currentTimeMillis())
+          .build();
+      return;
+    }
+
+    // If we don't need the network, we're done.
+    if (networkRequest == null) {
+      userResponse = cacheResponse.newBuilder()
+          .request(userRequest)
+          .priorResponse(stripBody(priorResponse))
+          .cacheResponse(stripBody(cacheResponse))
+          .build();
+      userResponse = unzip(userResponse);
+      return;
+    }
 
-      transport = Internal.instance.newTransport(connection, this);
+    // We need the network to satisfy this request. Possibly for validating a conditional GET.
+    boolean success = false;
+    try {
+      httpStream = connect();
+      httpStream.setHttpEngine(this);
 
-      // If the caller's control flow writes the request body, we need to create that stream
-      // immediately. And that means we need to immediately write the request headers, so we can
-      // start streaming the request body. (We may already have a request body if we're retrying a
-      // failed POST.)
-      if (callerWritesRequestBody && permitsRequestBody() && requestBodyOut == null) {
+      if (writeRequestHeadersEagerly()) {
         long contentLength = OkHeaders.contentLength(request);
         if (bufferRequestBody) {
           if (contentLength > Integer.MAX_VALUE) {
@@ -261,48 +253,44 @@ public void sendRequest() throws RequestException, RouteException, IOException {
 
           if (contentLength != -1) {
             // Buffer a request body of a known length.
-            transport.writeRequestHeaders(networkRequest);
+            httpStream.writeRequestHeaders(networkRequest);
             requestBodyOut = new RetryableSink((int) contentLength);
           } else {
-            // Buffer a request body of an unknown length. Don't write request
-            // headers until the entire body is ready; otherwise we can't set the
-            // Content-Length header correctly.
+            // Buffer a request body of an unknown length. Don't write request headers until the
+            // entire body is ready; otherwise we can't set the Content-Length header correctly.
             requestBodyOut = new RetryableSink();
           }
         } else {
-          transport.writeRequestHeaders(networkRequest);
-          requestBodyOut = transport.createRequestBody(networkRequest, contentLength);
+          httpStream.writeRequestHeaders(networkRequest);
+          requestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);
         }
       }
-
-    } else {
-      // We aren't using the network. Recycle a connection we may have inherited from a redirect.
-      if (connection != null) {
-        Internal.instance.recycle(client.getConnectionPool(), connection);
-        connection = null;
+      success = true;
+    } finally {
+      // If we're crashing on I/O or otherwise, don't leak the cache body.
+      if (!success && cacheCandidate != null) {
+        closeQuietly(cacheCandidate.body());
       }
+    }
+  }
 
-      if (cacheResponse != null) {
-        // We have a valid cached response. Promote it to the user response immediately.
-        this.userResponse = cacheResponse.newBuilder()
-            .request(userRequest)
-            .priorResponse(stripBody(priorResponse))
-            .cacheResponse(stripBody(cacheResponse))
-            .build();
-      } else {
-        // We're forbidden from using the network, and the cache is insufficient.
-        this.userResponse = new Response.Builder()
-            .request(userRequest)
-            .priorResponse(stripBody(priorResponse))
-            .protocol(Protocol.HTTP_1_1)
-            .code(504)
-            .message("Unsatisfiable Request (only-if-cached)")
-            .body(EMPTY_BODY)
-            .build();
-      }
+  /**
+   * If the caller's control flow writes the request body, we need to create that stream
+   * immediately. And that means we need to immediately write the request headers, so we can
+   * start streaming the request body. (We may already have a request body if we're retrying a
+   * failed POST.)
+   */
+  private boolean writeRequestHeadersEagerly() {
+    return callerWritesRequestBody
+        && permitsRequestBody(networkRequest)
+        && requestBodyOut == null;
+  }
 
-      userResponse = unzip(userResponse);
-    }
+  private HttpStream connect() throws RouteException, RequestException, IOException {
+    boolean doExtensiveHealthChecks = !networkRequest.method().equals("GET");
+    return streamAllocation.newStream(client.connectTimeoutMillis(),
+        client.readTimeoutMillis(), client.writeTimeoutMillis(),
+        client.retryOnConnectionFailure(), doExtensiveHealthChecks);
   }
 
   private static Response stripBody(Response response) {
@@ -311,54 +299,17 @@ private static Response stripBody(Response response) {
         : response;
   }
 
-  /** Connect to the origin server either directly or via a proxy. */
-  private void connect() throws RequestException, RouteException {
-    if (connection != null) throw new IllegalStateException();
-
-    if (routeSelector == null) {
-      address = createAddress(client, networkRequest);
-      try {
-        routeSelector = RouteSelector.get(address, networkRequest, client);
-      } catch (IOException e) {
-        throw new RequestException(e);
-      }
-    }
-
-    connection = createNextConnection();
-    Internal.instance.connectAndSetOwner(client, connection, this, networkRequest);
-    route = connection.getRoute();
-  }
-
-  private Connection createNextConnection() throws RouteException {
-    ConnectionPool pool = client.getConnectionPool();
-
-    // Always prefer pooled connections over new connections.
-    for (Connection pooled; (pooled = pool.get(address)) != null; ) {
-      if (networkRequest.method().equals("GET") || Internal.instance.isReadable(pooled)) {
-        return pooled;
-      }
-      closeQuietly(pooled.getSocket());
-    }
-
-    try {
-      Route route = routeSelector.next();
-      return new Connection(pool, route);
-    } catch (IOException e) {
-      throw new RouteException(e);
-    }
-  }
-
   /**
-   * Called immediately before the transport transmits HTTP request headers.
-   * This is used to observe the sent time should the request be cached.
+   * Called immediately before the transport transmits HTTP request headers. This is used to observe
+   * the sent time should the request be cached.
    */
   public void writingRequestHeaders() {
     if (sentRequestMillis != -1) throw new IllegalStateException();
     sentRequestMillis = System.currentTimeMillis();
   }
 
-  boolean permitsRequestBody() {
-    return HttpMethod.permitsRequestBody(userRequest.method());
+  boolean permitsRequestBody(Request request) {
+    return HttpMethod.permitsRequestBody(request.method());
   }
 
   /** Returns the request body or null if this request doesn't have a body. */
@@ -392,138 +343,32 @@ public Response getResponse() {
   }
 
   public Connection getConnection() {
-    return connection;
+    return streamAllocation.connection();
   }
 
   /**
-   * Attempt to recover from failure to connect via a route. Returns a new HTTP engine
-   * that should be used for the retry if there are other routes to try, or null if
-   * there are no more routes to try.
+   * Report and attempt to recover from a failure to communicate with a server. Returns a new HTTP
+   * engine that should be used for the retry if {@code e} is recoverable, or null if the failure is
+   * permanent. Requests with a body can only be recovered if the body is buffered.
    */
-  public HttpEngine recover(RouteException e) {
-    if (routeSelector != null && connection != null) {
-      connectFailed(routeSelector, e.getLastConnectException());
-    }
-
-    if (routeSelector == null && connection == null // No connection.
-        || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
-        || !isRecoverable(e)) {
+  public HttpEngine recover(IOException e, boolean routeException, Sink requestBodyOut) {
+    if (!streamAllocation.recover(e, routeException, requestBodyOut)) {
       return null;
     }
 
-    Connection connection = close();
-
-    // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
-        forWebSocket, connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
-  }
-
-  private boolean isRecoverable(RouteException e) {
-    // If the application has opted-out of recovery, don't recover.
-    if (!client.getRetryOnConnectionFailure()) {
-      return false;
-    }
-
-    // Problems with a route may mean the connection can be retried with a new route, or may
-    // indicate a client-side or server-side issue that should not be retried. To tell, we must look
-    // at the cause.
-
-    IOException ioe = e.getLastConnectException();
-
-    // TODO(nfuller): This is the same logic as in ConnectionSpecSelector
-    // If there was a protocol problem, don't recover.
-    if (ioe instanceof ProtocolException) {
-      return false;
-    }
-
-    // If there was an interruption or timeout, don't recover.
-    if (ioe instanceof InterruptedIOException) {
-      return false;
-    }
-
-    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
-    // again with a different route.
-    if (ioe instanceof SSLHandshakeException) {
-      // If the problem was a CertificateException from the X509TrustManager,
-      // do not retry.
-      if (ioe.getCause() instanceof CertificateException) {
-        return false;
-      }
-    }
-    if (ioe instanceof SSLPeerUnverifiedException) {
-      // e.g. a certificate pinning error.
-      return false;
-    }
-    // TODO(nfuller): End of common code.
-
-    // An example of one we might want to retry with a different route is a problem connecting to a
-    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
-    // retry, we return true and try a new route.
-    return true;
-  }
-
-  /**
-   * Report and attempt to recover from a failure to communicate with a server. Returns a new
-   * HTTP engine that should be used for the retry if {@code e} is recoverable, or null if
-   * the failure is permanent. Requests with a body can only be recovered if the
-   * body is buffered.
-   */
-  public HttpEngine recover(IOException e, Sink requestBodyOut) {
-    if (routeSelector != null && connection != null) {
-      connectFailed(routeSelector, e);
-    }
-
-    boolean canRetryRequestBody = requestBodyOut == null || requestBodyOut instanceof RetryableSink;
-    if (routeSelector == null && connection == null // No connection.
-        || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
-        || !isRecoverable(e)
-        || !canRetryRequestBody) {
+    if (!client.retryOnConnectionFailure()) {
       return null;
     }
 
-    Connection connection = close();
+    StreamAllocation streamAllocation = close();
 
     // For failure recovery, use the same route selector with a new connection.
     return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
-        forWebSocket, connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
-  }
-
-  private void connectFailed(RouteSelector routeSelector, IOException e) {
-    // If this is a recycled connection, don't count its failure against the route.
-    if (Internal.instance.recycleCount(connection) > 0) return;
-    Route failedRoute = connection.getRoute();
-    routeSelector.connectFailed(failedRoute, e);
-  }
-
-  public HttpEngine recover(IOException e) {
-    return recover(e, requestBodyOut);
+        forWebSocket, streamAllocation, (RetryableSink) requestBodyOut, priorResponse);
   }
 
-  private boolean isRecoverable(IOException e) {
-    // If the application has opted-out of recovery, don't recover.
-    if (!client.getRetryOnConnectionFailure()) {
-      return false;
-    }
-
-    // If there was a protocol problem, don't recover.
-    if (e instanceof ProtocolException) {
-      return false;
-    }
-
-    // If there was an interruption or timeout, don't recover.
-    if (e instanceof InterruptedIOException) {
-      return false;
-    }
-
-    return true;
-  }
-
-  /**
-   * Returns the route used to retrieve the response. Null if we haven't
-   * connected yet, or if no connection was necessary.
-   */
-  public Route getRoute() {
-    return route;
+  public HttpEngine recover(IOException e, boolean routeException) {
+    return recover(e, routeException, requestBodyOut);
   }
 
   private void maybeCache() throws IOException {
@@ -543,19 +388,15 @@ private void maybeCache() throws IOException {
     }
 
     // Offer this request to the cache.
-    storeRequest = responseCache.put(stripBody(userResponse));
+    storeRequest = responseCache.put(userResponse);
   }
 
   /**
-   * Configure the socket connection to be either pooled or closed when it is
-   * either exhausted or closed. If it is unneeded when this is called, it will
-   * be released immediately.
+   * Configure the socket connection to be either pooled or closed when it is either exhausted or
+   * closed. If it is unneeded when this is called, it will be released immediately.
    */
-  public void releaseConnection() throws IOException {
-    if (transport != null && connection != null) {
-      transport.releaseConnectionOnIdle();
-    }
-    connection = null;
+  public void releaseStreamAllocation() throws IOException {
+    streamAllocation.release();
   }
 
   /**
@@ -567,25 +408,15 @@ public void releaseConnection() throws IOException {
    * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
    * Otherwise if a socket connection is being established, that is terminated.
    */
-  public void disconnect() {
-    try {
-      if (transport != null) {
-        transport.disconnect(this);
-      } else {
-        Connection connection = this.connection;
-        if (connection != null) {
-          Internal.instance.closeIfOwnedBy(connection, this);
-        }
-      }
-    } catch (IOException ignored) {
-    }
+  public void cancel() {
+    streamAllocation.cancel();
   }
 
   /**
-   * Release any resources held by this engine. If a connection is still held by
-   * this engine, it is returned.
+   * Release any resources held by this engine. Returns the stream allocation held by this engine,
+   * which itself must be used or released.
    */
-  public Connection close() {
+  public StreamAllocation close() {
     if (bufferedRequestBody != null) {
       // This also closes the wrapped requestBodyOut.
       closeQuietly(bufferedRequestBody);
@@ -593,31 +424,14 @@ public Connection close() {
       closeQuietly(requestBodyOut);
     }
 
-    // If this engine never achieved a response body, its connection cannot be reused.
-    if (userResponse == null) {
-      if (connection != null) closeQuietly(connection.getSocket()); // TODO: does this break SPDY?
-      connection = null;
-      return null;
-    }
-
-    // Close the response body. This will recycle the connection if it is eligible.
-    closeQuietly(userResponse.body());
-
-    // Close the connection if it cannot be reused.
-    if (transport != null && connection != null && !transport.canReuseConnection()) {
-      closeQuietly(connection.getSocket());
-      connection = null;
-      return null;
-    }
-
-    // Prevent this engine from disconnecting a connection it no longer owns.
-    if (connection != null && !Internal.instance.clearOwner(connection)) {
-      connection = null;
+    if (userResponse != null) {
+      closeQuietly(userResponse.body());
+    } else {
+      // If this engine never achieved a response body, its stream allocation is dead.
+      streamAllocation.connectionFailed(null);
     }
 
-    Connection result = connection;
-    connection = null;
-    return result;
+    return streamAllocation;
   }
 
   /**
@@ -654,8 +468,7 @@ private Response unzip(final Response response) throws IOException {
   }
 
   /**
-   * Returns true if the response must have a (possibly 0-length) body.
-   * See RFC 2616 section 4.3.
+   * Returns true if the response must have a (possibly 0-length) body. See RFC 2616 section 4.3.
    */
   public static boolean hasBody(Response response) {
     // HEAD requests never yield a body regardless of the response headers.
@@ -684,18 +497,17 @@ public static boolean hasBody(Response response) {
   /**
    * Populates request with defaults and cookies.
    *
-   * <p>This client doesn't specify a default {@code Accept} header because it
-   * doesn't know what content types the application is interested in.
+   * <p>This client doesn't specify a default {@code Accept} header because it doesn't know what
+   * content types the application is interested in.
    */
   private Request networkRequest(Request request) throws IOException {
     Request.Builder result = request.newBuilder();
 
     if (request.header("Host") == null) {
-      result.header("Host", Util.hostHeader(request.httpUrl()));
+      result.header("Host", hostHeader(request.url(), false));
     }
 
-    if ((connection == null || connection.getProtocol() != Protocol.HTTP_1_0)
-        && request.header("Connection") == null) {
+    if (request.header("Connection") == null) {
       result.header("Connection", "Keep-Alive");
     }
 
@@ -704,17 +516,9 @@ private Request networkRequest(Request request) throws IOException {
       result.header("Accept-Encoding", "gzip");
     }
 
-    CookieHandler cookieHandler = client.getCookieHandler();
-    if (cookieHandler != null) {
-      // Capture the request headers added so far so that they can be offered to the CookieHandler.
-      // This is mostly to stay close to the RI; it is unlikely any of the headers above would
-      // affect cookie choice besides "Host".
-      Map<String, List<String>> headers = OkHeaders.toMultimap(result.build().headers(), null);
-
-      Map<String, List<String>> cookies = cookieHandler.get(request.uri(), headers);
-
-      // Add any new cookies to the request.
-      OkHeaders.addCookies(result, cookies);
+    List<Cookie> cookies = client.cookieJar().loadForRequest(request.url());
+    if (!cookies.isEmpty()) {
+      result.header("Cookie", cookieHeader(cookies));
     }
 
     if (request.header("User-Agent") == null) {
@@ -724,9 +528,22 @@ private Request networkRequest(Request request) throws IOException {
     return result.build();
   }
 
+  /** Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}. */
+  private String cookieHeader(List<Cookie> cookies) {
+    StringBuilder cookieHeader = new StringBuilder();
+    for (int i = 0, size = cookies.size(); i < size; i++) {
+      if (i > 0) {
+        cookieHeader.append("; ");
+      }
+      Cookie cookie = cookies.get(i);
+      cookieHeader.append(cookie.name()).append('=').append(cookie.value());
+    }
+    return cookieHeader.toString();
+  }
+
   /**
-   * Flushes the remaining request header and body, parses the HTTP response
-   * headers and starts reading the HTTP response body if it exists.
+   * Flushes the remaining request header and body, parses the HTTP response headers and starts
+   * reading the HTTP response body if it exists.
    */
   public void readResponse() throws IOException {
     if (userResponse != null) {
@@ -742,12 +559,11 @@ public void readResponse() throws IOException {
     Response networkResponse;
 
     if (forWebSocket) {
-      transport.writeRequestHeaders(networkRequest);
+      httpStream.writeRequestHeaders(networkRequest);
       networkResponse = readNetworkResponse();
-
     } else if (!callerWritesRequestBody) {
-      networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);
-
+      networkResponse = new NetworkInterceptorChain(0, networkRequest,
+          streamAllocation.connection()).proceed(networkRequest);
     } else {
       // Emit the request body's buffer so that everything is in requestBodyOut.
       if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
@@ -763,7 +579,7 @@ public void readResponse() throws IOException {
               .header("Content-Length", Long.toString(contentLength))
               .build();
         }
-        transport.writeRequestHeaders(networkRequest);
+        httpStream.writeRequestHeaders(networkRequest);
       }
 
       // Write the request body to the socket.
@@ -775,7 +591,7 @@ public void readResponse() throws IOException {
           requestBodyOut.close();
         }
         if (requestBodyOut instanceof RetryableSink) {
-          transport.writeRequestBody((RetryableSink) requestBodyOut);
+          httpStream.writeRequestBody((RetryableSink) requestBodyOut);
         }
       }
 
@@ -795,13 +611,13 @@ public void readResponse() throws IOException {
             .networkResponse(stripBody(networkResponse))
             .build();
         networkResponse.body().close();
-        releaseConnection();
+        releaseStreamAllocation();
 
         // Update the cache after combining headers but before stripping the
         // Content-Encoding header (as performed by initContentStream()).
         InternalCache responseCache = Internal.instance.internalCache(client);
         responseCache.trackConditionalCacheHit();
-        responseCache.update(cacheResponse, stripBody(userResponse));
+        responseCache.update(cacheResponse, userResponse);
         userResponse = unzip(userResponse);
         return;
       } else {
@@ -825,11 +641,13 @@ public void readResponse() throws IOException {
   class NetworkInterceptorChain implements Interceptor.Chain {
     private final int index;
     private final Request request;
+    private final Connection connection;
     private int calls;
 
-    NetworkInterceptorChain(int index, Request request) {
+    NetworkInterceptorChain(int index, Request request, Connection connection) {
       this.index = index;
       this.request = request;
+      this.connection = connection;
     }
 
     @Override public Connection connection() {
@@ -845,11 +663,11 @@ public void readResponse() throws IOException {
 
       if (index > 0) {
         Interceptor caller = client.networkInterceptors().get(index - 1);
-        Address address = connection().getRoute().getAddress();
+        Address address = connection().route().address();
 
         // Confirm that the interceptor uses the connection we've already prepared.
-        if (!request.httpUrl().host().equals(address.getUriHost())
-            || request.httpUrl().port() != address.getUriPort()) {
+        if (!request.url().host().equals(address.url().host())
+            || request.url().port() != address.url().port()) {
           throw new IllegalStateException("network interceptor " + caller
               + " must retain the same host and port");
         }
@@ -863,7 +681,7 @@ public void readResponse() throws IOException {
 
       if (index < client.networkInterceptors().size()) {
         // There's another interceptor in the chain. Call that.
-        NetworkInterceptorChain chain = new NetworkInterceptorChain(index + 1, request);
+        NetworkInterceptorChain chain = new NetworkInterceptorChain(index + 1, request, connection);
         Interceptor interceptor = client.networkInterceptors().get(index);
         Response interceptedResponse = interceptor.intercept(chain);
 
@@ -872,17 +690,21 @@ public void readResponse() throws IOException {
           throw new IllegalStateException("network interceptor " + interceptor
               + " must call proceed() exactly once");
         }
+        if (interceptedResponse == null) {
+          throw new NullPointerException("network interceptor " + interceptor
+              + " returned null");
+        }
 
         return interceptedResponse;
       }
 
-      transport.writeRequestHeaders(request);
+      httpStream.writeRequestHeaders(request);
 
       //Update the networkRequest with the possibly updated interceptor request.
       networkRequest = request;
 
-      if (permitsRequestBody() && request.body() != null) {
-        Sink requestBodyOut = transport.createRequestBody(request, request.body().contentLength());
+      if (permitsRequestBody(request) && request.body() != null) {
+        Sink requestBodyOut = httpStream.createRequestBody(request, request.body().contentLength());
         BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
         request.body().writeTo(bufferedRequestBody);
         bufferedRequestBody.close();
@@ -901,22 +723,26 @@ public void readResponse() throws IOException {
   }
 
   private Response readNetworkResponse() throws IOException {
-    transport.finishRequest();
+    httpStream.finishRequest();
 
-    Response networkResponse = transport.readResponseHeaders()
+    Response networkResponse = httpStream.readResponseHeaders()
         .request(networkRequest)
-        .handshake(connection.getHandshake())
-        .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
-        .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
+        .handshake(streamAllocation.connection().handshake())
+        .sentRequestAtMillis(sentRequestMillis)
+        .receivedResponseAtMillis(System.currentTimeMillis())
         .build();
 
     if (!forWebSocket) {
       networkResponse = networkResponse.newBuilder()
-          .body(transport.openResponseBody(networkResponse))
+          .body(httpStream.openResponseBody(networkResponse))
           .build();
     }
 
-    Internal.instance.setProtocol(connection, networkResponse.protocol());
+    if ("close".equalsIgnoreCase(networkResponse.request().header("Connection"))
+        || "close".equalsIgnoreCase(networkResponse.header("Connection"))) {
+      streamAllocation.noNewStreams();
+    }
+
     return networkResponse;
   }
 
@@ -969,7 +795,7 @@ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response
 
       @Override public void close() throws IOException {
         if (!cacheRequestClosed
-            && !Util.discard(this, Transport.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+            && !discard(this, HttpStream.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
           cacheRequestClosed = true;
           cacheRequest.abort();
         }
@@ -983,8 +809,8 @@ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response
   }
 
   /**
-   * Returns true if {@code cached} should be used; false if {@code network}
-   * response should be used.
+   * Returns true if {@code cached} should be used; false if {@code network} response should be
+   * used.
    */
   private static boolean validate(Response cached, Response network) {
     if (network.code() == HTTP_NOT_MODIFIED) {
@@ -1007,8 +833,7 @@ private static boolean validate(Response cached, Response network) {
   }
 
   /**
-   * Combines cached headers with a network headers as defined by RFC 2616,
-   * 13.5.3.
+   * Combines cached headers with a network headers as defined by RFC 2616, 13.5.3.
    */
   private static Headers combine(Headers cachedHeaders, Headers networkHeaders) throws IOException {
     Headers.Builder result = new Headers.Builder();
@@ -1038,39 +863,47 @@ private static Headers combine(Headers cachedHeaders, Headers networkHeaders) th
   }
 
   public void receiveHeaders(Headers headers) throws IOException {
-    CookieHandler cookieHandler = client.getCookieHandler();
-    if (cookieHandler != null) {
-      cookieHandler.put(userRequest.uri(), OkHeaders.toMultimap(headers, null));
-    }
+    if (client.cookieJar() == CookieJar.NO_COOKIES) return;
+
+    List<Cookie> cookies = Cookie.parseAll(userRequest.url(), headers);
+    if (cookies.isEmpty()) return;
+
+    client.cookieJar().saveFromResponse(userRequest.url(), cookies);
   }
 
   /**
-   * Figures out the HTTP request to make in response to receiving this engine's
-   * response. This will either add authentication headers or follow redirects.
-   * If a follow-up is either unnecessary or not applicable, this returns null.
+   * Figures out the HTTP request to make in response to receiving this engine's response. This will
+   * either add authentication headers, follow redirects or handle a client request timeout. If a
+   * follow-up is either unnecessary or not applicable, this returns null.
    */
   public Request followUpRequest() throws IOException {
     if (userResponse == null) throw new IllegalStateException();
-    Proxy selectedProxy = getRoute() != null
-        ? getRoute().getProxy()
-        : client.getProxy();
+    Connection connection = streamAllocation.connection();
+    Route route = connection != null
+        ? connection.route()
+        : null;
     int responseCode = userResponse.code();
 
+    final String method = userRequest.method();
     switch (responseCode) {
       case HTTP_PROXY_AUTH:
+        Proxy selectedProxy = route != null
+            ? route.proxy()
+            : client.proxy();
         if (selectedProxy.type() != Proxy.Type.HTTP) {
           throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
         }
-        // fall-through
+        return client.proxyAuthenticator().authenticate(route, userResponse);
+
       case HTTP_UNAUTHORIZED:
-        return OkHeaders.processAuthHeader(client.getAuthenticator(), userResponse, selectedProxy);
+        return client.authenticator().authenticate(route, userResponse);
 
       case HTTP_PERM_REDIRECT:
       case HTTP_TEMP_REDIRECT:
         // "If the 307 or 308 status code is received in response to a request other than GET
         // or HEAD, the user agent MUST NOT automatically redirect the request"
-        if (!userRequest.method().equals("GET") && !userRequest.method().equals("HEAD")) {
-            return null;
+        if (!method.equals("GET") && !method.equals("HEAD")) {
+          return null;
         }
         // fall-through
       case HTTP_MULT_CHOICE:
@@ -1078,23 +911,27 @@ public Request followUpRequest() throws IOException {
       case HTTP_MOVED_TEMP:
       case HTTP_SEE_OTHER:
         // Does the client allow redirects?
-        if (!client.getFollowRedirects()) return null;
+        if (!client.followRedirects()) return null;
 
         String location = userResponse.header("Location");
         if (location == null) return null;
-        HttpUrl url = userRequest.httpUrl().resolve(location);
+        HttpUrl url = userRequest.url().resolve(location);
 
         // Don't follow redirects to unsupported protocols.
         if (url == null) return null;
 
         // If configured, don't follow redirects between SSL and non-SSL.
-        boolean sameScheme = url.scheme().equals(userRequest.httpUrl().scheme());
-        if (!sameScheme && !client.getFollowSslRedirects()) return null;
+        boolean sameScheme = url.scheme().equals(userRequest.url().scheme());
+        if (!sameScheme && !client.followSslRedirects()) return null;
 
         // Redirects don't include a request body.
         Request.Builder requestBuilder = userRequest.newBuilder();
-        if (HttpMethod.permitsRequestBody(userRequest.method())) {
-          requestBuilder.method("GET", null);
+        if (HttpMethod.permitsRequestBody(method)) {
+          if (HttpMethod.redirectsToGet(method)) {
+            requestBuilder.method("GET", null);
+          } else {
+            requestBuilder.method(method, null);
+          }
           requestBuilder.removeHeader("Transfer-Encoding");
           requestBuilder.removeHeader("Content-Length");
           requestBuilder.removeHeader("Content-Type");
@@ -1109,17 +946,28 @@ public Request followUpRequest() throws IOException {
 
         return requestBuilder.url(url).build();
 
+      case HTTP_CLIENT_TIMEOUT:
+        // 408's are rare in practice, but some servers like HAProxy use this response code. The
+        // spec says that we may repeat the request without modifications. Modern browsers also
+        // repeat the request (even non-idempotent ones.)
+        boolean retryableBody = requestBodyOut == null || requestBodyOut instanceof RetryableSink;
+        if (callerWritesRequestBody && !retryableBody) {
+          return null;
+        }
+
+        return userRequest;
+
       default:
         return null;
     }
   }
 
   /**
-   * Returns true if an HTTP request for {@code followUp} can reuse the
-   * connection used by this engine.
+   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
+   * engine.
    */
   public boolean sameConnection(HttpUrl followUp) {
-    HttpUrl url = userRequest.httpUrl();
+    HttpUrl url = userRequest.url();
     return url.host().equals(followUp.host())
         && url.port() == followUp.port()
         && url.scheme().equals(followUp.scheme());
@@ -1130,14 +978,14 @@ private static Address createAddress(OkHttpClient client, Request request) {
     HostnameVerifier hostnameVerifier = null;
     CertificatePinner certificatePinner = null;
     if (request.isHttps()) {
-      sslSocketFactory = client.getSslSocketFactory();
-      hostnameVerifier = client.getHostnameVerifier();
-      certificatePinner = client.getCertificatePinner();
+      sslSocketFactory = client.sslSocketFactory();
+      hostnameVerifier = client.hostnameVerifier();
+      certificatePinner = client.certificatePinner();
     }
 
-    return new Address(request.httpUrl().host(), request.httpUrl().port(),
-        client.getSocketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
-        client.getAuthenticator(), client.getProxy(), client.getProtocols(),
-        client.getConnectionSpecs(), client.getProxySelector());
+    return new Address(request.url().host(), request.url().port(), client.dns(),
+        client.socketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
+        client.proxyAuthenticator(), client.proxy(), client.protocols(),
+        client.connectionSpecs(), client.proxySelector());
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
similarity index 55%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
rename to okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
index b5f2a48f86..3629810c0e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
@@ -13,25 +13,37 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
 public final class HttpMethod {
   public static boolean invalidatesCache(String method) {
     return method.equals("POST")
         || method.equals("PATCH")
         || method.equals("PUT")
-        || method.equals("DELETE");
+        || method.equals("DELETE")
+        || method.equals("MOVE");     // WebDAV
   }
 
   public static boolean requiresRequestBody(String method) {
     return method.equals("POST")
         || method.equals("PUT")
-        || method.equals("PATCH");
+        || method.equals("PATCH")
+        || method.equals("PROPPATCH") // WebDAV
+        || method.equals("REPORT");   // CalDAV/CardDAV (defined in WebDAV Versioning)
   }
 
   public static boolean permitsRequestBody(String method) {
     return requiresRequestBody(method)
-        || method.equals("DELETE"); // Permitted as spec is ambiguous.
+        || method.equals("OPTIONS")
+        || method.equals("DELETE")    // Permitted as spec is ambiguous.
+        || method.equals("PROPFIND")  // (WebDAV) without body: request <allprop/>
+        || method.equals("MKCOL")     // (WebDAV) may contain a body, but behaviour is unspecified
+        || method.equals("LOCK");     // (WebDAV) body: create lock, without body: refresh lock
+  }
+
+  public static boolean redirectsToGet(String method) {
+    // All requests but PROPFIND should redirect to a GET request.
+    return !method.equals("PROPFIND");
   }
 
   private HttpMethod() {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java b/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
similarity index 67%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
rename to okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
index 77f7c9e746..34c471345c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
@@ -13,20 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package okhttp3.internal.http;
 
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
 import okio.Sink;
 
-public interface Transport {
+public interface HttpStream {
   /**
-   * The timeout to use while discarding a stream of input data. Since this is
-   * used for connection reuse, this timeout should be significantly less than
-   * the time it takes to establish a new connection.
+   * The timeout to use while discarding a stream of input data. Since this is used for connection
+   * reuse, this timeout should be significantly less than the time it takes to establish a new
+   * connection.
    */
   int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
 
@@ -37,8 +36,7 @@
   void writeRequestHeaders(Request request) throws IOException;
 
   /**
-   * Sends the request body returned by {@link #createRequestBody} to the
-   * remote peer.
+   * Sends the request body returned by {@link #createRequestBody} to the remote peer.
    */
   void writeRequestBody(RetryableSink requestBody) throws IOException;
 
@@ -51,17 +49,11 @@
   /** Returns a stream that reads the response body. */
   ResponseBody openResponseBody(Response response) throws IOException;
 
-  /**
-   * Configures the response body to pool or close the socket connection when
-   * the response body is closed.
-   */
-  void releaseConnectionOnIdle() throws IOException;
-
-  void disconnect(HttpEngine engine) throws IOException;
+  void setHttpEngine(HttpEngine httpEngine);
 
   /**
-   * Returns true if the socket connection held by this transport can be reused
-   * for a follow-up exchange.
+   * Cancel this stream. Resources held by this stream will be cleaned up, though not synchronously.
+   * That may happen later by the connection pool thread.
    */
-  boolean canReuseConnection();
+  void cancel();
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java
similarity index 61%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
rename to okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java
index c381c47562..db8011c542 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/OkHeaders.java
@@ -1,41 +1,36 @@
-package com.squareup.okhttp.internal.http;
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
 
-import com.squareup.okhttp.Authenticator;
-import com.squareup.okhttp.Challenge;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.Platform;
-import java.io.IOException;
-import java.net.Proxy;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
-import java.util.TreeMap;
 import java.util.TreeSet;
+import okhttp3.Challenge;
+import okhttp3.Headers;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.Platform;
 
-import static com.squareup.okhttp.internal.Util.equal;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static okhttp3.internal.Util.equal;
 
 /** Headers and utilities for internal use by OkHttp. */
 public final class OkHeaders {
-  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
-    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
-    @Override public int compare(String a, String b) {
-      if (a == b) {
-        return 0;
-      } else if (a == null) {
-        return -1;
-      } else if (b == null) {
-        return 1;
-      } else {
-        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
-      }
-    }
-  };
 
   static final String PREFIX = Platform.get().getPrefix();
 
@@ -50,11 +45,14 @@
   public static final String RECEIVED_MILLIS = PREFIX + "-Received-Millis";
 
   /**
-   * Synthetic response header: the selected
-   * {@link com.squareup.okhttp.Protocol protocol} ("spdy/3.1", "http/1.1", etc).
+   * Synthetic response header: the selected {@link Protocol protocol} ("spdy/3.1", "http/1.1",
+   * etc).
    */
   public static final String SELECTED_PROTOCOL = PREFIX + "-Selected-Protocol";
 
+  /** Synthetic response header: the location from which the response was loaded. */
+  public static final String RESPONSE_SOURCE = PREFIX + "-Response-Source";
+
   private OkHeaders() {
   }
 
@@ -80,58 +78,8 @@ private static long stringToLong(String s) {
   }
 
   /**
-   * Returns an immutable map containing each field to its list of values.
-   *
-   * @param valueForNullKey the request line for requests, or the status line
-   *     for responses. If non-null, this value is mapped to the null key.
-   */
-  public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
-    Map<String, List<String>> result = new TreeMap<>(FIELD_NAME_COMPARATOR);
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      String fieldName = headers.name(i);
-      String value = headers.value(i);
-
-      List<String> allValues = new ArrayList<>();
-      List<String> otherValues = result.get(fieldName);
-      if (otherValues != null) {
-        allValues.addAll(otherValues);
-      }
-      allValues.add(value);
-      result.put(fieldName, Collections.unmodifiableList(allValues));
-    }
-    if (valueForNullKey != null) {
-      result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));
-    }
-    return Collections.unmodifiableMap(result);
-  }
-
-  public static void addCookies(Request.Builder builder, Map<String, List<String>> cookieHeaders) {
-    for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
-      String key = entry.getKey();
-      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
-          && !entry.getValue().isEmpty()) {
-        builder.addHeader(key, buildCookieHeader(entry.getValue()));
-      }
-    }
-  }
-
-  /**
-   * Send all cookies in one big header, as recommended by
-   * <a href="http://tools.ietf.org/html/rfc6265#section-4.2.1">RFC 6265</a>.
-   */
-  private static String buildCookieHeader(List<String> cookies) {
-    if (cookies.size() == 1) return cookies.get(0);
-    StringBuilder sb = new StringBuilder();
-    for (int i = 0, size = cookies.size(); i < size; i++) {
-      if (i > 0) sb.append("; ");
-      sb.append(cookies.get(i));
-    }
-    return sb.toString();
-  }
-
-  /**
-   * Returns true if none of the Vary headers have changed between {@code
-   * cachedRequest} and {@code newRequest}.
+   * Returns true if none of the Vary headers have changed between {@code cachedRequest} and {@code
+   * newRequest}.
    */
   public static boolean varyMatches(
       Response cachedResponse, Headers cachedRequest, Request newRequest) {
@@ -142,16 +90,14 @@ public static boolean varyMatches(
   }
 
   /**
-   * Returns true if a Vary header contains an asterisk. Such responses cannot
-   * be cached.
+   * Returns true if a Vary header contains an asterisk. Such responses cannot be cached.
    */
   public static boolean hasVaryAll(Response response) {
     return hasVaryAll(response.headers());
   }
 
   /**
-   * Returns true if a Vary header contains an asterisk. Such responses cannot
-   * be cached.
+   * Returns true if a Vary header contains an asterisk. Such responses cannot be cached.
    */
   public static boolean hasVaryAll(Headers responseHeaders) {
     return varyFields(responseHeaders).contains("*");
@@ -162,8 +108,7 @@ public static boolean hasVaryAll(Headers responseHeaders) {
   }
 
   /**
-   * Returns the names of the request headers that need to be checked for
-   * equality when caching.
+   * Returns the names of the request headers that need to be checked for equality when caching.
    */
   public static Set<String> varyFields(Headers responseHeaders) {
     Set<String> result = Collections.emptySet();
@@ -182,8 +127,8 @@ public static boolean hasVaryAll(Headers responseHeaders) {
   }
 
   /**
-   * Returns the subset of the headers in {@code response}'s request that
-   * impact the content of response's body.
+   * Returns the subset of the headers in {@code response}'s request that impact the content of
+   * response's body.
    */
   public static Headers varyHeaders(Response response) {
     // Use the request headers sent over the network, since that's what the
@@ -195,8 +140,8 @@ public static Headers varyHeaders(Response response) {
   }
 
   /**
-   * Returns the subset of the headers in {@code requestHeaders} that
-   * impact the content of response's body.
+   * Returns the subset of the headers in {@code requestHeaders} that impact the content of
+   * response's body.
    */
   public static Headers varyHeaders(Headers requestHeaders, Headers responseHeaders) {
     Set<String> varyFields = varyFields(responseHeaders);
@@ -213,8 +158,8 @@ public static Headers varyHeaders(Headers requestHeaders, Headers responseHeader
   }
 
   /**
-   * Returns true if {@code fieldName} is an end-to-end HTTP header, as
-   * defined by RFC 2616, 13.5.1.
+   * Returns true if {@code fieldName} is an end-to-end HTTP header, as defined by RFC 2616,
+   * 13.5.1.
    */
   static boolean isEndToEnd(String fieldName) {
     return !"Connection".equalsIgnoreCase(fieldName)
@@ -228,8 +173,7 @@ static boolean isEndToEnd(String fieldName) {
   }
 
   /**
-   * Parse RFC 2617 challenges. This API is only interested in the scheme
-   * name and realm.
+   * Parse RFC 2617 challenges. This API is only interested in the scheme name and realm.
    */
   public static List<Challenge> parseChallenges(Headers responseHeaders, String challengeHeader) {
     // auth-scheme = token
@@ -272,16 +216,4 @@ static boolean isEndToEnd(String fieldName) {
     }
     return result;
   }
-
-  /**
-   * React to a failed authorization response by looking up new credentials.
-   * Returns a request for a subsequent attempt, or null if no further attempts
-   * should be made.
-   */
-  public static Request processAuthHeader(Authenticator authenticator, Response response,
-      Proxy proxy) throws IOException {
-    return response.code() == HTTP_PROXY_AUTH
-        ? authenticator.authenticateProxy(proxy, response)
-        : authenticator.authenticate(proxy, response);
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RealResponseBody.java b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
similarity index 88%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/RealResponseBody.java
rename to okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
index 18d026f11a..d66fed988c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RealResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.ResponseBody;
+import okhttp3.Headers;
+import okhttp3.MediaType;
+import okhttp3.ResponseBody;
 import okio.BufferedSource;
 
 public final class RealResponseBody extends ResponseBody {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestException.java b/okhttp/src/main/java/okhttp3/internal/http/RequestException.java
similarity index 96%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestException.java
rename to okhttp/src/main/java/okhttp3/internal/http/RequestException.java
index 16893acdfb..56884c811f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestException.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RequestException.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
 import java.io.IOException;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
new file mode 100644
index 0000000000..c70a86934e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.net.HttpURLConnection;
+import java.net.Proxy;
+import okhttp3.HttpUrl;
+import okhttp3.Request;
+
+public final class RequestLine {
+  private RequestLine() {
+  }
+
+  /**
+   * Returns the request status line, like "GET / HTTP/1.1". This is exposed to the application by
+   * {@link HttpURLConnection#getHeaderFields}, so it needs to be set even if the transport is
+   * SPDY.
+   */
+  static String get(Request request, Proxy.Type proxyType) {
+    StringBuilder result = new StringBuilder();
+    result.append(request.method());
+    result.append(' ');
+
+    if (includeAuthorityInRequestLine(request, proxyType)) {
+      result.append(request.url());
+    } else {
+      result.append(requestPath(request.url()));
+    }
+
+    result.append(" HTTP/1.1");
+    return result.toString();
+  }
+
+  /**
+   * Returns true if the request line should contain the full URL with host and port (like "GET
+   * http://android.com/foo HTTP/1.1") or only the path (like "GET /foo HTTP/1.1").
+   */
+  private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type proxyType) {
+    return !request.isHttps() && proxyType == Proxy.Type.HTTP;
+  }
+
+  /**
+   * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty, even if the request
+   * URL is. Includes the query component if it exists.
+   */
+  public static String requestPath(HttpUrl url) {
+    String path = url.encodedPath();
+    String query = url.encodedQuery();
+    return query != null ? (path + '?' + query) : path;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java b/okhttp/src/main/java/okhttp3/internal/http/RetryableSink.java
similarity index 90%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
rename to okhttp/src/main/java/okhttp3/internal/http/RetryableSink.java
index 371769f66e..c0010d1898 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryableSink.java
@@ -13,8 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
 import java.io.IOException;
 import java.net.ProtocolException;
@@ -22,12 +21,11 @@
 import okio.Sink;
 import okio.Timeout;
 
-import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
+import static okhttp3.internal.Util.checkOffsetAndCount;
 
 /**
- * An HTTP request body that's completely buffered in memory. This allows
- * the post body to be transparently re-sent if the HTTP request must be
- * sent multiple times.
+ * An HTTP request body that's completely buffered in memory. This allows the post body to be
+ * transparently re-sent if the HTTP request must be sent multiple times.
  */
 public final class RetryableSink implements Sink {
   private boolean closed;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteException.java b/okhttp/src/main/java/okhttp3/internal/http/RouteException.java
similarity index 97%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteException.java
rename to okhttp/src/main/java/okhttp3/internal/http/RouteException.java
index 62b31751e9..030b346a5a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteException.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RouteException.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okhttp3.internal.http;
 
 import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
@@ -25,6 +25,7 @@
  */
 public final class RouteException extends Exception {
   private static final Method addSuppressedExceptionMethod;
+
   static {
     Method m;
     try {
@@ -34,6 +35,7 @@
     }
     addSuppressedExceptionMethod = m;
   }
+
   private IOException lastException;
 
   public RouteException(IOException cause) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java b/okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java
similarity index 78%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
rename to okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java
index b16bab3fd6..3b5725cbe6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RouteSelector.java
@@ -13,16 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Address;
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Route;
-import com.squareup.okhttp.internal.Internal;
-import com.squareup.okhttp.internal.Network;
-import com.squareup.okhttp.internal.RouteDatabase;
+package okhttp3.internal.http;
+
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -33,17 +25,17 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.NoSuchElementException;
+import okhttp3.Address;
+import okhttp3.HttpUrl;
+import okhttp3.Route;
+import okhttp3.internal.RouteDatabase;
 
 /**
- * Selects routes to connect to an origin server. Each connection requires a
- * choice of proxy server, IP address, and TLS mode. Connections may also be
- * recycled.
+ * Selects routes to connect to an origin server. Each connection requires a choice of proxy server,
+ * IP address, and TLS mode. Connections may also be recycled.
  */
 public final class RouteSelector {
   private final Address address;
-  private final HttpUrl url;
-  private final Network network;
-  private final OkHttpClient client;
   private final RouteDatabase routeDatabase;
 
   /* The most recently attempted route. */
@@ -61,24 +53,15 @@
   /* State for negotiating failed routes */
   private final List<Route> postponedRoutes = new ArrayList<>();
 
-  private RouteSelector(Address address, HttpUrl url, OkHttpClient client) {
+  public RouteSelector(Address address, RouteDatabase routeDatabase) {
     this.address = address;
-    this.url = url;
-    this.client = client;
-    this.routeDatabase = Internal.instance.routeDatabase(client);
-    this.network = Internal.instance.network(client);
-
-    resetNextProxy(url, address.getProxy());
-  }
+    this.routeDatabase = routeDatabase;
 
-  public static RouteSelector get(Address address, Request request, OkHttpClient client)
-      throws IOException {
-    return new RouteSelector(address, request.httpUrl(), client);
+    resetNextProxy(address.url(), address.proxy());
   }
 
   /**
-   * Returns true if there's another route to attempt. Every address has at
-   * least one route.
+   * Returns true if there's another route to attempt. Every address has at least one route.
    */
   public boolean hasNext() {
     return hasNextInetSocketAddress()
@@ -110,14 +93,14 @@ public Route next() throws IOException {
   }
 
   /**
-   * Clients should invoke this method when they encounter a connectivity
-   * failure on a connection returned by this route selector.
+   * Clients should invoke this method when they encounter a connectivity failure on a connection
+   * returned by this route selector.
    */
   public void connectFailed(Route failedRoute, IOException failure) {
-    if (failedRoute.getProxy().type() != Proxy.Type.DIRECT && address.getProxySelector() != null) {
+    if (failedRoute.proxy().type() != Proxy.Type.DIRECT && address.proxySelector() != null) {
       // Tell the proxy selector when we fail to connect on a fresh connection.
-      address.getProxySelector().connectFailed(
-          url.uri(), failedRoute.getProxy().address(), failure);
+      address.proxySelector().connectFailed(
+          address.url().uri(), failedRoute.proxy().address(), failure);
     }
 
     routeDatabase.failed(failedRoute);
@@ -132,7 +115,7 @@ private void resetNextProxy(HttpUrl url, Proxy proxy) {
       // Try each of the ProxySelector choices until one connection succeeds. If none succeed
       // then we'll try a direct connection below.
       proxies = new ArrayList<>();
-      List<Proxy> selectedProxies = client.getProxySelector().select(url.uri());
+      List<Proxy> selectedProxies = address.proxySelector().select(url.uri());
       if (selectedProxies != null) proxies.addAll(selectedProxies);
       // Finally try a direct connection. We only try it once!
       proxies.removeAll(Collections.singleton(Proxy.NO_PROXY));
@@ -149,7 +132,7 @@ private boolean hasNextProxy() {
   /** Returns the next proxy to try. May be PROXY.NO_PROXY but never null. */
   private Proxy nextProxy() throws IOException {
     if (!hasNextProxy()) {
-      throw new SocketException("No route to " + address.getUriHost()
+      throw new SocketException("No route to " + address.url().host()
           + "; exhausted proxy configurations: " + proxies);
     }
     Proxy result = proxies.get(nextProxyIndex++);
@@ -165,8 +148,8 @@ private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
     String socketHost;
     int socketPort;
     if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) {
-      socketHost = address.getUriHost();
-      socketPort = address.getUriPort();
+      socketHost = address.url().host();
+      socketPort = address.url().port();
     } else {
       SocketAddress proxyAddress = proxy.address();
       if (!(proxyAddress instanceof InetSocketAddress)) {
@@ -183,9 +166,15 @@ private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
           + "; port is out of range");
     }
 
-    // Try each address for best behavior in mixed IPv4/IPv6 environments.
-    for (InetAddress inetAddress : network.resolveInetAddresses(socketHost)) {
-      inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
+    if (proxy.type() == Proxy.Type.SOCKS) {
+      inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));
+    } else {
+      // Try each address for best behavior in mixed IPv4/IPv6 environments.
+      List<InetAddress> addresses = address.dns().lookup(socketHost);
+      for (int i = 0, size = addresses.size(); i < size; i++) {
+        InetAddress inetAddress = addresses.get(i);
+        inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
+      }
     }
 
     nextInetSocketAddressIndex = 0;
@@ -217,7 +206,7 @@ private boolean hasNextInetSocketAddress() {
   /** Returns the next socket address to try. */
   private InetSocketAddress nextInetSocketAddress() throws IOException {
     if (!hasNextInetSocketAddress()) {
-      throw new SocketException("No route to " + address.getUriHost()
+      throw new SocketException("No route to " + address.url().host()
           + "; exhausted inet socket addresses: " + inetSocketAddresses);
     }
     return inetSocketAddresses.get(nextInetSocketAddressIndex++);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java b/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java
similarity index 81%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
rename to okhttp/src/main/java/okhttp3/internal/http/StatusLine.java
index ab9ebc1535..f3591a6bf9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java
@@ -1,9 +1,24 @@
-package com.squareup.okhttp.internal.http;
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
 
-import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.net.ProtocolException;
+import okhttp3.Protocol;
+import okhttp3.Response;
 
 /** An HTTP response status line like "HTTP/1.1 200 OK". */
 public final class StatusLine {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
new file mode 100644
index 0000000000..385dc2b2ac
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
@@ -0,0 +1,362 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.lang.ref.Reference;
+import java.lang.ref.WeakReference;
+import java.net.ProtocolException;
+import java.net.SocketTimeoutException;
+import java.security.cert.CertificateException;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.Address;
+import okhttp3.ConnectionPool;
+import okhttp3.Route;
+import okhttp3.internal.Internal;
+import okhttp3.internal.RouteDatabase;
+import okhttp3.internal.Util;
+import okhttp3.internal.io.RealConnection;
+import okio.Sink;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+/**
+ * This class coordinates the relationship between three entities:
+ *
+ * <ul>
+ *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are
+ *         potentially slow to establish so it is necessary to be able to cancel a connection
+ *         currently being connected.
+ *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
+ *         connections. Each connection has its own allocation limit, which defines how many
+ *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
+ *         at a time, SPDY and HTTP/2 typically carry multiple.
+ *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
+ *         its follow up requests. We prefer to keep all streams of a single call on the same
+ *         connection for better behavior and locality.
+ * </ul>
+ *
+ * <p>Instances of this class act on behalf of the call, using one or more streams over one or more
+ * connections. This class has APIs to release each of the above resources:
+ *
+ * <ul>
+ *     <li>{@link #noNewStreams()} prevents the connection from being used for new streams in the
+ *         future. Use this after a {@code Connection: close} header, or when the connection may be
+ *         inconsistent.
+ *     <li>{@link #streamFinished streamFinished()} releases the active stream from this allocation.
+ *         Note that only one stream may be active at a given time, so it is necessary to call
+ *         {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
+ *         #newStream newStream()}.
+ *     <li>{@link #release()} removes the call's hold on the connection. Note that this won't
+ *         immediately free the connection if there is a stream still lingering. That happens when a
+ *         call is complete but its response body has yet to be fully consumed.
+ * </ul>
+ *
+ * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
+ * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
+ * but not the other streams sharing its connection. But if the TLS handshake is still in progress
+ * then canceling may break the entire connection.
+ */
+public final class StreamAllocation {
+  public final Address address;
+  private Route route;
+  private final ConnectionPool connectionPool;
+
+  // State guarded by connectionPool.
+  private RouteSelector routeSelector;
+  private RealConnection connection;
+  private boolean released;
+  private boolean canceled;
+  private HttpStream stream;
+
+  public StreamAllocation(ConnectionPool connectionPool, Address address) {
+    this.connectionPool = connectionPool;
+    this.address = address;
+    this.routeSelector = new RouteSelector(address, routeDatabase());
+  }
+
+  public HttpStream newStream(int connectTimeout, int readTimeout, int writeTimeout,
+      boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
+      throws RouteException, IOException {
+    try {
+      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
+          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
+
+      HttpStream resultStream;
+      if (resultConnection.framedConnection != null) {
+        resultStream = new Http2xStream(this, resultConnection.framedConnection);
+      } else {
+        resultConnection.socket().setSoTimeout(readTimeout);
+        resultConnection.source.timeout().timeout(readTimeout, MILLISECONDS);
+        resultConnection.sink.timeout().timeout(writeTimeout, MILLISECONDS);
+        resultStream = new Http1xStream(this, resultConnection.source, resultConnection.sink);
+      }
+
+      synchronized (connectionPool) {
+        stream = resultStream;
+        return resultStream;
+      }
+    } catch (IOException e) {
+      throw new RouteException(e);
+    }
+  }
+
+  /**
+   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
+   * until a healthy connection is found.
+   */
+  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
+      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
+      throws IOException, RouteException {
+    while (true) {
+      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
+          connectionRetryEnabled);
+
+      // If this is a brand new connection, we can skip the extensive health checks.
+      synchronized (connectionPool) {
+        if (candidate.successCount == 0) {
+          return candidate;
+        }
+      }
+
+      // Otherwise do a potentially-slow check to confirm that the pooled connection is still good.
+      if (candidate.isHealthy(doExtensiveHealthChecks)) {
+        return candidate;
+      }
+
+      connectionFailed(new IOException());
+    }
+  }
+
+  /**
+   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
+   * then the pool, finally building a new connection.
+   */
+  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
+      boolean connectionRetryEnabled) throws IOException, RouteException {
+    Route selectedRoute;
+    synchronized (connectionPool) {
+      if (released) throw new IllegalStateException("released");
+      if (stream != null) throw new IllegalStateException("stream != null");
+      if (canceled) throw new IOException("Canceled");
+
+      RealConnection allocatedConnection = this.connection;
+      if (allocatedConnection != null && !allocatedConnection.noNewStreams) {
+        return allocatedConnection;
+      }
+
+      // Attempt to get a connection from the pool.
+      RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);
+      if (pooledConnection != null) {
+        this.connection = pooledConnection;
+        return pooledConnection;
+      }
+
+      selectedRoute = route;
+    }
+
+    if (selectedRoute == null) {
+      selectedRoute = routeSelector.next();
+      synchronized (connectionPool) {
+        route = selectedRoute;
+      }
+    }
+    RealConnection newConnection = new RealConnection(selectedRoute);
+    acquire(newConnection);
+
+    synchronized (connectionPool) {
+      Internal.instance.put(connectionPool, newConnection);
+      this.connection = newConnection;
+      if (canceled) throw new IOException("Canceled");
+    }
+
+    newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),
+        connectionRetryEnabled);
+    routeDatabase().connected(newConnection.route());
+
+    return newConnection;
+  }
+
+  public void streamFinished(boolean noNewStreams, HttpStream stream) {
+    synchronized (connectionPool) {
+      if (stream == null || stream != this.stream) {
+        throw new IllegalStateException("expected " + this.stream + " but was " + stream);
+      }
+      if (!noNewStreams) {
+        connection.successCount++;
+      }
+    }
+    deallocate(noNewStreams, false, true);
+  }
+
+  public HttpStream stream() {
+    synchronized (connectionPool) {
+      return stream;
+    }
+  }
+
+  private RouteDatabase routeDatabase() {
+    return Internal.instance.routeDatabase(connectionPool);
+  }
+
+  public synchronized RealConnection connection() {
+    return connection;
+  }
+
+  public void release() {
+    deallocate(false, true, false);
+  }
+
+  /** Forbid new streams from being created on the connection that hosts this allocation. */
+  public void noNewStreams() {
+    deallocate(true, false, false);
+  }
+
+  /**
+   * Releases resources held by this allocation. If sufficient resources are allocated, the
+   * connection will be detached or closed.
+   */
+  private void deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
+    RealConnection connectionToClose = null;
+    synchronized (connectionPool) {
+      if (streamFinished) {
+        this.stream = null;
+      }
+      if (released) {
+        this.released = true;
+      }
+      if (connection != null) {
+        if (noNewStreams) {
+          connection.noNewStreams = true;
+        }
+        if (this.stream == null && (this.released || connection.noNewStreams)) {
+          release(connection);
+          if (connection.allocations.isEmpty()) {
+            connection.idleAtNanos = System.nanoTime();
+            if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
+              connectionToClose = connection;
+            }
+          }
+          connection = null;
+        }
+      }
+    }
+    if (connectionToClose != null) {
+      Util.closeQuietly(connectionToClose.socket());
+    }
+  }
+
+  public void cancel() {
+    HttpStream streamToCancel;
+    RealConnection connectionToCancel;
+    synchronized (connectionPool) {
+      canceled = true;
+      streamToCancel = stream;
+      connectionToCancel = connection;
+    }
+    if (streamToCancel != null) {
+      streamToCancel.cancel();
+    } else if (connectionToCancel != null) {
+      connectionToCancel.cancel();
+    }
+  }
+
+  public void connectionFailed(IOException e) {
+    synchronized (connectionPool) {
+      // Avoid this route if it's never seen a successful call.
+      if (connection != null && connection.successCount == 0) {
+        if (route != null && e != null) {
+          routeSelector.connectFailed(route, e);
+        }
+        route = null;
+      }
+    }
+    deallocate(true, false, true);
+  }
+
+  /**
+   * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
+   * {@link #release} on the same connection.
+   */
+  public void acquire(RealConnection connection) {
+    connection.allocations.add(new WeakReference<>(this));
+  }
+
+  /** Remove this allocation from the connection's list of allocations. */
+  private void release(RealConnection connection) {
+    for (int i = 0, size = connection.allocations.size(); i < size; i++) {
+      Reference<StreamAllocation> reference = connection.allocations.get(i);
+      if (reference.get() == this) {
+        connection.allocations.remove(i);
+        return;
+      }
+    }
+    throw new IllegalStateException();
+  }
+
+  public boolean recover(IOException e, boolean routeException, Sink requestBodyOut) {
+    if (connection != null) {
+      connectionFailed(e);
+    }
+
+    boolean canRetryRequestBody = requestBodyOut == null || requestBodyOut instanceof RetryableSink;
+    if ((routeSelector != null && !routeSelector.hasNext()) // No more routes to attempt.
+        || !isRecoverable(e, routeException)
+        || !canRetryRequestBody) {
+      return false;
+    }
+
+    return true;
+  }
+
+  private boolean isRecoverable(IOException e, boolean routeException) {
+    // If there was a protocol problem, don't recover.
+    if (e instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption don't recover, but if there was a timeout connecting to a route
+    // we should try the next route (if there is one).
+    if (e instanceof InterruptedIOException) {
+      return e instanceof SocketTimeoutException && routeException;
+    }
+
+    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+    // again with a different route.
+    if (e instanceof SSLHandshakeException) {
+      // If the problem was a CertificateException from the X509TrustManager,
+      // do not retry.
+      if (e.getCause() instanceof CertificateException) {
+        return false;
+      }
+    }
+    if (e instanceof SSLPeerUnverifiedException) {
+      // e.g. a certificate pinning error.
+      return false;
+    }
+
+    // An example of one we might want to retry with a different route is a problem connecting to a
+    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
+    // retry, we return true and try a new route.
+    return true;
+  }
+
+  @Override public String toString() {
+    return address.toString();
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
similarity index 93%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java
rename to okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
index 74245997a5..0b1b1cfbc4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/io/FileSystem.java
+++ b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.io;
+package okhttp3.internal.io;
 
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -28,9 +28,9 @@
  * implementations may be used to inject faults (for testing) or to transform stored data (to add
  * encryption, for example).
  *
- * <p>All operations on a file system are racy. For example, guarding a call to {@link #source}
- * with {@link #exists} does not guarantee that {@link FileNotFoundException} will not be thrown.
- * The file may be moved between the two calls!
+ * <p>All operations on a file system are racy. For example, guarding a call to {@link #source} with
+ * {@link #exists} does not guarantee that {@link FileNotFoundException} will not be thrown. The
+ * file may be moved between the two calls!
  *
  * <p>This interface is less ambitious than {@link java.nio.file.FileSystem} introduced in Java 7.
  * It lacks important features like file watching, metadata, permissions, and disk space
@@ -71,7 +71,7 @@
       }
     }
 
-    @Override public boolean exists(File file) throws IOException {
+    @Override public boolean exists(File file) {
       return file.exists();
     }
 
@@ -121,7 +121,7 @@
   void delete(File file) throws IOException;
 
   /** Returns true if {@code file} exists on the file system. */
-  boolean exists(File file) throws IOException;
+  boolean exists(File file);
 
   /** Returns the number of bytes stored in {@code file}, or 0 if it does not exist. */
   long size(File file);
diff --git a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
new file mode 100644
index 0000000000..ef6e8f84d9
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
@@ -0,0 +1,439 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.io;
+
+import java.io.IOException;
+import java.lang.ref.Reference;
+import java.net.ConnectException;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.Socket;
+import java.net.SocketTimeoutException;
+import java.net.UnknownServiceException;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Address;
+import okhttp3.CertificatePinner;
+import okhttp3.Connection;
+import okhttp3.ConnectionSpec;
+import okhttp3.Handshake;
+import okhttp3.HttpUrl;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.Route;
+import okhttp3.internal.ConnectionSpecSelector;
+import okhttp3.internal.Platform;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.internal.framed.ErrorCode;
+import okhttp3.internal.framed.FramedConnection;
+import okhttp3.internal.framed.FramedStream;
+import okhttp3.internal.http.Http1xStream;
+import okhttp3.internal.http.OkHeaders;
+import okhttp3.internal.http.RouteException;
+import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.tls.OkHostnameVerifier;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Source;
+
+import static java.net.HttpURLConnection.HTTP_OK;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.closeQuietly;
+
+public final class RealConnection extends FramedConnection.Listener implements Connection {
+  private final Route route;
+
+  /** The low-level TCP socket. */
+  private Socket rawSocket;
+
+  /**
+   * The application layer socket. Either an {@link SSLSocket} layered over {@link #rawSocket}, or
+   * {@link #rawSocket} itself if this connection does not use SSL.
+   */
+  public Socket socket;
+  private Handshake handshake;
+  private Protocol protocol;
+  public volatile FramedConnection framedConnection;
+  public int successCount;
+  public BufferedSource source;
+  public BufferedSink sink;
+  public int allocationLimit;
+  public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();
+  public boolean noNewStreams;
+  public long idleAtNanos = Long.MAX_VALUE;
+
+  public RealConnection(Route route) {
+    this.route = route;
+  }
+
+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,
+      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) throws RouteException {
+    if (protocol != null) throw new IllegalStateException("already connected");
+
+    RouteException routeException = null;
+    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
+
+    if (route.address().sslSocketFactory() == null
+        && !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
+      throw new RouteException(new UnknownServiceException(
+          "CLEARTEXT communication not supported: " + connectionSpecs));
+    }
+
+    while (protocol == null) {
+      try {
+        if (route.requiresTunnel()) {
+          buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,
+              connectionSpecSelector);
+        } else {
+          buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
+        }
+      } catch (IOException e) {
+        closeQuietly(socket);
+        closeQuietly(rawSocket);
+        socket = null;
+        rawSocket = null;
+        source = null;
+        sink = null;
+        handshake = null;
+        protocol = null;
+
+        if (routeException == null) {
+          routeException = new RouteException(e);
+        } else {
+          routeException.addConnectException(e);
+        }
+
+        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {
+          throw routeException;
+        }
+      }
+    }
+  }
+
+  /**
+   * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
+   * proxy server can issue an auth challenge and then close the connection.
+   */
+  private void buildTunneledConnection(int connectTimeout, int readTimeout, int writeTimeout,
+      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+    Request tunnelRequest = createTunnelRequest();
+    HttpUrl url = tunnelRequest.url();
+    int attemptedConnections = 0;
+    int maxAttempts = 21;
+    while (true) {
+      if (++attemptedConnections > maxAttempts) {
+        throw new ProtocolException("Too many tunnel connections attempted: " + maxAttempts);
+      }
+
+      connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
+      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
+
+      if (tunnelRequest == null) break; // Tunnel successfully created.
+
+      // The proxy decided to close the connection after an auth challenge. We need to create a new
+      // connection, but this time with the auth credentials.
+      closeQuietly(rawSocket);
+      rawSocket = null;
+      sink = null;
+      source = null;
+    }
+
+    establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);
+  }
+
+  /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
+  private void buildConnection(int connectTimeout, int readTimeout, int writeTimeout,
+      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+    connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
+    establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);
+  }
+
+  private void connectSocket(int connectTimeout, int readTimeout, int writeTimeout,
+      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+    Proxy proxy = route.proxy();
+    Address address = route.address();
+
+    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP
+        ? address.socketFactory().createSocket()
+        : new Socket(proxy);
+
+    rawSocket.setSoTimeout(readTimeout);
+    try {
+      Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
+    } catch (ConnectException e) {
+      throw new ConnectException("Failed to connect to " + route.socketAddress());
+    }
+    source = Okio.buffer(Okio.source(rawSocket));
+    sink = Okio.buffer(Okio.sink(rawSocket));
+  }
+
+  private void establishProtocol(int readTimeout, int writeTimeout,
+      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+    if (route.address().sslSocketFactory() != null) {
+      connectTls(readTimeout, writeTimeout, connectionSpecSelector);
+    } else {
+      protocol = Protocol.HTTP_1_1;
+      socket = rawSocket;
+    }
+
+    if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
+      socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.
+
+      FramedConnection framedConnection = new FramedConnection.Builder(true)
+          .socket(socket, route.address().url().host(), source, sink)
+          .protocol(protocol)
+          .listener(this)
+          .build();
+      framedConnection.start();
+
+      // Only assign the framed connection once the preface has been sent successfully.
+      this.allocationLimit = framedConnection.maxConcurrentStreams();
+      this.framedConnection = framedConnection;
+    } else {
+      this.allocationLimit = 1;
+    }
+  }
+
+  private void connectTls(int readTimeout, int writeTimeout,
+      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+    Address address = route.address();
+    SSLSocketFactory sslSocketFactory = address.sslSocketFactory();
+    boolean success = false;
+    SSLSocket sslSocket = null;
+    try {
+      // Create the wrapper over the connected socket.
+      sslSocket = (SSLSocket) sslSocketFactory.createSocket(
+          rawSocket, address.url().host(), address.url().port(), true /* autoClose */);
+
+      // Configure the socket's ciphers, TLS versions, and extensions.
+      ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
+      if (connectionSpec.supportsTlsExtensions()) {
+        Platform.get().configureTlsExtensions(
+            sslSocket, address.url().host(), address.protocols());
+      }
+
+      // Force handshake. This can throw!
+      sslSocket.startHandshake();
+      Handshake unverifiedHandshake = Handshake.get(sslSocket.getSession());
+
+      // Verify that the socket's certificates are acceptable for the target host.
+      if (!address.hostnameVerifier().verify(address.url().host(), sslSocket.getSession())) {
+        X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0);
+        throw new SSLPeerUnverifiedException("Hostname " + address.url().host() + " not verified:"
+            + "\n    certificate: " + CertificatePinner.pin(cert)
+            + "\n    DN: " + cert.getSubjectDN().getName()
+            + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
+      }
+
+      // Check that the certificate pinner is satisfied by the certificates presented.
+      address.certificatePinner().check(address.url().host(),
+          unverifiedHandshake.peerCertificates());
+
+      // Success! Save the handshake and the ALPN protocol.
+      String maybeProtocol = connectionSpec.supportsTlsExtensions()
+          ? Platform.get().getSelectedProtocol(sslSocket)
+          : null;
+      socket = sslSocket;
+      source = Okio.buffer(Okio.source(socket));
+      sink = Okio.buffer(Okio.sink(socket));
+      handshake = unverifiedHandshake;
+      protocol = maybeProtocol != null
+          ? Protocol.get(maybeProtocol)
+          : Protocol.HTTP_1_1;
+      success = true;
+    } catch (AssertionError e) {
+      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
+      throw e;
+    } finally {
+      if (sslSocket != null) {
+        Platform.get().afterHandshake(sslSocket);
+      }
+      if (!success) {
+        closeQuietly(sslSocket);
+      }
+    }
+  }
+
+  /**
+   * To make an HTTPS connection over an HTTP proxy, send an unencrypted CONNECT request to create
+   * the proxy connection. This may need to be retried if the proxy requires authorization.
+   */
+  private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRequest,
+      HttpUrl url) throws IOException {
+    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
+    String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
+    while (true) {
+      Http1xStream tunnelConnection = new Http1xStream(null, source, sink);
+      source.timeout().timeout(readTimeout, MILLISECONDS);
+      sink.timeout().timeout(writeTimeout, MILLISECONDS);
+      tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
+      tunnelConnection.finishRequest();
+      Response response = tunnelConnection.readResponse().request(tunnelRequest).build();
+      // The response body from a CONNECT should be empty, but if it is not then we should consume
+      // it before proceeding.
+      long contentLength = OkHeaders.contentLength(response);
+      if (contentLength == -1L) {
+        contentLength = 0L;
+      }
+      Source body = tunnelConnection.newFixedLengthSource(contentLength);
+      Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
+      body.close();
+
+      switch (response.code()) {
+        case HTTP_OK:
+          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
+          // that happens, then we will have buffered bytes that are needed by the SSLSocket!
+          // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
+          // that it will almost certainly fail because the proxy has sent unexpected data.
+          if (!source.buffer().exhausted() || !sink.buffer().exhausted()) {
+            throw new IOException("TLS tunnel buffered too many bytes!");
+          }
+          return null;
+
+        case HTTP_PROXY_AUTH:
+          tunnelRequest = route.address().proxyAuthenticator().authenticate(route, response);
+          if (tunnelRequest == null) throw new IOException("Failed to authenticate with proxy");
+
+          if ("close".equalsIgnoreCase(response.header("Connection"))) {
+            return tunnelRequest;
+          }
+          break;
+
+        default:
+          throw new IOException(
+              "Unexpected response code for CONNECT: " + response.code());
+      }
+    }
+  }
+
+  /**
+   * Returns a request that creates a TLS tunnel via an HTTP proxy. Everything in the tunnel request
+   * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
+   * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
+   */
+  private Request createTunnelRequest() throws IOException {
+    return new Request.Builder()
+        .url(route.address().url())
+        .header("Host", Util.hostHeader(route.address().url(), true))
+        .header("Proxy-Connection", "Keep-Alive")
+        .header("User-Agent", Version.userAgent()) // For HTTP/1.0 proxies like Squid.
+        .build();
+  }
+
+  /** Returns true if {@link #connect} has been attempted on this connection. */
+  boolean isConnected() {
+    return protocol != null;
+  }
+
+  @Override public Route route() {
+    return route;
+  }
+
+  public void cancel() {
+    // Close the raw socket so we don't end up doing synchronous I/O.
+    closeQuietly(rawSocket);
+  }
+
+  @Override public Socket socket() {
+    return socket;
+  }
+
+  /** Returns true if this connection is ready to host new streams. */
+  public boolean isHealthy(boolean doExtensiveChecks) {
+    if (socket.isClosed() || socket.isInputShutdown() || socket.isOutputShutdown()) {
+      return false;
+    }
+
+    if (framedConnection != null) {
+      return true; // TODO: check framedConnection.shutdown.
+    }
+
+    if (doExtensiveChecks) {
+      try {
+        int readTimeout = socket.getSoTimeout();
+        try {
+          socket.setSoTimeout(1);
+          if (source.exhausted()) {
+            return false; // Stream is exhausted; socket is closed.
+          }
+          return true;
+        } finally {
+          socket.setSoTimeout(readTimeout);
+        }
+      } catch (SocketTimeoutException ignored) {
+        // Read timed out; socket is good.
+      } catch (IOException e) {
+        return false; // Couldn't read; socket is closed.
+      }
+    }
+
+    return true;
+  }
+
+  /** Refuse incoming streams. */
+  @Override public void onStream(FramedStream stream) throws IOException {
+    stream.close(ErrorCode.REFUSED_STREAM);
+  }
+
+  /** When settings are received, adjust the allocation limit. */
+  @Override public void onSettings(FramedConnection connection) {
+    allocationLimit = connection.maxConcurrentStreams();
+  }
+
+  @Override public Handshake handshake() {
+    return handshake;
+  }
+
+  /**
+   * Returns true if this is a SPDY connection. Such connections can be used in multiple HTTP
+   * requests simultaneously.
+   */
+  public boolean isMultiplexed() {
+    return framedConnection != null;
+  }
+
+  @Override public Protocol protocol() {
+    if (framedConnection == null) {
+      return protocol != null ? protocol : Protocol.HTTP_1_1;
+    } else {
+      return framedConnection.getProtocol();
+    }
+  }
+
+  @Override public String toString() {
+    return "Connection{"
+        + route.address().url().host() + ":" + route.address().url().port()
+        + ", proxy="
+        + route.proxy()
+        + " hostAddress="
+        + route.socketAddress()
+        + " cipherSuite="
+        + (handshake != null ? handshake.cipherSuite() : "none")
+        + " protocol="
+        + protocol
+        + '}';
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
new file mode 100644
index 0000000000..672e48651b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
@@ -0,0 +1,181 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.security.GeneralSecurityException;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.X509TrustManager;
+
+/**
+ * Computes the effective certificate chain from the raw array returned by Java's built in TLS APIs.
+ * Cleaning a chain returns a list of certificates where the first element is {@code chain[0]}, each
+ * certificate is signed by the certificate that follows, and the last certificate is a trusted CA
+ * certificate.
+ *
+ * <p>Use of the chain cleaner is necessary to omit unexpected certificates that aren't relevant to
+ * the TLS handshake and to extract the trusted CA certificate for the benefit of certificate
+ * pinning.
+ */
+public abstract class CertificateChainCleaner {
+  public abstract List<Certificate> clean(List<Certificate> chain, String hostname)
+      throws SSLPeerUnverifiedException;
+
+  public static CertificateChainCleaner get(X509TrustManager trustManager) {
+    try {
+      Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");
+      Constructor<?> constructor = extensionsClass.getConstructor(X509TrustManager.class);
+      Object extensions = constructor.newInstance(trustManager);
+      Method checkServerTrusted = extensionsClass.getMethod(
+          "checkServerTrusted", X509Certificate[].class, String.class, String.class);
+      return new AndroidCertificateChainCleaner(extensions, checkServerTrusted);
+    } catch (Exception e) {
+      return new BasicCertificateChainCleaner(TrustRootIndex.get(trustManager));
+    }
+  }
+
+  public static CertificateChainCleaner get(X509Certificate... caCerts) {
+    return new BasicCertificateChainCleaner(TrustRootIndex.get(caCerts));
+  }
+
+  /**
+   * A certificate chain cleaner that uses a set of trusted root certificates to build the trusted
+   * chain. This class duplicates the clean chain building performed during the TLS handshake. We
+   * prefer other mechanisms where they exist, such as with {@link AndroidCertificateChainCleaner}.
+   *
+   * <p>This class includes code from <a href="https://conscrypt.org/">Conscrypt's</a> {@code
+   * TrustManagerImpl} and {@code TrustedCertificateIndex}.
+   */
+  static final class BasicCertificateChainCleaner extends CertificateChainCleaner {
+    /** The maximum number of signers in a chain. We use 9 for consistency with OpenSSL. */
+    private static final int MAX_SIGNERS = 9;
+
+    private final TrustRootIndex trustRootIndex;
+
+    public BasicCertificateChainCleaner(TrustRootIndex trustRootIndex) {
+      this.trustRootIndex = trustRootIndex;
+    }
+
+    /**
+     * Returns a cleaned chain for {@code chain}.
+     *
+     * <p>This method throws if the complete chain to a trusted CA certificate cannot be
+     * constructed. This is unexpected unless the trust root index in this class has a different
+     * trust manager than what was used to establish {@code chain}.
+     */
+    @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
+        throws SSLPeerUnverifiedException {
+      Deque<Certificate> queue = new ArrayDeque<>(chain);
+      List<Certificate> result = new ArrayList<>();
+      result.add(queue.removeFirst());
+      boolean foundTrustedCertificate = false;
+
+      followIssuerChain:
+      for (int c = 0; c < MAX_SIGNERS; c++) {
+        X509Certificate toVerify = (X509Certificate) result.get(result.size() - 1);
+
+        // If this cert has been signed by a trusted cert, use that. Add the trusted certificate to
+        // the end of the chain unless it's already present. (That would happen if the first
+        // certificate in the chain is itself a self-signed and trusted CA certificate.)
+        X509Certificate trustedCert = trustRootIndex.findByIssuerAndSignature(toVerify);
+        if (trustedCert != null) {
+          if (result.size() > 1 || !toVerify.equals(trustedCert)) {
+            result.add(trustedCert);
+          }
+          if (verifySignature(trustedCert, trustedCert)) {
+            return result; // The self-signed cert is a root CA. We're done.
+          }
+          foundTrustedCertificate = true;
+          continue;
+        }
+
+        // Search for the certificate in the chain that signed this certificate. This is typically
+        // the next element in the chain, but it could be any element.
+        for (Iterator<Certificate> i = queue.iterator(); i.hasNext(); ) {
+          X509Certificate signingCert = (X509Certificate) i.next();
+          if (verifySignature(toVerify, signingCert)) {
+            i.remove();
+            result.add(signingCert);
+            continue followIssuerChain;
+          }
+        }
+
+        // We've reached the end of the chain. If any cert in the chain is trusted, we're done.
+        if (foundTrustedCertificate) {
+          return result;
+        }
+
+        // The last link isn't trusted. Fail.
+        throw new SSLPeerUnverifiedException(
+            "Failed to find a trusted cert that signed " + toVerify);
+      }
+
+      throw new SSLPeerUnverifiedException("Certificate chain too long: " + result);
+    }
+
+    /** Returns true if {@code toVerify} was signed by {@code signingCert}'s public key. */
+    private boolean verifySignature(X509Certificate toVerify, X509Certificate signingCert) {
+      if (!toVerify.getIssuerDN().equals(signingCert.getSubjectDN())) return false;
+      try {
+        toVerify.verify(signingCert.getPublicKey());
+        return true;
+      } catch (GeneralSecurityException verifyFailed) {
+        return false;
+      }
+    }
+  }
+
+  /**
+   * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
+   * This is the best way to get a clean chain on Android because it uses the same code as the TLS
+   * handshake.
+   */
+  static final class AndroidCertificateChainCleaner extends CertificateChainCleaner {
+    private final Object x509TrustManagerExtensions;
+    private final Method checkServerTrusted;
+
+    AndroidCertificateChainCleaner(Object x509TrustManagerExtensions, Method checkServerTrusted) {
+      this.x509TrustManagerExtensions = x509TrustManagerExtensions;
+      this.checkServerTrusted = checkServerTrusted;
+    }
+
+    @SuppressWarnings({"unchecked", "SuspiciousToArrayCall"}) // Reflection on List<Certificate>.
+    @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
+        throws SSLPeerUnverifiedException {
+      try {
+        X509Certificate[] certificates = chain.toArray(new X509Certificate[chain.size()]);
+        return (List<Certificate>) checkServerTrusted.invoke(
+            x509TrustManagerExtensions, certificates, "RSA", hostname);
+      } catch (InvocationTargetException e) {
+        SSLPeerUnverifiedException exception = new SSLPeerUnverifiedException(e.getMessage());
+        exception.initCause(e);
+        throw exception;
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/DistinguishedNameParser.java b/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
similarity index 98%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/tls/DistinguishedNameParser.java
rename to okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
index e0aef14916..616bca534a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/DistinguishedNameParser.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
@@ -14,14 +14,13 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
-package com.squareup.okhttp.internal.tls;
+package okhttp3.internal.tls;
 
 import javax.security.auth.x500.X500Principal;
 
 /**
- * A distinguished name (DN) parser. This parser only supports extracting a
- * string value from a DN. It doesn't support values in the hex-string style.
+ * A distinguished name (DN) parser. This parser only supports extracting a string value from a DN.
+ * It doesn't support values in the hex-string style.
  */
 final class DistinguishedNameParser {
   private final String dn;
@@ -341,8 +340,8 @@ private int getByte(int position) {
   }
 
   /**
-   * Parses the DN and returns the most significant attribute value
-   * for an attribute type, or null if none found.
+   * Parses the DN and returns the most significant attribute value for an attribute type, or null
+   * if none found.
    *
    * @param attributeType attribute type to look for (e.g. "ca")
    */
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
similarity index 71%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
rename to okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
index 740de1bcdf..a85df784d7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
@@ -14,8 +14,7 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-
-package com.squareup.okhttp.internal.tls;
+package okhttp3.internal.tls;
 
 import java.security.cert.Certificate;
 import java.security.cert.CertificateParsingException;
@@ -25,33 +24,19 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
-import java.util.regex.Pattern;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLSession;
 import javax.security.auth.x500.X500Principal;
 
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
 /**
- * A HostnameVerifier consistent with <a
- * href="http://www.ietf.org/rfc/rfc2818.txt">RFC 2818</a>.
+ * A HostnameVerifier consistent with <a href="http://www.ietf.org/rfc/rfc2818.txt">RFC 2818</a>.
  */
 public final class OkHostnameVerifier implements HostnameVerifier {
   public static final OkHostnameVerifier INSTANCE = new OkHostnameVerifier();
 
-  /**
-   * Quick and dirty pattern to differentiate IP addresses from hostnames. This
-   * is an approximation of Android's private InetAddress#isNumeric API.
-   *
-   * <p>This matches IPv6 addresses as a hex string containing at least one
-   * colon, and possibly including dots after the first colon. It matches IPv4
-   * addresses as strings containing only decimal digits and dots. This pattern
-   * matches strings like "a:.23" and "54" that are neither IP addresses nor
-   * hostnames; they will be verified as IP addresses (which is a more strict
-   * verification).
-   */
-  private static final Pattern VERIFY_AS_IP_ADDRESS = Pattern.compile(
-      "([0-9a-fA-F]*:[0-9a-fA-F:.]*)|([\\d.]+)");
-
   private static final int ALT_DNS_NAME = 2;
   private static final int ALT_IPA_NAME = 7;
 
@@ -71,16 +56,10 @@ public boolean verify(String host, SSLSession session) {
   public boolean verify(String host, X509Certificate certificate) {
     return verifyAsIpAddress(host)
         ? verifyIpAddress(host, certificate)
-        : verifyHostName(host, certificate);
+        : verifyHostname(host, certificate);
   }
 
-  static boolean verifyAsIpAddress(String host) {
-    return VERIFY_AS_IP_ADDRESS.matcher(host).matches();
-  }
-
-  /**
-   * Returns true if {@code certificate} matches {@code ipAddress}.
-   */
+  /** Returns true if {@code certificate} matches {@code ipAddress}. */
   private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
     List<String> altNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
     for (int i = 0, size = altNames.size(); i < size; i++) {
@@ -91,16 +70,14 @@ private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
     return false;
   }
 
-  /**
-   * Returns true if {@code certificate} matches {@code hostName}.
-   */
-  private boolean verifyHostName(String hostName, X509Certificate certificate) {
-    hostName = hostName.toLowerCase(Locale.US);
+  /** Returns true if {@code certificate} matches {@code hostname}. */
+  private boolean verifyHostname(String hostname, X509Certificate certificate) {
+    hostname = hostname.toLowerCase(Locale.US);
     boolean hasDns = false;
     List<String> altNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
     for (int i = 0, size = altNames.size(); i < size; i++) {
       hasDns = true;
-      if (verifyHostName(hostName, altNames.get(i))) {
+      if (verifyHostname(hostname, altNames.get(i))) {
         return true;
       }
     }
@@ -110,7 +87,7 @@ private boolean verifyHostName(String hostName, X509Certificate certificate) {
       // RFC 2818 advises using the most specific name for matching.
       String cn = new DistinguishedNameParser(principal).findMostSpecific("cn");
       if (cn != null) {
-        return verifyHostName(hostName, cn);
+        return verifyHostname(hostname, cn);
       }
     }
 
@@ -156,17 +133,17 @@ private boolean verifyHostName(String hostName, X509Certificate certificate) {
   }
 
   /**
-   * Returns {@code true} iff {@code hostName} matches the domain name {@code pattern}.
+   * Returns {@code true} iff {@code hostname} matches the domain name {@code pattern}.
    *
-   * @param hostName lower-case host name.
-   * @param pattern domain name pattern from certificate. May be a wildcard pattern such as
-   *        {@code *.android.com}.
+   * @param hostname lower-case host name.
+   * @param pattern domain name pattern from certificate. May be a wildcard pattern such as {@code
+   * *.android.com}.
    */
-  private boolean verifyHostName(String hostName, String pattern) {
+  private boolean verifyHostname(String hostname, String pattern) {
     // Basic sanity checks
     // Check length == 0 instead of .isEmpty() to support Java 5.
-    if ((hostName == null) || (hostName.length() == 0) || (hostName.startsWith("."))
-        || (hostName.endsWith(".."))) {
+    if ((hostname == null) || (hostname.length() == 0) || (hostname.startsWith("."))
+        || (hostname.endsWith(".."))) {
       // Invalid domain name
       return false;
     }
@@ -176,29 +153,29 @@ private boolean verifyHostName(String hostName, String pattern) {
       return false;
     }
 
-    // Normalize hostName and pattern by turning them into absolute domain names if they are not
+    // Normalize hostname and pattern by turning them into absolute domain names if they are not
     // yet absolute. This is needed because server certificates do not normally contain absolute
-    // names or patterns, but they should be treated as absolute. At the same time, any hostName
+    // names or patterns, but they should be treated as absolute. At the same time, any hostname
     // presented to this method should also be treated as absolute for the purposes of matching
     // to the server certificate.
     //   www.android.com  matches www.android.com
     //   www.android.com  matches www.android.com.
     //   www.android.com. matches www.android.com.
     //   www.android.com. matches www.android.com
-    if (!hostName.endsWith(".")) {
-      hostName += '.';
+    if (!hostname.endsWith(".")) {
+      hostname += '.';
     }
     if (!pattern.endsWith(".")) {
       pattern += '.';
     }
-    // hostName and pattern are now absolute domain names.
+    // hostname and pattern are now absolute domain names.
 
     pattern = pattern.toLowerCase(Locale.US);
-    // hostName and pattern are now in lower case -- domain names are case-insensitive.
+    // hostname and pattern are now in lower case -- domain names are case-insensitive.
 
     if (!pattern.contains("*")) {
-      // Not a wildcard pattern -- hostName and pattern must match exactly.
-      return hostName.equals(pattern);
+      // Not a wildcard pattern -- hostname and pattern must match exactly.
+      return hostname.equals(pattern);
     }
     // Wildcard pattern
 
@@ -218,11 +195,11 @@ private boolean verifyHostName(String hostName, String pattern) {
       return false;
     }
 
-    // Optimization: check whether hostName is too short to match the pattern. hostName must be at
+    // Optimization: check whether hostname is too short to match the pattern. hostName must be at
     // least as long as the pattern because asterisk must match the whole left-most label and
-    // hostName starts with a non-empty label. Thus, asterisk has to match one or more characters.
-    if (hostName.length() < pattern.length()) {
-      // hostName too short to match the pattern.
+    // hostname starts with a non-empty label. Thus, asterisk has to match one or more characters.
+    if (hostname.length() < pattern.length()) {
+      // hostname too short to match the pattern.
       return false;
     }
 
@@ -231,22 +208,22 @@ private boolean verifyHostName(String hostName, String pattern) {
       return false;
     }
 
-    // hostName must end with the region of pattern following the asterisk.
+    // hostname must end with the region of pattern following the asterisk.
     String suffix = pattern.substring(1);
-    if (!hostName.endsWith(suffix)) {
-      // hostName does not end with the suffix
+    if (!hostname.endsWith(suffix)) {
+      // hostname does not end with the suffix
       return false;
     }
 
     // Check that asterisk did not match across domain name labels.
-    int suffixStartIndexInHostName = hostName.length() - suffix.length();
-    if ((suffixStartIndexInHostName > 0)
-        && (hostName.lastIndexOf('.', suffixStartIndexInHostName - 1) != -1)) {
+    int suffixStartIndexInHostname = hostname.length() - suffix.length();
+    if ((suffixStartIndexInHostname > 0)
+        && (hostname.lastIndexOf('.', suffixStartIndexInHostname - 1) != -1)) {
       // Asterisk is matching across domain name labels -- not permitted.
       return false;
     }
 
-    // hostName matches pattern
+    // hostname matches pattern
     return true;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
new file mode 100644
index 0000000000..fcc7468e0e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.security.PublicKey;
+import java.security.cert.TrustAnchor;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import javax.net.ssl.X509TrustManager;
+import javax.security.auth.x500.X500Principal;
+
+public abstract class TrustRootIndex {
+  /** Returns the trusted CA certificate that signed {@code cert}. */
+  abstract X509Certificate findByIssuerAndSignature(X509Certificate cert);
+
+  public static TrustRootIndex get(X509TrustManager trustManager) {
+    try {
+      // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
+      // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
+      Method method = trustManager.getClass().getDeclaredMethod(
+          "findTrustAnchorByIssuerAndSignature", X509Certificate.class);
+      method.setAccessible(true);
+      return new AndroidTrustRootIndex(trustManager, method);
+    } catch (NoSuchMethodException e) {
+      return get(trustManager.getAcceptedIssuers());
+    }
+  }
+
+  public static TrustRootIndex get(X509Certificate... caCerts) {
+    return new BasicTrustRootIndex(caCerts);
+  }
+
+  /**
+   * An index of trusted root certificates that exploits knowledge of Android implementation
+   * details. This class is potentially much faster to initialize than {@link BasicTrustRootIndex}
+   * because it doesn't need to load and index trusted CA certificates.
+   *
+   * <p>This class uses APIs added to Android in API 14 (Android 4.0, released October 2011). This
+   * class shouldn't be used in Android API 17 or better because those releases are better served by
+   * {@link CertificateChainCleaner.AndroidCertificateChainCleaner}.
+   */
+  static final class AndroidTrustRootIndex extends TrustRootIndex {
+    private final X509TrustManager trustManager;
+    private final Method findByIssuerAndSignatureMethod;
+
+    AndroidTrustRootIndex(X509TrustManager trustManager, Method findByIssuerAndSignatureMethod) {
+      this.findByIssuerAndSignatureMethod = findByIssuerAndSignatureMethod;
+      this.trustManager = trustManager;
+    }
+
+    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+      try {
+        TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
+            trustManager, cert);
+        return trustAnchor != null
+            ? trustAnchor.getTrustedCert()
+            : null;
+      } catch (IllegalAccessException e) {
+        throw new AssertionError();
+      } catch (InvocationTargetException e) {
+        return null;
+      }
+    }
+  }
+
+  /** A simple index that of trusted root certificates that have been loaded into memory. */
+  static final class BasicTrustRootIndex extends TrustRootIndex {
+    private final Map<X500Principal, List<X509Certificate>> subjectToCaCerts;
+
+    public BasicTrustRootIndex(X509Certificate... caCerts) {
+      subjectToCaCerts = new LinkedHashMap<>();
+      for (X509Certificate caCert : caCerts) {
+        X500Principal subject = caCert.getSubjectX500Principal();
+        List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
+        if (subjectCaCerts == null) {
+          subjectCaCerts = new ArrayList<>(1);
+          subjectToCaCerts.put(subject, subjectCaCerts);
+        }
+        subjectCaCerts.add(caCert);
+      }
+    }
+
+    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+      X500Principal issuer = cert.getIssuerX500Principal();
+      List<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
+      if (subjectCaCerts == null) return null;
+
+      for (X509Certificate caCert : subjectCaCerts) {
+        PublicKey publicKey = caCert.getPublicKey();
+        try {
+          cert.verify(publicKey);
+          return caCert;
+        } catch (Exception ignored) {
+        }
+      }
+
+      return null;
+    }
+  }
+}
diff --git a/pom.xml b/pom.xml
index 9ecff5dda8..5a8273bf06 100644
--- a/pom.xml
+++ b/pom.xml
@@ -9,9 +9,9 @@
     <version>7</version>
   </parent>
 
-  <groupId>com.squareup.okhttp</groupId>
+  <groupId>com.squareup.okhttp3</groupId>
   <artifactId>parent</artifactId>
-  <version>2.5.0-SNAPSHOT</version>
+  <version>3.3.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
@@ -31,6 +31,8 @@
     <module>okhttp-ws</module>
     <module>okhttp-ws-tests</module>
 
+    <module>okhttp-logging-interceptor</module>
+
     <module>okcurl</module>
     <module>mockwebserver</module>
     <module>samples</module>
@@ -41,20 +43,24 @@
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 
     <!-- Compilation -->
-    <java.version>1.7</java.version>
-    <okio.version>1.5.0</okio.version>
+    <airlift.version>0.7</airlift.version>
     <!-- ALPN library targeted to Java 7 -->
     <alpn.jdk7.version>7.1.2.v20141202</alpn.jdk7.version>
-    <!-- ALPN library targeted to Java 8 update 25. -->
-    <alpn.jdk8.version>8.1.2.v20141202</alpn.jdk8.version>
-    <bouncycastle.version>1.50</bouncycastle.version>
-    <gson.version>2.2.3</gson.version>
+    <!-- ALPN library targeted to Java 8 update 71 - 74 -->
+    <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
+    <android.version>4.1.1.4</android.version>
     <apache.http.version>4.2.2</apache.http.version>
-    <airlift.version>0.6</airlift.version>
+    <bouncycastle.version>1.50</bouncycastle.version>
     <guava.version>16.0</guava.version>
+    <java.version>1.7</java.version>
+    <moshi.version>1.1.0</moshi.version>
+    <okio.version>1.8.0</okio.version>
 
     <!-- Test Dependencies -->
-    <junit.version>4.11</junit.version>
+    <junit.version>4.12</junit.version>
+
+    <!-- platform test mode -->
+    <okhttp.platform>platform</okhttp.platform>
   </properties>
 
   <scm>
@@ -93,11 +99,6 @@
         <artifactId>bcprov-jdk15on</artifactId>
         <version>${bouncycastle.version}</version>
       </dependency>
-      <dependency>
-        <groupId>com.google.code.gson</groupId>
-        <artifactId>gson</artifactId>
-        <version>${gson.version}</version>
-      </dependency>
       <dependency>
         <groupId>org.apache.httpcomponents</groupId>
         <artifactId>httpclient</artifactId>
@@ -113,6 +114,16 @@
         <artifactId>guava</artifactId>
         <version>${guava.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.android</groupId>
+        <artifactId>android</artifactId>
+        <version>${android.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.squareup.moshi</groupId>
+        <artifactId>moshi</artifactId>
+        <version>${moshi.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
@@ -134,6 +145,9 @@
           <artifactId>maven-surefire-plugin</artifactId>
           <version>2.17</version>
           <configuration>
+            <systemPropertyVariables>
+              <okhttp.platform>${okhttp.platform}</okhttp.platform>
+            </systemPropertyVariables>
             <properties>
               <!--
                 Configure a listener for enforcing that no uncaught exceptions issue from OkHttp
@@ -142,7 +156,7 @@
                 -->
               <property>
                 <name>listener</name>
-                <value>com.squareup.okhttp.testing.InstallUncaughtExceptionHandlerListener</value>
+                <value>okhttp3.testing.InstallUncaughtExceptionHandlerListener</value>
               </property>
             </properties>
           </configuration>
@@ -229,7 +243,10 @@
         <jdk>1.7</jdk>
       </activation>
       <properties>
-        <bootclasspathPrefix>${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk7.version}/alpn-boot-${alpn.jdk7.version}.jar</bootclasspathPrefix>
+        <bootclasspathPrefix>
+          ${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk7.version}/alpn-boot-${alpn.jdk7.version}.jar
+        </bootclasspathPrefix>
+        <okhttp.platform>jdk-with-jetty-boot</okhttp.platform>
       </properties>
       <build>
         <pluginManagement>
@@ -258,7 +275,10 @@
         <jdk>1.8</jdk>
       </activation>
       <properties>
-        <bootclasspathPrefix>${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk8.version}/alpn-boot-${alpn.jdk8.version}.jar</bootclasspathPrefix>
+        <bootclasspathPrefix>
+          ${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk8.version}/alpn-boot-${alpn.jdk8.version}.jar
+        </bootclasspathPrefix>
+        <okhttp.platform>jdk-with-jetty-boot</okhttp.platform>
       </properties>
       <build>
         <pluginManagement>
@@ -281,6 +301,15 @@
         </pluginManagement>
       </build>
     </profile>
+    <profile>
+      <id>jdk9</id>
+      <activation>
+        <jdk>1.9</jdk>
+      </activation>
+      <properties>
+        <okhttp.platform>jdk9</okhttp.platform>
+      </properties>
+    </profile>
   </profiles>
 </project>
 
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index 1703c305a2..0daef2b940 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp.sample</groupId>
+    <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.5.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
@@ -14,7 +14,7 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
diff --git a/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
similarity index 90%
rename from samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
rename to samples/crawler/src/main/java/okhttp3/sample/Crawler.java
index 8c731bebac..7fad2ee5e1 100644
--- a/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
+++ b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
@@ -13,14 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.sample;
+package okhttp3.sample;
 
-import com.squareup.okhttp.Cache;
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.NamedRunnable;
 import java.io.File;
 import java.io.IOException;
 import java.util.Collections;
@@ -31,6 +25,12 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.Cache;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.NamedRunnable;
 import org.jsoup.Jsoup;
 import org.jsoup.nodes.Document;
 import org.jsoup.nodes.Element;
@@ -106,7 +106,7 @@ public void fetch(HttpUrl url) throws IOException {
     Document document = Jsoup.parse(response.body().string(), url.toString());
     for (Element element : document.select("a[href]")) {
       String href = element.attr("href");
-      HttpUrl link = response.request().httpUrl().resolve(href);
+      HttpUrl link = response.request().url().resolve(href);
       if (link != null) queue.add(link);
     }
   }
@@ -120,9 +120,10 @@ public static void main(String[] args) throws IOException {
     int threadCount = 20;
     long cacheByteCount = 1024L * 1024L * 100L;
 
-    OkHttpClient client = new OkHttpClient();
     Cache cache = new Cache(new File(args[0]), cacheByteCount);
-    client.setCache(cache);
+    OkHttpClient client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
 
     Crawler crawler = new Crawler(client);
     crawler.queue.add(HttpUrl.parse(args[1]));
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index c1c1339128..d6ccee43e1 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp.sample</groupId>
+    <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.5.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
@@ -14,18 +14,18 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>okhttp-ws</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
     </dependency>
   </dependencies>
 </project>
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java b/samples/guide/src/main/java/okhttp3/guide/GetExample.java
similarity index 79%
rename from samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java
rename to samples/guide/src/main/java/okhttp3/guide/GetExample.java
index aa2f200e40..19ef73bf2e 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/GetExample.java
@@ -1,9 +1,9 @@
-package com.squareup.okhttp.guide;
+package okhttp3.guide;
 
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public class GetExample {
   OkHttpClient client = new OkHttpClient();
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
similarity index 84%
rename from samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java
rename to samples/guide/src/main/java/okhttp3/guide/PostExample.java
index 5de644c7d7..74ddc56127 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
@@ -1,11 +1,11 @@
-package com.squareup.okhttp.guide;
+package okhttp3.guide;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 
 public class PostExample {
   public static final MediaType JSON
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/AccessHeaders.java b/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java
similarity index 90%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/AccessHeaders.java
rename to samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java
index 9fe9d1ab67..fe4d2f521f 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/AccessHeaders.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class AccessHeaders {
   private final OkHttpClient client = new OkHttpClient();
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/AsynchronousGet.java b/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java
similarity index 79%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/AsynchronousGet.java
rename to samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java
index 34cfc584ce..ad49c3e487 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/AsynchronousGet.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.Callback;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class AsynchronousGet {
   private final OkHttpClient client = new OkHttpClient();
@@ -31,11 +32,11 @@ public void run() throws Exception {
         .build();
 
     client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Request request, IOException e) {
+      @Override public void onFailure(Call call, IOException e) {
         e.printStackTrace();
       }
 
-      @Override public void onResponse(Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) throws IOException {
         if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
         Headers responseHeaders = response.headers();
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/Authenticate.java b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
similarity index 54%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/Authenticate.java
rename to samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
index 44581aed33..04c8cae2a8 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/Authenticate.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
@@ -13,35 +13,35 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.Authenticator;
-import com.squareup.okhttp.Credentials;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
-import java.net.Proxy;
+import okhttp3.Authenticator;
+import okhttp3.Credentials;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.Route;
 
 public final class Authenticate {
-  private final OkHttpClient client = new OkHttpClient();
+  private final OkHttpClient client;
+
+  public Authenticate() {
+    client = new OkHttpClient.Builder()
+        .authenticator(new Authenticator() {
+          @Override public Request authenticate(Route route, Response response) throws IOException {
+            System.out.println("Authenticating for response: " + response);
+            System.out.println("Challenges: " + response.challenges());
+            String credential = Credentials.basic("jesse", "password1");
+            return response.request().newBuilder()
+                .header("Authorization", credential)
+                .build();
+          }
+        })
+        .build();
+  }
 
   public void run() throws Exception {
-    client.setAuthenticator(new Authenticator() {
-      @Override public Request authenticate(Proxy proxy, Response response) {
-        System.out.println("Authenticating for response: " + response);
-        System.out.println("Challenges: " + response.challenges());
-        String credential = Credentials.basic("jesse", "password1");
-        return response.request().newBuilder()
-            .header("Authorization", credential)
-            .build();
-      }
-
-      @Override public Request authenticateProxy(Proxy proxy, Response response) {
-        return null; // Null indicates no attempt to authenticate.
-      }
-    });
-
     Request request = new Request.Builder()
         .url("http://publicobject.com/secrets/hellosecret.txt")
         .build();
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java b/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
similarity index 89%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java
rename to samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
index 3335ebe668..8e82f4ab5f 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.Cache;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.File;
 import java.io.IOException;
+import okhttp3.Cache;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class CacheResponse {
   private final OkHttpClient client;
@@ -29,8 +29,9 @@ public CacheResponse(File cacheDirectory) throws Exception {
     int cacheSize = 10 * 1024 * 1024; // 10 MiB
     Cache cache = new Cache(cacheDirectory, cacheSize);
 
-    client = new OkHttpClient();
-    client.setCache(cache);
+    client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
   }
 
   public void run() throws Exception {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CancelCall.java b/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
similarity index 92%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/CancelCall.java
rename to samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
index 9f8d37305c..c3551f78be 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CancelCall.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
@@ -13,16 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.Call;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public class CancelCall {
   private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CertificatePinning.java b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
similarity index 68%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/CertificatePinning.java
rename to samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
index b643d52d03..36371303d7 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CertificatePinning.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
@@ -13,27 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.CertificatePinner;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.security.cert.Certificate;
+import okhttp3.CertificatePinner;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class CertificatePinning {
   private final OkHttpClient client;
 
   public CertificatePinning() {
-    client = new OkHttpClient();
-    client.setCertificatePinner(
-        new CertificatePinner.Builder()
-            .add("publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
-            .add("publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
-            .add("publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
-            .add("publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
-            .build());
+    client = new OkHttpClient.Builder()
+        .certificatePinner(
+            new CertificatePinner.Builder()
+                .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+                .build())
+        .build();
   }
 
   public void run() throws Exception {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CheckHandshake.java b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
similarity index 78%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/CheckHandshake.java
rename to samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
index 0a2e86e7d2..0f52fb426d 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CheckHandshake.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
@@ -13,17 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.CertificatePinner;
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.security.cert.Certificate;
 import java.util.Collections;
 import java.util.Set;
+import okhttp3.CertificatePinner;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class CheckHandshake {
   /** Rejects otherwise-trusted certificates. */
@@ -31,7 +31,7 @@
     Set<String> blacklist = Collections.singleton("sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
 
     @Override public Response intercept(Chain chain) throws IOException {
-      for (Certificate certificate : chain.connection().getHandshake().peerCertificates()) {
+      for (Certificate certificate : chain.connection().handshake().peerCertificates()) {
         String pin = CertificatePinner.pin(certificate);
         if (blacklist.contains(pin)) {
           throw new IOException("Blacklisted peer certificate: " + pin);
@@ -41,11 +41,9 @@
     }
   };
 
-  private final OkHttpClient client = new OkHttpClient();
-
-  public CheckHandshake() {
-    client.networkInterceptors().add(CHECK_HANDSHAKE_INTERCEPTOR);
-  }
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .addNetworkInterceptor(CHECK_HANDSHAKE_INTERCEPTOR)
+      .build();
 
   public void run() throws Exception {
     Request request = new Request.Builder()
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/ConfigureTimeouts.java b/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
similarity index 77%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/ConfigureTimeouts.java
rename to samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
index f358a4564f..2f93880260 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/ConfigureTimeouts.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
@@ -13,21 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.util.concurrent.TimeUnit;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class ConfigureTimeouts {
   private final OkHttpClient client;
 
   public ConfigureTimeouts() throws Exception {
-    client = new OkHttpClient();
-    client.setConnectTimeout(10, TimeUnit.SECONDS);
-    client.setWriteTimeout(10, TimeUnit.SECONDS);
-    client.setReadTimeout(30, TimeUnit.SECONDS);
+    client = new OkHttpClient.Builder()
+        .connectTimeout(10, TimeUnit.SECONDS)
+        .writeTimeout(10, TimeUnit.SECONDS)
+        .readTimeout(30, TimeUnit.SECONDS)
+        .build();
   }
 
   public void run() throws Exception {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CustomTrust.java b/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
similarity index 77%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/CustomTrust.java
rename to samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
index f99dc627a9..0ee606cbf0 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CustomTrust.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
@@ -13,33 +13,47 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.CertificatePinner;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.io.InputStream;
 import java.security.GeneralSecurityException;
 import java.security.KeyStore;
-import java.security.SecureRandom;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateFactory;
+import java.util.Arrays;
 import java.util.Collection;
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
 import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.CertificatePinner;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 import okio.Buffer;
 
 public final class CustomTrust {
   private final OkHttpClient client;
 
   public CustomTrust() {
-    client = new OkHttpClient();
-    SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());
-    client.setSslSocketFactory(sslContext.getSocketFactory());
+    X509TrustManager trustManager;
+    SSLSocketFactory sslSocketFactory;
+    try {
+      trustManager = trustManagerForCertificates(trustedCertificatesInputStream());
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(null, new TrustManager[] { trustManager }, null);
+      sslSocketFactory = sslContext.getSocketFactory();
+    } catch (GeneralSecurityException e) {
+      throw new RuntimeException(e);
+    }
+
+    client = new OkHttpClient.Builder()
+        .sslSocketFactory(sslSocketFactory, trustManager)
+        .build();
   }
 
   public void run() throws Exception {
@@ -138,7 +152,7 @@ private InputStream trustedCertificatesInputStream() {
   }
 
   /**
-   * Returns a SSL context that trusts {@code certificates} and none other. HTTPS services whose
+   * Returns a trust manager that trusts {@code certificates} and none other. HTTPS services whose
    * certificates have not been signed by these certificates will fail with a {@code
    * SSLHandshakeException}.
    *
@@ -150,43 +164,43 @@ private InputStream trustedCertificatesInputStream() {
    * the host platform's built-in trust store.
    *
    * <h3>Warning: Customizing Trusted Certificates is Dangerous!</h3>
-   * Relying on your own trusted certificates limits your server team's ability to update their TLS
-   * certificates. By installing a specific set of trusted certificates, you take on additional
+   *
+   * <p>Relying on your own trusted certificates limits your server team's ability to update their
+   * TLS certificates. By installing a specific set of trusted certificates, you take on additional
    * operational complexity and limit your ability to migrate between certificate authorities. Do
    * not use custom trusted certificates in production without the blessing of your server's TLS
    * administrator.
    */
-  public SSLContext sslContextForTrustedCertificates(InputStream in) {
-    try {
-      CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-      Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(in);
-      if (certificates.isEmpty()) {
-        throw new IllegalArgumentException("expected non-empty set of trusted certificates");
-      }
+  private X509TrustManager trustManagerForCertificates(InputStream in)
+      throws GeneralSecurityException {
+    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
+    Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(in);
+    if (certificates.isEmpty()) {
+      throw new IllegalArgumentException("expected non-empty set of trusted certificates");
+    }
 
-      // Put the certificates a key store.
-      char[] password = "password".toCharArray(); // Any password will work.
-      KeyStore keyStore = newEmptyKeyStore(password);
-      int index = 0;
-      for (Certificate certificate : certificates) {
-        String certificateAlias = Integer.toString(index++);
-        keyStore.setCertificateEntry(certificateAlias, certificate);
-      }
+    // Put the certificates a key store.
+    char[] password = "password".toCharArray(); // Any password will work.
+    KeyStore keyStore = newEmptyKeyStore(password);
+    int index = 0;
+    for (Certificate certificate : certificates) {
+      String certificateAlias = Integer.toString(index++);
+      keyStore.setCertificateEntry(certificateAlias, certificate);
+    }
 
-      // Wrap it up in an SSL context.
-      KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
-          KeyManagerFactory.getDefaultAlgorithm());
-      keyManagerFactory.init(keyStore, password);
-      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-          TrustManagerFactory.getDefaultAlgorithm());
-      trustManagerFactory.init(keyStore);
-      SSLContext sslContext = SSLContext.getInstance("TLS");
-      sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(),
-          new SecureRandom());
-      return sslContext;
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
+    // Use it to build an X509 trust manager.
+    KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
+        KeyManagerFactory.getDefaultAlgorithm());
+    keyManagerFactory.init(keyStore, password);
+    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    trustManagerFactory.init(keyStore);
+    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+    if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+      throw new IllegalStateException("Unexpected default trust managers:"
+          + Arrays.toString(trustManagers));
     }
+    return (X509TrustManager) trustManagers[0];
   }
 
   private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/LoggingInterceptors.java b/samples/guide/src/main/java/okhttp3/recipes/LoggingInterceptors.java
similarity index 56%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/LoggingInterceptors.java
rename to samples/guide/src/main/java/okhttp3/recipes/LoggingInterceptors.java
index bcfa6e9aa9..8cb72b4bc8 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/LoggingInterceptors.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/LoggingInterceptors.java
@@ -13,35 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.util.logging.Logger;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class LoggingInterceptors {
   private static final Logger logger = Logger.getLogger(LoggingInterceptors.class.getName());
-  private final OkHttpClient client = new OkHttpClient();
-
-  public LoggingInterceptors() {
-    client.networkInterceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        long t1 = System.nanoTime();
-        Request request = chain.request();
-        logger.info(String.format("Sending request %s on %s%n%s",
-            request.httpUrl(), chain.connection(), request.headers()));
-        Response response = chain.proceed(request);
-
-        long t2 = System.nanoTime();
-        logger.info(String.format("Received response for %s in %.1fms%n%s",
-            request.httpUrl(), (t2 - t1) / 1e6d, response.headers()));
-        return response;
-      }
-    });
-  }
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .addInterceptor(new LoggingInterceptor())
+      .build();
 
   public void run() throws Exception {
     Request request = new Request.Builder()
@@ -52,6 +37,21 @@ public void run() throws Exception {
     response.body().close();
   }
 
+  private static class LoggingInterceptor implements Interceptor {
+    @Override public Response intercept(Chain chain) throws IOException {
+      long t1 = System.nanoTime();
+      Request request = chain.request();
+      logger.info(String.format("Sending request %s on %s%n%s",
+          request.url(), chain.connection(), request.headers()));
+      Response response = chain.proceed(request);
+
+      long t2 = System.nanoTime();
+      logger.info(String.format("Received response for %s in %.1fms%n%s",
+          request.url(), (t2 - t1) / 1e6d, response.headers()));
+      return response;
+    }
+  }
+
   public static void main(String... args) throws Exception {
     new LoggingInterceptors().run();
   }
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/ParseResponseWithGson.java b/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java
similarity index 73%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/ParseResponseWithGson.java
rename to samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java
index cf63f0d4b1..80585c10fe 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/ParseResponseWithGson.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java
@@ -13,18 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.google.gson.Gson;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
 import java.io.IOException;
 import java.util.Map;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
-public final class ParseResponseWithGson {
+public final class ParseResponseWithMoshi {
   private final OkHttpClient client = new OkHttpClient();
-  private final Gson gson = new Gson();
+  private final Moshi moshi = new Moshi.Builder().build();
+  private final JsonAdapter<Gist> gistJsonAdapter = moshi.adapter(Gist.class);
 
   public void run() throws Exception {
     Request request = new Request.Builder()
@@ -33,7 +35,9 @@ public void run() throws Exception {
     Response response = client.newCall(request).execute();
     if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    Gist gist = gson.fromJson(response.body().charStream(), Gist.class);
+    Gist gist = gistJsonAdapter.fromJson(response.body().source());
+    response.body().close();
+
     for (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {
       System.out.println(entry.getKey());
       System.out.println(entry.getValue().content);
@@ -49,6 +53,6 @@ public void run() throws Exception {
   }
 
   public static void main(String... args) throws Exception {
-    new ParseResponseWithGson().run();
+    new ParseResponseWithMoshi().run();
   }
 }
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PerCallSettings.java b/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java
similarity index 70%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/PerCallSettings.java
rename to samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java
index af4956e17f..9f82d1efae 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PerCallSettings.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java
@@ -13,13 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.util.concurrent.TimeUnit;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class PerCallSettings {
   private final OkHttpClient client = new OkHttpClient();
@@ -30,20 +30,24 @@ public void run() throws Exception {
         .build();
 
     try {
-      OkHttpClient cloned = client.clone(); // Clone to make a customized OkHttp for this request.
-      cloned.setReadTimeout(500, TimeUnit.MILLISECONDS);
+      // Copy to customize OkHttp for this request.
+      OkHttpClient copy = client.newBuilder()
+          .readTimeout(500, TimeUnit.MILLISECONDS)
+          .build();
 
-      Response response = cloned.newCall(request).execute();
+      Response response = copy.newCall(request).execute();
       System.out.println("Response 1 succeeded: " + response);
     } catch (IOException e) {
       System.out.println("Response 1 failed: " + e);
     }
 
     try {
-      OkHttpClient cloned = client.clone(); // Clone to make a customized OkHttp for this request.
-      cloned.setReadTimeout(3000, TimeUnit.MILLISECONDS);
+      // Copy to customize OkHttp for this request.
+      OkHttpClient copy = client.newBuilder()
+          .readTimeout(3000, TimeUnit.MILLISECONDS)
+          .build();
 
-      Response response = cloned.newCall(request).execute();
+      Response response = copy.newCall(request).execute();
       System.out.println("Response 2 succeeded: " + response);
     } catch (IOException e) {
       System.out.println("Response 2 failed: " + e);
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostFile.java b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
similarity index 85%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/PostFile.java
rename to samples/guide/src/main/java/okhttp3/recipes/PostFile.java
index a0d98df45f..4d69844a7a 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostFile.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
 import java.io.File;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 
 public final class PostFile {
   public static final MediaType MEDIA_TYPE_MARKDOWN
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java b/samples/guide/src/main/java/okhttp3/recipes/PostForm.java
similarity index 81%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java
rename to samples/guide/src/main/java/okhttp3/recipes/PostForm.java
index 30054f1905..f2f05def19 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostForm.java
@@ -13,20 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.FormEncodingBuilder;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.FormBody;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 
 public final class PostForm {
   private final OkHttpClient client = new OkHttpClient();
 
   public void run() throws Exception {
-    RequestBody formBody = new FormEncodingBuilder()
+    RequestBody formBody = new FormBody.Builder()
         .add("search", "Jurassic Park")
         .build();
     Request request = new Request.Builder()
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostMultipart.java b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
similarity index 76%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/PostMultipart.java
rename to samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
index 8e5334aa39..ab3708fab5 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostMultipart.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
@@ -13,22 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
-
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.MultipartBuilder;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
+package okhttp3.recipes;
+
 import java.io.File;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.MultipartBody;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 
 public final class PostMultipart {
   /**
-   * The imgur client ID for OkHttp recipes. If you're using imgur for anything
-   * other than running these examples, please request your own client ID!
-   *   https://api.imgur.com/oauth2
+   * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
+   * these examples, please request your own client ID! https://api.imgur.com/oauth2
    */
   private static final String IMGUR_CLIENT_ID = "9199fdef135c122";
   private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
@@ -37,10 +36,10 @@
 
   public void run() throws Exception {
     // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
-    RequestBody requestBody = new MultipartBuilder()
-        .type(MultipartBuilder.FORM)
+    RequestBody requestBody = new MultipartBody.Builder()
+        .setType(MultipartBody.FORM)
         .addFormDataPart("title", "Square Logo")
-        .addFormDataPart("image", null,
+        .addFormDataPart("image", "logo-square.png",
             RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png")))
         .build();
 
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostStreaming.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
similarity index 89%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/PostStreaming.java
rename to samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
index 500344c7e9..4651240d67 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostStreaming.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 import okio.BufferedSink;
 
 public final class PostStreaming {
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostString.java b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
similarity index 87%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/PostString.java
rename to samples/guide/src/main/java/okhttp3/recipes/PostString.java
index 943636abb5..f956f97f1f 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostString.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 
 public final class PostString {
   public static final MediaType MEDIA_TYPE_MARKDOWN
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/Progress.java b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
similarity index 78%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/Progress.java
rename to samples/guide/src/main/java/okhttp3/recipes/Progress.java
index 9d329fa16e..f499a90cf1 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/Progress.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
-
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseBody;
-import com.squareup.okhttp.Request;
+package okhttp3.recipes;
+
 import java.io.IOException;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ForwardingSource;
@@ -30,8 +30,6 @@
 
 public final class Progress {
 
-  private final OkHttpClient client = new OkHttpClient();
-
   public void run() throws Exception {
     Request request = new Request.Builder()
         .url("https://publicobject.com/helloworld.txt")
@@ -46,14 +44,16 @@ public void run() throws Exception {
       }
     };
 
-    client.networkInterceptors().add(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Response originalResponse = chain.proceed(chain.request());
-        return originalResponse.newBuilder()
-            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
-            .build();
-        }
-    });
+    OkHttpClient client = new OkHttpClient.Builder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            Response originalResponse = chain.proceed(chain.request());
+            return originalResponse.newBuilder()
+                .body(new ProgressResponseBody(originalResponse.body(), progressListener))
+                .build();
+          }
+        })
+        .build();
 
     Response response = client.newCall(request).execute();
     if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
@@ -80,11 +80,11 @@ public ProgressResponseBody(ResponseBody responseBody, ProgressListener progress
       return responseBody.contentType();
     }
 
-    @Override public long contentLength() throws IOException {
+    @Override public long contentLength() {
       return responseBody.contentLength();
     }
 
-    @Override public BufferedSource source() throws IOException {
+    @Override public BufferedSource source() {
       if (bufferedSource == null) {
         bufferedSource = Okio.buffer(source(responseBody.source()));
       }
@@ -94,6 +94,7 @@ public ProgressResponseBody(ResponseBody responseBody, ProgressListener progress
     private Source source(Source source) {
       return new ForwardingSource(source) {
         long totalBytesRead = 0L;
+
         @Override public long read(Buffer sink, long byteCount) throws IOException {
           long bytesRead = super.read(sink, byteCount);
           // read() returns the number of bytes read, or -1 if this source is exhausted.
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/RequestBodyCompression.java b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
similarity index 80%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/RequestBodyCompression.java
rename to samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
index c4805bdeb3..1dccacc8fa 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/RequestBodyCompression.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
@@ -13,18 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.google.gson.Gson;
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import com.squareup.moshi.Types;
 import java.io.IOException;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 import okio.BufferedSink;
 import okio.GzipSink;
 import okio.Okio;
@@ -33,22 +35,24 @@
   /**
    * The Google API KEY for OkHttp recipes. If you're using Google APIs for anything other than
    * running these examples, please request your own client ID!
-   *   https://console.developers.google.com/project
+   *
+   * https://console.developers.google.com/project
    */
   public static final String GOOGLE_API_KEY = "AIzaSyAx2WZYe0My0i-uGurpvraYJxO7XNbwiGs";
   public static final MediaType MEDIA_TYPE_JSON = MediaType.parse("application/json");
 
-  private final OkHttpClient client = new OkHttpClient();
-
-  public RequestBodyCompression() {
-    client.interceptors().add(new GzipRequestInterceptor());
-  }
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .addInterceptor(new GzipRequestInterceptor())
+      .build();
+  private final Moshi moshi = new Moshi.Builder().build();
+  private final JsonAdapter<Map<String, String>> mapJsonAdapter = moshi.adapter(
+      Types.newParameterizedType(Map.class, String.class, String.class));
 
   public void run() throws Exception {
     Map<String, String> requestBody = new LinkedHashMap<>();
     requestBody.put("longUrl", "https://publicobject.com/2014/12/04/html-formatting-javadocs/");
     RequestBody jsonRequestBody = RequestBody.create(
-        MEDIA_TYPE_JSON, new Gson().toJson(requestBody));
+        MEDIA_TYPE_JSON, mapJsonAdapter.toJson(requestBody));
     Request request = new Request.Builder()
         .url("https://www.googleapis.com/urlshortener/v1/url?key=" + GOOGLE_API_KEY)
         .post(jsonRequestBody)
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/RewriteResponseCacheControl.java b/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
similarity index 81%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/RewriteResponseCacheControl.java
rename to samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
index 63f819e5e5..d034c505c2 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/RewriteResponseCacheControl.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.Cache;
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.File;
 import java.io.IOException;
+import okhttp3.Cache;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class RewriteResponseCacheControl {
   /** Dangerous interceptor that rewrites the server's cache-control header. */
@@ -40,8 +40,9 @@ public RewriteResponseCacheControl(File cacheDirectory) throws Exception {
     Cache cache = new Cache(cacheDirectory, 1024 * 1024);
     cache.evictAll();
 
-    client = new OkHttpClient();
-    client.setCache(cache);
+    client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
   }
 
   public void run() throws Exception {
@@ -52,17 +53,20 @@ public void run() throws Exception {
           .url("https://api.github.com/search/repositories?q=http")
           .build();
 
+      OkHttpClient clientForCall;
       if (i == 2) {
         // Force this request's response to be written to the cache. This way, subsequent responses
         // can be read from the cache.
         System.out.println("Force cache: true");
-        client.networkInterceptors().add(REWRITE_CACHE_CONTROL_INTERCEPTOR);
+        clientForCall = client.newBuilder()
+            .addNetworkInterceptor(REWRITE_CACHE_CONTROL_INTERCEPTOR)
+            .build();
       } else {
         System.out.println("Force cache: false");
-        client.networkInterceptors().clear();
+        clientForCall = client;
       }
 
-      Response response = client.newCall(request).execute();
+      Response response = clientForCall.newCall(request).execute();
       response.body().close();
       if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/SynchronousGet.java b/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java
similarity index 88%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/SynchronousGet.java
rename to samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java
index 6b4cecbe13..ab8d48e3d2 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/SynchronousGet.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java
@@ -13,13 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
 import java.io.IOException;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
 
 public final class SynchronousGet {
   private final OkHttpClient client = new OkHttpClient();
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
similarity index 53%
rename from samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java
rename to samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
index d439e99b68..c7ee9438b0 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
@@ -1,20 +1,21 @@
-package com.squareup.okhttp.recipes;
+package okhttp3.recipes;
 
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ws.WebSocket;
-import com.squareup.okhttp.ws.WebSocketCall;
-import com.squareup.okhttp.ws.WebSocketListener;
 import java.io.IOException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.ws.WebSocket;
+import okhttp3.ws.WebSocketCall;
+import okhttp3.ws.WebSocketListener;
 import okio.Buffer;
-import okio.BufferedSource;
+import okio.ByteString;
 
-import static com.squareup.okhttp.ws.WebSocket.PayloadType;
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.BINARY;
-import static com.squareup.okhttp.ws.WebSocket.PayloadType.TEXT;
+import static okhttp3.ws.WebSocket.BINARY;
+import static okhttp3.ws.WebSocket.TEXT;
 
 public final class WebSocketEcho implements WebSocketListener {
   private final Executor writeExecutor = Executors.newSingleThreadExecutor();
@@ -28,16 +29,16 @@ private void run() throws IOException {
     WebSocketCall.create(client, request).enqueue(this);
 
     // Trigger shutdown of the dispatcher's executor so this process can exit cleanly.
-    client.getDispatcher().getExecutorService().shutdown();
+    client.dispatcher().executorService().shutdown();
   }
 
   @Override public void onOpen(final WebSocket webSocket, Response response) {
     writeExecutor.execute(new Runnable() {
       @Override public void run() {
         try {
-          webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello..."));
-          webSocket.sendMessage(TEXT, new Buffer().writeUtf8("...World!"));
-          webSocket.sendMessage(BINARY, new Buffer().writeInt(0xdeadbeef));
+          webSocket.sendMessage(RequestBody.create(TEXT, "Hello..."));
+          webSocket.sendMessage(RequestBody.create(TEXT, "...World!"));
+          webSocket.sendMessage(RequestBody.create(BINARY, ByteString.decodeHex("deadbeef")));
           webSocket.close(1000, "Goodbye, World!");
         } catch (IOException e) {
           System.err.println("Unable to send messages: " + e.getMessage());
@@ -46,18 +47,13 @@ private void run() throws IOException {
     });
   }
 
-  @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
-    switch (type) {
-      case TEXT:
-        System.out.println("MESSAGE: " + payload.readUtf8());
-        break;
-      case BINARY:
-        System.out.println("MESSAGE: " + payload.readByteString().hex());
-        break;
-      default:
-        throw new IllegalStateException("Unknown payload type: " + type);
+  @Override public void onMessage(ResponseBody message) throws IOException {
+    if (message.contentType() == TEXT) {
+      System.out.println("MESSAGE: " + message.string());
+    } else {
+      System.out.println("MESSAGE: " + message.source().readByteString().hex());
     }
-    payload.close();
+    message.close();
   }
 
   @Override public void onPong(Buffer payload) {
diff --git a/samples/pom.xml b/samples/pom.xml
index e2be70ea56..4c484cbf13 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -4,12 +4,12 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp</groupId>
+    <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>2.5.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
-  <groupId>com.squareup.okhttp.sample</groupId>
+  <groupId>com.squareup.okhttp3.sample</groupId>
   <artifactId>sample-parent</artifactId>
   <packaging>pom</packaging>
   <name>Samples (Parent)</name>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index a6092921f9..1327dea146 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp.sample</groupId>
+    <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.5.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
@@ -14,14 +14,14 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
 
     <dependency>
-      <groupId>com.google.code.gson</groupId>
-      <artifactId>gson</artifactId>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
     </dependency>
   </dependencies>
 </project>
diff --git a/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
similarity index 65%
rename from samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
rename to samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
index e616d41d51..ec9019110b 100644
--- a/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
+++ b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
@@ -1,21 +1,21 @@
-package com.squareup.okhttp.sample;
-
-import com.google.gson.Gson;
-import com.google.gson.reflect.TypeToken;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.Response;
-import java.io.Reader;
+package okhttp3.sample;
+
+import com.squareup.moshi.JsonAdapter;
+import com.squareup.moshi.Moshi;
+import com.squareup.moshi.Types;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
 
 public class OkHttpContributors {
   private static final String ENDPOINT = "https://api.github.com/repos/square/okhttp/contributors";
-  private static final Gson GSON = new Gson();
-  private static final TypeToken<List<Contributor>> CONTRIBUTORS =
-      new TypeToken<List<Contributor>>() {
-      };
+  private static final Moshi MOSHI = new Moshi.Builder().build();
+  private static final JsonAdapter<List<Contributor>> CONTRIBUTORS_JSON_ADAPTER = MOSHI.adapter(
+      Types.newParameterizedType(List.class, Contributor.class));
 
   static class Contributor {
     String login;
@@ -34,8 +34,9 @@ public static void main(String... args) throws Exception {
     Response response = client.newCall(request).execute();
 
     // Deserialize HTTP response to concrete type.
-    Reader body = response.body().charStream();
-    List<Contributor> contributors = GSON.fromJson(body, CONTRIBUTORS.getType());
+    ResponseBody body = response.body();
+    List<Contributor> contributors = CONTRIBUTORS_JSON_ADAPTER.fromJson(body.source());
+    body.close();
 
     // Sort list by the most contributions.
     Collections.sort(contributors, new Comparator<Contributor>() {
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index 6432b40192..f9e5101f9c 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -4,9 +4,9 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.squareup.okhttp.sample</groupId>
+    <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.5.0-SNAPSHOT</version>
+    <version>3.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
@@ -14,7 +14,7 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
+      <groupId>com.squareup.okhttp3</groupId>
       <artifactId>mockwebserver</artifactId>
       <version>${project.version}</version>
     </dependency>
@@ -33,7 +33,7 @@
           <transformers>
             <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
               <manifestEntries>
-                <Main-Class>com.squareup.okhttp.sample.SampleServer</Main-Class>
+                <Main-Class>okhttp3.sample.SampleServer</Main-Class>
               </manifestEntries>
             </transformer>
           </transformers>
@@ -51,7 +51,9 @@
         <executions>
           <execution>
             <phase>package</phase>
-            <goals><goal>shade</goal></goals>
+            <goals>
+              <goal>shade</goal>
+            </goals>
           </execution>
         </executions>
       </plugin>
diff --git a/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java b/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
similarity index 94%
rename from samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
rename to samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
index a2fd19d424..e21432ed20 100644
--- a/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
+++ b/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
@@ -1,10 +1,5 @@
-package com.squareup.okhttp.sample;
+package okhttp3.sample;
 
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.mockwebserver.Dispatcher;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -16,6 +11,11 @@
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManagerFactory;
+import okhttp3.internal.Util;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
 import okio.Buffer;
 import okio.Okio;
 
diff --git a/website/index.html b/website/index.html
index 86695a403a..ff9ec474b3 100644
--- a/website/index.html
+++ b/website/index.html
@@ -4,7 +4,7 @@
     <meta charset="utf-8">
     <title>OkHttp</title>
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <meta name="description" content="An HTTP &amp; SPDY client for Android and Java applications">
+    <meta name="description" content="An HTTP &amp; HTTP/2 client for Android and Java applications">
     <link href="static/bootstrap-combined.min.css" rel="stylesheet">
     <link href="static/app.css" rel="stylesheet">
     <link href="static/app-theme.css" rel="stylesheet">
@@ -33,7 +33,7 @@ <h1>OkHttp</h1>
       <div class="container">
         <div class="row">
           <div class="span12">
-            <h2>An <strong>HTTP &amp; SPDY</strong> client for Android and Java applications</h2>
+            <h2>An <strong>HTTP &amp; HTTP/2</strong> client for Android and Java applications</h2>
           </div>
         </div>
       </div>
@@ -48,8 +48,8 @@ <h3 id="overview">Overview</h3>
 
             <p>OkHttp is an HTTP client that’s efficient by default:</p>
             <ul>
-                <li>HTTP/2 and SPDY support allows all requests to the same host to share a socket.</li>
-                <li>Connection pooling reduces request latency (if SPDY isn’t available).</li>
+                <li>HTTP/2 support allows all requests to the same host to share a socket.</li>
+                <li>Connection pooling reduces request latency (if HTTP/2 isn’t available).</li>
                 <li>Transparent GZIP shrinks download sizes.</li>
                 <li>Response caching avoids the network completely for repeat requests.</li>
             </ul>
@@ -61,20 +61,15 @@ <h3 id="overview">Overview</h3>
                 with modern TLS features (SNI, ALPN), and falls back to TLS 1.0 if the handshake
                 fails.</p>
 
-            <p>Using OkHttp is easy. Its 2.0 API is designed with fluent builders and
+            <p>Using OkHttp is easy. Its request/response API is designed with fluent builders and
                 immutability. It supports both synchronous blocking calls and async calls with
                 callbacks.</p>
 
-            <p>You can try out OkHttp without rewriting your network code. The
-                <code>okhttp-urlconnection</code> module implements the familiar
-                <code>java.net.HttpURLConnection</code> API and the <code>okhttp-apache</code>
-                module implements the Apache <code>HttpClient</code> API.</p>
-
             <p>OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.</p>
 
             <h3 id="examples">Examples</h3>
             <h4>Get a URL</h4>
-            <p>This program downloads a URL and print its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java">Full source</a>.
+            <p>This program downloads a URL and print its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/GetExample.java">Full source</a>.
 <pre class="prettyprint">
 OkHttpClient client = new OkHttpClient();
 
@@ -88,7 +83,7 @@ <h4>Get a URL</h4>
 }
 </pre>
             <h4>Post to a Server</h4>
-            <p>This program posts data to a service. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java">Full source</a>.
+            <p>This program posts data to a service. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/PostExample.java">Full source</a>.
 
 <pre class="prettyprint">
 public static final MediaType JSON
@@ -108,7 +103,7 @@ <h4>Post to a Server</h4>
 </pre>
 
             <h3 id="download">Download</h3>
-            <p><a href="https://search.maven.org/remote_content?g=com.squareup.okhttp&a=okhttp&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
+            <p><a href="https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
             <p>You'll also need <a href="http://github.com/square/okio">Okio</a>, which OkHttp
                 uses for fast I/O and resizable buffers. Download the
                 <a href="https://search.maven.org/remote_content?g=com.squareup.okio&a=okio&v=LATEST">latest JAR</a>.
@@ -116,13 +111,13 @@ <h3 id="download">Download</h3>
 
             <h4>Maven</h4>
             <pre class="prettyprint">&lt;dependency>
-  &lt;groupId>com.squareup.okhttp&lt;/groupId>
+  &lt;groupId>com.squareup.okhttp3&lt;/groupId>
   &lt;artifactId>okhttp&lt;/artifactId>
   &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
 &lt;/dependency></pre>
 
             <h4>Gradle</h4>
-            <pre class="prettyprint">compile 'com.squareup.okhttp:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
+            <pre class="prettyprint">compile 'com.squareup.okhttp3:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
 
             <h3 id="contributing">Contributing</h3>
             <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
@@ -130,7 +125,7 @@ <h3 id="contributing">Contributing</h3>
             <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
 
             <h3 id="license">License</h3>
-            <pre>Copyright 2014 Square, Inc.
+            <pre>Copyright 2016 Square, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -155,7 +150,7 @@ <h3 id="license">License</h3>
               </ul>
               <ul class="nav nav-pills nav-stacked secondary">
                 <li><a href="https://github.com/square/okhttp/wiki">Wiki</a></li>
-                <li><a href="javadoc/index.html">Javadoc</a></li>
+                <li><a href="3.x/okhttp/">Javadoc</a></li>
                 <li><a href="http://stackoverflow.com/questions/tagged/okhttp?sort=active">StackOverflow</a></li>
               </ul>
             </div>
@@ -197,7 +192,7 @@ <h3 id="license">License</h3>
 
         // Look up the latest version of the library.
         $.fn.artifactVersion({
-          'groupId': 'com.squareup.okhttp',
+          'groupId': 'com.squareup.okhttp3',
           'artifactId': 'okhttp'
         }, function(version, url) {
           $('.version').text(version);
