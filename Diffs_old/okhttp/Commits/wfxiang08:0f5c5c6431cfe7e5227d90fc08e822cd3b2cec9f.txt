diff --git a/okhttp-tests/src/test/java/okhttp3/internal/io/WaitUntilNotifiedTest.java b/okhttp-tests/src/test/java/okhttp3/internal/io/WaitUntilNotifiedTest.java
index efe1a809b2..d2e8dfbffc 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/io/WaitUntilNotifiedTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/io/WaitUntilNotifiedTest.java
@@ -142,6 +142,6 @@ private double now() {
    * -50..+450 milliseconds.
    */
   private void assertElapsed(double duration, double start) {
-    assertEquals(duration, now() - start + 200d, 250.0);
+    assertEquals(duration, now() - start - 200d, 250.0);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 41aa866d20..c78062dfcc 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -21,10 +21,9 @@
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Platform;
 import okhttp3.internal.http.HttpEngine;
-import okhttp3.internal.http.UnrepeatableRequestBody;
-import okhttp3.internal.http.RequestException;
 import okhttp3.internal.http.RouteException;
 import okhttp3.internal.http.StreamAllocation;
+import okhttp3.internal.http.UnrepeatableRequestBody;
 
 import static okhttp3.internal.Platform.INFO;
 import static okhttp3.internal.http.HttpEngine.MAX_FOLLOW_UPS;
@@ -223,7 +222,7 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
     }
 
     // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
-    engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null);
+    engine = new HttpEngine(client, request, false, forWebSocket, null, null);
 
     int followUpCount = 0;
     while (true) {
@@ -237,12 +236,9 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
         engine.sendRequest();
         engine.readResponse();
         releaseConnection = false;
-      } catch (RequestException e) {
-        // The attempt to interpret the request failed. Give up.
-        throw e.getCause();
       } catch (RouteException e) {
         // The attempt to connect via a route failed. The request will not have been sent.
-        HttpEngine retryEngine = engine.recover(e.getLastConnectException(), true, null);
+        HttpEngine retryEngine = engine.recover(e.getLastConnectException(), true);
         if (retryEngine != null) {
           releaseConnection = false;
           engine = retryEngine;
@@ -252,7 +248,7 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
         throw e.getLastConnectException();
       } catch (IOException e) {
         // An attempt to communicate with a server failed. The request may have been sent.
-        HttpEngine retryEngine = engine.recover(e, false, null);
+        HttpEngine retryEngine = engine.recover(e, false);
         if (retryEngine != null) {
           releaseConnection = false;
           engine = retryEngine;
@@ -299,8 +295,7 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
       }
 
       request = followUp;
-      engine = new HttpEngine(client, request, false, false, forWebSocket, streamAllocation, null,
-          response);
+      engine = new HttpEngine(client, request, false, forWebSocket, streamAllocation, response);
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java b/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
index 613e0bf215..7df8540049 100644
--- a/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/RouteDatabase.java
@@ -42,8 +42,4 @@ public synchronized void connected(Route route) {
   public synchronized boolean shouldPostpone(Route route) {
     return failedRoutes.contains(route);
   }
-
-  public synchronized int failedRoutesCount() {
-    return failedRoutes.size();
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
index 320788755b..d0160c9089 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
@@ -224,12 +224,6 @@ public Sink newFixedLengthSink(long contentLength) {
     return new FixedLengthSink(contentLength);
   }
 
-  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
-    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READ_RESPONSE_HEADERS;
-    requestBody.writeToSocket(sink);
-  }
-
   public Source newFixedLengthSource(long length) throws IOException {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_READING_RESPONSE_BODY;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
index 5c8fdfe667..3f878f633c 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
@@ -137,10 +137,6 @@ public Http2xStream(StreamAllocation streamAllocation, FramedConnection framedCo
     stream.writeTimeout().timeout(httpEngine.client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
   }
 
-  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
-    requestBody.writeToSocket(stream.getSink());
-  }
-
   @Override public void finishRequest() throws IOException {
     stream.getSink().close();
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
index 6baf560beb..a1845bfe22 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
@@ -73,12 +73,17 @@
 import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
 /**
- * Handles a single HTTP request/response pair. Each HTTP engine follows this lifecycle: <ol> <li>It
- * is created. <li>The HTTP request message is sent with sendRequest(). Once the request is sent it
- * is an error to modify the request headers. After sendRequest() has been called the request body
- * can be written to if it exists. <li>The HTTP response message is read with readResponse(). After
- * the response has been read the response headers and body can be read. All responses have a
- * response body input stream, though in some instances this stream is empty. </ol>
+ * Handles a single HTTP request/response pair. Each HTTP engine follows this lifecycle:
+ *
+ * <ol>
+ *     <li>It is created.
+ *     <li>The HTTP request message is sent with sendRequest(). Once the request is sent it is an
+ *         error to modify the request headers. After sendRequest() has been called the request body
+ *         can be written to if it exists.
+ *     <li>The HTTP response message is read with readResponse(). After the response has been read
+ *         the response headers and body can be read. All responses have a response body input
+ *         stream, though in some instances this stream is empty.
+ * </ol>
  *
  * <p>The request and response may be served by the HTTP response cache, by the network, or by both
  * in the event of a conditional GET.
@@ -151,9 +156,6 @@
    */
   private Response userResponse;
 
-  private Sink requestBodyOut;
-  private BufferedSink bufferedRequestBody;
-  private final boolean callerWritesRequestBody;
   private final boolean forWebSocket;
 
   /** The cache request currently being populated from a network response. */
@@ -163,22 +165,16 @@
   /**
    * @param request the HTTP request without a body. The body must be written via the engine's
    * request body stream.
-   * @param callerWritesRequestBody true for the {@code HttpURLConnection}-style interaction model
-   * where control flow is returned to the calling application to write the request body before the
-   * response body is readable.
    */
   public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
-      boolean callerWritesRequestBody, boolean forWebSocket, StreamAllocation streamAllocation,
-      RetryableSink requestBodyOut, Response priorResponse) {
+      boolean forWebSocket, StreamAllocation streamAllocation, Response priorResponse) {
     this.client = client;
     this.userRequest = request;
     this.bufferRequestBody = bufferRequestBody;
-    this.callerWritesRequestBody = callerWritesRequestBody;
     this.forWebSocket = forWebSocket;
     this.streamAllocation = streamAllocation != null
         ? streamAllocation
         : new StreamAllocation(client.connectionPool(), createAddress(client, request));
-    this.requestBodyOut = requestBodyOut;
     this.priorResponse = priorResponse;
   }
 
@@ -186,13 +182,12 @@ public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBod
    * Figures out what the response source will be, and opens a socket to that source if necessary.
    * Prepares the request headers and gets ready to start writing the request body if it exists.
    *
-   * @throws RequestException if there was a problem with request setup. Unrecoverable.
    * @throws RouteException if the was a problem during connection via a specific route. Sometimes
    * recoverable. See {@link #recover}.
    * @throws IOException if there was a problem while making a request. Sometimes recoverable. See
    * {@link #recover(IOException, boolean)}.
    */
-  public void sendRequest() throws RequestException, RouteException, IOException {
+  public void sendRequest() throws RouteException, IOException {
     if (cacheStrategy != null) return; // Already sent.
     if (httpStream != null) throw new IllegalStateException();
 
@@ -247,29 +242,6 @@ public void sendRequest() throws RequestException, RouteException, IOException {
     try {
       httpStream = connect();
       httpStream.setHttpEngine(this);
-
-      if (writeRequestHeadersEagerly()) {
-        long contentLength = OkHeaders.contentLength(request);
-        if (bufferRequestBody) {
-          if (contentLength > Integer.MAX_VALUE) {
-            throw new IllegalStateException("Use setFixedLengthStreamingMode() or "
-                + "setChunkedStreamingMode() for requests larger than 2 GiB.");
-          }
-
-          if (contentLength != -1) {
-            // Buffer a request body of a known length.
-            httpStream.writeRequestHeaders(networkRequest);
-            requestBodyOut = new RetryableSink((int) contentLength);
-          } else {
-            // Buffer a request body of an unknown length. Don't write request headers until the
-            // entire body is ready; otherwise we can't set the Content-Length header correctly.
-            requestBodyOut = new RetryableSink();
-          }
-        } else {
-          httpStream.writeRequestHeaders(networkRequest);
-          requestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);
-        }
-      }
       success = true;
     } finally {
       // If we're crashing on I/O or otherwise, don't leak the cache body.
@@ -279,19 +251,7 @@ public void sendRequest() throws RequestException, RouteException, IOException {
     }
   }
 
-  /**
-   * If the caller's control flow writes the request body, we need to create that stream
-   * immediately. And that means we need to immediately write the request headers, so we can
-   * start streaming the request body. (We may already have a request body if we're retrying a
-   * failed POST.)
-   */
-  private boolean writeRequestHeadersEagerly() {
-    return callerWritesRequestBody
-        && permitsRequestBody(networkRequest)
-        && requestBodyOut == null;
-  }
-
-  private HttpStream connect() throws RouteException, RequestException, IOException {
+  private HttpStream connect() throws RouteException, IOException {
     boolean doExtensiveHealthChecks = !networkRequest.method().equals("GET");
     return streamAllocation.newStream(client.connectTimeoutMillis(),
         client.readTimeoutMillis(), client.writeTimeoutMillis(),
@@ -317,29 +277,6 @@ boolean permitsRequestBody(Request request) {
     return HttpMethod.permitsRequestBody(request.method());
   }
 
-  /** Returns the request body or null if this request doesn't have a body. */
-  public Sink getRequestBody() {
-    if (cacheStrategy == null) throw new IllegalStateException();
-    return requestBodyOut;
-  }
-
-  public BufferedSink getBufferedRequestBody() {
-    BufferedSink result = bufferedRequestBody;
-    if (result != null) return result;
-    Sink requestBody = getRequestBody();
-    return requestBody != null
-        ? (bufferedRequestBody = Okio.buffer(requestBody))
-        : null;
-  }
-
-  public boolean hasResponse() {
-    return userResponse != null;
-  }
-
-  public Request getRequest() {
-    return userRequest;
-  }
-
   /** Returns the engine's response. */
   // TODO: the returned body will always be null.
   public Response getResponse() {
@@ -356,17 +293,13 @@ public Connection getConnection() {
    * engine that should be used for the retry if {@code e} is recoverable, or null if the failure is
    * permanent. Requests with a body can only be recovered if the body is buffered.
    */
-  public HttpEngine recover(IOException e, boolean routeException, Sink requestBodyOut) {
+  public HttpEngine recover(IOException e, boolean routeException) {
     streamAllocation.streamFailed(e);
 
     if (!client.retryOnConnectionFailure()) {
       return null; // The application layer has forbidden retries.
     }
 
-    if (requestBodyOut != null && !(requestBodyOut instanceof RetryableSink)) {
-      return null; // The body on this request cannot be retried.
-    }
-
     if (!isRecoverable(e, routeException)) {
       return null; // This exception is fatal.
     }
@@ -378,12 +311,8 @@ public HttpEngine recover(IOException e, boolean routeException, Sink requestBod
     StreamAllocation streamAllocation = close();
 
     // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
-        forWebSocket, streamAllocation, (RetryableSink) requestBodyOut, priorResponse);
-  }
-
-  public HttpEngine recover(IOException e, boolean routeException) {
-    return recover(e, routeException, requestBodyOut);
+    return new HttpEngine(client, userRequest, bufferRequestBody,
+        forWebSocket, streamAllocation, priorResponse);
   }
 
   private boolean isRecoverable(IOException e, boolean routeException) {
@@ -464,13 +393,6 @@ public void cancel() {
    * which itself must be used or released.
    */
   public StreamAllocation close() {
-    if (bufferedRequestBody != null) {
-      // This also closes the wrapped requestBodyOut.
-      closeQuietly(bufferedRequestBody);
-    } else if (requestBodyOut != null) {
-      closeQuietly(requestBodyOut);
-    }
-
     if (userResponse != null) {
       closeQuietly(userResponse.body());
     } else {
@@ -608,41 +530,9 @@ public void readResponse() throws IOException {
     if (forWebSocket) {
       httpStream.writeRequestHeaders(networkRequest);
       networkResponse = readNetworkResponse();
-    } else if (!callerWritesRequestBody) {
+    } else {
       networkResponse = new NetworkInterceptorChain(0, networkRequest,
           streamAllocation.connection()).proceed(networkRequest);
-    } else {
-      // Emit the request body's buffer so that everything is in requestBodyOut.
-      if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
-        bufferedRequestBody.emit();
-      }
-
-      // Emit the request headers if we haven't yet. We might have just learned the Content-Length.
-      if (sentRequestMillis == -1) {
-        if (OkHeaders.contentLength(networkRequest) == -1
-            && requestBodyOut instanceof RetryableSink) {
-          long contentLength = ((RetryableSink) requestBodyOut).contentLength();
-          networkRequest = networkRequest.newBuilder()
-              .header("Content-Length", Long.toString(contentLength))
-              .build();
-        }
-        httpStream.writeRequestHeaders(networkRequest);
-      }
-
-      // Write the request body to the socket.
-      if (requestBodyOut != null) {
-        if (bufferedRequestBody != null) {
-          // This also closes the wrapped requestBodyOut.
-          bufferedRequestBody.close();
-        } else {
-          requestBodyOut.close();
-        }
-        if (requestBodyOut instanceof RetryableSink) {
-          httpStream.writeRequestBody((RetryableSink) requestBodyOut);
-        }
-      }
-
-      networkResponse = readNetworkResponse();
     }
 
     receiveHeaders(networkResponse.headers());
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java b/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
index 34c471345c..fb47e27704 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpStream.java
@@ -35,11 +35,6 @@
   /** This should update the HTTP engine's sentRequestMillis field. */
   void writeRequestHeaders(Request request) throws IOException;
 
-  /**
-   * Sends the request body returned by {@link #createRequestBody} to the remote peer.
-   */
-  void writeRequestBody(RetryableSink requestBody) throws IOException;
-
   /** Flush the request to the underlying socket. */
   void finishRequest() throws IOException;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RequestException.java b/okhttp/src/main/java/okhttp3/internal/http/RequestException.java
deleted file mode 100644
index 56884c811f..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/RequestException.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-
-/**
- * Indicates a problem with interpreting a request. It may indicate there was a problem with the
- * request itself, or the environment being used to interpret the request (network failure, etc.).
- */
-public final class RequestException extends Exception {
-
-  public RequestException(IOException cause) {
-    super(cause);
-  }
-
-  @Override
-  public IOException getCause() {
-    return (IOException) super.getCause();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryableSink.java b/okhttp/src/main/java/okhttp3/internal/http/RetryableSink.java
deleted file mode 100644
index c0010d1898..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryableSink.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import okio.Buffer;
-import okio.Sink;
-import okio.Timeout;
-
-import static okhttp3.internal.Util.checkOffsetAndCount;
-
-/**
- * An HTTP request body that's completely buffered in memory. This allows the post body to be
- * transparently re-sent if the HTTP request must be sent multiple times.
- */
-public final class RetryableSink implements Sink {
-  private boolean closed;
-  private final int limit;
-  private final Buffer content = new Buffer();
-
-  public RetryableSink(int limit) {
-    this.limit = limit;
-  }
-
-  public RetryableSink() {
-    this(-1);
-  }
-
-  @Override public void close() throws IOException {
-    if (closed) return;
-    closed = true;
-    if (content.size() < limit) {
-      throw new ProtocolException(
-          "content-length promised " + limit + " bytes, but received " + content.size());
-    }
-  }
-
-  @Override public void write(Buffer source, long byteCount) throws IOException {
-    if (closed) throw new IllegalStateException("closed");
-    checkOffsetAndCount(source.size(), 0, byteCount);
-    if (limit != -1 && content.size() > limit - byteCount) {
-      throw new ProtocolException("exceeded content-length limit of " + limit + " bytes");
-    }
-    content.write(source, byteCount);
-  }
-
-  @Override public void flush() throws IOException {
-  }
-
-  @Override public Timeout timeout() {
-    return Timeout.NONE;
-  }
-
-  public long contentLength() throws IOException {
-    return content.size();
-  }
-
-  public void writeToSocket(Sink socketOut) throws IOException {
-    // Copy the content; otherwise we won't have data to retry.
-    Buffer buffer = new Buffer();
-    content.copyTo(buffer, 0, content.size());
-    socketOut.write(buffer, buffer.size());
-  }
-}
