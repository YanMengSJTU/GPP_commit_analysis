diff --git a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
index 16ef3bef7d..5b14352bbd 100644
--- a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
@@ -22,6 +22,7 @@
 import java.util.List;
 import java.util.Map;
 import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http2.Header;
 import okhttp3.internal.http2.Http2Codec;
@@ -434,4 +435,27 @@
     challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(0, challenges.size());
   }
+
+  @Test public void basicChallenge() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\"")
+        .build();
+    assertEquals(Arrays.asList(new Challenge("Basic", "protected area")),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void basicChallengeWithCharset() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
+        .build();
+    assertEquals(Arrays.asList(new Challenge("Basic", "protected area").withCharset(Util.UTF_8)),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void basicChallengeWithUnexpectedCharset() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"US-ASCII\"")
+        .build();
+    assertEquals(Collections.emptyList(), HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index a566babadb..29558b123f 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -24,6 +24,7 @@
 import java.net.HttpRetryException;
 import java.net.HttpURLConnection;
 import java.net.InetAddress;
+import java.net.PasswordAuthentication;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.ProxySelector;
@@ -42,7 +43,6 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.EnumSet;
-import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -58,7 +58,6 @@
 import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLProtocolException;
-import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.TrustManagerFactory;
@@ -1930,6 +1929,37 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     }
   }
 
+  @Test public void authenticateWithCharset() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
+        .setBody("Please authenticate with UTF-8."));
+    server.enqueue(new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate with ISO-8859-1."));
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator(
+        new PasswordAuthentication("username", "mötorhead".toCharArray())));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    // No authorization header for the first request...
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("Authorization"));
+
+    // UTF-8 encoding for the first credential.
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("Basic dXNlcm5hbWU6bcO2dG9yaGVhZA==", request2.getHeader("Authorization"));
+
+    // ISO-8859-1 encoding for the second credential.
+    RecordedRequest request3 = server.takeRequest();
+    assertEquals("Basic dXNlcm5hbWU6bfZ0b3JoZWFk", request3.getHeader("Authorization"));
+  }
+
   /** https://code.google.com/p/android/issues/detail?id=74026 */
   @Test public void authenticateWithGetAndTransparentGzip() throws Exception {
     MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 6c0ef5e455..4e9267eae3 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -29,7 +29,6 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.SynchronousQueue;
-
 import javax.net.ssl.HostnameVerifier;
 import okhttp3.Cache;
 import okhttp3.Call;
@@ -46,6 +45,7 @@
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
+import okhttp3.Route;
 import okhttp3.TestUtil;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
@@ -736,6 +736,74 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     }
   }
 
+  @Test public void recoverFromConnectionNoNewStreamsOnFollowUp() throws InterruptedException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.CANCEL.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location", "/foo"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final BlockingQueue<String> responses = new SynchronousQueue<>();
+    okhttp3.Authenticator authenticator = new okhttp3.Authenticator() {
+      @Override public Request authenticate(Route route, Response response) throws IOException {
+        responses.offer(response.body().string());
+        try {
+          latch.await();
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+        return response.request();
+      }
+    };
+
+    OkHttpClient blockingAuthClient = client.newBuilder()
+        .authenticator(authenticator)
+        .build();
+
+    Callback callback = new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        fail();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        responses.offer(response.body().string());
+      }
+    };
+
+    // Make the first request waiting until we get our auth challenge.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    blockingAuthClient.newCall(request).enqueue(callback);
+    String response1 = responses.take();
+    assertEquals("", response1);
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Now make the second request which will restrict the first HTTP/2 connection from creating new
+    // streams.
+    client.newCall(request).enqueue(callback);
+    String response2 = responses.take();
+    assertEquals("DEF", response2);
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Let the first request proceed. It should discard the the held HTTP/2 connection and get a new
+    // one.
+    latch.countDown();
+    String response3 = responses.take();
+    assertEquals("ABC", response3);
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
   @Test public void nonAsciiResponseHeader() throws Exception {
     server.enqueue(new MockResponse()
         .addHeaderLenient("Alpha", "α")
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
index b5440a4d02..2649510d35 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
@@ -54,7 +54,8 @@
       }
 
       if (auth != null) {
-        String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
+        String credential = Credentials.basic(
+            auth.getUserName(), new String(auth.getPassword()), challenge.charset());
         return request.newBuilder()
             .header(proxyAuthorization ? "Proxy-Authorization" : "Authorization", credential)
             .build();
diff --git a/okhttp/src/main/java/okhttp3/Challenge.java b/okhttp/src/main/java/okhttp3/Challenge.java
index 196de325b8..4b000eceda 100644
--- a/okhttp/src/main/java/okhttp3/Challenge.java
+++ b/okhttp/src/main/java/okhttp3/Challenge.java
@@ -15,18 +15,33 @@
  */
 package okhttp3;
 
+import java.nio.charset.Charset;
 import javax.annotation.Nullable;
 
-/** An RFC 2617 challenge. */
+import static okhttp3.internal.Util.ISO_8859_1;
+
+/** An RFC 7617 challenge. */
 public final class Challenge {
   private final String scheme;
   private final String realm;
+  private final Charset charset;
 
   public Challenge(String scheme, String realm) {
+    this(scheme, realm, ISO_8859_1);
+  }
+
+  private Challenge(String scheme, String realm, Charset charset) {
     if (scheme == null) throw new NullPointerException("scheme == null");
     if (realm == null) throw new NullPointerException("realm == null");
+    if (charset == null) throw new NullPointerException("charset == null");
     this.scheme = scheme;
     this.realm = realm;
+    this.charset = charset;
+  }
+
+  /** Returns a copy of this charset that expects a credential encoded with {@code charset}. */
+  public Challenge withCharset(Charset charset) {
+    return new Challenge(scheme, realm, charset);
   }
 
   /** Returns the authentication scheme, like {@code Basic}. */
@@ -39,20 +54,29 @@ public String realm() {
     return realm;
   }
 
+  /** Returns the charset that should be used to encode the credential. */
+  public Charset charset() {
+    return charset;
+  }
+
   @Override public boolean equals(@Nullable Object other) {
     return other instanceof Challenge
         && ((Challenge) other).scheme.equals(scheme)
-        && ((Challenge) other).realm.equals(realm);
+        && ((Challenge) other).realm.equals(realm)
+        && ((Challenge) other).charset.equals(charset);
   }
 
   @Override public int hashCode() {
     int result = 29;
     result = 31 * result + realm.hashCode();
     result = 31 * result + scheme.hashCode();
+    result = 31 * result + charset.hashCode();
     return result;
   }
 
   @Override public String toString() {
-    return scheme + " realm=\"" + realm + "\"";
+    return scheme
+        + " realm=\"" + realm + "\""
+        + " charset=\"" + charset + "\"";
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Credentials.java b/okhttp/src/main/java/okhttp3/Credentials.java
index efbc170161..a27ecae001 100644
--- a/okhttp/src/main/java/okhttp3/Credentials.java
+++ b/okhttp/src/main/java/okhttp3/Credentials.java
@@ -18,6 +18,8 @@
 import java.nio.charset.Charset;
 import okio.ByteString;
 
+import static okhttp3.internal.Util.ISO_8859_1;
+
 /** Factory for HTTP authorization credentials. */
 public final class Credentials {
   private Credentials() {
@@ -25,7 +27,7 @@ private Credentials() {
 
   /** Returns an auth credential for the Basic scheme. */
   public static String basic(String userName, String password) {
-    return basic(userName, password, Charset.forName("ISO-8859-1"));
+    return basic(userName, password, ISO_8859_1);
   }
 
   public static String basic(String userName, String password, Charset charset) {
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index ff66cdf885..68bbf5f6a2 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -58,6 +58,7 @@
   private static final ByteString UTF_32_LE_BOM = ByteString.decodeHex("ffff0000");
 
   public static final Charset UTF_8 = Charset.forName("UTF-8");
+  public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
   private static final Charset UTF_16_BE = Charset.forName("UTF-16BE");
   private static final Charset UTF_16_LE = Charset.forName("UTF-16LE");
   private static final Charset UTF_32_BE = Charset.forName("UTF-32BE");
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 13b52392a1..bc9999c42d 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -160,30 +160,44 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
     boolean foundPooledConnection = false;
     RealConnection result = null;
     Route selectedRoute = null;
+    Connection releasedConnection;
+    Socket toClose;
     synchronized (connectionPool) {
       if (released) throw new IllegalStateException("released");
       if (codec != null) throw new IllegalStateException("codec != null");
       if (canceled) throw new IOException("Canceled");
 
-      // Attempt to use an already-allocated connection.
-      RealConnection allocatedConnection = this.connection;
-      if (allocatedConnection != null && !allocatedConnection.noNewStreams) {
-        return allocatedConnection;
+      // Attempt to use an already-allocated connection. We need to be careful here because our
+      // already-allocated connection may have been restricted from creating new streams.
+      releasedConnection = this.connection;
+      toClose = releaseIfNoNewStreams();
+      if (this.connection != null) {
+        // We had an already-allocated connection and it's good.
+        result = this.connection;
+        releasedConnection = null;
       }
 
-      // Attempt to get a connection from the pool.
-      Internal.instance.get(connectionPool, address, this, null);
-      if (connection != null) {
-        foundPooledConnection = true;
-        result = connection;
-      } else {
-        selectedRoute = route;
+      if (result == null) {
+        // Attempt to get a connection from the pool.
+        Internal.instance.get(connectionPool, address, this, null);
+        if (connection != null) {
+          foundPooledConnection = true;
+          result = connection;
+        } else {
+          selectedRoute = route;
+        }
       }
     }
+    closeQuietly(toClose);
 
-    // If we found a pooled connection, we're done.
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
     if (foundPooledConnection) {
       eventListener.connectionAcquired(call, result);
+    }
+    if (result != null) {
+      // If we found an already-allocated or pooled connection, we're done.
       return result;
     }
 
@@ -257,6 +271,21 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
     return result;
   }
 
+  /**
+   * Releases the currently held connection and returns a socket to close if the held connection
+   * restricts new streams from being created. With HTTP/2 multiple requests share the same
+   * connection so it's possible that our connection is restricted from creating new streams during
+   * a follow-up request.
+   */
+  private Socket releaseIfNoNewStreams() {
+    assert (Thread.holdsLock(connectionPool));
+    RealConnection allocatedConnection = this.connection;
+    if (allocatedConnection != null && allocatedConnection.noNewStreams) {
+      return deallocate(false, false, true);
+    }
+    return null;
+  }
+
   public void streamFinished(boolean noNewStreams, HttpCodec codec, long bytesRead, IOException e) {
     eventListener.responseBodyEnd(call, bytesRead);
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
index 0ce0d07858..a1d6712906 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
@@ -29,6 +29,7 @@
 import okhttp3.HttpUrl;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.Util;
 
 import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
 import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
@@ -143,7 +144,7 @@ public static Headers varyHeaders(Headers requestHeaders, Headers responseHeader
   }
 
   /**
-   * Parse RFC 2617 challenges, also wrong ordered ones.
+   * Parse RFC 7617 challenges, also wrong ordered ones.
    * This API is only interested in the scheme name and realm.
    */
   public static List<Challenge> parseChallenges(Headers responseHeaders, String challengeHeader) {
@@ -158,17 +159,38 @@ public static Headers varyHeaders(Headers requestHeaders, Headers responseHeader
       int index = header.indexOf(' ');
       if (index == -1) continue;
 
+      String scheme = header.substring(0, index);
+      String realm = null;
+      String charset = null;
+
       Matcher matcher = PARAMETER.matcher(header);
       for (int i = index; matcher.find(i); i = matcher.end()) {
         if (header.regionMatches(true, matcher.start(1), "realm", 0, 5)) {
-          String scheme = header.substring(0, index);
-          String realm = matcher.group(3);
-          if (realm != null) {
-            challenges.add(new Challenge(scheme, realm));
-            break;
-          }
+          realm = matcher.group(3);
+        } else if (header.regionMatches(true, matcher.start(1), "charset", 0, 7)) {
+          charset = matcher.group(3);
+        }
+
+        if (realm != null && charset != null) {
+          break;
         }
       }
+
+      // "realm" is required.
+      if (realm == null) continue;
+
+      Challenge challenge = new Challenge(scheme, realm);
+
+      // If a charset is provided, RFC 7617 says it must be "UTF-8".
+      if (charset != null) {
+        if (charset.equalsIgnoreCase("UTF-8")) {
+          challenge = challenge.withCharset(Util.UTF_8);
+        } else {
+          continue;
+        }
+      }
+
+      challenges.add(challenge);
     }
     return challenges;
   }
