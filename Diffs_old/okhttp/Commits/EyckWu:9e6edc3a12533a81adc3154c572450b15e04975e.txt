diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
index 0b3f7afa85..6bdcf1c505 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
@@ -28,83 +28,83 @@ import java.util.Collections
 /** A cookie jar that delegates to a [java.net.CookieHandler]. */
 class JavaNetCookieJar(private val cookieHandler: CookieHandler) : CookieJar {
 
-  override fun saveFromResponse(url: HttpUrl, cookies: List<Cookie>) {
-    val cookieStrings = mutableListOf<String>()
-    for (cookie in cookies) {
-      cookieStrings.add(cookieToString(cookie, true))
-    }
-    val multimap = mapOf("Set-Cookie" to cookieStrings)
-    try {
-      cookieHandler.put(url.toUri(), multimap)
-    } catch (e: IOException) {
-      Platform.get().log(WARN, "Saving cookies failed for " + url.resolve("/...")!!, e)
+    override fun saveFromResponse(url: HttpUrl, cookies: List<Cookie>) {
+        val cookieStrings = mutableListOf<String>()
+        for (cookie in cookies) {
+            cookieStrings.add(cookieToString(cookie, true))
+        }
+        val multimap = mapOf("Set-Cookie" to cookieStrings)
+        try {
+            cookieHandler.put(url.toUri(), multimap)
+        } catch (e: IOException) {
+            Platform.get().log(WARN, "Saving cookies failed for " + url.resolve("/...")!!, e)
+        }
     }
-  }
 
-  override fun loadForRequest(url: HttpUrl): List<Cookie> {
-    val cookieHeaders = try {
-      // The RI passes all headers. We don't have 'em, so we don't pass 'em!
-      cookieHandler.get(url.toUri(), emptyMap<String, List<String>>())
-    } catch (e: IOException) {
-      Platform.get().log(WARN, "Loading cookies failed for " + url.resolve("/...")!!, e)
-      return emptyList()
-    }
+    override fun loadForRequest(url: HttpUrl): List<Cookie> {
+        val cookieHeaders = try {
+            // The RI passes all headers. We don't have 'em, so we don't pass 'em!
+            cookieHandler.get(url.toUri(), emptyMap<String, List<String>>())
+        } catch (e: IOException) {
+            Platform.get().log(WARN, "Loading cookies failed for " + url.resolve("/...")!!, e)
+            return emptyList()
+        }
 
-    var cookies: MutableList<Cookie>? = null
-    for ((key, value) in cookieHeaders) {
-      if (("Cookie".equals(key, ignoreCase = true) || "Cookie2".equals(key, ignoreCase = true)) &&
-          value.isNotEmpty()) {
-        for (header in value) {
-          if (cookies == null) cookies = mutableListOf()
-          cookies.addAll(decodeHeaderAsJavaNetCookies(url, header))
+        var cookies: MutableList<Cookie>? = null
+        for ((key, value) in cookieHeaders) {
+            if (("Cookie".equals(key, ignoreCase = true) || "Cookie2".equals(key, ignoreCase = true)) &&
+                    value.isNotEmpty()) {
+                for (header in value) {
+                    if (cookies == null) cookies = mutableListOf()
+                    cookies.addAll(decodeHeaderAsJavaNetCookies(url, header))
+                }
+            }
         }
-      }
-    }
 
-    return if (cookies != null) {
-      Collections.unmodifiableList(cookies)
-    } else {
-      emptyList()
+        return if (cookies != null) {
+            Collections.unmodifiableList(cookies)
+        } else {
+            emptyList()
+        }
     }
-  }
 
-  /**
-   * Convert a request header to OkHttp's cookies via [HttpCookie]. That extra step handles
-   * multiple cookies in a single request header, which [Cookie.parse] doesn't support.
-   */
-  private fun decodeHeaderAsJavaNetCookies(url: HttpUrl, header: String): List<Cookie> {
-    val result = mutableListOf<Cookie>()
-    var pos = 0
-    val limit = header.length
-    var pairEnd: Int
-    while (pos < limit) {
-      pairEnd = header.delimiterOffset(";,", pos, limit)
-      val equalsSign = header.delimiterOffset('=', pos, pairEnd)
-      val name = header.trimSubstring(pos, equalsSign)
-      if (name.startsWith("$")) {
-        pos = pairEnd + 1
-        continue
-      }
+    /**
+     * Convert a request header to OkHttp's cookies via [HttpCookie]. That extra step handles
+     * multiple cookies in a single request header, which [Cookie.parse] doesn't support.
+     */
+    private fun decodeHeaderAsJavaNetCookies(url: HttpUrl, header: String): List<Cookie> {
+        val result = mutableListOf<Cookie>()
+        var pos = 0
+        val limit = header.length
+        var pairEnd: Int
+        while (pos < limit) {
+            pairEnd = header.delimiterOffset(";,", pos, limit)
+            val equalsSign = header.delimiterOffset('=', pos, pairEnd)
+            val name = header.trimSubstring(pos, equalsSign)
+            if (name.startsWith("$")) {
+                pos = pairEnd + 1
+                continue
+            }
 
-      // We have either name=value or just a name.
-      var value = if (equalsSign < pairEnd) {
-        header.trimSubstring(equalsSign + 1, pairEnd)
-      } else {
-        ""
-      }
+            // We have either name=value or just a name.
+            var value = if (equalsSign < pairEnd) {
+                header.trimSubstring(equalsSign + 1, pairEnd)
+            } else {
+                ""
+            }
 
-      // If the value is "quoted", drop the quotes.
-      if (value.startsWith("\"") && value.endsWith("\"")) {
-        value = value.substring(1, value.length - 1)
-      }
+            // If the value is "quoted", drop the quotes.
+            if (value.startsWith("\"") && value.endsWith("\"")) {
+                value = value.substring(1, value.length - 1)
+            }
 
-      result.add(Cookie.Builder()
-          .name(name)
-          .value(value)
-          .domain(url.host)
-          .build())
-      pos = pairEnd + 1
+            result.add(Cookie.Builder()
+                    .name(name)
+                    .value(value)
+                    .domain(url.host)
+                    .build())
+            pos = pairEnd + 1
+        }
+        return result
     }
-    return result
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.kt b/okhttp/src/main/java/okhttp3/Dispatcher.kt
index 8e2daeea00..b171561a9a 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.kt
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.kt
@@ -33,215 +33,224 @@ import java.util.concurrent.TimeUnit
  * concurrently.
  */
 class Dispatcher constructor() {
-  /**
-   * The maximum number of requests to execute concurrently. Above this requests queue in memory,
-   * waiting for the running calls to complete.
-   *
-   * If more than [maxRequests] requests are in flight when this is invoked, those requests will
-   * remain in flight.
-   */
-  @get:Synchronized var maxRequests = 64
-    set(maxRequests) {
-      require(maxRequests >= 1) { "max < 1: $maxRequests" }
-      synchronized(this) {
-        field = maxRequests
-      }
-      promoteAndExecute()
+    /**
+     * The maximum number of requests to execute concurrently. Above this requests queue in memory,
+     * waiting for the running calls to complete.
+     *
+     * If more than [maxRequests] requests are in flight when this is invoked, those requests will
+     * remain in flight.
+     */
+    @get:Synchronized
+    var maxRequests = 64
+        set(maxRequests) {
+            require(maxRequests >= 1) { "max < 1: $maxRequests" }
+            synchronized(this) {
+                field = maxRequests
+            }
+            promoteAndExecute()
+        }
+
+    /**
+     * The maximum number of requests for each host to execute concurrently. This limits requests by
+     * the URL's host name. Note that concurrent requests to a single IP address may still exceed this
+     * limit: multiple hostnames may share an IP address or be routed through the same HTTP proxy.
+     *
+     * If more than [maxRequestsPerHost] requests are in flight when this is invoked, those requests
+     * will remain in flight.
+     *
+     * WebSocket connections to hosts **do not** count against this limit.
+     */
+    @get:Synchronized
+    var maxRequestsPerHost = 5
+        set(maxRequestsPerHost) {
+            require(maxRequestsPerHost >= 1) { "max < 1: $maxRequestsPerHost" }
+            synchronized(this) {
+                field = maxRequestsPerHost
+            }
+            promoteAndExecute()
+        }
+
+    /**
+     * A callback to be invoked each time the dispatcher becomes idle (when the number of running
+     * calls returns to zero).
+     *
+     * Note: The time at which a [call][Call] is considered idle is different depending on whether it
+     * was run [asynchronously][Call.enqueue] or [synchronously][Call.execute]. Asynchronous calls
+     * become idle after the [onResponse][Callback.onResponse] or [onFailure][Callback.onFailure]
+     * callback has returned. Synchronous calls become idle once [execute()][Call.execute] returns.
+     * This means that if you are doing synchronous calls the network layer will not truly be idle
+     * until every returned [Response] has been closed.
+     */
+    @set:Synchronized
+    @get:Synchronized
+    var idleCallback: Runnable? = null
+
+    private var executorServiceOrNull: ExecutorService? = null
+
+    @get:Synchronized
+    @get:JvmName("executorService")
+    val executorService: ExecutorService
+        get() {
+            if (executorServiceOrNull == null) {
+                executorServiceOrNull = ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS,
+                        SynchronousQueue(), threadFactory("OkHttp Dispatcher", false))
+            }
+            return executorServiceOrNull!!
+        }
+
+    /** Ready async calls in the order they'll be run. */
+    private val readyAsyncCalls = ArrayDeque<AsyncCall>()
+
+    /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
+    private val runningAsyncCalls = ArrayDeque<AsyncCall>()
+
+    /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
+    private val runningSyncCalls = ArrayDeque<RealCall>()
+
+    constructor(executorService: ExecutorService) : this() {
+        this.executorServiceOrNull = executorService
     }
 
-  /**
-   * The maximum number of requests for each host to execute concurrently. This limits requests by
-   * the URL's host name. Note that concurrent requests to a single IP address may still exceed this
-   * limit: multiple hostnames may share an IP address or be routed through the same HTTP proxy.
-   *
-   * If more than [maxRequestsPerHost] requests are in flight when this is invoked, those requests
-   * will remain in flight.
-   *
-   * WebSocket connections to hosts **do not** count against this limit.
-   */
-  @get:Synchronized var maxRequestsPerHost = 5
-    set(maxRequestsPerHost) {
-      require(maxRequestsPerHost >= 1) { "max < 1: $maxRequestsPerHost" }
-      synchronized(this) {
-        field = maxRequestsPerHost
-      }
-      promoteAndExecute()
+    internal fun enqueue(call: AsyncCall) {
+        synchronized(this) {
+            readyAsyncCalls.add(call)
+
+            // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to
+            // the same host.
+            if (!call.get().forWebSocket) {
+                val existingCall = findExistingCallWithHost(call.host())
+                if (existingCall != null) call.reuseCallsPerHostFrom(existingCall)
+            }
+        }
+        promoteAndExecute()
     }
 
-  /**
-   * A callback to be invoked each time the dispatcher becomes idle (when the number of running
-   * calls returns to zero).
-   *
-   * Note: The time at which a [call][Call] is considered idle is different depending on whether it
-   * was run [asynchronously][Call.enqueue] or [synchronously][Call.execute]. Asynchronous calls
-   * become idle after the [onResponse][Callback.onResponse] or [onFailure][Callback.onFailure]
-   * callback has returned. Synchronous calls become idle once [execute()][Call.execute] returns.
-   * This means that if you are doing synchronous calls the network layer will not truly be idle
-   * until every returned [Response] has been closed.
-   */
-  @set:Synchronized
-  @get:Synchronized
-  var idleCallback: Runnable? = null
-
-  private var executorServiceOrNull: ExecutorService? = null
-
-  @get:Synchronized
-  @get:JvmName("executorService") val executorService: ExecutorService
-    get() {
-      if (executorServiceOrNull == null) {
-        executorServiceOrNull = ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS,
-            SynchronousQueue(), threadFactory("OkHttp Dispatcher", false))
-      }
-      return executorServiceOrNull!!
+    private fun findExistingCallWithHost(host: String): AsyncCall? {
+        for (existingCall in runningAsyncCalls) {
+            if (existingCall.host() == host) return existingCall
+        }
+        for (existingCall in readyAsyncCalls) {
+            if (existingCall.host() == host) return existingCall
+        }
+        return null
     }
 
-  /** Ready async calls in the order they'll be run. */
-  private val readyAsyncCalls = ArrayDeque<AsyncCall>()
-
-  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
-  private val runningAsyncCalls = ArrayDeque<AsyncCall>()
-
-  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
-  private val runningSyncCalls = ArrayDeque<RealCall>()
-
-  constructor(executorService: ExecutorService) : this() {
-    this.executorServiceOrNull = executorService
-  }
-
-  internal fun enqueue(call: AsyncCall) {
-    synchronized(this) {
-      readyAsyncCalls.add(call)
-
-      // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to
-      // the same host.
-      if (!call.get().forWebSocket) {
-        val existingCall = findExistingCallWithHost(call.host())
-        if (existingCall != null) call.reuseCallsPerHostFrom(existingCall)
-      }
+    /**
+     * Cancel all calls currently enqueued or executing. Includes calls executed both
+     * [synchronously][Call.execute] and [asynchronously][Call.enqueue].
+     */
+    @Synchronized
+    fun cancelAll() {
+        for (call in readyAsyncCalls) {
+            call.get().cancel()
+        }
+        for (call in runningAsyncCalls) {
+            call.get().cancel()
+        }
+        for (call in runningSyncCalls) {
+            call.cancel()
+        }
     }
-    promoteAndExecute()
-  }
 
-  private fun findExistingCallWithHost(host: String): AsyncCall? {
-    for (existingCall in runningAsyncCalls) {
-      if (existingCall.host() == host) return existingCall
-    }
-    for (existingCall in readyAsyncCalls) {
-      if (existingCall.host() == host) return existingCall
-    }
-    return null
-  }
-
-  /**
-   * Cancel all calls currently enqueued or executing. Includes calls executed both
-   * [synchronously][Call.execute] and [asynchronously][Call.enqueue].
-   */
-  @Synchronized fun cancelAll() {
-    for (call in readyAsyncCalls) {
-      call.get().cancel()
+    /**
+     * Promotes eligible calls from [readyAsyncCalls] to [runningAsyncCalls] and runs them on the
+     * executor service. Must not be called with synchronization because executing calls can call
+     * into user code.
+     *
+     * @return true if the dispatcher is currently running calls.
+     */
+    private fun promoteAndExecute(): Boolean {
+        assert(!Thread.holdsLock(this))
+
+        val executableCalls = mutableListOf<AsyncCall>()
+        val isRunning: Boolean
+        synchronized(this) {
+            val i = readyAsyncCalls.iterator()
+            while (i.hasNext()) {
+                val asyncCall = i.next()
+
+                if (runningAsyncCalls.size >= this.maxRequests) break // Max capacity.
+                if (asyncCall.callsPerHost().get() >= this.maxRequestsPerHost) continue // Host max capacity.
+
+                i.remove()
+                asyncCall.callsPerHost().incrementAndGet()
+                executableCalls.add(asyncCall)
+                runningAsyncCalls.add(asyncCall)
+            }
+            isRunning = runningCallsCount() > 0
+        }
+
+        for (i in 0 until executableCalls.size) {
+            val asyncCall = executableCalls[i]
+            asyncCall.executeOn(executorService)
+        }
+
+        return isRunning
     }
-    for (call in runningAsyncCalls) {
-      call.get().cancel()
+
+    /** Used by `Call#execute` to signal it is in-flight. */
+    @Synchronized
+    internal fun executed(call: RealCall) {
+        runningSyncCalls.add(call)
     }
-    for (call in runningSyncCalls) {
-      call.cancel()
+
+    /** Used by `AsyncCall#run` to signal completion. */
+    internal fun finished(call: AsyncCall) {
+        call.callsPerHost().decrementAndGet()
+        finished(runningAsyncCalls, call)
     }
-  }
-
-  /**
-   * Promotes eligible calls from [readyAsyncCalls] to [runningAsyncCalls] and runs them on the
-   * executor service. Must not be called with synchronization because executing calls can call
-   * into user code.
-   *
-   * @return true if the dispatcher is currently running calls.
-   */
-  private fun promoteAndExecute(): Boolean {
-    assert(!Thread.holdsLock(this))
-
-    val executableCalls = mutableListOf<AsyncCall>()
-    val isRunning: Boolean
-    synchronized(this) {
-      val i = readyAsyncCalls.iterator()
-      while (i.hasNext()) {
-        val asyncCall = i.next()
-
-        if (runningAsyncCalls.size >= this.maxRequests) break // Max capacity.
-        if (asyncCall.callsPerHost().get() >= this.maxRequestsPerHost) continue // Host max capacity.
-
-        i.remove()
-        asyncCall.callsPerHost().incrementAndGet()
-        executableCalls.add(asyncCall)
-        runningAsyncCalls.add(asyncCall)
-      }
-      isRunning = runningCallsCount() > 0
+
+    /** Used by `Call#execute` to signal completion. */
+    internal fun finished(call: RealCall) {
+        finished(runningSyncCalls, call)
     }
 
-    for (i in 0 until executableCalls.size) {
-      val asyncCall = executableCalls[i]
-      asyncCall.executeOn(executorService)
+    private fun <T> finished(calls: Deque<T>, call: T) {
+        val idleCallback: Runnable?
+        synchronized(this) {
+            if (!calls.remove(call)) throw AssertionError("Call wasn't in-flight!")
+            idleCallback = this.idleCallback
+        }
+
+        val isRunning = promoteAndExecute()
+
+        if (!isRunning && idleCallback != null) {
+            idleCallback.run()
+        }
     }
 
-    return isRunning
-  }
-
-  /** Used by `Call#execute` to signal it is in-flight. */
-  @Synchronized internal fun executed(call: RealCall) {
-    runningSyncCalls.add(call)
-  }
-
-  /** Used by `AsyncCall#run` to signal completion. */
-  internal fun finished(call: AsyncCall) {
-    call.callsPerHost().decrementAndGet()
-    finished(runningAsyncCalls, call)
-  }
-
-  /** Used by `Call#execute` to signal completion. */
-  internal fun finished(call: RealCall) {
-    finished(runningSyncCalls, call)
-  }
-
-  private fun <T> finished(calls: Deque<T>, call: T) {
-    val idleCallback: Runnable?
-    synchronized(this) {
-      if (!calls.remove(call)) throw AssertionError("Call wasn't in-flight!")
-      idleCallback = this.idleCallback
+    /** Returns a snapshot of the calls currently awaiting execution. */
+    @Synchronized
+    fun queuedCalls(): List<Call> {
+        return Collections.unmodifiableList(readyAsyncCalls.map { it.get() })
     }
 
-    val isRunning = promoteAndExecute()
+    /** Returns a snapshot of the calls currently being executed. */
+    @Synchronized
+    fun runningCalls(): List<Call> {
+        return Collections.unmodifiableList(runningSyncCalls + runningAsyncCalls.map { it.get() })
+    }
 
-    if (!isRunning && idleCallback != null) {
-      idleCallback.run()
+    @Synchronized
+    fun queuedCallsCount(): Int = readyAsyncCalls.size
+
+    @Synchronized
+    fun runningCallsCount(): Int = runningAsyncCalls.size + runningSyncCalls.size
+
+    @JvmName("-deprecated_executorService")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "executorService"),
+            level = DeprecationLevel.WARNING)
+    fun executorService(): ExecutorService = executorService
+
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @Deprecated(
+            message = "moved to var",
+            replaceWith = ReplaceWith(expression = "this.idleCallback = Runnable { idleCallback() }"),
+            level = DeprecationLevel.WARNING)
+    @JvmName("-deprecated_setIdleCallback")
+    inline fun setIdleCallback(crossinline idleCallback: () -> Unit) {
+        this.idleCallback = Runnable { idleCallback() }
     }
-  }
-
-  /** Returns a snapshot of the calls currently awaiting execution. */
-  @Synchronized fun queuedCalls(): List<Call> {
-    return Collections.unmodifiableList(readyAsyncCalls.map { it.get() })
-  }
-
-  /** Returns a snapshot of the calls currently being executed. */
-  @Synchronized fun runningCalls(): List<Call> {
-    return Collections.unmodifiableList(runningSyncCalls + runningAsyncCalls.map { it.get() })
-  }
-
-  @Synchronized fun queuedCallsCount(): Int = readyAsyncCalls.size
-
-  @Synchronized fun runningCallsCount(): Int = runningAsyncCalls.size + runningSyncCalls.size
-
-  @JvmName("-deprecated_executorService")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "executorService"),
-      level = DeprecationLevel.WARNING)
-  fun executorService(): ExecutorService = executorService
-
-  // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
-  @Deprecated(
-      message = "moved to var",
-      replaceWith = ReplaceWith(expression = "this.idleCallback = Runnable { idleCallback() }"),
-      level = DeprecationLevel.WARNING)
-  @JvmName("-deprecated_setIdleCallback")
-  inline fun setIdleCallback(crossinline idleCallback: () -> Unit) {
-    this.idleCallback = Runnable { idleCallback() }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/Interceptor.kt b/okhttp/src/main/java/okhttp3/Interceptor.kt
index 43739a90b2..e6018f025b 100644
--- a/okhttp/src/main/java/okhttp3/Interceptor.kt
+++ b/okhttp/src/main/java/okhttp3/Interceptor.kt
@@ -24,43 +24,43 @@ import java.util.concurrent.TimeUnit
  * or response.
  */
 interface Interceptor {
-  @Throws(IOException::class)
-  fun intercept(chain: Chain): Response
+    @Throws(IOException::class)
+    fun intercept(chain: Chain): Response
 
-  companion object {
-    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
-    @JvmName("-deprecated_Interceptor")
-    inline operator fun invoke(
-      crossinline block: (chain: Chain) -> Response
-    ): Interceptor = object : Interceptor {
-      override fun intercept(chain: Chain) = block(chain)
+    companion object {
+        // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+        @JvmName("-deprecated_Interceptor")
+        inline operator fun invoke(
+                crossinline block: (chain: Chain) -> Response
+        ): Interceptor = object : Interceptor {
+            override fun intercept(chain: Chain) = block(chain)
+        }
     }
-  }
 
-  interface Chain {
-    fun request(): Request
+    interface Chain {
+        fun request(): Request
 
-    @Throws(IOException::class)
-    fun proceed(request: Request): Response
+        @Throws(IOException::class)
+        fun proceed(request: Request): Response
 
-    /**
-     * Returns the connection the request will be executed on. This is only available in the chains
-     * of network interceptors; for application interceptors this is always null.
-     */
-    fun connection(): Connection?
+        /**
+         * Returns the connection the request will be executed on. This is only available in the chains
+         * of network interceptors; for application interceptors this is always null.
+         */
+        fun connection(): Connection?
 
-    fun call(): Call
+        fun call(): Call
 
-    fun connectTimeoutMillis(): Int
+        fun connectTimeoutMillis(): Int
 
-    fun withConnectTimeout(timeout: Int, unit: TimeUnit): Chain
+        fun withConnectTimeout(timeout: Int, unit: TimeUnit): Chain
 
-    fun readTimeoutMillis(): Int
+        fun readTimeoutMillis(): Int
 
-    fun withReadTimeout(timeout: Int, unit: TimeUnit): Chain
+        fun withReadTimeout(timeout: Int, unit: TimeUnit): Chain
 
-    fun writeTimeoutMillis(): Int
+        fun writeTimeoutMillis(): Int
 
-    fun withWriteTimeout(timeout: Int, unit: TimeUnit): Chain
-  }
+        fun withWriteTimeout(timeout: Int, unit: TimeUnit): Chain
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.kt b/okhttp/src/main/java/okhttp3/OkHttpClient.kt
index 456ba9029e..57ae4c2efe 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.kt
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.kt
@@ -118,879 +118,907 @@ import kotlin.DeprecationLevel.ERROR
  * remain idle.
  */
 open class OkHttpClient internal constructor(
-  builder: Builder
+        builder: Builder
 ) : Cloneable, Call.Factory, WebSocket.Factory {
 
-  @get:JvmName("dispatcher") val dispatcher: Dispatcher = builder.dispatcher
+    @get:JvmName("dispatcher")
+    val dispatcher: Dispatcher = builder.dispatcher
 
-  @get:JvmName("connectionPool") val connectionPool: ConnectionPool = builder.connectionPool
+    @get:JvmName("connectionPool")
+    val connectionPool: ConnectionPool = builder.connectionPool
 
-  /**
-   * Returns an immutable list of interceptors that observe the full span of each call: from before
-   * the connection is established (if any) until after the response source is selected (either the
-   * origin server, cache, or both).
-   */
-  @get:JvmName("interceptors") val interceptors: List<Interceptor> =
-      builder.interceptors.toImmutableList()
-
-  /**
-   * Returns an immutable list of interceptors that observe a single network request and response.
-   * These interceptors must call [Interceptor.Chain.proceed] exactly once: it is an error for
-   * a network interceptor to short-circuit or repeat a network request.
-   */
-  @get:JvmName("networkInterceptors") val networkInterceptors: List<Interceptor> =
-      builder.networkInterceptors.toImmutableList()
-
-  @get:JvmName("eventListenerFactory") val eventListenerFactory: EventListener.Factory =
-      builder.eventListenerFactory
-
-  @get:JvmName("retryOnConnectionFailure") val retryOnConnectionFailure: Boolean =
-      builder.retryOnConnectionFailure
-
-  @get:JvmName("authenticator") val authenticator: Authenticator = builder.authenticator
-
-  @get:JvmName("followRedirects") val followRedirects: Boolean = builder.followRedirects
-
-  @get:JvmName("followSslRedirects") val followSslRedirects: Boolean = builder.followSslRedirects
-
-  @get:JvmName("cookieJar") val cookieJar: CookieJar = builder.cookieJar
-
-  @get:JvmName("cache") val cache: Cache? = builder.cache
-
-  @get:JvmName("dns") val dns: Dns = builder.dns
-
-  @get:JvmName("proxy") val proxy: Proxy? = builder.proxy
+    /**
+     * Returns an immutable list of interceptors that observe the full span of each call: from before
+     * the connection is established (if any) until after the response source is selected (either the
+     * origin server, cache, or both).
+     */
+    @get:JvmName("interceptors")
+    val interceptors: List<Interceptor> =
+            builder.interceptors.toImmutableList()
 
-  @get:JvmName("proxySelector") val proxySelector: ProxySelector = builder.proxySelector
+    /**
+     * Returns an immutable list of interceptors that observe a single network request and response.
+     * These interceptors must call [Interceptor.Chain.proceed] exactly once: it is an error for
+     * a network interceptor to short-circuit or repeat a network request.
+     */
+    @get:JvmName("networkInterceptors")
+    val networkInterceptors: List<Interceptor> =
+            builder.networkInterceptors.toImmutableList()
 
-  @get:JvmName("proxyAuthenticator") val proxyAuthenticator: Authenticator =
-      builder.proxyAuthenticator
+    @get:JvmName("eventListenerFactory")
+    val eventListenerFactory: EventListener.Factory =
+            builder.eventListenerFactory
 
-  @get:JvmName("socketFactory") val socketFactory: SocketFactory = builder.socketFactory
+    @get:JvmName("retryOnConnectionFailure")
+    val retryOnConnectionFailure: Boolean =
+            builder.retryOnConnectionFailure
 
-  private val sslSocketFactoryOrNull: SSLSocketFactory?
+    @get:JvmName("authenticator")
+    val authenticator: Authenticator = builder.authenticator
 
-  @get:JvmName("sslSocketFactory") val sslSocketFactory: SSLSocketFactory
-    get() = sslSocketFactoryOrNull ?: throw IllegalStateException("CLEARTEXT-only client")
+    @get:JvmName("followRedirects")
+    val followRedirects: Boolean = builder.followRedirects
 
-  @get:JvmName("connectionSpecs") val connectionSpecs: List<ConnectionSpec> =
-      builder.connectionSpecs
+    @get:JvmName("followSslRedirects")
+    val followSslRedirects: Boolean = builder.followSslRedirects
 
-  @get:JvmName("protocols") val protocols: List<Protocol> = builder.protocols
+    @get:JvmName("cookieJar")
+    val cookieJar: CookieJar = builder.cookieJar
 
-  @get:JvmName("hostnameVerifier") val hostnameVerifier: HostnameVerifier = builder.hostnameVerifier
+    @get:JvmName("cache")
+    val cache: Cache? = builder.cache
 
-  @get:JvmName("certificatePinner") val certificatePinner: CertificatePinner
+    @get:JvmName("dns")
+    val dns: Dns = builder.dns
 
-  @get:JvmName("certificateChainCleaner") val certificateChainCleaner: CertificateChainCleaner?
+    @get:JvmName("proxy")
+    val proxy: Proxy? = builder.proxy
 
-  /**
-   * Default call timeout (in milliseconds). By default there is no timeout for complete calls, but
-   * there is for the connect, write, and read actions within a call.
-   */
-  @get:JvmName("callTimeoutMillis") val callTimeoutMillis: Int = builder.callTimeout
+    @get:JvmName("proxySelector")
+    val proxySelector: ProxySelector = builder.proxySelector
 
-  /** Default connect timeout (in milliseconds). The default is 10 seconds. */
-  @get:JvmName("connectTimeoutMillis") val connectTimeoutMillis: Int = builder.connectTimeout
+    @get:JvmName("proxyAuthenticator")
+    val proxyAuthenticator: Authenticator =
+            builder.proxyAuthenticator
 
-  /** Default read timeout (in milliseconds). The default is 10 seconds. */
-  @get:JvmName("readTimeoutMillis") val readTimeoutMillis: Int = builder.readTimeout
+    @get:JvmName("socketFactory")
+    val socketFactory: SocketFactory = builder.socketFactory
 
-  /** Default write timeout (in milliseconds). The default is 10 seconds. */
-  @get:JvmName("writeTimeoutMillis") val writeTimeoutMillis: Int = builder.writeTimeout
+    private val sslSocketFactoryOrNull: SSLSocketFactory?
 
-  /** Web socket and HTTP/2 ping interval (in milliseconds). By default pings are not sent. */
-  @get:JvmName("pingIntervalMillis") val pingIntervalMillis: Int = builder.pingInterval
+    @get:JvmName("sslSocketFactory")
+    val sslSocketFactory: SSLSocketFactory
+        get() = sslSocketFactoryOrNull ?: throw IllegalStateException("CLEARTEXT-only client")
 
-  constructor() : this(Builder())
+    @get:JvmName("connectionSpecs")
+    val connectionSpecs: List<ConnectionSpec> =
+            builder.connectionSpecs
 
-  init {
-    if (builder.sslSocketFactoryOrNull != null || connectionSpecs.none { it.isTls }) {
-      this.sslSocketFactoryOrNull = builder.sslSocketFactoryOrNull
-      this.certificateChainCleaner = builder.certificateChainCleaner
-    } else {
-      val trustManager = Platform.get().platformTrustManager()
-      Platform.get().configureTrustManager(trustManager)
-      this.sslSocketFactoryOrNull = newSslSocketFactory(trustManager)
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager)
-    }
+    @get:JvmName("protocols")
+    val protocols: List<Protocol> = builder.protocols
 
-    if (sslSocketFactoryOrNull != null) {
-      Platform.get().configureSslSocketFactory(sslSocketFactoryOrNull)
-    }
+    @get:JvmName("hostnameVerifier")
+    val hostnameVerifier: HostnameVerifier = builder.hostnameVerifier
 
-    this.certificatePinner = builder.certificatePinner
-        .withCertificateChainCleaner(certificateChainCleaner)
+    @get:JvmName("certificatePinner")
+    val certificatePinner: CertificatePinner
 
-    check(null !in (interceptors as List<Interceptor?>)) {
-      "Null interceptor: $interceptors"
-    }
-    check(null !in (networkInterceptors as List<Interceptor?>)) {
-      "Null network interceptor: $networkInterceptors"
-    }
-  }
-
-  /** Prepares the [request] to be executed at some point in the future. */
-  override fun newCall(request: Request): Call {
-    return RealCall.newRealCall(this, request, forWebSocket = false)
-  }
-
-  /** Uses [request] to connect a new web socket. */
-  override fun newWebSocket(request: Request, listener: WebSocketListener): WebSocket {
-    val webSocket = RealWebSocket(request, listener, Random(), pingIntervalMillis.toLong())
-    webSocket.connect(this)
-    return webSocket
-  }
-
-  open fun newBuilder(): Builder = Builder(this)
-
-  @JvmName("-deprecated_dispatcher")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "dispatcher"),
-      level = DeprecationLevel.WARNING)
-  fun dispatcher(): Dispatcher = dispatcher
-
-  @JvmName("-deprecated_connectionPool")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "connectionPool"),
-      level = DeprecationLevel.WARNING)
-  fun connectionPool(): ConnectionPool = connectionPool
-
-  @JvmName("-deprecated_interceptors")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "interceptors"),
-      level = DeprecationLevel.WARNING)
-  fun interceptors(): List<Interceptor> = interceptors
-
-  @JvmName("-deprecated_networkInterceptors")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "networkInterceptors"),
-      level = DeprecationLevel.WARNING)
-  fun networkInterceptors(): List<Interceptor> = networkInterceptors
-
-  @JvmName("-deprecated_eventListenerFactory")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "eventListenerFactory"),
-      level = DeprecationLevel.WARNING)
-  fun eventListenerFactory(): EventListener.Factory = eventListenerFactory
-
-  @JvmName("-deprecated_retryOnConnectionFailure")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "retryOnConnectionFailure"),
-      level = DeprecationLevel.WARNING)
-  fun retryOnConnectionFailure(): Boolean = retryOnConnectionFailure
-
-  @JvmName("-deprecated_authenticator")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "authenticator"),
-      level = DeprecationLevel.WARNING)
-  fun authenticator(): Authenticator = authenticator
-
-  @JvmName("-deprecated_followRedirects")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "followRedirects"),
-      level = DeprecationLevel.WARNING)
-  fun followRedirects(): Boolean = followRedirects
-
-  @JvmName("-deprecated_followSslRedirects")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "followSslRedirects"),
-      level = DeprecationLevel.WARNING)
-  fun followSslRedirects(): Boolean = followSslRedirects
-
-  @JvmName("-deprecated_cookieJar")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "cookieJar"),
-      level = DeprecationLevel.WARNING)
-  fun cookieJar(): CookieJar = cookieJar
-
-  @JvmName("-deprecated_cache")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "cache"),
-      level = DeprecationLevel.WARNING)
-  fun cache(): Cache? = cache
-
-  @JvmName("-deprecated_dns")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "dns"),
-      level = DeprecationLevel.WARNING)
-  fun dns(): Dns = dns
-
-  @JvmName("-deprecated_proxy")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "proxy"),
-      level = DeprecationLevel.WARNING)
-  fun proxy(): Proxy? = proxy
-
-  @JvmName("-deprecated_proxySelector")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "proxySelector"),
-      level = DeprecationLevel.WARNING)
-  fun proxySelector(): ProxySelector = proxySelector
-
-  @JvmName("-deprecated_proxyAuthenticator")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "proxyAuthenticator"),
-      level = DeprecationLevel.WARNING)
-  fun proxyAuthenticator(): Authenticator = proxyAuthenticator
-
-  @JvmName("-deprecated_socketFactory")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "socketFactory"),
-      level = DeprecationLevel.WARNING)
-  fun socketFactory(): SocketFactory = socketFactory
-
-  @JvmName("-deprecated_sslSocketFactory")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "sslSocketFactory"),
-      level = DeprecationLevel.WARNING)
-  fun sslSocketFactory(): SSLSocketFactory = sslSocketFactory
-
-  @JvmName("-deprecated_connectionSpecs")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "connectionSpecs"),
-      level = DeprecationLevel.WARNING)
-  fun connectionSpecs(): List<ConnectionSpec> = connectionSpecs
-
-  @JvmName("-deprecated_protocols")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "protocols"),
-      level = DeprecationLevel.WARNING)
-  fun protocols(): List<Protocol> = protocols
-
-  @JvmName("-deprecated_hostnameVerifier")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "hostnameVerifier"),
-      level = DeprecationLevel.WARNING)
-  fun hostnameVerifier(): HostnameVerifier = hostnameVerifier
-
-  @JvmName("-deprecated_certificatePinner")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "certificatePinner"),
-      level = DeprecationLevel.WARNING)
-  fun certificatePinner(): CertificatePinner = certificatePinner
-
-  @JvmName("-deprecated_callTimeoutMillis")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "callTimeoutMillis"),
-      level = DeprecationLevel.WARNING)
-  fun callTimeoutMillis(): Int = callTimeoutMillis
-
-  @JvmName("-deprecated_connectTimeoutMillis")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "connectTimeoutMillis"),
-      level = DeprecationLevel.WARNING)
-  fun connectTimeoutMillis(): Int = connectTimeoutMillis
-
-  @JvmName("-deprecated_readTimeoutMillis")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "readTimeoutMillis"),
-      level = DeprecationLevel.WARNING)
-  fun readTimeoutMillis(): Int = readTimeoutMillis
-
-  @JvmName("-deprecated_writeTimeoutMillis")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "writeTimeoutMillis"),
-      level = DeprecationLevel.WARNING)
-  fun writeTimeoutMillis(): Int = writeTimeoutMillis
-
-  @JvmName("-deprecated_pingIntervalMillis")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "pingIntervalMillis"),
-      level = DeprecationLevel.WARNING)
-  fun pingIntervalMillis(): Int = pingIntervalMillis
-
-  class Builder constructor() {
-    // 调度器，异步请求执行的策略
-    internal var dispatcher: Dispatcher = Dispatcher()
-    // 连接池，管理http/http2连接复用以减少网络延迟
-    internal var connectionPool: ConnectionPool = ConnectionPool()
-    // 拦截器
-    internal val interceptors: MutableList<Interceptor> = mutableListOf()
-    // 网络拦截器
-    internal val networkInterceptors: MutableList<Interceptor> = mutableListOf()
-    // http 请求质量监控器
-    internal var eventListenerFactory: EventListener.Factory = EventListener.NONE.asFactory()
-    internal var retryOnConnectionFailure = true
-    // 身份鉴权
-    internal var authenticator: Authenticator = Authenticator.NONE
-    internal var followRedirects = true
-    internal var followSslRedirects = true
-    // 为HTTP cookie提供政策和持久性;
-    internal var cookieJar: CookieJar = CookieJar.NO_COOKIES
-    // 缓存http response到文件系统中便于重用，以节约时间合带宽
-    internal var cache: Cache? = null
-    // 域名解析服务
-    internal var dns: Dns = Dns.SYSTEM
-    internal var proxy: Proxy? = null
-    internal var proxySelector: ProxySelector = ProxySelector.getDefault() ?: NullProxySelector()
-    internal var proxyAuthenticator: Authenticator = Authenticator.NONE
-    internal var socketFactory: SocketFactory = SocketFactory.getDefault()
-    internal var sslSocketFactoryOrNull: SSLSocketFactory? = null
-    internal var connectionSpecs: List<ConnectionSpec> = DEFAULT_CONNECTION_SPECS
-    // http 实现的协议
-    internal var protocols: List<Protocol> = DEFAULT_PROTOCOLS
-    // 域名校验
-    internal var hostnameVerifier: HostnameVerifier = OkHostnameVerifier
-    // 证书约束
-    internal var certificatePinner: CertificatePinner = CertificatePinner.DEFAULT
-    internal var certificateChainCleaner: CertificateChainCleaner? = null
-    internal var callTimeout = 0
-    internal var connectTimeout = 10_000
-    internal var readTimeout = 10_000
-    internal var writeTimeout = 10_000
-    internal var pingInterval = 0
-
-    internal constructor(okHttpClient: OkHttpClient) : this() {
-      this.dispatcher = okHttpClient.dispatcher
-      this.connectionPool = okHttpClient.connectionPool
-      this.interceptors += okHttpClient.interceptors
-      this.networkInterceptors += okHttpClient.networkInterceptors
-      this.eventListenerFactory = okHttpClient.eventListenerFactory
-      this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure
-      this.authenticator = okHttpClient.authenticator
-      this.followRedirects = okHttpClient.followRedirects
-      this.followSslRedirects = okHttpClient.followSslRedirects
-      this.cookieJar = okHttpClient.cookieJar
-      this.cache = okHttpClient.cache
-      this.dns = okHttpClient.dns
-      this.proxy = okHttpClient.proxy
-      this.proxySelector = okHttpClient.proxySelector
-      this.proxyAuthenticator = okHttpClient.proxyAuthenticator
-      this.socketFactory = okHttpClient.socketFactory
-      this.sslSocketFactoryOrNull = okHttpClient.sslSocketFactoryOrNull
-      this.connectionSpecs = okHttpClient.connectionSpecs
-      this.protocols = okHttpClient.protocols
-      this.hostnameVerifier = okHttpClient.hostnameVerifier
-      this.certificatePinner = okHttpClient.certificatePinner
-      this.certificateChainCleaner = okHttpClient.certificateChainCleaner
-      this.callTimeout = okHttpClient.callTimeoutMillis
-      this.connectTimeout = okHttpClient.connectTimeoutMillis
-      this.readTimeout = okHttpClient.readTimeoutMillis
-      this.writeTimeout = okHttpClient.writeTimeoutMillis
-      this.pingInterval = okHttpClient.pingIntervalMillis
-    }
+    @get:JvmName("certificateChainCleaner")
+    val certificateChainCleaner: CertificateChainCleaner?
 
     /**
-     * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
+     * Default call timeout (in milliseconds). By default there is no timeout for complete calls, but
+     * there is for the connect, write, and read actions within a call.
      */
-    fun dispatcher(dispatcher: Dispatcher) = apply {
-      this.dispatcher = dispatcher
+    @get:JvmName("callTimeoutMillis")
+    val callTimeoutMillis: Int = builder.callTimeout
+
+    /** Default connect timeout (in milliseconds). The default is 10 seconds. */
+    @get:JvmName("connectTimeoutMillis")
+    val connectTimeoutMillis: Int = builder.connectTimeout
+
+    /** Default read timeout (in milliseconds). The default is 10 seconds. */
+    @get:JvmName("readTimeoutMillis")
+    val readTimeoutMillis: Int = builder.readTimeout
+
+    /** Default write timeout (in milliseconds). The default is 10 seconds. */
+    @get:JvmName("writeTimeoutMillis")
+    val writeTimeoutMillis: Int = builder.writeTimeout
+
+    /** Web socket and HTTP/2 ping interval (in milliseconds). By default pings are not sent. */
+    @get:JvmName("pingIntervalMillis")
+    val pingIntervalMillis: Int = builder.pingInterval
+
+    constructor() : this(Builder())
+
+    init {
+        if (builder.sslSocketFactoryOrNull != null || connectionSpecs.none { it.isTls }) {
+            this.sslSocketFactoryOrNull = builder.sslSocketFactoryOrNull
+            this.certificateChainCleaner = builder.certificateChainCleaner
+        } else {
+            val trustManager = Platform.get().platformTrustManager()
+            Platform.get().configureTrustManager(trustManager)
+            this.sslSocketFactoryOrNull = newSslSocketFactory(trustManager)
+            this.certificateChainCleaner = CertificateChainCleaner.get(trustManager)
+        }
+
+        if (sslSocketFactoryOrNull != null) {
+            Platform.get().configureSslSocketFactory(sslSocketFactoryOrNull)
+        }
+
+        this.certificatePinner = builder.certificatePinner
+                .withCertificateChainCleaner(certificateChainCleaner)
+
+        check(null !in (interceptors as List<Interceptor?>)) {
+            "Null interceptor: $interceptors"
+        }
+        check(null !in (networkInterceptors as List<Interceptor?>)) {
+            "Null network interceptor: $networkInterceptors"
+        }
     }
 
-    /**
-     * Sets the connection pool used to recycle HTTP and HTTPS connections.
-     *
-     * If unset, a new connection pool will be used.
-     */
-    fun connectionPool(connectionPool: ConnectionPool) = apply {
-      this.connectionPool = connectionPool
+    /** Prepares the [request] to be executed at some point in the future. */
+    override fun newCall(request: Request): Call {
+        return RealCall.newRealCall(this, request, forWebSocket = false)
     }
 
-    /**
-     * Returns a modifiable list of interceptors that observe the full span of each call: from
-     * before the connection is established (if any) until after the response source is selected
-     * (either the origin server, cache, or both).
-     */
-    fun interceptors(): MutableList<Interceptor> = interceptors
-
-    fun addInterceptor(interceptor: Interceptor) = apply {
-      interceptors += interceptor
+    /** Uses [request] to connect a new web socket. */
+    override fun newWebSocket(request: Request, listener: WebSocketListener): WebSocket {
+        val webSocket = RealWebSocket(request, listener, Random(), pingIntervalMillis.toLong())
+        webSocket.connect(this)
+        return webSocket
     }
 
-    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
-    @JvmName("-deprecated_addInterceptor")
-    inline fun addInterceptor(
-      crossinline interceptor: (chain: Interceptor.Chain) -> Response
-    ) = apply {
-      addInterceptor(object : Interceptor {
-        override fun intercept(chain: Interceptor.Chain): Response = interceptor(chain)
-      })
-    }
-
-    /**
-     * Returns a modifiable list of interceptors that observe a single network request and response.
-     * These interceptors must call [Interceptor.Chain.proceed] exactly once: it is an error for a
-     * network interceptor to short-circuit or repeat a network request.
-     */
-    fun networkInterceptors(): MutableList<Interceptor> = networkInterceptors
+    open fun newBuilder(): Builder = Builder(this)
 
-    fun addNetworkInterceptor(interceptor: Interceptor) = apply {
-      networkInterceptors += interceptor
-    }
+    @JvmName("-deprecated_dispatcher")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "dispatcher"),
+            level = DeprecationLevel.WARNING)
+    fun dispatcher(): Dispatcher = dispatcher
 
-    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
-    @JvmName("-deprecated_addNetworkInterceptor")
-    inline fun addNetworkInterceptor(
-      crossinline interceptor: (chain: Interceptor.Chain) -> Response
-    ) = apply {
-      addInterceptor(object : Interceptor {
-        override fun intercept(chain: Interceptor.Chain): Response = interceptor(chain)
-      })
-    }
+    @JvmName("-deprecated_connectionPool")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "connectionPool"),
+            level = DeprecationLevel.WARNING)
+    fun connectionPool(): ConnectionPool = connectionPool
 
-    /**
-     * Configure a single client scoped listener that will receive all analytic events for this
-     * client.
-     *
-     * @see EventListener for semantics and restrictions on listener implementations.
-     */
-    fun eventListener(eventListener: EventListener) = apply {
-      this.eventListenerFactory = eventListener.asFactory()
-    }
+    @JvmName("-deprecated_interceptors")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "interceptors"),
+            level = DeprecationLevel.WARNING)
+    fun interceptors(): List<Interceptor> = interceptors
 
-    /**
-     * Configure a factory to provide per-call scoped listeners that will receive analytic events
-     * for this client.
-     *
-     * @see EventListener for semantics and restrictions on listener implementations.
-     */
-    fun eventListenerFactory(eventListenerFactory: EventListener.Factory) = apply {
-      this.eventListenerFactory = eventListenerFactory
-    }
+    @JvmName("-deprecated_networkInterceptors")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "networkInterceptors"),
+            level = DeprecationLevel.WARNING)
+    fun networkInterceptors(): List<Interceptor> = networkInterceptors
 
-    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
     @JvmName("-deprecated_eventListenerFactory")
-    inline fun eventListenerFactory(crossinline block: (call: Call) -> EventListener) = apply {
-      eventListenerFactory(object : EventListener.Factory {
-        override fun create(call: Call) = block(call)
-      })
-    }
-
-    /**
-     * Configure this client to retry or not when a connectivity problem is encountered. By default,
-     * this client silently recovers from the following problems:
-     *
-     * * **Unreachable IP addresses.** If the URL's host has multiple IP addresses,
-     *   failure to reach any individual IP address doesn't fail the overall request. This can
-     *   increase availability of multi-homed services.
-     *
-     * * **Stale pooled connections.** The [ConnectionPool] reuses sockets
-     *   to decrease request latency, but these connections will occasionally time out.
-     *
-     * * **Unreachable proxy servers.** A [ProxySelector] can be used to
-     *   attempt multiple proxy servers in sequence, eventually falling back to a direct
-     *   connection.
-     *
-     * Set this to false to avoid retrying requests when doing so is destructive. In this case the
-     * calling application should do its own recovery of connectivity failures.
-     */
-    fun retryOnConnectionFailure(retryOnConnectionFailure: Boolean) = apply {
-      this.retryOnConnectionFailure = retryOnConnectionFailure
-    }
-
-    /**
-     * Sets the authenticator used to respond to challenges from origin servers. Use
-     * [proxyAuthenticator] to set the authenticator for proxy servers.
-     *
-     * If unset, the [no authentication will be attempted][Authenticator.NONE].
-     */
-    fun authenticator(authenticator: Authenticator) = apply {
-      this.authenticator = authenticator
-    }
-
-    /** Configure this client to follow redirects. If unset, redirects will be followed. */
-    fun followRedirects(followRedirects: Boolean) = apply {
-      this.followRedirects = followRedirects
-    }
-
-    /**
-     * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
-     *
-     * If unset, protocol redirects will be followed. This is different than the built-in
-     * `HttpURLConnection`'s default.
-     */
-    fun followSslRedirects(followProtocolRedirects: Boolean) = apply {
-      this.followSslRedirects = followProtocolRedirects
-    }
-
-    /**
-     * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
-     * outgoing HTTP requests.
-     *
-     * If unset, [no cookies][CookieJar.NO_COOKIES] will be accepted nor provided.
-     */
-    fun cookieJar(cookieJar: CookieJar) = apply {
-      this.cookieJar = cookieJar
-    }
-
-    /** Sets the response cache to be used to read and write cached responses. */
-    fun cache(cache: Cache?) = apply {
-      this.cache = cache
-    }
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "eventListenerFactory"),
+            level = DeprecationLevel.WARNING)
+    fun eventListenerFactory(): EventListener.Factory = eventListenerFactory
 
-    /**
-     * Sets the DNS service used to lookup IP addresses for hostnames.
-     *
-     * If unset, the [system-wide default][Dns.SYSTEM] DNS will be used.
-     */
-    fun dns(dns: Dns) = apply {
-      this.dns = dns
-    }
+    @JvmName("-deprecated_retryOnConnectionFailure")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "retryOnConnectionFailure"),
+            level = DeprecationLevel.WARNING)
+    fun retryOnConnectionFailure(): Boolean = retryOnConnectionFailure
 
-    /**
-     * Sets the HTTP proxy that will be used by connections created by this client. This takes
-     * precedence over [proxySelector], which is only honored when this proxy is null (which it is
-     * by default). To disable proxy use completely, call `proxy(Proxy.NO_PROXY)`.
-     */
-    fun proxy(proxy: Proxy?) = apply {
-      this.proxy = proxy
-    }
+    @JvmName("-deprecated_authenticator")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "authenticator"),
+            level = DeprecationLevel.WARNING)
+    fun authenticator(): Authenticator = authenticator
 
-    /**
-     * Sets the proxy selection policy to be used if no [proxy][proxy] is specified explicitly. The
-     * proxy selector may return multiple proxies; in that case they will be tried in sequence until
-     * a successful connection is established.
-     *
-     * If unset, the [system-wide default][ProxySelector.getDefault] proxy selector will be used.
-     */
-    fun proxySelector(proxySelector: ProxySelector) = apply {
-      this.proxySelector = proxySelector
-    }
+    @JvmName("-deprecated_followRedirects")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "followRedirects"),
+            level = DeprecationLevel.WARNING)
+    fun followRedirects(): Boolean = followRedirects
 
-    /**
-     * Sets the authenticator used to respond to challenges from proxy servers. Use [authenticator]
-     * to set the authenticator for origin servers.
-     *
-     * If unset, the [no authentication will be attempted][Authenticator.NONE].
-     */
-    fun proxyAuthenticator(proxyAuthenticator: Authenticator) = apply {
-      this.proxyAuthenticator = proxyAuthenticator
-    }
+    @JvmName("-deprecated_followSslRedirects")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "followSslRedirects"),
+            level = DeprecationLevel.WARNING)
+    fun followSslRedirects(): Boolean = followSslRedirects
 
-    /**
-     * Sets the socket factory used to create connections. OkHttp only uses the parameterless
-     * [SocketFactory.createSocket] method to create unconnected sockets. Overriding this method,
-     * e. g., allows the socket to be bound to a specific local address.
-     *
-     * If unset, the [system-wide default][SocketFactory.getDefault] socket factory will be used.
-     */
-    fun socketFactory(socketFactory: SocketFactory) = apply {
-      require(socketFactory !is SSLSocketFactory) { "socketFactory instanceof SSLSocketFactory" }
-      this.socketFactory = socketFactory
-    }
+    @JvmName("-deprecated_cookieJar")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "cookieJar"),
+            level = DeprecationLevel.WARNING)
+    fun cookieJar(): CookieJar = cookieJar
 
-    /**
-     * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
-     * be used.
-     *
-     * @deprecated [SSLSocketFactory] does not expose its [X509TrustManager], which is a field that
-     *     OkHttp needs to build a clean certificate chain. This method instead must use reflection
-     *     to extract the trust manager. Applications should prefer to call
-     *     `sslSocketFactory(SSLSocketFactory, X509TrustManager)`, which avoids such reflection.
-     */
+    @JvmName("-deprecated_cache")
     @Deprecated(
-        message = "Use the sslSocketFactory overload that accepts a X509TrustManager.",
-        level = ERROR
-    )
-    fun sslSocketFactory(sslSocketFactory: SSLSocketFactory) = apply {
-      this.sslSocketFactoryOrNull = sslSocketFactory
-      this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory)
-    }
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "cache"),
+            level = DeprecationLevel.WARNING)
+    fun cache(): Cache? = cache
 
-    /**
-     * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
-     * system defaults will be used.
-     *
-     * Most applications should not call this method, and instead use the system defaults. Those
-     * classes include special optimizations that can be lost if the implementations are decorated.
-     *
-     * If necessary, you can create and configure the defaults yourself with the following code:
-     *
-     * ```
-     * TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-     * TrustManagerFactory.getDefaultAlgorithm());
-     * trustManagerFactory.init((KeyStore) null);
-     * TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-     * if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-     *     throw new IllegalStateException("Unexpected default trust managers:"
-     *         + Arrays.toString(trustManagers));
-     * }
-     * X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
-     *
-     * SSLContext sslContext = SSLContext.getInstance("TLS");
-     * sslContext.init(null, new TrustManager[] { trustManager }, null);
-     * SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
-     *
-     * OkHttpClient client = new OkHttpClient.Builder()
-     *     .sslSocketFactory(sslSocketFactory, trustManager)
-     *     .build();
-     * ```
-     */
-    fun sslSocketFactory(
-      sslSocketFactory: SSLSocketFactory,
-      trustManager: X509TrustManager
-    ) = apply {
-      this.sslSocketFactoryOrNull = sslSocketFactory
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager)
-    }
+    @JvmName("-deprecated_dns")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "dns"),
+            level = DeprecationLevel.WARNING)
+    fun dns(): Dns = dns
 
-    fun connectionSpecs(connectionSpecs: List<ConnectionSpec>) = apply {
-      this.connectionSpecs = connectionSpecs.toImmutableList()
-    }
+    @JvmName("-deprecated_proxy")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "proxy"),
+            level = DeprecationLevel.WARNING)
+    fun proxy(): Proxy? = proxy
 
-    /**
-     * Configure the protocols used by this client to communicate with remote servers. By default
-     * this client will prefer the most efficient transport available, falling back to more
-     * ubiquitous protocols. Applications should only call this method to avoid specific
-     * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
-     *
-     * The following protocols are currently supported:
-     *
-     * * [http/1.1][rfc_2616]
-     * * [h2][rfc_7540]
-     * * [h2 with prior knowledge(cleartext only)][rfc_7540_34]
-     *
-     * **This is an evolving set.** Future releases include support for transitional
-     * protocols. The http/1.1 transport will never be dropped.
-     *
-     * If multiple protocols are specified, [ALPN][alpn] will be used to negotiate a transport.
-     * Protocol negotiation is only attempted for HTTPS URLs.
-     *
-     * [Protocol.HTTP_1_0] is not supported in this set. Requests are initiated with `HTTP/1.1`. If
-     * the server responds with `HTTP/1.0`, that will be exposed by [Response.protocol].
-     *
-     * [alpn]: http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg
-     * [rfc_2616]: http://www.w3.org/Protocols/rfc2616/rfc2616.html
-     * [rfc_7540]: https://tools.ietf.org/html/rfc7540
-     * [rfc_7540_34]: https://tools.ietf.org/html/rfc7540#section-3.4
-     *
-     * @param protocols the protocols to use, in order of preference. If the list contains
-     *     [Protocol.H2_PRIOR_KNOWLEDGE] then that must be the only protocol and HTTPS URLs will not
-     *     be supported. Otherwise the list must contain [Protocol.HTTP_1_1]. The list must
-     *     not contain null or [Protocol.HTTP_1_0].
-     */
-    fun protocols(protocols: List<Protocol>) = apply {
-      // Create a private copy of the list.
-      val protocolsCopy = protocols.toMutableList()
-
-      // Validate that the list has everything we require and nothing we forbid.
-      require(Protocol.H2_PRIOR_KNOWLEDGE in protocolsCopy || HTTP_1_1 in protocolsCopy) {
-        "protocols must contain h2_prior_knowledge or http/1.1: $protocolsCopy"
-      }
-      require(Protocol.H2_PRIOR_KNOWLEDGE !in protocolsCopy || protocolsCopy.size <= 1) {
-        "protocols containing h2_prior_knowledge cannot use other protocols: $protocolsCopy"
-      }
-      require(Protocol.HTTP_1_0 !in protocolsCopy) {
-        "protocols must not contain http/1.0: $protocolsCopy"
-      }
-      require(null !in (protocols as List<Protocol?>)) {
-        "protocols must not contain null"
-      }
-
-      // Remove protocolsCopy that we no longer support.
-      @Suppress("DEPRECATION")
-      protocolsCopy.remove(Protocol.SPDY_3)
-
-      // Assign as an unmodifiable list. This is effectively immutable.
-      this.protocols = Collections.unmodifiableList(protocols)
-    }
+    @JvmName("-deprecated_proxySelector")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "proxySelector"),
+            level = DeprecationLevel.WARNING)
+    fun proxySelector(): ProxySelector = proxySelector
 
-    /**
-     * Sets the verifier used to confirm that response certificates apply to requested hostnames for
-     * HTTPS connections.
-     *
-     * If unset, a default hostname verifier will be used.
-     */
-    fun hostnameVerifier(hostnameVerifier: HostnameVerifier) = apply {
-      this.hostnameVerifier = hostnameVerifier
-    }
+    @JvmName("-deprecated_proxyAuthenticator")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "proxyAuthenticator"),
+            level = DeprecationLevel.WARNING)
+    fun proxyAuthenticator(): Authenticator = proxyAuthenticator
 
-    /**
-     * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
-     * connections rely on only the [SSL socket factory][sslSocketFactory] to establish trust.
-     * Pinning certificates avoids the need to trust certificate authorities.
-     */
-    fun certificatePinner(certificatePinner: CertificatePinner) = apply {
-      this.certificatePinner = certificatePinner
-    }
+    @JvmName("-deprecated_socketFactory")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "socketFactory"),
+            level = DeprecationLevel.WARNING)
+    fun socketFactory(): SocketFactory = socketFactory
 
-    /**
-     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
-     * must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
-     *
-     * The call timeout spans the entire call: resolving DNS, connecting, writing the request body,
-     * server processing, and reading the response body. If the call requires redirects or retries
-     * all must complete within one timeout period.
-     *
-     * The default value is 0 which imposes no timeout.
-     */
-    fun callTimeout(timeout: Long, unit: TimeUnit) = apply {
-      callTimeout = checkDuration("timeout", timeout, unit)
-    }
+    @JvmName("-deprecated_sslSocketFactory")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "sslSocketFactory"),
+            level = DeprecationLevel.WARNING)
+    fun sslSocketFactory(): SSLSocketFactory = sslSocketFactory
 
-    /**
-     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
-     * must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
-     *
-     * The call timeout spans the entire call: resolving DNS, connecting, writing the request body,
-     * server processing, and reading the response body. If the call requires redirects or retries
-     * all must complete within one timeout period.
-     *
-     * The default value is 0 which imposes no timeout.
-     */
-    @IgnoreJRERequirement
-    fun callTimeout(duration: Duration) = apply {
-      callTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
-    }
+    @JvmName("-deprecated_connectionSpecs")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "connectionSpecs"),
+            level = DeprecationLevel.WARNING)
+    fun connectionSpecs(): List<ConnectionSpec> = connectionSpecs
 
-    /**
-     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
-     * otherwise values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
-     *
-     * The connect timeout is applied when connecting a TCP socket to the target host. The default
-     * value is 10 seconds.
-     */
-    fun connectTimeout(timeout: Long, unit: TimeUnit) = apply {
-      connectTimeout = checkDuration("timeout", timeout, unit)
-    }
+    @JvmName("-deprecated_protocols")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "protocols"),
+            level = DeprecationLevel.WARNING)
+    fun protocols(): List<Protocol> = protocols
 
-    /**
-     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
-     * otherwise values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
-     *
-     * The connect timeout is applied when connecting a TCP socket to the target host. The default
-     * value is 10 seconds.
-     */
-    @IgnoreJRERequirement
-    fun connectTimeout(duration: Duration) = apply {
-      connectTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
-    }
+    @JvmName("-deprecated_hostnameVerifier")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "hostnameVerifier"),
+            level = DeprecationLevel.WARNING)
+    fun hostnameVerifier(): HostnameVerifier = hostnameVerifier
 
-    /**
-     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
-     *
-     * The read timeout is applied to both the TCP socket and for individual read IO operations
-     * including on [Source] of the [Response]. The default value is 10 seconds.
-     *
-     * @see Socket.setSoTimeout
-     * @see Source.timeout
-     */
-    fun readTimeout(timeout: Long, unit: TimeUnit) = apply {
-      readTimeout = checkDuration("timeout", timeout, unit)
-    }
+    @JvmName("-deprecated_certificatePinner")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "certificatePinner"),
+            level = DeprecationLevel.WARNING)
+    fun certificatePinner(): CertificatePinner = certificatePinner
 
-    /**
-     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
-     *
-     * The read timeout is applied to both the TCP socket and for individual read IO operations
-     * including on [Source] of the [Response]. The default value is 10 seconds.
-     *
-     * @see Socket.setSoTimeout
-     * @see Source.timeout
-     */
-    @IgnoreJRERequirement
-    fun readTimeout(duration: Duration) = apply {
-      readTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
-    }
+    @JvmName("-deprecated_callTimeoutMillis")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "callTimeoutMillis"),
+            level = DeprecationLevel.WARNING)
+    fun callTimeoutMillis(): Int = callTimeoutMillis
 
-    /**
-     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
-     *
-     * The write timeout is applied for individual write IO operations. The default value is 10
-     * seconds.
-     *
-     * @see Sink.timeout
-     */
-    fun writeTimeout(timeout: Long, unit: TimeUnit) = apply {
-      writeTimeout = checkDuration("timeout", timeout, unit)
-    }
+    @JvmName("-deprecated_connectTimeoutMillis")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "connectTimeoutMillis"),
+            level = DeprecationLevel.WARNING)
+    fun connectTimeoutMillis(): Int = connectTimeoutMillis
 
-    /**
-     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
-     *
-     * The write timeout is applied for individual write IO operations. The default value is 10
-     * seconds.
-     *
-     * @see Sink.timeout
-     */
-    @IgnoreJRERequirement
-    fun writeTimeout(duration: Duration) = apply {
-      writeTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
-    }
+    @JvmName("-deprecated_readTimeoutMillis")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "readTimeoutMillis"),
+            level = DeprecationLevel.WARNING)
+    fun readTimeoutMillis(): Int = readTimeoutMillis
 
-    /**
-     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
-     * automatically send ping frames until either the connection fails or it is closed. This keeps
-     * the connection alive and may detect connectivity failures.
-     *
-     * If the server does not respond to each ping with a pong within `interval`, this client will
-     * assume that connectivity has been lost. When this happens on a web socket the connection is
-     * canceled and its listener is [notified][WebSocketListener.onFailure]. When it happens on an
-     * HTTP/2 connection the connection is closed and any calls it is carrying
-     * [will fail with an IOException][java.io.IOException].
-     *
-     * The default value of 0 disables client-initiated pings.
-     */
-    fun pingInterval(interval: Long, unit: TimeUnit) = apply {
-      pingInterval = checkDuration("interval", interval, unit)
-    }
+    @JvmName("-deprecated_writeTimeoutMillis")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "writeTimeoutMillis"),
+            level = DeprecationLevel.WARNING)
+    fun writeTimeoutMillis(): Int = writeTimeoutMillis
 
-    /**
-     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
-     * automatically send ping frames until either the connection fails or it is closed. This keeps
-     * the connection alive and may detect connectivity failures.
-     *
-     * If the server does not respond to each ping with a pong within `interval`, this client will
-     * assume that connectivity has been lost. When this happens on a web socket the connection is
-     * canceled and its listener is [notified][WebSocketListener.onFailure]. When it happens on an
-     * HTTP/2 connection the connection is closed and any calls it is carrying
-     * [will fail with an IOException][java.io.IOException].
-     *
-     * The default value of 0 disables client-initiated pings.
-     */
-    @IgnoreJRERequirement
-    fun pingInterval(duration: Duration) = apply {
-      pingInterval = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+    @JvmName("-deprecated_pingIntervalMillis")
+    @Deprecated(
+            message = "moved to val",
+            replaceWith = ReplaceWith(expression = "pingIntervalMillis"),
+            level = DeprecationLevel.WARNING)
+    fun pingIntervalMillis(): Int = pingIntervalMillis
+
+    class Builder constructor() {
+        // 调度器，异步请求执行的策略
+        internal var dispatcher: Dispatcher = Dispatcher()
+        // 连接池，管理http/http2连接复用以减少网络延迟
+        internal var connectionPool: ConnectionPool = ConnectionPool()
+        // 拦截器
+        internal val interceptors: MutableList<Interceptor> = mutableListOf()
+        // 网络拦截器
+        internal val networkInterceptors: MutableList<Interceptor> = mutableListOf()
+        // http 请求质量监控器
+        internal var eventListenerFactory: EventListener.Factory = EventListener.NONE.asFactory()
+        internal var retryOnConnectionFailure = true
+        // 身份鉴权
+        internal var authenticator: Authenticator = Authenticator.NONE
+        internal var followRedirects = true
+        internal var followSslRedirects = true
+        // 为HTTP cookie提供政策和持久性;
+        internal var cookieJar: CookieJar = CookieJar.NO_COOKIES
+        // 缓存http response到文件系统中便于重用，以节约时间合带宽
+        internal var cache: Cache? = null
+        // 域名解析服务
+        internal var dns: Dns = Dns.SYSTEM
+        internal var proxy: Proxy? = null
+        internal var proxySelector: ProxySelector = ProxySelector.getDefault()
+                ?: NullProxySelector()
+        internal var proxyAuthenticator: Authenticator = Authenticator.NONE
+        internal var socketFactory: SocketFactory = SocketFactory.getDefault()
+        internal var sslSocketFactoryOrNull: SSLSocketFactory? = null
+        internal var connectionSpecs: List<ConnectionSpec> = DEFAULT_CONNECTION_SPECS
+        // http 实现的协议
+        internal var protocols: List<Protocol> = DEFAULT_PROTOCOLS
+        // 域名校验
+        internal var hostnameVerifier: HostnameVerifier = OkHostnameVerifier
+        // 证书约束
+        internal var certificatePinner: CertificatePinner = CertificatePinner.DEFAULT
+        internal var certificateChainCleaner: CertificateChainCleaner? = null
+        internal var callTimeout = 0
+        internal var connectTimeout = 10_000
+        internal var readTimeout = 10_000
+        internal var writeTimeout = 10_000
+        internal var pingInterval = 0
+
+        internal constructor(okHttpClient: OkHttpClient) : this() {
+            this.dispatcher = okHttpClient.dispatcher
+            this.connectionPool = okHttpClient.connectionPool
+            this.interceptors += okHttpClient.interceptors
+            this.networkInterceptors += okHttpClient.networkInterceptors
+            this.eventListenerFactory = okHttpClient.eventListenerFactory
+            this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure
+            this.authenticator = okHttpClient.authenticator
+            this.followRedirects = okHttpClient.followRedirects
+            this.followSslRedirects = okHttpClient.followSslRedirects
+            this.cookieJar = okHttpClient.cookieJar
+            this.cache = okHttpClient.cache
+            this.dns = okHttpClient.dns
+            this.proxy = okHttpClient.proxy
+            this.proxySelector = okHttpClient.proxySelector
+            this.proxyAuthenticator = okHttpClient.proxyAuthenticator
+            this.socketFactory = okHttpClient.socketFactory
+            this.sslSocketFactoryOrNull = okHttpClient.sslSocketFactoryOrNull
+            this.connectionSpecs = okHttpClient.connectionSpecs
+            this.protocols = okHttpClient.protocols
+            this.hostnameVerifier = okHttpClient.hostnameVerifier
+            this.certificatePinner = okHttpClient.certificatePinner
+            this.certificateChainCleaner = okHttpClient.certificateChainCleaner
+            this.callTimeout = okHttpClient.callTimeoutMillis
+            this.connectTimeout = okHttpClient.connectTimeoutMillis
+            this.readTimeout = okHttpClient.readTimeoutMillis
+            this.writeTimeout = okHttpClient.writeTimeoutMillis
+            this.pingInterval = okHttpClient.pingIntervalMillis
+        }
+
+        /**
+         * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
+         */
+        fun dispatcher(dispatcher: Dispatcher) = apply {
+            this.dispatcher = dispatcher
+        }
+
+        /**
+         * Sets the connection pool used to recycle HTTP and HTTPS connections.
+         *
+         * If unset, a new connection pool will be used.
+         */
+        fun connectionPool(connectionPool: ConnectionPool) = apply {
+            this.connectionPool = connectionPool
+        }
+
+        /**
+         * Returns a modifiable list of interceptors that observe the full span of each call: from
+         * before the connection is established (if any) until after the response source is selected
+         * (either the origin server, cache, or both).
+         */
+        fun interceptors(): MutableList<Interceptor> = interceptors
+
+        fun addInterceptor(interceptor: Interceptor) = apply {
+            interceptors += interceptor
+        }
+
+        // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+        @JvmName("-deprecated_addInterceptor")
+        inline fun addInterceptor(
+                crossinline interceptor: (chain: Interceptor.Chain) -> Response
+        ) = apply {
+            addInterceptor(object : Interceptor {
+                override fun intercept(chain: Interceptor.Chain): Response = interceptor(chain)
+            })
+        }
+
+        /**
+         * Returns a modifiable list of interceptors that observe a single network request and response.
+         * These interceptors must call [Interceptor.Chain.proceed] exactly once: it is an error for a
+         * network interceptor to short-circuit or repeat a network request.
+         */
+        fun networkInterceptors(): MutableList<Interceptor> = networkInterceptors
+
+        fun addNetworkInterceptor(interceptor: Interceptor) = apply {
+            networkInterceptors += interceptor
+        }
+
+        // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+        @JvmName("-deprecated_addNetworkInterceptor")
+        inline fun addNetworkInterceptor(
+                crossinline interceptor: (chain: Interceptor.Chain) -> Response
+        ) = apply {
+            addInterceptor(object : Interceptor {
+                override fun intercept(chain: Interceptor.Chain): Response = interceptor(chain)
+            })
+        }
+
+        /**
+         * Configure a single client scoped listener that will receive all analytic events for this
+         * client.
+         *
+         * @see EventListener for semantics and restrictions on listener implementations.
+         */
+        fun eventListener(eventListener: EventListener) = apply {
+            this.eventListenerFactory = eventListener.asFactory()
+        }
+
+        /**
+         * Configure a factory to provide per-call scoped listeners that will receive analytic events
+         * for this client.
+         *
+         * @see EventListener for semantics and restrictions on listener implementations.
+         */
+        fun eventListenerFactory(eventListenerFactory: EventListener.Factory) = apply {
+            this.eventListenerFactory = eventListenerFactory
+        }
+
+        // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+        @JvmName("-deprecated_eventListenerFactory")
+        inline fun eventListenerFactory(crossinline block: (call: Call) -> EventListener) = apply {
+            eventListenerFactory(object : EventListener.Factory {
+                override fun create(call: Call) = block(call)
+            })
+        }
+
+        /**
+         * Configure this client to retry or not when a connectivity problem is encountered. By default,
+         * this client silently recovers from the following problems:
+         *
+         * * **Unreachable IP addresses.** If the URL's host has multiple IP addresses,
+         *   failure to reach any individual IP address doesn't fail the overall request. This can
+         *   increase availability of multi-homed services.
+         *
+         * * **Stale pooled connections.** The [ConnectionPool] reuses sockets
+         *   to decrease request latency, but these connections will occasionally time out.
+         *
+         * * **Unreachable proxy servers.** A [ProxySelector] can be used to
+         *   attempt multiple proxy servers in sequence, eventually falling back to a direct
+         *   connection.
+         *
+         * Set this to false to avoid retrying requests when doing so is destructive. In this case the
+         * calling application should do its own recovery of connectivity failures.
+         */
+        fun retryOnConnectionFailure(retryOnConnectionFailure: Boolean) = apply {
+            this.retryOnConnectionFailure = retryOnConnectionFailure
+        }
+
+        /**
+         * Sets the authenticator used to respond to challenges from origin servers. Use
+         * [proxyAuthenticator] to set the authenticator for proxy servers.
+         *
+         * If unset, the [no authentication will be attempted][Authenticator.NONE].
+         */
+        fun authenticator(authenticator: Authenticator) = apply {
+            this.authenticator = authenticator
+        }
+
+        /** Configure this client to follow redirects. If unset, redirects will be followed. */
+        fun followRedirects(followRedirects: Boolean) = apply {
+            this.followRedirects = followRedirects
+        }
+
+        /**
+         * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
+         *
+         * If unset, protocol redirects will be followed. This is different than the built-in
+         * `HttpURLConnection`'s default.
+         */
+        fun followSslRedirects(followProtocolRedirects: Boolean) = apply {
+            this.followSslRedirects = followProtocolRedirects
+        }
+
+        /**
+         * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
+         * outgoing HTTP requests.
+         *
+         * If unset, [no cookies][CookieJar.NO_COOKIES] will be accepted nor provided.
+         */
+        fun cookieJar(cookieJar: CookieJar) = apply {
+            this.cookieJar = cookieJar
+        }
+
+        /** Sets the response cache to be used to read and write cached responses. */
+        fun cache(cache: Cache?) = apply {
+            this.cache = cache
+        }
+
+        /**
+         * Sets the DNS service used to lookup IP addresses for hostnames.
+         *
+         * If unset, the [system-wide default][Dns.SYSTEM] DNS will be used.
+         */
+        fun dns(dns: Dns) = apply {
+            this.dns = dns
+        }
+
+        /**
+         * Sets the HTTP proxy that will be used by connections created by this client. This takes
+         * precedence over [proxySelector], which is only honored when this proxy is null (which it is
+         * by default). To disable proxy use completely, call `proxy(Proxy.NO_PROXY)`.
+         */
+        fun proxy(proxy: Proxy?) = apply {
+            this.proxy = proxy
+        }
+
+        /**
+         * Sets the proxy selection policy to be used if no [proxy][proxy] is specified explicitly. The
+         * proxy selector may return multiple proxies; in that case they will be tried in sequence until
+         * a successful connection is established.
+         *
+         * If unset, the [system-wide default][ProxySelector.getDefault] proxy selector will be used.
+         */
+        fun proxySelector(proxySelector: ProxySelector) = apply {
+            this.proxySelector = proxySelector
+        }
+
+        /**
+         * Sets the authenticator used to respond to challenges from proxy servers. Use [authenticator]
+         * to set the authenticator for origin servers.
+         *
+         * If unset, the [no authentication will be attempted][Authenticator.NONE].
+         */
+        fun proxyAuthenticator(proxyAuthenticator: Authenticator) = apply {
+            this.proxyAuthenticator = proxyAuthenticator
+        }
+
+        /**
+         * Sets the socket factory used to create connections. OkHttp only uses the parameterless
+         * [SocketFactory.createSocket] method to create unconnected sockets. Overriding this method,
+         * e. g., allows the socket to be bound to a specific local address.
+         *
+         * If unset, the [system-wide default][SocketFactory.getDefault] socket factory will be used.
+         */
+        fun socketFactory(socketFactory: SocketFactory) = apply {
+            require(socketFactory !is SSLSocketFactory) { "socketFactory instanceof SSLSocketFactory" }
+            this.socketFactory = socketFactory
+        }
+
+        /**
+         * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
+         * be used.
+         *
+         * @deprecated [SSLSocketFactory] does not expose its [X509TrustManager], which is a field that
+         *     OkHttp needs to build a clean certificate chain. This method instead must use reflection
+         *     to extract the trust manager. Applications should prefer to call
+         *     `sslSocketFactory(SSLSocketFactory, X509TrustManager)`, which avoids such reflection.
+         */
+        @Deprecated(
+                message = "Use the sslSocketFactory overload that accepts a X509TrustManager.",
+                level = ERROR
+        )
+        fun sslSocketFactory(sslSocketFactory: SSLSocketFactory) = apply {
+            this.sslSocketFactoryOrNull = sslSocketFactory
+            this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory)
+        }
+
+        /**
+         * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
+         * system defaults will be used.
+         *
+         * Most applications should not call this method, and instead use the system defaults. Those
+         * classes include special optimizations that can be lost if the implementations are decorated.
+         *
+         * If necessary, you can create and configure the defaults yourself with the following code:
+         *
+         * ```
+         * TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+         * TrustManagerFactory.getDefaultAlgorithm());
+         * trustManagerFactory.init((KeyStore) null);
+         * TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+         * if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+         *     throw new IllegalStateException("Unexpected default trust managers:"
+         *         + Arrays.toString(trustManagers));
+         * }
+         * X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
+         *
+         * SSLContext sslContext = SSLContext.getInstance("TLS");
+         * sslContext.init(null, new TrustManager[] { trustManager }, null);
+         * SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+         *
+         * OkHttpClient client = new OkHttpClient.Builder()
+         *     .sslSocketFactory(sslSocketFactory, trustManager)
+         *     .build();
+         * ```
+         */
+        fun sslSocketFactory(
+                sslSocketFactory: SSLSocketFactory,
+                trustManager: X509TrustManager
+        ) = apply {
+            this.sslSocketFactoryOrNull = sslSocketFactory
+            this.certificateChainCleaner = CertificateChainCleaner.get(trustManager)
+        }
+
+        fun connectionSpecs(connectionSpecs: List<ConnectionSpec>) = apply {
+            this.connectionSpecs = connectionSpecs.toImmutableList()
+        }
+
+        /**
+         * Configure the protocols used by this client to communicate with remote servers. By default
+         * this client will prefer the most efficient transport available, falling back to more
+         * ubiquitous protocols. Applications should only call this method to avoid specific
+         * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
+         *
+         * The following protocols are currently supported:
+         *
+         * * [http/1.1][rfc_2616]
+         * * [h2][rfc_7540]
+         * * [h2 with prior knowledge(cleartext only)][rfc_7540_34]
+         *
+         * **This is an evolving set.** Future releases include support for transitional
+         * protocols. The http/1.1 transport will never be dropped.
+         *
+         * If multiple protocols are specified, [ALPN][alpn] will be used to negotiate a transport.
+         * Protocol negotiation is only attempted for HTTPS URLs.
+         *
+         * [Protocol.HTTP_1_0] is not supported in this set. Requests are initiated with `HTTP/1.1`. If
+         * the server responds with `HTTP/1.0`, that will be exposed by [Response.protocol].
+         *
+         * [alpn]: http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg
+         * [rfc_2616]: http://www.w3.org/Protocols/rfc2616/rfc2616.html
+         * [rfc_7540]: https://tools.ietf.org/html/rfc7540
+         * [rfc_7540_34]: https://tools.ietf.org/html/rfc7540#section-3.4
+         *
+         * @param protocols the protocols to use, in order of preference. If the list contains
+         *     [Protocol.H2_PRIOR_KNOWLEDGE] then that must be the only protocol and HTTPS URLs will not
+         *     be supported. Otherwise the list must contain [Protocol.HTTP_1_1]. The list must
+         *     not contain null or [Protocol.HTTP_1_0].
+         */
+        fun protocols(protocols: List<Protocol>) = apply {
+            // Create a private copy of the list.
+            val protocolsCopy = protocols.toMutableList()
+
+            // Validate that the list has everything we require and nothing we forbid.
+            require(Protocol.H2_PRIOR_KNOWLEDGE in protocolsCopy || HTTP_1_1 in protocolsCopy) {
+                "protocols must contain h2_prior_knowledge or http/1.1: $protocolsCopy"
+            }
+            require(Protocol.H2_PRIOR_KNOWLEDGE !in protocolsCopy || protocolsCopy.size <= 1) {
+                "protocols containing h2_prior_knowledge cannot use other protocols: $protocolsCopy"
+            }
+            require(Protocol.HTTP_1_0 !in protocolsCopy) {
+                "protocols must not contain http/1.0: $protocolsCopy"
+            }
+            require(null !in (protocols as List<Protocol?>)) {
+                "protocols must not contain null"
+            }
+
+            // Remove protocolsCopy that we no longer support.
+            @Suppress("DEPRECATION")
+            protocolsCopy.remove(Protocol.SPDY_3)
+
+            // Assign as an unmodifiable list. This is effectively immutable.
+            this.protocols = Collections.unmodifiableList(protocols)
+        }
+
+        /**
+         * Sets the verifier used to confirm that response certificates apply to requested hostnames for
+         * HTTPS connections.
+         *
+         * If unset, a default hostname verifier will be used.
+         */
+        fun hostnameVerifier(hostnameVerifier: HostnameVerifier) = apply {
+            this.hostnameVerifier = hostnameVerifier
+        }
+
+        /**
+         * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
+         * connections rely on only the [SSL socket factory][sslSocketFactory] to establish trust.
+         * Pinning certificates avoids the need to trust certificate authorities.
+         */
+        fun certificatePinner(certificatePinner: CertificatePinner) = apply {
+            this.certificatePinner = certificatePinner
+        }
+
+        /**
+         * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+         * must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+         *
+         * The call timeout spans the entire call: resolving DNS, connecting, writing the request body,
+         * server processing, and reading the response body. If the call requires redirects or retries
+         * all must complete within one timeout period.
+         *
+         * The default value is 0 which imposes no timeout.
+         */
+        fun callTimeout(timeout: Long, unit: TimeUnit) = apply {
+            callTimeout = checkDuration("timeout", timeout, unit)
+        }
+
+        /**
+         * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+         * must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+         *
+         * The call timeout spans the entire call: resolving DNS, connecting, writing the request body,
+         * server processing, and reading the response body. If the call requires redirects or retries
+         * all must complete within one timeout period.
+         *
+         * The default value is 0 which imposes no timeout.
+         */
+        @IgnoreJRERequirement
+        fun callTimeout(duration: Duration) = apply {
+            callTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+        }
+
+        /**
+         * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+         * otherwise values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+         *
+         * The connect timeout is applied when connecting a TCP socket to the target host. The default
+         * value is 10 seconds.
+         */
+        fun connectTimeout(timeout: Long, unit: TimeUnit) = apply {
+            connectTimeout = checkDuration("timeout", timeout, unit)
+        }
+
+        /**
+         * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+         * otherwise values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+         *
+         * The connect timeout is applied when connecting a TCP socket to the target host. The default
+         * value is 10 seconds.
+         */
+        @IgnoreJRERequirement
+        fun connectTimeout(duration: Duration) = apply {
+            connectTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+        }
+
+        /**
+         * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+         * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+         *
+         * The read timeout is applied to both the TCP socket and for individual read IO operations
+         * including on [Source] of the [Response]. The default value is 10 seconds.
+         *
+         * @see Socket.setSoTimeout
+         * @see Source.timeout
+         */
+        fun readTimeout(timeout: Long, unit: TimeUnit) = apply {
+            readTimeout = checkDuration("timeout", timeout, unit)
+        }
+
+        /**
+         * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+         * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+         *
+         * The read timeout is applied to both the TCP socket and for individual read IO operations
+         * including on [Source] of the [Response]. The default value is 10 seconds.
+         *
+         * @see Socket.setSoTimeout
+         * @see Source.timeout
+         */
+        @IgnoreJRERequirement
+        fun readTimeout(duration: Duration) = apply {
+            readTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+        }
+
+        /**
+         * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+         * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+         *
+         * The write timeout is applied for individual write IO operations. The default value is 10
+         * seconds.
+         *
+         * @see Sink.timeout
+         */
+        fun writeTimeout(timeout: Long, unit: TimeUnit) = apply {
+            writeTimeout = checkDuration("timeout", timeout, unit)
+        }
+
+        /**
+         * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+         * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+         *
+         * The write timeout is applied for individual write IO operations. The default value is 10
+         * seconds.
+         *
+         * @see Sink.timeout
+         */
+        @IgnoreJRERequirement
+        fun writeTimeout(duration: Duration) = apply {
+            writeTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+        }
+
+        /**
+         * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+         * automatically send ping frames until either the connection fails or it is closed. This keeps
+         * the connection alive and may detect connectivity failures.
+         *
+         * If the server does not respond to each ping with a pong within `interval`, this client will
+         * assume that connectivity has been lost. When this happens on a web socket the connection is
+         * canceled and its listener is [notified][WebSocketListener.onFailure]. When it happens on an
+         * HTTP/2 connection the connection is closed and any calls it is carrying
+         * [will fail with an IOException][java.io.IOException].
+         *
+         * The default value of 0 disables client-initiated pings.
+         */
+        fun pingInterval(interval: Long, unit: TimeUnit) = apply {
+            pingInterval = checkDuration("interval", interval, unit)
+        }
+
+        /**
+         * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+         * automatically send ping frames until either the connection fails or it is closed. This keeps
+         * the connection alive and may detect connectivity failures.
+         *
+         * If the server does not respond to each ping with a pong within `interval`, this client will
+         * assume that connectivity has been lost. When this happens on a web socket the connection is
+         * canceled and its listener is [notified][WebSocketListener.onFailure]. When it happens on an
+         * HTTP/2 connection the connection is closed and any calls it is carrying
+         * [will fail with an IOException][java.io.IOException].
+         *
+         * The default value of 0 disables client-initiated pings.
+         */
+        @IgnoreJRERequirement
+        fun pingInterval(duration: Duration) = apply {
+            pingInterval = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+        }
+
+        fun build(): OkHttpClient = OkHttpClient(this)
     }
 
-    fun build(): OkHttpClient = OkHttpClient(this)
-  }
-
-  companion object {
-    internal val DEFAULT_PROTOCOLS = immutableListOf(HTTP_2, HTTP_1_1)
-
-    internal val DEFAULT_CONNECTION_SPECS = immutableListOf(
-        ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT)
-
-    private fun newSslSocketFactory(trustManager: X509TrustManager): SSLSocketFactory {
-      try {
-        val sslContext = Platform.get().newSSLContext()
-        sslContext.init(null, arrayOf<TrustManager>(trustManager), null)
-        return sslContext.socketFactory
-      } catch (e: GeneralSecurityException) {
-        throw AssertionError("No System TLS", e) // The system has no TLS. Just give up.
-      }
+    companion object {
+        internal val DEFAULT_PROTOCOLS = immutableListOf(HTTP_2, HTTP_1_1)
+
+        internal val DEFAULT_CONNECTION_SPECS = immutableListOf(
+                ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT)
+
+        private fun newSslSocketFactory(trustManager: X509TrustManager): SSLSocketFactory {
+            try {
+                val sslContext = Platform.get().newSSLContext()
+                sslContext.init(null, arrayOf<TrustManager>(trustManager), null)
+                return sslContext.socketFactory
+            } catch (e: GeneralSecurityException) {
+                throw AssertionError("No System TLS", e) // The system has no TLS. Just give up.
+            }
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/RealCall.kt b/okhttp/src/main/java/okhttp3/RealCall.kt
index 34057964b2..dc02028b79 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.kt
+++ b/okhttp/src/main/java/okhttp3/RealCall.kt
@@ -34,179 +34,187 @@ import java.util.concurrent.RejectedExecutionException
 import java.util.concurrent.atomic.AtomicInteger
 
 internal class RealCall private constructor(
-  val client: OkHttpClient,
-  /** The application's original request unadulterated by redirects or auth headers. */
-  val originalRequest: Request,
-  val forWebSocket: Boolean
+        val client: OkHttpClient,
+        /** The application's original request unadulterated by redirects or auth headers. */
+        val originalRequest: Request,
+        val forWebSocket: Boolean
 ) : Call {
-  /**
-   * There is a cycle between the [Call] and [Transmitter] that makes this awkward.
-   * This is set after immediately after creating the call instance.
-   */
-  private lateinit var transmitter: Transmitter
+    /**
+     * There is a cycle between the [Call] and [Transmitter] that makes this awkward.
+     * This is set after immediately after creating the call instance.
+     */
+    private lateinit var transmitter: Transmitter
 
-  // Guarded by this.
-  var executed: Boolean = false
+    // Guarded by this.
+    var executed: Boolean = false
 
-  @Synchronized override fun isExecuted(): Boolean = executed
+    @Synchronized
+    override fun isExecuted(): Boolean = executed
 
-  override fun isCanceled(): Boolean = transmitter.isCanceled
+    override fun isCanceled(): Boolean = transmitter.isCanceled
 
-  override fun request(): Request = originalRequest
+    override fun request(): Request = originalRequest
 
-  override fun execute(): Response {
-    synchronized(this) {
-      check(!executed) { "Already Executed" }
-      executed = true
-    }
-    transmitter.timeoutEnter()
-    transmitter.callStart()
-    try {
-      client.dispatcher.executed(this)
-      return getResponseWithInterceptorChain()
-    } finally {
-      client.dispatcher.finished(this)
+    override fun execute(): Response {
+        synchronized(this) {
+            check(!executed) { "Already Executed" }
+            executed = true
+        }
+        transmitter.timeoutEnter()
+        transmitter.callStart()
+        try {
+            client.dispatcher.executed(this)
+            return getResponseWithInterceptorChain()
+        } finally {
+            client.dispatcher.finished(this)
+        }
     }
-  }
 
-  override fun enqueue(responseCallback: Callback) {
-    synchronized(this) {
-      check(!executed) { "Already Executed" }
-      executed = true
+    override fun enqueue(responseCallback: Callback) {
+        synchronized(this) {
+            check(!executed) { "Already Executed" }
+            executed = true
+        }
+        transmitter.callStart()
+        client.dispatcher.enqueue(AsyncCall(responseCallback))
     }
-    transmitter.callStart()
-    client.dispatcher.enqueue(AsyncCall(responseCallback))
-  }
-
-  override fun cancel() {
-    transmitter.cancel()
-  }
 
-  override fun timeout(): Timeout = transmitter.timeout()
+    override fun cancel() {
+        transmitter.cancel()
+    }
 
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  override fun clone(): RealCall {
-    return newRealCall(client, originalRequest, forWebSocket)
-  }
+    override fun timeout(): Timeout = transmitter.timeout()
 
-  internal inner class AsyncCall(
-    private val responseCallback: Callback
-  ) : Runnable {
-    @Volatile private var callsPerHost = AtomicInteger(0)
+    @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+    override fun clone(): RealCall {
+        return newRealCall(client, originalRequest, forWebSocket)
+    }
 
-    fun callsPerHost(): AtomicInteger = callsPerHost
+    internal inner class AsyncCall(
+            private val responseCallback: Callback
+    ) : Runnable {
+        @Volatile
+        private var callsPerHost = AtomicInteger(0)
 
-    fun reuseCallsPerHostFrom(other: AsyncCall) {
-      this.callsPerHost = other.callsPerHost
-    }
+        fun callsPerHost(): AtomicInteger = callsPerHost
 
-    fun host(): String = originalRequest.url.host
+        fun reuseCallsPerHostFrom(other: AsyncCall) {
+            this.callsPerHost = other.callsPerHost
+        }
 
-    fun request(): Request = originalRequest
+        fun host(): String = originalRequest.url.host
+
+        fun request(): Request = originalRequest
+
+        fun get(): RealCall = this@RealCall
+
+        /**
+         * Attempt to enqueue this async call on [executorService]. This will attempt to clean up
+         * if the executor has been shut down by reporting the call as failed.
+         */
+        fun executeOn(executorService: ExecutorService) {
+            assert(!Thread.holdsLock(client.dispatcher))
+            var success = false
+            try {
+                executorService.execute(this)
+                success = true
+            } catch (e: RejectedExecutionException) {
+                val ioException = InterruptedIOException("executor rejected")
+                ioException.initCause(e)
+                transmitter.noMoreExchanges(ioException)
+                responseCallback.onFailure(this@RealCall, ioException)
+            } finally {
+                if (!success) {
+                    client.dispatcher.finished(this) // This call is no longer running!
+                }
+            }
+        }
 
-    fun get(): RealCall = this@RealCall
+        override fun run() {
+            threadName("OkHttp ${redactedUrl()}") {
+                var signalledCallback = false
+                transmitter.timeoutEnter()
+                try {
+                    val response = getResponseWithInterceptorChain()
+                    signalledCallback = true
+                    responseCallback.onResponse(this@RealCall, response)
+                } catch (e: IOException) {
+                    if (signalledCallback) {
+                        // Do not signal the callback twice!
+                        Platform.get().log(INFO, "Callback failure for ${toLoggableString()}", e)
+                    } else {
+                        responseCallback.onFailure(this@RealCall, e)
+                    }
+                } finally {
+                    client.dispatcher.finished(this)
+                }
+            }
+        }
+    }
 
     /**
-     * Attempt to enqueue this async call on [executorService]. This will attempt to clean up
-     * if the executor has been shut down by reporting the call as failed.
+     * Returns a string that describes this call. Doesn't include a full URL as that might contain
+     * sensitive information.
      */
-    fun executeOn(executorService: ExecutorService) {
-      assert(!Thread.holdsLock(client.dispatcher))
-      var success = false
-      try {
-        executorService.execute(this)
-        success = true
-      } catch (e: RejectedExecutionException) {
-        val ioException = InterruptedIOException("executor rejected")
-        ioException.initCause(e)
-        transmitter.noMoreExchanges(ioException)
-        responseCallback.onFailure(this@RealCall, ioException)
-      } finally {
-        if (!success) {
-          client.dispatcher.finished(this) // This call is no longer running!
-        }
-      }
+    fun toLoggableString(): String {
+        return ((if (isCanceled()) "canceled " else "") +
+                (if (forWebSocket) "web socket" else "call") +
+                " to " + redactedUrl())
     }
 
-    override fun run() {
-      threadName("OkHttp ${redactedUrl()}") {
-        var signalledCallback = false
-        transmitter.timeoutEnter()
+    fun redactedUrl(): String = originalRequest.url.redact()
+
+    @Throws(IOException::class)
+    fun getResponseWithInterceptorChain(): Response {
+        // Build a full stack of interceptors.
+        val interceptors = mutableListOf<Interceptor>()
+        // 添加client设置的拦截器
+        interceptors += client.interceptors
+        // 失败重试和重定向的拦截器
+        interceptors += RetryAndFollowUpInterceptor(client)
+        // 将客户端构造的请求转换为服务器的请求，将服务器的响应转换未客户端的响应的拦截器
+        interceptors += BridgeInterceptor(client.cookieJar)
+        // 缓存拦截器
+        interceptors += CacheInterceptor(client.cache)
+        // 与服务器建立连接的拦截器
+        interceptors += ConnectInterceptor
+        if (!forWebSocket) {
+            interceptors += client.networkInterceptors
+        }
+        // 真正向服务器发起请求并获取响应的拦截器
+        interceptors += CallServerInterceptor(forWebSocket)
+        // 构造拦截器链
+        val chain = RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this,
+                client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis)
+
+        var calledNoMoreExchanges = false
         try {
-          val response = getResponseWithInterceptorChain()
-          signalledCallback = true
-          responseCallback.onResponse(this@RealCall, response)
+            val response = chain.proceed(originalRequest)
+            if (transmitter.isCanceled) {
+                response.closeQuietly()
+                throw IOException("Canceled")
+            }
+            return response
         } catch (e: IOException) {
-          if (signalledCallback) {
-            // Do not signal the callback twice!
-            Platform.get().log(INFO, "Callback failure for ${toLoggableString()}", e)
-          } else {
-            responseCallback.onFailure(this@RealCall, e)
-          }
+            calledNoMoreExchanges = true
+            throw transmitter.noMoreExchanges(e) as Throwable
         } finally {
-          client.dispatcher.finished(this)
+            if (!calledNoMoreExchanges) {
+                transmitter.noMoreExchanges(null)
+            }
         }
-      }
-    }
-  }
-
-  /**
-   * Returns a string that describes this call. Doesn't include a full URL as that might contain
-   * sensitive information.
-   */
-  fun toLoggableString(): String {
-    return ((if (isCanceled()) "canceled " else "") +
-        (if (forWebSocket) "web socket" else "call") +
-        " to " + redactedUrl())
-  }
-
-  fun redactedUrl(): String = originalRequest.url.redact()
-
-  @Throws(IOException::class)
-  fun getResponseWithInterceptorChain(): Response {
-    // Build a full stack of interceptors.
-    val interceptors = mutableListOf<Interceptor>()
-    interceptors += client.interceptors
-    interceptors += RetryAndFollowUpInterceptor(client)
-    interceptors += BridgeInterceptor(client.cookieJar)
-    interceptors += CacheInterceptor(client.cache)
-    interceptors += ConnectInterceptor
-    if (!forWebSocket) {
-      interceptors += client.networkInterceptors
     }
-    interceptors += CallServerInterceptor(forWebSocket)
-
-    val chain = RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this,
-        client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis)
-
-    var calledNoMoreExchanges = false
-    try {
-      val response = chain.proceed(originalRequest)
-      if (transmitter.isCanceled) {
-        response.closeQuietly()
-        throw IOException("Canceled")
-      }
-      return response
-    } catch (e: IOException) {
-      calledNoMoreExchanges = true
-      throw transmitter.noMoreExchanges(e) as Throwable
-    } finally {
-      if (!calledNoMoreExchanges) {
-        transmitter.noMoreExchanges(null)
-      }
-    }
-  }
-
-  companion object {
-    fun newRealCall(
-      client: OkHttpClient,
-      originalRequest: Request,
-      forWebSocket: Boolean
-    ): RealCall {
-      // Safely publish the Call instance to the EventListener.
-      return RealCall(client, originalRequest, forWebSocket).apply {
-        transmitter = Transmitter(client, this)
-      }
+
+    companion object {
+        fun newRealCall(
+                client: OkHttpClient,
+                originalRequest: Request,
+                forWebSocket: Boolean
+        ): RealCall {
+            // Safely publish the Call instance to the EventListener.
+            return RealCall(client, originalRequest, forWebSocket).apply {
+                transmitter = Transmitter(client, this)
+            }
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.kt b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.kt
index f73a856d90..1a97685382 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.kt
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.kt
@@ -40,226 +40,230 @@ import java.util.concurrent.TimeUnit.MILLISECONDS
 /** Serves requests from the cache and writes responses to the cache. */
 class CacheInterceptor(internal val cache: Cache?) : Interceptor {
 
-  @Throws(IOException::class)
-  override fun intercept(chain: Interceptor.Chain): Response {
-    val cacheCandidate = cache?.get(chain.request())
+    @Throws(IOException::class)
+    override fun intercept(chain: Interceptor.Chain): Response {
+        // 获取缓存
+        val cacheCandidate = cache?.get(chain.request())
 
-    val now = System.currentTimeMillis()
+        val now = System.currentTimeMillis()
 
-    val strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()
-    val networkRequest = strategy.networkRequest
-    val cacheResponse = strategy.cacheResponse
+        val strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()
+        val networkRequest = strategy.networkRequest
+        val cacheResponse = strategy.cacheResponse
 
-    cache?.trackResponse(strategy)
+        cache?.trackResponse(strategy)
 
-    if (cacheCandidate != null && cacheResponse == null) {
-      // The cache candidate wasn't applicable. Close it.
-      cacheCandidate.body?.closeQuietly()
-    }
-
-    // If we're forbidden from using the network and the cache is insufficient, fail.
-    if (networkRequest == null && cacheResponse == null) {
-      return Response.Builder()
-          .request(chain.request())
-          .protocol(Protocol.HTTP_1_1)
-          .code(HTTP_GATEWAY_TIMEOUT)
-          .message("Unsatisfiable Request (only-if-cached)")
-          .body(EMPTY_RESPONSE)
-          .sentRequestAtMillis(-1L)
-          .receivedResponseAtMillis(System.currentTimeMillis())
-          .build()
-    }
-
-    // If we don't need the network, we're done.
-    if (networkRequest == null) {
-      return cacheResponse!!.newBuilder()
-          .cacheResponse(stripBody(cacheResponse))
-          .build()
-    }
-
-    var networkResponse: Response? = null
-    try {
-      networkResponse = chain.proceed(networkRequest)
-    } finally {
-      // If we're crashing on I/O or otherwise, don't leak the cache body.
-      if (networkResponse == null && cacheCandidate != null) {
-        cacheCandidate.body?.closeQuietly()
-      }
-    }
-
-    // If we have a cache response too, then we're doing a conditional get.
-    if (cacheResponse != null) {
-      if (networkResponse?.code == HTTP_NOT_MODIFIED) {
-        val response = cacheResponse.newBuilder()
-            .headers(combine(cacheResponse.headers, networkResponse.headers))
-            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)
-            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)
-            .cacheResponse(stripBody(cacheResponse))
-            .networkResponse(stripBody(networkResponse))
-            .build()
-
-        networkResponse.body!!.close()
-
-        // Update the cache after combining headers but before stripping the
-        // Content-Encoding header (as performed by initContentStream()).
-        cache!!.trackConditionalCacheHit()
-        cache.update(cacheResponse, response)
-        return response
-      } else {
-        cacheResponse.body?.closeQuietly()
-      }
-    }
-
-    val response = networkResponse!!.newBuilder()
-        .cacheResponse(stripBody(cacheResponse))
-        .networkResponse(stripBody(networkResponse))
-        .build()
+        if (cacheCandidate != null && cacheResponse == null) {
+            // The cache candidate wasn't applicable. Close it.
+            cacheCandidate.body?.closeQuietly()
+        }
 
-    if (cache != null) {
-      if (response.promisesBody() && CacheStrategy.isCacheable(response, networkRequest)) {
-        // Offer this request to the cache.
-        val cacheRequest = cache.put(response)
-        return cacheWritingResponse(cacheRequest, response)
-      }
+        // If we're forbidden from using the network and the cache is insufficient, fail.
+        // 如果我们禁用网络， 并且缓存为空， 失败
+        if (networkRequest == null && cacheResponse == null) {
+            return Response.Builder()
+                    .request(chain.request())
+                    .protocol(Protocol.HTTP_1_1)
+                    .code(HTTP_GATEWAY_TIMEOUT)
+                    .message("Unsatisfiable Request (only-if-cached)")
+                    .body(EMPTY_RESPONSE)
+                    .sentRequestAtMillis(-1L)
+                    .receivedResponseAtMillis(System.currentTimeMillis())
+                    .build()
+        }
 
-      if (HttpMethod.invalidatesCache(networkRequest.method)) {
-        try {
-          cache.remove(networkRequest)
-        } catch (_: IOException) {
-          // The cache cannot be written.
+        // If we don't need the network, we're done.
+        // 如果禁用网络， 返回缓存
+        if (networkRequest == null) {
+            return cacheResponse!!.newBuilder()
+                    .cacheResponse(stripBody(cacheResponse))
+                    .build()
         }
-      }
-    }
 
-    return response
-  }
-
-  /**
-   * Returns a new source that writes bytes to [cacheRequest] as they are read by the source
-   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
-   * may never exhaust the source stream and therefore not complete the cached response.
-   */
-  @Throws(IOException::class)
-  private fun cacheWritingResponse(cacheRequest: CacheRequest?, response: Response): Response {
-    // Some apps return a null body; for compatibility we treat that like a null cache request.
-    if (cacheRequest == null) return response
-    val cacheBodyUnbuffered = cacheRequest.body()
-
-    val source = response.body!!.source()
-    val cacheBody = cacheBodyUnbuffered.buffer()
-
-    val cacheWritingSource = object : Source {
-      var cacheRequestClosed: Boolean = false
-
-      @Throws(IOException::class)
-      override fun read(sink: Buffer, byteCount: Long): Long {
-        val bytesRead: Long
+        var networkResponse: Response? = null
         try {
-          bytesRead = source.read(sink, byteCount)
-        } catch (e: IOException) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true
-            cacheRequest.abort() // Failed to write a complete cache response.
-          }
-          throw e
+            networkResponse = chain.proceed(networkRequest)
+        } finally {
+            // If we're crashing on I/O or otherwise, don't leak the cache body.
+            // 如果因为 i/o 或其他原因崩溃， 不要泄漏缓存体
+            if (networkResponse == null && cacheCandidate != null) {
+                cacheCandidate.body?.closeQuietly()
+            }
         }
 
-        if (bytesRead == -1L) {
-          if (!cacheRequestClosed) {
-            cacheRequestClosed = true
-            cacheBody.close() // The cache response is complete!
-          }
-          return -1
+        // If we have a cache response too, then we're doing a conditional get.
+        if (cacheResponse != null) {
+            if (networkResponse?.code == HTTP_NOT_MODIFIED) {
+                val response = cacheResponse.newBuilder()
+                        .headers(combine(cacheResponse.headers, networkResponse.headers))
+                        .sentRequestAtMillis(networkResponse.sentRequestAtMillis)
+                        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)
+                        .cacheResponse(stripBody(cacheResponse))
+                        .networkResponse(stripBody(networkResponse))
+                        .build()
+
+                networkResponse.body!!.close()
+
+                // Update the cache after combining headers but before stripping the
+                // Content-Encoding header (as performed by initContentStream()).
+                cache!!.trackConditionalCacheHit()
+                cache.update(cacheResponse, response)
+                return response
+            } else {
+                cacheResponse.body?.closeQuietly()
+            }
         }
 
-        sink.copyTo(cacheBody.buffer, sink.size - bytesRead, bytesRead)
-        cacheBody.emitCompleteSegments()
-        return bytesRead
-      }
-
-      override fun timeout(): Timeout {
-        return source.timeout()
-      }
-
-      @Throws(IOException::class)
-      override fun close() {
-        if (!cacheRequestClosed &&
-            !discard(ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-          cacheRequestClosed = true
-          cacheRequest.abort()
+        val response = networkResponse!!.newBuilder()
+                .cacheResponse(stripBody(cacheResponse))
+                .networkResponse(stripBody(networkResponse))
+                .build()
+
+        if (cache != null) {
+            if (response.promisesBody() && CacheStrategy.isCacheable(response, networkRequest)) {
+                // Offer this request to the cache.
+                val cacheRequest = cache.put(response)
+                return cacheWritingResponse(cacheRequest, response)
+            }
+
+            if (HttpMethod.invalidatesCache(networkRequest.method)) {
+                try {
+                    cache.remove(networkRequest)
+                } catch (_: IOException) {
+                    // The cache cannot be written.
+                }
+            }
         }
-        source.close()
-      }
+
+        return response
     }
 
-    val contentType = response.header("Content-Type")
-    val contentLength = response.body.contentLength()
-    return response.newBuilder()
-        .body(RealResponseBody(contentType, contentLength, cacheWritingSource.buffer()))
-        .build()
-  }
-
-  companion object {
-
-    private fun stripBody(response: Response?): Response? {
-      return if (response?.body != null) {
-        response.newBuilder().body(null).build()
-      } else {
-        response
-      }
+    /**
+     * Returns a new source that writes bytes to [cacheRequest] as they are read by the source
+     * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
+     * may never exhaust the source stream and therefore not complete the cached response.
+     */
+    @Throws(IOException::class)
+    private fun cacheWritingResponse(cacheRequest: CacheRequest?, response: Response): Response {
+        // Some apps return a null body; for compatibility we treat that like a null cache request.
+        if (cacheRequest == null) return response
+        val cacheBodyUnbuffered = cacheRequest.body()
+
+        val source = response.body!!.source()
+        val cacheBody = cacheBodyUnbuffered.buffer()
+
+        val cacheWritingSource = object : Source {
+            var cacheRequestClosed: Boolean = false
+
+            @Throws(IOException::class)
+            override fun read(sink: Buffer, byteCount: Long): Long {
+                val bytesRead: Long
+                try {
+                    bytesRead = source.read(sink, byteCount)
+                } catch (e: IOException) {
+                    if (!cacheRequestClosed) {
+                        cacheRequestClosed = true
+                        cacheRequest.abort() // Failed to write a complete cache response.
+                    }
+                    throw e
+                }
+
+                if (bytesRead == -1L) {
+                    if (!cacheRequestClosed) {
+                        cacheRequestClosed = true
+                        cacheBody.close() // The cache response is complete!
+                    }
+                    return -1
+                }
+
+                sink.copyTo(cacheBody.buffer, sink.size - bytesRead, bytesRead)
+                cacheBody.emitCompleteSegments()
+                return bytesRead
+            }
+
+            override fun timeout(): Timeout {
+                return source.timeout()
+            }
+
+            @Throws(IOException::class)
+            override fun close() {
+                if (!cacheRequestClosed &&
+                        !discard(ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+                    cacheRequestClosed = true
+                    cacheRequest.abort()
+                }
+                source.close()
+            }
+        }
+
+        val contentType = response.header("Content-Type")
+        val contentLength = response.body.contentLength()
+        return response.newBuilder()
+                .body(RealResponseBody(contentType, contentLength, cacheWritingSource.buffer()))
+                .build()
     }
 
-    /** Combines cached headers with a network headers as defined by RFC 7234, 4.3.4. */
-    private fun combine(cachedHeaders: Headers, networkHeaders: Headers): Headers {
-      val result = Headers.Builder()
+    companion object {
 
-      for (index in cachedHeaders.names().indices) {
-        val fieldName = cachedHeaders.name(index)
-        val value = cachedHeaders.value(index)
-        if ("Warning".equals(fieldName, ignoreCase = true) && value.startsWith("1")) {
-          // Drop 100-level freshness warnings.
-          continue
-        }
-        if (isContentSpecificHeader(fieldName) ||
-            !isEndToEnd(fieldName) ||
-            networkHeaders[fieldName] == null) {
-          result.addLenient(fieldName, value)
+        private fun stripBody(response: Response?): Response? {
+            return if (response?.body != null) {
+                response.newBuilder().body(null).build()
+            } else {
+                response
+            }
         }
-      }
 
-      for (index in networkHeaders.names().indices) {
-        val fieldName = networkHeaders.name(index)
-        if (!isContentSpecificHeader(fieldName) && isEndToEnd(fieldName)) {
-          result.addLenient(fieldName, networkHeaders.value(index))
+        /** Combines cached headers with a network headers as defined by RFC 7234, 4.3.4. */
+        private fun combine(cachedHeaders: Headers, networkHeaders: Headers): Headers {
+            val result = Headers.Builder()
+
+            for (index in cachedHeaders.names().indices) {
+                val fieldName = cachedHeaders.name(index)
+                val value = cachedHeaders.value(index)
+                if ("Warning".equals(fieldName, ignoreCase = true) && value.startsWith("1")) {
+                    // Drop 100-level freshness warnings.
+                    continue
+                }
+                if (isContentSpecificHeader(fieldName) ||
+                        !isEndToEnd(fieldName) ||
+                        networkHeaders[fieldName] == null) {
+                    result.addLenient(fieldName, value)
+                }
+            }
+
+            for (index in networkHeaders.names().indices) {
+                val fieldName = networkHeaders.name(index)
+                if (!isContentSpecificHeader(fieldName) && isEndToEnd(fieldName)) {
+                    result.addLenient(fieldName, networkHeaders.value(index))
+                }
+            }
+
+            return result.build()
         }
-      }
-
-      return result.build()
-    }
 
-    /**
-     * Returns true if [fieldName] is an end-to-end HTTP header, as defined by RFC 2616,
-     * 13.5.1.
-     */
-    private fun isEndToEnd(fieldName: String): Boolean {
-      return !"Connection".equals(fieldName, ignoreCase = true) &&
-          !"Keep-Alive".equals(fieldName, ignoreCase = true) &&
-          !"Proxy-Authenticate".equals(fieldName, ignoreCase = true) &&
-          !"Proxy-Authorization".equals(fieldName, ignoreCase = true) &&
-          !"TE".equals(fieldName, ignoreCase = true) &&
-          !"Trailers".equals(fieldName, ignoreCase = true) &&
-          !"Transfer-Encoding".equals(fieldName, ignoreCase = true) &&
-          !"Upgrade".equals(fieldName, ignoreCase = true)
-    }
+        /**
+         * Returns true if [fieldName] is an end-to-end HTTP header, as defined by RFC 2616,
+         * 13.5.1.
+         */
+        private fun isEndToEnd(fieldName: String): Boolean {
+            return !"Connection".equals(fieldName, ignoreCase = true) &&
+                    !"Keep-Alive".equals(fieldName, ignoreCase = true) &&
+                    !"Proxy-Authenticate".equals(fieldName, ignoreCase = true) &&
+                    !"Proxy-Authorization".equals(fieldName, ignoreCase = true) &&
+                    !"TE".equals(fieldName, ignoreCase = true) &&
+                    !"Trailers".equals(fieldName, ignoreCase = true) &&
+                    !"Transfer-Encoding".equals(fieldName, ignoreCase = true) &&
+                    !"Upgrade".equals(fieldName, ignoreCase = true)
+        }
 
-    /**
-     * Returns true if [fieldName] is content specific and therefore should always be used
-     * from cached headers.
-     */
-    private fun isContentSpecificHeader(fieldName: String): Boolean {
-      return "Content-Length".equals(fieldName, ignoreCase = true) ||
-          "Content-Encoding".equals(fieldName, ignoreCase = true) ||
-          "Content-Type".equals(fieldName, ignoreCase = true)
+        /**
+         * Returns true if [fieldName] is content specific and therefore should always be used
+         * from cached headers.
+         */
+        private fun isContentSpecificHeader(fieldName: String): Boolean {
+            return "Content-Length".equals(fieldName, ignoreCase = true) ||
+                    "Content-Encoding".equals(fieldName, ignoreCase = true) ||
+                    "Content-Type".equals(fieldName, ignoreCase = true)
+        }
     }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.kt b/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.kt
index b58ab9cc0c..68d9e9ed15 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.kt
+++ b/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.kt
@@ -47,295 +47,295 @@ import javax.net.ssl.SSLSocketFactory
  * canceling may break the entire connection.
  */
 class Transmitter(
-  private val client: OkHttpClient,
-  private val call: Call
+        private val client: OkHttpClient,
+        private val call: Call
 ) {
-  private val connectionPool: RealConnectionPool = client.connectionPool.delegate
-  private val eventListener: EventListener = client.eventListenerFactory.create(call)
-  private val timeout = object : AsyncTimeout() {
-    override fun timedOut() {
-      cancel()
-    }
-  }.apply {
-    timeout(client.callTimeoutMillis.toLong(), MILLISECONDS)
-  }
-
-  private var callStackTrace: Any? = null
-
-  private var request: Request? = null
-  private var exchangeFinder: ExchangeFinder? = null
-
-  // Guarded by connectionPool.
-  var connection: RealConnection? = null
-  private var exchange: Exchange? = null
-  private var exchangeRequestDone = false
-  private var exchangeResponseDone = false
-  private var canceled = false
-  private var timeoutEarlyExit = false
-  private var noMoreExchanges = false
-
-  val isCanceled: Boolean
-    get() {
-      synchronized(connectionPool) {
-        return canceled
-      }
+    private val connectionPool: RealConnectionPool = client.connectionPool.delegate
+    private val eventListener: EventListener = client.eventListenerFactory.create(call)
+    private val timeout = object : AsyncTimeout() {
+        override fun timedOut() {
+            cancel()
+        }
+    }.apply {
+        timeout(client.callTimeoutMillis.toLong(), MILLISECONDS)
     }
 
-  fun timeout(): Timeout = timeout
-
-  fun timeoutEnter() {
-    timeout.enter()
-  }
-
-  /**
-   * Stops applying the timeout before the call is entirely complete. This is used for WebSockets
-   * and duplex calls where the timeout only applies to the initial setup.
-   */
-  fun timeoutEarlyExit() {
-    check(!timeoutEarlyExit)
-    timeoutEarlyExit = true
-    timeout.exit()
-  }
-
-  private fun <E : IOException?> timeoutExit(cause: E): E {
-    if (timeoutEarlyExit) return cause
-    if (!timeout.exit()) return cause
-
-    val e = InterruptedIOException("timeout")
-    if (cause != null) e.initCause(cause)
-    @Suppress("UNCHECKED_CAST") // E is either IOException or IOException?
-    return e as E
-  }
-
-  fun callStart() {
-    this.callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()")
-    eventListener.callStart(call)
-  }
-
-  /**
-   * Prepare to create a stream to carry [request]. This prefers to use the existing connection if
-   * it exists.
-   */
-  fun prepareToConnect(request: Request) {
-    if (this.request != null) {
-      if (this.request!!.url.canReuseConnectionFor(request.url) && exchangeFinder!!.hasRouteToTry()) {
-        return // Already ready.
-      }
-      check(exchange == null)
-
-      if (exchangeFinder != null) {
-        maybeReleaseConnection(null, true)
-        exchangeFinder = null
-      }
-    }
+    private var callStackTrace: Any? = null
+
+    private var request: Request? = null
+    private var exchangeFinder: ExchangeFinder? = null
+
+    // Guarded by connectionPool.
+    var connection: RealConnection? = null
+    private var exchange: Exchange? = null
+    private var exchangeRequestDone = false
+    private var exchangeResponseDone = false
+    private var canceled = false
+    private var timeoutEarlyExit = false
+    private var noMoreExchanges = false
 
-    this.request = request
-    this.exchangeFinder = ExchangeFinder(
-        this, connectionPool, createAddress(request.url), call, eventListener)
-  }
-
-  private fun createAddress(url: HttpUrl): Address {
-    var sslSocketFactory: SSLSocketFactory? = null
-    var hostnameVerifier: HostnameVerifier? = null
-    var certificatePinner: CertificatePinner? = null
-    if (url.isHttps) {
-      sslSocketFactory = client.sslSocketFactory
-      hostnameVerifier = client.hostnameVerifier
-      certificatePinner = client.certificatePinner
+    val isCanceled: Boolean
+        get() {
+            synchronized(connectionPool) {
+                return canceled
+            }
+        }
+
+    fun timeout(): Timeout = timeout
+
+    fun timeoutEnter() {
+        timeout.enter()
     }
 
-    return Address(url.host, url.port, client.dns, client.socketFactory,
-        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator,
-        client.proxy, client.protocols, client.connectionSpecs, client.proxySelector)
-  }
-
-  /** Returns a new exchange to carry a new request and response. */
-  internal fun newExchange(chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean): Exchange {
-    synchronized(connectionPool) {
-      check(!noMoreExchanges) { "released" }
-      check(exchange == null) {
-        "cannot make a new request because the previous response is still open: " +
-            "please call response.close()"
-      }
+    /**
+     * Stops applying the timeout before the call is entirely complete. This is used for WebSockets
+     * and duplex calls where the timeout only applies to the initial setup.
+     */
+    fun timeoutEarlyExit() {
+        check(!timeoutEarlyExit)
+        timeoutEarlyExit = true
+        timeout.exit()
     }
 
-    val codec = exchangeFinder!!.find(client, chain, doExtensiveHealthChecks)
-    val result = Exchange(this, call, eventListener, exchangeFinder!!, codec)
+    private fun <E : IOException?> timeoutExit(cause: E): E {
+        if (timeoutEarlyExit) return cause
+        if (!timeout.exit()) return cause
 
-    synchronized(connectionPool) {
-      this.exchange = result
-      this.exchangeRequestDone = false
-      this.exchangeResponseDone = false
-      return result
+        val e = InterruptedIOException("timeout")
+        if (cause != null) e.initCause(cause)
+        @Suppress("UNCHECKED_CAST") // E is either IOException or IOException?
+        return e as E
     }
-  }
-
-  fun acquireConnectionNoEvents(connection: RealConnection) {
-    assert(Thread.holdsLock(connectionPool))
-
-    check(this.connection == null)
-    this.connection = connection
-    connection.transmitters.add(TransmitterReference(this, callStackTrace))
-  }
-
-  /**
-   * Remove the transmitter from the connection's list of allocations. Returns a socket that the
-   * caller should close.
-   */
-  fun releaseConnectionNoEvents(): Socket? {
-    assert(Thread.holdsLock(connectionPool))
-
-    val index = connection!!.transmitters.indexOfFirst { it.get() == this@Transmitter }
-    check(index != -1)
-
-    val released = this.connection
-    released!!.transmitters.removeAt(index)
-    this.connection = null
-
-    if (released.transmitters.isEmpty()) {
-      released.idleAtNanos = System.nanoTime()
-      if (connectionPool.connectionBecameIdle(released)) {
-        return released.socket()
-      }
+
+    fun callStart() {
+        this.callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()")
+        eventListener.callStart(call)
     }
 
-    return null
-  }
+    /**
+     * Prepare to create a stream to carry [request]. This prefers to use the existing connection if
+     * it exists.
+     */
+    fun prepareToConnect(request: Request) {
+        if (this.request != null) {
+            if (this.request!!.url.canReuseConnectionFor(request.url) && exchangeFinder!!.hasRouteToTry()) {
+                return // Already ready.
+            }
+            check(exchange == null)
+
+            if (exchangeFinder != null) {
+                maybeReleaseConnection(null, true)
+                exchangeFinder = null
+            }
+        }
+
+        this.request = request
+        this.exchangeFinder = ExchangeFinder(
+                this, connectionPool, createAddress(request.url), call, eventListener)
+    }
 
-  fun exchangeDoneDueToException() {
-    synchronized(connectionPool) {
-      check(!noMoreExchanges)
-      exchange = null
+    private fun createAddress(url: HttpUrl): Address {
+        var sslSocketFactory: SSLSocketFactory? = null
+        var hostnameVerifier: HostnameVerifier? = null
+        var certificatePinner: CertificatePinner? = null
+        if (url.isHttps) {
+            sslSocketFactory = client.sslSocketFactory
+            hostnameVerifier = client.hostnameVerifier
+            certificatePinner = client.certificatePinner
+        }
+
+        return Address(url.host, url.port, client.dns, client.socketFactory,
+                sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator,
+                client.proxy, client.protocols, client.connectionSpecs, client.proxySelector)
     }
-  }
-
-  /**
-   * Releases resources held with the request or response of [exchange]. This should be called when
-   * the request completes normally or when it fails due to an exception, in which case [e] should
-   * be non-null.
-   *
-   * If the exchange was canceled or timed out, this will wrap [e] in an exception that provides
-   * that additional context. Otherwise [e] is returned as-is.
-   */
-  internal fun <E : IOException?> exchangeMessageDone(
-    exchange: Exchange,
-    requestDone: Boolean,
-    responseDone: Boolean,
-    e: E
-  ): E {
-    var result = e
-    var exchangeDone = false
-    synchronized(connectionPool) {
-      if (exchange != this.exchange) {
-        return result // This exchange was detached violently!
-      }
-      var changed = false
-      if (requestDone) {
-        if (!exchangeRequestDone) changed = true
-        this.exchangeRequestDone = true
-      }
-      if (responseDone) {
-        if (!exchangeResponseDone) changed = true
-        this.exchangeResponseDone = true
-      }
-      if (exchangeRequestDone && exchangeResponseDone && changed) {
-        exchangeDone = true
-        this.exchange!!.connection()!!.successCount++
-        this.exchange = null
-      }
+
+    /** Returns a new exchange to carry a new request and response. */
+    internal fun newExchange(chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean): Exchange {
+        synchronized(connectionPool) {
+            check(!noMoreExchanges) { "released" }
+            check(exchange == null) {
+                "cannot make a new request because the previous response is still open: " +
+                        "please call response.close()"
+            }
+        }
+
+        val codec = exchangeFinder!!.find(client, chain, doExtensiveHealthChecks)
+        val result = Exchange(this, call, eventListener, exchangeFinder!!, codec)
+
+        synchronized(connectionPool) {
+            this.exchange = result
+            this.exchangeRequestDone = false
+            this.exchangeResponseDone = false
+            return result
+        }
     }
-    if (exchangeDone) {
-      result = maybeReleaseConnection(result, false)
+
+    fun acquireConnectionNoEvents(connection: RealConnection) {
+        assert(Thread.holdsLock(connectionPool))
+
+        check(this.connection == null)
+        this.connection = connection
+        connection.transmitters.add(TransmitterReference(this, callStackTrace))
     }
-    return result
-  }
 
-  fun noMoreExchanges(e: IOException?): IOException? {
-    synchronized(connectionPool) {
-      noMoreExchanges = true
+    /**
+     * Remove the transmitter from the connection's list of allocations. Returns a socket that the
+     * caller should close.
+     */
+    fun releaseConnectionNoEvents(): Socket? {
+        assert(Thread.holdsLock(connectionPool))
+
+        val index = connection!!.transmitters.indexOfFirst { it.get() == this@Transmitter }
+        check(index != -1)
+
+        val released = this.connection
+        released!!.transmitters.removeAt(index)
+        this.connection = null
+
+        if (released.transmitters.isEmpty()) {
+            released.idleAtNanos = System.nanoTime()
+            if (connectionPool.connectionBecameIdle(released)) {
+                return released.socket()
+            }
+        }
+
+        return null
     }
-    return maybeReleaseConnection(e, false)
-  }
-
-  /**
-   * Release the connection if it is no longer needed. This is called after each exchange completes
-   * and after the call signals that no more exchanges are expected.
-   *
-   * If the transmitter was canceled or timed out, this will wrap [e] in an exception that provides
-   * that additional context. Otherwise [e] is returned as-is.
-   *
-   * @param force true to release the connection even if more exchanges are expected for the call.
-   */
-  private fun <E : IOException?> maybeReleaseConnection(e: E, force: Boolean): E {
-    var result = e
-    val socket: Socket?
-    var releasedConnection: Connection?
-    val callEnd: Boolean
-    synchronized(connectionPool) {
-      check(!force || exchange == null) { "cannot release connection while it is in use" }
-      releasedConnection = this.connection
-      socket = if (this.connection != null && exchange == null && (force || noMoreExchanges)) {
-        releaseConnectionNoEvents()
-      } else {
-        null
-      }
-      if (this.connection != null) releasedConnection = null
-      callEnd = noMoreExchanges && exchange == null
+
+    fun exchangeDoneDueToException() {
+        synchronized(connectionPool) {
+            check(!noMoreExchanges)
+            exchange = null
+        }
     }
-    socket?.closeQuietly()
 
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection!!)
+    /**
+     * Releases resources held with the request or response of [exchange]. This should be called when
+     * the request completes normally or when it fails due to an exception, in which case [e] should
+     * be non-null.
+     *
+     * If the exchange was canceled or timed out, this will wrap [e] in an exception that provides
+     * that additional context. Otherwise [e] is returned as-is.
+     */
+    internal fun <E : IOException?> exchangeMessageDone(
+            exchange: Exchange,
+            requestDone: Boolean,
+            responseDone: Boolean,
+            e: E
+    ): E {
+        var result = e
+        var exchangeDone = false
+        synchronized(connectionPool) {
+            if (exchange != this.exchange) {
+                return result // This exchange was detached violently!
+            }
+            var changed = false
+            if (requestDone) {
+                if (!exchangeRequestDone) changed = true
+                this.exchangeRequestDone = true
+            }
+            if (responseDone) {
+                if (!exchangeResponseDone) changed = true
+                this.exchangeResponseDone = true
+            }
+            if (exchangeRequestDone && exchangeResponseDone && changed) {
+                exchangeDone = true
+                this.exchange!!.connection()!!.successCount++
+                this.exchange = null
+            }
+        }
+        if (exchangeDone) {
+            result = maybeReleaseConnection(result, false)
+        }
+        return result
     }
 
-    if (callEnd) {
-      val callFailed = result != null
-      result = timeoutExit(result)
-      if (callFailed) {
-        eventListener.callFailed(call, result!!)
-      } else {
-        eventListener.callEnd(call)
-      }
+    fun noMoreExchanges(e: IOException?): IOException? {
+        synchronized(connectionPool) {
+            noMoreExchanges = true
+        }
+        return maybeReleaseConnection(e, false)
     }
-    return result
-  }
 
-  fun canRetry(): Boolean {
-    return exchangeFinder!!.hasStreamFailure() && exchangeFinder!!.hasRouteToTry()
-  }
+    /**
+     * Release the connection if it is no longer needed. This is called after each exchange completes
+     * and after the call signals that no more exchanges are expected.
+     *
+     * If the transmitter was canceled or timed out, this will wrap [e] in an exception that provides
+     * that additional context. Otherwise [e] is returned as-is.
+     *
+     * @param force true to release the connection even if more exchanges are expected for the call.
+     */
+    private fun <E : IOException?> maybeReleaseConnection(e: E, force: Boolean): E {
+        var result = e
+        val socket: Socket?
+        var releasedConnection: Connection?
+        val callEnd: Boolean
+        synchronized(connectionPool) {
+            check(!force || exchange == null) { "cannot release connection while it is in use" }
+            releasedConnection = this.connection
+            socket = if (this.connection != null && exchange == null && (force || noMoreExchanges)) {
+                releaseConnectionNoEvents()
+            } else {
+                null
+            }
+            if (this.connection != null) releasedConnection = null
+            callEnd = noMoreExchanges && exchange == null
+        }
+        socket?.closeQuietly()
+
+        if (releasedConnection != null) {
+            eventListener.connectionReleased(call, releasedConnection!!)
+        }
+
+        if (callEnd) {
+            val callFailed = result != null
+            result = timeoutExit(result)
+            if (callFailed) {
+                eventListener.callFailed(call, result!!)
+            } else {
+                eventListener.callEnd(call)
+            }
+        }
+        return result
+    }
 
-  fun hasExchange(): Boolean {
-    synchronized(connectionPool) {
-      return exchange != null
+    fun canRetry(): Boolean {
+        return exchangeFinder!!.hasStreamFailure() && exchangeFinder!!.hasRouteToTry()
     }
-  }
-
-  /**
-   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
-   * in-flight request from any thread. It's the caller's responsibility to close the request body
-   * and response body streams; otherwise resources may be leaked.
-   *
-   * This method is safe to be called concurrently, but provides limited guarantees. If a transport
-   * layer connection has been established (such as a HTTP/2 stream) that is terminated. Otherwise
-   * if a socket connection is being established, that is terminated.
-   */
-  fun cancel() {
-    val exchangeToCancel: Exchange?
-    val connectionToCancel: RealConnection?
-    synchronized(connectionPool) {
-      canceled = true
-      exchangeToCancel = exchange
-      connectionToCancel = exchangeFinder?.connectingConnection() ?: connection
+
+    fun hasExchange(): Boolean {
+        synchronized(connectionPool) {
+            return exchange != null
+        }
     }
-    exchangeToCancel?.cancel() ?: connectionToCancel?.cancel()
-  }
 
-  internal class TransmitterReference(
-    referent: Transmitter,
     /**
-     * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
-     * identifying the origin of connection leaks.
+     * Immediately closes the socket connection if it's currently held. Use this to interrupt an
+     * in-flight request from any thread. It's the caller's responsibility to close the request body
+     * and response body streams; otherwise resources may be leaked.
+     *
+     * This method is safe to be called concurrently, but provides limited guarantees. If a transport
+     * layer connection has been established (such as a HTTP/2 stream) that is terminated. Otherwise
+     * if a socket connection is being established, that is terminated.
      */
-    val callStackTrace: Any?
-  ) : WeakReference<Transmitter>(referent)
+    fun cancel() {
+        val exchangeToCancel: Exchange?
+        val connectionToCancel: RealConnection?
+        synchronized(connectionPool) {
+            canceled = true
+            exchangeToCancel = exchange
+            connectionToCancel = exchangeFinder?.connectingConnection() ?: connection
+        }
+        exchangeToCancel?.cancel() ?: connectionToCancel?.cancel()
+    }
+
+    internal class TransmitterReference(
+            referent: Transmitter,
+            /**
+             * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
+             * identifying the origin of connection leaks.
+             */
+            val callStackTrace: Any?
+    ) : WeakReference<Transmitter>(referent)
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.kt b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.kt
index caf6957ab8..6f59e2d6ec 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.kt
@@ -34,84 +34,84 @@ import okio.buffer
  */
 class BridgeInterceptor(private val cookieJar: CookieJar) : Interceptor {
 
-  @Throws(IOException::class)
-  override fun intercept(chain: Interceptor.Chain): Response {
-    val userRequest = chain.request()
-    val requestBuilder = userRequest.newBuilder()
-
-    val body = userRequest.body
-    if (body != null) {
-      val contentType = body.contentType()
-      if (contentType != null) {
-        requestBuilder.header("Content-Type", contentType.toString())
-      }
-
-      val contentLength = body.contentLength()
-      if (contentLength != -1L) {
-        requestBuilder.header("Content-Length", contentLength.toString())
-        requestBuilder.removeHeader("Transfer-Encoding")
-      } else {
-        requestBuilder.header("Transfer-Encoding", "chunked")
-        requestBuilder.removeHeader("Content-Length")
-      }
+    @Throws(IOException::class)
+    override fun intercept(chain: Interceptor.Chain): Response {
+        val userRequest = chain.request()
+        val requestBuilder = userRequest.newBuilder()
+        // 检查request.将用户的request转换为发送到server的请求
+        val body = userRequest.body
+        if (body != null) {
+            val contentType = body.contentType()
+            if (contentType != null) {
+                requestBuilder.header("Content-Type", contentType.toString())
+            }
+
+            val contentLength = body.contentLength()
+            if (contentLength != -1L) {
+                requestBuilder.header("Content-Length", contentLength.toString())
+                requestBuilder.removeHeader("Transfer-Encoding")
+            } else {
+                requestBuilder.header("Transfer-Encoding", "chunked")
+                requestBuilder.removeHeader("Content-Length")
+            }
+        }
+
+        if (userRequest.header("Host") == null) {
+            requestBuilder.header("Host", userRequest.url.toHostHeader())
+        }
+
+        if (userRequest.header("Connection") == null) {
+            requestBuilder.header("Connection", "Keep-Alive")
+        }
+
+        // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
+        // the transfer stream.
+        var transparentGzip = false
+        if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
+            transparentGzip = true
+            requestBuilder.header("Accept-Encoding", "gzip")
+        }
+
+        val cookies = cookieJar.loadForRequest(userRequest.url)
+        if (cookies.isNotEmpty()) {
+            requestBuilder.header("Cookie", cookieHeader(cookies))
+        }
+
+        if (userRequest.header("User-Agent") == null) {
+            requestBuilder.header("User-Agent", userAgent)
+        }
+
+        val networkResponse = chain.proceed(requestBuilder.build())
+
+        cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)
+
+        val responseBuilder = networkResponse.newBuilder()
+                .request(userRequest)
+
+        if (transparentGzip &&
+                "gzip".equals(networkResponse.header("Content-Encoding"), ignoreCase = true) &&
+                networkResponse.promisesBody()) {
+            val responseBody = networkResponse.body
+            if (responseBody != null) {
+                val gzipSource = GzipSource(responseBody.source())
+                val strippedHeaders = networkResponse.headers.newBuilder()
+                        .removeAll("Content-Encoding")
+                        .removeAll("Content-Length")
+                        .build()
+                responseBuilder.headers(strippedHeaders)
+                val contentType = networkResponse.header("Content-Type")
+                responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer()))
+            }
+        }
+
+        return responseBuilder.build()
     }
 
-    if (userRequest.header("Host") == null) {
-      requestBuilder.header("Host", userRequest.url.toHostHeader())
+    /** Returns a 'Cookie' HTTP request header with all cookies, like `a=b; c=d`. */
+    private fun cookieHeader(cookies: List<Cookie>): String = buildString {
+        cookies.forEachIndexed { index, cookie ->
+            if (index > 0) append("; ")
+            append(cookie.name).append('=').append(cookie.value)
+        }
     }
-
-    if (userRequest.header("Connection") == null) {
-      requestBuilder.header("Connection", "Keep-Alive")
-    }
-
-    // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
-    // the transfer stream.
-    var transparentGzip = false
-    if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
-      transparentGzip = true
-      requestBuilder.header("Accept-Encoding", "gzip")
-    }
-
-    val cookies = cookieJar.loadForRequest(userRequest.url)
-    if (cookies.isNotEmpty()) {
-      requestBuilder.header("Cookie", cookieHeader(cookies))
-    }
-
-    if (userRequest.header("User-Agent") == null) {
-      requestBuilder.header("User-Agent", userAgent)
-    }
-
-    val networkResponse = chain.proceed(requestBuilder.build())
-
-    cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)
-
-    val responseBuilder = networkResponse.newBuilder()
-        .request(userRequest)
-
-    if (transparentGzip &&
-        "gzip".equals(networkResponse.header("Content-Encoding"), ignoreCase = true) &&
-        networkResponse.promisesBody()) {
-      val responseBody = networkResponse.body
-      if (responseBody != null) {
-        val gzipSource = GzipSource(responseBody.source())
-        val strippedHeaders = networkResponse.headers.newBuilder()
-            .removeAll("Content-Encoding")
-            .removeAll("Content-Length")
-            .build()
-        responseBuilder.headers(strippedHeaders)
-        val contentType = networkResponse.header("Content-Type")
-        responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer()))
-      }
-    }
-
-    return responseBuilder.build()
-  }
-
-  /** Returns a 'Cookie' HTTP request header with all cookies, like `a=b; c=d`. */
-  private fun cookieHeader(cookies: List<Cookie>): String = buildString {
-    cookies.forEachIndexed { index, cookie ->
-      if (index > 0) append("; ")
-      append(cookie.name).append('=').append(cookie.value)
-    }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.kt b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.kt
index 474970e881..212e395b28 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.kt
@@ -25,101 +25,101 @@ import java.net.ProtocolException
 /** This is the last interceptor in the chain. It makes a network call to the server. */
 class CallServerInterceptor(private val forWebSocket: Boolean) : Interceptor {
 
-  @Throws(IOException::class)
-  override fun intercept(chain: Interceptor.Chain): Response {
-    val realChain = chain as RealInterceptorChain
-    val exchange = realChain.exchange()
-    val request = realChain.request()
-    val requestBody = request.body
-    val sentRequestMillis = System.currentTimeMillis()
+    @Throws(IOException::class)
+    override fun intercept(chain: Interceptor.Chain): Response {
+        val realChain = chain as RealInterceptorChain
+        val exchange = realChain.exchange()
+        val request = realChain.request()
+        val requestBody = request.body
+        val sentRequestMillis = System.currentTimeMillis()
 
-    exchange.writeRequestHeaders(request)
+        exchange.writeRequestHeaders(request)
 
-    var responseHeadersStarted = false
-    var responseBuilder: Response.Builder? = null
-    if (HttpMethod.permitsRequestBody(request.method) && requestBody != null) {
-      // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
-      // Continue" response before transmitting the request body. If we don't get that, return
-      // what we did get (such as a 4xx response) without ever transmitting the request body.
-      if ("100-continue".equals(request.header("Expect"), ignoreCase = true)) {
-        exchange.flushRequest()
-        responseHeadersStarted = true
-        exchange.responseHeadersStart()
-        responseBuilder = exchange.readResponseHeaders(true)
-      }
-      if (responseBuilder == null) {
-        if (requestBody.isDuplex()) {
-          // Prepare a duplex body so that the application can send a request body later.
-          exchange.flushRequest()
-          val bufferedRequestBody = exchange.createRequestBody(request, true).buffer()
-          requestBody.writeTo(bufferedRequestBody)
+        var responseHeadersStarted = false
+        var responseBuilder: Response.Builder? = null
+        if (HttpMethod.permitsRequestBody(request.method) && requestBody != null) {
+            // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
+            // Continue" response before transmitting the request body. If we don't get that, return
+            // what we did get (such as a 4xx response) without ever transmitting the request body.
+            if ("100-continue".equals(request.header("Expect"), ignoreCase = true)) {
+                exchange.flushRequest()
+                responseHeadersStarted = true
+                exchange.responseHeadersStart()
+                responseBuilder = exchange.readResponseHeaders(true)
+            }
+            if (responseBuilder == null) {
+                if (requestBody.isDuplex()) {
+                    // Prepare a duplex body so that the application can send a request body later.
+                    exchange.flushRequest()
+                    val bufferedRequestBody = exchange.createRequestBody(request, true).buffer()
+                    requestBody.writeTo(bufferedRequestBody)
+                } else {
+                    // Write the request body if the "Expect: 100-continue" expectation was met.
+                    val bufferedRequestBody = exchange.createRequestBody(request, false).buffer()
+                    requestBody.writeTo(bufferedRequestBody)
+                    bufferedRequestBody.close()
+                }
+            } else {
+                exchange.noRequestBody()
+                if (!exchange.connection()!!.isMultiplexed) {
+                    // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
+                    // from being reused. Otherwise we're still obligated to transmit the request body to
+                    // leave the connection in a consistent state.
+                    exchange.noNewExchangesOnConnection()
+                }
+            }
         } else {
-          // Write the request body if the "Expect: 100-continue" expectation was met.
-          val bufferedRequestBody = exchange.createRequestBody(request, false).buffer()
-          requestBody.writeTo(bufferedRequestBody)
-          bufferedRequestBody.close()
+            exchange.noRequestBody()
         }
-      } else {
-        exchange.noRequestBody()
-        if (!exchange.connection()!!.isMultiplexed) {
-          // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
-          // from being reused. Otherwise we're still obligated to transmit the request body to
-          // leave the connection in a consistent state.
-          exchange.noNewExchangesOnConnection()
-        }
-      }
-    } else {
-      exchange.noRequestBody()
-    }
 
-    if (requestBody == null || !requestBody.isDuplex()) {
-      exchange.finishRequest()
-    }
-    if (!responseHeadersStarted) {
-      exchange.responseHeadersStart()
-    }
-    if (responseBuilder == null) {
-      responseBuilder = exchange.readResponseHeaders(false)!!
-    }
-    var response = responseBuilder
-        .request(request)
-        .handshake(exchange.connection()!!.handshake())
-        .sentRequestAtMillis(sentRequestMillis)
-        .receivedResponseAtMillis(System.currentTimeMillis())
-        .build()
-    var code = response.code
-    if (code == 100) {
-      // server sent a 100-continue even though we did not request one.
-      // try again to read the actual response
-      response = exchange.readResponseHeaders(false)!!
-          .request(request)
-          .handshake(exchange.connection()!!.handshake())
-          .sentRequestAtMillis(sentRequestMillis)
-          .receivedResponseAtMillis(System.currentTimeMillis())
-          .build()
-      code = response.code
-    }
+        if (requestBody == null || !requestBody.isDuplex()) {
+            exchange.finishRequest()
+        }
+        if (!responseHeadersStarted) {
+            exchange.responseHeadersStart()
+        }
+        if (responseBuilder == null) {
+            responseBuilder = exchange.readResponseHeaders(false)!!
+        }
+        var response = responseBuilder
+                .request(request)
+                .handshake(exchange.connection()!!.handshake())
+                .sentRequestAtMillis(sentRequestMillis)
+                .receivedResponseAtMillis(System.currentTimeMillis())
+                .build()
+        var code = response.code
+        if (code == 100) {
+            // server sent a 100-continue even though we did not request one.
+            // try again to read the actual response
+            response = exchange.readResponseHeaders(false)!!
+                    .request(request)
+                    .handshake(exchange.connection()!!.handshake())
+                    .sentRequestAtMillis(sentRequestMillis)
+                    .receivedResponseAtMillis(System.currentTimeMillis())
+                    .build()
+            code = response.code
+        }
 
-    exchange.responseHeadersEnd(response)
+        exchange.responseHeadersEnd(response)
 
-    response = if (forWebSocket && code == 101) {
-      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
-      response.newBuilder()
-          .body(EMPTY_RESPONSE)
-          .build()
-    } else {
-      response.newBuilder()
-          .body(exchange.openResponseBody(response))
-          .build()
-    }
-    if ("close".equals(response.request.header("Connection"), ignoreCase = true) ||
-        "close".equals(response.header("Connection"), ignoreCase = true)) {
-      exchange.noNewExchangesOnConnection()
-    }
-    if ((code == 204 || code == 205) && response.body?.contentLength() ?: -1L > 0L) {
-      throw ProtocolException(
-          "HTTP $code had non-zero Content-Length: ${response.body?.contentLength()}")
+        response = if (forWebSocket && code == 101) {
+            // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
+            response.newBuilder()
+                    .body(EMPTY_RESPONSE)
+                    .build()
+        } else {
+            response.newBuilder()
+                    .body(exchange.openResponseBody(response))
+                    .build()
+        }
+        if ("close".equals(response.request.header("Connection"), ignoreCase = true) ||
+                "close".equals(response.header("Connection"), ignoreCase = true)) {
+            exchange.noNewExchangesOnConnection()
+        }
+        if ((code == 204 || code == 205) && response.body?.contentLength() ?: -1L > 0L) {
+            throw ProtocolException(
+                    "HTTP $code had non-zero Content-Length: ${response.body?.contentLength()}")
+        }
+        return response
     }
-    return response
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt
index 5f1b787c8f..3e2c93a129 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 @file:JvmName("HttpHeaders")
+
 package okhttp3.internal.http
 
 import okhttp3.Challenge
@@ -56,101 +57,101 @@ private val TOKEN_DELIMITERS = "\t ,=".encodeUtf8()
  * ```
  */
 fun Headers.parseChallenges(headerName: String): List<Challenge> {
-  val result = mutableListOf<Challenge>()
-  for (h in 0 until size) {
-    if (headerName.equals(name(h), ignoreCase = true)) {
-      val header = Buffer().writeUtf8(value(h))
-      try {
-        header.readChallengeHeader(result)
-      } catch (e: EOFException) {
-        Platform.get().log(Platform.WARN, "Unable to parse challenge", e)
-      }
+    val result = mutableListOf<Challenge>()
+    for (h in 0 until size) {
+        if (headerName.equals(name(h), ignoreCase = true)) {
+            val header = Buffer().writeUtf8(value(h))
+            try {
+                header.readChallengeHeader(result)
+            } catch (e: EOFException) {
+                Platform.get().log(Platform.WARN, "Unable to parse challenge", e)
+            }
+        }
     }
-  }
-  return result
+    return result
 }
 
 @Throws(EOFException::class)
 private fun Buffer.readChallengeHeader(result: MutableList<Challenge>) {
-  var peek: String? = null
-
-  while (true) {
-    // Read a scheme name for this challenge if we don't have one already.
-    if (peek == null) {
-      skipCommasAndWhitespace()
-      peek = readToken()
-      if (peek == null) return
-    }
-
-    val schemeName = peek
+    var peek: String? = null
 
-    // Read a token68, a sequence of parameters, or nothing.
-    val commaPrefixed = skipCommasAndWhitespace()
-    peek = readToken()
-    if (peek == null) {
-      if (!exhausted()) return // Expected a token; got something else.
-      result.add(Challenge(schemeName, emptyMap()))
-      return
-    }
+    while (true) {
+        // Read a scheme name for this challenge if we don't have one already.
+        if (peek == null) {
+            skipCommasAndWhitespace()
+            peek = readToken()
+            if (peek == null) return
+        }
 
-    var eqCount = skipAll('='.toByte())
-    val commaSuffixed = skipCommasAndWhitespace()
+        val schemeName = peek
 
-    // It's a token68 because there isn't a value after it.
-    if (!commaPrefixed && (commaSuffixed || exhausted())) {
-      result.add(Challenge(schemeName,
-          Collections.singletonMap<String, String>(null, peek + "=".repeat(eqCount))))
-      peek = null
-      continue
-    }
-
-    // It's a series of parameter names and values.
-    val parameters = mutableMapOf<String?, String>()
-    eqCount += skipAll('='.toByte())
-    while (true) {
-      if (peek == null) {
+        // Read a token68, a sequence of parameters, or nothing.
+        val commaPrefixed = skipCommasAndWhitespace()
         peek = readToken()
-        if (skipCommasAndWhitespace()) break // We peeked a scheme name followed by ','.
-        eqCount = skipAll('='.toByte())
-      }
-      if (eqCount == 0) break // We peeked a scheme name.
-      if (eqCount > 1) return // Unexpected '=' characters.
-      if (skipCommasAndWhitespace()) return // Unexpected ','.
-
-      val parameterValue = when {
-        startsWith('"'.toByte()) -> readQuotedString()
-        else -> readToken()
-      } ?: return // Expected a value.
-
-      val replaced = parameters.put(peek, parameterValue)
-      peek = null
-      if (replaced != null) return // Unexpected duplicate parameter.
-      if (!skipCommasAndWhitespace() && !exhausted()) return // Expected ',' or EOF.
+        if (peek == null) {
+            if (!exhausted()) return // Expected a token; got something else.
+            result.add(Challenge(schemeName, emptyMap()))
+            return
+        }
+
+        var eqCount = skipAll('='.toByte())
+        val commaSuffixed = skipCommasAndWhitespace()
+
+        // It's a token68 because there isn't a value after it.
+        if (!commaPrefixed && (commaSuffixed || exhausted())) {
+            result.add(Challenge(schemeName,
+                    Collections.singletonMap<String, String>(null, peek + "=".repeat(eqCount))))
+            peek = null
+            continue
+        }
+
+        // It's a series of parameter names and values.
+        val parameters = mutableMapOf<String?, String>()
+        eqCount += skipAll('='.toByte())
+        while (true) {
+            if (peek == null) {
+                peek = readToken()
+                if (skipCommasAndWhitespace()) break // We peeked a scheme name followed by ','.
+                eqCount = skipAll('='.toByte())
+            }
+            if (eqCount == 0) break // We peeked a scheme name.
+            if (eqCount > 1) return // Unexpected '=' characters.
+            if (skipCommasAndWhitespace()) return // Unexpected ','.
+
+            val parameterValue = when {
+                startsWith('"'.toByte()) -> readQuotedString()
+                else -> readToken()
+            } ?: return // Expected a value.
+
+            val replaced = parameters.put(peek, parameterValue)
+            peek = null
+            if (replaced != null) return // Unexpected duplicate parameter.
+            if (!skipCommasAndWhitespace() && !exhausted()) return // Expected ',' or EOF.
+        }
+        result.add(Challenge(schemeName, parameters))
     }
-    result.add(Challenge(schemeName, parameters))
-  }
 }
 
 /** Returns true if any commas were skipped. */
 private fun Buffer.skipCommasAndWhitespace(): Boolean {
-  var commaFound = false
-  loop@ while (!exhausted()) {
-    when (this[0]) {
-      ','.toByte() -> {
-        // Consume ','.
-        readByte()
-        commaFound = true
-      }
-
-      ' '.toByte(), '\t'.toByte() -> {
-        readByte()
-        // Consume space or tab.
-      }
-
-      else -> break@loop
+    var commaFound = false
+    loop@ while (!exhausted()) {
+        when (this[0]) {
+            ','.toByte() -> {
+                // Consume ','.
+                readByte()
+                commaFound = true
+            }
+
+            ' '.toByte(), '\t'.toByte() -> {
+                readByte()
+                // Consume space or tab.
+            }
+
+            else -> break@loop
+        }
     }
-  }
-  return commaFound
+    return commaFound
 }
 
 private fun Buffer.startsWith(prefix: Byte) = !exhausted() && this[0] == prefix
@@ -162,25 +163,25 @@ private fun Buffer.startsWith(prefix: Byte) = !exhausted() && this[0] == prefix
  */
 @Throws(EOFException::class)
 private fun Buffer.readQuotedString(): String? {
-  require(readByte() == '\"'.toByte())
-  val result = Buffer()
-  while (true) {
-    val i = indexOfElement(QUOTED_STRING_DELIMITERS)
-    if (i == -1L) return null // Unterminated quoted string.
-
-    if (this[i] == '"'.toByte()) {
-      result.write(this, i)
-      // Consume '"'.
-      readByte()
-      return result.readUtf8()
+    require(readByte() == '\"'.toByte())
+    val result = Buffer()
+    while (true) {
+        val i = indexOfElement(QUOTED_STRING_DELIMITERS)
+        if (i == -1L) return null // Unterminated quoted string.
+
+        if (this[i] == '"'.toByte()) {
+            result.write(this, i)
+            // Consume '"'.
+            readByte()
+            return result.readUtf8()
+        }
+
+        if (size == i + 1L) return null // Dangling escape.
+        result.write(this, i)
+        // Consume '\'.
+        readByte()
+        result.write(this, 1L) // The escaped character.
     }
-
-    if (size == i + 1L) return null // Dangling escape.
-    result.write(this, i)
-    // Consume '\'.
-    readByte()
-    result.write(this, 1L) // The escaped character.
-  }
 }
 
 /**
@@ -188,22 +189,22 @@ private fun Buffer.readQuotedString(): String? {
  * [TOKEN_DELIMITERS]. Returns null if the buffer is empty or prefixed with a delimiter.
  */
 private fun Buffer.readToken(): String? {
-  var tokenSize = indexOfElement(TOKEN_DELIMITERS)
-  if (tokenSize == -1L) tokenSize = size
+    var tokenSize = indexOfElement(TOKEN_DELIMITERS)
+    if (tokenSize == -1L) tokenSize = size
 
-  return when {
-    tokenSize != 0L -> readUtf8(tokenSize)
-    else -> null
-  }
+    return when {
+        tokenSize != 0L -> readUtf8(tokenSize)
+        else -> null
+    }
 }
 
 fun CookieJar.receiveHeaders(url: HttpUrl, headers: Headers) {
-  if (this === CookieJar.NO_COOKIES) return
+    if (this === CookieJar.NO_COOKIES) return
 
-  val cookies = Cookie.parseAll(url, headers)
-  if (cookies.isEmpty()) return
+    val cookies = Cookie.parseAll(url, headers)
+    if (cookies.isEmpty()) return
 
-  saveFromResponse(url, cookies)
+    saveFromResponse(url, cookies)
 }
 
 /**
@@ -211,24 +212,24 @@ fun CookieJar.receiveHeaders(url: HttpUrl, headers: Headers) {
  * 0-length) body. See RFC 7231.
  */
 fun Response.promisesBody(): Boolean {
-  // HEAD requests never yield a body regardless of the response headers.
-  if (request.method == "HEAD") {
+    // HEAD requests never yield a body regardless of the response headers.
+    if (request.method == "HEAD") {
+        return false
+    }
+
+    val responseCode = code
+    if ((responseCode < HTTP_CONTINUE || responseCode >= 200) &&
+            responseCode != HTTP_NO_CONTENT &&
+            responseCode != HTTP_NOT_MODIFIED) {
+        return true
+    }
+
+    // If the Content-Length or Transfer-Encoding headers disagree with the response code, the
+    // response is malformed. For best compatibility, we honor the headers.
+    if (headersContentLength() != -1L ||
+            "chunked".equals(header("Transfer-Encoding"), ignoreCase = true)) {
+        return true
+    }
+
     return false
-  }
-
-  val responseCode = code
-  if ((responseCode < HTTP_CONTINUE || responseCode >= 200) &&
-      responseCode != HTTP_NO_CONTENT &&
-      responseCode != HTTP_NOT_MODIFIED) {
-    return true
-  }
-
-  // If the Content-Length or Transfer-Encoding headers disagree with the response code, the
-  // response is malformed. For best compatibility, we honor the headers.
-  if (headersContentLength() != -1L ||
-      "chunked".equals(header("Transfer-Encoding"), ignoreCase = true)) {
-    return true
-  }
-
-  return false
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.kt b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.kt
index 157324d662..d1c2895457 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.kt
@@ -34,91 +34,91 @@ import java.util.concurrent.TimeUnit
  * Otherwise it is for a network interceptor and [connection] must be non-null.
  */
 class RealInterceptorChain(
-  private val interceptors: List<Interceptor>,
-  private val transmitter: Transmitter,
-  private val exchange: Exchange?,
-  private val index: Int,
-  private val request: Request,
-  private val call: Call,
-  private val connectTimeout: Int,
-  private val readTimeout: Int,
-  private val writeTimeout: Int
+        private val interceptors: List<Interceptor>,
+        private val transmitter: Transmitter,
+        private val exchange: Exchange?,
+        private val index: Int,
+        private val request: Request,
+        private val call: Call,
+        private val connectTimeout: Int,
+        private val readTimeout: Int,
+        private val writeTimeout: Int
 ) : Interceptor.Chain {
 
-  private var calls: Int = 0
+    private var calls: Int = 0
 
-  override fun connection(): Connection? {
-    return exchange?.connection()
-  }
+    override fun connection(): Connection? {
+        return exchange?.connection()
+    }
 
-  override fun connectTimeoutMillis(): Int = connectTimeout
+    override fun connectTimeoutMillis(): Int = connectTimeout
 
-  override fun withConnectTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain {
-    val millis = checkDuration("timeout", timeout.toLong(), unit)
-    return RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
-        millis, readTimeout, writeTimeout)
-  }
+    override fun withConnectTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain {
+        val millis = checkDuration("timeout", timeout.toLong(), unit)
+        return RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
+                millis, readTimeout, writeTimeout)
+    }
 
-  override fun readTimeoutMillis(): Int = readTimeout
+    override fun readTimeoutMillis(): Int = readTimeout
 
-  override fun withReadTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain {
-    val millis = checkDuration("timeout", timeout.toLong(), unit)
-    return RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
-        connectTimeout, millis, writeTimeout)
-  }
+    override fun withReadTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain {
+        val millis = checkDuration("timeout", timeout.toLong(), unit)
+        return RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
+                connectTimeout, millis, writeTimeout)
+    }
 
-  override fun writeTimeoutMillis(): Int = writeTimeout
+    override fun writeTimeoutMillis(): Int = writeTimeout
 
-  override fun withWriteTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain {
-    val millis = checkDuration("timeout", timeout.toLong(), unit)
-    return RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
-        connectTimeout, readTimeout, millis)
-  }
+    override fun withWriteTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain {
+        val millis = checkDuration("timeout", timeout.toLong(), unit)
+        return RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
+                connectTimeout, readTimeout, millis)
+    }
 
-  fun transmitter(): Transmitter = transmitter
+    fun transmitter(): Transmitter = transmitter
 
-  fun exchange(): Exchange = exchange!!
+    fun exchange(): Exchange = exchange!!
 
-  override fun call(): Call = call
+    override fun call(): Call = call
 
-  override fun request(): Request = request
+    override fun request(): Request = request
 
-  override fun proceed(request: Request): Response {
-    return proceed(request, transmitter, exchange)
-  }
+    override fun proceed(request: Request): Response {
+        return proceed(request, transmitter, exchange)
+    }
 
-  @Throws(IOException::class)
-  fun proceed(request: Request, transmitter: Transmitter, exchange: Exchange?): Response {
-    if (index >= interceptors.size) throw AssertionError()
+    @Throws(IOException::class)
+    fun proceed(request: Request, transmitter: Transmitter, exchange: Exchange?): Response {
+        if (index >= interceptors.size) throw AssertionError()
 
-    calls++
+        calls++
 
-    // If we already have a stream, confirm that the incoming request will use it.
-    check(this.exchange == null || this.exchange.connection()!!.supportsUrl(request.url)) {
-      "network interceptor ${interceptors[index - 1]} must retain the same host and port"
-    }
+        // If we already have a stream, confirm that the incoming request will use it.
+        check(this.exchange == null || this.exchange.connection()!!.supportsUrl(request.url)) {
+            "network interceptor ${interceptors[index - 1]} must retain the same host and port"
+        }
 
-    // If we already have a stream, confirm that this is the only call to chain.proceed().
-    check(this.exchange == null || calls <= 1) {
-      "network interceptor ${interceptors[index - 1]} must call proceed() exactly once"
-    }
+        // If we already have a stream, confirm that this is the only call to chain.proceed().
+        check(this.exchange == null || calls <= 1) {
+            "network interceptor ${interceptors[index - 1]} must call proceed() exactly once"
+        }
 
-    // Call the next interceptor in the chain.
-    val next = RealInterceptorChain(interceptors, transmitter, exchange,
-        index + 1, request, call, connectTimeout, readTimeout, writeTimeout)
-    val interceptor = interceptors[index]
+        // Call the next interceptor in the chain.
+        val next = RealInterceptorChain(interceptors, transmitter, exchange,
+                index + 1, request, call, connectTimeout, readTimeout, writeTimeout)
+        val interceptor = interceptors[index]
 
-    @Suppress("USELESS_ELVIS")
-    val response = interceptor.intercept(next) ?: throw NullPointerException(
-        "interceptor $interceptor returned null")
+        @Suppress("USELESS_ELVIS")
+        val response = interceptor.intercept(next) ?: throw NullPointerException(
+                "interceptor $interceptor returned null")
 
-    // Confirm that the next interceptor made its required call to chain.proceed().
-    check(exchange == null || index + 1 >= interceptors.size || next.calls == 1) {
-      "network interceptor $interceptor must call proceed() exactly once"
-    }
+        // Confirm that the next interceptor made its required call to chain.proceed().
+        check(exchange == null || index + 1 >= interceptors.size || next.calls == 1) {
+            "network interceptor $interceptor must call proceed() exactly once"
+        }
 
-    check(response.body != null) { "interceptor $interceptor returned a response with no body" }
+        check(response.body != null) { "interceptor $interceptor returned a response with no body" }
 
-    return response
-  }
+        return response
+    }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.kt b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.kt
index 8f156b8eae..39b8468dfc 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.kt
@@ -51,279 +51,284 @@ import javax.net.ssl.SSLPeerUnverifiedException
  */
 class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Interceptor {
 
-  @Throws(IOException::class)
-  override fun intercept(chain: Interceptor.Chain): Response {
-    var request = chain.request()
-    val realChain = chain as RealInterceptorChain
-    val transmitter = realChain.transmitter()
-    var followUpCount = 0
-    var priorResponse: Response? = null
-    while (true) {
-      transmitter.prepareToConnect(request)
-
-      if (transmitter.isCanceled) {
-        throw IOException("Canceled")
-      }
-
-      var response: Response
-      var success = false
-      try {
-        response = realChain.proceed(request, transmitter, null)
-        success = true
-      } catch (e: RouteException) {
-        // The attempt to connect via a route failed. The request will not have been sent.
-        if (!recover(e.lastConnectException, transmitter, false, request)) {
-          throw e.firstConnectException
+    @Throws(IOException::class)
+    override fun intercept(chain: Interceptor.Chain): Response {
+        var request = chain.request()
+        val realChain = chain as RealInterceptorChain
+        val transmitter = realChain.transmitter()
+        var followUpCount = 0
+        var priorResponse: Response? = null
+        while (true) {
+            transmitter.prepareToConnect(request)
+
+            if (transmitter.isCanceled) {
+                throw IOException("Canceled")
+            }
+
+            var response: Response
+            var success = false
+            try {
+                // 调用下一个拦截器
+                response = realChain.proceed(request, transmitter, null)
+                success = true
+            } catch (e: RouteException) {
+                // The attempt to connect via a route failed. The request will not have been sent.
+                // 通过路由连接失败， 请求不会再发送
+                if (!recover(e.lastConnectException, transmitter, false, request)) {
+                    throw e.firstConnectException
+                }
+                continue
+            } catch (e: IOException) {
+                // An attempt to communicate with a server failed. The request may have been sent.
+                // 与服务器尝试通信失败， 请求不会失败
+                val requestSendStarted = e !is ConnectionShutdownException
+                if (!recover(e, transmitter, requestSendStarted, request)) throw e
+                continue
+            } finally {
+                // The network call threw an exception. Release any resources.
+                // 抛出未检查异常， 释放资源
+                if (!success) {
+                    transmitter.exchangeDoneDueToException()
+                }
+            }
+
+            // Attach the prior response if it exists. Such responses never have a body.
+            // 添加之前存在的response， response没有body
+            if (priorResponse != null) {
+                response = response.newBuilder()
+                        .priorResponse(priorResponse.newBuilder()
+                                .body(null)
+                                .build())
+                        .build()
+            }
+
+            val exchange = response.exchange
+            val route = exchange?.connection()?.route()
+            val followUp = followUpRequest(response, route)
+
+            if (followUp == null) {
+                if (exchange != null && exchange.isDuplex) {
+                    transmitter.timeoutEarlyExit()
+                }
+                return response
+            }
+
+            val followUpBody = followUp.body
+            if (followUpBody != null && followUpBody.isOneShot()) {
+                return response
+            }
+
+            response.body?.closeQuietly()
+            if (transmitter.hasExchange()) {
+                exchange?.detachWithViolence()
+            }
+
+            if (++followUpCount > MAX_FOLLOW_UPS) {
+                throw ProtocolException("Too many follow-up requests: $followUpCount")
+            }
+
+            request = followUp
+            priorResponse = response
         }
-        continue
-      } catch (e: IOException) {
-        // An attempt to communicate with a server failed. The request may have been sent.
-        val requestSendStarted = e !is ConnectionShutdownException
-        if (!recover(e, transmitter, requestSendStarted, request)) throw e
-        continue
-      } finally {
-        // The network call threw an exception. Release any resources.
-        if (!success) {
-          transmitter.exchangeDoneDueToException()
-        }
-      }
-
-      // Attach the prior response if it exists. Such responses never have a body.
-      if (priorResponse != null) {
-        response = response.newBuilder()
-            .priorResponse(priorResponse.newBuilder()
-                .body(null)
-                .build())
-            .build()
-      }
-
-      val exchange = response.exchange
-      val route = exchange?.connection()?.route()
-      val followUp = followUpRequest(response, route)
-
-      if (followUp == null) {
-        if (exchange != null && exchange.isDuplex) {
-          transmitter.timeoutEarlyExit()
-        }
-        return response
-      }
-
-      val followUpBody = followUp.body
-      if (followUpBody != null && followUpBody.isOneShot()) {
-        return response
-      }
-
-      response.body?.closeQuietly()
-      if (transmitter.hasExchange()) {
-        exchange?.detachWithViolence()
-      }
-
-      if (++followUpCount > MAX_FOLLOW_UPS) {
-        throw ProtocolException("Too many follow-up requests: $followUpCount")
-      }
-
-      request = followUp
-      priorResponse = response
-    }
-  }
-
-  /**
-   * Report and attempt to recover from a failure to communicate with a server. Returns true if
-   * `e` is recoverable, or false if the failure is permanent. Requests with a body can only
-   * be recovered if the body is buffered or if the failure occurred before the request has been
-   * sent.
-   */
-  private fun recover(
-    e: IOException,
-    transmitter: Transmitter,
-    requestSendStarted: Boolean,
-    userRequest: Request
-  ): Boolean {
-    // The application layer has forbidden retries.
-    if (!client.retryOnConnectionFailure) return false
-
-    // We can't send the request body again.
-    if (requestSendStarted && requestIsOneShot(e, userRequest)) return false
-
-    // This exception is fatal.
-    if (!isRecoverable(e, requestSendStarted)) return false
-
-    // No more routes to attempt.
-    if (!transmitter.canRetry()) return false
-    // For failure recovery, use the same route selector with a new connection.
-    return true
-  }
-
-  private fun requestIsOneShot(e: IOException, userRequest: Request): Boolean {
-    val requestBody = userRequest.body
-    return (requestBody != null && requestBody.isOneShot()) ||
-        e is FileNotFoundException
-  }
-
-  private fun isRecoverable(e: IOException, requestSendStarted: Boolean): Boolean {
-    // If there was a protocol problem, don't recover.
-    if (e is ProtocolException) {
-      return false
     }
 
-    // If there was an interruption don't recover, but if there was a timeout connecting to a route
-    // we should try the next route (if there is one).
-    if (e is InterruptedIOException) {
-      return e is SocketTimeoutException && !requestSendStarted
+    /**
+     * Report and attempt to recover from a failure to communicate with a server. Returns true if
+     * `e` is recoverable, or false if the failure is permanent. Requests with a body can only
+     * be recovered if the body is buffered or if the failure occurred before the request has been
+     * sent.
+     */
+    private fun recover(
+            e: IOException,
+            transmitter: Transmitter,
+            requestSendStarted: Boolean,
+            userRequest: Request
+    ): Boolean {
+        // The application layer has forbidden retries.
+        if (!client.retryOnConnectionFailure) return false
+
+        // We can't send the request body again.
+        if (requestSendStarted && requestIsOneShot(e, userRequest)) return false
+
+        // This exception is fatal.
+        if (!isRecoverable(e, requestSendStarted)) return false
+
+        // No more routes to attempt.
+        if (!transmitter.canRetry()) return false
+        // For failure recovery, use the same route selector with a new connection.
+        return true
     }
 
-    // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
-    // again with a different route.
-    if (e is SSLHandshakeException) {
-      // If the problem was a CertificateException from the X509TrustManager,
-      // do not retry.
-      if (e.cause is CertificateException) {
-        return false
-      }
-    }
-    if (e is SSLPeerUnverifiedException) {
-      // e.g. a certificate pinning error.
-      return false
+    private fun requestIsOneShot(e: IOException, userRequest: Request): Boolean {
+        val requestBody = userRequest.body
+        return (requestBody != null && requestBody.isOneShot()) ||
+                e is FileNotFoundException
     }
-    // An example of one we might want to retry with a different route is a problem connecting to a
-    // proxy and would manifest as a standard IOException. Unless it is one we know we should not
-    // retry, we return true and try a new route.
-    return true
-  }
-
-  /**
-   * Figures out the HTTP request to make in response to receiving [userResponse]. This will
-   * either add authentication headers, follow redirects or handle a client request timeout. If a
-   * follow-up is either unnecessary or not applicable, this returns null.
-   */
-  @Throws(IOException::class)
-  private fun followUpRequest(userResponse: Response, route: Route?): Request? {
-    val responseCode = userResponse.code
-
-    val method = userResponse.request.method
-    when (responseCode) {
-      HTTP_PROXY_AUTH -> {
-        val selectedProxy = route!!.proxy
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy")
-        }
-        return client.proxyAuthenticator.authenticate(route, userResponse)
-      }
-
-      HTTP_UNAUTHORIZED -> return client.authenticator.authenticate(route, userResponse)
 
-      HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT -> {
-        // "If the 307 or 308 status code is received in response to a request other than GET
-        // or HEAD, the user agent MUST NOT automatically redirect the request"
-        if (method != "GET" && method != "HEAD") {
-          return null
+    private fun isRecoverable(e: IOException, requestSendStarted: Boolean): Boolean {
+        // If there was a protocol problem, don't recover.
+        if (e is ProtocolException) {
+            return false
         }
-        return buildRedirectRequest(userResponse, method)
-      }
-
-      HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -> {
-        return buildRedirectRequest(userResponse, method)
-      }
-
-      HTTP_CLIENT_TIMEOUT -> {
-        // 408's are rare in practice, but some servers like HAProxy use this response code. The
-        // spec says that we may repeat the request without modifications. Modern browsers also
-        // repeat the request (even non-idempotent ones.)
-        if (!client.retryOnConnectionFailure) {
-          // The application layer has directed us not to retry the request.
-          return null
+
+        // If there was an interruption don't recover, but if there was a timeout connecting to a route
+        // we should try the next route (if there is one).
+        if (e is InterruptedIOException) {
+            return e is SocketTimeoutException && !requestSendStarted
         }
 
-        val requestBody = userResponse.request.body
-        if (requestBody != null && requestBody.isOneShot()) {
-          return null
+        // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
+        // again with a different route.
+        if (e is SSLHandshakeException) {
+            // If the problem was a CertificateException from the X509TrustManager,
+            // do not retry.
+            if (e.cause is CertificateException) {
+                return false
+            }
         }
-        val priorResponse = userResponse.priorResponse
-        if (priorResponse != null && priorResponse.code == HTTP_CLIENT_TIMEOUT) {
-          // We attempted to retry and got another timeout. Give up.
-          return null
+        if (e is SSLPeerUnverifiedException) {
+            // e.g. a certificate pinning error.
+            return false
         }
+        // An example of one we might want to retry with a different route is a problem connecting to a
+        // proxy and would manifest as a standard IOException. Unless it is one we know we should not
+        // retry, we return true and try a new route.
+        return true
+    }
 
-        if (retryAfter(userResponse, 0) > 0) {
-          return null
+    /**
+     * Figures out the HTTP request to make in response to receiving [userResponse]. This will
+     * either add authentication headers, follow redirects or handle a client request timeout. If a
+     * follow-up is either unnecessary or not applicable, this returns null.
+     */
+    @Throws(IOException::class)
+    private fun followUpRequest(userResponse: Response, route: Route?): Request? {
+        val responseCode = userResponse.code
+
+        val method = userResponse.request.method
+        when (responseCode) {
+            HTTP_PROXY_AUTH -> {
+                val selectedProxy = route!!.proxy
+                if (selectedProxy.type() != Proxy.Type.HTTP) {
+                    throw ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy")
+                }
+                return client.proxyAuthenticator.authenticate(route, userResponse)
+            }
+
+            HTTP_UNAUTHORIZED -> return client.authenticator.authenticate(route, userResponse)
+
+            HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT -> {
+                // "If the 307 or 308 status code is received in response to a request other than GET
+                // or HEAD, the user agent MUST NOT automatically redirect the request"
+                if (method != "GET" && method != "HEAD") {
+                    return null
+                }
+                return buildRedirectRequest(userResponse, method)
+            }
+
+            HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -> {
+                return buildRedirectRequest(userResponse, method)
+            }
+
+            HTTP_CLIENT_TIMEOUT -> {
+                // 408's are rare in practice, but some servers like HAProxy use this response code. The
+                // spec says that we may repeat the request without modifications. Modern browsers also
+                // repeat the request (even non-idempotent ones.)
+                if (!client.retryOnConnectionFailure) {
+                    // The application layer has directed us not to retry the request.
+                    return null
+                }
+
+                val requestBody = userResponse.request.body
+                if (requestBody != null && requestBody.isOneShot()) {
+                    return null
+                }
+                val priorResponse = userResponse.priorResponse
+                if (priorResponse != null && priorResponse.code == HTTP_CLIENT_TIMEOUT) {
+                    // We attempted to retry and got another timeout. Give up.
+                    return null
+                }
+
+                if (retryAfter(userResponse, 0) > 0) {
+                    return null
+                }
+
+                return userResponse.request
+            }
+
+            HTTP_UNAVAILABLE -> {
+                val priorResponse = userResponse.priorResponse
+                if (priorResponse != null && priorResponse.code == HTTP_UNAVAILABLE) {
+                    // We attempted to retry and got another timeout. Give up.
+                    return null
+                }
+
+                if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) {
+                    // specifically received an instruction to retry without delay
+                    return userResponse.request
+                }
+
+                return null
+            }
+            else -> return null
         }
+    }
 
-        return userResponse.request
-      }
-
-      HTTP_UNAVAILABLE -> {
-        val priorResponse = userResponse.priorResponse
-        if (priorResponse != null && priorResponse.code == HTTP_UNAVAILABLE) {
-          // We attempted to retry and got another timeout. Give up.
-          return null
+    private fun buildRedirectRequest(userResponse: Response, method: String): Request? {
+        // Does the client allow redirects?
+        if (!client.followRedirects) return null
+
+        val location = userResponse.header("Location") ?: return null
+        // Don't follow redirects to unsupported protocols.
+        val url = userResponse.request.url.resolve(location) ?: return null
+
+        // If configured, don't follow redirects between SSL and non-SSL.
+        val sameScheme = url.scheme == userResponse.request.url.scheme
+        if (!sameScheme && !client.followSslRedirects) return null
+
+        // Most redirects don't include a request body.
+        val requestBuilder = userResponse.request.newBuilder()
+        if (HttpMethod.permitsRequestBody(method)) {
+            val maintainBody = HttpMethod.redirectsWithBody(method)
+            if (HttpMethod.redirectsToGet(method)) {
+                requestBuilder.method("GET", null)
+            } else {
+                val requestBody = if (maintainBody) userResponse.request.body else null
+                requestBuilder.method(method, requestBody)
+            }
+            if (!maintainBody) {
+                requestBuilder.removeHeader("Transfer-Encoding")
+                requestBuilder.removeHeader("Content-Length")
+                requestBuilder.removeHeader("Content-Type")
+            }
         }
 
-        if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) {
-          // specifically received an instruction to retry without delay
-          return userResponse.request
+        // When redirecting across hosts, drop all authentication headers. This
+        // is potentially annoying to the application layer since they have no
+        // way to retain them.
+        if (!userResponse.request.url.canReuseConnectionFor(url)) {
+            requestBuilder.removeHeader("Authorization")
         }
 
-        return null
-      }
-      else -> return null
-    }
-  }
-
-  private fun buildRedirectRequest(userResponse: Response, method: String): Request? {
-    // Does the client allow redirects?
-    if (!client.followRedirects) return null
-
-    val location = userResponse.header("Location") ?: return null
-    // Don't follow redirects to unsupported protocols.
-    val url = userResponse.request.url.resolve(location) ?: return null
-
-    // If configured, don't follow redirects between SSL and non-SSL.
-    val sameScheme = url.scheme == userResponse.request.url.scheme
-    if (!sameScheme && !client.followSslRedirects) return null
-
-    // Most redirects don't include a request body.
-    val requestBuilder = userResponse.request.newBuilder()
-    if (HttpMethod.permitsRequestBody(method)) {
-      val maintainBody = HttpMethod.redirectsWithBody(method)
-      if (HttpMethod.redirectsToGet(method)) {
-        requestBuilder.method("GET", null)
-      } else {
-        val requestBody = if (maintainBody) userResponse.request.body else null
-        requestBuilder.method(method, requestBody)
-      }
-      if (!maintainBody) {
-        requestBuilder.removeHeader("Transfer-Encoding")
-        requestBuilder.removeHeader("Content-Length")
-        requestBuilder.removeHeader("Content-Type")
-      }
+        return requestBuilder.url(url).build()
     }
 
-    // When redirecting across hosts, drop all authentication headers. This
-    // is potentially annoying to the application layer since they have no
-    // way to retain them.
-    if (!userResponse.request.url.canReuseConnectionFor(url)) {
-      requestBuilder.removeHeader("Authorization")
-    }
+    private fun retryAfter(userResponse: Response, defaultDelay: Int): Int {
+        val header = userResponse.header("Retry-After") ?: return defaultDelay
 
-    return requestBuilder.url(url).build()
-  }
-
-  private fun retryAfter(userResponse: Response, defaultDelay: Int): Int {
-    val header = userResponse.header("Retry-After") ?: return defaultDelay
-
-    // https://tools.ietf.org/html/rfc7231#section-7.1.3
-    // currently ignores a HTTP-date, and assumes any non int 0 is a delay
-    if (header.matches("\\d+".toRegex())) {
-      return Integer.valueOf(header)
+        // https://tools.ietf.org/html/rfc7231#section-7.1.3
+        // currently ignores a HTTP-date, and assumes any non int 0 is a delay
+        if (header.matches("\\d+".toRegex())) {
+            return Integer.valueOf(header)
+        }
+        return Integer.MAX_VALUE
     }
-    return Integer.MAX_VALUE
-  }
 
-  companion object {
-    /**
-     * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
-     * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
-     */
-    private const val MAX_FOLLOW_UPS = 20
-  }
+    companion object {
+        /**
+         * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
+         * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
+         */
+        private const val MAX_FOLLOW_UPS = 20
+    }
 }
diff --git a/samples/guide/src/main/java/okhttp3/guide/GetExample.java b/samples/guide/src/main/java/okhttp3/guide/GetExample.java
index 35a1cc658c..878d730cf0 100644
--- a/samples/guide/src/main/java/okhttp3/guide/GetExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/GetExample.java
@@ -1,26 +1,49 @@
 package okhttp3.guide;
 
+import org.jetbrains.annotations.NotNull;
+
 import java.io.IOException;
+
+import okhttp3.Call;
+import okhttp3.Callback;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
 
 public class GetExample {
-  OkHttpClient client = new OkHttpClient();
+    OkHttpClient client = new OkHttpClient();
 
-  String run(String url) throws IOException {
-    Request request = new Request.Builder()
-        .url(url)
-        .build();
+    String run(String url) throws IOException {
+        Request request = new Request.Builder()
+                .url(url)
+                .build();
+
+        try (Response response = client.newCall(request).execute()) {
+            return response.body().string();
+        }
+    }
 
-    try (Response response = client.newCall(request).execute()) {
-      return response.body().string();
+    void enque(String url, Callback responseCallback) {
+        Request request = new Request.Builder().url(url).build();
+        client.newCall(request).enqueue(responseCallback);
     }
-  }
 
-  public static void main(String[] args) throws IOException {
-    GetExample example = new GetExample();
-    String response = example.run("https://raw.github.com/square/okhttp/master/README.md");
-    System.out.println(response);
-  }
+
+    public static void main(String[] args) throws IOException {
+        GetExample example = new GetExample();
+        String response = example.run("https://raw.github.com/square/okhttp/master/README.md");
+        System.out.println(response);
+
+        example.enque("https://raw.github.com/square/okhttp/master/README.md", new Callback() {
+            @Override
+            public void onFailure(@NotNull Call call, @NotNull IOException e) {
+                System.out.println(e);
+            }
+
+            @Override
+            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
+                System.out.println(response);
+            }
+        });
+    }
 }
diff --git a/samples/guide/src/main/java/okhttp3/guide/PostExample.java b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
index d505beba3a..b4fce444f4 100644
--- a/samples/guide/src/main/java/okhttp3/guide/PostExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
@@ -1,44 +1,68 @@
 package okhttp3.guide;
 
+import org.jetbrains.annotations.NotNull;
+
 import java.io.IOException;
+
+import okhttp3.Call;
+import okhttp3.Callback;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
+import okhttp3.Request.Builder;
 import okhttp3.RequestBody;
 import okhttp3.Response;
 
 public class PostExample {
-  public static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
-
-  OkHttpClient client = new OkHttpClient();
-
-  String post(String url, String json) throws IOException {
-    RequestBody body = RequestBody.create(json, JSON);
-    Request request = new Request.Builder()
-        .url(url)
-        .post(body)
-        .build();
-    try (Response response = client.newCall(request).execute()) {
-      return response.body().string();
+    public static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
+
+    OkHttpClient client = new OkHttpClient();
+
+    String post(String url, String json) throws IOException {
+        RequestBody body = RequestBody.create(json, JSON);
+        Request request = new Request.Builder()
+                .url(url)
+                .post(body)
+                .build();
+        try (Response response = client.newCall(request).execute()) {
+            return response.body().string();
+        }
+    }
+
+    void postEnque(String url, String json, Callback responseCallback){
+        RequestBody body = RequestBody.create(json, JSON);
+        Request request = new Builder().url(url).post(body).build();
+        client.newCall(request).enqueue(responseCallback);
+    }
+
+    String bowlingJson(String player1, String player2) {
+        return "{'winCondition':'HIGH_SCORE',"
+                + "'name':'Bowling',"
+                + "'round':4,"
+                + "'lastSaved':1367702411696,"
+                + "'dateStarted':1367702378785,"
+                + "'players':["
+                + "{'name':'" + player1 + "','history':[10,8,6,7,8],'color':-13388315,'total':39},"
+                + "{'name':'" + player2 + "','history':[6,10,5,10,10],'color':-48060,'total':41}"
+                + "]}";
+    }
+
+    public static void main(String[] args) throws IOException {
+        PostExample example = new PostExample();
+        String json = example.bowlingJson("Jesse", "Jake");
+        String response = example.post("http://www.roundsapp.com/post", json);
+        System.out.println(response);
+
+        example.postEnque("http://www.roundsapp.com/post", json, new Callback() {
+            @Override
+            public void onFailure(@NotNull Call call, @NotNull IOException e) {
+                System.out.println(e);
+            }
+
+            @Override
+            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
+                System.out.println(response);
+            }
+        });
     }
-  }
-
-  String bowlingJson(String player1, String player2) {
-    return "{'winCondition':'HIGH_SCORE',"
-        + "'name':'Bowling',"
-        + "'round':4,"
-        + "'lastSaved':1367702411696,"
-        + "'dateStarted':1367702378785,"
-        + "'players':["
-        + "{'name':'" + player1 + "','history':[10,8,6,7,8],'color':-13388315,'total':39},"
-        + "{'name':'" + player2 + "','history':[6,10,5,10,10],'color':-48060,'total':41}"
-        + "]}";
-  }
-
-  public static void main(String[] args) throws IOException {
-    PostExample example = new PostExample();
-    String json = example.bowlingJson("Jesse", "Jake");
-    String response = example.post("http://www.roundsapp.com/post", json);
-    System.out.println(response);
-  }
 }
