diff --git a/okhttp/src/main/java/okhttp3/Note.java b/okhttp/src/main/java/okhttp3/Note.java
index ce3b2d0761..4e015ad470 100644
--- a/okhttp/src/main/java/okhttp3/Note.java
+++ b/okhttp/src/main/java/okhttp3/Note.java
@@ -33,6 +33,11 @@
      * {@link CacheControl#FORCE_NETWORK}、{@link CacheControl#FORCE_CACHE}
      */
 
+    /**
+     * {@link okhttp3.internal.cache.InternalCache}
+     * Applications shouldn't implement this: instead use {@link okhttp3.Cache}.
+     */
+
     /**
      * X.509是密码学里公钥证书的格式标准
      */
@@ -44,6 +49,10 @@
      * @see OkHttpClient.Builder#protocols(List)
      */
 
+    /**
+     * Authenticator的实现示例：{@link JavaNetAuthenticator}
+     */
+
 
     /**
      * okhttp异步任务默认创建的线程池，size为{@link Integer#MAX_VALUE}。
@@ -55,4 +64,13 @@
      * 同步请求：{@link RealCall#execute()}
      * 异步请求：{@link RealCall#enqueue(Callback)}
      */
+
+    /**
+     * okhttp对重定向的处理：{@link okhttp3.internal.http.RetryAndFollowUpInterceptor#followUpRequest(Response, Route)}
+     * 1.如果{@link OkHttpClient.Builder#followRedirects(boolean)}传入fasle，不会进行重定向。
+     * 2.默认不支持跨协议的重定向，比如不在http和https之间进行重定向
+     * 3.非"PROPFIND"请求的重定向，比如POST，都会变成"GET"，丢失请求体
+     *
+     * <a href="https://www.jianshu.com/p/61a60859a317">案例：okhttp post 重定向参数丢失 跨协议重定向</a>
+     */
 }
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 9bd403a729..823ef0d244 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -184,15 +184,15 @@ String redactedUrl() {
   Response getResponseWithInterceptorChain() throws IOException {
     // Build a full stack of interceptors.
     List<Interceptor> interceptors = new ArrayList<>();
-    interceptors.addAll(client.interceptors());
-    interceptors.add(retryAndFollowUpInterceptor);
-    interceptors.add(new BridgeInterceptor(client.cookieJar()));
-    interceptors.add(new CacheInterceptor(client.internalCache()));
-    interceptors.add(new ConnectInterceptor(client));
+    interceptors.addAll(client.interceptors());//加入用户自定义的拦截器
+    interceptors.add(retryAndFollowUpInterceptor);//重试和重定向拦截器
+    interceptors.add(new BridgeInterceptor(client.cookieJar()));//加入转化请求响应的拦截器
+    interceptors.add(new CacheInterceptor(client.internalCache()));//加入缓存拦截器
+    interceptors.add(new ConnectInterceptor(client));//加入连接拦截器
     if (!forWebSocket) {
-      interceptors.addAll(client.networkInterceptors());
+      interceptors.addAll(client.networkInterceptors());//加入用户自定义的网络拦截器
     }
-    interceptors.add(new CallServerInterceptor(forWebSocket));
+    interceptors.add(new CallServerInterceptor(forWebSocket));//加入发出请求和读取响应的拦截器
 
     Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
         originalRequest, this, eventListener, client.connectTimeoutMillis(),
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
index c10dc34cdc..d8095c0f19 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
@@ -76,11 +76,13 @@ public BridgeInterceptor(CookieJar cookieJar) {
     // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
     // the transfer stream.
     boolean transparentGzip = false;
+    // 使用 gzip 压缩
     if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
       transparentGzip = true;
       requestBuilder.header("Accept-Encoding", "gzip");
     }
 
+    // 加入以前保存的cookie
     List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());
     if (!cookies.isEmpty()) {
       requestBuilder.header("Cookie", cookieHeader(cookies));
@@ -92,11 +94,13 @@ public BridgeInterceptor(CookieJar cookieJar) {
 
     Response networkResponse = chain.proceed(requestBuilder.build());
 
+    // 保存networkResponse的cookie
     HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());
 
     Response.Builder responseBuilder = networkResponse.newBuilder()
         .request(userRequest);
 
+    // 如果networkResponse使用gzip并且有响应体的话，给用户友好的response设置响应体
     if (transparentGzip
         && "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
         && HttpHeaders.hasBody(networkResponse)) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index ffb75058aa..4c5e509bb6 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -114,6 +114,7 @@ public StreamAllocation streamAllocation() {
 
     int followUpCount = 0;
     Response priorResponse = null;
+    //如果需要重定向，会多次执行。
     while (true) {
       if (canceled) {
         streamAllocation.release();
@@ -155,6 +156,7 @@ public StreamAllocation streamAllocation() {
             .build();
       }
 
+      // 如果不需要重定向，那么 followUp 为空，会根据响应码判断
       Request followUp;
       try {
         followUp = followUpRequest(response, streamAllocation.route());
@@ -182,6 +184,8 @@ public StreamAllocation streamAllocation() {
         throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
       }
 
+      //response 和 followUp 比较是否为同一个连接
+      //若为重定向就销毁旧连接，创建新连接
       if (!sameConnection(response, followUp.url())) {
         streamAllocation.release();
         streamAllocation = new StreamAllocation(client.connectionPool(),
