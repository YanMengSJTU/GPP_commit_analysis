diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 3c027a2caf..e3a842af0c 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -52,18 +52,27 @@
     return originalRequest;
   }
 
+  /**
+   * 同步网络请求
+   * @return
+   * @throws IOException
+     */
   @Override public Response execute() throws IOException {
     synchronized (this) {
+      // 检查这个 call 是否已经被执行了，每个 call 只能被执行一次，如果想要一个完全一样的 call，可以利用 call#clone 方法进行克隆。
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
     captureCallStackTrace();
     try {
+      // 利用 client.dispatcher().executed(this) 来进行实际执行，dispatcher 是 OkHttpClient.Builder 的成员之一。
       client.dispatcher().executed(this);
+      // 调用 getResponseWithInterceptorChain() 函数获取 HTTP 返回结果，从函数名可以看出，这一步还会进行一系列“拦截”操作。
       Response result = getResponseWithInterceptorChain();
       if (result == null) throw new IOException("Canceled");
       return result;
     } finally {
+      // 通知 dispatcher 自己已经执行完毕。
       client.dispatcher().finished(this);
     }
   }
@@ -161,17 +170,24 @@ String redactedUrl() {
     return originalRequest.url().redact().toString();
   }
 
+  // OKHttp的变化历程：https://publicobject.com/2016/07/03/the-last-httpurlconnection/
   Response getResponseWithInterceptorChain() throws IOException {
     // Build a full stack of interceptors.
     List<Interceptor> interceptors = new ArrayList<>();
     interceptors.addAll(client.interceptors());
+    // 负责失败重试以及重定向的 RetryAndFollowUpInterceptor；
     interceptors.add(retryAndFollowUpInterceptor);
+    // 负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的 BridgeInterceptor；
     interceptors.add(new BridgeInterceptor(client.cookieJar()));
+    // 负责读取缓存直接返回、更新缓存的 CacheInterceptor；
     interceptors.add(new CacheInterceptor(client.internalCache()));
+    // 负责和服务器建立连接的 ConnectInterceptor；
     interceptors.add(new ConnectInterceptor(client));
+    // 配置 OkHttpClient 时设置的 networkInterceptors；
     if (!forWebSocket) {
       interceptors.addAll(client.networkInterceptors());
     }
+    // 负责向服务器发送请求数据、从服务器读取响应数据的 CallServerInterceptor。
     interceptors.add(new CallServerInterceptor(forWebSocket));
 
     Interceptor.Chain chain = new RealInterceptorChain(
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index 18d4fd9813..f93bfa9fce 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -50,12 +50,14 @@ public CacheInterceptor(InternalCache cache) {
   }
 
   @Override public Response intercept(Chain chain) throws IOException {
+    // 根据 request 来判断 cache 中是否有缓存的 response ，如果有，得到这个 response
     Response cacheCandidate = cache != null
         ? cache.get(chain.request())
         : null;
 
     long now = System.currentTimeMillis();
 
+    // request判断缓存的策略，是否要使用了网络，缓存 或两者都使用
     CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
     Request networkRequest = strategy.networkRequest;
     Response cacheResponse = strategy.cacheResponse;
@@ -64,11 +66,13 @@ public CacheInterceptor(InternalCache cache) {
       cache.trackResponse(strategy);
     }
 
+    // 存在缓存的response，但是不允许缓存
     if (cacheCandidate != null && cacheResponse == null) {
       closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
     }
 
     // If we're forbidden from using the network and the cache is insufficient, fail.
+    // 如果我们禁止使用网络，且缓存为null，失败
     if (networkRequest == null && cacheResponse == null) {
       return new Response.Builder()
           .request(chain.request())
@@ -82,6 +86,7 @@ public CacheInterceptor(InternalCache cache) {
     }
 
     // If we don't need the network, we're done.
+    // 没有网络请求，跳过网络，返回缓存
     if (networkRequest == null) {
       return cacheResponse.newBuilder()
           .cacheResponse(stripBody(cacheResponse))
@@ -90,6 +95,7 @@ public CacheInterceptor(InternalCache cache) {
 
     Response networkResponse = null;
     try {
+      // 调用下一个拦截器，决定从网络上来得到 response
       networkResponse = chain.proceed(networkRequest);
     } finally {
       // If we're crashing on I/O or otherwise, don't leak the cache body.
@@ -99,7 +105,9 @@ public CacheInterceptor(InternalCache cache) {
     }
 
     // If we have a cache response too, then we're doing a conditional get.
+    // 如果我们有一个缓存的response，然后我们正在做一个条件GET
     if (cacheResponse != null) {
+      // 304
       if (networkResponse.code() == HTTP_NOT_MODIFIED) {
         Response response = cacheResponse.newBuilder()
             .headers(combine(cacheResponse.headers(), networkResponse.headers()))
@@ -125,6 +133,7 @@ public CacheInterceptor(InternalCache cache) {
         .networkResponse(stripBody(networkResponse))
         .build();
 
+    // 请求有body内容，则判断是否需要缓存
     if (HttpHeaders.hasBody(response)) {
       CacheRequest cacheRequest = maybeCache(response, networkResponse.request(), cache);
       response = cacheWritingResponse(cacheRequest, response);
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
index cabd065813..ba59556c9d 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
@@ -39,6 +39,7 @@ public ConnectInterceptor(OkHttpClient client) {
 
     // We need the network to satisfy this request. Possibly for validating a conditional GET.
     boolean doExtensiveHealthChecks = !request.method().equals("GET");
+    // 找到一个可用的 RealConnection，再利用 RealConnection 的输入输出（BufferedSource 和 BufferedSink）创建 HttpCodec 对象
     HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);
     RealConnection connection = streamAllocation.connection();
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
index f8a720ff8a..fda4c672fe 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
@@ -48,6 +48,7 @@ public BridgeInterceptor(CookieJar cookieJar) {
     Request userRequest = chain.request();
     Request.Builder requestBuilder = userRequest.newBuilder();
 
+    // 检查request。将用户的request转换为发送到server的请求
     RequestBody body = userRequest.body();
     if (body != null) {
       MediaType contentType = body.contentType();
@@ -90,6 +91,7 @@ public BridgeInterceptor(CookieJar cookieJar) {
       requestBuilder.header("User-Agent", Version.userAgent());
     }
 
+    // 调用下一个 interceptor 来得到response
     Response networkResponse = chain.proceed(requestBuilder.build());
 
     HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index 6adbc28b56..e7d4b6c54e 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -40,8 +40,10 @@ public CallServerInterceptor(boolean forWebSocket) {
     Request request = chain.request();
 
     long sentRequestMillis = System.currentTimeMillis();
+    // 1.向服务器发送 request header；
     httpCodec.writeRequestHeaders(request);
 
+    // 2.如果有 request body，就向服务器发送；
     if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
       Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());
       BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
@@ -51,6 +53,7 @@ public CallServerInterceptor(boolean forWebSocket) {
 
     httpCodec.finishRequest();
 
+    // 3.读取 response header，先构造一个 Response 对象；
     Response response = httpCodec.readResponseHeaders()
         .request(request)
         .handshake(streamAllocation.connection().handshake())
@@ -65,6 +68,7 @@ public CallServerInterceptor(boolean forWebSocket) {
           .body(Util.EMPTY_RESPONSE)
           .build();
     } else {
+      // 4.如果有 response body，就在 步骤3 的基础上加上 body 构造一个新的 Response 对象；
       response = response.newBuilder()
           .body(httpCodec.openResponseBody(response))
           .build();
