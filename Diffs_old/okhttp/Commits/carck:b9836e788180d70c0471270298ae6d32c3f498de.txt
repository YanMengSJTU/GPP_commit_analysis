diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index 5c0888cb3c..20b03171e6 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -41,15 +41,46 @@
      * this stream.
      * @param priority or -1 for no priority. For SPDY, priorities range from 0
      * (highest) thru 7 (lowest). For HTTP/2.0, priorities range from 0
+     * (highest) thru 2^31-1 (lowest), defaulting to 2^30.
      */
     void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-        int priority, List<Header> nameValueBlock, HeadersMode headersMode);
+        int priority, List<Header> headerBlock, HeadersMode headersMode);
     void rstStream(int streamId, ErrorCode errorCode);
     void settings(boolean clearPrevious, Settings settings);
     void noop();
-    void ping(boolean reply, int payload1, int payload2);
+
+    /**
+     *  Read a connection-level ping from the peer.  {@code ack} indicates this
+     *  is a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
+     *  <p/>
+     *  In SPDY/3, only the first {@code payload1} parameter is set.  If the
+     *  reader is a client, it is an unsigned even number.  Likewise, a server
+     *  will receive an odd number.
+     *  <p/>
+     *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
+     *  set. The data is opaque binary, and there are no rules on the content.
+     */
+    void ping(boolean ack, int payload1, int payload2);
     void goAway(int lastGoodStreamId, ErrorCode errorCode);
     void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl);
     void priority(int streamId, int priority);
+
+    /**
+     * HTTP/2 only. Receive a push promise header block.
+     * <p/>
+     * A push promise contains all the headers that pertain to a server-initiated
+     * request, and a {@code promisedStreamId} to which response frames will be
+     * delivered. Push promise frames are sent as a part of the response to
+     * {@code streamId}.  The {@code promisedStreamId} has a priority of one
+     * greater than {@code streamId}.
+     *
+     * @param streamId client-initiated stream ID.  Must be an odd number.
+     * @param promisedStreamId server-initiated stream ID.  Must be an even
+     * number.
+     * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
+     * {@code :authority}, and (@code :path}.
+     */
+    void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+        throws IOException;
   }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index 63d2007e04..ab90db69dc 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -26,21 +26,61 @@
   void connectionHeader() throws IOException;
   void ackSettings() throws IOException;
 
+  /**
+   * HTTP/2 only. Send a push promise header block.
+   * <p/>
+   * A push promise contains all the headers that pertain to a server-initiated
+   * request, and a {@code promisedStreamId} to which response frames will be
+   * delivered. Push promise frames are sent as a part of the response to
+   * {@code streamId}.  The {@code promisedStreamId} has a priority of one
+   * greater than {@code streamId}.
+   *
+   * @param streamId client-initiated stream ID.  Must be an odd number.
+   * @param promisedStreamId server-initiated stream ID.  Must be an even
+   * number.
+   * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
+   * {@code :authority}, and (@code :path}.
+   */
+  void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+      throws IOException;
+
   /** SPDY/3 only. */
   void flush() throws IOException;
   void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      int priority, int slot, List<Header> nameValueBlock) throws IOException;
-  void synReply(boolean outFinished, int streamId, List<Header> nameValueBlock)
+      int priority, int slot, List<Header> headerBlock) throws IOException;
+  void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
       throws IOException;
-  void headers(int streamId, List<Header> nameValueBlock) throws IOException;
+  void headers(int streamId, List<Header> headerBlock) throws IOException;
   void rstStream(int streamId, ErrorCode errorCode) throws IOException;
+
+  /**
+   * {@code data.length} may be longer than the max length of the variant's data frame.
+   * Implementations must send multiple frames as necessary.
+   */
   void data(boolean outFinished, int streamId, byte[] data) throws IOException;
+
+  /**
+   * {@code byteCount} may be longer than the max length of the variant's data frame.
+   * Implementations must send multiple frames as necessary.
+   */
   void data(boolean outFinished, int streamId, byte[] data, int offset, int byteCount)
       throws IOException;
   /** Write okhttp's settings to the peer. */
   void settings(Settings okHttpSettings) throws IOException;
   void noop() throws IOException;
-  void ping(boolean reply, int payload1, int payload2) throws IOException;
+
+  /**
+   *  Send a connection-level ping to the peer.  {@code ack} indicates this is
+   *  a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
+   *  <p/>
+   *  In SPDY/3, only the first {@code payload1} parameter is sent.  If the
+   *  sender is a client, it is an unsigned odd number.  Likewise, a server
+   *  will send an even number.
+   *  <p/>
+   *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
+   *  sent.  The data is opaque binary, and there are no rules on the content.
+   */
+  void ping(boolean ack, int payload1, int payload2) throws IOException;
   void goAway(int lastGoodStreamId, ErrorCode errorCode) throws IOException;
   void windowUpdate(int streamId, int deltaWindowSize) throws IOException;
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 75c77240a0..8a3941e33d 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -3,8 +3,8 @@
 import com.squareup.okhttp.internal.BitArray;
 import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
-import java.io.DataInputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -93,13 +93,12 @@ private HpackDraft05() {
   }
 
   // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.2
-  static class Reader {
+  static final class Reader {
     private final Huffman.Codec huffmanCodec;
 
-    private final DataInputStream in;
+    private final InputStream in;
     private final List<Header> emittedHeaders = new ArrayList<Header>();
     private int maxHeaderTableByteCount;
-    private long bytesLeft = 0;
 
     // Visible for testing.
     Header[] headerTable = new Header[8];
@@ -121,7 +120,7 @@ private HpackDraft05() {
     long referencedStaticHeaders = 0L;
     int headerTableByteCount = 0;
 
-    Reader(boolean client, int maxHeaderTableByteCount, DataInputStream in) {
+    Reader(boolean client, int maxHeaderTableByteCount, InputStream in) {
       this.huffmanCodec = client ? Huffman.Codec.RESPONSE : Huffman.Codec.REQUEST;
       this.maxHeaderTableByteCount = maxHeaderTableByteCount;
       this.in = in;
@@ -133,7 +132,7 @@ int maxHeaderTableByteCount() {
 
     /**
      * Called by the reader when the peer sent a new header table size setting.
-     *
+     * <p/>
      * Evicts entries or clears the table as needed.
      */
     void maxHeaderTableByteCount(int newMaxHeaderTableByteCount) {
@@ -178,13 +177,10 @@ private int evictToRecoverBytes(int bytesToRecover) {
      * Read {@code byteCount} bytes of headers from the source stream into the
      * set of emitted headers.
      */
-    public void readHeaders(int byteCount) throws IOException {
-      bytesLeft += byteCount;
-      // TODO: limit to 'byteCount' bytes?
-
-      while (bytesLeft > 0) {
-        int b = readByte();
-
+    void readHeaders() throws IOException {
+      int b;
+      while ((b = in.read()) != -1) {
+        b &= 0xff;
         if (b == 0x80) { // 10000000
           clearReferenceSet();
         } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
@@ -214,7 +210,7 @@ private void clearReferenceSet() {
       referencedHeaders.clear();
     }
 
-    public void emitReferenceSet() {
+    void emitReferenceSet() {
       for (int i = 0; i < STATIC_HEADER_TABLE.length; ++i) {
         if (((referencedStaticHeaders >> i) & 1L) == 1) {
           emittedHeaders.add(STATIC_HEADER_TABLE[i]);
@@ -231,7 +227,7 @@ public void emitReferenceSet() {
      * Returns all headers emitted since they were last cleared, then clears the
      * emitted headers.
      */
-    public List<Header> getAndReset() {
+    List<Header> getAndReset() {
       List<Header> result = new ArrayList<Header>(emittedHeaders);
       emittedHeaders.clear();
       return result;
@@ -335,8 +331,7 @@ private void insertIntoHeaderTable(int index, Header entry) {
     }
 
     private int readByte() throws IOException {
-      bytesLeft--;
-      return in.readByte() & 0xff;
+      return in.read() & 0xff;
     }
 
     int readInt(int firstByte, int prefixMask) throws IOException {
@@ -365,42 +360,40 @@ int readInt(int firstByte, int prefixMask) throws IOException {
      * Reads a potentially Huffman encoded string byte string. When
      * {@code asciiLowercase} is true, bytes will be converted to lowercase.
      */
-    public ByteString readByteString(boolean asciiLowercase) throws IOException {
+    ByteString readByteString(boolean asciiLowercase) throws IOException {
       int firstByte = readByte();
       int length = readInt(firstByte, PREFIX_8_BITS);
       if ((length & 0x80) == 0x80) { // 1NNNNNNN
         length &= ~0x80;
         byte[] buff = new byte[length];
         Util.readFully(in, buff);
-        bytesLeft -= length;
         buff = huffmanCodec.decode(buff); // TODO: streaming Huffman!
         if (asciiLowercase) asciiLowerCase(buff);
         return ByteString.of(buff);
       }
-      bytesLeft -= length;
       return length == 0 ? ByteString.EMPTY
           : asciiLowercase ? ByteString.readLowerCase(in, length) : ByteString.read(in, length);
     }
   }
 
-  static class Writer {
+  static final class Writer {
     private final OutputStream out;
 
     Writer(OutputStream out) {
       this.out = out;
     }
 
-    public void writeHeaders(List<Header> nameValueBlock) throws IOException {
+    void writeHeaders(List<Header> headerBlock) throws IOException {
       // TODO: implement a compression strategy.
-      for (int i = 0, size = nameValueBlock.size(); i < size; i++) {
+      for (int i = 0, size = headerBlock.size(); i < size; i++) {
         out.write(0x40); // Literal Header without Indexing - New Name.
-        writeByteString(nameValueBlock.get(i).name);
-        writeByteString(nameValueBlock.get(i).value);
+        writeByteString(headerBlock.get(i).name);
+        writeByteString(headerBlock.get(i).value);
       }
     }
 
     // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.1
-    public void writeInt(int value, int prefixMask, int bits) throws IOException {
+    void writeInt(int value, int prefixMask, int bits) throws IOException {
       // Write the raw value for a single byte value.
       if (value < prefixMask) {
         out.write(bits | value);
@@ -420,7 +413,7 @@ public void writeInt(int value, int prefixMask, int bits) throws IOException {
       out.write(value);
     }
 
-    public void writeByteString(ByteString data) throws IOException {
+    void writeByteString(ByteString data) throws IOException {
       writeInt(data.size(), PREFIX_8_BITS, 0);
       data.write(out);
     }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 7875656040..4589788c11 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -20,10 +20,10 @@
 import java.io.ByteArrayOutputStream;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
+import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
 import java.util.Arrays;
 import java.util.List;
 
@@ -39,33 +39,21 @@
 
   // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-6.5
   @Override public Settings defaultOkHttpSettings(boolean client) {
-    Settings settings = new Settings();
-    settings.set(Settings.HEADER_TABLE_SIZE, 0, 4096);
-    if (!client) { // client doesn't send push requests.
-      settings.set(Settings.ENABLE_PUSH, 0, 0); // TODO: support writing push.
-    }
-    settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
-    return settings;
+    return initialPeerSettings(client);
   }
 
   @Override public Settings initialPeerSettings(boolean client) {
     Settings settings = new Settings();
     settings.set(Settings.HEADER_TABLE_SIZE, 0, 4096);
-    if (client) { // server doesn't read push requests.
-      settings.set(Settings.ENABLE_PUSH, 0, 0); // TODO: support reading push.
+    if (client) { // client specifies whether or not it accepts push.
+      settings.set(Settings.ENABLE_PUSH, 0, 1);
     }
     settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
     return settings;
   }
 
-  private static final byte[] CONNECTION_HEADER;
-  static {
-    try {
-      CONNECTION_HEADER = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n".getBytes("UTF-8");
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
-  }
+  private static final byte[] CONNECTION_HEADER =
+      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n".getBytes(Util.UTF_8);
 
   static final int TYPE_DATA = 0x0;
   static final int TYPE_HEADERS = 0x1;
@@ -80,8 +68,9 @@
 
   static final int FLAG_END_STREAM = 0x1;
 
-  /** Used for headers, push-promise and continuation. */
+  /** Used for headers and continuation. */
   static final int FLAG_END_HEADERS = 0x4;
+  static final int FLAG_END_PUSH_PROMISE = 0x4;
   static final int FLAG_PRIORITY = 0x8;
   static final int FLAG_ACK = 0x1;
   static final int FLAG_END_FLOW_CONTROL = 0x1;
@@ -96,6 +85,7 @@
 
   static final class Reader implements FrameReader {
     private final DataInputStream in;
+    private final ContinuationInputStream continuation;
     private final boolean client;
 
     // Visible for testing.
@@ -103,8 +93,9 @@
 
     Reader(InputStream in, int headerTableSize, boolean client) {
       this.in = new DataInputStream(in);
+      this.continuation = new ContinuationInputStream(this.in);
       this.client = client;
-      this.hpackReader = new HpackDraft05.Reader(client, headerTableSize, this.in);
+      this.hpackReader = new HpackDraft05.Reader(client, headerTableSize, continuation);
     }
 
     @Override public void readConnectionHeader() throws IOException {
@@ -176,41 +167,29 @@
 
     private void readHeaders(Handler handler, int flags, int length, int streamId)
         throws IOException {
-      if (streamId == 0) throw ioException("TYPE_HEADERS streamId == 0");
+      if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
 
-      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
-
-      while (true) {
-        hpackReader.readHeaders(length);
-
-        if ((flags & FLAG_END_HEADERS) != 0) {
-          hpackReader.emitReferenceSet();
-          List<Header> nameValueBlock = hpackReader.getAndReset();
-          // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
-          // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
-          int priority = -1; // TODO: priority
-          handler.headers(false, inFinished, streamId, -1, priority, nameValueBlock,
-              HeadersMode.HTTP_20_HEADERS);
-          return;
-        }
+      boolean endHeaders = (flags & FLAG_END_HEADERS) != 0;
+      boolean endStream = (flags & FLAG_END_STREAM) != 0;
+      int priority = ((flags & FLAG_PRIORITY) != 0) ? in.readInt() & 0x7fffffff : -1;
 
-        // Read another continuation frame.
-        int w1 = in.readInt();
-        int w2 = in.readInt();
+      List<Header> headerBlock = readHeaderBlock(length, endHeaders, streamId);
 
-        // boolean r = (w1 & 0xc0000000) != 0; // Reserved.
-        length = (w1 & 0x3fff0000) >> 16; // 14-bit unsigned.
-        int newType = (w1 & 0xff00) >> 8;
-        flags = w1 & 0xff;
+      handler.headers(false, endStream, streamId, -1, priority, headerBlock,
+          HeadersMode.HTTP_20_HEADERS);
+    }
 
-        // boolean u = (w2 & 0x80000000) != 0; // Unused.
-        int newStreamId = (w2 & 0x7fffffff);
+    private List<Header> readHeaderBlock(int length, boolean endHeaders, int streamId)
+        throws IOException {
+      continuation.bytesLeft = length;
+      continuation.endHeaders = endHeaders;
+      continuation.streamId = streamId;
 
-        if (newType != TYPE_CONTINUATION) {
-          throw ioException("TYPE_CONTINUATION didn't have FLAG_END_HEADERS");
-        }
-        if (newStreamId != streamId) throw ioException("TYPE_CONTINUATION streamId changed");
-      }
+      hpackReader.readHeaders();
+      hpackReader.emitReferenceSet();
+      // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
+      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
+      return hpackReader.getAndReset();
     }
 
     private void readData(Handler handler, int flags, int length, int streamId) throws IOException {
@@ -263,8 +242,17 @@ private void readSettings(Handler handler, int flags, int length, int streamId)
       }
     }
 
-    private void readPushPromise(Handler handler, int flags, int length, int streamId) {
-      // TODO:
+    private void readPushPromise(Handler handler, int flags, int length, int streamId)
+        throws IOException {
+      if (streamId == 0) {
+        throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
+      }
+      boolean endHeaders = (flags & FLAG_END_PUSH_PROMISE) != 0;
+
+      int promisedStreamId = in.readInt() & 0x7fffffff;
+      List<Header> headerBlock = readHeaderBlock(length, endHeaders, streamId);
+
+      handler.pushPromise(streamId, promisedStreamId, headerBlock);
     }
 
     private void readPing(Handler handler, int flags, int length, int streamId) throws IOException {
@@ -272,8 +260,8 @@ private void readPing(Handler handler, int flags, int length, int streamId) thro
       if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
       int payload1 = in.readInt();
       int payload2 = in.readInt();
-      boolean reply = (flags & FLAG_ACK) != 0;
-      handler.ping(reply, payload1, payload2);
+      boolean ack = (flags & FLAG_ACK) != 0;
+      handler.ping(ack, payload1, payload2);
     }
 
     private void readGoAway(Handler handler, int flags, int length, int streamId)
@@ -336,26 +324,42 @@ private void readWindowUpdate(Handler handler, int flags, int length, int stream
 
     @Override
     public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, int slot, List<Header> nameValueBlock)
+        int associatedStreamId, int priority, int slot, List<Header> headerBlock)
         throws IOException {
       if (inFinished) throw new UnsupportedOperationException();
-      headers(outFinished, streamId, priority, nameValueBlock);
+      headers(outFinished, streamId, priority, headerBlock);
     }
 
     @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<Header> nameValueBlock) throws IOException {
-      headers(outFinished, streamId, -1, nameValueBlock);
+        List<Header> headerBlock) throws IOException {
+      headers(outFinished, streamId, -1, headerBlock);
+    }
+
+    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
+        throws IOException {
+      headers(false, streamId, -1, headerBlock);
     }
 
-    @Override public synchronized void headers(int streamId, List<Header> nameValueBlock)
+    @Override
+    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
         throws IOException {
-      headers(false, streamId, -1, nameValueBlock);
+      hpackBuffer.reset();
+      hpackWriter.writeHeaders(requestHeaders);
+      int type = TYPE_PUSH_PROMISE;
+      // TODO: implement CONTINUATION
+      int length = hpackBuffer.size();
+      checkFrameSize(length);
+      int flags = FLAG_END_HEADERS;
+      out.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
+      out.writeInt(streamId & 0x7fffffff);
+      out.writeInt(promisedStreamId & 0x7fffffff);
+      hpackBuffer.writeTo(out);
     }
 
     private void headers(boolean outFinished, int streamId, int priority,
-        List<Header> nameValueBlock) throws IOException {
+        List<Header> headerBlock) throws IOException {
       hpackBuffer.reset();
-      hpackWriter.writeHeaders(nameValueBlock);
+      hpackWriter.writeHeaders(headerBlock);
       int type = TYPE_HEADERS;
       // TODO: implement CONTINUATION
       int length = hpackBuffer.size();
@@ -387,12 +391,16 @@ private void headers(boolean outFinished, int streamId, int priority,
 
     @Override public synchronized void data(boolean outFinished, int streamId, byte[] data,
         int offset, int byteCount) throws IOException {
-      int type = TYPE_DATA;
       int flags = 0;
       if (outFinished) flags |= FLAG_END_STREAM;
       // TODO: Implement looping strategy.
+      sendDataFrame(streamId, flags, data, offset, byteCount);
+    }
+
+    void sendDataFrame(int streamId, int flags, byte[] data, int offset, int byteCount)
+        throws IOException {
       checkFrameSize(byteCount);
-      out.writeInt((byteCount & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
+      out.writeInt((byteCount & 0x3fff) << 16 | (TYPE_DATA & 0xff) << 8 | (flags & 0xff));
       out.writeInt(streamId & 0x7fffffff);
       out.write(data, offset, byteCount);
     }
@@ -415,9 +423,12 @@ private void headers(boolean outFinished, int streamId, int priority,
       throw new UnsupportedOperationException();
     }
 
-    @Override public synchronized void ping(boolean reply, int payload1, int payload2)
+    @Override public synchronized void ping(boolean ack, int payload1, int payload2)
         throws IOException {
-      // TODO
+      out.writeInt(8 << 16 | (TYPE_PING & 0xff) << 8 | ((ack ? FLAG_ACK : 0) & 0xff));
+      out.writeInt(0); // connection-level
+      out.writeInt(payload1);
+      out.writeInt(payload2);
     }
 
     @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode)
@@ -442,4 +453,75 @@ private static void checkFrameSize(int bytes) throws IOException {
   private static IOException ioException(String message, Object... args) throws IOException {
     throw new IOException(String.format(message, args));
   }
+
+  /**
+   * Decompression of the header block occurs above the framing layer.  This
+   * class lazily reads continuation frames as they are needed by
+   * {@link HpackDraft05.Reader#readHeaders()}.
+   */
+  static final class ContinuationInputStream extends InputStream {
+    private final DataInputStream in;
+
+    int bytesLeft;
+    boolean endHeaders;
+    int streamId;
+
+    ContinuationInputStream(DataInputStream in) {
+      this.in = in;
+    }
+
+    @Override public int read() throws IOException {
+      if (bytesLeft == 0) {
+        if (endHeaders) {
+          return -1;
+        } else {
+          readContinuationHeader();
+        }
+      }
+      bytesLeft--;
+      int result = in.read();
+      if (result == -1) throw new EOFException();
+      return result;
+    }
+
+    @Override public int read(byte[] dst, int offset, int byteCount) throws IOException {
+      if (byteCount > bytesLeft) {
+        if (endHeaders) {
+          throw new EOFException(
+              String.format("Attempted to read %s bytes, when only %s left", byteCount, bytesLeft));
+        } else {
+          int beforeContinuation = bytesLeft;
+          Util.readFully(in, dst, offset, bytesLeft);
+          readContinuationHeader();
+          int afterContinuation = byteCount - beforeContinuation;
+          offset += beforeContinuation;
+          bytesLeft -= afterContinuation;
+          Util.readFully(in, dst, offset, afterContinuation);
+          return byteCount;
+        }
+      } else {
+        bytesLeft -= byteCount;
+        Util.readFully(in, dst, offset, byteCount);
+        return byteCount;
+      }
+    }
+
+    private void readContinuationHeader() throws IOException {
+      int w1 = in.readInt();
+      int w2 = in.readInt();
+
+      // boolean r = (w1 & 0xc0000000) != 0; // Reserved.
+      bytesLeft = (w1 & 0x3fff0000) >> 16; // 14-bit unsigned.
+      int newType = (w1 & 0xff00) >> 8;
+      endHeaders = (w1 & 0xff & FLAG_END_HEADERS) != 0;
+
+      // boolean u = (w2 & 0x80000000) != 0; // Unused.
+      int newStreamId = (w2 & 0x7fffffff);
+
+      if (newType != TYPE_CONTINUATION) {
+        throw ioException("TYPE_CONTINUATION didn't have FLAG_END_HEADERS");
+      }
+      if (newStreamId != streamId) throw ioException("TYPE_CONTINUATION streamId changed");
+    }
+  }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
index 34ce45522c..9c72eb5eb5 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
@@ -19,7 +19,7 @@
  * bytes.
  */
 class NameValueBlockReader implements Closeable {
-  private final DataInputStream nameValueBlockIn;
+  private final DataInputStream headerBlockIn;
   private final FillableInflaterInputStream fillableInflaterInputStream;
   private int compressedLimit;
 
@@ -58,7 +58,7 @@
     };
 
     fillableInflaterInputStream = new FillableInflaterInputStream(throttleStream, inflater);
-    nameValueBlockIn = new DataInputStream(fillableInflaterInputStream);
+    headerBlockIn = new DataInputStream(fillableInflaterInputStream);
   }
 
   /** Extend the inflater stream so we can eagerly fill the compressed bytes buffer if necessary. */
@@ -74,7 +74,7 @@ public FillableInflaterInputStream(InputStream in, Inflater inf) {
 
   public List<Header> readNameValueBlock(int length) throws IOException {
     this.compressedLimit += length;
-    int numberOfPairs = nameValueBlockIn.readInt();
+    int numberOfPairs = headerBlockIn.readInt();
     if (numberOfPairs < 0) {
       throw new IOException("numberOfPairs < 0: " + numberOfPairs);
     }
@@ -83,8 +83,8 @@ public FillableInflaterInputStream(InputStream in, Inflater inf) {
     }
     List<Header> entries = new ArrayList<Header>(numberOfPairs);
     for (int i = 0; i < numberOfPairs; i++) {
-      ByteString name = ByteString.readLowerCase(nameValueBlockIn, nameValueBlockIn.readInt());
-      ByteString values = ByteString.read(nameValueBlockIn, nameValueBlockIn.readInt());
+      ByteString name = ByteString.readLowerCase(headerBlockIn, headerBlockIn.readInt());
+      ByteString values = ByteString.read(headerBlockIn, headerBlockIn.readInt());
       if (name.size() == 0) throw new IOException("name.size == 0");
       entries.add(new Header(name, values));
     }
@@ -107,6 +107,6 @@ private void doneReading() throws IOException {
   }
 
   @Override public void close() throws IOException {
-    nameValueBlockIn.close();
+    headerBlockIn.close();
   }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index ad5081d633..4d0bf84556 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -116,11 +116,11 @@
   static final class Reader implements FrameReader {
     private final DataInputStream in;
     private final boolean client;
-    private final NameValueBlockReader nameValueBlockReader;
+    private final NameValueBlockReader headerBlockReader;
 
     Reader(InputStream in, boolean client) {
       this.in = new DataInputStream(in);
-      this.nameValueBlockReader = new NameValueBlockReader(in);
+      this.headerBlockReader = new NameValueBlockReader(in);
       this.client = client;
     }
 
@@ -213,20 +213,20 @@ private void readSynStream(Handler handler, int flags, int length) throws IOExce
       int associatedStreamId = w2 & 0x7fffffff;
       int priority = (s3 & 0xe000) >>> 13;
       int slot = s3 & 0xff;
-      List<Header> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 10);
+      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 10);
 
       boolean inFinished = (flags & FLAG_FIN) != 0;
       boolean outFinished = (flags & FLAG_UNIDIRECTIONAL) != 0;
       handler.headers(outFinished, inFinished, streamId, associatedStreamId, priority,
-          nameValueBlock, HeadersMode.SPDY_SYN_STREAM);
+          headerBlock, HeadersMode.SPDY_SYN_STREAM);
     }
 
     private void readSynReply(Handler handler, int flags, int length) throws IOException {
       int w1 = in.readInt();
       int streamId = w1 & 0x7fffffff;
-      List<Header> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 4);
+      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
       boolean inFinished = (flags & FLAG_FIN) != 0;
-      handler.headers(false, inFinished, streamId, -1, -1, nameValueBlock, HeadersMode.SPDY_REPLY);
+      handler.headers(false, inFinished, streamId, -1, -1, headerBlock, HeadersMode.SPDY_REPLY);
     }
 
     private void readRstStream(Handler handler, int flags, int length) throws IOException {
@@ -243,8 +243,8 @@ private void readRstStream(Handler handler, int flags, int length) throws IOExce
     private void readHeaders(Handler handler, int flags, int length) throws IOException {
       int w1 = in.readInt();
       int streamId = w1 & 0x7fffffff;
-      List<Header> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 4);
-      handler.headers(false, false, streamId, -1, -1, nameValueBlock, HeadersMode.SPDY_HEADERS);
+      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
+      handler.headers(false, false, streamId, -1, -1, headerBlock, HeadersMode.SPDY_HEADERS);
     }
 
     private void readWindowUpdate(Handler handler, int flags, int length) throws IOException {
@@ -259,8 +259,8 @@ private void readWindowUpdate(Handler handler, int flags, int length) throws IOE
     private void readPing(Handler handler, int flags, int length) throws IOException {
       if (length != 4) throw ioException("TYPE_PING length: %d != 4", length);
       int id = in.readInt();
-      boolean reply = client == ((id % 2) == 1);
-      handler.ping(reply, id, 0);
+      boolean ack = client == ((id % 2) == 1);
+      handler.ping(ack, id, 0);
     }
 
     private void readGoAway(Handler handler, int flags, int length) throws IOException {
@@ -296,15 +296,15 @@ private static IOException ioException(String message, Object... args) throws IO
     }
 
     @Override public void close() throws IOException {
-      Util.closeAll(in, nameValueBlockReader);
+      Util.closeAll(in, headerBlockReader);
     }
   }
 
   /** Write spdy/3 frames. */
   static final class Writer implements FrameWriter {
     private final DataOutputStream out;
-    private final ByteArrayOutputStream nameValueBlockBuffer;
-    private final DataOutputStream nameValueBlockOut;
+    private final ByteArrayOutputStream headerBlockBuffer;
+    private final DataOutputStream headerBlockOut;
     private final boolean client;
 
     Writer(OutputStream out, boolean client) {
@@ -313,15 +313,21 @@ private static IOException ioException(String message, Object... args) throws IO
 
       Deflater deflater = new Deflater();
       deflater.setDictionary(DICTIONARY);
-      nameValueBlockBuffer = new ByteArrayOutputStream();
-      nameValueBlockOut = new DataOutputStream(
-          Platform.get().newDeflaterOutputStream(nameValueBlockBuffer, deflater, true));
+      headerBlockBuffer = new ByteArrayOutputStream();
+      headerBlockOut = new DataOutputStream(
+          Platform.get().newDeflaterOutputStream(headerBlockBuffer, deflater, true));
     }
 
     @Override public void ackSettings() {
       // Do nothing: no ACK for SPDY/3 settings.
     }
 
+    @Override
+    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+        throws IOException {
+      // Do nothing: no push promise for SPDY/3.
+    }
+
     @Override public synchronized void connectionHeader() {
       // Do nothing: no connection header for SPDY/3.
     }
@@ -332,10 +338,10 @@ private static IOException ioException(String message, Object... args) throws IO
 
     @Override
     public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, int slot, List<Header> nameValueBlock)
+        int associatedStreamId, int priority, int slot, List<Header> headerBlock)
         throws IOException {
-      writeNameValueBlockToBuffer(nameValueBlock);
-      int length = 10 + nameValueBlockBuffer.size();
+      writeNameValueBlockToBuffer(headerBlock);
+      int length = 10 + headerBlockBuffer.size();
       int type = TYPE_SYN_STREAM;
       int flags = (outFinished ? FLAG_FIN : 0) | (inFinished ? FLAG_UNIDIRECTIONAL : 0);
 
@@ -345,35 +351,35 @@ public synchronized void synStream(boolean outFinished, boolean inFinished, int
       out.writeInt(streamId & 0x7fffffff);
       out.writeInt(associatedStreamId & 0x7fffffff);
       out.writeShort((priority & 0x7) << 13 | (unused & 0x1f) << 8 | (slot & 0xff));
-      nameValueBlockBuffer.writeTo(out);
+      headerBlockBuffer.writeTo(out);
       out.flush();
     }
 
     @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<Header> nameValueBlock) throws IOException {
-      writeNameValueBlockToBuffer(nameValueBlock);
+        List<Header> headerBlock) throws IOException {
+      writeNameValueBlockToBuffer(headerBlock);
       int type = TYPE_SYN_REPLY;
       int flags = (outFinished ? FLAG_FIN : 0);
-      int length = nameValueBlockBuffer.size() + 4;
+      int length = headerBlockBuffer.size() + 4;
 
       out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
       out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
       out.writeInt(streamId & 0x7fffffff);
-      nameValueBlockBuffer.writeTo(out);
+      headerBlockBuffer.writeTo(out);
       out.flush();
     }
 
-    @Override public synchronized void headers(int streamId, List<Header> nameValueBlock)
+    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
         throws IOException {
-      writeNameValueBlockToBuffer(nameValueBlock);
+      writeNameValueBlockToBuffer(headerBlock);
       int flags = 0;
       int type = TYPE_HEADERS;
-      int length = nameValueBlockBuffer.size() + 4;
+      int length = headerBlockBuffer.size() + 4;
 
       out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
       out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
       out.writeInt(streamId & 0x7fffffff);
-      nameValueBlockBuffer.writeTo(out);
+      headerBlockBuffer.writeTo(out);
       out.flush();
     }
 
@@ -397,24 +403,33 @@ public synchronized void synStream(boolean outFinished, boolean inFinished, int
 
     @Override public synchronized void data(boolean outFinished, int streamId, byte[] data,
         int offset, int byteCount) throws IOException {
+      // TODO: Implement looping strategy.
       int flags = (outFinished ? FLAG_FIN : 0);
+      sendDataFrame(streamId, flags, data, offset, byteCount);
+    }
+
+    void sendDataFrame(int streamId, int flags, byte[] data, int offset, int byteCount)
+        throws IOException {
+      if (byteCount > 0xffffff) {
+        throw new IOException("FRAME_TOO_LARGE max size is 16Mib: " + byteCount);
+      }
       out.writeInt(streamId & 0x7fffffff);
       out.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
       out.write(data, offset, byteCount);
     }
 
-    private void writeNameValueBlockToBuffer(List<Header> nameValueBlock) throws IOException {
-      nameValueBlockBuffer.reset();
-      nameValueBlockOut.writeInt(nameValueBlock.size());
-      for (int i = 0, size = nameValueBlock.size(); i < size; i++) {
-        ByteString name = nameValueBlock.get(i).name;
-        nameValueBlockOut.writeInt(name.size());
-        name.write(nameValueBlockOut);
-        ByteString value = nameValueBlock.get(i).value;
-        nameValueBlockOut.writeInt(value.size());
-        value.write(nameValueBlockOut);
+    private void writeNameValueBlockToBuffer(List<Header> headerBlock) throws IOException {
+      headerBlockBuffer.reset();
+      headerBlockOut.writeInt(headerBlock.size());
+      for (int i = 0, size = headerBlock.size(); i < size; i++) {
+        ByteString name = headerBlock.get(i).name;
+        headerBlockOut.writeInt(name.size());
+        name.write(headerBlockOut);
+        ByteString value = headerBlock.get(i).value;
+        headerBlockOut.writeInt(value.size());
+        value.write(headerBlockOut);
       }
-      nameValueBlockOut.flush();
+      headerBlockOut.flush();
     }
 
     @Override public synchronized void settings(Settings settings) throws IOException {
@@ -482,7 +497,7 @@ private void writeNameValueBlockToBuffer(List<Header> nameValueBlock) throws IOE
     }
 
     @Override public void close() throws IOException {
-      Util.closeAll(out, nameValueBlockOut);
+      Util.closeAll(out, headerBlockOut);
     }
   }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index 5ed07bbf4f..504d49fc0c 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -82,7 +82,10 @@
   private Map<Integer, Ping> pings;
   private int nextPingId;
 
+  // TODO: Do we want to dynamically adjust settings, or KISS and only set once?
+  // Settings we might send include toggling push, adjusting compression table size.
   final Settings okHttpSettings;
+  // TODO: MWS will need to guard on this setting before attempting to push.
   final Settings peerSettings;
   final FrameReader frameReader;
   final FrameWriter frameWriter;
@@ -479,7 +482,7 @@ private Reader() {
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<Header> nameValueBlock,
+        int associatedStreamId, int priority, List<Header> headerBlock,
         HeadersMode headersMode) {
       SpdyStream stream;
       synchronized (SpdyConnection.this) {
@@ -503,7 +506,7 @@ private Reader() {
 
           // Create a stream.
           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,
-              inFinished, priority, nameValueBlock, peerSettings);
+              inFinished, priority, headerBlock, peerSettings);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
           executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
@@ -527,7 +530,7 @@ private Reader() {
       }
 
       // Update an existing stream.
-      stream.receiveHeaders(nameValueBlock, headersMode);
+      stream.receiveHeaders(headerBlock, headersMode);
       if (inFinished) stream.receiveFin();
     }
 
@@ -627,5 +630,23 @@ private void ackSettingsLater() {
     @Override public void priority(int streamId, int priority) {
       // TODO: honor priority.
     }
+
+    @Override
+    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+        throws IOException {
+      // TODO: Wire up properly and only cancel when local settings disable push.
+      cancelStreamLater(promisedStreamId);
+    }
+
+    private void cancelStreamLater(final int streamId) {
+      executor.submit(new NamedRunnable("OkHttp %s Cancelling Stream %s", hostName, streamId) {
+        @Override public void execute() {
+          try {
+            frameWriter.rstStream(streamId, ErrorCode.CANCEL);
+          } catch (IOException ignored) {
+          }
+        }
+      });
+    }
   }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index dbfb2dc3a9..ba14dbe45a 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -29,6 +29,7 @@
 
 /** A logical bidirectional stream. */
 public final class SpdyStream {
+  static final int OUTPUT_BUFFER_SIZE = 8192;
 
   // Internal state is guarded by this. No long-running or potentially
   // blocking operations are performed while the lock is held.
@@ -576,7 +577,7 @@ private void cancelStreamIfNecessary() throws IOException {
    * is not thread safe.
    */
   private final class SpdyDataOutputStream extends OutputStream {
-    private final byte[] buffer = SpdyStream.this.connection.bufferPool.getBuf(8192);
+    private final byte[] buffer = SpdyStream.this.connection.bufferPool.getBuf(OUTPUT_BUFFER_SIZE);
     private int pos = 0;
 
     /** True if the caller has closed this stream. */
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
index 116f9ea1e6..f7367302cc 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
@@ -28,7 +28,7 @@
   Protocol getProtocol();
 
   /**
-   * Default settings used for sending frames to the peer.
+   * Default settings used for reading or writing frames to the peer.
    * @param client true if these settings apply to writing requests, false if responses.
    */
   Settings defaultOkHttpSettings(boolean client);
@@ -47,9 +47,8 @@
   FrameReader newReader(InputStream in, Settings peerSettings, boolean client);
 
   /**
-   * @param okHttpSettings settings configured locally.
+   * @param okHttpSettings settings sent to the peer, such compression header table size.
    * @param client true if this is the HTTP client's writer, writing frames to a server.
    */
   FrameWriter newWriter(OutputStream out, Settings okHttpSettings, boolean client);
-
 }
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
index eefb461f75..cbb6eac507 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -29,7 +29,7 @@
 
   @Override
   public void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      int priority, List<Header> nameValueBlock, HeadersMode headersMode) {
+      int priority, List<Header> headerBlock, HeadersMode headersMode) {
     fail();
   }
 
@@ -45,7 +45,7 @@ public void headers(boolean outFinished, boolean inFinished, int streamId, int a
     fail();
   }
 
-  @Override public void ping(boolean reply, int payload1, int payload2) {
+  @Override public void ping(boolean ack, int payload1, int payload2) {
     fail();
   }
 
@@ -61,4 +61,9 @@ public void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowContr
   @Override public void priority(int streamId, int priority) {
     fail();
   }
+
+  @Override
+  public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
+    fail();
+  }
 }
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java
new file mode 100644
index 0000000000..0ed247d34d
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.Arrays;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.spdy.HpackDraft05Test.MutableByteArrayInputStream;
+import static com.squareup.okhttp.internal.spdy.Http20Draft09.ContinuationInputStream;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class ContinuationInputStreamTest {
+  private final MutableByteArrayInputStream bytesIn = new MutableByteArrayInputStream();
+  private final ContinuationInputStream continuation =
+      new ContinuationInputStream(new DataInputStream(bytesIn));
+
+  @Test public void read() throws IOException {
+
+    // When there are bytes left this frame, read one.
+    continuation.bytesLeft = 2;
+    bytesIn.set(new byte[] {1, 2});
+    assertEquals(1, continuation.read());
+    assertEquals(1, continuation.bytesLeft);
+
+    // When there are bytes left this frame, but none on the remote stream, EOF!
+    continuation.bytesLeft = 2;
+    bytesIn.set(new byte[] {});
+    try {
+      continuation.read();
+      fail();
+    } catch (EOFException expected) {
+    }
+
+    // When there are no bytes left in the last header frame, return -1.
+    continuation.bytesLeft = 0;
+    continuation.endHeaders = true;
+    assertEquals(-1, continuation.read());
+    assertEquals(0, continuation.bytesLeft);
+
+    // When there are no bytes left in this frame, but it isn't the last, read continuation.
+    continuation.bytesLeft = 0;
+    continuation.endHeaders = false; // Read continuation.
+    bytesIn.set(lastContinuationFrame(new byte[] {1}));
+    assertEquals(1, continuation.read());
+    assertEquals(0, continuation.bytesLeft);
+  }
+
+  @Test public void readArray() throws IOException {
+    byte[] buff = new byte[3];
+
+    // When there are bytes left this frame, read them.
+    continuation.bytesLeft = 3;
+    continuation.endHeaders = true;
+    bytesIn.set(new byte[] {1, 2, 3});
+    assertEquals(3, continuation.read(buff));
+    assertEquals(0, continuation.bytesLeft);
+    assertTrue(Arrays.equals(buff, new byte[] {1, 2, 3}));
+
+    // When there are no bytes left in the last header frame, EOF.
+    Arrays.fill(buff, (byte) -1);
+    continuation.bytesLeft = 0;
+    continuation.endHeaders = true;
+    bytesIn.set(new byte[] {});
+    try {
+      continuation.read(buff);
+      fail();
+    } catch (EOFException expected) {
+    }
+
+    // When there are no bytes left in this frame, but it isn't the last, read continuation.
+    Arrays.fill(buff, (byte) -1);
+    continuation.bytesLeft = 0;
+    continuation.endHeaders = false; // Read continuation.
+    bytesIn.set(lastContinuationFrame(new byte[] {1, 2, 3}));
+    assertEquals(3, continuation.read(buff));
+    assertTrue(Arrays.equals(buff, new byte[] {1, 2, 3}));
+    assertEquals(0, continuation.bytesLeft);
+  }
+
+  static byte[] lastContinuationFrame(byte[] headerBlock) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+    dataOut.writeShort(headerBlock.length);
+    dataOut.write(Http20Draft09.TYPE_CONTINUATION);
+    dataOut.write(Http20Draft09.FLAG_END_HEADERS);
+    dataOut.writeInt(0);
+    dataOut.write(headerBlock);
+    return out.toByteArray();
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index 7bd99b2016..f4d4709429 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -18,9 +18,9 @@
 import com.squareup.okhttp.internal.ByteString;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.util.Arrays;
 import java.util.List;
 import org.junit.Before;
@@ -38,7 +38,7 @@
   private HpackDraft05.Reader hpackReader;
 
   @Before public void resetReader() {
-    hpackReader = newReader(new DataInputStream(bytesIn));
+    hpackReader = newReader(bytesIn);
   }
 
   /**
@@ -57,7 +57,7 @@
 
     bytesIn.set(out.toByteArray());
     hpackReader.maxHeaderTableByteCount(1);
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(0, hpackReader.headerCount);
@@ -93,7 +93,7 @@
     bytesIn.set(out.toByteArray());
     // Set to only support 110 bytes (enough for 2 headers).
     hpackReader.maxHeaderTableByteCount(110);
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(2, hpackReader.headerCount);
@@ -131,7 +131,7 @@
 
     bytesIn.set(out.toByteArray());
     hpackReader.maxHeaderTableByteCount(16384); // Lots of headers need more room!
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(256, hpackReader.headerCount);
@@ -153,7 +153,7 @@
     out.write(huffmanBytes, 0, huffmanBytes.length);
 
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(1, hpackReader.headerCount);
@@ -178,7 +178,7 @@
     out.write("custom-header".getBytes(), 0, 13);
 
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(1, hpackReader.headerCount);
@@ -203,7 +203,7 @@
     out.write("/sample/path".getBytes(), 0, 12);
 
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(0, hpackReader.headerCount);
@@ -221,7 +221,7 @@
                      // idx = 2 -> :method: GET
 
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(1, hpackReader.headerCount);
@@ -248,7 +248,7 @@
                      // idx = 1 -> :method: GET
 
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(1, hpackReader.headerCount);
@@ -272,7 +272,7 @@
 
     bytesIn.set(out.toByteArray());
     hpackReader.maxHeaderTableByteCount(0); // SETTINGS_HEADER_TABLE_SIZE == 0
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     // Not buffered in header table.
@@ -287,19 +287,19 @@
   @Test public void decodeRequestExamplesWithoutHuffman() throws IOException {
     ByteArrayOutputStream out = firstRequestWithoutHuffman();
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkFirstRequestWithoutHuffman();
 
     out = secondRequestWithoutHuffman();
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkSecondRequestWithoutHuffman();
 
     out = thirdRequestWithoutHuffman();
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkThirdRequestWithoutHuffman();
   }
@@ -489,19 +489,19 @@ private void checkThirdRequestWithoutHuffman() {
   @Test public void decodeRequestExamplesWithHuffman() throws IOException {
     ByteArrayOutputStream out = firstRequestWithHuffman();
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkFirstRequestWithHuffman();
 
     out = secondRequestWithHuffman();
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkSecondRequestWithHuffman();
 
     out = thirdRequestWithHuffman();
     bytesIn.set(out.toByteArray());
-    hpackReader.readHeaders(out.size());
+    hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkThirdRequestWithHuffman();
   }
@@ -772,20 +772,20 @@ private void checkThirdRequestWithHuffman() {
     List<Header> sentHeaders = headerEntries("name", "value");
     hpackWriter.writeHeaders(sentHeaders);
     ByteArrayInputStream bytesIn = new ByteArrayInputStream(bytesOut.toByteArray());
-    HpackDraft05.Reader reader = newReader(new DataInputStream(bytesIn));
-    reader.readHeaders(bytesOut.size());
+    HpackDraft05.Reader reader = newReader(bytesIn);
+    reader.readHeaders();
     reader.emitReferenceSet();
     List<Header> receivedHeaders = reader.getAndReset();
     assertEquals(sentHeaders, receivedHeaders);
   }
 
-  private HpackDraft05.Reader newReader(DataInputStream input) {
+  private HpackDraft05.Reader newReader(InputStream input) {
     return new HpackDraft05.Reader(false, 4096, input);
   }
 
-  private DataInputStream byteStream(int... bytes) {
+  private InputStream byteStream(int... bytes) {
     byte[] data = intArrayToByteArray(bytes);
-    return new DataInputStream(new ByteArrayInputStream(data));
+    return new ByteArrayInputStream(data);
   }
 
   private void checkEntry(Header entry, String name, String value, int size) {
@@ -821,13 +821,13 @@ private int headerTableLength() {
     return hpackReader.headerTable.length;
   }
 
-  private static class MutableByteArrayInputStream extends ByteArrayInputStream {
+  static class MutableByteArrayInputStream extends ByteArrayInputStream {
 
-    private MutableByteArrayInputStream() {
+    MutableByteArrayInputStream() {
       super(new byte[] { });
     }
 
-    private void set(byte[] replacement) {
+    void set(byte[] replacement) {
       this.buf = replacement;
       this.pos = 0;
       this.count = replacement.length;
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index 3dc4c085da..31d08421a2 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -15,17 +15,22 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
 import java.util.List;
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.headerEntries;
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 public class Http20Draft09Test {
   static final int expectedStreamId = 15;
@@ -53,64 +58,181 @@
 
       @Override
       public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<Header> nameValueBlock,
+          int associatedStreamId, int priority, List<Header> headerBlock,
           HeadersMode headersMode) {
         assertFalse(outFinished);
         assertTrue(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(-1, priority);
+        assertEquals(sentHeaders, headerBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  @Test public void headersWithPriority() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final List<Header> sentHeaders = headerEntries("name", "value");
+
+    { // Write the headers frame, specifying priority flag and value.
+      byte[] headerBytes = literalHeaders(sentHeaders);
+      dataOut.writeShort(headerBytes.length);
+      dataOut.write(Http20Draft09.TYPE_HEADERS);
+      dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_PRIORITY);
+      dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
+      dataOut.writeInt(0); // Highest priority is 0.
+      dataOut.write(headerBytes);
+    }
+
+    FrameReader fr = newReader(out);
+
+    // Consume the headers frame.
+    fr.nextFrame(new BaseTestHandler() {
+
+      @Override
+      public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, int priority, List<Header> nameValueBlock,
+          HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(0, priority);
         assertEquals(sentHeaders, nameValueBlock);
         assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     });
   }
 
+  /** Headers are compressed, then framed. */
   @Test public void headersFrameThenContinuation() throws IOException {
 
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     DataOutputStream dataOut = new DataOutputStream(out);
 
-    // Write the first headers frame.
-    {
-      byte[] headerBytes = literalHeaders(headerEntries("foo", "bar"));
-      dataOut.writeShort(headerBytes.length);
+    // Decoding the first header will cross frame boundaries.
+    byte[] headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+    { // Write the first headers frame.
+      dataOut.writeShort(headerBlock.length / 2);
       dataOut.write(Http20Draft09.TYPE_HEADERS);
       dataOut.write(0); // no flags
       dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
-      dataOut.write(headerBytes);
+      dataOut.write(headerBlock, 0, headerBlock.length / 2);
     }
 
-    // Write the continuation frame, specifying no more frames are expected.
-    {
-      byte[] headerBytes = literalHeaders(headerEntries("baz", "qux"));
-      dataOut.writeShort(headerBytes.length);
+    { // Write the continuation frame, specifying no more frames are expected.
+      dataOut.writeShort(headerBlock.length / 2);
       dataOut.write(Http20Draft09.TYPE_CONTINUATION);
-      dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_END_STREAM);
+      dataOut.write(Http20Draft09.FLAG_END_HEADERS);
       dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
-      dataOut.write(headerBytes);
+      dataOut.write(headerBlock, headerBlock.length / 2, headerBlock.length / 2);
     }
 
     FrameReader fr = newReader(out);
 
-    // Reading the above frames should result in a concatenated nameValueBlock.
+    // Reading the above frames should result in a concatenated headerBlock.
     fr.nextFrame(new BaseTestHandler() {
 
       @Override
       public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<Header> nameValueBlock,
+          int associatedStreamId, int priority, List<Header> headerBlock,
           HeadersMode headersMode) {
         assertFalse(outFinished);
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(-1, priority);
-        assertEquals(headerEntries("foo", "bar", "baz", "qux"), nameValueBlock);
+        assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
         assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     });
   }
 
+  @Test public void pushPromise() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final int expectedPromisedStreamId = 11;
+
+    final List<Header> pushPromise = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/")
+    );
+
+    { // Write the push promise frame, specifying the associated stream ID.
+      byte[] headerBytes = literalHeaders(pushPromise);
+      dataOut.writeShort(headerBytes.length);
+      dataOut.write(Http20Draft09.TYPE_PUSH_PROMISE);
+      dataOut.write(Http20Draft09.FLAG_END_PUSH_PROMISE);
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
+      dataOut.writeInt(expectedPromisedStreamId & 0x7fffffff);
+      dataOut.write(headerBytes);
+    }
+
+    FrameReader fr = newReader(out);
+
+    // Consume the headers frame.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedPromisedStreamId, promisedStreamId);
+        assertEquals(pushPromise, headerBlock);
+      }
+    });
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void pushPromiseThenContinuation() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final int expectedPromisedStreamId = 11;
+
+    final List<Header> pushPromise = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/")
+    );
+
+    // Decoding the first header will cross frame boundaries.
+    byte[] headerBlock = literalHeaders(pushPromise);
+    { // Write the first headers frame.
+      dataOut.writeShort(headerBlock.length / 2);
+      dataOut.write(Http20Draft09.TYPE_PUSH_PROMISE);
+      dataOut.write(0); // no flags
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
+      dataOut.writeInt(expectedPromisedStreamId & 0x7fffffff);
+      dataOut.write(headerBlock, 0, headerBlock.length / 2);
+    }
+
+    { // Write the continuation frame, specifying no more frames are expected.
+      dataOut.writeShort(headerBlock.length / 2);
+      dataOut.write(Http20Draft09.TYPE_CONTINUATION);
+      dataOut.write(Http20Draft09.FLAG_END_HEADERS);
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
+      dataOut.write(headerBlock, headerBlock.length / 2, headerBlock.length / 2);
+    }
+
+    FrameReader fr = newReader(out);
+
+    // Reading the above frames should result in a concatenated headerBlock.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedPromisedStreamId, promisedStreamId);
+        assertEquals(pushPromise, headerBlock);
+      }
+    });
+  }
+
   @Test public void readRstStreamFrame() throws IOException {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     DataOutputStream dataOut = new DataOutputStream(out);
@@ -138,12 +260,14 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
 
     final int reducedTableSizeBytes = 16;
 
-    dataOut.writeShort(8); // 1 setting = 4 bytes for the code and 4 for the value.
+    dataOut.writeShort(16); // 2 settings * 4 bytes for the code and 4 for the value.
     dataOut.write(Http20Draft09.TYPE_SETTINGS);
     dataOut.write(0); // No flags
     dataOut.writeInt(0 & 0x7fffffff); // Settings are always on the connection stream 0.
     dataOut.writeInt(Settings.HEADER_TABLE_SIZE & 0xffffff);
     dataOut.writeInt(reducedTableSizeBytes);
+    dataOut.writeInt(Settings.ENABLE_PUSH & 0xffffff);
+    dataOut.writeInt(0);
 
     final Http20Draft09.Reader fr = newReader(out);
 
@@ -152,18 +276,107 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
       @Override public void settings(boolean clearPrevious, Settings settings) {
         assertFalse(clearPrevious); // No clearPrevious in http/2.
         assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
+        assertEquals(false, settings.getEnablePush(true));
+      }
+    });
+  }
+
+  @Test public void pingRoundTrip() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final int expectedPayload1 = 7;
+    final int expectedPayload2 = 8;
+
+    // Compose the expected PING frame.
+    dataOut.writeShort(8); // length
+    dataOut.write(Http20Draft09.TYPE_PING);
+    dataOut.write(Http20Draft09.FLAG_ACK);
+    dataOut.writeInt(0); // connection-level
+    dataOut.writeInt(expectedPayload1);
+    dataOut.writeInt(expectedPayload2);
+
+    // Check writer sends the same bytes.
+    assertArrayEquals(out.toByteArray(), sendPingFrame(true, expectedPayload1, expectedPayload2));
+
+    FrameReader fr = newReader(out);
+
+    fr.nextFrame(new BaseTestHandler() { // Consume the ping frame.
+      @Override public void ping(boolean ack, int payload1, int payload2) {
+        assertTrue(ack);
+        assertEquals(expectedPayload1, payload1);
+        assertEquals(expectedPayload2, payload2);
       }
     });
   }
 
+  @Test public void maxLengthDataFrame() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final byte[] expectedData = new byte[16383];
+    Arrays.fill(expectedData, (byte) 2);
+
+    // Write the data frame.
+    dataOut.writeShort(expectedData.length);
+    dataOut.write(Http20Draft09.TYPE_DATA);
+    dataOut.write(0); // no flags
+    dataOut.writeInt(expectedStreamId & 0x7fffffff);
+    dataOut.write(expectedData);
+
+    // Check writer sends the same bytes.
+    assertArrayEquals(out.toByteArray(), sendDataFrame(expectedData));
+
+    FrameReader fr = newReader(out);
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void data(boolean inFinished, int streamId, InputStream in, int length)
+          throws IOException {
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(16383, length);
+        byte[] data = new byte[length];
+        Util.readFully(in, data);
+        for (byte b : data){
+          assertEquals(2, b);
+        }
+      }
+    });
+  }
+
+  @Test public void tooLargeDataFrame() throws IOException {
+    try {
+      sendDataFrame(new byte[0x1000000]);
+      fail();
+    } catch (IOException e) {
+      assertEquals("FRAME_SIZE_ERROR max size is 16383: 16777216", e.getMessage());
+    }
+  }
+
   private Http20Draft09.Reader newReader(ByteArrayOutputStream out) {
     return new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()),
         Variant.HTTP_20_DRAFT_09.initialPeerSettings(false).getHeaderTableSize(), false);
   }
 
   private byte[] literalHeaders(List<Header> sentHeaders) throws IOException {
-    ByteArrayOutputStream headerBytes = new ByteArrayOutputStream();
-    new HpackDraft05.Writer(new DataOutputStream(headerBytes)).writeHeaders(sentHeaders);
-    return headerBytes.toByteArray();
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new HpackDraft05.Writer(new DataOutputStream(out)).writeHeaders(sentHeaders);
+    return out.toByteArray();
+  }
+
+  private byte[] sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Http20Draft09.Writer(out, true).ping(ack, payload1, payload2);
+    return out.toByteArray();
+  }
+
+  private byte[] sendDataFrame(byte[] data) throws IOException {
+    return sendDataFrame(data, 0, data.length);
+  }
+
+  private byte[] sendDataFrame(byte[] data, int offset, int byteCount) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Http20Draft09.Writer(out, true).sendDataFrame(expectedStreamId, 0, data, offset, byteCount);
+    return out.toByteArray();
   }
 }
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index fe1789f454..73a37e01dd 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -186,10 +186,13 @@ private OutFrame(int sequence, int start, int truncateToLength) {
     public int priority;
     public ErrorCode errorCode;
     public int deltaWindowSize;
-    public List<Header> nameValueBlock;
+    public List<Header> headerBlock;
     public byte[] data;
     public Settings settings;
     public HeadersMode headersMode;
+    public boolean ack;
+    public int payload1;
+    public int payload2;
 
     public InFrame(int sequence, FrameReader reader) {
       this.sequence = sequence;
@@ -204,7 +207,7 @@ public InFrame(int sequence, FrameReader reader) {
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<Header> nameValueBlock,
+        int associatedStreamId, int priority, List<Header> headerBlock,
         HeadersMode headersMode) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_HEADERS;
@@ -213,7 +216,7 @@ public InFrame(int sequence, FrameReader reader) {
       this.streamId = streamId;
       this.associatedStreamId = associatedStreamId;
       this.priority = priority;
-      this.nameValueBlock = nameValueBlock;
+      this.headerBlock = headerBlock;
       this.headersMode = headersMode;
     }
 
@@ -234,10 +237,12 @@ public InFrame(int sequence, FrameReader reader) {
       this.errorCode = errorCode;
     }
 
-    @Override public void ping(boolean reply, int payload1, int payload2) {
+    @Override public void ping(boolean ack, int payload1, int payload2) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_PING;
-      this.streamId = payload1;
+      this.ack = ack;
+      this.payload1 = payload1;
+      this.payload2 = payload2;
     }
 
     @Override public void noop() {
@@ -262,5 +267,13 @@ public InFrame(int sequence, FrameReader reader) {
     @Override public void priority(int streamId, int priority) {
       throw new UnsupportedOperationException();
     }
+
+    @Override
+    public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
+      this.type = Http20Draft09.TYPE_PUSH_PROMISE;
+      this.streamId = streamId;
+      this.associatedStreamId = associatedStreamId;
+      this.headerBlock = headerBlock;
+    }
   }
-}
\ No newline at end of file
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
new file mode 100644
index 0000000000..83d3fd2a48
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class Spdy3Test {
+  static final int expectedStreamId = 15;
+
+  @Test public void tooLargeDataFrame() throws IOException {
+    try {
+      sendDataFrame(new byte[0x1000000]);
+      fail();
+    } catch (IOException e) {
+      assertEquals("FRAME_TOO_LARGE max size is 16Mib: 16777216", e.getMessage());
+    }
+  }
+
+  private byte[] sendDataFrame(byte[] data) throws IOException {
+    return sendDataFrame(data, 0, data.length);
+  }
+
+  private byte[] sendDataFrame(byte[] data, int offset, int byteCount) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Spdy3.Writer(out, true).sendDataFrame(expectedStreamId, 0, data, offset, byteCount);
+    return out.toByteArray();
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 928ff23c2b..313bcbc74f 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -13,7 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.Protocol;
@@ -90,7 +89,7 @@
     assertFalse(synStream.outFinished);
     assertEquals(1, synStream.streamId);
     assertEquals(0, synStream.associatedStreamId);
-    assertEquals(headerEntries("b", "banana"), synStream.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
     MockSpdyPeer.InFrame requestData = peer.takeFrame();
     assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
   }
@@ -155,7 +154,7 @@
     assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
     assertFalse(reply.inFinished);
     assertEquals(2, reply.streamId);
-    assertEquals(headerEntries("b", "banana"), reply.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), reply.headerBlock);
     assertEquals(1, receiveCount.get());
   }
 
@@ -180,7 +179,7 @@
     assertEquals(TYPE_HEADERS, reply.type);
     assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
     assertTrue(reply.inFinished);
-    assertEquals(headerEntries("b", "banana"), reply.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), reply.headerBlock);
     assertEquals(1, receiveCount.get());
   }
 
@@ -209,16 +208,38 @@
     // play it back
     new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
 
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame ping = peer.takeFrame();
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(0, ping.payload2); // ignored in spdy!
+    assertTrue(ping.ack);
+  }
+
+  @Test public void serverPingsClientHttp2() throws Exception {
+    MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, false);
+
+    // write the mocking script
+    peer.sendFrame().ping(false, 2, 3);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    http2Connection(peer);
+
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.streamId);
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(3, ping.payload2);
+    assertTrue(ping.ack);
   }
 
   @Test public void clientPingsServer() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
+    peer.sendFrame().ping(true, 1, 5); // payload2 ignored in spdy!
     peer.play();
 
     // play it back
@@ -232,7 +253,31 @@
     // verify the peer received what was expected
     MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
     assertEquals(TYPE_PING, pingFrame.type);
-    assertEquals(1, pingFrame.streamId);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(0, pingFrame.payload2);
+    assertFalse(pingFrame.ack);
+  }
+
+  @Test public void clientPingsServerHttp2() throws Exception {
+    MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, false);
+
+    // write the mocking script
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 5);
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = http2Connection(peer);
+    Ping ping = connection.ping();
+    assertTrue(ping.roundTripTime() > 0);
+    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
+    assertEquals(0, pingFrame.streamId);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
+    assertFalse(pingFrame.ack);
   }
 
   @Test public void unexpectedPingIsNotReturned() throws Exception {
@@ -249,40 +294,38 @@
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping2 = peer.takeFrame();
-    assertEquals(2, ping2.streamId);
+    assertEquals(2, ping2.payload1);
     MockSpdyPeer.InFrame ping4 = peer.takeFrame();
-    assertEquals(4, ping4.streamId);
+    assertEquals(4, ping4.payload1);
   }
 
-  @Test public void http2SettingsAck() throws Exception {
-    MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, false);
-    // write the mocking script
-    Settings settings = new Settings();
-    settings.set(Settings.HEADER_TABLE_SIZE, PERSIST_VALUE, 1024);
-    peer.sendFrame().settings(settings);
-    peer.acceptFrame(); // ACK
-    peer.play();
+  @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
+    boolean client = false; // Peer is server, so we are client.
+    Settings settings = Variant.HTTP_20_DRAFT_09.initialPeerSettings(client);
+    settings.set(Settings.HEADER_TABLE_SIZE, PERSIST_VALUE, 0);
 
-    // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .protocol(Protocol.HTTP_2)
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
-
-    // verify the peer received the ACK
-    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
-    assertEquals(TYPE_SETTINGS, pingFrame.type);
-    assertEquals(0, pingFrame.streamId);
-    // TODO: check for ACK flag.
-    assertEquals(0, pingFrame.settings.size());
+    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
 
     // verify the peer's settings were read and applied.
     synchronized (connection) {
-      assertEquals(1024, connection.peerSettings.getHeaderTableSize());
+      assertEquals(0, connection.peerSettings.getHeaderTableSize());
       Http20Draft09.Reader frameReader = (Http20Draft09.Reader) connection.frameReader;
-      assertEquals(1024, frameReader.hpackReader.maxHeaderTableByteCount());
+      assertEquals(0, frameReader.hpackReader.maxHeaderTableByteCount());
+      // TODO: when supported, check the frameWriter's compression table is unaffected.
+    }
+  }
+
+  @Test public void peerHttp2ClientDisablesPush() throws Exception {
+    boolean client = false; // Peer is client, so we are server.
+    Settings settings = Variant.HTTP_20_DRAFT_09.initialPeerSettings(client);
+    settings.set(Settings.ENABLE_PUSH, 0, 0); // The peer client disables push.
+
+    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+
+    // verify the peer's settings were read and applied.
+    synchronized (connection) {
+      assertFalse(connection.peerSettings.getEnablePush(true));
     }
-    peer.close();
   }
 
   @Test public void serverSendsSettingsToClient() throws Exception {
@@ -356,7 +399,7 @@
     assertEquals(42, rstStream.streamId);
     assertEquals(INVALID_STREAM, rstStream.errorCode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void bogusReplyFrameDoesNotDisruptConnection() throws Exception {
@@ -376,7 +419,7 @@
     assertEquals(42, rstStream.streamId);
     assertEquals(INVALID_STREAM, rstStream.errorCode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void clientClosesClientOutputStream() throws Exception {
@@ -423,7 +466,7 @@
     assertTrue(fin.inFinished);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(1, ping.streamId);
+    assertEquals(1, ping.payload1);
   }
 
   @Test public void serverClosesClientOutputStream() throws Exception {
@@ -459,7 +502,7 @@
     assertFalse(synStream.outFinished);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(1, ping.streamId);
+    assertEquals(1, ping.payload1);
     MockSpdyPeer.InFrame data = peer.takeFrame();
     assertEquals(TYPE_DATA, data.type);
     assertEquals(1, data.streamId);
@@ -670,7 +713,7 @@
     assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void remoteSendsTooMuchData() throws Exception {
@@ -698,7 +741,7 @@
     assertEquals(FLOW_CONTROL_ERROR, rstStream.errorCode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
@@ -726,7 +769,7 @@
     assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void receiveGoAway() throws Exception {
@@ -1050,8 +1093,42 @@
     }
   }
 
+  /**
+   * This tests that data frames are written in chunks limited by the
+   * SpdyDataOutputStream buffer size.  A side-effect is that this size
+   * prevents us from overrunning the max frame size of SPDY/3 or HTTP/2.
+   */
+  @Test public void spdyStreamOutputBufferSizeLimitsDataFrameLength() throws Exception {
+    MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, false);
+
+    byte[] buff = new byte[SpdyStream.OUTPUT_BUFFER_SIZE * 2];
+    Arrays.fill(buff, (byte) '*');
+
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA 1
+    peer.acceptFrame(); // DATA 2
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = http2Connection(peer);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    OutputStream out = stream.getOutputStream();
+    out.write(buff);
+    out.flush();
+    out.close();
+
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    MockSpdyPeer.InFrame data = peer.takeFrame();
+    assertEquals(SpdyStream.OUTPUT_BUFFER_SIZE, data.data.length);
+    data = peer.takeFrame();
+    assertEquals(SpdyStream.OUTPUT_BUFFER_SIZE, data.data.length);
+  }
+
   /** https://github.com/square/okhttp/issues/333 */
-  @Test public void nameValueBlockHasTrailingCompressedBytes() throws Exception {
+  @Test public void headerBlockHasTrailingCompressedBytes() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     // This specially-formatted frame has trailing deflated bytes after the name value block.
@@ -1077,6 +1154,59 @@
     assertStreamData("robot", stream.getInputStream());
   }
 
+  // TODO: change this to only cancel when local settings disable push
+  @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
+    MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, false);
+
+    // write the mocking script
+    peer.sendFrame().pushPromise(1, 2, Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    ));
+    peer.sendFrame().synReply(true, 1, Arrays.asList(
+        new Header(Header.RESPONSE_STATUS, "200")
+    ));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    http2Connection(peer);
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
+    assertEquals(TYPE_RST_STREAM, rstStream.type);
+    assertEquals(2, rstStream.streamId);
+    assertEquals(CANCEL, rstStream.errorCode);
+  }
+
+  private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
+      throws IOException, InterruptedException {
+    MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, client);
+    peer.sendFrame().settings(settings);
+    peer.acceptFrame(); // ACK
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = http2Connection(peer);
+
+    // verify the peer received the ACK
+    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, pingFrame.type);
+    assertEquals(0, pingFrame.streamId);
+    // TODO: check for ACK flag.
+    assertEquals(0, pingFrame.settings.size());
+    peer.close();
+    return connection;
+  }
+
+  private SpdyConnection http2Connection(MockSpdyPeer peer) throws IOException {
+    return new SpdyConnection.Builder(true, peer.openSocket())
+        .protocol(Protocol.HTTP_2)
+        .handler(REJECT_INCOMING_STREAMS).build();
+  }
+
   private void writeAndClose(SpdyStream stream, String data) throws IOException {
     OutputStream out = stream.getOutputStream();
     out.write(data.getBytes("UTF-8"));
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 1cf9bd3751..d76417def2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -333,7 +333,7 @@ public HttpEngine recover(IOException e) {
 
   private boolean isRecoverable(IOException e) {
     // If the problem was a CertificateException from the X509TrustManager,
-    // do not retry, we didn't have an abrupt server initiated exception.
+    // do not retry, we didn't have an abrupt server-initiated exception.
     boolean sslFailure =
         e instanceof SSLHandshakeException && e.getCause() instanceof CertificateException;
     boolean protocolFailure = e instanceof ProtocolException;
@@ -401,16 +401,25 @@ public final void release(boolean streamCanceled) {
     }
   }
 
+  /**
+   * Initialize the response content stream from the response transfer stream.
+   * These two streams are the same unless we're doing transparent gzip, in
+   * which case the content stream is decompressed.
+   *
+   * <p>Whenever we do transparent gzip we also strip the corresponding headers.
+   * We strip the Content-Encoding header to prevent the application from
+   * attempting to double decompress. We strip the Content-Length header because
+   * it is the length of the compressed content, but the application is only
+   * interested in the length of the uncompressed content.
+   *
+   * <p>This method should only be used for non-empty response bodies. Response
+   * codes like "304 Not Modified" can include "Content-Encoding: gzip" without
+   * a response body and we will crash if we attempt to decompress the zero-byte
+   * stream.
+   */
   private void initContentStream(InputStream transferStream) throws IOException {
     responseTransferIn = transferStream;
     if (transparentGzip && "gzip".equalsIgnoreCase(response.header("Content-Encoding"))) {
-      // If the response was transparently gzipped, remove the gzip header field
-      // so clients don't double decompress. http://b/3009828
-      //
-      // Also remove the Content-Length in this case because it contains the
-      // length of the gzipped response. This isn't terribly useful and is
-      // dangerous because clients can query the content length, but not the
-      // content encoding.
       response = response.newBuilder()
           .removeHeader("Content-Encoding")
           .removeHeader("Content-Length")
@@ -561,10 +570,14 @@ public final void readResponse() throws IOException {
       }
     }
 
-    if (hasResponseBody()) {
-      maybeCache();
+    if (!hasResponseBody()) {
+      // Don't call initContentStream() when the response doesn't have any content.
+      responseTransferIn = transport.getTransferStream(cacheRequest);
+      responseBodyIn = responseTransferIn;
+      return;
     }
 
+    maybeCache();
     initContentStream(transport.getTransferStream(cacheRequest));
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 03578e27a1..9c1453b647 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -153,7 +153,7 @@ private static String joinOnNull(String first, String second) {
   }
 
   /** Returns headers for a name value block containing a SPDY response. */
-  public static Response.Builder readNameValueBlock(List<Header> nameValueBlock,
+  public static Response.Builder readNameValueBlock(List<Header> headerBlock,
       Protocol protocol) throws IOException {
     String status = null;
     String version = "HTTP/1.1"; // :version present only in spdy/3.
@@ -161,9 +161,9 @@ private static String joinOnNull(String first, String second) {
     Headers.Builder headersBuilder = new Headers.Builder();
     headersBuilder.set(OkHeaders.SELECTED_TRANSPORT, protocol.name.utf8());
     headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.name.utf8());
-    for (int i = 0; i < nameValueBlock.size(); i++) {
-      ByteString name = nameValueBlock.get(i).name;
-      String values = nameValueBlock.get(i).value.utf8();
+    for (int i = 0; i < headerBlock.size(); i++) {
+      ByteString name = headerBlock.get(i).name;
+      String values = headerBlock.get(i).value.utf8();
       for (int start = 0; start < values.length(); ) {
         int end = values.indexOf('\0', start);
         if (end == -1) {
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
index 84926bc4a3..36b63f07ed 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
@@ -30,14 +30,14 @@
 
 public final class HeadersTest {
   @Test public void parseNameValueBlock() throws IOException {
-    List<Header> nameValueBlock = headerEntries(
+    List<Header> headerBlock = headerEntries(
         "cache-control", "no-cache, no-store",
         "set-cookie", "Cookie1\u0000Cookie2",
         ":status", "200 OK",
         ":version", "HTTP/1.1");
     Request request = new Request.Builder().url("http://square.com/").build();
     Response response =
-        SpdyTransport.readNameValueBlock(nameValueBlock, Protocol.SPDY_3).request(request).build();
+        SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
     Headers headers = response.headers();
     assertEquals(5, headers.size());
     assertEquals("HTTP/1.1 200 OK", response.statusLine());
@@ -59,13 +59,13 @@
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersSpdy3() throws IOException {
-    List<Header> nameValueBlock = headerEntries(
+    List<Header> headerBlock = headerEntries(
         ":status", "200 OK",
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
     Response response =
-        SpdyTransport.readNameValueBlock(nameValueBlock, Protocol.SPDY_3).request(request).build();
+        SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
     Headers headers = response.headers();
     assertEquals(2, headers.size());
     assertEquals(OkHeaders.SELECTED_TRANSPORT, headers.name(0));
@@ -75,12 +75,12 @@
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
-    List<Header> nameValueBlock = headerEntries(
+    List<Header> headerBlock = headerEntries(
         ":status", "200 OK",
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = SpdyTransport.readNameValueBlock(nameValueBlock, Protocol.HTTP_2)
+    Response response = SpdyTransport.readNameValueBlock(headerBlock, Protocol.HTTP_2)
         .request(request).build();
     Headers headers = response.headers();
     assertEquals(2, headers.size());
@@ -98,7 +98,7 @@
         .addHeader("set-cookie", "Cookie2")
         .header(":status", "200 OK")
         .build();
-    List<Header> nameValueBlock =
+    List<Header> headerBlock =
         SpdyTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1");
     List<Header> expected = headerEntries(
         ":method", "GET",
@@ -109,7 +109,7 @@
         "cache-control", "no-cache, no-store",
         "set-cookie", "Cookie1\u0000Cookie2",
         ":status", "200 OK");
-    assertEquals(expected, nameValueBlock);
+    assertEquals(expected, headerBlock);
   }
 
   @Test public void toNameValueBlockDropsForbiddenHeadersSpdy3() {
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 5704b6b5cb..7b9eb8d09d 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -17,6 +17,7 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.HttpResponseCache;
+import com.squareup.okhttp.OkAuthenticator.Credential;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.RecordingAuthenticator;
@@ -75,7 +76,6 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
-import static com.squareup.okhttp.OkAuthenticator.Credential;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
@@ -2572,6 +2572,38 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertEquals(Long.toString(contentLength), request.getHeader("Content-Length"));
   }
 
+  /**
+   * We had a bug where we attempted to gunzip responses that didn't have a
+   * body. This only came up with 304s since that response code can include
+   * headers (like "Content-Encoding") without any content to go along with it.
+   * https://github.com/square/okhttp/issues/358
+   */
+  @Test public void noTransparentGzipFor304NotModified() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    server.play();
+
+    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection1.getResponseCode());
+    assertContent("", connection1);
+    connection1.getInputStream().close();
+
+    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+    assertContent("b", connection2);
+    connection2.getInputStream().close();
+
+    RecordedRequest requestA = server.takeRequest();
+    assertEquals(0, requestA.getSequenceNumber());
+
+    RecordedRequest requestB = server.takeRequest();
+    assertEquals(1, requestB.getSequenceNumber());
+  }
+
   /** Returns a gzipped copy of {@code bytes}. */
   public byte[] gzip(byte[] bytes) throws IOException {
     ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
