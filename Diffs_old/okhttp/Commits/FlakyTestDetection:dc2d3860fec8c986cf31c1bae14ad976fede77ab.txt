diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
index 56d78513bd..283b43a247 100644
--- a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
@@ -19,17 +19,22 @@
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Deque;
 import java.util.List;
 import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
@@ -40,6 +45,7 @@
 
   private OkHttpClient client;
   private final RecordingEventListener listener = new RecordingEventListener();
+  private final SslClient sslClient = SslClient.localhost();
 
   @Before public void setUp() {
     client = new OkHttpClient.Builder()
@@ -48,6 +54,37 @@
         .build();
   }
 
+  @Test public void successfulCallEventSequence() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    List<Class<?>> expectedEvents = Arrays.asList(DnsStart.class, DnsEnd.class);
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void successfulHttpsCallEventSequence() throws IOException {
+    enableTls(false);
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    List<Class<?>> expectedEvents = Arrays.asList(
+        DnsStart.class, DnsEnd.class,
+        SecureConnectStart.class, SecureConnectEnd.class);
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
   @Test public void successfulDnsLookup() throws IOException {
     server.enqueue(new MockResponse());
 
@@ -58,11 +95,11 @@
     assertEquals(200, response.code());
     response.body().close();
 
-    DnsStart dnsStart = listener.expectNextEvent(DnsStart.class);
+    DnsStart dnsStart = listener.findNextEvent(DnsStart.class);
     assertSame(call, dnsStart.call);
     assertEquals("localhost", dnsStart.domainName);
 
-    DnsEnd dnsEnd = listener.expectNextEvent(DnsEnd.class);
+    DnsEnd dnsEnd = listener.findNextEvent(DnsEnd.class);
     assertSame(call, dnsEnd.call);
     assertEquals("localhost", dnsEnd.domainName);
     assertEquals(1, dnsEnd.inetAddressList.size());
@@ -82,9 +119,9 @@
     } catch (IOException expected) {
     }
 
-    listener.expectNextEvent(DnsStart.class);
+    listener.findNextEvent(DnsStart.class);
 
-    DnsEnd dnsEnd = listener.expectNextEvent(DnsEnd.class);
+    DnsEnd dnsEnd = listener.findNextEvent(DnsEnd.class);
     assertSame(call, dnsEnd.call);
     assertEquals("fakeurl", dnsEnd.domainName);
     assertNull(dnsEnd.inetAddressList);
@@ -110,15 +147,92 @@
     } catch (IOException expected) {
     }
 
-    listener.expectNextEvent(DnsStart.class);
+    listener.findNextEvent(DnsStart.class);
 
-    DnsEnd dnsEnd = listener.expectNextEvent(DnsEnd.class);
+    DnsEnd dnsEnd = listener.findNextEvent(DnsEnd.class);
     assertSame(call, dnsEnd.call);
     assertEquals("fakeurl", dnsEnd.domainName);
     assertNull(dnsEnd.inetAddressList);
     assertTrue(dnsEnd.throwable instanceof UnknownHostException);
   }
 
+  @Test public void successfulSecureConnect() throws IOException {
+    enableTls(false);
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    SecureConnectStart secureStart = listener.findNextEvent(SecureConnectStart.class);
+    assertSame(call, secureStart.call);
+
+    SecureConnectEnd secureEnd = listener.findNextEvent(SecureConnectEnd.class);
+    assertSame(call, secureEnd.call);
+    assertNotNull(secureEnd.handshake);
+    assertNull(secureEnd.throwable);
+  }
+
+  @Test public void failedSecureConnect() {
+    enableTls(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    SecureConnectStart secureStart = listener.findNextEvent(SecureConnectStart.class);
+    assertSame(call, secureStart.call);
+
+    SecureConnectEnd secureEnd = listener.findNextEvent(SecureConnectEnd.class);
+    assertSame(call, secureEnd.call);
+    assertNull(secureEnd.handshake);
+    assertTrue(secureEnd.throwable instanceof IOException);
+  }
+
+  @Test public void secureConnectWithTunnel() throws IOException {
+    enableTls(true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    SecureConnectStart secureStart = listener.findNextEvent(SecureConnectStart.class);
+    assertSame(call, secureStart.call);
+
+    SecureConnectEnd secureEnd = listener.findNextEvent(SecureConnectEnd.class);
+    assertSame(call, secureEnd.call);
+    assertNotNull(secureEnd.handshake);
+    assertNull(secureEnd.throwable);
+  }
+
+  private void enableTls(boolean tunnelProxy) {
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    server.useHttps(sslClient.socketFactory, tunnelProxy);
+  }
+
   static final class DnsStart {
     final Call call;
     final String domainName;
@@ -143,17 +257,48 @@
     }
   }
 
+  static final class SecureConnectStart {
+    final Call call;
+
+    SecureConnectStart(Call call) {
+      this.call = call;
+    }
+  }
+
+  static final class SecureConnectEnd {
+    final Call call;
+    final Handshake handshake;
+    final Throwable throwable;
+
+    SecureConnectEnd(Call call, Handshake handshake, Throwable throwable) {
+      this.call = call;
+      this.handshake = handshake;
+      this.throwable = throwable;
+    }
+  }
+
   static final class RecordingEventListener extends EventListener {
     final Deque<Object> eventSequence = new ArrayDeque<>();
 
-    <T> T expectNextEvent(Class<T> eventClass) {
+    <T> T findNextEvent(Class<T> eventClass) {
       Object event = eventSequence.poll();
-      if (!eventClass.isInstance(event)) {
+      while (event != null && !eventClass.isInstance(event)) {
+        event = eventSequence.poll();
+      }
+      if (event == null) {
         fail("Expected event type: " + eventClass.getName());
       }
       return (T) event;
     }
 
+    List<Class<?>> recordedEventTypes() {
+      List<Class<?>> eventTypes = new ArrayList<>();
+      for (Object event : eventSequence) {
+        eventTypes.add(event.getClass());
+      }
+      return eventTypes;
+    }
+
     @Override public void dnsStart(Call call, String domainName) {
       eventSequence.offer(new DnsStart(call, domainName));
     }
@@ -162,5 +307,13 @@
         Throwable throwable) {
       eventSequence.offer(new DnsEnd(call, domainName, inetAddressList, throwable));
     }
+
+    @Override public void secureConnectStart(Call call) {
+      eventSequence.offer(new SecureConnectStart(call));
+    }
+
+    @Override public void secureConnectEnd(Call call, Handshake handshake, Throwable throwable) {
+      eventSequence.offer(new SecureConnectEnd(call, handshake, throwable));
+    }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java b/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
index df765a67c1..9e9ec71dd8 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
@@ -106,7 +106,7 @@
   }
 
   @Test public void allPublicSuffixes() throws IOException {
-    InputStream resource = PublicSuffixDatabaseTest.class.getClassLoader()
+    InputStream resource = PublicSuffixDatabaseTest.class
         .getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
     BufferedSource source = Okio.buffer(new GzipSource(Okio.source(resource)));
     int length = source.readInt();
@@ -128,7 +128,7 @@
   }
 
   @Test public void publicSuffixExceptions() throws IOException {
-    InputStream resource = PublicSuffixDatabaseTest.class.getClassLoader()
+    InputStream resource = PublicSuffixDatabaseTest.class
         .getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
     BufferedSource source = Okio.buffer(new GzipSource(Okio.source(resource)));
     int length = source.readInt();
diff --git a/okhttp/src/main/java/okhttp3/EventListener.java b/okhttp/src/main/java/okhttp3/EventListener.java
index 890e64c874..7f8c553929 100644
--- a/okhttp/src/main/java/okhttp3/EventListener.java
+++ b/okhttp/src/main/java/okhttp3/EventListener.java
@@ -54,11 +54,27 @@ public void dnsEnd(Call call, String domainName, @Nullable List<InetAddress> ine
   public void connectStart(Call call, InetAddress address, int port) {
   }
 
+  /**
+   * Invoked just prior to initiating a TLS connection.
+   *
+   * <p>If the {@link Call#request()} does not use TLS, this method will not be invoked.
+   */
   public void secureConnectStart(Call call) {
   }
 
-  public void secureConnectEnd(Call call, Handshake handshake,
-      Throwable throwable) {
+  /**
+   * Invoked immediately after a TLS connection was attempted.
+   *
+   * <p>If the {@link Call#request()} does not use TLS, this method will not be invoked.
+   *
+   * <p>{@code handshake} will be non-null and {@code throwable} will be null in the case of a
+   * successful TLS connection.
+   *
+   * <p>{@code handshake} will be null and {@code throwable} will be non-null in the case of a
+   * failed TLS connection attempt.
+   */
+  public void secureConnectEnd(Call call, @Nullable Handshake handshake,
+      @Nullable Throwable throwable) {
   }
 
   public void connectEnd(Call call,  InetAddress address, int port, String protocol,
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index a38eab6a62..1df7ae98b8 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -34,10 +34,12 @@
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Address;
+import okhttp3.Call;
 import okhttp3.CertificatePinner;
 import okhttp3.Connection;
 import okhttp3.ConnectionPool;
 import okhttp3.ConnectionSpec;
+import okhttp3.EventListener;
 import okhttp3.Handshake;
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
@@ -121,8 +123,8 @@ public static RealConnection testConnection(
     return result;
   }
 
-  public void connect(
-      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {
+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,
+      boolean connectionRetryEnabled, Call call, EventListener eventListener) {
     if (protocol != null) throw new IllegalStateException("already connected");
 
     RouteException routeException = null;
@@ -148,7 +150,7 @@ public void connect(
         } else {
           connectSocket(connectTimeout, readTimeout);
         }
-        establishProtocol(connectionSpecSelector);
+        establishProtocol(connectionSpecSelector, call, eventListener);
         break;
       } catch (IOException e) {
         closeQuietly(socket);
@@ -241,14 +243,22 @@ private void connectSocket(int connectTimeout, int readTimeout) throws IOExcepti
     }
   }
 
-  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector) throws IOException {
+  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector, Call call,
+      EventListener eventListener) throws IOException {
     if (route.address().sslSocketFactory() == null) {
       protocol = Protocol.HTTP_1_1;
       socket = rawSocket;
       return;
     }
 
-    connectTls(connectionSpecSelector);
+    eventListener.secureConnectStart(call);
+    try {
+      connectTls(connectionSpecSelector);
+    } catch (Exception e) {
+      eventListener.secureConnectEnd(call, null, e);
+      throw e;
+    }
+    eventListener.secureConnectEnd(call, handshake, null);
 
     if (protocol == Protocol.HTTP_2) {
       socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index e23b48288a..ecca028c3c 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -75,6 +75,8 @@
   public final Address address;
   private Route route;
   private final ConnectionPool connectionPool;
+  private final Call call;
+  private final EventListener eventListener;
   private final Object callStackTrace;
 
   // State guarded by connectionPool.
@@ -89,6 +91,8 @@ public StreamAllocation(ConnectionPool connectionPool, Address address, Call cal
       EventListener eventListener, Object callStackTrace) {
     this.connectionPool = connectionPool;
     this.address = address;
+    this.call = call;
+    this.eventListener = eventListener;
     this.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener);
     this.callStackTrace = callStackTrace;
   }
@@ -195,7 +199,8 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
     }
 
     // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);
+    result.connect(
+        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);
     routeDatabase().connected(result.route());
 
     Socket socket = null;
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index fc89d0f10b..023a7ff35d 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -541,7 +541,7 @@ public Builder pushObserver(PushObserver pushObserver) {
       return this;
     }
 
-    public Http2Connection build() throws IOException {
+    public Http2Connection build() {
       return new Http2Connection(this);
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
index 20e64aa17e..75dafdd0a3 100644
--- a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
@@ -306,8 +306,7 @@ private void readTheList() throws IOException {
     byte[] publicSuffixListBytes;
     byte[] publicSuffixExceptionListBytes;
 
-    InputStream resource = PublicSuffixDatabase.class.getClassLoader().getResourceAsStream(
-        PUBLIC_SUFFIX_RESOURCE);
+    InputStream resource = PublicSuffixDatabase.class.getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
     if (resource == null) return;
 
     BufferedSource bufferedSource = Okio.buffer(new GzipSource(Okio.source(resource)));
diff --git a/okhttp/src/main/resources/publicsuffixes.gz b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz
similarity index 100%
rename from okhttp/src/main/resources/publicsuffixes.gz
rename to okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz
diff --git a/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
index c32032ee15..50b1f8703a 100644
--- a/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
+++ b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
@@ -40,7 +40,8 @@
  */
 public final class PublicSuffixListGenerator {
   private static final String OKHTTP_RESOURCE_DIR = "okhttp" + File.separator + "src"
-      + File.separator + "main" + File.separator + "resources";
+      + File.separator + "main" + File.separator + "resources" + File.separator
+      + "okhttp3" + File.separator + "internal" + File.separator + "publicsuffix";
 
   private static final ByteString EXCEPTION_RULE_MARKER = ByteString.encodeUtf8("!");
   private static final String WILDCARD_CHAR = "*";
