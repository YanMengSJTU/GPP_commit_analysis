diff --git a/okhttp/src/main/java/okhttp3/Address.java b/okhttp/src/main/java/okhttp3/Address.java
index 9df666ad78..d0d4077e2a 100644
--- a/okhttp/src/main/java/okhttp3/Address.java
+++ b/okhttp/src/main/java/okhttp3/Address.java
@@ -157,19 +157,23 @@ public ProxySelector proxySelector() {
         && equalsNonHost((Address) other);
   }
 
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + url.hashCode();
-    result = 31 * result + dns.hashCode();
-    result = 31 * result + proxyAuthenticator.hashCode();
-    result = 31 * result + protocols.hashCode();
-    result = 31 * result + connectionSpecs.hashCode();
-    result = 31 * result + proxySelector.hashCode();
-    result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
-    result = 31 * result + (sslSocketFactory != null ? sslSocketFactory.hashCode() : 0);
-    result = 31 * result + (hostnameVerifier != null ? hostnameVerifier.hashCode() : 0);
-    result = 31 * result + (certificatePinner != null ? certificatePinner.hashCode() : 0);
-    return result;
+  public String hash256() {
+
+    String result = "";
+
+    result = result + url.hash256();
+    result = result + Util.hash256(dns);
+    result = result + Util.hash256(proxyAuthenticator);
+    result = result + Util.hash256(protocols);
+    result = result + Util.hash256(connectionSpecs);
+    result = result + Util.hash256(proxySelector);
+    result = result + Util.hash256(proxy);
+    result = result + Util.hash256(sslSocketFactory);
+    result = result + Util.hash256(hostnameVerifier);
+    result = result + Util.hash256(certificatePinner);
+
+    return Util.hash256(result);
+
   }
 
   boolean equalsNonHost(Address that) {
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index d509364544..98090b049a 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -25,6 +25,8 @@
 import java.util.Set;
 import javax.annotation.Nullable;
 import javax.net.ssl.SSLPeerUnverifiedException;
+
+import okhttp3.internal.Util;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okio.ByteString;
 
@@ -143,12 +145,20 @@
         && pins.equals(((CertificatePinner) other).pins));
   }
 
-  @Override public int hashCode() {
-    int result = certificateChainCleaner != null ? certificateChainCleaner.hashCode() : 0;
-    result = 31 * result + pins.hashCode();
+  public String hash256() {
+    String result = certificateChainCleaner != null ? Util.hash256(certificateChainCleaner) : "";
+
+    result = result + Util.hash256(pins);
+
     return result;
   }
 
+//  @Override public int hashCode() {
+//    int result = certificateChainCleaner != null ? certificateChainCleaner.hashCode() : 0;
+//    result = 31 * result + pins.hashCode();
+//    return result;
+//  }
+
   /**
    * Confirms that at least one of the certificates pinned for {@code hostname} is in {@code
    * peerCertificates}. Does nothing if there are no certificates pinned for {@code hostname}.
@@ -303,14 +313,19 @@ boolean matches(String hostname) {
           && hash.equals(((Pin) other).hash);
     }
 
-    @Override public int hashCode() {
-      int result = 17;
-      result = 31 * result + pattern.hashCode();
-      result = 31 * result + hashAlgorithm.hashCode();
-      result = 31 * result + hash.hashCode();
-      return result;
+    public String hash256() {
+
+      String result = "";
+
+      result = result + Util.hash256(pattern);
+      result = result + Util.hash256(hashAlgorithm);
+      result = result + Util.hash256(hash);
+
+      return Util.hash256(result);
+
     }
 
+
     @Override public String toString() {
       return hashAlgorithm + hash.base64();
     }
diff --git a/okhttp/src/main/java/okhttp3/Challenge.java b/okhttp/src/main/java/okhttp3/Challenge.java
index 4b000eceda..7a80200f57 100644
--- a/okhttp/src/main/java/okhttp3/Challenge.java
+++ b/okhttp/src/main/java/okhttp3/Challenge.java
@@ -15,6 +15,8 @@
  */
 package okhttp3;
 
+import okhttp3.internal.Util;
+
 import java.nio.charset.Charset;
 import javax.annotation.Nullable;
 
@@ -66,12 +68,15 @@ public Charset charset() {
         && ((Challenge) other).charset.equals(charset);
   }
 
-  @Override public int hashCode() {
-    int result = 29;
-    result = 31 * result + realm.hashCode();
-    result = 31 * result + scheme.hashCode();
-    result = 31 * result + charset.hashCode();
-    return result;
+  public String hash256() {
+    String result = "";
+
+    result = result + Util.hash256(realm);
+    result = result + Util.hash256(scheme);
+    result = result + Util.hash256(charset);
+
+    return Util.hash256(result);
+
   }
 
   @Override public String toString() {
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.java b/okhttp/src/main/java/okhttp3/CipherSuite.java
index ef1c36832d..9b058a6a9e 100644
--- a/okhttp/src/main/java/okhttp3/CipherSuite.java
+++ b/okhttp/src/main/java/okhttp3/CipherSuite.java
@@ -67,119 +67,6 @@
   private static final Map<String, CipherSuite> INSTANCES = new TreeMap<>(ORDER_BY_NAME);
 
   // Last updated 2016-07-03 using cipher suites from Android 24 and Java 9.
-
-  // public static final CipherSuite TLS_NULL_WITH_NULL_NULL = of("TLS_NULL_WITH_NULL_NULL", 0x0000);
-//  public static final CipherSuite TLS_RSA_WITH_NULL_MD5 = of("SSL_RSA_WITH_NULL_MD5", 0x0001);
-//  public static final CipherSuite TLS_RSA_WITH_NULL_SHA = of("SSL_RSA_WITH_NULL_SHA", 0x0002);
-//  public static final CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003);
-//  public static final CipherSuite TLS_RSA_WITH_RC4_128_MD5 = of("SSL_RSA_WITH_RC4_128_MD5", 0x0004);
-//  public static final CipherSuite TLS_RSA_WITH_RC4_128_SHA = of("SSL_RSA_WITH_RC4_128_SHA", 0x0005);
-  // public static final CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006);
-  // public static final CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = of("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007);
-//  public static final CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008);
-//  public static final CipherSuite TLS_RSA_WITH_DES_CBC_SHA = of("SSL_RSA_WITH_DES_CBC_SHA", 0x0009);
-//  public static final CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a);
-  // public static final CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b);
-  // public static final CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA = of("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c);
-  // public static final CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d);
-  // public static final CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA = of("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010);
-//  public static final CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011);
-//  public static final CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA = of("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012);
-//  public static final CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013);
-//  public static final CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014);
-//  public static final CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA = of("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015);
-//  public static final CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016);
-//  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = of("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017);
-//  public static final CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = of("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018);
-//  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019);
-//  public static final CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA = of("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a);
-//  public static final CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = of("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b);
-//  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_SHA = of("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e);
-//  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA = of("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f);
-//  public static final CipherSuite TLS_KRB5_WITH_RC4_128_SHA = of("TLS_KRB5_WITH_RC4_128_SHA", 0x0020);
-//   public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA = of("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021);
-//  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_MD5 = of("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022);
-//  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = of("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023);
-//  public static final CipherSuite TLS_KRB5_WITH_RC4_128_MD5 = of("TLS_KRB5_WITH_RC4_128_MD5", 0x0024);
-//   public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5 = of("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025);
-//  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026);
-//   public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027);
-//  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028);
-//  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029);
-//   public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a);
-//  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b);
-//   public static final CipherSuite TLS_PSK_WITH_NULL_SHA = of("TLS_PSK_WITH_NULL_SHA", 0x002c);
-//   public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA = of("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA = of("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e);
-//  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = of("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031);
-//  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032);
-//  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033);
-//  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = of("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034);
-//  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = of("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037);
-//  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038);
-//  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039);
-//  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = of("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a);
-  public static final CipherSuite TLS_RSA_WITH_NULL_SHA256 = of("TLS_RSA_WITH_NULL_SHA256", 0x003b);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040);
-//  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043);
-//  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044);
-//  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d);
-//  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086);
-//  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087);
-//  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089);
-//  public static final CipherSuite TLS_PSK_WITH_RC4_128_SHA = of("TLS_PSK_WITH_RC4_128_SHA", 0x008a);
-//  public static final CipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b);
-//  public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA = of("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c);
-//  public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA = of("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA = of("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA = of("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095);
-//  public static final CipherSuite TLS_RSA_WITH_SEED_CBC_SHA = of("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096);
-  // public static final CipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA = of("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097);
-  // public static final CipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA = of("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA = of("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA = of("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a);
-  // public static final CipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA = of("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256 = of("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384 = of("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7);
   // public static final CipherSuite TLS_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8);
   // public static final CipherSuite TLS_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9);
   // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa);
@@ -246,22 +133,6 @@
   // public static final CipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020);
   // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021);
   // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032);
   // public static final CipherSuite TLS_ECDHE_PSK_WITH_RC4_128_SHA = of("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033);
   // public static final CipherSuite TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034);
 //  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035);
@@ -387,16 +258,139 @@
   // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad);
   // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae);
   // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af);
+  // public static final CipherSuite TLS_NULL_WITH_NULL_NULL = of("TLS_NULL_WITH_NULL_NULL", 0x0000);
+//  public static final CipherSuite TLS_RSA_WITH_NULL_MD5 = of("SSL_RSA_WITH_NULL_MD5", 0x0001);
+//  public static final CipherSuite TLS_RSA_WITH_NULL_SHA = of("SSL_RSA_WITH_NULL_SHA", 0x0002);
+//  public static final CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003);
+//  public static final CipherSuite TLS_RSA_WITH_RC4_128_MD5 = of("SSL_RSA_WITH_RC4_128_MD5", 0x0004);
+//  public static final CipherSuite TLS_RSA_WITH_RC4_128_SHA = of("SSL_RSA_WITH_RC4_128_SHA", 0x0005);
+  // public static final CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006);
+  // public static final CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = of("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007);
+//  public static final CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008);
+//  public static final CipherSuite TLS_RSA_WITH_DES_CBC_SHA = of("SSL_RSA_WITH_DES_CBC_SHA", 0x0009);
+//  public static final CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a);
+  // public static final CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b);
+  // public static final CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA = of("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c);
+  // public static final CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d);
+  // public static final CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA = of("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010);
+//  public static final CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011);
+//  public static final CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA = of("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012);
+//  public static final CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013);
+//  public static final CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014);
+//  public static final CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA = of("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015);
+//  public static final CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016);
+//  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = of("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017);
+//  public static final CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = of("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018);
+//  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019);
+//  public static final CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA = of("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a);
+//  public static final CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = of("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b);
+//  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_SHA = of("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e);
+//  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA = of("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f);
+//  public static final CipherSuite TLS_KRB5_WITH_RC4_128_SHA = of("TLS_KRB5_WITH_RC4_128_SHA", 0x0020);
+//   public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA = of("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021);
+//  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_MD5 = of("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022);
+//  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = of("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023);
+//  public static final CipherSuite TLS_KRB5_WITH_RC4_128_MD5 = of("TLS_KRB5_WITH_RC4_128_MD5", 0x0024);
+//   public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5 = of("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025);
+//  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026);
+//   public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027);
+//  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028);
+//  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029);
+//   public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a);
+//  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b);
+//   public static final CipherSuite TLS_PSK_WITH_NULL_SHA = of("TLS_PSK_WITH_NULL_SHA", 0x002c);
+//   public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA = of("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA = of("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e);
+//  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = of("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031);
+//  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032);
+//  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033);
+//  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = of("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034);
+//  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = of("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037);
+//  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038);
+//  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039);
+//  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = of("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f);
+  //  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043);
+//  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044);
+//  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069);
+  //  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086);
+//  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087);
+//  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089);
+//  public static final CipherSuite TLS_PSK_WITH_RC4_128_SHA = of("TLS_PSK_WITH_RC4_128_SHA", 0x008a);
+//  public static final CipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b);
+//  public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA = of("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c);
+//  public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA = of("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA = of("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA = of("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095);
+//  public static final CipherSuite TLS_RSA_WITH_SEED_CBC_SHA = of("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096);
+  // public static final CipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA = of("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097);
+  // public static final CipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA = of("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA = of("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA = of("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a);
+  // public static final CipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA = of("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5);
+
+  public static final CipherSuite TLS_RSA_WITH_NULL_SHA256 = of("TLS_RSA_WITH_NULL_SHA256", 0x003b);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256 = of("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384 = of("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032);
   public static final CipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8);
   public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9);
   public static final CipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa);
-  // public static final CipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccab);
   public static final CipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccad);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccae);
-
-  // TLS 1.3 https://tools.ietf.org/html/draft-ietf-tls-tls13-28
-  // Documentation only ids will be updated once assigned by IANA.
   public static final CipherSuite TLS_AES_128_GCM_SHA256 = of("TLS_AES_128_GCM_SHA256", 0x1301);
   public static final CipherSuite TLS_AES_256_GCM_SHA384 = of("TLS_AES_256_GCM_SHA384", 0x1302);
   public static final CipherSuite TLS_CHACHA20_POLY1305_SHA256 = of("TLS_CHACHA20_POLY1305_SHA256", 0x1303);
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
index c7161bacb3..4f98487342 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -19,6 +19,7 @@
 import java.util.List;
 import javax.annotation.Nullable;
 import javax.net.ssl.SSLSocket;
+
 import okhttp3.internal.Util;
 
 import static okhttp3.internal.Util.concat;
@@ -40,313 +41,334 @@
  */
 public final class ConnectionSpec {
 
-  // This cipher suites are compliant to PCI DSS
-  private static final CipherSuite[] PCI_CIPHER_SUITES = new CipherSuite[] {
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
-          CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
-  };
-
-  // Most secure but generally supported list.
-  private static final CipherSuite[] RESTRICTED_CIPHER_SUITES = new CipherSuite[] {
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
-          CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
-  };
-
-  // TLS 1.3
-  private static final CipherSuite[] TLS13_CIPHER_SUITES = new CipherSuite[] {
-          CipherSuite.TLS_AES_128_GCM_SHA256,
-          CipherSuite.TLS_AES_256_GCM_SHA384,
-          CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
-          CipherSuite.TLS_AES_128_CCM_SHA256,
-          CipherSuite.TLS_AES_256_CCM_8_SHA256
-  };
-
-  // This is nearly equal to the cipher suites supported in Chrome 51, current as of 2016-05-25.
-  // All of these suites are available on Android 7.0; earlier releases support a subset of these
-  // suites. https://github.com/square/okhttp/issues/1972
-  private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
-          CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
-          CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
-          CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
-  };
-
-  /**
-   * A TLS 1.3 only Connection Spec for testing. This will be eventually be exposed
-   * as part of MODERN_TLS or folded into the default OkHttp client once published and
-   * available in JDK11.
-   */
-  static final ConnectionSpec TLS_13 = new Builder(true)
-          .cipherSuites(TLS13_CIPHER_SUITES)
-          .tlsVersions(TlsVersion.TLS_1_3)
-          .supportsTlsExtensions(true)
-          .build();
-
-  /** A secure TLS connection assuming a modern client platform and server. */
-  public static final ConnectionSpec RESTRICTED_TLS = new Builder(true)
-          .cipherSuites(RESTRICTED_CIPHER_SUITES)
-          .tlsVersions(TlsVersion.TLS_1_2)
-          .supportsTlsExtensions(true)
-          .build();
-
-  /** A modern TLS connection with extensions like SNI and ALPN available. */
-  public static final ConnectionSpec MODERN_TLS = new Builder(true)
-          .cipherSuites(APPROVED_CIPHER_SUITES)
-          .tlsVersions(TlsVersion.TLS_1_2)
-          .supportsTlsExtensions(true)
-          .build();
-
-  /** A backwards-compatible fallback connection for interop with obsolete servers. */
-  public static final ConnectionSpec COMPATIBLE_TLS = new Builder(MODERN_TLS)
-          .tlsVersions(TlsVersion.TLS_1_0)
-          .supportsTlsExtensions(true)
-          .build();
-
-  /** A modern TLS connection with extensions like SNI and ALPN available. */
-  public static final ConnectionSpec PCI_TLS = new Builder(true)
-          .cipherSuites(PCI_CIPHER_SUITES)
-          .tlsVersions(TlsVersion.TLS_1_2)
-          .supportsTlsExtensions(true)
-          .build();
-
-  /** Unencrypted, unauthenticated connections for {@code http:} URLs. */
-  public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
-
-  final boolean tls;
-  final boolean supportsTlsExtensions;
-  final @Nullable String[] cipherSuites;
-  final @Nullable String[] tlsVersions;
-
-  ConnectionSpec(Builder builder) {
-    this.tls = builder.tls;
-    this.cipherSuites = builder.cipherSuites;
-    this.tlsVersions = builder.tlsVersions;
-    this.supportsTlsExtensions = builder.supportsTlsExtensions;
-  }
-
-  public boolean isTls() {
-    return tls;
-  }
-
-  /**
-   * Returns the cipher suites to use for a connection. Returns null if all of the SSL socket's
-   * enabled cipher suites should be used.
-   */
-  public @Nullable List<CipherSuite> cipherSuites() {
-    return cipherSuites != null ? CipherSuite.forJavaNames(cipherSuites) : null;
-  }
-
-  /**
-   * Returns the TLS versions to use when negotiating a connection. Returns null if all of the SSL
-   * socket's enabled TLS versions should be used.
-   */
-  public @Nullable List<TlsVersion> tlsVersions() {
-    return tlsVersions != null ? TlsVersion.forJavaNames(tlsVersions) : null;
-  }
-
-  public boolean supportsTlsExtensions() {
-    return supportsTlsExtensions;
-  }
-
-  /** Applies this spec to {@code sslSocket}. */
-  void apply(SSLSocket sslSocket, boolean isFallback) {
-    ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);
-
-    if (specToApply.tlsVersions != null) {
-      sslSocket.setEnabledProtocols(specToApply.tlsVersions);
-    }
-    if (specToApply.cipherSuites != null) {
-      sslSocket.setEnabledCipherSuites(specToApply.cipherSuites);
-    }
-  }
-
-  /**
-   * Returns a copy of this that omits cipher suites and TLS versions not enabled by {@code
-   * sslSocket}.
-   */
-  private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
-    String[] cipherSuitesIntersection = cipherSuites != null
-            ? intersect(CipherSuite.ORDER_BY_NAME, sslSocket.getEnabledCipherSuites(), cipherSuites)
-            : sslSocket.getEnabledCipherSuites();
-    String[] tlsVersionsIntersection = tlsVersions != null
-            ? intersect(Util.NATURAL_ORDER, sslSocket.getEnabledProtocols(), tlsVersions)
-            : sslSocket.getEnabledProtocols();
-
-    // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
-    // the SCSV cipher is added to signal that a protocol fallback has taken place.
-    String[] supportedCipherSuites = sslSocket.getSupportedCipherSuites();
-    int indexOfFallbackScsv = indexOf(
-            CipherSuite.ORDER_BY_NAME, supportedCipherSuites, "TLS_FALLBACK_SCSV");
-    if (isFallback && indexOfFallbackScsv != -1) {
-      cipherSuitesIntersection = concat(
-              cipherSuitesIntersection, supportedCipherSuites[indexOfFallbackScsv]);
-    }
-
-    return new Builder(this)
-            .cipherSuites(cipherSuitesIntersection)
-            .tlsVersions(tlsVersionsIntersection)
+    // This cipher suites are compliant to PCI DSS
+    private static final CipherSuite[] PCI_CIPHER_SUITES = new CipherSuite[]{
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+            CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+            CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+            CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
+    };
+
+    // Most secure but generally supported list.
+    private static final CipherSuite[] RESTRICTED_CIPHER_SUITES = new CipherSuite[]{
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+            CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+            CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+            CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
+    };
+
+    // TLS 1.3
+    private static final CipherSuite[] TLS13_CIPHER_SUITES = new CipherSuite[]{
+            CipherSuite.TLS_AES_128_GCM_SHA256,
+            CipherSuite.TLS_AES_256_GCM_SHA384,
+            CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+            CipherSuite.TLS_AES_128_CCM_SHA256,
+            CipherSuite.TLS_AES_256_CCM_8_SHA256
+    };
+
+    // This is nearly equal to the cipher suites supported in Chrome 51, current as of 2016-05-25.
+    // All of these suites are available on Android 7.0; earlier releases support a subset of these
+    // suites. https://github.com/square/okhttp/issues/1972
+    private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[]{
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+            CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+            CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+            CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+            CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
+    };
+
+    /**
+     * A TLS 1.3 only Connection Spec for testing. This will be eventually be exposed
+     * as part of MODERN_TLS or folded into the default OkHttp client once published and
+     * available in JDK11.
+     */
+    static final ConnectionSpec TLS_13 = new Builder(true)
+            .cipherSuites(TLS13_CIPHER_SUITES)
+            .tlsVersions(TlsVersion.TLS_1_3)
+            .supportsTlsExtensions(true)
             .build();
-  }
-
-  /**
-   * Returns {@code true} if the socket, as currently configured, supports this connection spec. In
-   * order for a socket to be compatible the enabled cipher suites and protocols must intersect.
-   *
-   * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
-   * match the socket's enabled cipher suites. If there are no required cipher suites the socket
-   * must have at least one cipher suite enabled.
-   *
-   * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the
-   * socket's enabled protocols.
-   */
-  public boolean isCompatible(SSLSocket socket) {
-    if (!tls) {
-      return false;
-    }
-
-    if (tlsVersions != null && !nonEmptyIntersection(
-            Util.NATURAL_ORDER, tlsVersions, socket.getEnabledProtocols())) {
-      return false;
-    }
 
-    if (cipherSuites != null && !nonEmptyIntersection(
-            CipherSuite.ORDER_BY_NAME, cipherSuites, socket.getEnabledCipherSuites())) {
-      return false;
-    }
+    /**
+     * A secure TLS connection assuming a modern client platform and server.
+     */
+    public static final ConnectionSpec RESTRICTED_TLS = new Builder(true)
+            .cipherSuites(RESTRICTED_CIPHER_SUITES)
+            .tlsVersions(TlsVersion.TLS_1_2)
+            .supportsTlsExtensions(true)
+            .build();
 
-    return true;
-  }
+    /**
+     * A modern TLS connection with extensions like SNI and ALPN available.
+     */
+    public static final ConnectionSpec MODERN_TLS = new Builder(true)
+            .cipherSuites(APPROVED_CIPHER_SUITES)
+            .tlsVersions(TlsVersion.TLS_1_2)
+            .supportsTlsExtensions(true)
+            .build();
 
-  @Override public boolean equals(@Nullable Object other) {
-    if (!(other instanceof ConnectionSpec)) return false;
-    if (other == this) return true;
+    /**
+     * A backwards-compatible fallback connection for interop with obsolete servers.
+     */
+    public static final ConnectionSpec COMPATIBLE_TLS = new Builder(MODERN_TLS)
+            .tlsVersions(TlsVersion.TLS_1_0)
+            .supportsTlsExtensions(true)
+            .build();
 
-    ConnectionSpec that = (ConnectionSpec) other;
-    if (this.tls != that.tls) return false;
+    /**
+     * A modern TLS connection with extensions like SNI and ALPN available.
+     */
+    public static final ConnectionSpec PCI_TLS = new Builder(true)
+            .cipherSuites(PCI_CIPHER_SUITES)
+            .tlsVersions(TlsVersion.TLS_1_2)
+            .supportsTlsExtensions(true)
+            .build();
 
-    if (tls) {
-      if (!Arrays.equals(this.cipherSuites, that.cipherSuites)) return false;
-      if (!Arrays.equals(this.tlsVersions, that.tlsVersions)) return false;
-      if (this.supportsTlsExtensions != that.supportsTlsExtensions) return false;
+    /**
+     * Unencrypted, unauthenticated connections for {@code http:} URLs.
+     */
+    public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
+
+    final boolean tls;
+    final boolean supportsTlsExtensions;
+    final @Nullable
+    String[] cipherSuites;
+    final @Nullable
+    String[] tlsVersions;
+
+    ConnectionSpec(Builder builder) {
+        this.tls = builder.tls;
+        this.cipherSuites = builder.cipherSuites;
+        this.tlsVersions = builder.tlsVersions;
+        this.supportsTlsExtensions = builder.supportsTlsExtensions;
     }
 
-    return true;
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    if (tls) {
-      result = 31 * result + Arrays.hashCode(cipherSuites);
-      result = 31 * result + Arrays.hashCode(tlsVersions);
-      result = 31 * result + (supportsTlsExtensions ? 0 : 1);
+    public boolean isTls() {
+        return tls;
     }
-    return result;
-  }
 
-  @Override public String toString() {
-    if (!tls) {
-      return "ConnectionSpec()";
+    /**
+     * Returns the cipher suites to use for a connection. Returns null if all of the SSL socket's
+     * enabled cipher suites should be used.
+     */
+    public @Nullable
+    List<CipherSuite> cipherSuites() {
+        return cipherSuites != null ? CipherSuite.forJavaNames(cipherSuites) : null;
     }
 
-    String cipherSuitesString = cipherSuites != null ? cipherSuites().toString() : "[all enabled]";
-    String tlsVersionsString = tlsVersions != null ? tlsVersions().toString() : "[all enabled]";
-    return "ConnectionSpec("
-            + "cipherSuites=" + cipherSuitesString
-            + ", tlsVersions=" + tlsVersionsString
-            + ", supportsTlsExtensions=" + supportsTlsExtensions
-            + ")";
-  }
-
-  public static final class Builder {
-    boolean tls;
-    @Nullable String[] cipherSuites;
-    @Nullable String[] tlsVersions;
-    boolean supportsTlsExtensions;
-
-    Builder(boolean tls) {
-      this.tls = tls;
+    /**
+     * Returns the TLS versions to use when negotiating a connection. Returns null if all of the SSL
+     * socket's enabled TLS versions should be used.
+     */
+    public @Nullable
+    List<TlsVersion> tlsVersions() {
+        return tlsVersions != null ? TlsVersion.forJavaNames(tlsVersions) : null;
     }
 
-    public Builder(ConnectionSpec connectionSpec) {
-      this.tls = connectionSpec.tls;
-      this.cipherSuites = connectionSpec.cipherSuites;
-      this.tlsVersions = connectionSpec.tlsVersions;
-      this.supportsTlsExtensions = connectionSpec.supportsTlsExtensions;
+    public boolean supportsTlsExtensions() {
+        return supportsTlsExtensions;
     }
 
-    public Builder allEnabledCipherSuites() {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
-      this.cipherSuites = null;
-      return this;
+    /**
+     * Applies this spec to {@code sslSocket}.
+     */
+    void apply(SSLSocket sslSocket, boolean isFallback) {
+        ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);
+
+        if (specToApply.tlsVersions != null) {
+            sslSocket.setEnabledProtocols(specToApply.tlsVersions);
+        }
+        if (specToApply.cipherSuites != null) {
+            sslSocket.setEnabledCipherSuites(specToApply.cipherSuites);
+        }
     }
 
-    public Builder cipherSuites(CipherSuite... cipherSuites) {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
-
-      String[] strings = new String[cipherSuites.length];
-      for (int i = 0; i < cipherSuites.length; i++) {
-        strings[i] = cipherSuites[i].javaName;
-      }
-      return cipherSuites(strings);
+    /**
+     * Returns a copy of this that omits cipher suites and TLS versions not enabled by {@code
+     * sslSocket}.
+     */
+    private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
+        String[] cipherSuitesIntersection = cipherSuites != null
+                ? intersect(CipherSuite.ORDER_BY_NAME, sslSocket.getEnabledCipherSuites(), cipherSuites)
+                : sslSocket.getEnabledCipherSuites();
+        String[] tlsVersionsIntersection = tlsVersions != null
+                ? intersect(Util.NATURAL_ORDER, sslSocket.getEnabledProtocols(), tlsVersions)
+                : sslSocket.getEnabledProtocols();
+
+        // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
+        // the SCSV cipher is added to signal that a protocol fallback has taken place.
+        String[] supportedCipherSuites = sslSocket.getSupportedCipherSuites();
+        int indexOfFallbackScsv = indexOf(
+                CipherSuite.ORDER_BY_NAME, supportedCipherSuites, "TLS_FALLBACK_SCSV");
+        if (isFallback && indexOfFallbackScsv != -1) {
+            cipherSuitesIntersection = concat(
+                    cipherSuitesIntersection, supportedCipherSuites[indexOfFallbackScsv]);
+        }
+
+        return new Builder(this)
+                .cipherSuites(cipherSuitesIntersection)
+                .tlsVersions(tlsVersionsIntersection)
+                .build();
     }
 
-    public Builder cipherSuites(String... cipherSuites) {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
-
-      if (cipherSuites.length == 0) {
-        throw new IllegalArgumentException("At least one cipher suite is required");
-      }
-
-      this.cipherSuites = cipherSuites.clone(); // Defensive copy.
-      return this;
+    /**
+     * Returns {@code true} if the socket, as currently configured, supports this connection spec. In
+     * order for a socket to be compatible the enabled cipher suites and protocols must intersect.
+     *
+     * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
+     * match the socket's enabled cipher suites. If there are no required cipher suites the socket
+     * must have at least one cipher suite enabled.
+     *
+     * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the
+     * socket's enabled protocols.
+     */
+    public boolean isCompatible(SSLSocket socket) {
+        if (!tls) {
+            return false;
+        }
+
+        if (tlsVersions != null && !nonEmptyIntersection(
+                Util.NATURAL_ORDER, tlsVersions, socket.getEnabledProtocols())) {
+            return false;
+        }
+
+        if (cipherSuites != null && !nonEmptyIntersection(
+                CipherSuite.ORDER_BY_NAME, cipherSuites, socket.getEnabledCipherSuites())) {
+            return false;
+        }
+
+        return true;
     }
 
-    public Builder allEnabledTlsVersions() {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
-      this.tlsVersions = null;
-      return this;
-    }
+    @Override
+    public boolean equals(@Nullable Object other) {
+        if (!(other instanceof ConnectionSpec)) return false;
+        if (other == this) return true;
 
-    public Builder tlsVersions(TlsVersion... tlsVersions) {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+        ConnectionSpec that = (ConnectionSpec) other;
+        if (this.tls != that.tls) return false;
 
-      String[] strings = new String[tlsVersions.length];
-      for (int i = 0; i < tlsVersions.length; i++) {
-        strings[i] = tlsVersions[i].javaName;
-      }
+        if (tls) {
+            if (!Arrays.equals(this.cipherSuites, that.cipherSuites)) return false;
+            if (!Arrays.equals(this.tlsVersions, that.tlsVersions)) return false;
+            if (this.supportsTlsExtensions != that.supportsTlsExtensions) return false;
+        }
 
-      return tlsVersions(strings);
+        return true;
     }
 
-    public Builder tlsVersions(String... tlsVersions) {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
-
-      if (tlsVersions.length == 0) {
-        throw new IllegalArgumentException("At least one TLS version is required");
-      }
-
-      this.tlsVersions = tlsVersions.clone(); // Defensive copy.
-      return this;
+    public String hash256() {
+        String result = "";
+        if (tls) {
+            result = result + Util.hash256(cipherSuites);
+            result = result + Util.hash256(tlsVersions);
+            result = result + Util.hash256(supportsTlsExtensions ? 0 : 1);
+            return Util.hash256(result);
+        }
+        return "";
     }
 
-    public Builder supportsTlsExtensions(boolean supportsTlsExtensions) {
-      if (!tls) throw new IllegalStateException("no TLS extensions for cleartext connections");
-      this.supportsTlsExtensions = supportsTlsExtensions;
-      return this;
+    @Override
+    public String toString() {
+        if (!tls) {
+            return "ConnectionSpec()";
+        }
+
+        String cipherSuitesString = cipherSuites != null ? cipherSuites().toString() : "[all enabled]";
+        String tlsVersionsString = tlsVersions != null ? tlsVersions().toString() : "[all enabled]";
+        return "ConnectionSpec("
+                + "cipherSuites=" + cipherSuitesString
+                + ", tlsVersions=" + tlsVersionsString
+                + ", supportsTlsExtensions=" + supportsTlsExtensions
+                + ")";
     }
 
-    public ConnectionSpec build() {
-      return new ConnectionSpec(this);
+    public static final class Builder {
+        boolean tls;
+        @Nullable
+        String[] cipherSuites;
+        @Nullable
+        String[] tlsVersions;
+        boolean supportsTlsExtensions;
+
+        Builder(boolean tls) {
+            this.tls = tls;
+        }
+
+        public Builder(ConnectionSpec connectionSpec) {
+            this.tls = connectionSpec.tls;
+            this.cipherSuites = connectionSpec.cipherSuites;
+            this.tlsVersions = connectionSpec.tlsVersions;
+            this.supportsTlsExtensions = connectionSpec.supportsTlsExtensions;
+        }
+
+        public Builder allEnabledCipherSuites() {
+            if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+            this.cipherSuites = null;
+            return this;
+        }
+
+        public Builder cipherSuites(CipherSuite... cipherSuites) {
+            if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+
+            String[] strings = new String[cipherSuites.length];
+            for (int i = 0; i < cipherSuites.length; i++) {
+                strings[i] = cipherSuites[i].javaName;
+            }
+            return cipherSuites(strings);
+        }
+
+        public Builder cipherSuites(String... cipherSuites) {
+            if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+
+            if (cipherSuites.length == 0) {
+                throw new IllegalArgumentException("At least one cipher suite is required");
+            }
+
+            this.cipherSuites = cipherSuites.clone(); // Defensive copy.
+            return this;
+        }
+
+        public Builder allEnabledTlsVersions() {
+            if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+            this.tlsVersions = null;
+            return this;
+        }
+
+        public Builder tlsVersions(TlsVersion... tlsVersions) {
+            if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+
+            String[] strings = new String[tlsVersions.length];
+            for (int i = 0; i < tlsVersions.length; i++) {
+                strings[i] = tlsVersions[i].javaName;
+            }
+
+            return tlsVersions(strings);
+        }
+
+        public Builder tlsVersions(String... tlsVersions) {
+            if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+
+            if (tlsVersions.length == 0) {
+                throw new IllegalArgumentException("At least one TLS version is required");
+            }
+
+            this.tlsVersions = tlsVersions.clone(); // Defensive copy.
+            return this;
+        }
+
+        public Builder supportsTlsExtensions(boolean supportsTlsExtensions) {
+            if (!tls) throw new IllegalStateException("no TLS extensions for cleartext connections");
+            this.supportsTlsExtensions = supportsTlsExtensions;
+            return this;
+        }
+
+        public ConnectionSpec build() {
+            return new ConnectionSpec(this);
+        }
     }
-  }
 }
\ No newline at end of file
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
index fbfa99c26d..a490cf5cb9 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -596,17 +596,22 @@ String toString(boolean forObsoleteRfc2965) {
         && that.hostOnly == hostOnly;
   }
 
-  @Override public int hashCode() {
-    int hash = 17;
-    hash = 31 * hash + name.hashCode();
-    hash = 31 * hash + value.hashCode();
-    hash = 31 * hash + domain.hashCode();
-    hash = 31 * hash + path.hashCode();
-    hash = 31 * hash + (int) (expiresAt ^ (expiresAt >>> 32));
-    hash = 31 * hash + (secure ? 0 : 1);
-    hash = 31 * hash + (httpOnly ? 0 : 1);
-    hash = 31 * hash + (persistent ? 0 : 1);
-    hash = 31 * hash + (hostOnly ? 0 : 1);
-    return hash;
+  public String hash256() {
+
+    String hash = "";
+
+    hash = hash + Util.hash256(name);
+    hash = hash + Util.hash256(value);
+    hash = hash + Util.hash256(domain);
+    hash = hash + Util.hash256(path);
+    hash = hash + Util.hash256(expiresAt ^ (expiresAt >>> 32));
+    hash = hash + Util.hash256(secure ? 0 : 1);
+    hash = hash + Util.hash256(httpOnly ? 0 : 1);
+    hash = hash + Util.hash256(persistent ? 0 : 1);
+    hash = hash + Util.hash256(hostOnly ? 0 : 1);
+
+    return Util.hash256(hash);
+
   }
+
 }
diff --git a/okhttp/src/main/java/okhttp3/Handshake.java b/okhttp/src/main/java/okhttp3/Handshake.java
index fefe3a5728..5ca443b8c0 100644
--- a/okhttp/src/main/java/okhttp3/Handshake.java
+++ b/okhttp/src/main/java/okhttp3/Handshake.java
@@ -132,12 +132,16 @@ public CipherSuite cipherSuite() {
         && localCertificates.equals(that.localCertificates);
   }
 
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + tlsVersion.hashCode();
-    result = 31 * result + cipherSuite.hashCode();
-    result = 31 * result + peerCertificates.hashCode();
-    result = 31 * result + localCertificates.hashCode();
-    return result;
+  public String hash256() {
+
+    String result = "";
+
+    result = result + Util.hash256(tlsVersion);
+    result = result + Util.hash256(cipherSuite);
+    result = result + Util.hash256(peerCertificates);
+    result = result + Util.hash256(localCertificates);
+
+    return result + Util.hash256(result);
   }
+
 }
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index e8a0def658..9976508f0f 100644
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -164,8 +164,9 @@ public Builder newBuilder() {
         && Arrays.equals(((Headers) other).namesAndValues, namesAndValues);
   }
 
-  @Override public int hashCode() {
-    return Arrays.hashCode(namesAndValues);
+  public String hash256() {
+    return Util.hash256(namesAndValues);
+    //return Arrays.hashCode(namesAndValues);
   }
 
   @Override public String toString() {
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index f88dfb6eb3..d9996b463a 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -932,8 +932,8 @@ public static HttpUrl get(String url) {
     return other instanceof HttpUrl && ((HttpUrl) other).url.equals(url);
   }
 
-  @Override public int hashCode() {
-    return url.hashCode();
+  public String hash256() {
+    return Util.hash256(url);
   }
 
   @Override public String toString() {
diff --git a/okhttp/src/main/java/okhttp3/MediaType.java b/okhttp/src/main/java/okhttp3/MediaType.java
index ddbd8fcb16..57960c2150 100644
--- a/okhttp/src/main/java/okhttp3/MediaType.java
+++ b/okhttp/src/main/java/okhttp3/MediaType.java
@@ -15,6 +15,8 @@
  */
 package okhttp3;
 
+import okhttp3.internal.Util;
+
 import java.nio.charset.Charset;
 import java.util.Locale;
 import java.util.regex.Matcher;
@@ -155,7 +157,7 @@ public String subtype() {
     return other instanceof MediaType && ((MediaType) other).mediaType.equals(mediaType);
   }
 
-  @Override public int hashCode() {
-    return mediaType.hashCode();
+  public String hash256() {
+    return Util.hash256(mediaType);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 2c678e23f0..a97bfe406e 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -19,10 +19,10 @@
 import java.net.ProxySelector;
 import java.net.Socket;
 import java.security.GeneralSecurityException;
+import java.security.SecureRandom;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
-import java.util.Random;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
 import javax.annotation.Nullable;
@@ -417,7 +417,7 @@ public Dispatcher dispatcher() {
    * Uses {@code request} to connect a new web socket.
    */
   @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {
-    RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval);
+    RealWebSocket webSocket = new RealWebSocket(request, listener, new SecureRandom(), pingInterval);
     webSocket.connect(this);
     return webSocket;
   }
diff --git a/okhttp/src/main/java/okhttp3/Route.java b/okhttp/src/main/java/okhttp3/Route.java
index 14158673ca..2126b1a81a 100644
--- a/okhttp/src/main/java/okhttp3/Route.java
+++ b/okhttp/src/main/java/okhttp3/Route.java
@@ -15,6 +15,8 @@
  */
 package okhttp3;
 
+import okhttp3.internal.Util;
+
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 import javax.annotation.Nullable;
@@ -87,12 +89,15 @@ public boolean requiresTunnel() {
         && ((Route) other).inetSocketAddress.equals(inetSocketAddress);
   }
 
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + address.hashCode();
-    result = 31 * result + proxy.hashCode();
-    result = 31 * result + inetSocketAddress.hashCode();
-    return result;
+  public String hash256() {
+    String result = "";
+
+    result = result + address.hash256();
+    result = result + Util.hash256(proxy);
+    result = result + Util.hash256(inetSocketAddress);
+
+    return Util.hash256(result);
+
   }
 
   @Override public String toString() {
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 6f8a4146b1..901325fd1e 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -15,9 +15,7 @@
  */
 package okhttp3.internal;
 
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InterruptedIOException;
+import java.io.*;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.net.IDN;
@@ -28,6 +26,8 @@
 import java.nio.charset.Charset;
 import java.security.GeneralSecurityException;
 import java.security.KeyStore;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -672,4 +672,73 @@ public static X509TrustManager platformTrustManager() {
       throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
     }
   }
+
+  public static String hash256(String message) {
+
+    try {
+      MessageDigest md = MessageDigest.getInstance("SHA-512");
+      byte[] digest = md.digest(message.getBytes());
+      StringBuilder sb = new StringBuilder();
+      for (int i = 0; i < digest.length; i++) {
+        sb.append(Integer.toString((digest[i] & 0xff) + 0x100, 16).substring(1));
+      }
+
+      return sb.toString();
+    } catch (NoSuchAlgorithmException ex) {
+      return "";
+    } catch (Exception ex) {
+      return "";
+    }
+
+  }
+
+  public static String hash256(Object message) {
+
+    try {
+      MessageDigest md = MessageDigest.getInstance("SHA-512");
+      byte[] bytes = objectGetBytes(message);
+
+      if(bytes == null)
+        return "";
+
+      byte[] digest = md.digest(bytes);
+      StringBuilder sb = new StringBuilder();
+      for (int i = 0; i < digest.length; i++) {
+        sb.append(Integer.toString((digest[i] & 0xff) + 0x100, 16).substring(1));
+      }
+
+      return sb.toString();
+    } catch (NoSuchAlgorithmException ex) {
+      return "";
+    } catch (Exception ex) {
+      return "";
+    }
+
+  }
+
+  private static byte[] objectGetBytes(Object object) {
+
+    ByteArrayOutputStream bos = new ByteArrayOutputStream();
+    ObjectOutput out = null;
+    byte[] resultBytes = null;
+
+    try {
+      out = new ObjectOutputStream(bos);
+      out.writeObject(object);
+      out.flush();
+
+      resultBytes = bos.toByteArray();
+    }catch (Exception ex) {
+
+    } finally {
+      try {
+        bos.close();
+      } catch (IOException ex) {
+        // ignore close exception
+      }
+    }
+
+    return resultBytes;
+
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
index 092dc5775e..a479838c2d 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -19,10 +19,10 @@
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.net.SocketTimeoutException;
+import java.security.SecureRandom;
 import java.util.ArrayDeque;
 import java.util.Collections;
 import java.util.List;
-import java.util.Random;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
@@ -72,7 +72,7 @@
   private final Request originalRequest;
 
   final WebSocketListener listener;
-  private final Random random;
+  private final SecureRandom random;
   private final long pingIntervalMillis;
   private final String key;
 
@@ -139,7 +139,7 @@
   /** True if we have sent a ping that is still awaiting a reply. */
   private boolean awaitingPong;
 
-  public RealWebSocket(Request request, WebSocketListener listener, Random random,
+  public RealWebSocket(Request request, WebSocketListener listener, SecureRandom random,
       long pingIntervalMillis) {
     if (!"GET".equals(request.method())) {
       throw new IllegalArgumentException("Request must be GET: " + request.method());
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
index baffe06b19..4749b32e7f 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -16,7 +16,8 @@
 package okhttp3.internal.ws;
 
 import java.io.IOException;
-import java.util.Random;
+import java.security.SecureRandom;
+
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
@@ -43,7 +44,7 @@
  */
 final class WebSocketWriter {
   final boolean isClient;
-  final Random random;
+  final SecureRandom random;
 
   final BufferedSink sink;
   /** The {@link Buffer} of {@link #sink}. Write to this and then flush/emit {@link #sink}. */
@@ -58,7 +59,7 @@
   private final byte[] maskKey;
   private final Buffer.UnsafeCursor maskCursor;
 
-  WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
+  WebSocketWriter(boolean isClient, BufferedSink sink, SecureRandom random) {
     if (sink == null) throw new NullPointerException("sink == null");
     if (random == null) throw new NullPointerException("random == null");
     this.isClient = isClient;
