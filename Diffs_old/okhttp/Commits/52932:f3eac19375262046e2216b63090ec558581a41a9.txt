diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index 41cd07ff2c..ee6565f759 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -129,6 +129,10 @@ public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
     this.idleCallback = idleCallback;
   }
 
+  /**
+   * 分发异步请求，添加到自定义的线程池中执行
+   * @param call
+   */
   synchronized void enqueue(AsyncCall call) {
     if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
       runningAsyncCalls.add(call);
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index afb388a748..ab073844eb 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -455,11 +455,11 @@ public Builder newBuilder() {
     int pingInterval;
 
     public Builder() {
-      dispatcher = new Dispatcher();
-      protocols = DEFAULT_PROTOCOLS;
-      connectionSpecs = DEFAULT_CONNECTION_SPECS;
+      dispatcher = new Dispatcher();//默认分发器
+      protocols = DEFAULT_PROTOCOLS;//默认协议
+      connectionSpecs = DEFAULT_CONNECTION_SPECS;//
       eventListenerFactory = EventListener.factory(EventListener.NONE);
-      proxySelector = ProxySelector.getDefault();
+      proxySelector = ProxySelector.getDefault();//默认代理选择
       cookieJar = CookieJar.NO_COOKIES;
       socketFactory = SocketFactory.getDefault();
       hostnameVerifier = OkHostnameVerifier.INSTANCE;
@@ -471,8 +471,8 @@ public Builder() {
       followSslRedirects = true;
       followRedirects = true;
       retryOnConnectionFailure = true;
-      connectTimeout = 10_000;
-      readTimeout = 10_000;
+      connectTimeout = 10_000;//默认连接超时时间10s
+      readTimeout = 10_000;//读取超时时间10s
       writeTimeout = 10_000;
       pingInterval = 0;
     }
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 84e6b66a8d..58285e6c86 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -30,6 +30,10 @@
 
 import static okhttp3.internal.platform.Platform.INFO;
 
+/**
+ * 通过建造者模式创建完成HttpClient和Request，将构建的Request转换为Call，在RealCall中进行异步或同步任务；
+ * 最后通过拦截器进行处理；
+ */
 final class RealCall implements Call {
   final OkHttpClient client;
   final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
@@ -67,6 +71,11 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
     return originalRequest;
   }
 
+  /**
+   * 同步请求
+   * @return
+   * @throws IOException
+   */
   @Override public Response execute() throws IOException {
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already Executed");
@@ -96,6 +105,10 @@ private void captureCallStackTrace() {
     retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
   }
 
+  /**
+   * 异步请求
+   * @param responseCallback
+   */
   @Override public void enqueue(Callback responseCallback) {
     //确保线程安全的情况下通过executed来保证每个Call只被执行一次
     synchronized (this) {
@@ -128,6 +141,10 @@ StreamAllocation streamAllocation() {
     return retryAndFollowUpInterceptor.streamAllocation();
   }
 
+  /**
+   * 异步请求
+   * execute()同样执行了getResponseWithInterceptorChain()，这样异步任务也会通过 interceptor
+   */
   final class AsyncCall extends NamedRunnable {
     private final Callback responseCallback;
 
@@ -187,6 +204,18 @@ String redactedUrl() {
     return originalRequest.url().redact();
   }
 
+  /**
+   * 拦截器的链调用流程下（向下）
+   *  自定义Interceptor(修饰原始的Request)
+   *  RetryAndFollowUpInterceptor
+   *  BridgeInterceptor
+   *  CacheInterceptor
+   *  ConnnectInterceptor
+   *  自定义NetWorkInterceptors
+   *  CallServerInterceptor
+   *
+   *  Response返回(向上)
+   */
   Response getResponseWithInterceptorChain() throws IOException {
     // Build a full stack of interceptors.
     List<Interceptor> interceptors = new ArrayList<>();
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index 62531aa514..abdd69aed6 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -37,9 +37,16 @@ public CallServerInterceptor(boolean forWebSocket) {
     this.forWebSocket = forWebSocket;
   }
 
+  /**
+   * 调用HttpCodec完成最终的请求
+   * @param chain
+   * @return 执行完成后 并没有调用RealIntercept的intercept方法，而是逆向返回response对象
+   * @throws IOException
+   */
   @Override public Response intercept(Chain chain) throws IOException {
     RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    HttpCodec httpCodec = realChain.httpStream();
+    //Okhttp1Codec okhttp2Codec实现了它，对应这个http1 http2.x的请求
+    HttpCodec httpCodec = realChain.httpStream();//codec内部的请求 都依赖于okio(对Socket的封装 )
     StreamAllocation streamAllocation = realChain.streamAllocation();
     RealConnection connection = (RealConnection) realChain.connection();
     Request request = realChain.request();
