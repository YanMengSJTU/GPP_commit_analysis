diff --git a/fuzzing/fuzzingserver-config.json b/fuzzing/fuzzingserver-config.json
deleted file mode 100644
index f9a3e1f597..0000000000
--- a/fuzzing/fuzzingserver-config.json
+++ /dev/null
@@ -1,153 +0,0 @@
-{
-  "url": "ws://127.0.0.1:9099",
-  "outdir": "./target/fuzzingserver-report",
-  "cases": ["*"],
-  "exclude-cases": [
-    "6.1.1",
-    "6.1.2",
-    "6.1.3",
-    "6.2.1",
-    "6.2.2",
-    "6.2.3",
-    "6.2.4",
-    "6.3.1",
-    "6.3.2",
-    "6.4.1",
-    "6.4.2",
-    "6.4.3",
-    "6.4.4",
-    "6.5.1",
-    "6.5.2",
-    "6.5.3",
-    "6.5.4",
-    "6.5.5",
-    "6.6.1",
-    "6.6.2",
-    "6.6.3",
-    "6.6.4",
-    "6.6.5",
-    "6.6.6",
-    "6.6.7",
-    "6.6.8",
-    "6.6.9",
-    "6.6.10",
-    "6.6.11",
-    "6.7.1",
-    "6.7.2",
-    "6.7.3",
-    "6.7.4",
-    "6.8.1",
-    "6.8.2",
-    "6.9.1",
-    "6.9.2",
-    "6.9.3",
-    "6.9.4",
-    "6.10.1",
-    "6.10.2",
-    "6.10.3",
-    "6.11.1",
-    "6.11.2",
-    "6.11.3",
-    "6.11.4",
-    "6.11.5",
-    "6.12.1",
-    "6.12.2",
-    "6.12.3",
-    "6.12.4",
-    "6.12.5",
-    "6.12.6",
-    "6.12.7",
-    "6.12.8",
-    "6.13.1",
-    "6.13.2",
-    "6.13.3",
-    "6.13.4",
-    "6.13.5",
-    "6.14.1",
-    "6.14.2",
-    "6.14.3",
-    "6.14.4",
-    "6.14.5",
-    "6.14.6",
-    "6.14.7",
-    "6.14.8",
-    "6.14.9",
-    "6.14.10",
-    "6.15.1",
-    "6.16.1",
-    "6.16.2",
-    "6.16.3",
-    "6.17.1",
-    "6.17.2",
-    "6.17.3",
-    "6.17.4",
-    "6.17.5",
-    "6.18.1",
-    "6.18.2",
-    "6.18.3",
-    "6.18.4",
-    "6.18.5",
-    "6.19.1",
-    "6.19.2",
-    "6.19.3",
-    "6.19.4",
-    "6.19.5",
-    "6.20.1",
-    "6.20.2",
-    "6.20.3",
-    "6.20.4",
-    "6.20.5",
-    "6.20.6",
-    "6.20.7",
-    "6.21.1",
-    "6.21.2",
-    "6.21.3",
-    "6.21.4",
-    "6.21.5",
-    "6.21.6",
-    "6.21.7",
-    "6.21.8",
-    "6.22.1",
-    "6.22.2",
-    "6.22.3",
-    "6.22.4",
-    "6.22.5",
-    "6.22.6",
-    "6.22.7",
-    "6.22.8",
-    "6.22.9",
-    "6.22.10",
-    "6.22.11",
-    "6.22.12",
-    "6.22.13",
-    "6.22.14",
-    "6.22.15",
-    "6.22.16",
-    "6.22.17",
-    "6.22.18",
-    "6.22.19",
-    "6.22.20",
-    "6.22.21",
-    "6.22.22",
-    "6.22.23",
-    "6.22.24",
-    "6.22.25",
-    "6.22.26",
-    "6.22.27",
-    "6.22.28",
-    "6.22.29",
-    "6.22.30",
-    "6.22.31",
-    "6.22.32",
-    "6.22.33",
-    "6.22.34",
-    "6.23.1",
-    "6.23.2",
-    "6.23.3",
-    "6.23.4",
-    "6.23.5",
-    "6.23.6",
-    "6.23.7"
-  ],
-  "exclude-agent-cases": {}
-}
diff --git a/fuzzing/fuzzingserver-expected.txt b/fuzzing/fuzzingserver-expected.txt
deleted file mode 100644
index f0f6ed0bbd..0000000000
--- a/fuzzing/fuzzingserver-expected.txt
+++ /dev/null
@@ -1,376 +0,0 @@
-"1.1.1 OK"
-"1.1.2 OK"
-"1.1.3 OK"
-"1.1.4 OK"
-"1.1.5 OK"
-"1.1.6 OK"
-"1.1.7 OK"
-"1.1.8 OK"
-"1.2.1 OK"
-"1.2.2 OK"
-"1.2.3 OK"
-"1.2.4 OK"
-"1.2.5 OK"
-"1.2.6 OK"
-"1.2.7 OK"
-"1.2.8 OK"
-"10.1.1 OK"
-"12.1.1 UNIMPLEMENTED"
-"12.1.10 UNIMPLEMENTED"
-"12.1.11 UNIMPLEMENTED"
-"12.1.12 UNIMPLEMENTED"
-"12.1.13 UNIMPLEMENTED"
-"12.1.14 UNIMPLEMENTED"
-"12.1.15 UNIMPLEMENTED"
-"12.1.16 UNIMPLEMENTED"
-"12.1.17 UNIMPLEMENTED"
-"12.1.18 UNIMPLEMENTED"
-"12.1.2 UNIMPLEMENTED"
-"12.1.3 UNIMPLEMENTED"
-"12.1.4 UNIMPLEMENTED"
-"12.1.5 UNIMPLEMENTED"
-"12.1.6 UNIMPLEMENTED"
-"12.1.7 UNIMPLEMENTED"
-"12.1.8 UNIMPLEMENTED"
-"12.1.9 UNIMPLEMENTED"
-"12.2.1 UNIMPLEMENTED"
-"12.2.10 UNIMPLEMENTED"
-"12.2.11 UNIMPLEMENTED"
-"12.2.12 UNIMPLEMENTED"
-"12.2.13 UNIMPLEMENTED"
-"12.2.14 UNIMPLEMENTED"
-"12.2.15 UNIMPLEMENTED"
-"12.2.16 UNIMPLEMENTED"
-"12.2.17 UNIMPLEMENTED"
-"12.2.18 UNIMPLEMENTED"
-"12.2.2 UNIMPLEMENTED"
-"12.2.3 UNIMPLEMENTED"
-"12.2.4 UNIMPLEMENTED"
-"12.2.5 UNIMPLEMENTED"
-"12.2.6 UNIMPLEMENTED"
-"12.2.7 UNIMPLEMENTED"
-"12.2.8 UNIMPLEMENTED"
-"12.2.9 UNIMPLEMENTED"
-"12.3.1 UNIMPLEMENTED"
-"12.3.10 UNIMPLEMENTED"
-"12.3.11 UNIMPLEMENTED"
-"12.3.12 UNIMPLEMENTED"
-"12.3.13 UNIMPLEMENTED"
-"12.3.14 UNIMPLEMENTED"
-"12.3.15 UNIMPLEMENTED"
-"12.3.16 UNIMPLEMENTED"
-"12.3.17 UNIMPLEMENTED"
-"12.3.18 UNIMPLEMENTED"
-"12.3.2 UNIMPLEMENTED"
-"12.3.3 UNIMPLEMENTED"
-"12.3.4 UNIMPLEMENTED"
-"12.3.5 UNIMPLEMENTED"
-"12.3.6 UNIMPLEMENTED"
-"12.3.7 UNIMPLEMENTED"
-"12.3.8 UNIMPLEMENTED"
-"12.3.9 UNIMPLEMENTED"
-"12.4.1 UNIMPLEMENTED"
-"12.4.10 UNIMPLEMENTED"
-"12.4.11 UNIMPLEMENTED"
-"12.4.12 UNIMPLEMENTED"
-"12.4.13 UNIMPLEMENTED"
-"12.4.14 UNIMPLEMENTED"
-"12.4.15 UNIMPLEMENTED"
-"12.4.16 UNIMPLEMENTED"
-"12.4.17 UNIMPLEMENTED"
-"12.4.18 UNIMPLEMENTED"
-"12.4.2 UNIMPLEMENTED"
-"12.4.3 UNIMPLEMENTED"
-"12.4.4 UNIMPLEMENTED"
-"12.4.5 UNIMPLEMENTED"
-"12.4.6 UNIMPLEMENTED"
-"12.4.7 UNIMPLEMENTED"
-"12.4.8 UNIMPLEMENTED"
-"12.4.9 UNIMPLEMENTED"
-"12.5.1 UNIMPLEMENTED"
-"12.5.10 UNIMPLEMENTED"
-"12.5.11 UNIMPLEMENTED"
-"12.5.12 UNIMPLEMENTED"
-"12.5.13 UNIMPLEMENTED"
-"12.5.14 UNIMPLEMENTED"
-"12.5.15 UNIMPLEMENTED"
-"12.5.16 UNIMPLEMENTED"
-"12.5.17 UNIMPLEMENTED"
-"12.5.18 UNIMPLEMENTED"
-"12.5.2 UNIMPLEMENTED"
-"12.5.3 UNIMPLEMENTED"
-"12.5.4 UNIMPLEMENTED"
-"12.5.5 UNIMPLEMENTED"
-"12.5.6 UNIMPLEMENTED"
-"12.5.7 UNIMPLEMENTED"
-"12.5.8 UNIMPLEMENTED"
-"12.5.9 UNIMPLEMENTED"
-"13.1.1 UNIMPLEMENTED"
-"13.1.10 UNIMPLEMENTED"
-"13.1.11 UNIMPLEMENTED"
-"13.1.12 UNIMPLEMENTED"
-"13.1.13 UNIMPLEMENTED"
-"13.1.14 UNIMPLEMENTED"
-"13.1.15 UNIMPLEMENTED"
-"13.1.16 UNIMPLEMENTED"
-"13.1.17 UNIMPLEMENTED"
-"13.1.18 UNIMPLEMENTED"
-"13.1.2 UNIMPLEMENTED"
-"13.1.3 UNIMPLEMENTED"
-"13.1.4 UNIMPLEMENTED"
-"13.1.5 UNIMPLEMENTED"
-"13.1.6 UNIMPLEMENTED"
-"13.1.7 UNIMPLEMENTED"
-"13.1.8 UNIMPLEMENTED"
-"13.1.9 UNIMPLEMENTED"
-"13.2.1 UNIMPLEMENTED"
-"13.2.10 UNIMPLEMENTED"
-"13.2.11 UNIMPLEMENTED"
-"13.2.12 UNIMPLEMENTED"
-"13.2.13 UNIMPLEMENTED"
-"13.2.14 UNIMPLEMENTED"
-"13.2.15 UNIMPLEMENTED"
-"13.2.16 UNIMPLEMENTED"
-"13.2.17 UNIMPLEMENTED"
-"13.2.18 UNIMPLEMENTED"
-"13.2.2 UNIMPLEMENTED"
-"13.2.3 UNIMPLEMENTED"
-"13.2.4 UNIMPLEMENTED"
-"13.2.5 UNIMPLEMENTED"
-"13.2.6 UNIMPLEMENTED"
-"13.2.7 UNIMPLEMENTED"
-"13.2.8 UNIMPLEMENTED"
-"13.2.9 UNIMPLEMENTED"
-"13.3.1 UNIMPLEMENTED"
-"13.3.10 UNIMPLEMENTED"
-"13.3.11 UNIMPLEMENTED"
-"13.3.12 UNIMPLEMENTED"
-"13.3.13 UNIMPLEMENTED"
-"13.3.14 UNIMPLEMENTED"
-"13.3.15 UNIMPLEMENTED"
-"13.3.16 UNIMPLEMENTED"
-"13.3.17 UNIMPLEMENTED"
-"13.3.18 UNIMPLEMENTED"
-"13.3.2 UNIMPLEMENTED"
-"13.3.3 UNIMPLEMENTED"
-"13.3.4 UNIMPLEMENTED"
-"13.3.5 UNIMPLEMENTED"
-"13.3.6 UNIMPLEMENTED"
-"13.3.7 UNIMPLEMENTED"
-"13.3.8 UNIMPLEMENTED"
-"13.3.9 UNIMPLEMENTED"
-"13.4.1 UNIMPLEMENTED"
-"13.4.10 UNIMPLEMENTED"
-"13.4.11 UNIMPLEMENTED"
-"13.4.12 UNIMPLEMENTED"
-"13.4.13 UNIMPLEMENTED"
-"13.4.14 UNIMPLEMENTED"
-"13.4.15 UNIMPLEMENTED"
-"13.4.16 UNIMPLEMENTED"
-"13.4.17 UNIMPLEMENTED"
-"13.4.18 UNIMPLEMENTED"
-"13.4.2 UNIMPLEMENTED"
-"13.4.3 UNIMPLEMENTED"
-"13.4.4 UNIMPLEMENTED"
-"13.4.5 UNIMPLEMENTED"
-"13.4.6 UNIMPLEMENTED"
-"13.4.7 UNIMPLEMENTED"
-"13.4.8 UNIMPLEMENTED"
-"13.4.9 UNIMPLEMENTED"
-"13.5.1 UNIMPLEMENTED"
-"13.5.10 UNIMPLEMENTED"
-"13.5.11 UNIMPLEMENTED"
-"13.5.12 UNIMPLEMENTED"
-"13.5.13 UNIMPLEMENTED"
-"13.5.14 UNIMPLEMENTED"
-"13.5.15 UNIMPLEMENTED"
-"13.5.16 UNIMPLEMENTED"
-"13.5.17 UNIMPLEMENTED"
-"13.5.18 UNIMPLEMENTED"
-"13.5.2 UNIMPLEMENTED"
-"13.5.3 UNIMPLEMENTED"
-"13.5.4 UNIMPLEMENTED"
-"13.5.5 UNIMPLEMENTED"
-"13.5.6 UNIMPLEMENTED"
-"13.5.7 UNIMPLEMENTED"
-"13.5.8 UNIMPLEMENTED"
-"13.5.9 UNIMPLEMENTED"
-"13.6.1 UNIMPLEMENTED"
-"13.6.10 UNIMPLEMENTED"
-"13.6.11 UNIMPLEMENTED"
-"13.6.12 UNIMPLEMENTED"
-"13.6.13 UNIMPLEMENTED"
-"13.6.14 UNIMPLEMENTED"
-"13.6.15 UNIMPLEMENTED"
-"13.6.16 UNIMPLEMENTED"
-"13.6.17 UNIMPLEMENTED"
-"13.6.18 UNIMPLEMENTED"
-"13.6.2 UNIMPLEMENTED"
-"13.6.3 UNIMPLEMENTED"
-"13.6.4 UNIMPLEMENTED"
-"13.6.5 UNIMPLEMENTED"
-"13.6.6 UNIMPLEMENTED"
-"13.6.7 UNIMPLEMENTED"
-"13.6.8 UNIMPLEMENTED"
-"13.6.9 UNIMPLEMENTED"
-"13.7.1 UNIMPLEMENTED"
-"13.7.10 UNIMPLEMENTED"
-"13.7.11 UNIMPLEMENTED"
-"13.7.12 UNIMPLEMENTED"
-"13.7.13 UNIMPLEMENTED"
-"13.7.14 UNIMPLEMENTED"
-"13.7.15 UNIMPLEMENTED"
-"13.7.16 UNIMPLEMENTED"
-"13.7.17 UNIMPLEMENTED"
-"13.7.18 UNIMPLEMENTED"
-"13.7.2 UNIMPLEMENTED"
-"13.7.3 UNIMPLEMENTED"
-"13.7.4 UNIMPLEMENTED"
-"13.7.5 UNIMPLEMENTED"
-"13.7.6 UNIMPLEMENTED"
-"13.7.7 UNIMPLEMENTED"
-"13.7.8 UNIMPLEMENTED"
-"13.7.9 UNIMPLEMENTED"
-"2.1 OK"
-"2.10 OK"
-"2.11 OK"
-"2.2 OK"
-"2.3 OK"
-"2.4 OK"
-"2.5 OK"
-"2.6 OK"
-"2.7 OK"
-"2.8 OK"
-"2.9 OK"
-"3.1 OK"
-"3.2 NON-STRICT"
-"3.3 NON-STRICT"
-"3.4 NON-STRICT"
-"3.5 OK"
-"3.6 OK"
-"3.7 OK"
-"4.1.1 OK"
-"4.1.2 OK"
-"4.1.3 NON-STRICT"
-"4.1.4 NON-STRICT"
-"4.1.5 OK"
-"4.2.1 OK"
-"4.2.2 OK"
-"4.2.3 NON-STRICT"
-"4.2.4 OK"
-"4.2.5 OK"
-"5.1 OK"
-"5.10 OK"
-"5.11 OK"
-"5.12 OK"
-"5.13 OK"
-"5.14 OK"
-"5.15 OK"
-"5.16 OK"
-"5.17 OK"
-"5.18 OK"
-"5.19 OK"
-"5.2 OK"
-"5.20 OK"
-"5.3 OK"
-"5.4 OK"
-"5.5 OK"
-"5.6 OK"
-"5.7 OK"
-"5.8 OK"
-"5.9 OK"
-"7.1.1 OK"
-"7.1.2 OK"
-"7.1.3 OK"
-"7.1.4 OK"
-"7.1.5 OK"
-"7.1.6 INFORMATIONAL"
-"7.13.1 INFORMATIONAL"
-"7.13.2 INFORMATIONAL"
-"7.3.1 OK"
-"7.3.2 OK"
-"7.3.3 OK"
-"7.3.4 OK"
-"7.3.5 OK"
-"7.3.6 OK"
-"7.5.1 FAILED"
-"7.7.1 OK"
-"7.7.10 OK"
-"7.7.11 OK"
-"7.7.12 OK"
-"7.7.13 OK"
-"7.7.2 OK"
-"7.7.3 OK"
-"7.7.4 OK"
-"7.7.5 OK"
-"7.7.6 OK"
-"7.7.7 OK"
-"7.7.8 OK"
-"7.7.9 OK"
-"7.9.1 OK"
-"7.9.10 OK"
-"7.9.11 OK"
-"7.9.12 OK"
-"7.9.13 OK"
-"7.9.2 OK"
-"7.9.3 OK"
-"7.9.4 OK"
-"7.9.5 OK"
-"7.9.6 OK"
-"7.9.7 OK"
-"7.9.8 OK"
-"7.9.9 OK"
-"9.1.1 OK"
-"9.1.2 OK"
-"9.1.3 OK"
-"9.1.4 OK"
-"9.1.5 OK"
-"9.1.6 OK"
-"9.2.1 OK"
-"9.2.2 OK"
-"9.2.3 OK"
-"9.2.4 OK"
-"9.2.5 OK"
-"9.2.6 OK"
-"9.3.1 OK"
-"9.3.2 OK"
-"9.3.3 OK"
-"9.3.4 OK"
-"9.3.5 OK"
-"9.3.6 OK"
-"9.3.7 OK"
-"9.3.8 OK"
-"9.3.9 OK"
-"9.4.1 OK"
-"9.4.2 OK"
-"9.4.3 OK"
-"9.4.4 OK"
-"9.4.5 OK"
-"9.4.6 OK"
-"9.4.7 OK"
-"9.4.8 OK"
-"9.4.9 OK"
-"9.5.1 OK"
-"9.5.2 OK"
-"9.5.3 OK"
-"9.5.4 OK"
-"9.5.5 OK"
-"9.5.6 OK"
-"9.6.1 OK"
-"9.6.2 OK"
-"9.6.3 OK"
-"9.6.4 OK"
-"9.6.5 OK"
-"9.6.6 OK"
-"9.7.1 OK"
-"9.7.2 OK"
-"9.7.3 OK"
-"9.7.4 OK"
-"9.7.5 OK"
-"9.7.6 OK"
-"9.8.1 OK"
-"9.8.2 OK"
-"9.8.3 OK"
-"9.8.4 OK"
-"9.8.5 OK"
-"9.8.6 OK"
diff --git a/fuzzing/fuzzingserver-test.sh b/fuzzing/fuzzingserver-test.sh
deleted file mode 100755
index 78ad71f59e..0000000000
--- a/fuzzing/fuzzingserver-test.sh
+++ /dev/null
@@ -1,28 +0,0 @@
-#!/usr/bin/env bash
-
-SCRIPT_DIR="$( cd "$( dirname "$0" )" && pwd )"
-cd "$SCRIPT_DIR"
-
-which wstest
-if [ $? != 0 ]; then
-  echo "Run 'pip install autobahntestsuite', maybe with 'sudo'."
-  exit 1
-fi
-which jq
-if [ $? != 0 ]; then
-  echo "Run 'brew install jq'"
-  exit 1
-fi
-
-trap 'kill $(jobs -pr)' SIGINT SIGTERM EXIT
-
-set -ex
-
-wstest -m fuzzingserver -s fuzzingserver-config.json &
-sleep 2 # wait for wstest to start
-
-java -jar target/okhttp-tests-*-jar-with-dependencies.jar
-
-jq '.[] as $in | $in | keys[] | . + " " + $in[.].behavior' target/fuzzingserver-report/index.json > target/fuzzingserver-actual.txt
-
-diff fuzzingserver-expected.txt target/fuzzingserver-actual.txt
diff --git a/fuzzing/fuzzingserver-update-expected.sh b/fuzzing/fuzzingserver-update-expected.sh
deleted file mode 100755
index 56592c95fe..0000000000
--- a/fuzzing/fuzzingserver-update-expected.sh
+++ /dev/null
@@ -1,11 +0,0 @@
-#!/usr/bin/env bash
-
-SCRIPT_DIR="$( cd "$( dirname "$0" )" && pwd )"
-cd "$SCRIPT_DIR"
-
-if [ ! -f target/fuzzingserver-actual.txt ]; then
-  echo "File not found. Did you run the Autobahn test script?"
-  exit 1
-fi
-
-cp target/fuzzingserver-actual.txt fuzzingserver-expected.txt
diff --git a/mockwebserver/Module.md b/mockwebserver/Module.md
deleted file mode 100644
index 8493a4c347..0000000000
--- a/mockwebserver/Module.md
+++ /dev/null
@@ -1,3 +0,0 @@
-# Module mockwebserver
-
-A scriptable web server for testing HTTP clients.
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
deleted file mode 100644
index b6d2443dc6..0000000000
--- a/mockwebserver/README.md
+++ /dev/null
@@ -1,160 +0,0 @@
-MockWebServer
-=============
-
-A scriptable web server for testing HTTP clients
-
-
-### Motivation
-
-This library makes it easy to test that your app Does The Right Thing when it
-makes HTTP and HTTPS calls. It lets you specify which responses to return and
-then verify that requests were made as expected.
-
-Because it exercises your full HTTP stack, you can be confident that you're
-testing everything. You can even copy & paste HTTP responses from your real web
-server to create representative test cases. Or test that your code survives in
-awkward-to-reproduce situations like 500 errors or slow-loading responses.
-
-
-### Example
-
-Use MockWebServer the same way that you use mocking frameworks like
-[Mockito](https://github.com/mockito/mockito):
-
-1. Script the mocks.
-2. Run application code.
-3. Verify that the expected requests were made.
-
-Here's a complete example:
-
-```java
-public void test() throws Exception {
-  // Create a MockWebServer. These are lean enough that you can create a new
-  // instance for every unit test.
-  MockWebServer server = new MockWebServer();
-
-  // Schedule some responses.
-  server.enqueue(new MockResponse().setBody("hello, world!"));
-  server.enqueue(new MockResponse().setBody("sup, bra?"));
-  server.enqueue(new MockResponse().setBody("yo dog"));
-
-  // Start the server.
-  server.start();
-
-  // Ask the server for its URL. You'll need this to make HTTP requests.
-  HttpUrl baseUrl = server.url("/v1/chat/");
-
-  // Exercise your application code, which should make those HTTP requests.
-  // Responses are returned in the same order that they are enqueued.
-  Chat chat = new Chat(baseUrl);
-
-  chat.loadMore();
-  assertEquals("hello, world!", chat.messages());
-
-  chat.loadMore();
-  chat.loadMore();
-  assertEquals(""
-      + "hello, world!\n"
-      + "sup, bra?\n"
-      + "yo dog", chat.messages());
-
-  // Optional: confirm that your app made the HTTP requests you were expecting.
-  RecordedRequest request1 = server.takeRequest();
-  assertEquals("/v1/chat/messages/", request1.getPath());
-  assertNotNull(request1.getHeader("Authorization"));
-
-  RecordedRequest request2 = server.takeRequest();
-  assertEquals("/v1/chat/messages/2", request2.getPath());
-
-  RecordedRequest request3 = server.takeRequest();
-  assertEquals("/v1/chat/messages/3", request3.getPath());
-
-  // Shut down the server. Instances cannot be reused.
-  server.shutdown();
-}
-```
-
-Your unit tests might move the `server` into a field so you can shut it down
-from your test's `tearDown()`.
-
-### API
-
-#### MockResponse
-
-Mock responses default to an empty response body and a `200` status code.
-You can set a custom body with a string, input stream or byte array. Also
-add headers with a fluent builder API.
-
-```java
-MockResponse response = new MockResponse()
-    .addHeader("Content-Type", "application/json; charset=utf-8")
-    .addHeader("Cache-Control", "no-cache")
-    .setBody("{}");
-```
-
-MockResponse can be used to simulate a slow network. This is useful for
-testing timeouts and interactive testing.
-
-```java
-response.throttleBody(1024, 1, TimeUnit.SECONDS);
-```
-
-
-#### RecordedRequest
-
-Verify requests by their method, path, HTTP version, body, and headers.
-
-```java
-RecordedRequest request = server.takeRequest();
-assertEquals("POST /v1/chat/send HTTP/1.1", request.getRequestLine());
-assertEquals("application/json; charset=utf-8", request.getHeader("Content-Type"));
-assertEquals("{}", request.getBody().readUtf8());
-```
-
-#### Dispatcher
-
-By default MockWebServer uses a queue to specify a series of responses. Use a
-Dispatcher to handle requests using another policy. One natural policy is to
-dispatch on the request path.
-You can, for example, filter the request instead of using `server.enqueue()`.
-
-```java
-final Dispatcher dispatcher = new Dispatcher() {
-
-    @Override
-    public MockResponse dispatch (RecordedRequest request) throws InterruptedException {
-
-        switch (request.getPath()) {
-            case "/v1/login/auth/":
-                return new MockResponse().setResponseCode(200);
-            case "v1/check/version/":
-                return new MockResponse().setResponseCode(200).setBody("version=9");
-            case "/v1/profile/info":
-                return new MockResponse().setResponseCode(200).setBody("{\\\"info\\\":{\\\"name\":\"Lucas Albuquerque\",\"age\":\"21\",\"gender\":\"male\"}}");
-        }
-        return new MockResponse().setResponseCode(404);
-    }
-};
-server.setDispatcher(dispatcher);
-```
-
-
-### Download
-
-```kotlin
-testImplementation("com.squareup.okhttp3:mockwebserver:4.2.1")
-```
-
-### License
-
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
diff --git a/mockwebserver/build.gradle b/mockwebserver/build.gradle
deleted file mode 100644
index d48d2ed554..0000000000
--- a/mockwebserver/build.gradle
+++ /dev/null
@@ -1,119 +0,0 @@
-apply plugin: 'com.vanniktech.maven.publish'
-apply plugin: 'me.champeau.gradle.japicmp'
-
-jar {
-  manifest {
-    attributes('Automatic-Module-Name': 'okhttp3.mockwebserver')
-  }
-}
-
-dependencies {
-  api project(':okhttp')
-  api deps.junit
-
-  testImplementation project(':okhttp-testing-support')
-  testImplementation project(':okhttp-tls')
-  testImplementation deps.assertj
-}
-
-afterEvaluate { project ->
-  project.tasks.dokka {
-    outputDirectory = "$rootDir/docs/4.x"
-    outputFormat = 'gfm'
-  }
-}
-
-task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
-  oldClasspath = files(baselineJar(project, baselineVersion))
-  newClasspath = files(jar.archivePath)
-  onlyBinaryIncompatibleModified = true
-  failOnModification = true
-  txtOutputFile = file("$buildDir/reports/japi.txt")
-  ignoreMissingClasses = true
-  includeSynthetic = true
-  packageExcludes = [
-      'okhttp3.mockwebserver.internal',
-  ]        
-  methodExcludes = [
-      // Became 'final' in 4.0.0:
-      'okhttp3.mockwebserver.RecordedRequest#getChunkSizes()',
-      'okhttp3.mockwebserver.RecordedRequest#getHandshake()',
-      'okhttp3.mockwebserver.RecordedRequest#getHeader(java.lang.String)',
-      'okhttp3.mockwebserver.RecordedRequest#getHeaders()',
-      'okhttp3.mockwebserver.RecordedRequest#getMethod()',
-      'okhttp3.mockwebserver.RecordedRequest#getPath()',
-      'okhttp3.mockwebserver.RecordedRequest#getRequestLine()',
-      'okhttp3.mockwebserver.RecordedRequest#getRequestUrl()',
-      'okhttp3.mockwebserver.RecordedRequest#getSequenceNumber()',
-      'okhttp3.mockwebserver.RecordedRequest#getTlsVersion()',
-      'okhttp3.mockwebserver.RecordedRequest#getUtf8Body()',
-      'okhttp3.mockwebserver.RecordedRequest#getBody()',
-      'okhttp3.mockwebserver.RecordedRequest#getBodySize()',
-      'okhttp3.mockwebserver.PushPromise#headers()',
-      'okhttp3.mockwebserver.PushPromise#method()',
-      'okhttp3.mockwebserver.PushPromise#path()',
-      'okhttp3.mockwebserver.PushPromise#response()',
-      'okhttp3.mockwebserver.MockResponse#addHeader(java.lang.String)',
-      'okhttp3.mockwebserver.MockResponse#addHeader(java.lang.String, java.lang.Object)',
-      'okhttp3.mockwebserver.MockResponse#addHeaderLenient(java.lang.String, java.lang.Object)',
-      'okhttp3.mockwebserver.MockResponse#clearHeaders()',
-      'okhttp3.mockwebserver.MockResponse#getBody()',
-      'okhttp3.mockwebserver.MockResponse#getBodyDelay(java.util.concurrent.TimeUnit)',
-      'okhttp3.mockwebserver.MockResponse#getDuplexResponseBody()',
-      'okhttp3.mockwebserver.MockResponse#getHeadersDelay(java.util.concurrent.TimeUnit)',
-      'okhttp3.mockwebserver.MockResponse#getHttp2ErrorCode()',
-      'okhttp3.mockwebserver.MockResponse#getPushPromises()',
-      'okhttp3.mockwebserver.MockResponse#getSettings()',
-      'okhttp3.mockwebserver.MockResponse#getSocketPolicy()',
-      'okhttp3.mockwebserver.MockResponse#getStatus()',
-      'okhttp3.mockwebserver.MockResponse#getThrottleBytesPerPeriod()',
-      'okhttp3.mockwebserver.MockResponse#getThrottlePeriod(java.util.concurrent.TimeUnit)',
-      'okhttp3.mockwebserver.MockResponse#getTrailers()',
-      'okhttp3.mockwebserver.MockResponse#getWebSocketListener()',
-      'okhttp3.mockwebserver.MockResponse#removeHeader(java.lang.String)',
-      'okhttp3.mockwebserver.MockResponse#setBody(okio.Buffer)',
-      'okhttp3.mockwebserver.MockResponse#setBody(java.lang.String)',
-      'okhttp3.mockwebserver.MockResponse#setBodyDelay(long, java.util.concurrent.TimeUnit)',
-      'okhttp3.mockwebserver.MockResponse#setChunkedBody(okio.Buffer, int)',
-      'okhttp3.mockwebserver.MockResponse#setChunkedBody(java.lang.String, int)',
-      'okhttp3.mockwebserver.MockResponse#setHeader(java.lang.String, java.lang.Object)',
-      'okhttp3.mockwebserver.MockResponse#setHeaders(okhttp3.Headers)',
-      'okhttp3.mockwebserver.MockResponse#setHeadersDelay(long, java.util.concurrent.TimeUnit)',
-      'okhttp3.mockwebserver.MockResponse#setHttp2ErrorCode(int)',
-      'okhttp3.mockwebserver.MockResponse#setResponseCode(int)',
-      'okhttp3.mockwebserver.MockResponse#setSocketPolicy(okhttp3.mockwebserver.SocketPolicy)',
-      'okhttp3.mockwebserver.MockResponse#setTrailers(okhttp3.Headers)',
-      'okhttp3.mockwebserver.MockResponse#throttleBody(long, long, java.util.concurrent.TimeUnit)',
-      'okhttp3.mockwebserver.MockResponse#withPush(okhttp3.mockwebserver.PushPromise)',
-      'okhttp3.mockwebserver.MockResponse#withSettings(okhttp3.internal.http2.Settings)',
-      'okhttp3.mockwebserver.MockResponse#withWebSocketUpgrade(okhttp3.WebSocketListener)',
-      'okhttp3.mockwebserver.MockResponse#getHeaders()',
-      'okhttp3.mockwebserver.MockResponse#setStatus(java.lang.String)',
-      'okhttp3.mockwebserver.MockResponse#isDuplex()',
-      'okhttp3.mockwebserver.MockResponse#setBody(okhttp3.mockwebserver.internal.duplex.DuplexResponseBody)',
-      'okhttp3.mockwebserver.MockWebServer#enqueue(okhttp3.mockwebserver.MockResponse)',
-      'okhttp3.mockwebserver.MockWebServer#getDispatcher()',
-      'okhttp3.mockwebserver.MockWebServer#getHostName()',
-      'okhttp3.mockwebserver.MockWebServer#getPort()',
-      'okhttp3.mockwebserver.MockWebServer#getRequestCount()',
-      'okhttp3.mockwebserver.MockWebServer#noClientAuth()',
-      'okhttp3.mockwebserver.MockWebServer#protocols()',
-      'okhttp3.mockwebserver.MockWebServer#requestClientAuth()',
-      'okhttp3.mockwebserver.MockWebServer#requireClientAuth()',
-      'okhttp3.mockwebserver.MockWebServer#setBodyLimit(long)',
-      'okhttp3.mockwebserver.MockWebServer#setDispatcher(okhttp3.mockwebserver.Dispatcher)',
-      'okhttp3.mockwebserver.MockWebServer#setProtocolNegotiationEnabled(boolean)',
-      'okhttp3.mockwebserver.MockWebServer#setProtocols(java.util.List)',
-      'okhttp3.mockwebserver.MockWebServer#setServerSocketFactory(javax.net.ServerSocketFactory)',
-      'okhttp3.mockwebserver.MockWebServer#shutdown()',
-      'okhttp3.mockwebserver.MockWebServer#start()',
-      'okhttp3.mockwebserver.MockWebServer#start(int)',
-      'okhttp3.mockwebserver.MockWebServer#start(java.net.InetAddress, int)',
-      'okhttp3.mockwebserver.MockWebServer#takeRequest()',
-      'okhttp3.mockwebserver.MockWebServer#takeRequest(long, java.util.concurrent.TimeUnit)',
-      'okhttp3.mockwebserver.MockWebServer#toProxyAddress()',
-      'okhttp3.mockwebserver.MockWebServer#url(java.lang.String)',
-      'okhttp3.mockwebserver.MockWebServer#useHttps(javax.net.ssl.SSLSocketFactory, boolean)',
-  ]
-}
-check.dependsOn(japicmp)
diff --git a/mockwebserver/gradle.properties b/mockwebserver/gradle.properties
deleted file mode 100644
index 640fcdf3d5..0000000000
--- a/mockwebserver/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=mockwebserver
-POM_NAME=mockwebserver
-POM_PACKAGING=jar
diff --git a/mockwebserver/src/main/java/okhttp3/internal/duplex/MwsDuplexAccess.kt b/mockwebserver/src/main/java/okhttp3/internal/duplex/MwsDuplexAccess.kt
deleted file mode 100644
index 0f16e5701c..0000000000
--- a/mockwebserver/src/main/java/okhttp3/internal/duplex/MwsDuplexAccess.kt
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.duplex
-
-import okhttp3.mockwebserver.MockResponse
-import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody
-
-/**
- * Internal access to MockWebServer APIs. Don't use this, don't use internal, these APIs are not
- * stable.
- */
-abstract class MwsDuplexAccess {
-
-  abstract fun setBody(mockResponse: MockResponse, duplexResponseBody: DuplexResponseBody)
-
-  companion object {
-    @JvmField var instance: MwsDuplexAccess? = null
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.kt
deleted file mode 100644
index 5208a3b47b..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.kt
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver
-
-/** Handler for mock server requests. */
-abstract class Dispatcher {
-  /**
-   * Returns a response to satisfy `request`. This method may block (for instance, to wait on
-   * a CountdownLatch).
-   */
-  @Throws(InterruptedException::class)
-  abstract fun dispatch(request: RecordedRequest): MockResponse
-
-  /**
-   * Returns an early guess of the next response, used for policy on how an incoming request should
-   * be received. The default implementation returns an empty response. Mischievous implementations
-   * can return other values to test HTTP edge cases, such as unhappy socket policies or throttled
-   * request bodies.
-   */
-  open fun peek(): MockResponse {
-    return MockResponse().apply { this.socketPolicy = SocketPolicy.KEEP_OPEN }
-  }
-
-  /**
-   * Release any resources held by this dispatcher. Any requests that are currently being dispatched
-   * should return immediately. Responses returned after shutdown will not be transmitted: their
-   * socket connections have already been closed.
-   */
-  open fun shutdown() {}
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.kt
deleted file mode 100644
index 0e8c5f247a..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.kt
+++ /dev/null
@@ -1,337 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver
-
-import okhttp3.Headers
-import okhttp3.WebSocketListener
-import okhttp3.internal.addHeaderLenient
-import okhttp3.internal.http2.Settings
-import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody
-import okio.Buffer
-import java.util.concurrent.TimeUnit
-
-/** A scripted response to be replayed by the mock web server. */
-class MockResponse : Cloneable {
-  /** Returns the HTTP response line, such as "HTTP/1.1 200 OK". */
-  @set:JvmName("status")
-  var status: String = ""
-
-  private var headersBuilder = Headers.Builder()
-  private var trailersBuilder = Headers.Builder()
-
-  /** The HTTP headers, such as "Content-Length: 0". */
-  @set:JvmName("headers")
-  var headers: Headers
-    get() = headersBuilder.build()
-    set(value) {
-      this.headersBuilder = value.newBuilder()
-    }
-
-  @set:JvmName("trailers")
-  var trailers: Headers
-    get() = trailersBuilder.build()
-    set(value) {
-      this.trailersBuilder = value.newBuilder()
-    }
-
-  private var body: Buffer? = null
-
-  var throttleBytesPerPeriod = Long.MAX_VALUE
-    private set
-  private var throttlePeriodAmount = 1L
-  private var throttlePeriodUnit = TimeUnit.SECONDS
-
-  @set:JvmName("socketPolicy")
-  var socketPolicy = SocketPolicy.KEEP_OPEN
-
-  /**
-   * Sets the [HTTP/2 error code](https://tools.ietf.org/html/rfc7540#section-7) to be
-   * returned when resetting the stream.
-   * This is only valid with [SocketPolicy.RESET_STREAM_AT_START].
-   */
-  @set:JvmName("http2ErrorCode")
-  var http2ErrorCode = -1
-
-  private var bodyDelayAmount = 0L
-  private var bodyDelayUnit = TimeUnit.MILLISECONDS
-
-  private var headersDelayAmount = 0L
-  private var headersDelayUnit = TimeUnit.MILLISECONDS
-
-  private var promises = mutableListOf<PushPromise>()
-  var settings: Settings = Settings()
-    private set
-  var webSocketListener: WebSocketListener? = null
-    private set
-  var duplexResponseBody: DuplexResponseBody? = null
-    private set
-  val isDuplex: Boolean
-    get() = duplexResponseBody != null
-
-  /** Returns the streams the server will push with this response. */
-  val pushPromises: List<PushPromise>
-    get() = promises
-
-  /** Creates a new mock response with an empty body. */
-  init {
-    setResponseCode(200)
-    setHeader("Content-Length", 0L)
-  }
-
-  public override fun clone(): MockResponse {
-    val result = super.clone() as MockResponse
-    result.headersBuilder = headersBuilder.build().newBuilder()
-    result.promises = promises.toMutableList()
-    return result
-  }
-
-  @JvmName("-deprecated_getStatus")
-  @Deprecated(
-      message = "moved to var",
-      replaceWith = ReplaceWith(expression = "status"),
-      level = DeprecationLevel.ERROR)
-  fun getStatus(): String = status
-
-  @Deprecated(
-      message = "moved to var.  Replace setStatus(...) with status(...) to fix Java",
-      replaceWith = ReplaceWith(expression = "apply { this.status = status }"),
-      level = DeprecationLevel.WARNING)
-  fun setStatus(status: String) = apply {
-    this.status = status
-  }
-
-  fun setResponseCode(code: Int): MockResponse {
-    val reason = when (code) {
-      in 100..199 -> "Informational"
-      in 200..299 -> "OK"
-      in 300..399 -> "Redirection"
-      in 400..499 -> "Client Error"
-      in 500..599 -> "Server Error"
-      else -> "Mock Response"
-    }
-    return apply { status = "HTTP/1.1 $code $reason" }
-  }
-
-  /**
-   * Removes all HTTP headers including any "Content-Length" and "Transfer-encoding" headers that
-   * were added by default.
-   */
-  fun clearHeaders() = apply {
-    headersBuilder = Headers.Builder()
-  }
-
-  /**
-   * Adds [header] as an HTTP header. For well-formed HTTP [header] should contain a
-   * name followed by a colon and a value.
-   */
-  fun addHeader(header: String) = apply {
-    headersBuilder.add(header)
-  }
-
-  /**
-   * Adds a new header with the name and value. This may be used to add multiple headers with the
-   * same name.
-   */
-  fun addHeader(name: String, value: Any) = apply {
-    headersBuilder.add(name, value.toString())
-  }
-
-  /**
-   * Adds a new header with the name and value. This may be used to add multiple headers with the
-   * same name. Unlike [addHeader] this does not validate the name and
-   * value.
-   */
-  fun addHeaderLenient(name: String, value: Any) = apply {
-    addHeaderLenient(headersBuilder, name, value.toString())
-  }
-
-  /**
-   * Removes all headers named [name], then adds a new header with the name and value.
-   */
-  fun setHeader(name: String, value: Any) = apply {
-    removeHeader(name)
-    addHeader(name, value)
-  }
-
-  /** Removes all headers named [name]. */
-  fun removeHeader(name: String) = apply {
-    headersBuilder.removeAll(name)
-  }
-
-  /** Returns a copy of the raw HTTP payload. */
-  fun getBody(): Buffer? = body?.clone()
-
-  fun setBody(body: Buffer) = apply {
-    setHeader("Content-Length", body.size)
-    this.body = body.clone() // Defensive copy.
-  }
-
-  /** Sets the response body to the UTF-8 encoded bytes of [body]. */
-  fun setBody(body: String): MockResponse = setBody(Buffer().writeUtf8(body))
-
-  fun setBody(duplexResponseBody: DuplexResponseBody) = apply {
-    this.duplexResponseBody = duplexResponseBody
-  }
-
-  /**
-   * Sets the response body to [body], chunked every [maxChunkSize] bytes.
-   */
-  fun setChunkedBody(body: Buffer, maxChunkSize: Int) = apply {
-    removeHeader("Content-Length")
-    headersBuilder.add(CHUNKED_BODY_HEADER)
-
-    val bytesOut = Buffer()
-    while (!body.exhausted()) {
-      val chunkSize = minOf(body.size, maxChunkSize.toLong())
-      bytesOut.writeHexadecimalUnsignedLong(chunkSize)
-      bytesOut.writeUtf8("\r\n")
-      bytesOut.write(body, chunkSize)
-      bytesOut.writeUtf8("\r\n")
-    }
-    bytesOut.writeUtf8("0\r\n") // Last chunk. Trailers follow!
-    this.body = bytesOut
-  }
-
-  /**
-   * Sets the response body to the UTF-8 encoded bytes of [body],
-   * chunked every [maxChunkSize] bytes.
-   */
-  fun setChunkedBody(body: String, maxChunkSize: Int): MockResponse =
-    setChunkedBody(Buffer().writeUtf8(body), maxChunkSize)
-
-  @JvmName("-deprecated_getHeaders")
-  @Deprecated(
-      message = "moved to var",
-      replaceWith = ReplaceWith(expression = "headers"),
-      level = DeprecationLevel.ERROR)
-  fun getHeaders(): Headers = headers
-
-  @Deprecated(
-      message = "moved to var. Replace setHeaders(...) with headers(...) to fix Java",
-      replaceWith = ReplaceWith(expression = "apply { this.headers = headers }"),
-      level = DeprecationLevel.WARNING)
-  fun setHeaders(headers: Headers) = apply { this.headers = headers }
-
-  @JvmName("-deprecated_getTrailers")
-  @Deprecated(
-      message = "moved to var",
-      replaceWith = ReplaceWith(expression = "trailers"),
-      level = DeprecationLevel.ERROR)
-  fun getTrailers(): Headers = trailers
-
-  @Deprecated(
-      message = "moved to var. Replace setTrailers(...) with trailers(...) to fix Java",
-      replaceWith = ReplaceWith(expression = "apply { this.trailers = trailers }"),
-      level = DeprecationLevel.WARNING)
-  fun setTrailers(trailers: Headers) = apply { this.trailers = trailers }
-
-  @JvmName("-deprecated_getSocketPolicy")
-  @Deprecated(
-      message = "moved to var",
-      replaceWith = ReplaceWith(expression = "socketPolicy"),
-      level = DeprecationLevel.ERROR)
-  fun getSocketPolicy() = socketPolicy
-
-  @Deprecated(
-      message = "moved to var. Replace setSocketPolicy(...) with socketPolicy(...) to fix Java",
-      replaceWith = ReplaceWith(expression = "apply { this.socketPolicy = socketPolicy }"),
-      level = DeprecationLevel.WARNING)
-  fun setSocketPolicy(socketPolicy: SocketPolicy) = apply {
-    this.socketPolicy = socketPolicy
-  }
-
-  @JvmName("-deprecated_getHttp2ErrorCode")
-  @Deprecated(
-      message = "moved to var",
-      replaceWith = ReplaceWith(expression = "http2ErrorCode"),
-      level = DeprecationLevel.ERROR)
-  fun getHttp2ErrorCode() = http2ErrorCode
-
-  @Deprecated(
-      message = "moved to var. Replace setHttp2ErrorCode(...) with http2ErrorCode(...) to fix Java",
-      replaceWith = ReplaceWith(expression = "apply { this.http2ErrorCode = http2ErrorCode }"),
-      level = DeprecationLevel.WARNING)
-  fun setHttp2ErrorCode(http2ErrorCode: Int) = apply {
-    this.http2ErrorCode = http2ErrorCode
-  }
-
-  /**
-   * Throttles the request reader and response writer to sleep for the given period after each
-   * series of [bytesPerPeriod] bytes are transferred. Use this to simulate network behavior.
-   */
-  fun throttleBody(bytesPerPeriod: Long, period: Long, unit: TimeUnit) = apply {
-    throttleBytesPerPeriod = bytesPerPeriod
-    throttlePeriodAmount = period
-    throttlePeriodUnit = unit
-  }
-
-  fun getThrottlePeriod(unit: TimeUnit): Long =
-    unit.convert(throttlePeriodAmount, throttlePeriodUnit)
-
-  /**
-   * Set the delayed time of the response body to [delay]. This applies to the response body
-   * only; response headers are not affected.
-   */
-  fun setBodyDelay(delay: Long, unit: TimeUnit) = apply {
-    bodyDelayAmount = delay
-    bodyDelayUnit = unit
-  }
-
-  fun getBodyDelay(unit: TimeUnit): Long =
-    unit.convert(bodyDelayAmount, bodyDelayUnit)
-
-  fun setHeadersDelay(delay: Long, unit: TimeUnit) = apply {
-    headersDelayAmount = delay
-    headersDelayUnit = unit
-  }
-
-  fun getHeadersDelay(unit: TimeUnit): Long =
-    unit.convert(headersDelayAmount, headersDelayUnit)
-
-  /**
-   * When [protocols][MockWebServer.protocols] include [HTTP_2][okhttp3.Protocol], this attaches a
-   * pushed stream to this response.
-   */
-  fun withPush(promise: PushPromise) = apply {
-    promises.add(promise)
-  }
-
-  /**
-   * When [protocols][MockWebServer.protocols] include [HTTP_2][okhttp3.Protocol], this pushes
-   * [settings] before writing the response.
-   */
-  fun withSettings(settings: Settings) = apply {
-    this.settings = settings
-  }
-
-  /**
-   * Attempts to perform a web socket upgrade on the connection.
-   * This will overwrite any previously set status or body.
-   */
-  fun withWebSocketUpgrade(listener: WebSocketListener) = apply {
-    status = "HTTP/1.1 101 Switching Protocols"
-    setHeader("Connection", "Upgrade")
-    setHeader("Upgrade", "websocket")
-    body = null
-    webSocketListener = listener
-  }
-
-  override fun toString() = status
-
-  companion object {
-    private const val CHUNKED_BODY_HEADER = "Transfer-encoding: chunked"
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
deleted file mode 100644
index f6782c11cf..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
+++ /dev/null
@@ -1,1153 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.mockwebserver
-
-import okhttp3.Headers
-import okhttp3.Headers.Companion.headersOf
-import okhttp3.HttpUrl
-import okhttp3.Protocol
-import okhttp3.Request
-import okhttp3.Response
-import okhttp3.internal.addHeaderLenient
-import okhttp3.internal.closeQuietly
-import okhttp3.internal.concurrent.TaskRunner
-import okhttp3.internal.duplex.MwsDuplexAccess
-import okhttp3.internal.http.HttpMethod
-import okhttp3.internal.http2.ErrorCode
-import okhttp3.internal.http2.Header
-import okhttp3.internal.http2.Http2Connection
-import okhttp3.internal.http2.Http2Stream
-import okhttp3.internal.immutableListOf
-import okhttp3.internal.platform.Platform
-import okhttp3.internal.threadFactory
-import okhttp3.internal.toImmutableList
-import okhttp3.internal.ws.RealWebSocket
-import okhttp3.internal.ws.WebSocketProtocol
-import okhttp3.mockwebserver.SocketPolicy.CONTINUE_ALWAYS
-import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST
-import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END
-import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START
-import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_REQUEST_BODY
-import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY
-import okhttp3.mockwebserver.SocketPolicy.EXPECT_CONTINUE
-import okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE
-import okhttp3.mockwebserver.SocketPolicy.NO_RESPONSE
-import okhttp3.mockwebserver.SocketPolicy.RESET_STREAM_AT_START
-import okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END
-import okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END
-import okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE
-import okhttp3.mockwebserver.SocketPolicy.STALL_SOCKET_AT_START
-import okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END
-import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody
-import okio.Buffer
-import okio.BufferedSink
-import okio.BufferedSource
-import okio.ByteString.Companion.encodeUtf8
-import okio.Sink
-import okio.Timeout
-import okio.buffer
-import okio.sink
-import okio.source
-import org.junit.rules.ExternalResource
-import java.io.Closeable
-import java.io.IOException
-import java.net.InetAddress
-import java.net.InetSocketAddress
-import java.net.ProtocolException
-import java.net.Proxy
-import java.net.ServerSocket
-import java.net.Socket
-import java.net.SocketException
-import java.security.SecureRandom
-import java.security.cert.CertificateException
-import java.security.cert.X509Certificate
-import java.util.Collections
-import java.util.Locale
-import java.util.concurrent.ConcurrentHashMap
-import java.util.concurrent.CountDownLatch
-import java.util.concurrent.LinkedBlockingQueue
-import java.util.concurrent.TimeUnit
-import java.util.concurrent.atomic.AtomicInteger
-import java.util.logging.Level
-import java.util.logging.Logger
-import javax.net.ServerSocketFactory
-import javax.net.ssl.SSLContext
-import javax.net.ssl.SSLSocket
-import javax.net.ssl.SSLSocketFactory
-import javax.net.ssl.TrustManager
-import javax.net.ssl.X509TrustManager
-
-/**
- * A scriptable web server. Callers supply canned responses and the server replays them upon request
- * in sequence.
- */
-class MockWebServer : ExternalResource(), Closeable {
-  private val taskRunnerBackend = TaskRunner.RealBackend(
-      threadFactory("MockWebServer TaskRunner", true))
-  private val taskRunner = TaskRunner(taskRunnerBackend)
-  private val requestQueue = LinkedBlockingQueue<RecordedRequest>()
-  private val openClientSockets =
-      Collections.newSetFromMap(ConcurrentHashMap<Socket, Boolean>())
-  private val openConnections =
-      Collections.newSetFromMap(ConcurrentHashMap<Http2Connection, Boolean>())
-
-  private val atomicRequestCount = AtomicInteger()
-
-  /**
-   * The number of HTTP requests received thus far by this server. This may exceed the number of
-   * HTTP connections when connection reuse is in practice.
-   */
-  val requestCount: Int
-    get() = atomicRequestCount.get()
-
-  /** The number of bytes of the POST body to keep in memory to the given limit. */
-  var bodyLimit = Long.MAX_VALUE
-
-  var serverSocketFactory: ServerSocketFactory? = null
-    get() {
-      if (field == null && started) {
-        field = ServerSocketFactory.getDefault() // Build the default value lazily.
-      }
-      return field
-    }
-    set(value) {
-      check(!started) { "serverSocketFactory must not be set after start()" }
-      field = value
-    }
-
-  private var serverSocket: ServerSocket? = null
-  private var sslSocketFactory: SSLSocketFactory? = null
-  private var tunnelProxy: Boolean = false
-  private var clientAuth = CLIENT_AUTH_NONE
-
-  /**
-   * The dispatcher used to respond to HTTP requests. The default dispatcher is a [QueueDispatcher],
-   * which serves a fixed sequence of responses from a [queue][enqueue].
-   *
-   * Other dispatchers can be configured. They can vary the response based on timing or the content
-   * of the request.
-   */
-  var dispatcher: Dispatcher = QueueDispatcher()
-
-  private var portField: Int = -1
-  val port: Int
-    get() {
-      before()
-      return portField
-    }
-
-  val hostName: String
-    get() {
-      before()
-      return inetSocketAddress!!.address.canonicalHostName
-    }
-
-  private var inetSocketAddress: InetSocketAddress? = null
-
-  /**
-   * True if ALPN is used on incoming HTTPS connections to negotiate a protocol like HTTP/1.1 or
-   * HTTP/2. This is true by default; set to false to disable negotiation and restrict connections
-   * to HTTP/1.1.
-   */
-  var protocolNegotiationEnabled = true
-
-  /**
-   * The protocols supported by ALPN on incoming HTTPS connections in order of preference. The list
-   * must contain [Protocol.HTTP_1_1]. It must not contain null.
-   *
-   * This list is ignored when [negotiation is disabled][protocolNegotiationEnabled].
-   */
-  @get:JvmName("protocols") var protocols: List<Protocol> =
-      immutableListOf(Protocol.HTTP_2, Protocol.HTTP_1_1)
-    set(value) {
-      val protocolList = value.toImmutableList()
-      require(Protocol.H2_PRIOR_KNOWLEDGE !in protocolList || protocolList.size == 1) {
-        "protocols containing h2_prior_knowledge cannot use other protocols: $protocolList"
-      }
-      require(Protocol.HTTP_1_1 in protocolList || Protocol.H2_PRIOR_KNOWLEDGE in protocolList) {
-        "protocols doesn't contain http/1.1: $protocolList"
-      }
-      require(null !in protocolList as List<Protocol?>) { "protocols must not contain null" }
-      field = protocolList
-    }
-
-  private var started: Boolean = false
-
-  @Synchronized override fun before() {
-    if (started) return
-    try {
-      start()
-    } catch (e: IOException) {
-      throw RuntimeException(e)
-    }
-  }
-
-  @JvmName("-deprecated_port")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "port"),
-      level = DeprecationLevel.ERROR)
-  fun getPort(): Int = port
-
-  fun toProxyAddress(): Proxy {
-    before()
-    val address = InetSocketAddress(inetSocketAddress!!.address.canonicalHostName, port)
-    return Proxy(Proxy.Type.HTTP, address)
-  }
-
-  @JvmName("-deprecated_serverSocketFactory")
-  @Deprecated(
-      message = "moved to var",
-      replaceWith = ReplaceWith(
-          expression = "run { this.serverSocketFactory = serverSocketFactory }"
-      ),
-      level = DeprecationLevel.ERROR)
-  fun setServerSocketFactory(serverSocketFactory: ServerSocketFactory) = run {
-    this.serverSocketFactory = serverSocketFactory
-  }
-
-  /**
-   * Returns a URL for connecting to this server.
-   *
-   * @param path the request path, such as "/".
-   */
-  fun url(path: String): HttpUrl {
-    return HttpUrl.Builder()
-        .scheme(if (sslSocketFactory != null) "https" else "http")
-        .host(hostName)
-        .port(port)
-        .build()
-        .resolve(path)!!
-  }
-
-  @JvmName("-deprecated_bodyLimit")
-  @Deprecated(
-      message = "moved to var",
-      replaceWith = ReplaceWith(
-          expression = "run { this.bodyLimit = bodyLimit }"
-      ),
-      level = DeprecationLevel.ERROR)
-  fun setBodyLimit(bodyLimit: Long) = run { this.bodyLimit = bodyLimit }
-
-  @JvmName("-deprecated_protocolNegotiationEnabled")
-  @Deprecated(
-      message = "moved to var",
-      replaceWith = ReplaceWith(
-          expression = "run { this.protocolNegotiationEnabled = protocolNegotiationEnabled }"
-      ),
-      level = DeprecationLevel.ERROR)
-  fun setProtocolNegotiationEnabled(protocolNegotiationEnabled: Boolean) = run {
-    this.protocolNegotiationEnabled = protocolNegotiationEnabled
-  }
-
-  @JvmName("-deprecated_protocols")
-  @Deprecated(
-      message = "moved to var",
-      replaceWith = ReplaceWith(expression = "run { this.protocols = protocols }"),
-      level = DeprecationLevel.ERROR)
-  fun setProtocols(protocols: List<Protocol>) = run { this.protocols = protocols }
-
-  @JvmName("-deprecated_protocols")
-  @Deprecated(
-      message = "moved to var",
-      replaceWith = ReplaceWith(expression = "protocols"),
-      level = DeprecationLevel.ERROR)
-  fun protocols(): List<Protocol> = protocols
-
-  /**
-   * Serve requests with HTTPS rather than otherwise.
-   *
-   * @param tunnelProxy true to expect the HTTP CONNECT method before negotiating TLS.
-   */
-  fun useHttps(sslSocketFactory: SSLSocketFactory, tunnelProxy: Boolean) {
-    this.sslSocketFactory = sslSocketFactory
-    this.tunnelProxy = tunnelProxy
-  }
-
-  /**
-   * Configure the server to not perform SSL authentication of the client. This leaves
-   * authentication to another layer such as in an HTTP cookie or header. This is the default and
-   * most common configuration.
-   */
-  fun noClientAuth() {
-    this.clientAuth = CLIENT_AUTH_NONE
-  }
-
-  /**
-   * Configure the server to [want client auth][SSLSocket.setWantClientAuth]. If the
-   * client presents a certificate that is [trusted][TrustManager] the handshake will
-   * proceed normally. The connection will also proceed normally if the client presents no
-   * certificate at all! But if the client presents an untrusted certificate the handshake
-   * will fail and no connection will be established.
-   */
-  fun requestClientAuth() {
-    this.clientAuth = CLIENT_AUTH_REQUESTED
-  }
-
-  /**
-   * Configure the server to [need client auth][SSLSocket.setNeedClientAuth]. If the
-   * client presents a certificate that is [trusted][TrustManager] the handshake will
-   * proceed normally. If the client presents an untrusted certificate or no certificate at all the
-   * handshake will fail and no connection will be established.
-   */
-  fun requireClientAuth() {
-    this.clientAuth = CLIENT_AUTH_REQUIRED
-  }
-
-  /**
-   * Awaits the next HTTP request, removes it, and returns it. Callers should use this to verify the
-   * request was sent as intended. This method will block until the request is available, possibly
-   * forever.
-   *
-   * @return the head of the request queue
-   */
-  @Throws(InterruptedException::class)
-  fun takeRequest(): RecordedRequest = requestQueue.take()
-
-  /**
-   * Awaits the next HTTP request (waiting up to the specified wait time if necessary), removes it,
-   * and returns it. Callers should use this to verify the request was sent as intended within the
-   * given time.
-   *
-   * @param timeout how long to wait before giving up, in units of [unit]
-   * @param unit a [TimeUnit] determining how to interpret the [timeout] parameter
-   * @return the head of the request queue
-   */
-  @Throws(InterruptedException::class)
-  fun takeRequest(timeout: Long, unit: TimeUnit): RecordedRequest? =
-      requestQueue.poll(timeout, unit)
-
-  @JvmName("-deprecated_requestCount")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "requestCount"),
-      level = DeprecationLevel.ERROR)
-  fun getRequestCount(): Int = requestCount
-
-  /**
-   * Scripts [response] to be returned to a request made in sequence. The first request is
-   * served by the first enqueued response; the second request by the second enqueued response; and
-   * so on.
-   *
-   * @throws ClassCastException if the default dispatcher has been
-   * replaced with [setDispatcher][dispatcher].
-   */
-  fun enqueue(response: MockResponse) =
-      (dispatcher as QueueDispatcher).enqueueResponse(response.clone())
-
-  /**
-   * Starts the server on the loopback interface for the given port.
-   *
-   * @param port the port to listen to, or 0 for any available port. Automated tests should always
-   * use port 0 to avoid flakiness when a specific port is unavailable.
-   */
-  @Throws(IOException::class)
-  @JvmOverloads fun start(port: Int = 0) = start(InetAddress.getByName("localhost"), port)
-
-  /**
-   * Starts the server on the given address and port.
-   *
-   * @param inetAddress the address to create the server socket on
-   * @param port the port to listen to, or 0 for any available port. Automated tests should always
-   * use port 0 to avoid flakiness when a specific port is unavailable.
-   */
-  @Throws(IOException::class)
-  fun start(inetAddress: InetAddress, port: Int) = start(InetSocketAddress(inetAddress, port))
-
-  /**
-   * Starts the server and binds to the given socket address.
-   *
-   * @param inetSocketAddress the socket address to bind the server on
-   */
-  @Synchronized @Throws(IOException::class)
-  private fun start(inetSocketAddress: InetSocketAddress) {
-    require(!started) { "start() already called" }
-    started = true
-
-    this.inetSocketAddress = inetSocketAddress
-
-    serverSocket = serverSocketFactory!!.createServerSocket()
-
-    // Reuse if the user specified a port
-    serverSocket!!.reuseAddress = inetSocketAddress.port != 0
-    serverSocket!!.bind(inetSocketAddress, 50)
-
-    portField = serverSocket!!.localPort
-
-    taskRunner.newQueue().execute("MockWebServer $portField", cancelable = false) {
-      try {
-        logger.info("${this@MockWebServer} starting to accept connections")
-        acceptConnections()
-      } catch (e: Throwable) {
-        logger.log(Level.WARNING, "${this@MockWebServer}  failed unexpectedly", e)
-      }
-
-      // Release all sockets and all threads, even if any close fails.
-      serverSocket?.closeQuietly()
-
-      val openClientSocket = openClientSockets.iterator()
-      while (openClientSocket.hasNext()) {
-        openClientSocket.next().closeQuietly()
-        openClientSocket.remove()
-      }
-
-      val httpConnection = openConnections.iterator()
-      while (httpConnection.hasNext()) {
-        httpConnection.next().closeQuietly()
-        httpConnection.remove()
-      }
-      dispatcher.shutdown()
-    }
-  }
-
-  @Throws(Exception::class)
-  private fun acceptConnections() {
-    while (true) {
-      val socket: Socket
-      try {
-        socket = serverSocket!!.accept()
-      } catch (e: SocketException) {
-        logger.info("${this@MockWebServer} done accepting connections: ${e.message}")
-        return
-      }
-
-      val socketPolicy = dispatcher.peek().socketPolicy
-      if (socketPolicy === DISCONNECT_AT_START) {
-        dispatchBookkeepingRequest(0, socket)
-        socket.close()
-      } else {
-        openClientSockets.add(socket)
-        serveConnection(socket)
-      }
-    }
-  }
-
-  @Synchronized
-  @Throws(IOException::class)
-  fun shutdown() {
-    if (!started) return
-    require(serverSocket != null) { "shutdown() before start()" }
-
-    // Cause acceptConnections() to break out.
-    serverSocket!!.close()
-
-    // Await shutdown.
-    for (queue in taskRunner.activeQueues()) {
-      if (!queue.awaitIdle(TimeUnit.SECONDS.toNanos(5))) {
-        throw IOException("Gave up waiting for queue to shut down")
-      }
-    }
-    taskRunnerBackend.shutdown()
-  }
-
-  @Synchronized override fun after() {
-    try {
-      shutdown()
-    } catch (e: IOException) {
-      logger.log(Level.WARNING, "MockWebServer shutdown failed", e)
-    }
-  }
-
-  private fun serveConnection(raw: Socket) {
-    taskRunner.newQueue().execute("MockWebServer ${raw.remoteSocketAddress}", cancelable = false) {
-      try {
-        SocketHandler(raw).handle()
-      } catch (e: IOException) {
-        logger.info("${this@MockWebServer} connection from ${raw.inetAddress} failed: $e")
-      } catch (e: Exception) {
-        logger.log(Level.SEVERE,
-            "${this@MockWebServer} connection from ${raw.inetAddress} crashed", e)
-      }
-    }
-  }
-
-  internal inner class SocketHandler(private val raw: Socket) {
-    private var sequenceNumber = 0
-
-    @Throws(Exception::class)
-    fun handle() {
-      val socketPolicy = dispatcher.peek().socketPolicy
-      var protocol = Protocol.HTTP_1_1
-      val socket: Socket
-      when {
-        sslSocketFactory != null -> {
-          if (tunnelProxy) {
-            createTunnel()
-          }
-          if (socketPolicy === FAIL_HANDSHAKE) {
-            dispatchBookkeepingRequest(sequenceNumber, raw)
-            processHandshakeFailure(raw)
-            return
-          }
-          socket = sslSocketFactory!!.createSocket(raw, raw.inetAddress.hostAddress,
-              raw.port, true)
-          val sslSocket = socket as SSLSocket
-          sslSocket.useClientMode = false
-          if (clientAuth == CLIENT_AUTH_REQUIRED) {
-            sslSocket.needClientAuth = true
-          } else if (clientAuth == CLIENT_AUTH_REQUESTED) {
-            sslSocket.wantClientAuth = true
-          }
-          openClientSockets.add(socket)
-
-          if (protocolNegotiationEnabled) {
-            Platform.get().configureTlsExtensions(sslSocket, protocols)
-          }
-
-          sslSocket.startHandshake()
-
-          if (protocolNegotiationEnabled) {
-            val protocolString = Platform.get().getSelectedProtocol(sslSocket)
-            protocol =
-                if (protocolString != null) Protocol.get(protocolString) else Protocol.HTTP_1_1
-            Platform.get().afterHandshake(sslSocket)
-          }
-          openClientSockets.remove(raw)
-        }
-        Protocol.H2_PRIOR_KNOWLEDGE in protocols -> {
-          socket = raw
-          protocol = Protocol.H2_PRIOR_KNOWLEDGE
-        }
-        else -> socket = raw
-      }
-
-      if (socketPolicy === STALL_SOCKET_AT_START) {
-        return // Ignore the socket until the server is shut down!
-      }
-
-      if (protocol === Protocol.HTTP_2 || protocol === Protocol.H2_PRIOR_KNOWLEDGE) {
-        val http2SocketHandler = Http2SocketHandler(socket, protocol)
-        val connection = Http2Connection.Builder(false, taskRunner)
-            .socket(socket)
-            .listener(http2SocketHandler)
-            .build()
-        connection.start()
-        openConnections.add(connection)
-        openClientSockets.remove(socket)
-        return
-      } else if (protocol !== Protocol.HTTP_1_1) {
-        throw AssertionError()
-      }
-
-      val source = socket.source().buffer()
-      val sink = socket.sink().buffer()
-
-      while (processOneRequest(socket, source, sink)) {
-      }
-
-      if (sequenceNumber == 0) {
-        logger.warning(
-            "${this@MockWebServer} connection from ${raw.inetAddress} didn't make a request")
-      }
-
-      socket.close()
-      openClientSockets.remove(socket)
-    }
-
-    /**
-     * Respond to CONNECT requests until a SWITCH_TO_SSL_AT_END response is
-     * dispatched.
-     */
-    @Throws(IOException::class, InterruptedException::class)
-    private fun createTunnel() {
-      val source = raw.source().buffer()
-      val sink = raw.sink().buffer()
-      while (true) {
-        val socketPolicy = dispatcher.peek().socketPolicy
-        check(processOneRequest(raw, source, sink)) { "Tunnel without any CONNECT!" }
-        if (socketPolicy === UPGRADE_TO_SSL_AT_END) return
-      }
-    }
-
-    /**
-     * Reads a request and writes its response. Returns true if further calls should be attempted
-     * on the socket.
-     */
-    @Throws(IOException::class, InterruptedException::class)
-    private fun processOneRequest(
-      socket: Socket,
-      source: BufferedSource,
-      sink: BufferedSink
-    ): Boolean {
-      if (source.exhausted()) {
-        return false // No more requests on this socket.
-      }
-
-      val request = readRequest(socket, source, sink, sequenceNumber)
-      atomicRequestCount.incrementAndGet()
-      requestQueue.add(request)
-
-      if (request.failure != null) {
-        return false // Nothing to respond to.
-      }
-
-      val response = dispatcher.dispatch(request)
-      if (response.socketPolicy === DISCONNECT_AFTER_REQUEST) {
-        socket.close()
-        return false
-      }
-      if (response.socketPolicy === NO_RESPONSE) {
-        // This read should block until the socket is closed. (Because nobody is writing.)
-        if (source.exhausted()) return false
-        throw ProtocolException("unexpected data")
-      }
-
-      var reuseSocket = true
-      val requestWantsWebSockets = "Upgrade".equals(request.getHeader("Connection"),
-          ignoreCase = true) && "websocket".equals(request.getHeader("Upgrade"),
-          ignoreCase = true)
-      val responseWantsWebSockets = response.webSocketListener != null
-      if (requestWantsWebSockets && responseWantsWebSockets) {
-        handleWebSocketUpgrade(socket, source, sink, request, response)
-        reuseSocket = false
-      } else {
-        writeHttpResponse(socket, sink, response)
-      }
-
-      if (logger.isLoggable(Level.INFO)) {
-        logger.info(
-            "${this@MockWebServer} received request: $request and responded: $response")
-      }
-
-      // See warnings associated with these socket policies in SocketPolicy.
-      when (response.socketPolicy) {
-        DISCONNECT_AT_END -> {
-          socket.close()
-          return false
-        }
-        SHUTDOWN_INPUT_AT_END -> socket.shutdownInput()
-        SHUTDOWN_OUTPUT_AT_END -> socket.shutdownOutput()
-        SHUTDOWN_SERVER_AFTER_RESPONSE -> shutdown()
-        else -> {
-        }
-      }
-      sequenceNumber++
-      return reuseSocket
-    }
-  }
-
-  @Throws(Exception::class)
-  private fun processHandshakeFailure(raw: Socket) {
-    val context = SSLContext.getInstance("TLS")
-    context.init(null, arrayOf<TrustManager>(UNTRUSTED_TRUST_MANAGER), SecureRandom())
-    val sslSocketFactory = context.socketFactory
-    val socket = sslSocketFactory.createSocket(
-        raw, raw.inetAddress.hostAddress, raw.port, true) as SSLSocket
-    try {
-      socket.startHandshake() // we're testing a handshake failure
-      throw AssertionError()
-    } catch (expected: IOException) {
-    }
-    socket.close()
-  }
-
-  @Throws(InterruptedException::class)
-  private fun dispatchBookkeepingRequest(sequenceNumber: Int, socket: Socket) {
-    val request = RecordedRequest(
-        "", headersOf(), emptyList(), 0L, Buffer(), sequenceNumber, socket)
-    atomicRequestCount.incrementAndGet()
-    requestQueue.add(request)
-    dispatcher.dispatch(request)
-  }
-
-  /** @param sequenceNumber the index of this request on this connection.*/
-  @Throws(IOException::class)
-  private fun readRequest(
-    socket: Socket,
-    source: BufferedSource,
-    sink: BufferedSink,
-    sequenceNumber: Int
-  ): RecordedRequest {
-    var request = ""
-    val headers = Headers.Builder()
-    var contentLength = -1L
-    var chunked = false
-    var expectContinue = false
-    val requestBody = TruncatingBuffer(bodyLimit)
-    val chunkSizes = mutableListOf<Int>()
-    var failure: IOException? = null
-
-    try {
-      request = source.readUtf8LineStrict()
-      if (request.isEmpty()) {
-        throw ProtocolException("no request because the stream is exhausted")
-      }
-
-      while (true) {
-        val header = source.readUtf8LineStrict()
-        if (header.isEmpty()) {
-          break
-        }
-        addHeaderLenient(headers, header)
-        val lowercaseHeader = header.toLowerCase(Locale.US)
-        if (contentLength == -1L && lowercaseHeader.startsWith("content-length:")) {
-          contentLength = header.substring(15).trim().toLong()
-        }
-        if (lowercaseHeader.startsWith("transfer-encoding:") && lowercaseHeader.substring(
-                18).trim() == "chunked") {
-          chunked = true
-        }
-        if (lowercaseHeader.startsWith("expect:") && lowercaseHeader.substring(
-                7).trim().equals("100-continue", ignoreCase = true)) {
-          expectContinue = true
-        }
-      }
-
-      val socketPolicy = dispatcher.peek().socketPolicy
-      if (expectContinue && socketPolicy === EXPECT_CONTINUE || socketPolicy === CONTINUE_ALWAYS) {
-        sink.writeUtf8("HTTP/1.1 100 Continue\r\n")
-        sink.writeUtf8("Content-Length: 0\r\n")
-        sink.writeUtf8("\r\n")
-        sink.flush()
-      }
-
-      var hasBody = false
-      val policy = dispatcher.peek()
-      if (contentLength != -1L) {
-        hasBody = contentLength > 0L
-        throttledTransfer(policy, socket, source, requestBody.buffer(), contentLength, true)
-      } else if (chunked) {
-        hasBody = true
-        while (true) {
-          val chunkSize = source.readUtf8LineStrict().trim().toInt(16)
-          if (chunkSize == 0) {
-            readEmptyLine(source)
-            break
-          }
-          chunkSizes.add(chunkSize)
-          throttledTransfer(policy, socket, source,
-              requestBody.buffer(), chunkSize.toLong(), true)
-          readEmptyLine(source)
-        }
-      }
-
-      val method = request.substringBefore(' ')
-      require(!hasBody || HttpMethod.permitsRequestBody(method)) {
-        "Request must not have a body: $request"
-      }
-    } catch (e: IOException) {
-      failure = e
-    }
-
-    return RecordedRequest(request, headers.build(), chunkSizes, requestBody.receivedByteCount,
-        requestBody.buffer, sequenceNumber, socket, failure)
-  }
-
-  @Throws(IOException::class)
-  private fun handleWebSocketUpgrade(
-    socket: Socket,
-    source: BufferedSource,
-    sink: BufferedSink,
-    request: RecordedRequest,
-    response: MockResponse
-  ) {
-    val key = request.getHeader("Sec-WebSocket-Key")
-    response.setHeader("Sec-WebSocket-Accept", WebSocketProtocol.acceptHeader(key!!))
-
-    writeHttpResponse(socket, sink, response)
-
-    // Adapt the request and response into our Request and Response domain model.
-    val scheme = if (request.tlsVersion != null) "https" else "http"
-    val authority = request.getHeader("Host") // Has host and port.
-    val fancyRequest = Request.Builder()
-        .url("$scheme://$authority/")
-        .headers(request.headers)
-        .build()
-    val statusParts = response.status.split(' ', limit = 3)
-    val fancyResponse = Response.Builder()
-        .code(statusParts[1].toInt())
-        .message(statusParts[2])
-        .headers(response.headers)
-        .request(fancyRequest)
-        .protocol(Protocol.HTTP_1_1)
-        .build()
-
-    val connectionClose = CountDownLatch(1)
-    val streams = object : RealWebSocket.Streams(false, source, sink) {
-      override fun close() = connectionClose.countDown()
-    }
-    val webSocket = RealWebSocket(
-        taskRunner = taskRunner,
-        originalRequest = fancyRequest,
-        listener = response.webSocketListener!!,
-        random = SecureRandom(),
-        pingIntervalMillis = 0
-    )
-    response.webSocketListener!!.onOpen(webSocket, fancyResponse)
-    val name = "MockWebServer WebSocket ${request.path!!}"
-    webSocket.initReaderAndWriter(name, streams)
-    try {
-      webSocket.loopReader()
-
-      // Even if messages are no longer being read we need to wait for the connection close signal.
-      connectionClose.await()
-    } catch (e: IOException) {
-      webSocket.failWebSocket(e, null)
-    } finally {
-      source.closeQuietly()
-    }
-  }
-
-  @Throws(IOException::class)
-  private fun writeHttpResponse(socket: Socket, sink: BufferedSink, response: MockResponse) {
-    sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS))
-    sink.writeUtf8(response.status)
-    sink.writeUtf8("\r\n")
-
-    writeHeaders(sink, response.headers)
-
-    val body = response.getBody() ?: return
-    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS))
-    throttledTransfer(response, socket, body, sink, body.size, false)
-
-    if ("chunked".equals(response.headers["Transfer-Encoding"], ignoreCase = true)) {
-      writeHeaders(sink, response.trailers)
-    }
-  }
-
-  @Throws(IOException::class)
-  private fun writeHeaders(sink: BufferedSink, headers: Headers) {
-    for ((name, value) in headers) {
-      sink.writeUtf8(name)
-      sink.writeUtf8(": ")
-      sink.writeUtf8(value)
-      sink.writeUtf8("\r\n")
-    }
-    sink.writeUtf8("\r\n")
-    sink.flush()
-  }
-
-  private fun sleepIfDelayed(delayMs: Long) {
-    if (delayMs != 0L) {
-      Thread.sleep(delayMs)
-    }
-  }
-
-  /**
-   * Transfer bytes from [source] to [sink] until either [byteCount] bytes have
-   * been transferred or [source] is exhausted. The transfer is throttled according to [policy].
-   */
-  @Throws(IOException::class)
-  private fun throttledTransfer(
-    policy: MockResponse,
-    socket: Socket,
-    source: BufferedSource,
-    sink: BufferedSink,
-    byteCount: Long,
-    isRequest: Boolean
-  ) {
-    var byteCountNum = byteCount
-    if (byteCountNum == 0L) return
-
-    val buffer = Buffer()
-    val bytesPerPeriod = policy.throttleBytesPerPeriod
-    val periodDelayMs = policy.getThrottlePeriod(TimeUnit.MILLISECONDS)
-
-    val halfByteCount = byteCountNum / 2
-    val disconnectHalfway = if (isRequest) {
-      policy.socketPolicy === DISCONNECT_DURING_REQUEST_BODY
-    } else {
-      policy.socketPolicy === DISCONNECT_DURING_RESPONSE_BODY
-    }
-
-    while (!socket.isClosed) {
-      var b = 0L
-      while (b < bytesPerPeriod) {
-        // Ensure we do not read past the allotted bytes in this period.
-        var toRead = minOf(byteCountNum, bytesPerPeriod - b)
-        // Ensure we do not read past halfway if the policy will kill the connection.
-        if (disconnectHalfway) {
-          toRead = minOf(toRead, byteCountNum - halfByteCount)
-        }
-
-        val read = source.read(buffer, toRead)
-        if (read == -1L) return
-
-        sink.write(buffer, read)
-        sink.flush()
-        b += read
-        byteCountNum -= read
-
-        if (disconnectHalfway && byteCountNum == halfByteCount) {
-          socket.close()
-          return
-        }
-
-        if (byteCountNum == 0L) return
-      }
-
-      if (periodDelayMs != 0L) {
-        Thread.sleep(periodDelayMs)
-      }
-    }
-  }
-
-  @Throws(IOException::class)
-  private fun readEmptyLine(source: BufferedSource) {
-    val line = source.readUtf8LineStrict()
-    check(line.isEmpty()) { "Expected empty but was: $line" }
-  }
-
-  override fun toString(): String = "MockWebServer[$portField]"
-
-  @Throws(IOException::class)
-  override fun close() = shutdown()
-
-  /** A buffer wrapper that drops data after [bodyLimit] bytes. */
-  private class TruncatingBuffer internal constructor(
-    private var remainingByteCount: Long
-  ) : Sink {
-    internal val buffer = Buffer()
-    internal var receivedByteCount = 0L
-
-    @Throws(IOException::class)
-    override fun write(source: Buffer, byteCount: Long) {
-      val toRead = minOf(remainingByteCount, byteCount)
-      if (toRead > 0L) {
-        source.read(buffer, toRead)
-      }
-      val toSkip = byteCount - toRead
-      if (toSkip > 0L) {
-        source.skip(toSkip)
-      }
-      remainingByteCount -= toRead
-      receivedByteCount += byteCount
-    }
-
-    @Throws(IOException::class)
-    override fun flush() {
-    }
-
-    override fun timeout(): Timeout = Timeout.NONE
-
-    @Throws(IOException::class)
-    override fun close() {
-    }
-  }
-
-  /** Processes HTTP requests layered over HTTP/2. */
-  private inner class Http2SocketHandler constructor(
-    private val socket: Socket,
-    private val protocol: Protocol
-  ) : Http2Connection.Listener() {
-    private val sequenceNumber = AtomicInteger()
-
-    @Throws(IOException::class)
-    override fun onStream(stream: Http2Stream) {
-      val peekedResponse = dispatcher.peek()
-      if (peekedResponse.socketPolicy === RESET_STREAM_AT_START) {
-        dispatchBookkeepingRequest(sequenceNumber.getAndIncrement(), socket)
-        stream.close(ErrorCode.fromHttp2(peekedResponse.http2ErrorCode)!!, null)
-        return
-      }
-
-      val request = readRequest(stream)
-      atomicRequestCount.incrementAndGet()
-      requestQueue.add(request)
-      if (request.failure != null) {
-        return // Nothing to respond to.
-      }
-
-      val response: MockResponse = dispatcher.dispatch(request)
-
-      if (response.socketPolicy === DISCONNECT_AFTER_REQUEST) {
-        socket.close()
-        return
-      }
-      writeResponse(stream, request, response)
-      if (logger.isLoggable(Level.INFO)) {
-        logger.info(
-            "${this@MockWebServer} received request: $request " +
-                "and responded: $response protocol is $protocol")
-      }
-
-      if (response.socketPolicy === DISCONNECT_AT_END) {
-        val connection = stream.connection
-        connection.shutdown(ErrorCode.NO_ERROR)
-      }
-    }
-
-    @Throws(IOException::class)
-    private fun readRequest(stream: Http2Stream): RecordedRequest {
-      val streamHeaders = stream.takeHeaders()
-      val httpHeaders = Headers.Builder()
-      var method = "<:method omitted>"
-      var path = "<:path omitted>"
-      var readBody = true
-      for ((name, value) in streamHeaders) {
-        if (name == Header.TARGET_METHOD_UTF8) {
-          method = value
-        } else if (name == Header.TARGET_PATH_UTF8) {
-          path = value
-        } else if (protocol === Protocol.HTTP_2 || protocol === Protocol.H2_PRIOR_KNOWLEDGE) {
-          httpHeaders.add(name, value)
-        } else {
-          throw IllegalStateException()
-        }
-        if (name == "expect" && value.equals("100-continue", ignoreCase = true)) {
-          // Don't read the body unless we've invited the client to send it.
-          readBody = false
-        }
-      }
-      val headers = httpHeaders.build()
-
-      val peek = dispatcher.peek()
-      if (!readBody && peek.socketPolicy === EXPECT_CONTINUE) {
-        val continueHeaders =
-            listOf(Header(Header.RESPONSE_STATUS, "100 Continue".encodeUtf8()))
-        stream.writeHeaders(continueHeaders, outFinished = false, flushHeaders = true)
-        stream.connection.flush()
-        readBody = true
-      }
-
-      val body = Buffer()
-      val requestLine = "$method $path HTTP/1.1"
-      var exception: IOException? = null
-      if (readBody && !peek.isDuplex) {
-        try {
-          val contentLengthString = headers["content-length"]
-          val byteCount = contentLengthString?.toLong() ?: Long.MAX_VALUE
-          throttledTransfer(peek, socket, stream.getSource().buffer(),
-              body, byteCount, true)
-        } catch (e: IOException) {
-          exception = e
-        }
-      }
-
-      return RecordedRequest(requestLine, headers, emptyList(), body.size, body,
-          sequenceNumber.getAndIncrement(), socket, exception)
-    }
-
-    @Throws(IOException::class)
-    private fun writeResponse(
-      stream: Http2Stream,
-      request: RecordedRequest,
-      response: MockResponse
-    ) {
-      val settings = response.settings
-      stream.connection.setSettings(settings)
-
-      if (response.socketPolicy === NO_RESPONSE) {
-        return
-      }
-      val http2Headers = mutableListOf<Header>()
-      val statusParts = response.status.split(' ', limit = 3)
-
-      if (statusParts.size < 2) {
-        throw AssertionError("Unexpected status: ${response.status}")
-      }
-      // TODO: constants for well-known header names.
-      http2Headers.add(Header(Header.RESPONSE_STATUS, statusParts[1]))
-      val headers = response.headers
-      for ((name, value) in headers) {
-        http2Headers.add(Header(name, value))
-      }
-      val trailers = response.trailers
-
-      sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS))
-
-      val body = response.getBody()
-      val outFinished = (body == null &&
-          response.pushPromises.isEmpty() &&
-          !response.isDuplex)
-      val flushHeaders = body == null
-      require(!outFinished || trailers.size == 0) {
-        "unsupported: no body and non-empty trailers $trailers"
-      }
-      stream.writeHeaders(http2Headers, outFinished, flushHeaders)
-      if (trailers.size > 0) {
-        stream.enqueueTrailers(trailers)
-      }
-      pushPromises(stream, request, response.pushPromises)
-      if (body != null) {
-        stream.getSink().buffer().use { sink ->
-          sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS))
-          throttledTransfer(response, socket, body, sink, body.size, false)
-        }
-      } else if (response.isDuplex) {
-        stream.getSink().buffer().use { sink ->
-          stream.getSource().buffer().use { source ->
-            val duplexResponseBody = response.duplexResponseBody
-            duplexResponseBody!!.onRequest(request, source, sink)
-          }
-        }
-      } else if (!outFinished) {
-        stream.close(ErrorCode.NO_ERROR, null)
-      }
-    }
-
-    @Throws(IOException::class)
-    private fun pushPromises(
-      stream: Http2Stream,
-      request: RecordedRequest,
-      promises: List<PushPromise>
-    ) {
-      for (pushPromise in promises) {
-        val pushedHeaders = mutableListOf<Header>()
-        pushedHeaders.add(Header(Header.TARGET_AUTHORITY, url(pushPromise.path).host))
-        pushedHeaders.add(Header(Header.TARGET_METHOD, pushPromise.method))
-        pushedHeaders.add(Header(Header.TARGET_PATH, pushPromise.path))
-        val pushPromiseHeaders = pushPromise.headers
-        for ((name, value) in pushPromiseHeaders) {
-          pushedHeaders.add(Header(name, value))
-        }
-        val requestLine = "${pushPromise.method} ${pushPromise.path} HTTP/1.1"
-        val chunkSizes = emptyList<Int>() // No chunked encoding for HTTP/2.
-        requestQueue.add(RecordedRequest(requestLine, pushPromise.headers, chunkSizes, 0,
-            Buffer(), sequenceNumber.getAndIncrement(), socket))
-        val hasBody = pushPromise.response.getBody() != null
-        val pushedStream = stream.connection.pushStream(stream.id, pushedHeaders, hasBody)
-        writeResponse(pushedStream, request, pushPromise.response)
-      }
-    }
-  }
-
-  companion object {
-    init {
-      MwsDuplexAccess.instance = object : MwsDuplexAccess() {
-        override fun setBody(
-          mockResponse: MockResponse,
-          duplexResponseBody: DuplexResponseBody
-        ) {
-          mockResponse.setBody(duplexResponseBody)
-        }
-      }
-    }
-
-    private const val CLIENT_AUTH_NONE = 0
-    private const val CLIENT_AUTH_REQUESTED = 1
-    private const val CLIENT_AUTH_REQUIRED = 2
-
-    private val UNTRUSTED_TRUST_MANAGER = object : X509TrustManager {
-      @Throws(CertificateException::class)
-      override fun checkClientTrusted(
-        chain: Array<X509Certificate>,
-        authType: String
-      ) = throw CertificateException()
-
-      override fun checkServerTrusted(
-        chain: Array<X509Certificate>,
-        authType: String
-      ) = throw AssertionError()
-
-      override fun getAcceptedIssuers(): Array<X509Certificate> = throw AssertionError()
-    }
-
-    private val logger = Logger.getLogger(MockWebServer::class.java.name)
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.kt
deleted file mode 100644
index fe078a79c9..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver
-
-import okhttp3.Headers
-
-/** An HTTP request initiated by the server. */
-class PushPromise(
-  @get:JvmName("method") val method: String,
-  @get:JvmName("path") val path: String,
-  @get:JvmName("headers") val headers: Headers,
-  @get:JvmName("response") val response: MockResponse
-) {
-
-  @JvmName("-deprecated_method")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "method"),
-      level = DeprecationLevel.ERROR)
-  fun method() = method
-
-  @JvmName("-deprecated_path")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "path"),
-      level = DeprecationLevel.ERROR)
-  fun path() = path
-
-  @JvmName("-deprecated_headers")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "headers"),
-      level = DeprecationLevel.ERROR)
-  fun headers() = headers
-
-  @JvmName("-deprecated_response")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "response"),
-      level = DeprecationLevel.ERROR)
-  fun response() = response
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.kt
deleted file mode 100644
index 557567156e..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.kt
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver
-
-import java.net.HttpURLConnection
-import java.net.HttpURLConnection.HTTP_UNAVAILABLE
-import java.util.concurrent.BlockingQueue
-import java.util.concurrent.LinkedBlockingQueue
-import java.util.logging.Logger
-
-/**
- * Default dispatcher that processes a script of responses. Populate the script by calling [enqueueResponse].
- */
-open class QueueDispatcher : Dispatcher() {
-  protected val responseQueue: BlockingQueue<MockResponse> = LinkedBlockingQueue()
-  private var failFastResponse: MockResponse? = null
-
-  @Throws(InterruptedException::class)
-  override fun dispatch(request: RecordedRequest): MockResponse {
-    // To permit interactive/browser testing, ignore requests for favicons.
-    val requestLine = request.requestLine
-    if (requestLine == "GET /favicon.ico HTTP/1.1") {
-      logger.info("served $requestLine")
-      return MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_FOUND)
-    }
-
-    if (failFastResponse != null && responseQueue.peek() == null) {
-      // Fail fast if there's no response queued up.
-      return failFastResponse!!
-    }
-
-    val result = responseQueue.take()
-
-    // If take() returned because we're shutting down, then enqueue another dead letter so that any
-    // other threads waiting on take() will also return.
-    if (result == DEAD_LETTER) responseQueue.add(DEAD_LETTER)
-
-    return result
-  }
-
-  override fun peek(): MockResponse {
-    return responseQueue.peek() ?: failFastResponse ?: super.peek()
-  }
-
-  open fun enqueueResponse(response: MockResponse) {
-    responseQueue.add(response)
-  }
-
-  override fun shutdown() {
-    responseQueue.add(DEAD_LETTER)
-  }
-
-  open fun setFailFast(failFast: Boolean) {
-    val failFastResponse = if (failFast) {
-      MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_FOUND)
-    } else {
-      null
-    }
-    setFailFast(failFastResponse)
-  }
-
-  open fun setFailFast(failFastResponse: MockResponse?) {
-    this.failFastResponse = failFastResponse
-  }
-
-  companion object {
-    /**
-     * Enqueued on shutdown to release threads waiting on [dispatch]. Note that this response
-     * isn't transmitted because the connection is closed before this response is returned.
-     */
-    private val DEAD_LETTER = MockResponse().apply {
-      this.status = "HTTP/1.1 $HTTP_UNAVAILABLE shutting down"
-    }
-
-    private val logger = Logger.getLogger(QueueDispatcher::class.java.name)
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt
deleted file mode 100644
index 1db64aa94a..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.mockwebserver
-
-import okhttp3.Handshake
-import okhttp3.Handshake.Companion.handshake
-import okhttp3.Headers
-import okhttp3.HttpUrl
-import okhttp3.HttpUrl.Companion.toHttpUrlOrNull
-import okhttp3.TlsVersion
-import okio.Buffer
-import java.io.IOException
-import java.net.Inet6Address
-import java.net.Socket
-import javax.net.ssl.SSLSocket
-
-/** An HTTP request that came into the mock web server. */
-class RecordedRequest @JvmOverloads constructor(
-  val requestLine: String,
-
-  /** All headers. */
-  val headers: Headers,
-
-  /**
-   * The sizes of the chunks of this request's body, or an empty list if the request's body
-   * was empty or unchunked.
-   */
-  val chunkSizes: List<Int>,
-
-  /** The total size of the body of this POST request (before truncation).*/
-  val bodySize: Long,
-
-  /** The body of this POST request. This may be truncated. */
-  val body: Buffer,
-
-  /**
-   * The index of this request on its HTTP connection. Since a single HTTP connection may serve
-   * multiple requests, each request is assigned its own sequence number.
-   */
-  val sequenceNumber: Int,
-  socket: Socket,
-
-  /**
-   * The failure MockWebServer recorded when attempting to decode this request. If, for example,
-   * the inbound request was truncated, this exception will be non-null.
-   */
-  val failure: IOException? = null
-) {
-  val method: String?
-  val path: String?
-
-  /**
-   * The TLS handshake of the connection that carried this request, or null if the request was
-   * received without TLS.
-   */
-  val handshake: Handshake?
-  val requestUrl: HttpUrl?
-
-  @get:JvmName("-deprecated_utf8Body")
-  @Deprecated(
-      message = "Use body.readUtf8()",
-      replaceWith = ReplaceWith("body.readUtf8()"),
-      level = DeprecationLevel.ERROR)
-  val utf8Body: String
-    get() = body.readUtf8()
-
-  /** Returns the connection's TLS version or null if the connection doesn't use SSL. */
-  val tlsVersion: TlsVersion?
-    get() = handshake?.tlsVersion
-
-  init {
-    if (socket is SSLSocket) {
-      try {
-        this.handshake = socket.session.handshake()
-      } catch (e: IOException) {
-        throw IllegalArgumentException(e)
-      }
-    } else {
-      this.handshake = null
-    }
-
-    if (requestLine.isNotEmpty()) {
-      val methodEnd = requestLine.indexOf(' ')
-      val pathEnd = requestLine.indexOf(' ', methodEnd + 1)
-      this.method = requestLine.substring(0, methodEnd)
-      var path = requestLine.substring(methodEnd + 1, pathEnd)
-      if (!path.startsWith("/")) {
-        path = "/"
-      }
-      this.path = path
-
-      val scheme = if (socket is SSLSocket) "https" else "http"
-      val inetAddress = socket.localAddress
-
-      var hostname = inetAddress.hostName
-      if (inetAddress is Inet6Address && hostname.contains(':')) {
-        // hostname is likely some form representing the IPv6 bytes
-        // 2001:0db8:85a3:0000:0000:8a2e:0370:7334
-        // 2001:db8:85a3::8a2e:370:7334
-        // ::1
-        hostname = "[$hostname]"
-      }
-
-      val localPort = socket.localPort
-      // Allow null in failure case to allow for testing bad requests
-      this.requestUrl = "$scheme://$hostname:$localPort$path".toHttpUrlOrNull()
-    } else {
-      this.requestUrl = null
-      this.method = null
-      this.path = null
-    }
-  }
-
-  @Deprecated(
-      message = "Use body.readUtf8()",
-      replaceWith = ReplaceWith("body.readUtf8()"),
-      level = DeprecationLevel.WARNING)
-  fun getUtf8Body(): String = body.readUtf8()
-
-  /** Returns the first header named [name], or null if no such header exists. */
-  fun getHeader(name: String): String? = headers.values(name).firstOrNull()
-
-  override fun toString(): String = requestLine
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.kt
deleted file mode 100644
index 60f26e5fdc..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.kt
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.mockwebserver
-
-/**
- * What should be done with the incoming socket.
- *
- * Be careful when using values like [DISCONNECT_AT_END], [SHUTDOWN_INPUT_AT_END]
- * and [SHUTDOWN_OUTPUT_AT_END] that close a socket after a response, and where there are
- * follow-up requests. The client is unblocked and free to continue as soon as it has received the
- * entire response body. If and when the client makes a subsequent request using a pooled socket the
- * server may not have had time to close the socket. The socket will be closed at an indeterminate
- * point before or during the second request. It may be closed after client has started sending the
- * request body. If a request body is not retryable then the client may fail the request, making
- * client behavior non-deterministic. Add delays in the client to improve the chances that the
- * server has closed the socket before follow up requests are made.
- */
-enum class SocketPolicy {
-
-  /**
-   * Shutdown [MockWebServer] after writing response.
-   */
-  SHUTDOWN_SERVER_AFTER_RESPONSE,
-
-  /**
-   * Keep the socket open after the response. This is the default HTTP/1.1 behavior.
-   */
-  KEEP_OPEN,
-
-  /**
-   * Close the socket after the response. This is the default HTTP/1.0 behavior. For HTTP/2
-   * connections, this sends a [GOAWAYframe](https://tools.ietf.org/html/rfc7540#section-6.8)
-   * immediately after the response and will close the connection when the client's socket
-   * is exhausted.
-   *
-   * See [SocketPolicy] for reasons why this can cause test flakiness and how to avoid it.
-   */
-  DISCONNECT_AT_END,
-
-  /**
-   * Wrap the socket with SSL at the completion of this request/response pair. Used for CONNECT
-   * messages to tunnel SSL over an HTTP proxy.
-   */
-  UPGRADE_TO_SSL_AT_END,
-
-  /**
-   * Request immediate close of connection without even reading the request. Use to simulate buggy
-   * SSL servers closing connections in response to unrecognized TLS extensions.
-   */
-  DISCONNECT_AT_START,
-
-  /**
-   * Close connection after reading the request but before writing the response. Use this to
-   * simulate late connection pool failures.
-   */
-  DISCONNECT_AFTER_REQUEST,
-
-  /** Close connection after reading half of the request body (if present). */
-  DISCONNECT_DURING_REQUEST_BODY,
-
-  /** Close connection after writing half of the response body (if present). */
-  DISCONNECT_DURING_RESPONSE_BODY,
-
-  /** Don't trust the client during the SSL handshake. */
-  FAIL_HANDSHAKE,
-
-  /**
-   * Shutdown the socket input after sending the response. For testing bad behavior.
-   *
-   * See [SocketPolicy] for reasons why this can cause test flakiness and how to avoid it.
-   */
-  SHUTDOWN_INPUT_AT_END,
-
-  /**
-   * Shutdown the socket output after sending the response. For testing bad behavior.
-   *
-   * See [SocketPolicy] for reasons why this can cause test flakiness and how to avoid it.
-   */
-  SHUTDOWN_OUTPUT_AT_END,
-
-  /**
-   * After accepting the connection and doing TLS (if configured) don't do HTTP/1.1 or HTTP/2
-   * framing. Ignore the socket completely until the server is shut down.
-   */
-  STALL_SOCKET_AT_START,
-
-  /**
-   * Read the request but don't respond to it. Just keep the socket open. For testing read response
-   * header timeout issue.
-   */
-  NO_RESPONSE,
-
-  /**
-   * Fail HTTP/2 requests without processing them by sending an [MockResponse.getHttp2ErrorCode].
-   */
-  RESET_STREAM_AT_START,
-
-  /**
-   * Transmit a `HTTP/1.1 100 Continue` response before reading the HTTP request body.
-   * Typically this response is sent when a client makes a request with the header `Expect: 100-continue`.
-   */
-  EXPECT_CONTINUE,
-
-  /**
-   * Transmit a `HTTP/1.1 100 Continue` response before reading the HTTP request body even
-   * if the client does not send the header `Expect: 100-continue` in its request.
-   */
-  CONTINUE_ALWAYS
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/DuplexResponseBody.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/DuplexResponseBody.kt
deleted file mode 100644
index 4fc74a497a..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/DuplexResponseBody.kt
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver.internal.duplex
-
-import okhttp3.mockwebserver.RecordedRequest
-import okio.BufferedSink
-import okio.BufferedSource
-import java.io.IOException
-
-interface DuplexResponseBody {
-  @Throws(IOException::class)
-  fun onRequest(request: RecordedRequest, requestBody: BufferedSource, responseBody: BufferedSink)
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/MockDuplexResponseBody.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/MockDuplexResponseBody.kt
deleted file mode 100644
index 88ea4d8595..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/MockDuplexResponseBody.kt
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver.internal.duplex
-
-import okhttp3.mockwebserver.RecordedRequest
-import okio.BufferedSink
-import okio.BufferedSource
-import okio.utf8Size
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertTrue
-import org.junit.Assert.fail
-import java.io.IOException
-import java.util.concurrent.CountDownLatch
-import java.util.concurrent.FutureTask
-import java.util.concurrent.LinkedBlockingQueue
-import java.util.concurrent.TimeUnit
-
-private typealias Action = (RecordedRequest, BufferedSource, BufferedSink) -> Unit
-
-/**
- * A scriptable request/response conversation. Create the script by calling methods like
- * [receiveRequest] in the sequence they are run.
- */
-class MockDuplexResponseBody : DuplexResponseBody {
-  private val actions = LinkedBlockingQueue<Action>()
-  private val results = LinkedBlockingQueue<FutureTask<Void>>()
-
-  fun receiveRequest(expected: String) = apply {
-    actions += { _, requestBody, _ ->
-      assertEquals(expected, requestBody.readUtf8(expected.utf8Size()))
-    }
-  }
-
-  fun exhaustRequest() = apply {
-    actions += { _, requestBody, _ -> assertTrue(requestBody.exhausted()) }
-  }
-
-  fun requestIOException() = apply {
-    actions += { _, requestBody, _ ->
-      try {
-        requestBody.exhausted()
-        fail()
-      } catch (expected: IOException) {
-      }
-    }
-  }
-
-  @JvmOverloads fun sendResponse(
-    s: String,
-    responseSent: CountDownLatch = CountDownLatch(0)
-  ) = apply {
-    actions += { _, _, responseBody ->
-      responseBody.writeUtf8(s)
-      responseBody.flush()
-      responseSent.countDown()
-    }
-  }
-
-  fun exhaustResponse() = apply {
-    actions += { _, _, responseBody -> responseBody.close() }
-  }
-
-  fun sleep(duration: Long, unit: TimeUnit) = apply {
-    actions += { _, _, _ -> Thread.sleep(unit.toMillis(duration)) }
-  }
-
-  override fun onRequest(
-    request: RecordedRequest,
-    requestBody: BufferedSource,
-    responseBody: BufferedSink
-  ) {
-    val futureTask = FutureTask<Void> {
-      while (true) {
-        val action = actions.poll() ?: break
-        action(request, requestBody, responseBody)
-      }
-      return@FutureTask null
-    }
-    results.add(futureTask)
-    futureTask.run()
-  }
-
-  /** Returns once the duplex conversation completes successfully. */
-  fun awaitSuccess() {
-    val futureTask = results.poll(5, TimeUnit.SECONDS)
-        ?: throw AssertionError("no onRequest call received")
-    futureTask.get(5, TimeUnit.SECONDS)
-  }
-}
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
deleted file mode 100644
index 39b5df5d11..0000000000
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.Timeout;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class CustomDispatcherTest {
-  @Rule public MockWebServer mockWebServer = new MockWebServer();
-
-  @Rule public Timeout globalTimeout = Timeout.seconds(30);
-
-  @Test public void simpleDispatch() throws Exception {
-    final List<RecordedRequest> requestsMade = new ArrayList<>();
-    final Dispatcher dispatcher = new Dispatcher() {
-      @Override
-      public MockResponse dispatch(RecordedRequest request) {
-        requestsMade.add(request);
-        return new MockResponse();
-      }
-    };
-    assertThat(requestsMade.size()).isEqualTo(0);
-    mockWebServer.setDispatcher(dispatcher);
-    final URL url = mockWebServer.url("/").url();
-    final HttpURLConnection conn = (HttpURLConnection) url.openConnection();
-    conn.getResponseCode(); // Force the connection to hit the "server".
-    // Make sure our dispatcher got the request.
-    assertThat(requestsMade.size()).isEqualTo(1);
-  }
-
-  @Test public void outOfOrderResponses() throws Exception {
-    AtomicInteger firstResponseCode = new AtomicInteger();
-    AtomicInteger secondResponseCode = new AtomicInteger();
-    final String secondRequest = "/bar";
-    final String firstRequest = "/foo";
-    final CountDownLatch latch = new CountDownLatch(1);
-    final Dispatcher dispatcher = new Dispatcher() {
-      @Override
-      public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
-        if (request.getPath().equals(firstRequest)) {
-          latch.await();
-        }
-        return new MockResponse();
-      }
-    };
-    mockWebServer.setDispatcher(dispatcher);
-    final Thread startsFirst = buildRequestThread(firstRequest, firstResponseCode);
-    startsFirst.start();
-    final Thread endsFirst = buildRequestThread(secondRequest, secondResponseCode);
-    endsFirst.start();
-    endsFirst.join();
-    // First response is still waiting.
-    assertThat(firstResponseCode.get()).isEqualTo(0);
-    // Second response is done.
-    assertThat(secondResponseCode.get()).isEqualTo(200);
-    latch.countDown();
-    startsFirst.join();
-    // And now it's done!
-    assertThat(firstResponseCode.get()).isEqualTo(200);
-    // (Still done).
-    assertThat(secondResponseCode.get()).isEqualTo(200);
-  }
-
-  private Thread buildRequestThread(String path, AtomicInteger responseCode) {
-    return new Thread(() -> {
-      URL url = mockWebServer.url(path).url();
-      HttpURLConnection conn;
-      try {
-        conn = (HttpURLConnection) url.openConnection();
-        responseCode.set(conn.getResponseCode()); // Force the connection to hit the "server".
-      } catch (IOException ignored) {
-      }
-    });
-  }
-}
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
deleted file mode 100644
index 2f09a8201e..0000000000
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ /dev/null
@@ -1,599 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver;
-
-import java.io.BufferedReader;
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.net.ConnectException;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.SocketTimeoutException;
-import java.net.URL;
-import java.net.URLConnection;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import javax.net.ssl.HttpsURLConnection;
-import okhttp3.Handshake;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.Protocol;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.tls.HandshakeCertificates;
-import okhttp3.tls.HeldCertificate;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.Timeout;
-import org.junit.runner.Description;
-import org.junit.runners.model.Statement;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static java.util.Arrays.asList;
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeFalse;
-
-@SuppressWarnings({"ArraysAsListWithZeroOrOneArgument", "deprecation"})
-public final class MockWebServerTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  @Rule public Timeout globalTimeout = Timeout.seconds(30);
-
-  @Test public void defaultMockResponse() {
-    MockResponse response = new MockResponse();
-    assertThat(headersToList(response)).containsExactly("Content-Length: 0");
-    assertThat(response.getStatus()).isEqualTo("HTTP/1.1 200 OK");
-  }
-
-  @Test public void setResponseMockReason() {
-    String[] reasons = {
-        "Mock Response",
-        "Informational",
-        "OK",
-        "Redirection",
-        "Client Error",
-        "Server Error",
-        "Mock Response"
-    };
-    for (int i = 0; i < 600; i++) {
-      MockResponse response = new MockResponse().setResponseCode(i);
-      String expectedReason = reasons[i / 100];
-      assertThat(response.getStatus()).isEqualTo(("HTTP/1.1 " + i + " " + expectedReason));
-      assertThat(headersToList(response)).containsExactly("Content-Length: 0");
-    }
-  }
-
-  @Test public void setStatusControlsWholeStatusLine() {
-    MockResponse response = new MockResponse().setStatus("HTTP/1.1 202 That'll do pig");
-    assertThat(headersToList(response)).containsExactly("Content-Length: 0");
-    assertThat(response.getStatus()).isEqualTo("HTTP/1.1 202 That'll do pig");
-  }
-
-  @Test public void setBodyAdjustsHeaders() throws IOException {
-    MockResponse response = new MockResponse().setBody("ABC");
-    assertThat(headersToList(response)).containsExactly("Content-Length: 3");
-    assertThat(response.getBody().readUtf8()).isEqualTo("ABC");
-  }
-
-  @Test public void mockResponseAddHeader() {
-    MockResponse response = new MockResponse()
-        .clearHeaders()
-        .addHeader("Cookie: s=square")
-        .addHeader("Cookie", "a=android");
-    assertThat(headersToList(response)).containsExactly("Cookie: s=square", "Cookie: a=android");
-  }
-
-  @Test public void mockResponseSetHeader() {
-    MockResponse response = new MockResponse()
-        .clearHeaders()
-        .addHeader("Cookie: s=square")
-        .addHeader("Cookie: a=android")
-        .addHeader("Cookies: delicious");
-    response.setHeader("cookie", "r=robot");
-    assertThat(headersToList(response)).containsExactly("Cookies: delicious", "cookie: r=robot");
-  }
-
-  @Test public void mockResponseSetHeaders() {
-    MockResponse response = new MockResponse()
-        .clearHeaders()
-        .addHeader("Cookie: s=square")
-        .addHeader("Cookies: delicious");
-
-    response.setHeaders(new Headers.Builder().add("Cookie", "a=android").build());
-
-    assertThat(headersToList(response)).containsExactly("Cookie: a=android");
-  }
-
-  @Test public void regularResponse() throws Exception {
-    server.enqueue(new MockResponse().setBody("hello world"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    connection.setRequestProperty("Accept-Language", "en-US");
-    InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));
-    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
-    assertThat(reader.readLine()).isEqualTo("hello world");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestLine()).isEqualTo("GET / HTTP/1.1");
-    assertThat(request.getHeader("Accept-Language")).isEqualTo("en-US");
-
-    // Server has no more requests.
-    assertThat(server.takeRequest(100, MILLISECONDS)).isNull();
-  }
-
-  @Test public void redirect() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server.url("/new-path"))
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-    URLConnection connection = server.url("/").url().openConnection();
-    InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));
-    assertThat(reader.readLine()).isEqualTo("This is the new location!");
-
-    RecordedRequest first = server.takeRequest();
-    assertThat(first.getRequestLine()).isEqualTo("GET / HTTP/1.1");
-    RecordedRequest redirect = server.takeRequest();
-    assertThat(redirect.getRequestLine()).isEqualTo("GET /new-path HTTP/1.1");
-  }
-
-  /**
-   * Test that MockWebServer blocks for a call to enqueue() if a request is made before a mock
-   * response is ready.
-   */
-  @Test public void dispatchBlocksWaitingForEnqueue() throws Exception {
-    new Thread(() -> {
-      try {
-        Thread.sleep(1000);
-      } catch (InterruptedException ignored) {
-      }
-      server.enqueue(new MockResponse().setBody("enqueued in the background"));
-    }).start();
-
-    URLConnection connection = server.url("/").url().openConnection();
-    InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));
-    assertThat(reader.readLine()).isEqualTo("enqueued in the background");
-  }
-
-  @Test public void nonHexadecimalChunkSize() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("G\r\nxxxxxxxxxxxxxxxx\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    URLConnection connection = server.url("/").url().openConnection();
-    InputStream in = connection.getInputStream();
-    try {
-      in.read();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void responseTimeout() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABC")
-        .clearHeaders()
-        .addHeader("Content-Length: 4"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-
-    URLConnection urlConnection = server.url("/").url().openConnection();
-    urlConnection.setReadTimeout(1000);
-    InputStream in = urlConnection.getInputStream();
-    assertThat(in.read()).isEqualTo('A');
-    assertThat(in.read()).isEqualTo('B');
-    assertThat(in.read()).isEqualTo('C');
-    try {
-      in.read(); // if Content-Length was accurate, this would return -1 immediately
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-
-    URLConnection urlConnection2 = server.url("/").url().openConnection();
-    InputStream in2 = urlConnection2.getInputStream();
-    assertThat(in2.read()).isEqualTo('D');
-    assertThat(in2.read()).isEqualTo('E');
-    assertThat(in2.read()).isEqualTo('F');
-    assertThat(in2.read()).isEqualTo(-1);
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Ignore("Not actually failing where expected")
-  @Test public void disconnectAtStart() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
-    server.enqueue(new MockResponse()); // The jdk's HttpUrlConnection is a bastard.
-    server.enqueue(new MockResponse());
-    try {
-      server.url("/a").url().openConnection().getInputStream();
-      fail();
-    } catch (IOException expected) {
-    }
-    server.url("/b").url().openConnection().getInputStream(); // Should succeed.
-  }
-
-  /**
-   * Throttle the request body by sleeping 500ms after every 3 bytes. With a 6-byte request, this
-   * should yield one sleep for a total delay of 500ms.
-   */
-  @Test public void throttleRequest() throws Exception {
-    server.enqueue(new MockResponse()
-        .throttleBody(3, 500, TimeUnit.MILLISECONDS));
-
-    long startNanos = System.nanoTime();
-    URLConnection connection = server.url("/").url().openConnection();
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("ABCDEF".getBytes(UTF_8));
-    InputStream in = connection.getInputStream();
-    assertThat(in.read()).isEqualTo(-1);
-    long elapsedNanos = System.nanoTime() - startNanos;
-    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-    assertThat(elapsedMillis).isBetween(500L, 1000L);
-  }
-
-  /**
-   * Throttle the response body by sleeping 500ms after every 3 bytes. With a 6-byte response, this
-   * should yield one sleep for a total delay of 500ms.
-   */
-  @Test public void throttleResponse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABCDEF")
-        .throttleBody(3, 500, TimeUnit.MILLISECONDS));
-
-    long startNanos = System.nanoTime();
-    URLConnection connection = server.url("/").url().openConnection();
-    InputStream in = connection.getInputStream();
-    assertThat(in.read()).isEqualTo('A');
-    assertThat(in.read()).isEqualTo('B');
-    assertThat(in.read()).isEqualTo('C');
-    assertThat(in.read()).isEqualTo('D');
-    assertThat(in.read()).isEqualTo('E');
-    assertThat(in.read()).isEqualTo('F');
-    assertThat(in.read()).isEqualTo(-1);
-    long elapsedNanos = System.nanoTime() - startNanos;
-    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-    assertThat(elapsedMillis).isBetween(500L, 1000L);
-  }
-
-  /** Delay the response body by sleeping 1s. */
-  @Test public void delayResponse() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("ABCDEF")
-        .setBodyDelay(1, SECONDS));
-
-    long startNanos = System.nanoTime();
-    URLConnection connection = server.url("/").url().openConnection();
-    InputStream in = connection.getInputStream();
-    assertThat(in.read()).isEqualTo('A');
-    long elapsedNanos = System.nanoTime() - startNanos;
-    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-    assertThat(elapsedMillis).isGreaterThanOrEqualTo(1000L);
-
-    in.close();
-  }
-
-  @Test public void disconnectRequestHalfway() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
-    // Limit the size of the request body that the server holds in memory to an arbitrary
-    // 3.5 MBytes so this test can pass on devices with little memory.
-    server.setBodyLimit(7 * 512 * 1024);
-
-    HttpURLConnection connection = (HttpURLConnection) server.url("/").url().openConnection();
-    connection.setRequestMethod("POST");
-    connection.setDoOutput(true);
-    connection.setFixedLengthStreamingMode(1024 * 1024 * 1024); // 1 GB
-    connection.connect();
-    OutputStream out = connection.getOutputStream();
-
-    byte[] data = new byte[1024 * 1024];
-    int i;
-    for (i = 0; i < 1024; i++) {
-      try {
-        out.write(data);
-        out.flush();
-        if (i == 513) {
-          // pause slightly after half way to make result more predictable
-          Thread.sleep(100);
-        }
-      } catch (IOException e) {
-        break;
-      }
-    }
-    // Halfway +/- 0.5%
-    assertThat((float) i).isCloseTo(512f, offset(5f));
-  }
-
-  @Test public void disconnectResponseHalfway() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("ab")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
-
-    URLConnection connection = server.url("/").url().openConnection();
-    assertThat(connection.getContentLength()).isEqualTo(2);
-    InputStream in = connection.getInputStream();
-    assertThat(in.read()).isEqualTo('a');
-    try {
-      int byteRead = in.read();
-      // OpenJDK behavior: end of stream.
-      assertThat(byteRead).isEqualTo(-1);
-    } catch (ProtocolException e) {
-      // On Android, HttpURLConnection is implemented by OkHttp v2. OkHttp
-      // treats an incomplete response body as a ProtocolException.
-    }
-  }
-
-  private List<String> headersToList(MockResponse response) {
-    Headers headers = response.getHeaders();
-    int size = headers.size();
-    List<String> headerList = new ArrayList<>(size);
-    for (int i = 0; i < size; i++) {
-      headerList.add(headers.name(i) + ": " + headers.value(i));
-    }
-    return headerList;
-  }
-
-  @Test public void shutdownWithoutStart() throws IOException {
-    MockWebServer server = new MockWebServer();
-    server.shutdown();
-  }
-
-  @Test public void closeViaClosable() throws IOException {
-    Closeable server = new MockWebServer();
-    server.close();
-  }
-
-  @Test public void shutdownWithoutEnqueue() throws IOException {
-    MockWebServer server = new MockWebServer();
-    server.start();
-    server.shutdown();
-  }
-
-  @Test public void portImplicitlyStarts() {
-    assertThat(server.getPort()).isGreaterThan(0);
-  }
-
-  @Test public void hostnameImplicitlyStarts() {
-    assertThat(server.getHostName()).isNotNull();
-  }
-
-  @Test public void toProxyAddressImplicitlyStarts() {
-    assertThat(server.toProxyAddress()).isNotNull();
-  }
-
-  @Test public void differentInstancesGetDifferentPorts() throws IOException {
-    MockWebServer other = new MockWebServer();
-    assertThat(other.getPort()).isNotEqualTo(server.getPort());
-    other.shutdown();
-  }
-
-  @Test public void statementStartsAndStops() throws Throwable {
-    final AtomicBoolean called = new AtomicBoolean();
-    Statement statement = server.apply(new Statement() {
-      @Override public void evaluate() throws Throwable {
-        called.set(true);
-        server.url("/").url().openConnection().connect();
-      }
-    }, Description.EMPTY);
-
-    statement.evaluate();
-
-    assertThat(called.get()).isTrue();
-    try {
-      server.url("/").url().openConnection().connect();
-      fail();
-    } catch (ConnectException expected) {
-    }
-  }
-
-  @Test public void shutdownWhileBlockedDispatching() throws Exception {
-    // Enqueue a request that'll cause MockWebServer to hang on QueueDispatcher.dispatch().
-    HttpURLConnection connection = (HttpURLConnection) server.url("/").url().openConnection();
-    connection.setReadTimeout(500);
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-
-    // Shutting down the server should unblock the dispatcher.
-    server.shutdown();
-  }
-
-  @Test public void requestUrlReconstructed() throws Exception {
-    server.enqueue(new MockResponse().setBody("hello world"));
-
-    URL url = server.url("/a/deep/path?key=foo%20bar").url();
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));
-    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
-    assertThat(reader.readLine()).isEqualTo("hello world");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestLine()).isEqualTo(
-        "GET /a/deep/path?key=foo%20bar HTTP/1.1");
-
-    HttpUrl requestUrl = request.getRequestUrl();
-    assertThat(requestUrl.scheme()).isEqualTo("http");
-    assertThat(requestUrl.host()).isEqualTo(server.getHostName());
-    assertThat(requestUrl.port()).isEqualTo(server.getPort());
-    assertThat(requestUrl.encodedPath()).isEqualTo("/a/deep/path");
-    assertThat(requestUrl.queryParameter("key")).isEqualTo("foo bar");
-  }
-
-  @Test public void shutdownServerAfterRequest() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE));
-
-    URL url = server.url("/").url();
-
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
-
-    HttpURLConnection refusedConnection = (HttpURLConnection) url.openConnection();
-
-    try {
-      refusedConnection.getResponseCode();
-      fail("Second connection should be refused");
-    } catch (ConnectException e) {
-      assertThat(e.getMessage()).contains("refused");
-    }
-  }
-
-  @Test public void http100Continue() throws Exception {
-    server.enqueue(new MockResponse().setBody("response"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    connection.setDoOutput(true);
-    connection.setRequestProperty("Expect", "100-Continue");
-    connection.getOutputStream().write("request".getBytes(UTF_8));
-
-    InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));
-    assertThat(reader.readLine()).isEqualTo("response");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("request");
-  }
-
-  @Test public void testH2PriorKnowledgeServerFallback() {
-    try {
-      server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("protocols containing h2_prior_knowledge cannot use other protocols: "
-              + "[h2_prior_knowledge, http/1.1]"));
-    }
-  }
-
-  @Test public void testH2PriorKnowledgeServerDuplicates() {
-    try {
-      // Treating this use case as user error
-      server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("protocols containing h2_prior_knowledge cannot use other protocols: "
-              + "[h2_prior_knowledge, h2_prior_knowledge]"));
-    }
-  }
-
-  @Test public void testMockWebServerH2PriorKnowledgeProtocol() {
-    server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE));
-
-    assertThat(server.protocols().size()).isEqualTo(1);
-    assertThat(server.protocols().get(0)).isEqualTo(Protocol.H2_PRIOR_KNOWLEDGE);
-  }
-
-  @Test public void https() throws Exception {
-    HandshakeCertificates handshakeCertificates = localhost();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    HttpUrl url = server.url("/");
-    HttpsURLConnection connection = (HttpsURLConnection) url.url().openConnection();
-    connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
-    connection.setHostnameVerifier(new RecordingHostnameVerifier());
-
-    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
-    BufferedReader reader =
-        new BufferedReader(new InputStreamReader(connection.getInputStream(), UTF_8));
-    assertThat(reader.readLine()).isEqualTo("abc");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestUrl().scheme()).isEqualTo("https");
-    Handshake handshake = request.getHandshake();
-    assertThat(handshake.tlsVersion()).isNotNull();
-    assertThat(handshake.cipherSuite()).isNotNull();
-    assertThat(handshake.localPrincipal()).isNotNull();
-    assertThat(handshake.localCertificates().size()).isEqualTo(1);
-    assertThat(handshake.peerPrincipal()).isNull();
-    assertThat(handshake.peerCertificates().size()).isEqualTo(0);
-  }
-
-  @Test public void httpsWithClientAuth() throws Exception {
-    assumeFalse(getPlatform().equals("conscrypt"));
-
-    HeldCertificate clientCa = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .build();
-    HeldCertificate serverCa = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .build();
-    HeldCertificate serverCertificate = new HeldCertificate.Builder()
-        .signedBy(serverCa)
-        .addSubjectAlternativeName(server.getHostName())
-        .build();
-    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(clientCa.certificate())
-        .heldCertificate(serverCertificate)
-        .build();
-
-    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.requestClientAuth();
-
-    HeldCertificate clientCertificate = new HeldCertificate.Builder()
-        .signedBy(clientCa)
-        .build();
-    HandshakeCertificates clientHandshakeCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(serverCa.certificate())
-        .heldCertificate(clientCertificate)
-        .build();
-
-    HttpUrl url = server.url("/");
-    HttpsURLConnection connection = (HttpsURLConnection) url.url().openConnection();
-    connection.setSSLSocketFactory(clientHandshakeCertificates.sslSocketFactory());
-    connection.setHostnameVerifier(new RecordingHostnameVerifier());
-
-    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
-    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
-    assertThat(reader.readLine()).isEqualTo("abc");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestUrl().scheme()).isEqualTo("https");
-    Handshake handshake = request.getHandshake();
-    assertThat(handshake.tlsVersion()).isNotNull();
-    assertThat(handshake.cipherSuite()).isNotNull();
-    assertThat(handshake.localPrincipal()).isNotNull();
-    assertThat(handshake.localCertificates().size()).isEqualTo(1);
-    assertThat(handshake.peerPrincipal()).isNotNull();
-    assertThat(handshake.peerCertificates().size()).isEqualTo(1);
-  }
-
-  public static String getPlatform() {
-    return System.getProperty("okhttp.platform", "jdk8");
-  }
-}
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
deleted file mode 100644
index 5e9bb82d75..0000000000
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.mockwebserver;
-
-import java.net.InetAddress;
-import java.net.Socket;
-import java.net.UnknownHostException;
-import java.util.Collections;
-import okhttp3.Headers;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.Timeout;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-@SuppressWarnings("ConstantConditions")
-public class RecordedRequestTest {
-  private Headers headers = Util.EMPTY_HEADERS;
-
-  private static class FakeSocket extends Socket {
-    private final InetAddress localAddress;
-    private final int remotePort;
-    private final InetAddress remoteAddress;
-    private final int localPort;
-
-    private FakeSocket(InetAddress inetAddress, int localPort) {
-      this(inetAddress, localPort, inetAddress, 1234);
-    }
-
-    private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAddress,
-        int remotePort) {
-      this.localAddress = localAddress;
-      this.localPort = localPort;
-      this.remoteAddress = remoteAddress;
-      this.remotePort = remotePort;
-    }
-
-    @Override public InetAddress getInetAddress() {
-      return remoteAddress;
-    }
-
-    @Override public InetAddress getLocalAddress() {
-      return localAddress;
-    }
-
-    @Override public int getLocalPort() {
-      return localPort;
-    }
-
-    @Override public int getPort() {
-      return remotePort;
-    }
-  }
-
-  @Rule public Timeout globalTimeout = Timeout.seconds(30);
-
-  @Test public void testIPv4() throws UnknownHostException {
-    Socket socket =
-        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] {127, 0, 0, 1}), 80);
-
-    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
-        Collections.emptyList(), 0, new Buffer(), 0, socket);
-
-    assertThat(request.getRequestUrl().toString()).isEqualTo("http://127.0.0.1/");
-  }
-
-  @Test public void testIpv6() throws UnknownHostException {
-    Socket socket = new FakeSocket(InetAddress.getByAddress("::1",
-        new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}), 80);
-
-    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
-        Collections.emptyList(), 0, new Buffer(), 0, socket);
-
-    assertThat(request.getRequestUrl().toString()).isEqualTo("http://[::1]/");
-  }
-
-  @Test public void testUsesLocal() throws UnknownHostException {
-    Socket socket =
-        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] {127, 0, 0, 1}), 80);
-
-    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
-        Collections.emptyList(), 0, new Buffer(), 0, socket);
-
-    assertThat(request.getRequestUrl().toString()).isEqualTo("http://127.0.0.1/");
-  }
-
-  @Test public void testLocalhostIpv6() throws UnknownHostException {
-    Socket socket = new FakeSocket(InetAddress.getByAddress("localhost",
-        new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}), 80);
-
-    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
-        Collections.emptyList(), 0, new Buffer(), 0, socket);
-
-    assertThat(request.getRequestUrl().toString()).isEqualTo("http://localhost/");
-  }
-
-  @Test public void testLocalhostIpv4() throws UnknownHostException {
-    Socket socket =
-        new FakeSocket(InetAddress.getByAddress("localhost", new byte[] {127, 0, 0, 1}), 80);
-
-    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
-        Collections.emptyList(), 0, new Buffer(), 0, socket);
-
-    assertThat(request.getRequestUrl().toString()).isEqualTo("http://localhost/");
-  }
-}
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
deleted file mode 100644
index 185dde5bfc..0000000000
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.mockwebserver.internal.http2;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.util.Collections;
-import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Headers;
-import okhttp3.Protocol;
-import okhttp3.internal.concurrent.TaskRunner;
-import okhttp3.internal.http2.Header;
-import okhttp3.internal.http2.Http2Connection;
-import okhttp3.internal.http2.Http2Stream;
-import okhttp3.internal.platform.Platform;
-import okio.BufferedSink;
-import okio.Okio;
-import okio.Source;
-
-import static java.util.Arrays.asList;
-import static okhttp3.internal.Util.closeQuietly;
-import static okhttp3.internal.platform.Platform.INFO;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-
-/** A basic HTTP/2 server that serves the contents of a local directory. */
-public final class Http2Server extends Http2Connection.Listener {
-  static final Logger logger = Logger.getLogger(Http2Server.class.getName());
-
-  private final File baseDirectory;
-  private final SSLSocketFactory sslSocketFactory;
-
-  public Http2Server(File baseDirectory, SSLSocketFactory sslSocketFactory) {
-    this.baseDirectory = baseDirectory;
-    this.sslSocketFactory = sslSocketFactory;
-  }
-
-  private void run() throws Exception {
-    ServerSocket serverSocket = new ServerSocket(8888);
-    serverSocket.setReuseAddress(true);
-
-    while (true) {
-      Socket socket = null;
-      try {
-        socket = serverSocket.accept();
-
-        SSLSocket sslSocket = doSsl(socket);
-        String protocolString = Platform.get().getSelectedProtocol(sslSocket);
-        Protocol protocol = protocolString != null ? Protocol.get(protocolString) : null;
-        if (protocol != Protocol.HTTP_2) {
-          throw new ProtocolException("Protocol " + protocol + " unsupported");
-        }
-        Http2Connection connection = new Http2Connection.Builder(false, TaskRunner.INSTANCE)
-            .socket(sslSocket)
-            .listener(this)
-            .build();
-        connection.start();
-      } catch (IOException e) {
-        logger.log(Level.INFO, "Http2Server connection failure: " + e);
-        if (socket != null) {
-          closeQuietly(socket);
-        }
-      } catch (Exception e) {
-        logger.log(Level.WARNING, "Http2Server unexpected failure", e);
-        if (socket != null) {
-          closeQuietly(socket);
-        }
-      }
-    }
-  }
-
-  private SSLSocket doSsl(Socket socket) throws IOException {
-    SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(
-        socket, socket.getInetAddress().getHostAddress(), socket.getPort(), true);
-    sslSocket.setUseClientMode(false);
-    Platform.get().configureTlsExtensions(sslSocket,
-        Collections.singletonList(Protocol.HTTP_2));
-    sslSocket.startHandshake();
-    return sslSocket;
-  }
-
-  @Override public void onStream(Http2Stream stream) throws IOException {
-    try {
-      Headers requestHeaders = stream.takeHeaders();
-      String path = null;
-      for (int i = 0, size = requestHeaders.size(); i < size; i++) {
-        if (requestHeaders.name(i).equals(Header.TARGET_PATH_UTF8)) {
-          path = requestHeaders.value(i);
-          break;
-        }
-      }
-
-      if (path == null) {
-        // TODO: send bad request error
-        throw new AssertionError();
-      }
-
-      File file = new File(baseDirectory + path);
-
-      if (file.isDirectory()) {
-        serveDirectory(stream, file.listFiles());
-      } else if (file.exists()) {
-        serveFile(stream, file);
-      } else {
-        send404(stream, path);
-      }
-    } catch (IOException e) {
-      Platform.get().log("Failure serving Http2Stream: " + e.getMessage(), INFO, null);
-    }
-  }
-
-  private void send404(Http2Stream stream, String path) throws IOException {
-    List<Header> responseHeaders = asList(
-        new Header(":status", "404"),
-        new Header(":version", "HTTP/1.1"),
-        new Header("content-type", "text/plain")
-    );
-    stream.writeHeaders(responseHeaders, false, false);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.writeUtf8("Not found: " + path);
-    out.close();
-  }
-
-  private void serveDirectory(Http2Stream stream, File[] files) throws IOException {
-    List<Header> responseHeaders = asList(
-        new Header(":status", "200"),
-        new Header(":version", "HTTP/1.1"),
-        new Header("content-type", "text/html; charset=UTF-8")
-    );
-    stream.writeHeaders(responseHeaders, false, false);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    for (File file : files) {
-      String target = file.isDirectory() ? (file.getName() + "/") : file.getName();
-      out.writeUtf8("<a href='" + target + "'>" + target + "</a><br>");
-    }
-    out.close();
-  }
-
-  private void serveFile(Http2Stream stream, File file) throws IOException {
-    List<Header> responseHeaders = asList(
-        new Header(":status", "200"),
-        new Header(":version", "HTTP/1.1"),
-        new Header("content-type", contentType(file))
-    );
-    stream.writeHeaders(responseHeaders, false, false);
-    try (Source source = Okio.source(file); BufferedSink sink = Okio.buffer(stream.getSink())) {
-      sink.writeAll(source);
-    }
-  }
-
-  private String contentType(File file) {
-    if (file.getName().endsWith(".css")) return "text/css";
-    if (file.getName().endsWith(".gif")) return "image/gif";
-    if (file.getName().endsWith(".html")) return "text/html";
-    if (file.getName().endsWith(".jpeg")) return "image/jpeg";
-    if (file.getName().endsWith(".jpg")) return "image/jpeg";
-    if (file.getName().endsWith(".js")) return "application/javascript";
-    if (file.getName().endsWith(".png")) return "image/png";
-    return "text/plain";
-  }
-
-  public static void main(String... args) throws Exception {
-    if (args.length != 1 || args[0].startsWith("-")) {
-      System.out.println("Usage: Http2Server <base directory>");
-      return;
-    }
-
-    Http2Server server = new Http2Server(new File(args[0]),
-        localhost().sslContext().getSocketFactory());
-    server.run();
-  }
-}
diff --git a/okcurl/build.gradle b/okcurl/build.gradle
index 990860e3e2..5ba959f92d 100644
--- a/okcurl/build.gradle
+++ b/okcurl/build.gradle
@@ -28,7 +28,6 @@ dependencies {
   implementation deps.picocli
   implementation deps.guava
 
-  testImplementation project(':okhttp-testing-support')
   testImplementation deps.junit
   testImplementation deps.assertj
 }
diff --git a/okhttp-brotli/build.gradle b/okhttp-brotli/build.gradle
index ef901c0477..0cff4929bf 100644
--- a/okhttp-brotli/build.gradle
+++ b/okhttp-brotli/build.gradle
@@ -11,11 +11,6 @@ dependencies {
   api deps.brotli
   compileOnly deps.jsr305
 
-  testImplementation project(':okhttp-testing-support')
-  testImplementation project(':mockwebserver')
-  testImplementation deps.conscrypt
-  testImplementation deps.junit
-  testImplementation deps.assertj
 }
 
 afterEvaluate { project ->
diff --git a/okhttp-dnsoverhttps/build.gradle b/okhttp-dnsoverhttps/build.gradle
index 16fb4c80fb..d40c4fce82 100644
--- a/okhttp-dnsoverhttps/build.gradle
+++ b/okhttp-dnsoverhttps/build.gradle
@@ -10,11 +10,6 @@ dependencies {
   api project(':okhttp')
   compileOnly deps.jsr305
 
-  testImplementation project(':okhttp-testing-support')
-  testImplementation project(':mockwebserver')
-  testImplementation deps.conscrypt
-  testImplementation deps.junit
-  testImplementation deps.assertj
 }
 
 afterEvaluate { project ->
diff --git a/okhttp-logging-interceptor/build.gradle b/okhttp-logging-interceptor/build.gradle
index b9d5410558..01fea55a9c 100644
--- a/okhttp-logging-interceptor/build.gradle
+++ b/okhttp-logging-interceptor/build.gradle
@@ -13,10 +13,6 @@ dependencies {
 
   testCompileOnly deps.jsr305
   testImplementation deps.junit
-  testImplementation project(':mockwebserver')
-  testImplementation project(':okhttp-testing-support')
-  testImplementation project(':okhttp-tls')
-  testImplementation deps.assertj
 }
 
 afterEvaluate { project ->
diff --git a/okhttp-sse/build.gradle b/okhttp-sse/build.gradle
index db2745599c..4afef7824e 100644
--- a/okhttp-sse/build.gradle
+++ b/okhttp-sse/build.gradle
@@ -11,11 +11,6 @@ dependencies {
   api project(':okhttp')
   compileOnly deps.jsr305
 
-  testImplementation project(':okhttp-testing-support')
-  testImplementation project(':mockwebserver')
-  testImplementation deps.junit
-  testImplementation deps.assertj
-  testCompileOnly deps.jsr305
 }
 
 afterEvaluate { project ->
diff --git a/okhttp-testing-support/README.md b/okhttp-testing-support/README.md
deleted file mode 100644
index f47dbe11bb..0000000000
--- a/okhttp-testing-support/README.md
+++ /dev/null
@@ -1,5 +0,0 @@
-OkHttp Testing Support
-======================
-
-This module offers utilities and support for testing OkHttp itself. It's not intended for use by
-other projects or consumers of the OkHttp library.
diff --git a/okhttp-testing-support/build.gradle b/okhttp-testing-support/build.gradle
deleted file mode 100644
index 3efe882543..0000000000
--- a/okhttp-testing-support/build.gradle
+++ /dev/null
@@ -1,9 +0,0 @@
-dependencies {
-  api project(':okhttp')
-  api deps.junit
-  api deps.assertj
-  api deps.conscrypt
-  api deps.openjsse
-  
-  compileOnly deps.jsr305
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/ClientRuleEventListener.kt b/okhttp-testing-support/src/main/java/okhttp3/ClientRuleEventListener.kt
deleted file mode 100644
index 28444acdb2..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/ClientRuleEventListener.kt
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3
-
-import java.io.IOException
-import java.net.InetAddress
-import java.net.InetSocketAddress
-import java.net.Proxy
-import java.util.concurrent.TimeUnit
-
-class ClientRuleEventListener(var logger: (String) -> Unit) : EventListener(),
-    EventListener.Factory {
-  private var startNs: Long = 0
-
-  override fun create(call: Call): EventListener = this
-
-  override fun callStart(call: Call) {
-    startNs = System.nanoTime()
-
-    logWithTime("callStart: ${call.request()}")
-  }
-
-  override fun proxySelectStart(call: Call, url: HttpUrl) {
-    logWithTime("proxySelectStart: $url")
-  }
-
-  override fun proxySelectEnd(call: Call, url: HttpUrl, proxies: List<Proxy>) {
-    logWithTime("proxySelectEnd: $proxies")
-  }
-
-  override fun dnsStart(call: Call, domainName: String) {
-    logWithTime("dnsStart: $domainName")
-  }
-
-  override fun dnsEnd(call: Call, domainName: String, inetAddressList: List<InetAddress>) {
-    logWithTime("dnsEnd: $inetAddressList")
-  }
-
-  override fun connectStart(call: Call, inetSocketAddress: InetSocketAddress, proxy: Proxy) {
-    logWithTime("connectStart: $inetSocketAddress $proxy")
-  }
-
-  override fun secureConnectStart(call: Call) {
-    logWithTime("secureConnectStart")
-  }
-
-  override fun secureConnectEnd(call: Call, handshake: Handshake?) {
-    logWithTime("secureConnectEnd: $handshake")
-  }
-
-  override fun connectEnd(
-    call: Call,
-    inetSocketAddress: InetSocketAddress,
-    proxy: Proxy,
-    protocol: Protocol?
-  ) {
-    logWithTime("connectEnd: $protocol")
-  }
-
-  override fun connectFailed(
-    call: Call,
-    inetSocketAddress: InetSocketAddress,
-    proxy: Proxy,
-    protocol: Protocol?,
-    ioe: IOException
-  ) {
-    logWithTime("connectFailed: $protocol $ioe")
-  }
-
-  override fun connectionAcquired(call: Call, connection: Connection) {
-    logWithTime("connectionAcquired: $connection")
-  }
-
-  override fun connectionReleased(call: Call, connection: Connection) {
-    logWithTime("connectionReleased")
-  }
-
-  override fun requestHeadersStart(call: Call) {
-    logWithTime("requestHeadersStart")
-  }
-
-  override fun requestHeadersEnd(call: Call, request: Request) {
-    logWithTime("requestHeadersEnd")
-  }
-
-  override fun requestBodyStart(call: Call) {
-    logWithTime("requestBodyStart")
-  }
-
-  override fun requestBodyEnd(call: Call, byteCount: Long) {
-    logWithTime("requestBodyEnd: byteCount=$byteCount")
-  }
-
-  override fun requestFailed(call: Call, ioe: IOException) {
-    logWithTime("requestFailed: $ioe")
-  }
-
-  override fun responseHeadersStart(call: Call) {
-    logWithTime("responseHeadersStart")
-  }
-
-  override fun responseHeadersEnd(call: Call, response: Response) {
-    logWithTime("responseHeadersEnd: $response")
-  }
-
-  override fun responseBodyStart(call: Call) {
-    logWithTime("responseBodyStart")
-  }
-
-  override fun responseBodyEnd(call: Call, byteCount: Long) {
-    logWithTime("responseBodyEnd: byteCount=$byteCount")
-  }
-
-  override fun responseFailed(call: Call, ioe: IOException) {
-    logWithTime("responseFailed: $ioe")
-  }
-
-  override fun callEnd(call: Call) {
-    logWithTime("callEnd")
-  }
-
-  override fun callFailed(call: Call, ioe: IOException) {
-    logWithTime("callFailed: $ioe")
-  }
-
-  private fun logWithTime(message: String) {
-    val timeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs)
-    logger.invoke("[$timeMs ms] $message")
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
deleted file mode 100644
index 82cacacbac..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class FakeDns implements Dns {
-  private final Map<String, List<InetAddress>> hostAddresses = new LinkedHashMap<>();
-  private final List<String> requestedHosts = new ArrayList<>();
-  private int nextAddress = 100;
-
-  /** Sets the results for {@code hostname}. */
-  public FakeDns set(String hostname, List<InetAddress> addresses) {
-    hostAddresses.put(hostname, addresses);
-    return this;
-  }
-
-  /** Clears the results for {@code hostname}. */
-  public FakeDns clear(String hostname) {
-    hostAddresses.remove(hostname);
-    return this;
-  }
-
-  public InetAddress lookup(String hostname, int index) throws UnknownHostException {
-    return hostAddresses.get(hostname).get(index);
-  }
-
-  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-    requestedHosts.add(hostname);
-
-    List<InetAddress> result = hostAddresses.get(hostname);
-    if (result != null) return result;
-
-    throw new UnknownHostException();
-  }
-
-  public void assertRequests(String... expectedHosts) {
-    assertThat(requestedHosts).containsExactly(expectedHosts);
-    requestedHosts.clear();
-  }
-
-  /** Allocates and returns {@code count} fake addresses like [255.0.0.100, 255.0.0.101]. */
-  public List<InetAddress> allocate(int count) {
-    try {
-      List<InetAddress> result = new ArrayList<>();
-      for (int i = 0; i < count; i++) {
-        if (nextAddress > 255) {
-          throw new AssertionError("too many addresses allocated");
-        }
-        result.add(InetAddress.getByAddress(
-            new byte[] {(byte) 255, (byte) 0, (byte) 0, (byte) nextAddress++}));
-      }
-      return result;
-    } catch (UnknownHostException e) {
-      throw new AssertionError();
-    }
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java b/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java
deleted file mode 100644
index c7d37f57ea..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/FakeProxySelector.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-public final class FakeProxySelector extends ProxySelector {
-  public final List<Proxy> proxies = new ArrayList<>();
-
-  public FakeProxySelector addProxy(Proxy proxy) {
-    proxies.add(proxy);
-    return this;
-  }
-
-  @Override public List<Proxy> select(URI uri) {
-    // Don't handle 'socket' schemes, which the RI's Socket class may request (for SOCKS).
-    return uri.getScheme().equals("http") || uri.getScheme().equals("https") ? proxies
-        : Collections.singletonList(Proxy.NO_PROXY);
-  }
-
-  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java b/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
deleted file mode 100644
index 3851ca3351..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with this
- * work for additional information regarding copyright ownership. The ASF
- * licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- */
-package okhttp3;
-
-import java.security.Principal;
-import java.security.cert.Certificate;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSessionContext;
-import javax.security.cert.X509Certificate;
-
-public final class FakeSSLSession implements SSLSession {
-  private final Certificate[] certificates;
-
-  public FakeSSLSession(Certificate... certificates) throws Exception {
-    this.certificates = certificates;
-  }
-
-  @Override
-  public int getApplicationBufferSize() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public String getCipherSuite() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public long getCreationTime() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public byte[] getId() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public long getLastAccessedTime() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public Certificate[] getLocalCertificates() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public Principal getLocalPrincipal() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public int getPacketBufferSize() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException {
-    if (certificates.length == 0) {
-      throw new SSLPeerUnverifiedException("peer not authenticated");
-    } else {
-      return certificates;
-    }
-  }
-
-  @Override
-  public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public String getPeerHost() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public int getPeerPort() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public String getProtocol() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public SSLSessionContext getSessionContext() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void putValue(String s, Object obj) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void removeValue(String s) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public Object getValue(String s) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public String[] getValueNames() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void invalidate() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean isValid() {
-    throw new UnsupportedOperationException();
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/ForwardingRequestBody.java b/okhttp-testing-support/src/main/java/okhttp3/ForwardingRequestBody.java
deleted file mode 100644
index 4aa144c6be..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/ForwardingRequestBody.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import javax.annotation.Nullable;
-import okio.BufferedSink;
-
-public class ForwardingRequestBody extends RequestBody {
-  private final RequestBody delegate;
-
-  public ForwardingRequestBody(RequestBody delegate) {
-    if (delegate == null) throw new IllegalArgumentException("delegate == null");
-    this.delegate = delegate;
-  }
-
-  public final RequestBody delegate() {
-    return delegate;
-  }
-
-  @Override public @Nullable MediaType contentType() {
-    return delegate.contentType();
-  }
-
-  @Override public long contentLength() throws IOException {
-    return delegate.contentLength();
-  }
-
-  @Override public void writeTo(BufferedSink sink) throws IOException {
-    delegate.writeTo(sink);
-  }
-
-  @Override public boolean isDuplex() {
-    return delegate.isDuplex();
-  }
-
-  @Override public String toString() {
-    return getClass().getSimpleName() + "(" + delegate.toString() + ")";
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/ForwardingResponseBody.java b/okhttp-testing-support/src/main/java/okhttp3/ForwardingResponseBody.java
deleted file mode 100644
index 2cc067ac0c..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/ForwardingResponseBody.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import javax.annotation.Nullable;
-import okio.BufferedSource;
-
-public class ForwardingResponseBody extends ResponseBody {
-  private final ResponseBody delegate;
-
-  public ForwardingResponseBody(ResponseBody delegate) {
-    if (delegate == null) throw new IllegalArgumentException("delegate == null");
-    this.delegate = delegate;
-  }
-
-  public final ResponseBody delegate() {
-    return delegate;
-  }
-
-  @Override public @Nullable MediaType contentType() {
-    return delegate.contentType();
-  }
-
-  @Override public long contentLength() {
-    return delegate.contentLength();
-  }
-
-  @Override public BufferedSource source() {
-    return delegate.source();
-  }
-
-  @Override public String toString() {
-    return getClass().getSimpleName() + "(" + delegate.toString() + ")";
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
deleted file mode 100644
index b4de378151..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3
-
-import okhttp3.internal.concurrent.TaskRunner
-import okhttp3.testing.Flaky
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.rules.TestRule
-import org.junit.runner.Description
-import org.junit.runners.model.Statement
-import java.net.InetAddress
-import java.util.concurrent.TimeUnit
-
-/** Apply this rule to tests that need an OkHttpClient instance. */
-class OkHttpClientTestRule : TestRule {
-  private val clientEventsList = mutableListOf<String>()
-  private var testClient: OkHttpClient? = null
-
-  /**
-   * Returns an OkHttpClient for tests to use as a starting point.
-   *
-   * The returned client installs a default event listener that gathers debug information. This will
-   * be logged if the test fails.
-   *
-   * This client is also configured to be slightly more deterministic, returning a single IP
-   * address for all hosts, regardless of the actual number of IP addresses reported by DNS.
-   */
-  fun newClient(): OkHttpClient {
-    var client = testClient
-    if (client == null) {
-      client = OkHttpClient.Builder()
-          .dns(SINGLE_INET_ADDRESS_DNS) // Prevent unexpected fallback addresses.
-          .eventListener(ClientRuleEventListener { addEvent(it) })
-          .build()
-      testClient = client
-    }
-    return client
-  }
-
-  fun newClientBuilder(): OkHttpClient.Builder {
-    return newClient().newBuilder()
-  }
-
-  @Synchronized private fun addEvent(it: String) {
-    clientEventsList.add(it)
-  }
-
-  fun ensureAllConnectionsReleased() {
-    testClient?.let {
-      val connectionPool = it.connectionPool
-      connectionPool.evictAll()
-      assertThat(connectionPool.connectionCount()).isEqualTo(0)
-    }
-  }
-
-  private fun ensureAllTaskQueuesIdle() {
-    for (queue in TaskRunner.INSTANCE.activeQueues()) {
-      assertThat(queue.awaitIdle(TimeUnit.MILLISECONDS.toNanos(1000L)))
-          .withFailMessage("Queue still active after 1000ms")
-          .isTrue()
-    }
-  }
-
-  override fun apply(base: Statement, description: Description): Statement {
-    return object : Statement() {
-      override fun evaluate() {
-        try {
-          base.evaluate()
-          logEventsIfFlaky(description)
-        } catch (t: Throwable) {
-          logEvents()
-          throw t
-        } finally {
-          ensureAllConnectionsReleased()
-          releaseClient()
-          ensureAllTaskQueuesIdle()
-        }
-      }
-
-      private fun releaseClient() {
-        testClient?.dispatcher?.executorService?.shutdown()
-      }
-    }
-  }
-
-  private fun logEventsIfFlaky(description: Description) {
-    if (isTestFlaky(description)) {
-      logEvents()
-    }
-  }
-
-  private fun isTestFlaky(description: Description): Boolean {
-    return description.annotations.any { it.annotationClass == Flaky::class } ||
-        description.testClass.annotations.any { it.annotationClass == Flaky::class }
-  }
-
-  @Synchronized private fun logEvents() {
-    // Will be ineffective if test overrides the listener
-    println("Events (${clientEventsList.size})")
-
-    for (e in clientEventsList) {
-      println(e)
-    }
-  }
-
-  companion object {
-    /**
-     * A network that resolves only one IP address per host. Use this when testing route selection
-     * fallbacks to prevent the host machine's various IP addresses from interfering.
-     */
-    private val SINGLE_INET_ADDRESS_DNS = object : Dns {
-      override fun lookup(hostname: String): List<InetAddress> {
-        val addresses = Dns.SYSTEM.lookup(hostname)
-        return listOf(addresses[0])
-      }
-    }
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
deleted file mode 100644
index eb9e46d9e4..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Deque;
-import java.util.List;
-
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class RecordingCookieJar implements CookieJar {
-  private final Deque<List<Cookie>> requestCookies = new ArrayDeque<>();
-  private final Deque<List<Cookie>> responseCookies = new ArrayDeque<>();
-
-  public void enqueueRequestCookies(Cookie... cookies) {
-    requestCookies.add(asList(cookies));
-  }
-
-  public List<Cookie> takeResponseCookies() {
-    return responseCookies.removeFirst();
-  }
-
-  public void assertResponseCookies(String... cookies) {
-    List<Cookie> actualCookies = takeResponseCookies();
-    List<String> actualCookieStrings = new ArrayList<>();
-    for (Cookie cookie : actualCookies) {
-      actualCookieStrings.add(cookie.toString());
-    }
-    assertThat(actualCookieStrings).containsExactly(cookies);
-  }
-
-  @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
-    responseCookies.add(cookies);
-  }
-
-  @Override public List<Cookie> loadForRequest(HttpUrl url) {
-    if (requestCookies.isEmpty()) return Collections.emptyList();
-    return requestCookies.removeFirst();
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/RecordingEventListener.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingEventListener.java
deleted file mode 100644
index 8bd4f86f57..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/RecordingEventListener.java
+++ /dev/null
@@ -1,470 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.util.ArrayList;
-import java.util.Deque;
-import java.util.List;
-import java.util.concurrent.ConcurrentLinkedDeque;
-import javax.annotation.Nullable;
-
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertTrue;
-
-public class RecordingEventListener extends EventListener {
-  final Deque<CallEvent> eventSequence = new ConcurrentLinkedDeque<>();
-
-  final List<Object> forbiddenLocks = new ArrayList<>();
-
-  /** Confirm that the thread does not hold a lock on {@code lock} during the callback. */
-  public void forbidLock(Object lock) {
-    forbiddenLocks.add(lock);
-  }
-
-  /**
-   * Removes recorded events up to (and including) an event is found whose class equals
-   * {@code eventClass} and returns it.
-   */
-  public <T> T removeUpToEvent(Class<T> eventClass) {
-    List<CallEvent> fullEventSequence = new ArrayList<>(eventSequence);
-    Object event = eventSequence.poll();
-    while (event != null && !eventClass.isInstance(event)) {
-      event = eventSequence.poll();
-    }
-    if (event == null) {
-      throw new AssertionError(
-          eventClass.getSimpleName() + " not found. Found " + fullEventSequence + ".");
-    }
-    return eventClass.cast(event);
-  }
-
-  public List<String> recordedEventTypes() {
-    List<String> eventTypes = new ArrayList<>();
-    for (CallEvent event : eventSequence) {
-      eventTypes.add(event.getName());
-    }
-    return eventTypes;
-  }
-
-  public void clearAllEvents() {
-    eventSequence.clear();
-  }
-
-  private void logEvent(CallEvent e) {
-    for (Object lock : forbiddenLocks) {
-      assertThat(Thread.holdsLock(lock)).overridingErrorMessage(lock.toString()).isFalse();
-    }
-
-    CallEvent startEvent = e.closes();
-
-    if (startEvent != null) {
-      assertTrue(eventSequence.contains(startEvent));
-    }
-
-    eventSequence.offer(e);
-  }
-
-  @Override public void proxySelectStart(Call call, HttpUrl url) {
-    logEvent(new ProxySelectStart(call, url));
-  }
-
-  @Override public void proxySelectEnd(Call call, HttpUrl url,
-      List<Proxy> proxies) {
-    logEvent(new ProxySelectEnd(call, url, proxies));
-  }
-
-  @Override public void dnsStart(Call call, String domainName) {
-    logEvent(new DnsStart(call, domainName));
-  }
-
-  @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
-    logEvent(new DnsEnd(call, domainName, inetAddressList));
-  }
-
-  @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
-      Proxy proxy) {
-    logEvent(new ConnectStart(call, inetSocketAddress, proxy));
-  }
-
-  @Override public void secureConnectStart(Call call) {
-    logEvent(new SecureConnectStart(call));
-  }
-
-  @Override public void secureConnectEnd(Call call, Handshake handshake) {
-    logEvent(new SecureConnectEnd(call, handshake));
-  }
-
-  @Override public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
-      @Nullable Proxy proxy, Protocol protocol) {
-    logEvent(new ConnectEnd(call, inetSocketAddress, proxy, protocol));
-  }
-
-  @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
-      @Nullable Protocol protocol, IOException ioe) {
-    logEvent(new ConnectFailed(call, inetSocketAddress, proxy, protocol, ioe));
-  }
-
-  @Override public void connectionAcquired(Call call, Connection connection) {
-    logEvent(new ConnectionAcquired(call, connection));
-  }
-
-  @Override public void connectionReleased(Call call, Connection connection) {
-    logEvent(new ConnectionReleased(call, connection));
-  }
-
-  @Override public void callStart(Call call) {
-    logEvent(new CallStart(call));
-  }
-
-  @Override public void requestHeadersStart(Call call) {
-    logEvent(new RequestHeadersStart(call));
-  }
-
-  @Override public void requestHeadersEnd(Call call, Request request) {
-    logEvent(new RequestHeadersEnd(call, request.headers().byteCount()));
-  }
-
-  @Override public void requestBodyStart(Call call) {
-    logEvent(new RequestBodyStart(call));
-  }
-
-  @Override public void requestBodyEnd(Call call, long byteCount) {
-    logEvent(new RequestBodyEnd(call, byteCount));
-  }
-
-  @Override public void requestFailed(Call call, IOException ioe) {
-    logEvent(new RequestFailed(call, ioe));
-  }
-
-  @Override public void responseHeadersStart(Call call) {
-    logEvent(new ResponseHeadersStart(call));
-  }
-
-  @Override public void responseHeadersEnd(Call call, Response response) {
-    logEvent(new ResponseHeadersEnd(call, response.headers().byteCount()));
-  }
-
-  @Override public void responseBodyStart(Call call) {
-    logEvent(new ResponseBodyStart(call));
-  }
-
-  @Override public void responseBodyEnd(Call call, long byteCount) {
-    logEvent(new ResponseBodyEnd(call, byteCount));
-  }
-
-  @Override public void responseFailed(Call call, IOException ioe) {
-    logEvent(new ResponseFailed(call, ioe));
-  }
-
-  @Override public void callEnd(Call call) {
-    logEvent(new CallEnd(call));
-  }
-
-  @Override public void callFailed(Call call, IOException ioe) {
-    logEvent(new CallFailed(call, ioe));
-  }
-
-  static class CallEvent {
-    final Call call;
-    final List<Object> params;
-
-    CallEvent(Call call, Object... params) {
-      this.call = call;
-      this.params = asList(params);
-    }
-
-    public String getName() {
-      return getClass().getSimpleName();
-    }
-
-    @Override public boolean equals(Object o) {
-      if (this == o) return true;
-      if (!(o instanceof CallEvent)) return false;
-
-      CallEvent callEvent = (CallEvent) o;
-
-      if (!getName().equals(callEvent.getName())) return false;
-      if (!call.equals(callEvent.call)) return false;
-      return params.equals(callEvent.params);
-    }
-
-    @Override public int hashCode() {
-      int result = call.hashCode();
-      result = 31 * result + getName().hashCode();
-      result = 31 * result + params.hashCode();
-      return result;
-    }
-
-    public @Nullable CallEvent closes() {
-      return null;
-    }
-  }
-
-  static final class ProxySelectStart extends CallEvent {
-    final HttpUrl url;
-
-    ProxySelectStart(Call call, HttpUrl url) {
-      super(call, url);
-      this.url = url;
-    }
-  }
-
-  static final class ProxySelectEnd extends CallEvent {
-    final HttpUrl url;
-
-    ProxySelectEnd(Call call, HttpUrl url, List<Proxy> proxies) {
-      super(call, url, proxies);
-      this.url = url;
-    }
-  }
-
-  static final class DnsStart extends CallEvent {
-    final String domainName;
-
-    DnsStart(Call call, String domainName) {
-      super(call, domainName);
-      this.domainName = domainName;
-    }
-  }
-
-  static final class DnsEnd extends CallEvent {
-    final String domainName;
-    final List<InetAddress> inetAddressList;
-
-    DnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
-      super(call, domainName, inetAddressList);
-      this.domainName = domainName;
-      this.inetAddressList = inetAddressList;
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new DnsStart(call, domainName);
-    }
-  }
-
-  static final class ConnectStart extends CallEvent {
-    final InetSocketAddress inetSocketAddress;
-    final Proxy proxy;
-
-    ConnectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
-      super(call, inetSocketAddress, proxy);
-      this.inetSocketAddress = inetSocketAddress;
-      this.proxy = proxy;
-    }
-  }
-
-  static final class ConnectEnd extends CallEvent {
-    final InetSocketAddress inetSocketAddress;
-    final Protocol protocol;
-    final Proxy proxy;
-
-    ConnectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol) {
-      super(call, inetSocketAddress, proxy, protocol);
-      this.inetSocketAddress = inetSocketAddress;
-      this.proxy = proxy;
-      this.protocol = protocol;
-    }
-
-    @Override public CallEvent closes() {
-      return new ConnectStart(call, inetSocketAddress, proxy);
-    }
-  }
-
-  static final class ConnectFailed extends CallEvent {
-    final InetSocketAddress inetSocketAddress;
-    final Protocol protocol;
-    final Proxy proxy;
-    final IOException ioe;
-
-    ConnectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol,
-        IOException ioe) {
-      super(call, inetSocketAddress, proxy, protocol, ioe);
-      this.inetSocketAddress = inetSocketAddress;
-      this.proxy = proxy;
-      this.protocol = protocol;
-      this.ioe = ioe;
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new ConnectStart(call, inetSocketAddress, proxy);
-    }
-  }
-
-  static final class SecureConnectStart extends CallEvent {
-    SecureConnectStart(Call call) {
-      super(call);
-    }
-  }
-
-  static final class SecureConnectEnd extends CallEvent {
-    final Handshake handshake;
-
-    SecureConnectEnd(Call call, Handshake handshake) {
-      super(call, handshake);
-      this.handshake = handshake;
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new SecureConnectStart(call);
-    }
-  }
-
-  static final class ConnectionAcquired extends CallEvent {
-    final Connection connection;
-
-    ConnectionAcquired(Call call, Connection connection) {
-      super(call, connection);
-      this.connection = connection;
-    }
-  }
-
-  static final class ConnectionReleased extends CallEvent {
-    final Connection connection;
-
-    ConnectionReleased(Call call, Connection connection) {
-      super(call, connection);
-      this.connection = connection;
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new ConnectionAcquired(call, connection);
-    }
-  }
-
-  static final class CallStart extends CallEvent {
-    CallStart(Call call) {
-      super(call);
-    }
-  }
-
-  static final class CallEnd extends CallEvent {
-    CallEnd(Call call) {
-      super(call);
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new CallStart(call);
-    }
-  }
-
-  static final class CallFailed extends CallEvent {
-    final IOException ioe;
-
-    CallFailed(Call call, IOException ioe) {
-      super(call, ioe);
-      this.ioe = ioe;
-    }
-  }
-
-  static final class RequestHeadersStart extends CallEvent {
-    RequestHeadersStart(Call call) {
-      super(call);
-    }
-  }
-
-  static final class RequestHeadersEnd extends CallEvent {
-    final long headerLength;
-
-    RequestHeadersEnd(Call call, long headerLength) {
-      super(call, headerLength);
-      this.headerLength = headerLength;
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new RequestHeadersStart(call);
-    }
-  }
-
-  static final class RequestBodyStart extends CallEvent {
-    RequestBodyStart(Call call) {
-      super(call);
-    }
-  }
-
-  static final class RequestBodyEnd extends CallEvent {
-    final long bytesWritten;
-
-    RequestBodyEnd(Call call, long bytesWritten) {
-      super(call, bytesWritten);
-      this.bytesWritten = bytesWritten;
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new RequestBodyStart(call);
-    }
-  }
-
-  static final class RequestFailed extends CallEvent {
-    final IOException ioe;
-
-    RequestFailed(Call call, IOException ioe) {
-      super(call, ioe);
-      this.ioe = ioe;
-    }
-  }
-
-  static final class ResponseHeadersStart extends CallEvent {
-    ResponseHeadersStart(Call call) {
-      super(call);
-    }
-  }
-
-  static final class ResponseHeadersEnd extends CallEvent {
-    final long headerLength;
-
-    ResponseHeadersEnd(Call call, long headerLength) {
-      super(call, headerLength);
-      this.headerLength = headerLength;
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new RequestHeadersStart(call);
-    }
-  }
-
-  static final class ResponseBodyStart extends CallEvent {
-    ResponseBodyStart(Call call) {
-      super(call);
-    }
-  }
-
-  static final class ResponseBodyEnd extends CallEvent {
-    final long bytesRead;
-
-    ResponseBodyEnd(Call call, long bytesRead) {
-      super(call, bytesRead);
-      this.bytesRead = bytesRead;
-    }
-
-    @Override public @Nullable CallEvent closes() {
-      return new ResponseBodyStart(call);
-    }
-  }
-
-  static final class ResponseFailed extends CallEvent {
-    final IOException ioe;
-
-    ResponseFailed(Call call, IOException ioe) {
-      super(call, ioe);
-      this.ioe = ioe;
-    }
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
deleted file mode 100644
index 7bae3ccac8..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.List;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
-
-public final class RecordingHostnameVerifier implements HostnameVerifier {
-  public final List<String> calls = new ArrayList<>();
-
-  @Override
-  public synchronized boolean verify(String hostname, SSLSession session) {
-    calls.add("verify " + hostname);
-    return true;
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java b/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
deleted file mode 100644
index 8a6bc3443c..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import okhttp3.internal.http2.Header;
-
-import static org.junit.Assume.assumeNoException;
-
-public final class TestUtil {
-  public static final InetSocketAddress UNREACHABLE_ADDRESS
-      = new InetSocketAddress("198.51.100.1", 8080);
-
-  private TestUtil() {
-  }
-
-  public static List<Header> headerEntries(String... elements) {
-    List<Header> result = new ArrayList<>(elements.length / 2);
-    for (int i = 0; i < elements.length; i += 2) {
-      result.add(new Header(elements[i], elements[i + 1]));
-    }
-    return result;
-  }
-
-  public static String repeat(char c, int count) {
-    char[] array = new char[count];
-    Arrays.fill(array, c);
-    return new String(array);
-  }
-
-  /**
-   * See FinalizationTester for discussion on how to best trigger GC in tests.
-   * https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
-   * java/lang/ref/FinalizationTester.java
-   */
-  public static void awaitGarbageCollection() throws Exception {
-    Runtime.getRuntime().gc();
-    Thread.sleep(100);
-    System.runFinalization();
-  }
-
-  public static void assumeNetwork() {
-    try {
-      InetAddress.getByName("www.google.com");
-    } catch (UnknownHostException uhe) {
-      assumeNoException(uhe);
-    }
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/UppercaseRequestInterceptor.java b/okhttp-testing-support/src/main/java/okhttp3/UppercaseRequestInterceptor.java
deleted file mode 100644
index 490c266116..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/UppercaseRequestInterceptor.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-import okio.ForwardingSink;
-import okio.Okio;
-import okio.Sink;
-
-/** Rewrites the request body sent to the server to be all uppercase. */
-public final class UppercaseRequestInterceptor implements Interceptor {
-  @Override public Response intercept(Chain chain) throws IOException {
-    return chain.proceed(uppercaseRequest(chain.request()));
-  }
-
-  /** Returns a request that transforms {@code request} to be all uppercase. */
-  private Request uppercaseRequest(Request request) {
-    RequestBody uppercaseBody = new ForwardingRequestBody(request.body()) {
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        delegate().writeTo(Okio.buffer(uppercaseSink(sink)));
-      }
-    };
-    return request.newBuilder()
-        .method(request.method(), uppercaseBody)
-        .build();
-  }
-
-  private Sink uppercaseSink(Sink sink) {
-    return new ForwardingSink(sink) {
-      @Override public void write(Buffer source, long byteCount) throws IOException {
-        ByteString bytes = source.readByteString(byteCount);
-        delegate().write(new Buffer().write(bytes.toAsciiUppercase()), byteCount);
-      }
-    };
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/UppercaseResponseInterceptor.java b/okhttp-testing-support/src/main/java/okhttp3/UppercaseResponseInterceptor.java
deleted file mode 100644
index 7fbf8ef479..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/UppercaseResponseInterceptor.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ForwardingSource;
-import okio.Okio;
-
-/** Rewrites the response body returned from the server to be all uppercase. */
-public final class UppercaseResponseInterceptor implements Interceptor {
-  @Override public Response intercept(Chain chain) throws IOException {
-    return uppercaseResponse(chain.proceed(chain.request()));
-  }
-
-  private Response uppercaseResponse(Response response) {
-    ResponseBody uppercaseBody = new ForwardingResponseBody(response.body()) {
-      @Override public BufferedSource source() {
-        return Okio.buffer(uppercaseSource(delegate().source()));
-      }
-    };
-    return response.newBuilder()
-        .body(uppercaseBody)
-        .build();
-  }
-
-  private ForwardingSource uppercaseSource(BufferedSource source) {
-    return new ForwardingSource(source) {
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        Buffer buffer = new Buffer();
-        long read = delegate().read(buffer, byteCount);
-        if (read != -1L) sink.write(buffer.readByteString().toAsciiUppercase());
-        return read;
-      }
-    };
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/internal/duplex/AsyncRequestBody.java b/okhttp-testing-support/src/main/java/okhttp3/internal/duplex/AsyncRequestBody.java
deleted file mode 100644
index a6b554adcb..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/internal/duplex/AsyncRequestBody.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.duplex;
-
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okio.BufferedSink;
-
-import static junit.framework.TestCase.assertTrue;
-
-/** A duplex request body that keeps the provided sinks so they can be written to later. */
-public final class AsyncRequestBody extends RequestBody {
-  private final BlockingQueue<BufferedSink> requestBodySinks = new LinkedBlockingQueue<>();
-
-  @Override public @Nullable MediaType contentType() {
-    return null;
-  }
-
-  @Override public void writeTo(BufferedSink sink) {
-    requestBodySinks.add(sink);
-  }
-
-  @Override public boolean isDuplex() {
-    return true;
-  }
-
-  public BufferedSink takeSink() throws InterruptedException {
-    BufferedSink result = requestBodySinks.poll(5, TimeUnit.SECONDS);
-    if (result == null) throw new AssertionError("no sink to take");
-    return result;
-  }
-
-  public void assertNoMoreSinks() {
-    assertTrue(requestBodySinks.isEmpty());
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java b/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
deleted file mode 100644
index bb6f519092..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/internal/io/InMemoryFileSystem.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.io;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.IdentityHashMap;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import okio.Buffer;
-import okio.ForwardingSink;
-import okio.ForwardingSource;
-import okio.Sink;
-import okio.Source;
-import org.junit.rules.TestRule;
-import org.junit.runner.Description;
-import org.junit.runners.model.Statement;
-
-/** A simple file system where all files are held in memory. Not safe for concurrent use. */
-public final class InMemoryFileSystem implements FileSystem, TestRule {
-  private final Map<File, Buffer> files = new LinkedHashMap<>();
-  private final Map<Source, File> openSources = new IdentityHashMap<>();
-  private final Map<Sink, File> openSinks = new IdentityHashMap<>();
-
-  @Override public Statement apply(final Statement base, Description description) {
-    return new Statement() {
-      @Override public void evaluate() throws Throwable {
-        base.evaluate();
-        ensureResourcesClosed();
-      }
-    };
-  }
-
-  public void ensureResourcesClosed() {
-    List<String> openResources = new ArrayList<>();
-    for (File file : openSources.values()) {
-      openResources.add("Source for " + file);
-    }
-    for (File file : openSinks.values()) {
-      openResources.add("Sink for " + file);
-    }
-    if (!openResources.isEmpty()) {
-      StringBuilder builder = new StringBuilder("Resources acquired but not closed:");
-      for (String resource : openResources) {
-        builder.append("\n * ").append(resource);
-      }
-      throw new IllegalStateException(builder.toString());
-    }
-  }
-
-  @Override public Source source(File file) throws FileNotFoundException {
-    Buffer result = files.get(file);
-    if (result == null) throw new FileNotFoundException();
-
-    final Source source = result.clone();
-    openSources.put(source, file);
-
-    return new ForwardingSource(source) {
-      @Override public void close() throws IOException {
-        openSources.remove(source);
-        super.close();
-      }
-    };
-  }
-
-  @Override public Sink sink(File file) throws FileNotFoundException {
-    return sink(file, false);
-  }
-
-  @Override public Sink appendingSink(File file) throws FileNotFoundException {
-    return sink(file, true);
-  }
-
-  private Sink sink(File file, boolean appending) {
-    Buffer result = null;
-    if (appending) {
-      result = files.get(file);
-    }
-    if (result == null) {
-      result = new Buffer();
-    }
-    files.put(file, result);
-
-    final Sink sink = result;
-    openSinks.put(sink, file);
-
-    return new ForwardingSink(sink) {
-      @Override public void close() throws IOException {
-        openSinks.remove(sink);
-        super.close();
-      }
-    };
-  }
-
-  @Override public void delete(File file) throws IOException {
-    files.remove(file);
-  }
-
-  @Override public boolean exists(File file) {
-    return files.containsKey(file);
-  }
-
-  @Override public long size(File file) {
-    Buffer buffer = files.get(file);
-    return buffer != null ? buffer.size() : 0L;
-  }
-
-  @Override public void rename(File from, File to) throws IOException {
-    Buffer buffer = files.remove(from);
-    if (buffer == null) throw new FileNotFoundException();
-    files.put(to, buffer);
-  }
-
-  @Override public void deleteContents(File directory) throws IOException {
-    String prefix = directory.toString() + "/";
-    for (Iterator<File> i = files.keySet().iterator(); i.hasNext(); ) {
-      File file = i.next();
-      if (file.toString().startsWith(prefix)) i.remove();
-    }
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/Flaky.kt b/okhttp-testing-support/src/main/java/okhttp3/testing/Flaky.kt
deleted file mode 100644
index f3b04d8809..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/testing/Flaky.kt
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.testing
-
-@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)
-@Retention(AnnotationRetention.RUNTIME)
-/**
- * Annotation marking a test as flaky, and requires extra logging and linking against
- * a known github issue.  This does not ignore the failure.
- */
-annotation class Flaky
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
deleted file mode 100644
index c1768dcd4b..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.testing;
-
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import org.junit.internal.Throwables;
-import org.junit.runner.Description;
-import org.junit.runner.Result;
-import org.junit.runner.notification.RunListener;
-
-/**
- * A {@link org.junit.runner.notification.RunListener} used to install an aggressive default {@link
- * java.lang.Thread.UncaughtExceptionHandler} similar to the one found on Android. No exceptions
- * should escape from OkHttp that might cause apps to be killed or tests to fail on Android.
- */
-public class InstallUncaughtExceptionHandlerListener extends RunListener {
-
-  private Thread.UncaughtExceptionHandler oldDefaultUncaughtExceptionHandler;
-  private Description lastTestStarted;
-  private final Map<Throwable, String> exceptions = new LinkedHashMap<>();
-
-  @Override public void testRunStarted(Description description) {
-    System.err.println("Installing aggressive uncaught exception handler");
-    oldDefaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
-    Thread.setDefaultUncaughtExceptionHandler((thread, throwable) -> {
-      StringWriter errorText = new StringWriter(256);
-      errorText.append("Uncaught exception in OkHttp thread \"");
-      errorText.append(thread.getName());
-      errorText.append("\"\n");
-      throwable.printStackTrace(new PrintWriter(errorText));
-      errorText.append("\n");
-      if (lastTestStarted != null) {
-        errorText.append("Last test to start was: ");
-        errorText.append(lastTestStarted.getDisplayName());
-        errorText.append("\n");
-      }
-      System.err.print(errorText.toString());
-
-      synchronized (exceptions) {
-        exceptions.put(throwable, lastTestStarted.getDisplayName());
-      }
-    });
-  }
-
-  @Override public void testStarted(Description description) {
-    lastTestStarted = description;
-  }
-
-  @Override public void testRunFinished(Result result) throws Exception {
-    Thread.setDefaultUncaughtExceptionHandler(oldDefaultUncaughtExceptionHandler);
-    System.err.println("Uninstalled aggressive uncaught exception handler");
-
-    synchronized (exceptions) {
-      if (!exceptions.isEmpty()) {
-        throw Throwables.rethrowAsException(exceptions.keySet().iterator().next());
-      }
-    }
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/PlatformRule.kt b/okhttp-testing-support/src/main/java/okhttp3/testing/PlatformRule.kt
deleted file mode 100644
index 172f11e8b6..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/testing/PlatformRule.kt
+++ /dev/null
@@ -1,312 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.testing
-
-import okhttp3.internal.platform.ConscryptPlatform
-import okhttp3.internal.platform.Jdk8WithJettyBootPlatform
-import okhttp3.internal.platform.Jdk9Platform
-import okhttp3.internal.platform.OpenJSSEPlatform
-import okhttp3.internal.platform.Platform
-import org.conscrypt.Conscrypt
-import org.hamcrest.BaseMatcher
-import org.hamcrest.CoreMatchers
-import org.hamcrest.CoreMatchers.equalTo
-import org.hamcrest.CoreMatchers.not
-import org.hamcrest.Description
-import org.hamcrest.Matcher
-import org.hamcrest.StringDescription
-import org.hamcrest.TypeSafeMatcher
-import org.junit.Assert
-import org.junit.Assume.assumeThat
-import org.junit.Assume.assumeTrue
-import org.junit.AssumptionViolatedException
-import org.junit.rules.TestRule
-import org.junit.runners.model.Statement
-import org.openjsse.net.ssl.OpenJSSE
-import java.security.Security
-
-/**
- * Marks a test as Platform aware, before the test runs a consistent Platform will be
- * established e.g. SecurityProvider for Conscrypt installed.
- *
- * Also allows a test file to state general platform assumptions, or for individual test.
- */
-@Suppress("unused", "MemberVisibilityCanBePrivate")
-open class PlatformRule @JvmOverloads constructor(
-  val requiredPlatformName: String? = null,
-  val platform: Platform? = null
-) : TestRule {
-  private val versionChecks = mutableListOf<Pair<Matcher<out Any>, Matcher<out Any>>>()
-
-  override fun apply(base: Statement, description: org.junit.runner.Description): Statement {
-    return object : Statement() {
-      @Throws(Throwable::class)
-      override fun evaluate() {
-        var failed = false
-        try {
-          setupPlatform()
-
-          System.err.println("Running with ${Platform.get().javaClass.simpleName}")
-
-          base.evaluate()
-        } catch (e: AssumptionViolatedException) {
-          throw e
-        } catch (e: Throwable) {
-          failed = true
-          rethrowIfNotExpected(e)
-        } finally {
-          resetPlatform()
-        }
-        if (!failed) {
-          failIfExpected()
-        }
-      }
-    }
-  }
-
-  fun setupPlatform() {
-    if (requiredPlatformName != null) {
-      assumeThat(getPlatformSystemProperty(), equalTo(requiredPlatformName))
-    }
-
-    if (platform != null) {
-      Platform.resetForTests(platform)
-    } else {
-      Platform.resetForTests()
-    }
-  }
-
-  fun resetPlatform() {
-    if (platform != null) {
-      Platform.resetForTests()
-    }
-  }
-
-  fun expectFailureOnConscryptPlatform() {
-    expectFailure(platformMatches(CONSCRYPT_PROPERTY))
-  }
-
-  fun expectFailureOnOpenJSSEPlatform() {
-    expectFailure(platformMatches(OPENJSSE_PROPERTY))
-  }
-
-  fun expectFailureFromJdkVersion(majorVersion: Int) {
-    expectFailure(fromMajor(majorVersion))
-  }
-
-  private fun expectFailure(
-    versionMatcher: Matcher<out Any>,
-    failureMatcher: Matcher<out Any> = CoreMatchers.anything()
-  ) {
-    versionChecks.add(Pair(versionMatcher, failureMatcher))
-  }
-
-  fun platformMatches(platform: String): Matcher<Any> = object : BaseMatcher<Any>() {
-    override fun describeTo(description: Description) {
-      description.appendText(platform)
-    }
-
-    override fun matches(item: Any?): Boolean {
-      return getPlatformSystemProperty() == platform
-    }
-  }
-
-  fun fromMajor(version: Int): Matcher<PlatformVersion> {
-    return object : TypeSafeMatcher<PlatformVersion>() {
-      override fun describeTo(description: Description) {
-        description.appendText("JDK with version from $version")
-      }
-
-      override fun matchesSafely(item: PlatformVersion): Boolean {
-        return item.majorVersion >= version
-      }
-    }
-  }
-
-  fun rethrowIfNotExpected(e: Throwable) {
-    versionChecks.forEach { (versionMatcher, failureMatcher) ->
-      if (versionMatcher.matches(PlatformVersion) && failureMatcher.matches(e)) {
-        return
-      }
-    }
-
-    throw e
-  }
-
-  fun failIfExpected() {
-    versionChecks.forEach { (versionMatcher, failureMatcher) ->
-      if (versionMatcher.matches(PlatformVersion)) {
-        val description = StringDescription()
-        versionMatcher.describeTo(description)
-        description.appendText(" expected to fail with exception that ")
-        failureMatcher.describeTo(description)
-
-        Assert.fail(description.toString())
-      }
-    }
-  }
-
-  fun isConscrypt() = getPlatformSystemProperty() == CONSCRYPT_PROPERTY
-
-  fun isJdk9() = getPlatformSystemProperty() == JDK9_PROPERTY
-
-  fun isJdk8() = getPlatformSystemProperty() == JDK8_PROPERTY
-
-  fun isJdk8Alpn() = getPlatformSystemProperty() == JDK8_ALPN_PROPERTY
-
-  fun hasHttp2Support() = !isJdk8()
-
-  fun assumeConscrypt() {
-    assumeThat(getPlatformSystemProperty(), equalTo(
-        CONSCRYPT_PROPERTY))
-  }
-
-  fun assumeJdk9() {
-    assumeThat(getPlatformSystemProperty(), equalTo(
-        JDK9_PROPERTY))
-  }
-
-  fun assumeOpenJSSE() {
-    assumeThat(getPlatformSystemProperty(), equalTo(
-        OPENJSSE_PROPERTY))
-  }
-
-  fun assumeJdk8() {
-    assumeThat(getPlatformSystemProperty(), equalTo(
-        JDK8_PROPERTY))
-  }
-
-  fun assumeJdk8Alpn() {
-    assumeThat(getPlatformSystemProperty(), equalTo(
-        JDK8_ALPN_PROPERTY))
-  }
-
-  fun assumeHttp2Support() {
-    assumeThat(getPlatformSystemProperty(), not(
-        JDK8_PROPERTY))
-  }
-
-  fun assumeNotConscrypt() {
-    assumeThat(getPlatformSystemProperty(), not(
-        CONSCRYPT_PROPERTY))
-  }
-
-  fun assumeNotJdk9() {
-    assumeThat(getPlatformSystemProperty(), not(
-        JDK9_PROPERTY))
-  }
-
-  fun assumeNotJdk8() {
-    assumeThat(getPlatformSystemProperty(), not(
-        JDK8_PROPERTY))
-  }
-
-  fun assumeNotJdk8Alpn() {
-    assumeThat(getPlatformSystemProperty(), not(
-        JDK8_ALPN_PROPERTY))
-  }
-
-  fun assumeNotOpenJSSE() {
-    assumeThat(getPlatformSystemProperty(), not(
-        OPENJSSE_PROPERTY))
-  }
-
-  fun assumeNotHttp2Support() {
-    assumeThat(getPlatformSystemProperty(), equalTo(
-        JDK8_PROPERTY))
-  }
-
-  fun assumeJettyBootEnabled() {
-    assumeTrue("ALPN Boot not enabled", isAlpnBootEnabled())
-  }
-
-  companion object {
-    const val PROPERTY_NAME = "okhttp.platform"
-    const val CONSCRYPT_PROPERTY = "conscrypt"
-    const val JDK9_PROPERTY = "jdk9"
-    const val JDK8_ALPN_PROPERTY = "jdk8alpn"
-    const val JDK8_PROPERTY = "jdk8"
-    const val OPENJSSE_PROPERTY = "openjsse"
-
-    init {
-      if (getPlatformSystemProperty() == CONSCRYPT_PROPERTY && Security.getProviders()[0].name != "Conscrypt") {
-        if (!Conscrypt.isAvailable()) {
-          System.err.println("Warning: Conscrypt not available")
-        }
-
-        val provider = Conscrypt.newProviderBuilder().provideTrustManager(true).build()
-        Security.insertProviderAt(provider, 1)
-      } else if (getPlatformSystemProperty() == JDK8_ALPN_PROPERTY) {
-        if (!isAlpnBootEnabled()) {
-          System.err.println("Warning: ALPN Boot not enabled")
-        }
-      } else if (getPlatformSystemProperty() == JDK8_PROPERTY) {
-        if (isAlpnBootEnabled()) {
-          System.err.println("Warning: ALPN Boot enabled unintentionally")
-        }
-      } else if (getPlatformSystemProperty() == OPENJSSE_PROPERTY && Security.getProviders()[0].name != "OpenJSSE") {
-        if (!OpenJSSEPlatform.isSupported) {
-          System.err.println("Warning: OpenJSSE not available")
-        }
-
-        Security.insertProviderAt(OpenJSSE(), 1)
-      }
-
-      Platform.resetForTests()
-    }
-
-    @JvmStatic
-    fun getPlatformSystemProperty(): String {
-      var property: String? = System.getProperty(
-          PROPERTY_NAME)
-
-      if (property == null) {
-        property = when (Platform.get()) {
-          is ConscryptPlatform -> CONSCRYPT_PROPERTY
-          is OpenJSSEPlatform -> OPENJSSE_PROPERTY
-          is Jdk8WithJettyBootPlatform -> CONSCRYPT_PROPERTY
-//          is Jdk9Platform -> JDK9_PROPERTY
-          else -> JDK8_PROPERTY
-        }
-      }
-
-      return property
-    }
-
-    @JvmStatic
-    fun conscrypt() = PlatformRule(CONSCRYPT_PROPERTY)
-
-    @JvmStatic
-    fun openjsse() = PlatformRule(OPENJSSE_PROPERTY)
-
-    @JvmStatic
-    fun jdk9() = PlatformRule(JDK9_PROPERTY)
-
-    @JvmStatic
-    fun jdk8() = PlatformRule(JDK8_PROPERTY)
-
-    @JvmStatic
-    fun jdk8alpn() = PlatformRule(JDK8_ALPN_PROPERTY)
-
-    @JvmStatic
-    fun isAlpnBootEnabled(): Boolean = try {
-      Class.forName("org.eclipse.jetty.alpn.ALPN", true, null)
-      true
-    } catch (cnfe: ClassNotFoundException) {
-      false
-    }
-  }
-}
\ No newline at end of file
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/PlatformVersion.kt b/okhttp-testing-support/src/main/java/okhttp3/testing/PlatformVersion.kt
deleted file mode 100644
index 17870a7ba7..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/testing/PlatformVersion.kt
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.testing
-
-object PlatformVersion {
-  val majorVersion: Int by lazy {
-    when (val jvmSpecVersion = getJvmSpecVersion()) {
-      "1.8" -> 8
-      else -> jvmSpecVersion.toInt()
-    }
-  }
-
-  fun getJvmSpecVersion(): String {
-    return System.getProperty("java.specification.version", "unknown")
-  }
-}
\ No newline at end of file
diff --git a/okhttp-testing-support/src/test/kotlin/okhttp3/testing/PlatformRuleTest.kt b/okhttp-testing-support/src/test/kotlin/okhttp3/testing/PlatformRuleTest.kt
deleted file mode 100644
index 5fe531cd00..0000000000
--- a/okhttp-testing-support/src/test/kotlin/okhttp3/testing/PlatformRuleTest.kt
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.testing
-
-import okhttp3.internal.platform.Platform
-import org.junit.Rule
-import org.junit.Test
-
-/**
- * Sanity test for checking which environment and IDE is picking up.
- */
-class PlatformRuleTest {
-  @Suppress("RedundantVisibilityModifier")
-  @JvmField
-  @Rule public val platform = PlatformRule()
-
-  @Test
-  fun testMode() {
-    println(PlatformRule.getPlatformSystemProperty())
-    println(Platform.get().javaClass.simpleName)
-  }
-  @Test
-  fun testGreenCase() {
-  }
-
-  @Test
-  fun testGreenCaseFailingOnLater() {
-    platform.expectFailureFromJdkVersion(PlatformVersion.majorVersion + 1)
-  }
-
-  @Test
-  fun failureCase() {
-    platform.expectFailureFromJdkVersion(PlatformVersion.majorVersion)
-
-    check(false)
-  }
-}
\ No newline at end of file
diff --git a/okhttp-tls/build.gradle b/okhttp-tls/build.gradle
index 011d8c0abc..b3847c6368 100644
--- a/okhttp-tls/build.gradle
+++ b/okhttp-tls/build.gradle
@@ -13,9 +13,6 @@ dependencies {
   implementation deps.bouncycastle
   compileOnly deps.jsr305
 
-  testImplementation project(':okhttp-testing-support')
-  testImplementation deps.junit
-  testImplementation deps.assertj
 }
 
 afterEvaluate { project ->
diff --git a/okhttp-urlconnection/build.gradle b/okhttp-urlconnection/build.gradle
index 8a197bdcd3..5c8a1436c7 100644
--- a/okhttp-urlconnection/build.gradle
+++ b/okhttp-urlconnection/build.gradle
@@ -12,11 +12,6 @@ dependencies {
   compileOnly deps.jsr305
   compileOnly deps.animalSniffer
 
-  testImplementation project(':okhttp-testing-support')
-  testImplementation project(':okhttp-tls')
-  testImplementation project(':mockwebserver')
-  testImplementation deps.junit
-  testImplementation deps.assertj
 }
 
 afterEvaluate { project ->
diff --git a/okhttp/build.gradle b/okhttp/build.gradle
index 8c88317eb9..4af6912edf 100644
--- a/okhttp/build.gradle
+++ b/okhttp/build.gradle
@@ -31,16 +31,6 @@ dependencies {
   compileOnly deps.jsr305
   compileOnly deps.animalSniffer
 
-  testImplementation project(':okhttp-testing-support')
-  testImplementation project(':okhttp-tls')
-  testImplementation project(':okhttp-urlconnection')
-  testImplementation project(':mockwebserver')
-  testImplementation project(':okhttp-logging-interceptor')
-  testImplementation deps.conscrypt
-  testImplementation deps.junit
-  testImplementation deps.assertj
-  testImplementation deps.openjsse
-  testCompileOnly deps.jsr305
 }
 
 afterEvaluate { project ->
diff --git a/settings.gradle b/settings.gradle
index 0c126509a1..8fb2322a27 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,6 +1,5 @@
 rootProject.name = 'okhttp-parent'
 
-include ':mockwebserver'
 
 include ':okcurl'
 include ':okhttp'
@@ -8,6 +7,5 @@ include ':okhttp-brotli'
 include ':okhttp-dnsoverhttps'
 include ':okhttp-logging-interceptor'
 include ':okhttp-sse'
-include ':okhttp-testing-support'
 include ':okhttp-tls'
 include ':okhttp-urlconnection'
