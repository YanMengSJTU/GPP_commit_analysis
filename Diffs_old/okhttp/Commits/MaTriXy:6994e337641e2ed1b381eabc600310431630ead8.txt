diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
index ed71fc3ccb..d9a8e909da 100755
--- a/.buildscript/deploy_snapshot.sh
+++ b/.buildscript/deploy_snapshot.sh
@@ -3,7 +3,7 @@
 # Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
 #
 # Adapted from https://coderwall.com/p/9b_lfq and
-# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
+# https://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
 
 SLUG="square/okhttp"
 JDK="oraclejdk8"
diff --git a/.travis.yml b/.travis.yml
index 050768bd34..1ebb5eb306 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -2,6 +2,7 @@ language: java
 
 jdk:
   - oraclejdk8
+#  - openjdk11
 
 addons:
   apt:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index a85ae84e5b..1f480f2c40 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,220 @@
 Change Log
 ==========
 
+## Version 3.12.0
+
+_2018-11-16_
+
+ *  **OkHttp now supports TLS 1.3.** This requires either Conscrypt or Java 11+.
+
+ *  **Proxy authenticators are now asked for preemptive authentication.** OkHttp will now request
+    authentication credentials before creating TLS tunnels through HTTP proxies (HTTP `CONNECT`).
+    Authenticators should identify preemptive authentications by the presence of a challenge whose
+    scheme is "OkHttp-Preemptive".
+
+ *  **OkHttp now offers full-operation timeouts.** This sets a limit on how long the entire call may
+    take and covers resolving DNS, connecting, writing the request body, server processing, and
+    reading the full response body. If a call requires redirects or retries all must complete within
+    one timeout period.
+
+    Use `OkHttpClient.Builder.callTimeout()` to specify the default duration and `Call.timeout()` to
+    specify the timeout of an individual call.
+
+ *  New: Return values and fields are now non-null unless otherwise annotated.
+ *  New: `LoggingEventListener` makes it easy to get basic visibility into a call's performance.
+    This class is in the `logging-interceptor` artifact.
+ *  New: `Headers.Builder.addUnsafeNonAscii()` allows non-ASCII values to be added without an
+    immediate exception.
+ *  New: Headers can be redacted in `HttpLoggingInterceptor`.
+ *  New: `Headers.Builder` now accepts dates.
+ *  New: OkHttp now accepts `java.time.Duration` for timeouts on Java 8+ and Android 26+.
+ *  New: `Challenge` includes all authentication parameters.
+ *  New: Upgrade to BouncyCastle 1.60, Conscrypt 1.4.0, and Okio 1.15.0. We don't yet require
+    Kotlin-friendly Okio 2.x but OkHttp works fine with that series.
+
+    ```kotlin
+    implementation("org.bouncycastle:bcprov-jdk15on:1.60")
+    implementation("org.conscrypt:conscrypt-openjdk-uber:1.4.0")
+    implementation("com.squareup.okio:okio:1.15.0")
+    ```
+
+ *  Fix: Handle dispatcher executor shutdowns gracefully. When there aren't any threads to carry a
+    call its callback now gets a `RejectedExecutionException`.
+ *  Fix: Don't permanently cache responses with `Cache-Control: immutable`. We misunderstood the
+    original `immutable` proposal!
+ *  Fix: Change `Authenticator`'s `Route` parameter to be nullable. This was marked as non-null but
+    could be called with null in some cases.
+ *  Fix: Don't create malformed URLs when `MockWebServer` is reached via an IPv6 address.
+ *  Fix: Don't crash if the system default authenticator is null.
+ *  Fix: Don't crash generating elliptic curve certificates on Android.
+ *  Fix: Don't crash doing platform detection on RoboVM.
+ *  Fix: Don't leak socket connections when web socket upgrades fail.
+
+
+## Version 3.11.0
+
+_2018-07-12_
+
+ *  **OkHttp's new okhttp-tls submodule tames HTTPS and TLS.**
+
+    `HeldCertificate` is a TLS certificate and its private key. Generate a certificate with its
+    builder then use it to sign another certificate or perform a TLS handshake. The
+    `certificatePem()` method encodes the certificate in the familiar PEM format
+    (`--- BEGIN CERTIFICATE ---`); the `privateKeyPkcs8Pem()` does likewise for the private key.
+
+    `HandshakeCertificates` holds the TLS certificates required for a TLS handshake. On the server
+    it keeps your `HeldCertificate` and its chain. On the client it keeps the root certificates
+    that are trusted to sign a server's certificate chain. `HandshakeCertificates` also works with
+    mutual TLS where these roles are reversed.
+
+    These classes make it possible to enable HTTPS in MockWebServer in [just a few lines of
+    code][https_server_sample].
+
+ *  **OkHttp now supports prior knowledge cleartext HTTP/2.** Enable this by setting
+    `Protocol.H2_PRIOR_KNOWLEDGE` as the lone protocol on an `OkHttpClient.Builder`. This mode
+    only supports `http:` URLs and is best suited in closed environments where HTTPS is
+    inappropriate.
+
+ *  New: `HttpUrl.get(String)` is an alternative to `HttpUrl.parse(String)` that throws an exception
+    when the URL is malformed instead of returning null. Use this to avoid checking for null in
+    situations where the input is known to be well-formed. We've also added `MediaType.get(String)`
+    which is an exception-throwing alternative to `MediaType.parse(String)`.
+ *  New: The `EventListener` API previewed in OkHttp 3.9 has graduated to a stable API. Use this
+    interface to track metrics and monitor HTTP requests' size and duration.
+ *  New: `okhttp-dnsoverhttps` is an experimental API for doing DNS queries over HTTPS. Using HTTPS
+    for DNS offers better security and potentially better performance. This feature is a preview:
+    the API is subject to change.
+ *  New: `okhttp-sse` is an early preview of Server-Sent Events (SSE). This feature is incomplete
+    and is only suitable for experimental use.
+ *  New: MockWebServer now supports client authentication (mutual TLS). Call `requestClientAuth()`
+    to permit an optional client certificate or `requireClientAuth()` to require one.
+ *  New: `RecordedRequest.getHandshake()` returns the HTTPS handshake of a request sent to
+    `MockWebServer`.
+ *  Fix: Honor the `MockResponse` header delay in MockWebServer.
+ *  Fix: Don't release HTTP/2 connections that have multiple canceled calls. We had a bug where
+    canceling calls would cause the shared HTTP/2 connection to be unnecessarily released. This
+    harmed connection reuse.
+ *  Fix: Ensure canceled and discarded HTTP/2 data is not permanently counted against the limited
+    flow control window. We had a few bugs where window size accounting was broken when streams
+    were canceled or reset.
+ *  Fix: Recover gracefully if the TLS session returns an unexpected version (`NONE`) or cipher
+    suite (`SSL_NULL_WITH_NULL_NULL`).
+ *  Fix: Don't change Conscrypt configuration globally. We migrated from a process-wide setting to
+    configuring only OkHttp's TLS sockets.
+ *  Fix: Prefer TLSv1.2 where it is available. On certain older platforms it is necessary to opt-in
+    to TLSv1.2.
+ *  New: `Request.tag()` permits multiple tags. Use a `Class<?>` as a key to identify tags. Note
+    that `tag()` now returns null if the request has no tag. Previously this would return the
+    request itself.
+ *  New: `Headers.Builder.addAll(Headers)`.
+ *  New: `ResponseBody.create(MediaType, ByteString)`.
+ *  New: Embed R8/ProGuard rules in the jar. These will be applied automatically by R8.
+ *  Fix: Release the connection if `Authenticator` throws an exception.
+ *  Fix: Change the declaration of `OkHttpClient.cache()` to return a `@Nullable Cache`. The return
+    value has always been nullable but it wasn't declared properly.
+ *  Fix: Reverse suppression of connect exceptions. When both a call and its retry fail, we now
+    throw the initial exception which is most likely to be actionable.
+ *  Fix: Retain interrupted state when throwing `InterruptedIOException`. A single interrupt should
+    now be sufficient to break out an in-flight OkHttp call.
+ *  Fix: Don't drop a call to `EventListener.callEnd()` when the response body is consumed inside an
+    interceptor.
+
+
+## Version 3.10.0
+
+_2018-02-24_
+
+ *  **The pingInterval() feature now aggressively checks connectivity for web
+    sockets and HTTP/2 connections.**
+
+    Previously if you configured a ping interval that would cause OkHttp to send
+    pings, but it did not track whether the reply pongs were received. With this
+    update OkHttp requires that every ping receive a response: if it does not
+    the connection will be closed and the listener's `onFailure()` method will
+    be called.
+
+    Web sockets have always been had pings, but pings on HTTP/2 connections is
+    new in this release. Pings are used for connections that are busy carrying
+    calls and for idle connections in the connection pool. (Pings do not impact
+    when pooled connections are evicted).
+
+    If you have a configured ping interval, you should confirm that it is long
+    enough for a roundtrip from client to server. If your ping interval is too
+    short, slow connections may be misinterpreted as failed connections. A ping
+    interval of 30 seconds is reasonable for most use cases.
+
+ *  **OkHttp now supports [Conscrypt][conscrypt].** Conscrypt is a Java Security
+    Provider that integrates BoringSSL into the Java platform. Conscrypt
+    supports more cipher suites than the JVM’s default provider and may also
+    execute more efficiently.
+
+    To use it, first register a [Conscrypt dependency][conscrypt_dependency] in
+    your build system.
+
+    OkHttp will use Conscrypt if you set the `okhttp.platform` system property
+    to `conscrypt`.
+
+    Alternatively, OkHttp will also use Conscrypt if you install it as your
+    preferred security provider. To do so, add the following code to execute
+    before you create your `OkHttpClient`.
+
+    ```
+    Security.insertProviderAt(
+        new org.conscrypt.OpenSSLProvider(), 1);
+    ```
+
+    Conscrypt is the bundled security provider on Android so it is not necessary
+    to configure it on that platform.
+
+ *  New: `HttpUrl.addQueryParameter()` percent-escapes more characters.
+    Previously several ASCII punctuation characters were not percent-escaped
+    when used with this method. This does not impact already-encoded query
+    parameters in APIs like `HttpUrl.parse()` and
+    `HttpUrl.Builder.addEncodedQueryParameter()`.
+ *  New: CBC-mode ECDSA cipher suites have been removed from OkHttp's default
+    configuration: `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA` and
+    `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA`. This tracks a [Chromium
+    change][remove_cbc_ecdsa] to remove these cipher suites because they are
+    fragile and rarely-used.
+ *  New: Don't fall back to common name (CN) verification for hostnames. This
+    behavior was deprecated with RFC 2818 in May 2000 and was recently dropped
+    from major web browsers.
+ *  New: Honor the `Retry-After` response header. HTTP 503 (Unavailable)
+    responses are retried automatically if this header is present and its delay
+    is 0 seconds. HTTP 408 (Client Timeout) responses are retried automatically
+    if the header is absent or its delay is 0 seconds.
+ *  New: Allow request bodies for all HTTP methods except GET and HEAD.
+ *  New: Automatic module name of `okhttp3` for use with the Java Platform
+    Module System.
+ *  New: Log gzipped bodies when `HttpLoggingInterceptor` is used as a network
+    interceptor.
+ *  New: `Protocol.QUIC` constant. This protocol is not supported but this
+    constant is included for completeness.
+ *  New: Upgrade to Okio 1.14.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.14.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.14.0
+     ```
+
+ *  Fix: Handle `HTTP/1.1 100 Continue` status lines, even on requests that did
+    not send the `Expect: continue` request header.
+ *  Fix: Do not count web sockets toward the dispatcher's per-host connection
+    limit.
+ *  Fix: Avoid using invalid HTTPS sessions. This prevents OkHttp from crashing
+    with the error, `Unexpected TLS version: NONE`.
+ *  Fix: Don't corrupt the response cache when a 304 (Not Modified) response
+    overrides the stored "Content-Encoding" header.
+ *  Fix: Gracefully shut down the HTTP/2 connection before it exhausts the
+    namespace of stream IDs (~536 million streams).
+ *  Fix: Never pass a null `Route` to `Authenticator`. There was a bug where
+    routes were omitted for eagerly-closed connections.
+
 ## Version 3.9.1
 
 _2017-11-18_
@@ -899,7 +1113,7 @@ _2014-12-30_
     for OkHttp 2.0 and 2.1 will continue to work with this update.
 
  *  **`COMPATIBLE_TLS` no longer supports SSLv3.** In response to the
-    [POODLE](http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html)
+    [POODLE](https://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html)
     vulnerability, OkHttp no longer offers SSLv3 when negotiation an
     HTTPS connection. If you continue to need to connect to webservers
     running SSLv3, you must manually configure your own `ConnectionSpec`.
@@ -1379,6 +1593,10 @@ Initial release.
  [nginx_959]: https://trac.nginx.org/nginx/ticket/959
  [okhttp_idling_resource]: https://github.com/JakeWharton/okhttp-idling-resource
  [bom]: https://en.wikipedia.org/wiki/Byte_order_mark
- [junit_5_rules]: http://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4-rulesupport
+ [junit_5_rules]: https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4-rulesupport
  [public_suffix]: https://publicsuffix.org/
  [maven_provided]: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html
+ [remove_cbc_ecdsa]: https://developers.google.com/web/updates/2016/12/chrome-56-deprecations#remove_cbc-mode_ecdsa_ciphers_in_tls
+ [conscrypt]: https://github.com/google/conscrypt/
+ [conscrypt_dependency]: https://github.com/google/conscrypt/#download
+ [https_server_sample]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
\ No newline at end of file
diff --git a/README.md b/README.md
index 7ae6ce68e8..fcecace952 100644
--- a/README.md
+++ b/README.md
@@ -6,17 +6,10 @@ An HTTP & HTTP/2 client for Android and Java applications. For more information
 Download
 --------
 
-Download [the latest JAR][3] or grab via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>okhttp</artifactId>
-  <version>3.9.1</version>
-</dependency>
-```
-or Gradle:
-```groovy
-implementation 'com.squareup.okhttp3:okhttp:3.9.1'
+Download [the latest JAR][3] or configure this dependency:
+
+```kotlin
+implementation("com.squareup.okhttp3:okhttp:3.12.0")
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -31,32 +24,19 @@ MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2 so
 
 ### Download
 
-Download [the latest JAR][4] or grab via Maven:
+Download [the latest JAR][4] or configure this dependency:
 ```xml
-<dependency>
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>mockwebserver</artifactId>
-  <version>3.9.1</version>
-  <scope>test</scope>
-</dependency>
-```
-or Gradle:
-```groovy
-testImplementation 'com.squareup.okhttp3:mockwebserver:3.9.1'
+testImplementation("com.squareup.okhttp3:mockwebserver:3.12.0")
 ```
 
-ProGuard
---------
+R8 / ProGuard
+-------------
 
-If you are using ProGuard you might need to add the following options:
+If you are using R8 or ProGuard add the options from
+[this file](https://github.com/square/okhttp/blob/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro).
+
+You might also need rules for Okio which is a dependency of this library.
 
-```
--dontwarn okhttp3.**
--dontwarn okio.**
--dontwarn javax.annotation.**
-# A resource is loaded with a relative path so the package of this class must be preserved.
--keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase
-```
 
 License
 -------
@@ -74,7 +54,7 @@ License
     limitations under the License.
 
 
- [1]: http://square.github.io/okhttp
+ [1]: https://square.github.io/okhttp
  [2]: https://github.com/square/okhttp/wiki
  [3]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST
  [4]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=mockwebserver&v=LATEST
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index 36a9aee9d5..2b03eb0062 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.10.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
@@ -36,12 +36,13 @@
     </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
+      <artifactId>okhttp-tls</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>org.bouncycastle</groupId>
-      <artifactId>bcprov-jdk15on</artifactId>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
     </dependency>
     <dependency>
       <groupId>org.apache.httpcomponents</groupId>
@@ -74,6 +75,7 @@
       <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>exec-maven-plugin</artifactId>
+        <version>1.5.0</version>
         <executions>
           <execution>
             <goals>
@@ -129,6 +131,7 @@
             <!-- Fails on caliper's ASM on OpenJDK 8. -->
             <groupId>org.codehaus.mojo</groupId>
             <artifactId>animal-sniffer-maven-plugin</artifactId>
+            <version>1.15</version>
             <executions>
               <execution>
                 <phase>none</phase>
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
index 6460aaa059..e3dbd3084c 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
@@ -20,7 +20,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
 import okhttp3.HttpUrl;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.HttpClient;
@@ -31,6 +31,8 @@
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.impl.conn.PoolingClientConnectionManager;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
+
 /** Benchmark Apache HTTP client. */
 class ApacheHttpClient extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
@@ -41,9 +43,9 @@
     super.prepare(benchmark);
     ClientConnectionManager connectionManager = new PoolingClientConnectionManager();
     if (benchmark.tls) {
-      SslClient sslClient = SslClient.localhost();
+      HandshakeCertificates handshakeCertificates = localhost();
       connectionManager.getSchemeRegistry().register(
-          new Scheme("https", 443, new SSLSocketFactory(sslClient.sslContext)));
+          new Scheme("https", 443, new SSLSocketFactory(handshakeCertificates.sslContext())));
     }
     client = new DefaultHttpClient(connectionManager);
   }
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
index 5ab326cbfc..081fcfccb9 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
@@ -28,14 +28,16 @@
 import java.util.logging.Logger;
 import okhttp3.HttpUrl;
 import okhttp3.Protocol;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.GzipSink;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
+
 /**
  * This benchmark is fake, but may be useful for certain relative comparisons. It uses a local
  * connection to a MockWebServer to measure how many identical requests per second can be carried
@@ -160,8 +162,8 @@ private MockWebServer startServer() throws IOException {
     MockWebServer server = new MockWebServer();
 
     if (tls) {
-      SslClient sslClient = SslClient.localhost();
-      server.useHttps(sslClient.socketFactory, false);
+      HandshakeCertificates handshakeCertificates = localhost();
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
       server.setProtocols(protocols);
     }
 
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
index 5186f41833..35731fa3b1 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
@@ -44,7 +44,9 @@
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLEngine;
 import okhttp3.HttpUrl;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+
+import static okhttp3.tls.internal.TlsUtil.localhost;
 
 /** Netty isn't an HTTP client, but it's almost one. */
 class NettyHttpClient implements HttpClient {
@@ -64,12 +66,12 @@
     this.targetBacklog = benchmark.targetBacklog;
 
     ChannelInitializer<SocketChannel> channelInitializer = new ChannelInitializer<SocketChannel>() {
-      @Override public void initChannel(SocketChannel channel) throws Exception {
+      @Override public void initChannel(SocketChannel channel) {
         ChannelPipeline pipeline = channel.pipeline();
 
         if (benchmark.tls) {
-          SslClient sslClient = SslClient.localhost();
-          SSLEngine engine = sslClient.sslContext.createSSLEngine();
+          HandshakeCertificates handshakeCertificates = localhost();
+          SSLEngine engine = handshakeCertificates.sslContext().createSSLEngine();
           engine.setUseClientMode(true);
           pipeline.addLast("ssl", new SslHandler(engine));
         }
@@ -152,7 +154,7 @@ private void sendRequest(HttpUrl url) {
     }
 
     @Override protected void channelRead0(
-        ChannelHandlerContext context, HttpObject message) throws Exception {
+        ChannelHandlerContext context, HttpObject message) {
       if (message instanceof HttpResponse) {
         receive((HttpResponse) message);
       }
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
index e97509a67b..86b44523a2 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
@@ -25,7 +25,9 @@
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+
+import static okhttp3.tls.internal.TlsUtil.localhost;
 
 class OkHttp extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
@@ -39,15 +41,15 @@
         .build();
 
     if (benchmark.tls) {
-      SslClient sslClient = SslClient.localhost();
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
+      HandshakeCertificates handshakeCertificates = localhost();
+      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
       HostnameVerifier hostnameVerifier = new HostnameVerifier() {
         @Override public boolean verify(String s, SSLSession session) {
           return true;
         }
       };
       client = new OkHttpClient.Builder()
-          .sslSocketFactory(socketFactory, sslClient.trustManager)
+          .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
           .hostnameVerifier(hostnameVerifier)
           .build();
     }
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
index c6bad2ba5f..d6d0bc5cb4 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
@@ -31,7 +31,9 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+
+import static okhttp3.tls.internal.TlsUtil.localhost;
 
 class OkHttpAsync implements HttpClient {
   private static final boolean VERBOSE = false;
@@ -54,15 +56,15 @@
         .build();
 
     if (benchmark.tls) {
-      SslClient sslClient = SslClient.localhost();
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
+      HandshakeCertificates handshakeCertificates = localhost();
+      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
       HostnameVerifier hostnameVerifier = new HostnameVerifier() {
         @Override public boolean verify(String s, SSLSession session) {
           return true;
         }
       };
       client = client.newBuilder()
-          .sslSocketFactory(socketFactory, sslClient.trustManager)
+          .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
           .hostnameVerifier(hostnameVerifier)
           .build();
     }
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
index 7aeb7582ed..96eb7422cd 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
@@ -25,7 +25,9 @@
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.HttpUrl;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+
+import static okhttp3.tls.internal.TlsUtil.localhost;
 
 class UrlConnection extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
@@ -33,8 +35,8 @@
   @Override public void prepare(Benchmark benchmark) {
     super.prepare(benchmark);
     if (benchmark.tls) {
-      SslClient sslClient = SslClient.localhost();
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
+      HandshakeCertificates handshakeCertificates = localhost();
+      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
       HostnameVerifier hostnameVerifier = new HostnameVerifier() {
         @Override public boolean verify(String s, SSLSession session) {
           return true;
diff --git a/bom/pom.xml b/bom/pom.xml
new file mode 100644
index 0000000000..f4a1e2818b
--- /dev/null
+++ b/bom/pom.xml
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.13.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-bom</artifactId>
+  <packaging>pom</packaging>
+  <name>OkHttp (Bill of Materials)</name>
+
+  <dependencyManagement>
+    <dependencies>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-tests</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-android-support</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-apache</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-sse</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-testing-support</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-tls</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-urlconnection</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-logging-interceptor</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okhttp-dnsoverhttps</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>okcurl</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>mockwebserver</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+</project>
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index a94cdf7bbc..92ced6b41d 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.10.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
@@ -25,8 +25,10 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.bouncycastle</groupId>
-      <artifactId>bcprov-jdk15on</artifactId>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
     </dependency>
     <dependency>
       <groupId>junit</groupId>
@@ -39,6 +41,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
@@ -49,6 +52,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-assembly-plugin</artifactId>
+        <version>3.0.0</version>
         <configuration>
           <descriptorRefs>
             <descriptorRef>jar-with-dependencies</descriptorRef>
@@ -66,6 +70,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 677adbae7d..d2a532dd6f 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -19,7 +19,6 @@
 
 import java.io.Closeable;
 import java.io.IOException;
-import java.io.InterruptedIOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.ProtocolException;
@@ -79,6 +78,7 @@
 import org.junit.rules.ExternalResource;
 
 import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.mockwebserver.SocketPolicy.CONTINUE_ALWAYS;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
@@ -90,6 +90,8 @@
 import static okhttp3.mockwebserver.SocketPolicy.RESET_STREAM_AT_START;
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE;
+import static okhttp3.mockwebserver.SocketPolicy.STALL_SOCKET_AT_START;
 import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
 
 /**
@@ -101,6 +103,10 @@
     Internal.initializeInstanceForTests();
   }
 
+  private static final int CLIENT_AUTH_NONE = 0;
+  private static final int CLIENT_AUTH_REQUESTED = 1;
+  private static final int CLIENT_AUTH_REQUIRED = 2;
+
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
     @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
         throws CertificateException {
@@ -131,6 +137,7 @@
   private SSLSocketFactory sslSocketFactory;
   private ExecutorService executor;
   private boolean tunnelProxy;
+  private int clientAuth = CLIENT_AUTH_NONE;
   private Dispatcher dispatcher = new QueueDispatcher();
 
   private int port = -1;
@@ -212,7 +219,12 @@ public void setProtocolNegotiationEnabled(boolean protocolNegotiationEnabled) {
    */
   public void setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
-    if (!protocols.contains(Protocol.HTTP_1_1)) {
+    if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
+      // when using h2_prior_knowledge, no other protocol should be supported.
+      throw new IllegalArgumentException(
+          "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
+    } else if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
+        && !protocols.contains(Protocol.HTTP_1_1)) {
       throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
     }
     if (protocols.contains(null)) {
@@ -221,6 +233,10 @@ public void setProtocols(List<Protocol> protocols) {
     this.protocols = protocols;
   }
 
+  public List<Protocol> protocols() {
+    return protocols;
+  }
+
   /**
    * Serve requests with HTTPS rather than otherwise.
    *
@@ -231,6 +247,36 @@ public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
     this.tunnelProxy = tunnelProxy;
   }
 
+  /**
+   * Configure the server to not perform SSL authentication of the client. This leaves
+   * authentication to another layer such as in an HTTP cookie or header. This is the default and
+   * most common configuration.
+   */
+  public void noClientAuth() {
+    this.clientAuth = CLIENT_AUTH_NONE;
+  }
+
+  /**
+   * Configure the server to {@linkplain SSLSocket#setWantClientAuth want client auth}. If the
+   * client presents a certificate that is {@linkplain TrustManager trusted} the handshake will
+   * proceed normally. The connection will also proceed normally if the client presents no
+   * certificate at all! But if the client presents an untrusted certificate the handshake will fail
+   * and no connection will be established.
+   */
+  public void requestClientAuth() {
+    this.clientAuth = CLIENT_AUTH_REQUESTED;
+  }
+
+  /**
+   * Configure the server to {@linkplain SSLSocket#setNeedClientAuth need client auth}. If the
+   * client presents a certificate that is {@linkplain TrustManager trusted} the handshake will
+   * proceed normally. If the client presents an untrusted certificate or no certificate at all the
+   * handshake will fail and no connection will be established.
+   */
+  public void requireClientAuth() {
+    this.clientAuth = CLIENT_AUTH_REQUIRED;
+  }
+
   /**
    * Awaits the next HTTP request, removes it, and returns it. Callers should use this to verify the
    * request was sent as intended. This method will block until the request is available, possibly
@@ -405,13 +451,13 @@ private void serveConnection(final Socket raw) {
       }
 
       public void processConnection() throws Exception {
+        SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
         Protocol protocol = Protocol.HTTP_1_1;
         Socket socket;
         if (sslSocketFactory != null) {
           if (tunnelProxy) {
             createTunnel();
           }
-          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
           if (socketPolicy == FAIL_HANDSHAKE) {
             dispatchBookkeepingRequest(sequenceNumber, raw);
             processHandshakeFailure(raw);
@@ -421,6 +467,11 @@ public void processConnection() throws Exception {
               raw.getPort(), true);
           SSLSocket sslSocket = (SSLSocket) socket;
           sslSocket.setUseClientMode(false);
+          if (clientAuth == CLIENT_AUTH_REQUIRED) {
+            sslSocket.setNeedClientAuth(true);
+          } else if (clientAuth == CLIENT_AUTH_REQUESTED) {
+            sslSocket.setWantClientAuth(true);
+          }
           openClientSockets.add(socket);
 
           if (protocolNegotiationEnabled) {
@@ -434,11 +485,18 @@ public void processConnection() throws Exception {
             protocol = protocolString != null ? Protocol.get(protocolString) : Protocol.HTTP_1_1;
           }
           openClientSockets.remove(raw);
+        } else if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
+          socket = raw;
+          protocol = Protocol.H2_PRIOR_KNOWLEDGE;
         } else {
           socket = raw;
         }
 
-        if (protocol == Protocol.HTTP_2) {
+        if (socketPolicy == STALL_SOCKET_AT_START) {
+          return; // Ignore the socket until the server is shut down!
+        }
+
+        if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
           Http2SocketHandler http2SocketHandler = new Http2SocketHandler(socket, protocol);
           Http2Connection connection = new Http2Connection.Builder(false)
               .socket(socket)
@@ -532,6 +590,8 @@ private boolean processOneRequest(Socket socket, BufferedSource source, Buffered
           socket.shutdownInput();
         } else if (response.getSocketPolicy() == SHUTDOWN_OUTPUT_AT_END) {
           socket.shutdownOutput();
+        } else if (response.getSocketPolicy() == SHUTDOWN_SERVER_AFTER_RESPONSE) {
+          shutdown();
         }
 
         sequenceNumber++;
@@ -597,7 +657,8 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
       }
     }
 
-    if (expectContinue && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {
+    final SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
+    if (expectContinue && socketPolicy == EXPECT_CONTINUE || socketPolicy == CONTINUE_ALWAYS) {
       sink.writeUtf8("HTTP/1.1 100 Continue\r\n");
       sink.writeUtf8("Content-Length: 0\r\n");
       sink.writeUtf8("\r\n");
@@ -663,17 +724,18 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
       }
     };
     RealWebSocket webSocket = new RealWebSocket(fancyRequest,
-        response.getWebSocketListener(), new SecureRandom());
+        response.getWebSocketListener(), new SecureRandom(), 0);
     response.getWebSocketListener().onOpen(webSocket, fancyResponse);
     String name = "MockWebServer WebSocket " + request.getPath();
-    webSocket.initReaderAndWriter(name, 0, streams);
+    webSocket.initReaderAndWriter(name, streams);
     try {
       webSocket.loopReader();
 
       // Even if messages are no longer being read we need to wait for the connection close signal.
       try {
         connectionClose.await();
-      } catch (InterruptedException ignored) {
+      } catch (InterruptedException e) {
+        throw new AssertionError(e);
       }
 
     } catch (IOException e) {
@@ -685,7 +747,7 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
 
   private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse response)
       throws IOException {
-    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
+    sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS));
     sink.writeUtf8(response.getStatus());
     sink.writeUtf8("\r\n");
 
@@ -762,7 +824,7 @@ private void throttledTransfer(MockResponse policy, Socket socket, BufferedSourc
         try {
           Thread.sleep(periodDelayMs);
         } catch (InterruptedException e) {
-          throw new AssertionError();
+          throw new AssertionError(e);
         }
       }
     }
@@ -844,7 +906,7 @@ private Http2SocketHandler(Socket socket, Protocol protocol) {
           stream.close(ErrorCode.fromHttp2(peekedResponse.getHttp2ErrorCode()));
           return;
         } catch (InterruptedException e) {
-          throw new InterruptedIOException();
+          throw new AssertionError(e);
         }
       }
 
@@ -875,24 +937,24 @@ private Http2SocketHandler(Socket socket, Protocol protocol) {
     }
 
     private RecordedRequest readRequest(Http2Stream stream) throws IOException {
-      List<Header> streamHeaders = stream.getRequestHeaders();
+      Headers streamHeaders = stream.takeHeaders();
       Headers.Builder httpHeaders = new Headers.Builder();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
       boolean readBody = true;
       for (int i = 0, size = streamHeaders.size(); i < size; i++) {
-        ByteString name = streamHeaders.get(i).name;
-        String value = streamHeaders.get(i).value.utf8();
-        if (name.equals(Header.TARGET_METHOD)) {
+        String name = streamHeaders.name(i);
+        String value = streamHeaders.value(i);
+        if (name.equals(Header.TARGET_METHOD_UTF8)) {
           method = value;
-        } else if (name.equals(Header.TARGET_PATH)) {
+        } else if (name.equals(Header.TARGET_PATH_UTF8)) {
           path = value;
-        } else if (protocol == Protocol.HTTP_2) {
-          httpHeaders.add(name.utf8(), value);
+        } else if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
+          httpHeaders.add(name, value);
         } else {
           throw new IllegalStateException();
         }
-        if (name.utf8().equals("expect") && value.equalsIgnoreCase("100-continue")) {
+        if (name.equals("expect") && value.equalsIgnoreCase("100-continue")) {
           // Don't read the body unless we've invited the client to send it.
           readBody = false;
         }
@@ -901,7 +963,7 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
 
       MockResponse peek = dispatcher.peek();
       if (!readBody && peek.getSocketPolicy() == EXPECT_CONTINUE) {
-        stream.sendResponseHeaders(Collections.singletonList(
+        stream.writeHeaders(Collections.singletonList(
             new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue"))), true);
         stream.getConnection().flush();
         readBody = true;
@@ -947,7 +1009,7 @@ private void writeResponse(Http2Stream stream, MockResponse response) throws IOE
 
       Buffer body = response.getBody();
       boolean closeStreamAfterHeaders = body != null || !response.getPushPromises().isEmpty();
-      stream.sendResponseHeaders(http2Headers, closeStreamAfterHeaders);
+      stream.writeHeaders(http2Headers, closeStreamAfterHeaders);
       pushPromises(stream, response.getPushPromises());
       if (body != null) {
         BufferedSink sink = Okio.buffer(stream.getSink());
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
index 672d42bc76..52beb79323 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
@@ -16,9 +16,13 @@
 
 package okhttp3.mockwebserver;
 
+import java.io.IOException;
+import java.net.Inet6Address;
+import java.net.InetAddress;
 import java.net.Socket;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
+import okhttp3.Handshake;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.TlsVersion;
@@ -30,11 +34,11 @@
   private final String method;
   private final String path;
   private final Headers headers;
+  private final Handshake handshake;
   private final List<Integer> chunkSizes;
   private final long bodySize;
   private final Buffer body;
   private final int sequenceNumber;
-  private final TlsVersion tlsVersion;
   private final HttpUrl requestUrl;
 
   public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkSizes,
@@ -45,20 +49,38 @@ public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkS
     this.bodySize = bodySize;
     this.body = body;
     this.sequenceNumber = sequenceNumber;
-    this.tlsVersion = socket instanceof SSLSocket
-        ? TlsVersion.forJavaName(((SSLSocket) socket).getSession().getProtocol())
-        : null;
+    if (socket instanceof SSLSocket) {
+      try {
+        this.handshake = Handshake.get(((SSLSocket) socket).getSession());
+      } catch (IOException e) {
+        throw new IllegalArgumentException(e);
+      }
+    } else {
+      this.handshake = null;
+    }
 
     if (requestLine != null) {
       int methodEnd = requestLine.indexOf(' ');
       int pathEnd = requestLine.indexOf(' ', methodEnd + 1);
       this.method = requestLine.substring(0, methodEnd);
-      this.path = requestLine.substring(methodEnd + 1, pathEnd);
+      String path = requestLine.substring(methodEnd + 1, pathEnd);
+      if (!path.startsWith("/")) {
+        path = "/";
+      }
+      this.path = path;
 
       String scheme = socket instanceof SSLSocket ? "https" : "http";
-      String hostname = socket.getInetAddress().getHostName();
-      int port = socket.getLocalPort();
-      this.requestUrl = HttpUrl.parse(String.format("%s://%s:%s%s", scheme, hostname, port, path));
+      InetAddress inetAddress = socket.getLocalAddress();
+
+      String hostname = inetAddress.getHostName();
+      if (inetAddress instanceof Inet6Address) {
+        hostname = "[" + hostname + "]";
+      }
+
+      int localPort = socket.getLocalPort();
+      // Allow null in failure case to allow for testing bad requests
+      this.requestUrl =
+          HttpUrl.parse(String.format("%s://%s:%s%s", scheme, hostname, localPort, path));
     } else {
       this.requestUrl = null;
       this.method = null;
@@ -128,7 +150,15 @@ public int getSequenceNumber() {
 
   /** Returns the connection's TLS version or null if the connection doesn't use SSL. */
   public TlsVersion getTlsVersion() {
-    return tlsVersion;
+    return handshake != null ? handshake.tlsVersion() : null;
+  }
+
+  /**
+   * Returns the TLS handshake of the connection that carried this request, or null if the request
+   * was received without TLS.
+   */
+  public Handshake getHandshake() {
+    return handshake;
   }
 
   @Override public String toString() {
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
index 521c5a0e58..beeb2c9a6d 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
@@ -31,6 +31,11 @@
  */
 public enum SocketPolicy {
 
+  /**
+   * Shutdown {@link MockWebServer} after writing response.
+   */
+  SHUTDOWN_SERVER_AFTER_RESPONSE,
+
   /**
    * Keep the socket open after the response. This is the default HTTP/1.1 behavior.
    */
@@ -88,8 +93,14 @@
   SHUTDOWN_OUTPUT_AT_END,
 
   /**
-   * Don't respond to the request but keep the socket open. For testing read response header timeout
-   * issue.
+   * After accepting the connection and doing TLS (if configured) don't do HTTP/1.1 or HTTP/2
+   * framing. Ignore the socket completely until the server is shut down.
+   */
+  STALL_SOCKET_AT_START,
+
+  /**
+   * Read the request but don't respond to it. Just keep the socket open. For testing read response
+   * header timeout issue.
    */
   NO_RESPONSE,
 
@@ -104,5 +115,11 @@
    * Typically this response is sent when a client makes a request with the header {@code
    * Expect: 100-continue}.
    */
-  EXPECT_CONTINUE
+  EXPECT_CONTINUE,
+
+  /**
+   * Transmit a {@code HTTP/1.1 100 Continue} response before reading the HTTP request body even
+   * if the client does not send the header {@code Expect: 100-continue} in its request.
+   */
+  CONTINUE_ALWAYS
 }
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/tls/HeldCertificate.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/tls/HeldCertificate.java
deleted file mode 100644
index 583c5335ba..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/tls/HeldCertificate.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver.internal.tls;
-
-import java.math.BigInteger;
-import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.KeyPairGenerator;
-import java.security.SecureRandom;
-import java.security.Security;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-import java.util.UUID;
-import javax.security.auth.x500.X500Principal;
-import org.bouncycastle.asn1.ASN1Encodable;
-import org.bouncycastle.asn1.DERSequence;
-import org.bouncycastle.asn1.x509.BasicConstraints;
-import org.bouncycastle.asn1.x509.GeneralName;
-import org.bouncycastle.asn1.x509.X509Extensions;
-import org.bouncycastle.jce.provider.BouncyCastleProvider;
-import org.bouncycastle.x509.X509V3CertificateGenerator;
-
-import static okhttp3.internal.Util.verifyAsIpAddress;
-
-/**
- * A certificate and its private key. This can be used on the server side by HTTPS servers, or on
- * the client side to verify those HTTPS servers. A held certificate can also be used to sign other
- * held certificates, as done in practice by certificate authorities.
- */
-public final class HeldCertificate {
-  public final X509Certificate certificate;
-  public final KeyPair keyPair;
-
-  public HeldCertificate(X509Certificate certificate, KeyPair keyPair) {
-    this.certificate = certificate;
-    this.keyPair = keyPair;
-  }
-
-  public static final class Builder {
-    static {
-      Security.addProvider(new BouncyCastleProvider());
-    }
-
-    private final long duration = 1000L * 60 * 60 * 24; // One day.
-    private String hostname;
-    private List<String> altNames = new ArrayList<>();
-    private String serialNumber = "1";
-    private KeyPair keyPair;
-    private HeldCertificate issuedBy;
-    private int maxIntermediateCas;
-
-    public Builder serialNumber(String serialNumber) {
-      this.serialNumber = serialNumber;
-      return this;
-    }
-
-    /**
-     * Set this certificate's name. Typically this is the URL hostname for TLS certificates. This is
-     * the CN (common name) in the certificate. Will be a random string if no value is provided.
-     */
-    public Builder commonName(String hostname) {
-      this.hostname = hostname;
-      return this;
-    }
-
-    public Builder keyPair(KeyPair keyPair) {
-      this.keyPair = keyPair;
-      return this;
-    }
-
-    /**
-     * Set the certificate that signs this certificate. If unset, a self-signed certificate will be
-     * generated.
-     */
-    public Builder issuedBy(HeldCertificate signedBy) {
-      this.issuedBy = signedBy;
-      return this;
-    }
-
-    /**
-     * Set this certificate to be a certificate authority, with up to {@code maxIntermediateCas}
-     * intermediate certificate authorities beneath it.
-     */
-    public Builder ca(int maxIntermediateCas) {
-      this.maxIntermediateCas = maxIntermediateCas;
-      return this;
-    }
-
-    /**
-     * Adds a subject alternative name to the certificate. This is usually a hostname or IP address.
-     * If no subject alternative names are added that extension will not be used.
-     */
-    public Builder subjectAlternativeName(String altName) {
-      altNames.add(altName);
-      return this;
-    }
-
-    public HeldCertificate build() throws GeneralSecurityException {
-      // Subject, public & private keys for this certificate.
-      KeyPair heldKeyPair = keyPair != null
-          ? keyPair
-          : generateKeyPair();
-      X500Principal subject = hostname != null
-          ? new X500Principal("CN=" + hostname)
-          : new X500Principal("CN=" + UUID.randomUUID());
-
-      // Subject, public & private keys for this certificate's signer. It may be self signed!
-      KeyPair signedByKeyPair;
-      X500Principal signedByPrincipal;
-      if (issuedBy != null) {
-        signedByKeyPair = issuedBy.keyPair;
-        signedByPrincipal = issuedBy.certificate.getSubjectX500Principal();
-      } else {
-        signedByKeyPair = heldKeyPair;
-        signedByPrincipal = subject;
-      }
-
-      // Generate & sign the certificate.
-      long now = System.currentTimeMillis();
-      X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
-      generator.setSerialNumber(new BigInteger(serialNumber));
-      generator.setIssuerDN(signedByPrincipal);
-      generator.setNotBefore(new Date(now));
-      generator.setNotAfter(new Date(now + duration));
-      generator.setSubjectDN(subject);
-      generator.setPublicKey(heldKeyPair.getPublic());
-      generator.setSignatureAlgorithm("SHA256WithRSAEncryption");
-
-      if (maxIntermediateCas > 0) {
-        generator.addExtension(X509Extensions.BasicConstraints, true,
-            new BasicConstraints(maxIntermediateCas));
-      }
-
-      if (!altNames.isEmpty()) {
-        ASN1Encodable[] encodableAltNames = new ASN1Encodable[altNames.size()];
-        for (int i = 0, size = altNames.size(); i < size; i++) {
-          String altName = altNames.get(i);
-          int tag = verifyAsIpAddress(altName)
-              ? GeneralName.iPAddress
-              : GeneralName.dNSName;
-          encodableAltNames[i] = new GeneralName(tag, altName);
-        }
-        generator.addExtension(X509Extensions.SubjectAlternativeName, true,
-            new DERSequence(encodableAltNames));
-      }
-
-      X509Certificate certificate = generator.generateX509Certificate(
-          signedByKeyPair.getPrivate(), "BC");
-      return new HeldCertificate(certificate, heldKeyPair);
-    }
-
-    public KeyPair generateKeyPair() throws GeneralSecurityException {
-      KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC");
-      keyPairGenerator.initialize(1024, new SecureRandom());
-      return keyPairGenerator.generateKeyPair();
-    }
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/tls/SslClient.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/tls/SslClient.java
deleted file mode 100644
index 076cc9011c..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/tls/SslClient.java
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver.internal.tls;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.KeyStore;
-import java.security.SecureRandom;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.platform.Platform;
-
-/**
- * Combines an SSL socket factory and trust manager, a pairing enough for OkHttp or MockWebServer to
- * create a secure connection.
- */
-public final class SslClient {
-  private static SslClient localhost; // Lazily initialized.
-
-  public final SSLContext sslContext;
-  public final SSLSocketFactory socketFactory;
-  public final X509TrustManager trustManager;
-
-  private SslClient(SSLContext sslContext, X509TrustManager trustManager) {
-    this.sslContext = sslContext;
-    this.socketFactory = sslContext.getSocketFactory();
-    this.trustManager = trustManager;
-  }
-
-  /** Returns an SSL client for this host's localhost address. */
-  public static synchronized SslClient localhost() {
-    if (localhost != null) return localhost;
-
-    try {
-      // Generate a self-signed cert for the server to serve and the client to trust.
-      HeldCertificate heldCertificate = new HeldCertificate.Builder()
-          .serialNumber("1")
-          .commonName(InetAddress.getByName("localhost").getCanonicalHostName())
-          .build();
-
-      localhost = new Builder()
-          .certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
-          .addTrustedCertificate(heldCertificate.certificate)
-          .build();
-
-      return localhost;
-    } catch (GeneralSecurityException | UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  public static class Builder {
-    private final List<X509Certificate> chainCertificates = new ArrayList<>();
-    private final List<X509Certificate> certificates = new ArrayList<>();
-    private KeyPair keyPair;
-    private String keyStoreType = KeyStore.getDefaultType();
-    private SSLContext sslContext;
-
-    /**
-     * Configure the certificate chain to use when serving HTTPS responses. The first certificate is
-     * the server's certificate, further certificates are included in the handshake so the client
-     * can build a trusted path to a CA certificate.
-     */
-    public Builder certificateChain(HeldCertificate localCert, HeldCertificate... chain) {
-      X509Certificate[] certificates = new X509Certificate[chain.length];
-      for (int i = 0; i < chain.length; i++) {
-        certificates[i] = chain[i].certificate;
-      }
-      return certificateChain(localCert.keyPair, localCert.certificate, certificates);
-    }
-
-    public Builder certificateChain(KeyPair keyPair, X509Certificate keyCert,
-        X509Certificate... certificates) {
-      this.keyPair = keyPair;
-      this.chainCertificates.add(keyCert);
-      this.chainCertificates.addAll(Arrays.asList(certificates));
-      this.certificates.addAll(Arrays.asList(certificates));
-      return this;
-    }
-
-    /**
-     * Add a certificate authority that this client trusts. Servers that provide certificate chains
-     * signed by these roots (or their intermediates) will be accepted.
-     */
-    public Builder addTrustedCertificate(X509Certificate certificate) {
-      this.certificates.add(certificate);
-      return this;
-    }
-
-    public Builder keyStoreType(String keyStoreType) {
-      this.keyStoreType = keyStoreType;
-      return this;
-    }
-
-    public Builder sslContext(SSLContext sslContext) {
-      this.sslContext = sslContext;
-      return this;
-    }
-
-    public SslClient build() {
-      try {
-        // Put the certificate in a key store.
-        char[] password = "password".toCharArray();
-        KeyStore keyStore = newEmptyKeyStore(password);
-
-        if (keyPair != null) {
-          Certificate[] certificates = chainCertificates.toArray(
-              new Certificate[chainCertificates.size()]);
-          keyStore.setKeyEntry("private", keyPair.getPrivate(), password, certificates);
-        }
-
-        for (int i = 0; i < certificates.size(); i++) {
-          keyStore.setCertificateEntry("cert_" + i, certificates.get(i));
-        }
-
-        // Wrap it up in an SSL context.
-        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
-            KeyManagerFactory.getDefaultAlgorithm());
-        keyManagerFactory.init(keyStore, password);
-        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-            TrustManagerFactory.getDefaultAlgorithm());
-        trustManagerFactory.init(keyStore);
-        TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-
-        if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-          throw new IllegalStateException("Unexpected default trust managers:"
-              + Arrays.toString(trustManagers));
-        }
-
-        SSLContext activeSslContext =
-            this.sslContext != null ? this.sslContext : Platform.get().getSSLContext();
-        activeSslContext.init(keyManagerFactory.getKeyManagers(), trustManagers,
-            new SecureRandom());
-
-        return new SslClient(activeSslContext, (X509TrustManager) trustManagers[0]);
-      } catch (GeneralSecurityException gse) {
-        throw new AssertionError(gse);
-      }
-    }
-
-    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
-      try {
-        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
-        InputStream in = null; // By convention, 'null' creates an empty key store.
-        keyStore.load(in, password);
-        return keyStore;
-      } catch (IOException e) {
-        throw new AssertionError(e);
-      }
-    }
-  }
-}
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
index 5f189dc608..ec8317e95e 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
@@ -39,7 +39,7 @@
     final List<RecordedRequest> requestsMade = new ArrayList<>();
     final Dispatcher dispatcher = new Dispatcher() {
       @Override
-      public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+      public MockResponse dispatch(RecordedRequest request) {
         requestsMade.add(request);
         return new MockResponse();
       }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index 0db518288a..eb41f4fbca 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -33,9 +33,15 @@
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import javax.net.ssl.HttpsURLConnection;
+import okhttp3.Handshake;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
+import okhttp3.Protocol;
+import okhttp3.RecordingHostnameVerifier;
 import okhttp3.internal.Util;
+import okhttp3.tls.HeldCertificate;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
@@ -44,9 +50,11 @@
 
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -293,7 +301,7 @@
     in.close();
   }
 
-  @Test public void disconnectRequestHalfway() throws IOException {
+  @Test public void disconnectRequestHalfway() throws Exception {
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
     // Limit the size of the request body that the server holds in memory to an arbitrary
     // 3.5 MBytes so this test can pass on devices with little memory.
@@ -312,11 +320,15 @@
       try {
         out.write(data);
         out.flush();
+        if (i == 513) {
+          // pause slightly after half way to make result more predictable
+          Thread.sleep(100);
+        }
       } catch (IOException e) {
         break;
       }
     }
-    assertEquals(512f, i, 10f); // Halfway +/- 1%
+    assertEquals(512f, i, 5f); // Halfway +/- 0.5%
   }
 
   @Test public void disconnectResponseHalfway() throws IOException {
@@ -440,6 +452,24 @@
     assertEquals("foo bar", requestUrl.queryParameter("key"));
   }
 
+  @Test public void shutdownServerAfterRequest() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE));
+
+    URL url = server.url("/").url();
+
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+
+    HttpURLConnection refusedConnection = (HttpURLConnection) url.openConnection();
+
+    try {
+      refusedConnection.getResponseCode();
+      fail("Second connection should be refused");
+    } catch (ConnectException e ) {
+      assertTrue(e.getMessage().contains("refused"));
+    }
+  }
+
   @Test public void http100Continue() throws Exception {
     server.enqueue(new MockResponse().setBody("response"));
 
@@ -456,4 +486,105 @@
     RecordedRequest request = server.takeRequest();
     assertEquals("request", request.getBody().readUtf8());
   }
+
+  @Test public void testH2PriorKnowledgeServerFallback() {
+    try {
+      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
+              + "[h2_prior_knowledge, http/1.1]", expected.getMessage());
+    }
+  }
+
+  @Test public void testH2PriorKnowledgeServerDuplicates() {
+    try {
+      // Treating this use case as user error
+      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
+          + "[h2_prior_knowledge, h2_prior_knowledge]", expected.getMessage());
+    }
+  }
+
+  @Test public void testMockWebServerH2PriorKnowledgeProtocol() {
+    server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE));
+
+    assertEquals(1, server.protocols().size());
+    assertEquals(Protocol.H2_PRIOR_KNOWLEDGE, server.protocols().get(0));
+  }
+
+  @Test public void https() throws Exception {
+    HandshakeCertificates handshakeCertificates = localhost();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    HttpUrl url = server.url("/");
+    HttpsURLConnection connection = (HttpsURLConnection) url.url().openConnection();
+    connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
+    connection.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+    assertEquals("abc", reader.readLine());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("https", request.getRequestUrl().scheme());
+    Handshake handshake = request.getHandshake();
+    assertNotNull(handshake.tlsVersion());
+    assertNotNull(handshake.cipherSuite());
+    assertNotNull(handshake.localPrincipal());
+    assertEquals(1, handshake.localCertificates().size());
+    assertNull(handshake.peerPrincipal());
+    assertEquals(0, handshake.peerCertificates().size());
+  }
+
+  @Test public void httpsWithClientAuth() throws Exception {
+    HeldCertificate clientCa = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .build();
+    HeldCertificate serverCa = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .build();
+    HeldCertificate serverCertificate = new HeldCertificate.Builder()
+        .signedBy(serverCa)
+        .addSubjectAlternativeName(server.getHostName())
+        .build();
+    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(clientCa.certificate())
+        .heldCertificate(serverCertificate)
+        .build();
+
+    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.requestClientAuth();
+
+    HeldCertificate clientCertificate = new HeldCertificate.Builder()
+        .signedBy(clientCa)
+        .build();
+    HandshakeCertificates clientHandshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(serverCa.certificate())
+        .heldCertificate(clientCertificate)
+        .build();
+
+    HttpUrl url = server.url("/");
+    HttpsURLConnection connection = (HttpsURLConnection) url.url().openConnection();
+    connection.setSSLSocketFactory(clientHandshakeCertificates.sslSocketFactory());
+    connection.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+    assertEquals("abc", reader.readLine());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("https", request.getRequestUrl().scheme());
+    Handshake handshake = request.getHandshake();
+    assertNotNull(handshake.tlsVersion());
+    assertNotNull(handshake.cipherSuite());
+    assertNotNull(handshake.localPrincipal());
+    assertEquals(1, handshake.localCertificates().size());
+    assertNotNull(handshake.peerPrincipal());
+    assertEquals(1, handshake.peerCertificates().size());
+  }
 }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
new file mode 100644
index 0000000000..e74e3c5275
--- /dev/null
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.mockwebserver;
+
+import java.net.Inet4Address;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import java.util.Collections;
+import java.util.Random;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okio.Buffer;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class RecordedRequestTest {
+  Headers headers = new Headers.Builder().build();
+
+  private class FakeSocket extends Socket {
+    private final InetAddress localAddress;
+    private final int remotePort;
+    private final InetAddress remoteAddress;
+    private final int localPort;
+
+    private FakeSocket(int localPort) {
+      this(Inet4Address.getLoopbackAddress(), localPort);
+    }
+
+    private FakeSocket(InetAddress inetAddress, int localPort) {
+      this(inetAddress, localPort, inetAddress, 1234);
+    }
+
+    private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAddress, int remotePort) {
+      this.localAddress = localAddress;
+      this.localPort = localPort;
+      this.remoteAddress = remoteAddress;
+      this.remotePort = remotePort;
+    }
+
+    @Override public InetAddress getInetAddress() {
+      return remoteAddress;
+    }
+
+    @Override public InetAddress getLocalAddress() {
+      return localAddress;
+    }
+
+    @Override public int getLocalPort() {
+      return localPort;
+    }
+
+    @Override public int getPort() {
+      return remotePort;
+    }
+  }
+
+  @Test public void testIPv4() throws UnknownHostException {
+    Socket socket =
+        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] { 127, 0, 0, 1 }), 80);
+
+    RecordedRequest request =
+        new RecordedRequest("GET / HTTP/1.1", headers, Collections.<Integer>emptyList(), 0,
+            new Buffer(), 0, socket);
+
+    assertEquals("http://127.0.0.1/", request.getRequestUrl().toString());
+  }
+
+  @Test public void testIPv6() throws UnknownHostException {
+    Socket socket = new FakeSocket(InetAddress.getByAddress("::1",
+        new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }), 80);
+
+    RecordedRequest request =
+        new RecordedRequest("GET / HTTP/1.1", headers, Collections.<Integer>emptyList(), 0,
+            new Buffer(), 0, socket);
+
+    assertEquals("http://[::1]/", request.getRequestUrl().toString());
+  }
+
+  @Test public void testUsesLocal() throws UnknownHostException {
+    Socket socket =
+        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] { 127, 0, 0, 1 }), 80);
+
+    RecordedRequest request =
+        new RecordedRequest("GET / HTTP/1.1", headers, Collections.<Integer>emptyList(), 0,
+            new Buffer(), 0, socket);
+
+    assertEquals("http://127.0.0.1/", request.getRequestUrl().toString());
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/http2/Http2Server.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
similarity index 93%
rename from mockwebserver/src/main/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
rename to mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
index cdd7d5a919..7d3b09a2cb 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
@@ -28,18 +28,19 @@
 import java.util.logging.Logger;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Headers;
 import okhttp3.Protocol;
 import okhttp3.internal.Util;
 import okhttp3.internal.http2.Header;
 import okhttp3.internal.http2.Http2Connection;
 import okhttp3.internal.http2.Http2Stream;
 import okhttp3.internal.platform.Platform;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okio.BufferedSink;
 import okio.Okio;
 import okio.Source;
 
 import static okhttp3.internal.platform.Platform.INFO;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 
 /** A basic HTTP/2 server that serves the contents of a local directory. */
 public final class Http2Server extends Http2Connection.Listener {
@@ -95,11 +96,11 @@ private SSLSocket doSsl(Socket socket) throws IOException {
 
   @Override public void onStream(Http2Stream stream) throws IOException {
     try {
-      List<Header> requestHeaders = stream.getRequestHeaders();
+      Headers requestHeaders = stream.takeHeaders();
       String path = null;
       for (int i = 0, size = requestHeaders.size(); i < size; i++) {
-        if (requestHeaders.get(i).name.equals(Header.TARGET_PATH)) {
-          path = requestHeaders.get(i).value.utf8();
+        if (requestHeaders.name(i).equals(Header.TARGET_PATH_UTF8)) {
+          path = requestHeaders.value(i);
           break;
         }
       }
@@ -129,7 +130,7 @@ private void send404(Http2Stream stream, String path) throws IOException {
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", "text/plain")
     );
-    stream.sendResponseHeaders(responseHeaders, true);
+    stream.writeHeaders(responseHeaders, true);
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("Not found: " + path);
     out.close();
@@ -141,7 +142,7 @@ private void serveDirectory(Http2Stream stream, File[] files) throws IOException
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", "text/html; charset=UTF-8")
     );
-    stream.sendResponseHeaders(responseHeaders, true);
+    stream.writeHeaders(responseHeaders, true);
     BufferedSink out = Okio.buffer(stream.getSink());
     for (File file : files) {
       String target = file.isDirectory() ? (file.getName() + "/") : file.getName();
@@ -156,7 +157,7 @@ private void serveFile(Http2Stream stream, File file) throws IOException {
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", contentType(file))
     );
-    stream.sendResponseHeaders(responseHeaders, true);
+    stream.writeHeaders(responseHeaders, true);
     Source source = Okio.source(file);
     try {
       BufferedSink out = Okio.buffer(stream.getSink());
@@ -185,7 +186,7 @@ public static void main(String... args) throws Exception {
     }
 
     Http2Server server = new Http2Server(new File(args[0]),
-        SslClient.localhost().sslContext.getSocketFactory());
+        localhost().sslContext().getSocketFactory());
     server.run();
   }
 }
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index 0a44e199e3..3511624331 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.10.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
@@ -20,13 +20,14 @@
     </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
+      <artifactId>logging-interceptor</artifactId>
       <version>${project.version}</version>
-      <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.bouncycastle</groupId>
-      <artifactId>bcprov-jdk15on</artifactId>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
     </dependency>
     <dependency>
       <groupId>io.airlift</groupId>
@@ -56,6 +57,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-assembly-plugin</artifactId>
+        <version>3.0.0</version>
         <configuration>
           <descriptorRefs>
             <descriptorRef>jar-with-dependencies</descriptorRef>
@@ -94,6 +96,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okcurl/src/main/java/okhttp3/curl/Main.java b/okcurl/src/main/java/okhttp3/curl/Main.java
index cee2600619..4b1fd21087 100644
--- a/okcurl/src/main/java/okhttp3/curl/Main.java
+++ b/okcurl/src/main/java/okhttp3/curl/Main.java
@@ -48,6 +48,8 @@
 import okhttp3.internal.http.StatusLine;
 import okhttp3.internal.http2.Http2;
 import okhttp3.internal.platform.Platform;
+import okhttp3.logging.HttpLoggingInterceptor;
+import okhttp3.logging.LoggingEventListener;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
@@ -121,6 +123,11 @@ private static String protocols() {
   @Option(name = {"-V", "--version"}, description = "Show version number and quit")
   public boolean version;
 
+  @Option(
+      name = {"-v", "--verbose"},
+      description = "Makes " + NAME + " verbose during the operation")
+  public boolean verbose;
+
   @Arguments(title = "url", description = "Remote resource URL")
   public String url;
 
@@ -184,6 +191,16 @@ private OkHttpClient createClient() {
       builder.sslSocketFactory(sslSocketFactory, trustManager);
       builder.hostnameVerifier(createInsecureHostnameVerifier());
     }
+    if (verbose) {
+      HttpLoggingInterceptor.Logger logger =
+          new HttpLoggingInterceptor.Logger() {
+            @Override
+            public void log(String message) {
+              System.out.println(message);
+            }
+          };
+      builder.eventListenerFactory(new LoggingEventListener.Factory(logger));
+    }
     return builder.build();
   }
 
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index 91df638a01..2b2d2b5e7a 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.10.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
@@ -27,6 +27,12 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-urlconnection</artifactId>
@@ -51,6 +57,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <excludePackageNames>okhttp3.internal.*</excludePackageNames>
           <links>
@@ -61,6 +68,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
index cdbc21efda..09a438807f 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
@@ -35,14 +35,15 @@
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.internal.Internal;
 import okhttp3.internal.cache.InternalCache;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -58,7 +59,7 @@
  * </ul>
  */
 public class CacheAdapterTest {
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
   private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private MockWebServer server;
   private OkHttpClient client;
@@ -123,7 +124,8 @@
     };
     setInternalCache(new CacheAdapter(responseCache));
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build();
 
@@ -253,7 +255,8 @@
     };
     setInternalCache(new CacheAdapter(responseCache));
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build();
 
@@ -281,7 +284,7 @@ private URL configureServer(MockResponse mockResponse) throws Exception {
   }
 
   private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
-    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false /* tunnelProxy */);
     server.enqueue(mockResponse);
     server.start();
     return server.url("/").url();
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
index c14d6d57f4..ad5d3fdfd3 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
@@ -660,7 +660,7 @@ private static Response createArbitraryOkResponse() {
   }
 
   private static RequestBody createRequestBody(String bodyText) {
-    return RequestBody.create(MediaType.parse("text/plain"), bodyText);
+    return RequestBody.create(MediaType.get("text/plain"), bodyText);
   }
 
   private static ResponseBody createResponseBody(String bodyText) {
@@ -668,7 +668,7 @@ private static ResponseBody createResponseBody(String bodyText) {
     final long contentLength = source.size();
     return new ResponseBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain; charset=utf-8");
+        return MediaType.get("text/plain; charset=utf-8");
       }
 
       @Override public long contentLength() {
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
index 17bd2d14b8..eb95e3ea4e 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
@@ -26,13 +26,11 @@
 import java.net.CacheRequest;
 import java.net.CacheResponse;
 import java.net.CookieManager;
-import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.ProtocolException;
 import java.net.ResponseCache;
 import java.net.SecureCacheResponse;
 import java.net.URI;
-import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.URLConnection;
 import java.nio.charset.StandardCharsets;
@@ -40,7 +38,6 @@
 import java.security.cert.Certificate;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
 import java.util.LinkedHashMap;
@@ -63,11 +60,11 @@
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.internal.Internal;
 import okhttp3.internal.cache.InternalCache;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -78,6 +75,7 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -96,7 +94,7 @@
   @Rule public MockWebServer server2 = new MockWebServer();
 
   private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
   private ResponseCache cache;
   private CookieManager cookieManager;
   private OkUrlFactory urlFactory;
@@ -111,7 +109,7 @@
     cookieManager = new CookieManager();
   }
 
-  @After public void tearDown() throws Exception {
+  @After public void tearDown() {
     ResponseCache.setDefault(null);
   }
 
@@ -272,14 +270,14 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   @Test public void secureResponseCaching() throws IOException {
     assumeFalse(getPlatform().equals("jdk9"));
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
     HttpsURLConnection c1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    c1.setSSLSocketFactory(sslClient.socketFactory);
+    c1.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     c1.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(c1));
 
@@ -291,7 +289,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Principal localPrincipal = c1.getLocalPrincipal();
 
     HttpsURLConnection c2 = (HttpsURLConnection) openConnection(server.url("/").url()); // cached!
-    c2.setSSLSocketFactory(sslClient.socketFactory);
+    c2.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     c2.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(c2));
 
@@ -350,7 +348,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -364,7 +362,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("DEF"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
 
@@ -388,7 +387,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
    * https://github.com/square/okhttp/issues/214
    */
   @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslClient.socketFactory, false);
+    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server2.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -403,7 +402,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Location: " + server2.url("/").url()));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
 
@@ -480,7 +480,7 @@ private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) th
     testServerPrematureDisconnect(TransferKind.CHUNKED);
   }
 
-  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
+  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() {
     // Intentionally empty. This case doesn't make sense because there's no
     // such thing as a premature disconnect when the disconnect itself
     // indicates the end of the data stream.
@@ -1196,7 +1196,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
     Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
     DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
     String lastModifiedString = dateFormat.format(lastModifiedDate);
     String servedString = dateFormat.format(servedDate);
 
@@ -1466,7 +1466,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void varyAndHttps() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
@@ -1475,7 +1475,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("B"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
 
@@ -1563,14 +1564,6 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("299 test danger", connection2.getHeaderField("Warning"));
   }
 
-  public void assertCookies(URL url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<>();
-    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
-      actualCookies.add(cookie.toString());
-    }
-    assertEquals(Arrays.asList(expectedCookies), actualCookies);
-  }
-
   @Test public void doNotCachePartialResponse() throws Exception {
     assertNotCached(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
@@ -1674,7 +1667,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     assertEquals("A", readAscii(connection));
   }
 
-  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
+  @Test public void emptyResponseHeaderNameFromCacheIsLenient() {
     Headers.Builder headers = new Headers.Builder()
         .add("Cache-Control: max-age=120");
     Internal.instance.addLenient(headers, ": A");
@@ -1769,8 +1762,7 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setChunkedBody(content, chunkSize);
       }
     },
@@ -1795,7 +1787,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
   }
 
   /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
+  private Buffer gzip(String data) throws IOException {
     Buffer result = new Buffer();
     BufferedSink sink = Okio.buffer(new GzipSink(result));
     sink.writeUtf8(data);
@@ -1898,7 +1890,7 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
             aborted.set(true);
           }
 
-          @Override public OutputStream getBody() throws IOException {
+          @Override public OutputStream getBody() {
             return null;
           }
         };
@@ -1924,10 +1916,9 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
     setInternalCache(new CacheAdapter(new AbstractResponseCache() {
       @Override
       public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders)
-          throws IOException {
+          Map<String, List<String>> requestHeaders) {
         return new CacheResponse() {
-          @Override public Map<String, List<String>> getHeaders() throws IOException {
+          @Override public Map<String, List<String>> getHeaders() {
             String contentType = "text/plain";
             Map<String, List<String>> headers = new LinkedHashMap<>();
             headers.put("Content-Length", Arrays.asList(Integer.toString(cachedContent.length)));
@@ -1939,7 +1930,7 @@ public CacheResponse get(URI uri, String requestMethod,
             return headers;
           }
 
-          @Override public InputStream getBody() throws IOException {
+          @Override public InputStream getBody() {
             return new ByteArrayInputStream(cachedContent);
           }
         };
@@ -1988,32 +1979,32 @@ private InsecureResponseCache(ResponseCache delegate) {
   @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
     assumeFalse(getPlatform().equals("jdk9"));
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
     AndroidInternal.setResponseCache(urlFactory, new InsecureResponseCache(cache));
 
     HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    connection1.setSSLSocketFactory(sslClient.socketFactory);
+    connection1.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     connection1.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(connection1));
 
     // Not cached!
     HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.url("/").url());
-    connection2.setSSLSocketFactory(sslClient.socketFactory);
+    connection2.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     connection2.setHostnameVerifier(hostnameVerifier);
     assertEquals("DEF", readAscii(connection2));
   }
 
-  @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
+  @Test public void responseCacheRequestHeaders() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("ABC"));
 
     final AtomicReference<Map<String, List<String>>> requestHeadersRef = new AtomicReference<>();
     setInternalCache(new CacheAdapter(new AbstractResponseCache() {
       @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
+          Map<String, List<String>> requestHeaders) {
         requestHeadersRef.set(requestHeaders);
         return null;
       }
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index 8ee6b0ccfc..4a1179e779 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.10.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
@@ -48,6 +48,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
@@ -59,6 +60,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java b/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
index 45d27aafd1..c55543f569 100644
--- a/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
+++ b/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
@@ -8,7 +8,7 @@
 
 /** Adapts an {@link HttpEntity} to OkHttp's {@link RequestBody}. */
 final class HttpEntityBody extends RequestBody {
-  private static final MediaType DEFAULT_MEDIA_TYPE = MediaType.parse("application/octet-stream");
+  private static final MediaType DEFAULT_MEDIA_TYPE = MediaType.get("application/octet-stream");
 
   private final HttpEntity entity;
   private final MediaType mediaType;
diff --git a/okhttp-dnsoverhttps/README.md b/okhttp-dnsoverhttps/README.md
new file mode 100644
index 0000000000..30132b47c8
--- /dev/null
+++ b/okhttp-dnsoverhttps/README.md
@@ -0,0 +1,5 @@
+OkHttp DNS over HTTPS Implementation
+====================================
+
+This module is an experimental implementation of DNS over HTTPS using OkHttp.
+API is not considered stable and may change at any time.
diff --git a/okhttp-dnsoverhttps/pom.xml b/okhttp-dnsoverhttps/pom.xml
new file mode 100644
index 0000000000..224f432979
--- /dev/null
+++ b/okhttp-dnsoverhttps/pom.xml
@@ -0,0 +1,67 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.13.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-dnsoverhttps</artifactId>
+  <name>OkHttp DNS over HTTPS</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.conscrypt</groupId>
+      <artifactId>conscrypt-openjdk-uber</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.dnsoverhttps</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.java
similarity index 53%
rename from okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
rename to okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.java
index 03e8ce08e9..2cd474d30b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
+ * Copyright (C) 2018 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,21 +13,33 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.dnsoverhttps;
 
 import java.net.InetAddress;
 import java.net.UnknownHostException;
-import java.util.Collections;
 import java.util.List;
 import okhttp3.Dns;
 
 /**
- * A network that resolves only one IP address per host. Use this when testing route selection
- * fallbacks to prevent the host machine's various IP addresses from interfering.
+ * Internal Bootstrap DNS implementation for handling initial connection to DNS over HTTPS server.
+ *
+ * Returns hardcoded results for the known host.
  */
-public class SingleInetAddressDns implements Dns {
+final class BootstrapDns implements Dns {
+  private final String dnsHostname;
+  private final List<InetAddress> dnsServers;
+
+  BootstrapDns(String dnsHostname, List<InetAddress> dnsServers) {
+    this.dnsHostname = dnsHostname;
+    this.dnsServers = dnsServers;
+  }
+
   @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-    List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
-    return Collections.singletonList(addresses.get(0));
+    if (!this.dnsHostname.equals(hostname)) {
+      throw new UnknownHostException(
+          "BootstrapDns called for " + hostname + " instead of " + dnsHostname);
+    }
+
+    return dnsServers;
   }
 }
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java
new file mode 100644
index 0000000000..67442f3313
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java
@@ -0,0 +1,359 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import javax.annotation.Nullable;
+import okhttp3.CacheControl;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Dns;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
+import okio.ByteString;
+
+/**
+ * DNS over HTTPS implementation.
+ *
+ * Implementation of https://tools.ietf.org/html/draft-ietf-doh-dns-over-https-13
+ *
+ * <blockquote>A DNS API client encodes a single DNS query into an HTTP request
+ * using either the HTTP GET or POST method and the other requirements
+ * of this section.  The DNS API server defines the URI used by the
+ * request through the use of a URI Template.</blockquote>
+ *
+ * <h3>Warning: This is a non-final API.</h3>
+ *
+ * <p><strong>As of OkHttp 3.11, this feature is an unstable preview: the API is subject to change,
+ * and the implementation is incomplete. We expect that OkHttp 3.12 or 3.13 will finalize this API.
+ * Until then, expect API and behavior changes when you update your OkHttp dependency.</strong>
+ */
+public class DnsOverHttps implements Dns {
+  public static final MediaType DNS_MESSAGE = MediaType.get("application/dns-message");
+  public static final int MAX_RESPONSE_SIZE = 64 * 1024;
+  private final OkHttpClient client;
+  private final HttpUrl url;
+  private final boolean includeIPv6;
+  private final boolean post;
+  private final boolean resolvePrivateAddresses;
+  private final boolean resolvePublicAddresses;
+
+  DnsOverHttps(Builder builder) {
+    if (builder.client == null) {
+      throw new NullPointerException("client not set");
+    }
+    if (builder.url == null) {
+      throw new NullPointerException("url not set");
+    }
+
+    this.url = builder.url;
+    this.includeIPv6 = builder.includeIPv6;
+    this.post = builder.post;
+    this.resolvePrivateAddresses = builder.resolvePrivateAddresses;
+    this.resolvePublicAddresses = builder.resolvePublicAddresses;
+    this.client = builder.client.newBuilder().dns(buildBootstrapClient(builder)).build();
+  }
+
+  private static Dns buildBootstrapClient(Builder builder) {
+    List<InetAddress> hosts = builder.bootstrapDnsHosts;
+
+    if (hosts != null) {
+      return new BootstrapDns(builder.url.host(), hosts);
+    } else {
+      return builder.systemDns;
+    }
+  }
+
+  public HttpUrl url() {
+    return url;
+  }
+
+  public boolean post() {
+    return post;
+  }
+
+  public boolean includeIPv6() {
+    return includeIPv6;
+  }
+
+  public OkHttpClient client() {
+    return client;
+  }
+
+  public boolean resolvePrivateAddresses() {
+    return resolvePrivateAddresses;
+  }
+
+  public boolean resolvePublicAddresses() {
+    return resolvePublicAddresses;
+  }
+
+  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+    if (!resolvePrivateAddresses || !resolvePublicAddresses) {
+      boolean privateHost = isPrivateHost(hostname);
+
+      if (privateHost && !resolvePrivateAddresses) {
+        throw new UnknownHostException("private hosts not resolved");
+      }
+
+      if (!privateHost && !resolvePublicAddresses) {
+        throw new UnknownHostException("public hosts not resolved");
+      }
+    }
+
+    return lookupHttps(hostname);
+  }
+
+  private List<InetAddress> lookupHttps(String hostname) throws UnknownHostException {
+    List<Call> networkRequests = new ArrayList<>(2);
+    List<Exception> failures = new ArrayList<>(2);
+    List<InetAddress> results = new ArrayList<>(5);
+
+    buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_A);
+
+    if (includeIPv6) {
+      buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_AAAA);
+    }
+
+    executeRequests(hostname, networkRequests, results, failures);
+
+    if (!results.isEmpty()) {
+      return results;
+    }
+
+    return throwBestFailure(hostname, failures);
+  }
+
+  private void buildRequest(String hostname, List<Call> networkRequests, List<InetAddress> results,
+      List<Exception> failures, int type) {
+    Request request = buildRequest(hostname, type);
+    Response response = getCacheOnlyResponse(request);
+
+    if (response != null) {
+      processResponse(response, hostname, results, failures);
+    } else {
+      networkRequests.add(client.newCall(request));
+    }
+  }
+
+  private void executeRequests(final String hostname, List<Call> networkRequests,
+      final List<InetAddress> responses, final List<Exception> failures) {
+    final CountDownLatch latch = new CountDownLatch(networkRequests.size());
+
+    for (Call call : networkRequests) {
+      call.enqueue(new Callback() {
+        @Override public void onFailure(Call call, IOException e) {
+          synchronized (failures) {
+            failures.add(e);
+          }
+          latch.countDown();
+        }
+
+        @Override public void onResponse(Call call, Response response) {
+          processResponse(response, hostname, responses, failures);
+          latch.countDown();
+        }
+      });
+    }
+
+    try {
+      latch.await();
+    } catch (InterruptedException e) {
+      failures.add(e);
+    }
+  }
+
+  private void processResponse(Response response, String hostname, List<InetAddress> results,
+      List<Exception> failures) {
+    try {
+      List<InetAddress> addresses = readResponse(hostname, response);
+      synchronized (results) {
+        results.addAll(addresses);
+      }
+    } catch (Exception e) {
+      synchronized (failures) {
+        failures.add(e);
+      }
+    }
+  }
+
+  private List<InetAddress> throwBestFailure(String hostname, List<Exception> failures)
+      throws UnknownHostException {
+    if (failures.size() == 0) {
+      throw new UnknownHostException(hostname);
+    }
+
+    Exception failure = failures.get(0);
+
+    if (failure instanceof UnknownHostException) {
+      throw (UnknownHostException) failure;
+    }
+
+    UnknownHostException unknownHostException = new UnknownHostException(hostname);
+    unknownHostException.initCause(failure);
+
+    for (int i = 1; i < failures.size(); i++) {
+      Util.addSuppressedIfPossible(unknownHostException, failures.get(i));
+    }
+
+    throw unknownHostException;
+  }
+
+  private @Nullable Response getCacheOnlyResponse(Request request) {
+    if (!post && client.cache() != null) {
+      try {
+        Request cacheRequest = request.newBuilder().cacheControl(CacheControl.FORCE_CACHE).build();
+
+        Response cacheResponse = client.newCall(cacheRequest).execute();
+
+        if (cacheResponse.code() != 504) {
+          return cacheResponse;
+        }
+      } catch (IOException ioe) {
+        // Failures are ignored as we can fallback to the network
+        // and hopefully repopulate the cache.
+      }
+    }
+
+    return null;
+  }
+
+  private List<InetAddress> readResponse(String hostname, Response response) throws Exception {
+    if (response.cacheResponse() == null && response.protocol() != Protocol.HTTP_2) {
+      Platform.get().log(Platform.WARN, "Incorrect protocol: " + response.protocol(), null);
+    }
+
+    try {
+      if (!response.isSuccessful()) {
+        throw new IOException("response: " + response.code() + " " + response.message());
+      }
+
+      ResponseBody body = response.body();
+
+      if (body.contentLength() > MAX_RESPONSE_SIZE) {
+        throw new IOException("response size exceeds limit ("
+            + MAX_RESPONSE_SIZE
+            + " bytes): "
+            + body.contentLength()
+            + " bytes");
+      }
+
+      ByteString responseBytes = body.source().readByteString();
+
+      return DnsRecordCodec.decodeAnswers(hostname, responseBytes);
+    } finally {
+      response.close();
+    }
+  }
+
+  private Request buildRequest(String hostname, int type) {
+    Request.Builder requestBuilder = new Request.Builder().header("Accept", DNS_MESSAGE.toString());
+
+    ByteString query = DnsRecordCodec.encodeQuery(hostname, type);
+
+    if (post) {
+      requestBuilder = requestBuilder.url(url).post(RequestBody.create(DNS_MESSAGE, query));
+    } else {
+      String encoded = query.base64Url().replace("=", "");
+      HttpUrl requestUrl = url.newBuilder().addQueryParameter("dns", encoded).build();
+
+      requestBuilder = requestBuilder.url(requestUrl);
+    }
+
+    return requestBuilder.build();
+  }
+
+  static boolean isPrivateHost(String host) {
+    return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host) == null;
+  }
+
+  public static final class Builder {
+    @Nullable OkHttpClient client = null;
+    @Nullable HttpUrl url = null;
+    boolean includeIPv6 = true;
+    boolean post = false;
+    Dns systemDns = Dns.SYSTEM;
+    @Nullable List<InetAddress> bootstrapDnsHosts = null;
+    boolean resolvePrivateAddresses = false;
+    boolean resolvePublicAddresses = true;
+
+    public Builder() {
+    }
+
+    public DnsOverHttps build() {
+      return new DnsOverHttps(this);
+    }
+
+    public Builder client(OkHttpClient client) {
+      this.client = client;
+      return this;
+    }
+
+    public Builder url(HttpUrl url) {
+      this.url = url;
+      return this;
+    }
+
+    public Builder includeIPv6(boolean includeIPv6) {
+      this.includeIPv6 = includeIPv6;
+      return this;
+    }
+
+    public Builder post(boolean post) {
+      this.post = post;
+      return this;
+    }
+
+    public Builder resolvePrivateAddresses(boolean resolvePrivateAddresses) {
+      this.resolvePrivateAddresses = resolvePrivateAddresses;
+      return this;
+    }
+
+    public Builder resolvePublicAddresses(boolean resolvePublicAddresses) {
+      this.resolvePublicAddresses = resolvePublicAddresses;
+      return this;
+    }
+
+    public Builder bootstrapDnsHosts(@Nullable List<InetAddress> bootstrapDnsHosts) {
+      this.bootstrapDnsHosts = bootstrapDnsHosts;
+      return this;
+    }
+
+    public Builder bootstrapDnsHosts(InetAddress... bootstrapDnsHosts) {
+      return bootstrapDnsHosts(Arrays.asList(bootstrapDnsHosts));
+    }
+
+    public Builder systemDns(Dns systemDns) {
+      this.systemDns = systemDns;
+      return this;
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java
new file mode 100644
index 0000000000..4c1cfc481e
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package okhttp3.dnsoverhttps;
+
+import java.io.EOFException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.List;
+import okio.Buffer;
+import okio.ByteString;
+import okio.Utf8;
+
+/**
+ * Trivial Dns Encoder/Decoder, basically ripped from Netty full implementation.
+ */
+class DnsRecordCodec {
+  private static final byte SERVFAIL = 2;
+  private static final byte NXDOMAIN = 3;
+  public static final int TYPE_A = 0x0001;
+  public static final int TYPE_AAAA = 0x001c;
+  private static final int TYPE_PTR = 0x000c;
+  private static final Charset ASCII = Charset.forName("ASCII");
+
+  private DnsRecordCodec() {
+  }
+
+  public static ByteString encodeQuery(String host, int type) {
+    Buffer buf = new Buffer();
+
+    buf.writeShort(0); // query id
+    buf.writeShort(256); // flags with recursion
+    buf.writeShort(1); // question count
+    buf.writeShort(0); // answerCount
+    buf.writeShort(0); // authorityResourceCount
+    buf.writeShort(0); // additional
+
+    Buffer nameBuf = new Buffer();
+    final String[] labels = host.split("\\.");
+    for (String label : labels) {
+      long utf8ByteCount = Utf8.size(label);
+      if (utf8ByteCount != label.length()) {
+        throw new IllegalArgumentException("non-ascii hostname: " + host);
+      }
+      nameBuf.writeByte((byte) utf8ByteCount);
+      nameBuf.writeUtf8(label);
+    }
+    nameBuf.writeByte(0); // end
+
+    nameBuf.copyTo(buf, 0, nameBuf.size());
+    buf.writeShort(type);
+    buf.writeShort(1); // CLASS_IN
+
+    return buf.readByteString();
+  }
+
+  public static List<InetAddress> decodeAnswers(String hostname, ByteString byteString)
+      throws Exception {
+    List<InetAddress> result = new ArrayList<>();
+
+    Buffer buf = new Buffer();
+    buf.write(byteString);
+    buf.readShort(); // query id
+
+    final int flags = buf.readShort() & 0xffff;
+    if (flags >> 15 == 0) {
+      throw new IllegalArgumentException("not a response");
+    }
+
+    byte responseCode = (byte) (flags & 0xf);
+
+    if (responseCode == NXDOMAIN) {
+      throw new UnknownHostException(hostname + ": NXDOMAIN");
+    } else if (responseCode == SERVFAIL) {
+      throw new UnknownHostException(hostname + ": SERVFAIL");
+    }
+
+    final int questionCount = buf.readShort() & 0xffff;
+    final int answerCount = buf.readShort() & 0xffff;
+    buf.readShort(); // authority record count
+    buf.readShort(); // additional record count
+
+    for (int i = 0; i < questionCount; i++) {
+      skipName(buf); // name
+      buf.readShort(); // type
+      buf.readShort(); // class
+    }
+
+    for (int i = 0; i < answerCount; i++) {
+      skipName(buf); // name
+
+      int type = buf.readShort() & 0xffff;
+      buf.readShort(); // class
+      final long ttl = buf.readInt() & 0xffffffffL; // ttl
+      final int length = buf.readShort() & 0xffff;
+
+      if (type == TYPE_A || type == TYPE_AAAA) {
+        byte[] bytes = new byte[length];
+        buf.read(bytes);
+        result.add(InetAddress.getByAddress(bytes));
+      } else {
+        buf.skip(length);
+      }
+    }
+
+    return result;
+  }
+
+  private static void skipName(Buffer in) throws EOFException {
+    // 0 - 63 bytes
+    int length = in.readByte();
+
+    if (length < 0) {
+      // compressed name pointer, first two bits are 1
+      // drop second byte of compression offset
+      in.skip(1);
+    } else {
+      while (length > 0) {
+        // skip each part of the domain name
+        in.skip(length);
+        length = in.readByte();
+      }
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java
new file mode 100644
index 0000000000..54da565bc2
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java
@@ -0,0 +1,3 @@
+/** A DNS over HTTPS implementation for OkHttp. */
+@okhttp3.internal.annotations.EverythingIsNonNull
+package okhttp3.dnsoverhttps;
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
new file mode 100644
index 0000000000..c6c16278dd
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.List;
+import okhttp3.Cache;
+import okhttp3.Dns;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static java.util.Arrays.asList;
+import static java.util.Collections.singletonList;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class DnsOverHttpsTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final OkHttpClient bootstrapClient =
+      new OkHttpClient.Builder().protocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1)).build();
+  private Dns dns = buildLocalhost(bootstrapClient, false);
+
+  @Before public void setUp() {
+    server.setProtocols(bootstrapClient.protocols());
+  }
+
+  @Test public void getOne() throws Exception {
+    server.enqueue(dnsResponse(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
+            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
+            + "0010000003b00049df00112"));
+
+    List<InetAddress> result = dns.lookup("google.com");
+
+    assertEquals(singletonList(address("157.240.1.18")), result);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("GET", recordedRequest.getMethod());
+    assertEquals("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
+        recordedRequest.getPath());
+  }
+
+  @Test public void getIpv6() throws Exception {
+    server.enqueue(dnsResponse(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
+            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
+            + "0010000003b00049df00112"));
+    server.enqueue(dnsResponse(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d00001c0001c00c00050001"
+            + "00000a1b000603617069c012c0300005000100000b1f000c04737461720463313072c012c042001c0"
+            + "0010000003b00102a032880f0290011faceb00c00000002"));
+
+    dns = buildLocalhost(bootstrapClient, true);
+
+    List<InetAddress> result = dns.lookup("google.com");
+
+    assertEquals(2, result.size());
+    assertTrue(result.contains(address("157.240.1.18")));
+    assertTrue(result.contains(address("2a03:2880:f029:11:face:b00c:0:2")));
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("GET", request1.getMethod());
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("GET", request2.getMethod());
+
+    assertEquals(new HashSet<>(
+            Arrays.asList("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
+                "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AABwAAQ")),
+        new LinkedHashSet<>(Arrays.asList(request1.getPath(), request2.getPath())));
+  }
+
+  @Test public void failure() throws Exception {
+    server.enqueue(dnsResponse(
+        "0000818300010000000100000e7364666c6b686673646c6b6a64660265650000010001c01b00060001"
+            + "000007070038026e7303746c64c01b0a686f73746d61737465720d6565737469696e7465726e657"
+            + "4c01b5adb12c100000e10000003840012750000000e10"));
+
+    try {
+      dns.lookup("google.com");
+      fail();
+    } catch (UnknownHostException uhe) {
+      uhe.printStackTrace();
+      assertEquals("google.com: NXDOMAIN", uhe.getMessage());
+    }
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("GET", recordedRequest.getMethod());
+    assertEquals("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
+        recordedRequest.getPath());
+  }
+
+  @Test public void failOnExcessiveResponse() {
+    char[] array = new char[128 * 1024 + 2];
+    Arrays.fill(array, '0');
+    server.enqueue(dnsResponse(new String(array)));
+
+    try {
+      dns.lookup("google.com");
+      fail();
+    } catch (IOException ioe) {
+      assertEquals("google.com", ioe.getMessage());
+      Throwable cause = ioe.getCause();
+      assertTrue(cause instanceof IOException);
+      assertEquals("response size exceeds limit (65536 bytes): 65537 bytes", cause.getMessage());
+    }
+  }
+
+  @Test public void failOnBadResponse() {
+    server.enqueue(dnsResponse("00"));
+
+    try {
+      dns.lookup("google.com");
+      fail();
+    } catch (IOException ioe) {
+      assertEquals("google.com", ioe.getMessage());
+      Throwable cause = ioe.getCause();
+      assertTrue(cause instanceof RuntimeException);
+    }
+  }
+
+  // TODO GET preferred order - with tests to confirm this
+  // 1. successful fresh cached GET response
+  // 2. unsuccessful (404, 500) fresh cached GET response
+  // 3. successful network response
+  // 4. successful stale cached GET response
+  // 5. unsuccessful response
+
+  // TODO how closely to follow POST rules on caching?
+
+  @Test public void usesCache() throws Exception {
+    Cache cache = new Cache(new File("./target/DnsOverHttpsTest.cache"), 100 * 1024);
+    OkHttpClient cachedClient = bootstrapClient.newBuilder().cache(cache).build();
+    DnsOverHttps cachedDns = buildLocalhost(cachedClient, false);
+
+    server.enqueue(dnsResponse(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
+            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
+            + "0010000003b00049df00112").setHeader("cache-control", "private, max-age=298"));
+
+    List<InetAddress> result = cachedDns.lookup("google.com");
+
+    assertEquals(singletonList(address("157.240.1.18")), result);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("GET", recordedRequest.getMethod());
+    assertEquals("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
+        recordedRequest.getPath());
+
+    result = cachedDns.lookup("google.com");
+    assertEquals(singletonList(address("157.240.1.18")), result);
+  }
+
+  private MockResponse dnsResponse(String s) {
+    return new MockResponse().setBody(new Buffer().write(ByteString.decodeHex(s)))
+        .addHeader("content-type", "application/dns-message")
+        .addHeader("content-length", s.length() / 2);
+  }
+
+  private DnsOverHttps buildLocalhost(OkHttpClient bootstrapClient, boolean includeIPv6) {
+    HttpUrl url = server.url("/lookup?ct");
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .includeIPv6(includeIPv6)
+        .resolvePrivateAddresses(true)
+        .url(url)
+        .build();
+  }
+
+  private static InetAddress address(String host) {
+    try {
+      return InetAddress.getByName(host);
+    } catch (UnknownHostException e) {
+      // impossible for IP addresses
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
new file mode 100644
index 0000000000..3a12b4d254
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Collections;
+import java.util.List;
+import okio.ByteString;
+import org.junit.Test;
+
+import static okhttp3.dnsoverhttps.DnsRecordCodec.TYPE_A;
+import static okhttp3.dnsoverhttps.DnsRecordCodec.TYPE_AAAA;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class DnsRecordCodecTest {
+  @Test public void testGoogleDotComEncoding() {
+    String encoded = encodeQuery("google.com", TYPE_A);
+
+    assertEquals("AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ", encoded);
+  }
+
+  private String encodeQuery(String host, int type) {
+    return DnsRecordCodec.encodeQuery(host, type).base64Url().replace("=", "");
+  }
+
+  @Test public void testGoogleDotComEncodingWithIPv6() {
+    String encoded = encodeQuery("google.com", TYPE_AAAA);
+
+    assertEquals("AAABAAABAAAAAAAABmdvb2dsZQNjb20AABwAAQ", encoded);
+  }
+
+  @Test public void testGoogleDotComDecodingFromCloudflare() throws Exception {
+    List<InetAddress> encoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
+        "00008180000100010000000006676f6f676c6503636f6d0000010001c00c00010001000000430004d83ad54e"));
+
+    assertEquals(Collections.singletonList(InetAddress.getByName("216.58.213.78")), encoded);
+  }
+
+  @Test public void testGoogleDotComDecodingFromGoogle() throws Exception {
+    List<InetAddress> decoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c0005000100000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c042000100010000003b00049df00112"));
+
+    assertEquals(Collections.singletonList(InetAddress.getByName("157.240.1.18")), decoded);
+  }
+
+  @Test public void testGoogleDotComDecodingFromGoogleIPv6() throws Exception {
+    List<InetAddress> decoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d00001c0001c00c0005000100000a1b000603617069c012c0300005000100000b1f000c04737461720463313072c012c042001c00010000003b00102a032880f0290011faceb00c00000002"));
+
+    assertEquals(
+        Collections.singletonList(InetAddress.getByName("2a03:2880:f029:11:face:b00c:0:2")),
+        decoded);
+  }
+
+  @Test public void testGoogleDotComDecodingNxdomainFailure() throws Exception {
+    try {
+      DnsRecordCodec.decodeAnswers("sdflkhfsdlkjdf.ee", ByteString.decodeHex(
+          "0000818300010000000100000e7364666c6b686673646c6b6a64660265650000010001c01b00060001000007070038026e7303746c64c01b0a686f73746d61737465720d6565737469696e7465726e6574c01b5adb12c100000e10000003840012750000000e10"));
+      fail();
+    } catch (UnknownHostException uhe) {
+      assertEquals("sdflkhfsdlkjdf.ee: NXDOMAIN", uhe.getMessage());
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java
new file mode 100644
index 0000000000..301eee57ca
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.List;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+
+/**
+ * Temporary registry of known DNS over HTTPS providers.
+ *
+ * https://github.com/curl/curl/wiki/DNS-over-HTTPS
+ */
+public class DohProviders {
+  static DnsOverHttps buildGoogle(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://dns.google.com/experimental"))
+        .bootstrapDnsHosts(getByIp("216.58.204.78"), getByIp("2a00:1450:4009:814:0:0:0:200e"))
+        .build();
+  }
+
+  static DnsOverHttps buildGooglePost(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://dns.google.com/experimental"))
+        .bootstrapDnsHosts(getByIp("216.58.204.78"), getByIp("2a00:1450:4009:814:0:0:0:200e"))
+        .post(true)
+        .build();
+  }
+
+  static DnsOverHttps buildCloudflareIp(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://1.1.1.1/dns-query"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  static DnsOverHttps buildCloudflare(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://cloudflare-dns.com/dns-query"))
+        .bootstrapDnsHosts(getByIp("1.1.1.1"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  static DnsOverHttps buildCloudflarePost(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://cloudflare-dns.com/dns-query"))
+        .bootstrapDnsHosts(getByIp("104.16.111.25"), getByIp("104.16.112.25"),
+            getByIp("2400:cb00:2048:1:0:0:6810:7019"), getByIp("2400:cb00:2048:1:0:0:6810:6f19"))
+        .includeIPv6(false)
+        .post(true)
+        .build();
+  }
+
+  static DnsOverHttps buildCleanBrowsing(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://doh.cleanbrowsing.org/doh/family-filter/"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  static DnsOverHttps buildChantra(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://dns.dnsoverhttps.net/dns-query"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  static DnsOverHttps buildCryptoSx(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://doh.crypto.sx/dns-query"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  public static List<DnsOverHttps> providers(OkHttpClient client, boolean http2Only,
+      boolean workingOnly, boolean getOnly) {
+
+    List<DnsOverHttps> result = new ArrayList<>();
+
+    result.add(buildGoogle(client));
+    if (!getOnly) {
+      result.add(buildGooglePost(client));
+    }
+    result.add(buildCloudflare(client));
+    result.add(buildCloudflareIp(client));
+    if (!getOnly) {
+      result.add(buildCloudflarePost(client));
+    }
+    if (!workingOnly) {
+      //result.add(buildCleanBrowsing(client)); // timeouts
+      result.add(buildCryptoSx(client)); // 521 - server down
+    }
+    result.add(buildChantra(client));
+
+    return result;
+  }
+
+  private static InetAddress getByIp(String host) {
+    try {
+      return InetAddress.getByName(host);
+    } catch (UnknownHostException e) {
+      // unlikely
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
new file mode 100644
index 0000000000..65975ae5cc
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.Security;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import okhttp3.Cache;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+
+public class TestDohMain {
+  public static void main(String[] args) throws IOException {
+    Security.insertProviderAt(new org.conscrypt.OpenSSLProvider(), 1);
+
+    OkHttpClient bootstrapClient = new OkHttpClient.Builder().build();
+
+    List<String> names = Arrays.asList("google.com", "graph.facebook.com", "sdflkhfsdlkjdf.ee");
+
+    try {
+      System.out.println("uncached\n********\n");
+      List<DnsOverHttps> dnsProviders =
+          DohProviders.providers(bootstrapClient, false, false, false);
+      runBatch(dnsProviders, names);
+
+      Cache dnsCache =
+          new Cache(new File("./target/TestDohMain.cache." + System.currentTimeMillis()),
+              10 * 1024 * 1024);
+
+      System.out.println("Bad targets\n***********\n");
+
+      HttpUrl url = HttpUrl.get("https://dns.cloudflare.com/.not-so-well-known/run-dmc-query");
+      List<DnsOverHttps> badProviders = Collections.singletonList(
+          new DnsOverHttps.Builder().client(bootstrapClient).url(url).post(true).build());
+      runBatch(badProviders, names);
+
+      System.out.println("cached first run\n****************\n");
+      names = Arrays.asList("google.com", "graph.facebook.com");
+      bootstrapClient = bootstrapClient.newBuilder().cache(dnsCache).build();
+      dnsProviders = DohProviders.providers(bootstrapClient, true, true, true);
+      runBatch(dnsProviders, names);
+
+      System.out.println("cached second run\n*****************\n");
+      dnsProviders = DohProviders.providers(bootstrapClient, true, true, true);
+      runBatch(dnsProviders, names);
+    } finally {
+      bootstrapClient.connectionPool().evictAll();
+      bootstrapClient.dispatcher().executorService().shutdownNow();
+      Cache cache = bootstrapClient.cache();
+      if (cache != null) {
+        cache.close();
+      }
+    }
+  }
+
+  private static void runBatch(List<DnsOverHttps> dnsProviders, List<String> names) {
+    long time = System.currentTimeMillis();
+
+    for (DnsOverHttps dns : dnsProviders) {
+      System.out.println("Testing " + dns.url());
+
+      for (String host : names) {
+        System.out.print(host + ": ");
+        System.out.flush();
+
+        try {
+          List<InetAddress> results = dns.lookup(host);
+          System.out.println(results);
+        } catch (UnknownHostException uhe) {
+          Throwable e = uhe;
+
+          while (e != null) {
+            System.out.println(e.toString());
+
+            e = e.getCause();
+          }
+        }
+      }
+
+      System.out.println();
+    }
+
+    time = System.currentTimeMillis() - time;
+
+    System.out.println("Time: " + (((double) time) / 1000) + " seconds\n");
+  }
+}
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
index f312938fd1..fae2f6e6ca 100644
--- a/okhttp-logging-interceptor/README.md
+++ b/okhttp-logging-interceptor/README.md
@@ -11,7 +11,7 @@ OkHttpClient client = new OkHttpClient.Builder()
   .build();
 ```
 
-You can change the log level at any time by calling `setLevel`.
+You can change the log level at any time by calling `setLevel()`.
 
 To log to a custom location, pass a `Logger` instance to the constructor.
 ```java
@@ -22,11 +22,16 @@ HttpLoggingInterceptor logging = new HttpLoggingInterceptor(new Logger() {
 });
 ```
 
-**Warning**: The logs generated by this interceptor when using the `HEADERS` or `BODY` levels has
+**Warning**: The logs generated by this interceptor when using the `HEADERS` or `BODY` levels have
 the potential to leak sensitive information such as "Authorization" or "Cookie" headers and the
 contents of request and response bodies. This data should only be logged in a controlled way or in
 a non-production environment.
 
+You can redact headers that may contain sensitive information by calling `redactHeader()`.
+```java
+logging.redactHeader("Authorization");
+logging.redactHeader("Cookie");
+```
 
 Download
 --------
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
index ce35ec3329..cff9ce9147 100644
--- a/okhttp-logging-interceptor/pom.xml
+++ b/okhttp-logging-interceptor/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.10.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>logging-interceptor</artifactId>
@@ -41,6 +41,12 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 
   <build>
@@ -48,6 +54,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
index e088ea7c64..c6acbccf1e 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
@@ -18,6 +18,9 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.nio.charset.Charset;
+import java.util.Collections;
+import java.util.Set;
+import java.util.TreeSet;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Connection;
 import okhttp3.Headers;
@@ -123,6 +126,15 @@ public HttpLoggingInterceptor(Logger logger) {
 
   private final Logger logger;
 
+  private volatile Set<String> headersToRedact = Collections.emptySet();
+
+  public void redactHeader(String name) {
+    Set<String> newHeadersToRedact = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
+    newHeadersToRedact.addAll(headersToRedact);
+    newHeadersToRedact.add(name);
+    headersToRedact = newHeadersToRedact;
+  }
+
   private volatile Level level = Level.NONE;
 
   /** Change the level at which this interceptor logs. */
@@ -177,7 +189,7 @@ public Level getLevel() {
         String name = headers.name(i);
         // Skip headers from the request body as they are explicitly logged above.
         if (!"Content-Type".equalsIgnoreCase(name) && !"Content-Length".equalsIgnoreCase(name)) {
-          logger.log(name + ": " + headers.value(i));
+          logHeader(headers, i);
         }
       }
 
@@ -229,7 +241,7 @@ public Level getLevel() {
     if (logHeaders) {
       Headers headers = response.headers();
       for (int i = 0, count = headers.size(); i < count; i++) {
-        logger.log(headers.name(i) + ": " + headers.value(i));
+        logHeader(headers, i);
       }
 
       if (!logBody || !HttpHeaders.hasBody(response)) {
@@ -285,6 +297,11 @@ public Level getLevel() {
     return response;
   }
 
+  private void logHeader(Headers headers, int i) {
+    String value = headersToRedact.contains(headers.name(i)) ? "██" : headers.value(i);
+    logger.log(headers.name(i) + ": " + value);
+  }
+
   /**
    * Returns true if the body in question probably contains human readable text. Uses a small sample
    * of code points to detect unicode control characters commonly used in binary file signatures.
@@ -309,7 +326,7 @@ static boolean isPlaintext(Buffer buffer) {
     }
   }
 
-  private boolean bodyHasUnknownEncoding(Headers headers) {
+  private static boolean bodyHasUnknownEncoding(Headers headers) {
     String contentEncoding = headers.get("Content-Encoding");
     return contentEncoding != null
         && !contentEncoding.equalsIgnoreCase("identity")
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.java
new file mode 100644
index 0000000000..da38261bfb
--- /dev/null
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.java
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.Call;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.Handshake;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+
+/**
+ * An OkHttp EventListener, which logs call events. Can be applied as an
+ * {@linkplain OkHttpClient#eventListenerFactory() event listener factory}.
+ *
+ * <p>The format of the logs created by this class should not be considered stable and may change
+ * slightly between releases. If you need a stable logging format, use your own event listener.
+ */
+public final class LoggingEventListener extends EventListener {
+  private final HttpLoggingInterceptor.Logger logger;
+  private long startNs;
+
+  private LoggingEventListener(HttpLoggingInterceptor.Logger logger) {
+    this.logger = logger;
+  }
+
+  @Override
+  public void callStart(Call call) {
+    startNs = System.nanoTime();
+
+    logWithTime("callStart: " + call.request());
+  }
+
+  @Override
+  public void dnsStart(Call call, String domainName) {
+    logWithTime("dnsStart: " + domainName);
+  }
+
+  @Override
+  public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+    logWithTime("dnsEnd: " + inetAddressList);
+  }
+
+  @Override
+  public void connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+    logWithTime("connectStart: " + inetSocketAddress + " " + proxy);
+  }
+
+  @Override
+  public void secureConnectStart(Call call) {
+    logWithTime("secureConnectStart");
+  }
+
+  @Override
+  public void secureConnectEnd(Call call, @Nullable Handshake handshake) {
+    logWithTime("secureConnectEnd: " + handshake);
+  }
+
+  @Override
+  public void connectEnd(
+      Call call, InetSocketAddress inetSocketAddress, Proxy proxy, @Nullable Protocol protocol) {
+    logWithTime("connectEnd: " + protocol);
+  }
+
+  @Override
+  public void connectFailed(
+      Call call,
+      InetSocketAddress inetSocketAddress,
+      Proxy proxy,
+      @Nullable Protocol protocol,
+      IOException ioe) {
+    logWithTime("connectFailed: " + protocol + " " + ioe);
+  }
+
+  @Override
+  public void connectionAcquired(Call call, Connection connection) {
+    logWithTime("connectionAcquired: " + connection);
+  }
+
+  @Override
+  public void connectionReleased(Call call, Connection connection) {
+    logWithTime("connectionReleased");
+  }
+
+  @Override
+  public void requestHeadersStart(Call call) {
+    logWithTime("requestHeadersStart");
+  }
+
+  @Override
+  public void requestHeadersEnd(Call call, Request request) {
+    logWithTime("requestHeadersEnd");
+  }
+
+  @Override
+  public void requestBodyStart(Call call) {
+    logWithTime("requestBodyStart");
+  }
+
+  @Override
+  public void requestBodyEnd(Call call, long byteCount) {
+    logWithTime("requestBodyEnd: byteCount=" + byteCount);
+  }
+
+  @Override
+  public void responseHeadersStart(Call call) {
+    logWithTime("responseHeadersStart");
+  }
+
+  @Override
+  public void responseHeadersEnd(Call call, Response response) {
+    logWithTime("responseHeadersEnd: " + response);
+  }
+
+  @Override
+  public void responseBodyStart(Call call) {
+    logWithTime("responseBodyStart");
+  }
+
+  @Override
+  public void responseBodyEnd(Call call, long byteCount) {
+    logWithTime("responseBodyEnd: byteCount=" + byteCount);
+  }
+
+  @Override
+  public void callEnd(Call call) {
+    logWithTime("callEnd");
+  }
+
+  @Override
+  public void callFailed(Call call, IOException ioe) {
+    logWithTime("callFailed: " + ioe);
+  }
+
+  private void logWithTime(String message) {
+    long timeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);
+    logger.log("[" + timeMs + " ms] " + message);
+  }
+
+  public static class Factory implements EventListener.Factory {
+    private final HttpLoggingInterceptor.Logger logger;
+
+    public Factory() {
+      this(HttpLoggingInterceptor.Logger.DEFAULT);
+    }
+
+    public Factory(HttpLoggingInterceptor.Logger logger) {
+      this.logger = logger;
+    }
+
+    @Override
+    public EventListener create(Call call) {
+      return new LoggingEventListener(logger);
+    }
+  }
+}
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
index 39904701cf..62d0ff5761 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
@@ -1,3 +1,3 @@
 /** An OkHttp interceptor which logs HTTP request and response data. */
-@javax.annotation.ParametersAreNonnullByDefault
+@okhttp3.internal.annotations.EverythingIsNonNull
 package okhttp3.logging;
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index 613aed1341..6fd53f7753 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -19,6 +19,7 @@
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import java.util.regex.Pattern;
 import javax.net.ssl.HostnameVerifier;
@@ -32,10 +33,10 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okhttp3.logging.HttpLoggingInterceptor.Level;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
@@ -44,6 +45,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.hamcrest.CoreMatchers.equalTo;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -53,12 +55,12 @@
 import static org.junit.Assume.assumeThat;
 
 public final class HttpLoggingInterceptorTest {
-  private static final MediaType PLAIN = MediaType.parse("text/plain; charset=utf-8");
+  private static final MediaType PLAIN = MediaType.get("text/plain; charset=utf-8");
 
   @Rule public final MockWebServer server = new MockWebServer();
 
-  private SslClient sslClient = SslClient.localhost();
-  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+  private final HandshakeCertificates handshakeCertificates = localhost();
+  private final HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private OkHttpClient client;
   private String host;
   private HttpUrl url;
@@ -80,7 +82,8 @@ private void setLevel(Level level) {
     client = new OkHttpClient.Builder()
         .addNetworkInterceptor(networkInterceptor)
         .addInterceptor(applicationInterceptor)
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build();
 
@@ -647,7 +650,7 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
   }
 
-  @Test public void isPlaintext() throws IOException {
+  @Test public void isPlaintext() {
     assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer()));
     assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("abc")));
     assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("new\r\nlines")));
@@ -723,7 +726,7 @@ private void bodyGetNoBody(int code) throws IOException {
   }
 
   @Test public void http2() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     url = server.url("/");
 
     setLevel(Level.BASIC);
@@ -743,11 +746,68 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
   }
 
+  @Test
+  public void headersAreRedacted() throws Exception {
+    HttpLoggingInterceptor networkInterceptor =
+        new HttpLoggingInterceptor(networkLogs).setLevel(Level.HEADERS);
+    networkInterceptor.redactHeader("sEnSiTiVe");
+
+    HttpLoggingInterceptor applicationInterceptor =
+        new HttpLoggingInterceptor(applicationLogs).setLevel(Level.HEADERS);
+    applicationInterceptor.redactHeader("sEnSiTiVe");
+
+    client =
+        new OkHttpClient.Builder()
+            .addNetworkInterceptor(networkInterceptor)
+            .addInterceptor(applicationInterceptor)
+            .build();
+
+    server.enqueue(
+        new MockResponse().addHeader("SeNsItIvE", "Value").addHeader("Not-Sensitive", "Value"));
+    Response response =
+        client
+            .newCall(
+                request()
+                    .addHeader("SeNsItIvE", "Value")
+                    .addHeader("Not-Sensitive", "Value")
+                    .build())
+            .execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogEqual("SeNsItIvE: ██")
+        .assertLogEqual("Not-Sensitive: Value")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("SeNsItIvE: ██")
+        .assertLogEqual("Not-Sensitive: Value")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("SeNsItIvE: ██")
+        .assertLogEqual("Not-Sensitive: Value")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("SeNsItIvE: ██")
+        .assertLogEqual("Not-Sensitive: Value")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
   private Request.Builder request() {
     return new Request.Builder().url(url);
   }
 
-  private static class LogRecorder implements HttpLoggingInterceptor.Logger {
+  static class LogRecorder implements HttpLoggingInterceptor.Logger {
     private final List<String> logs = new ArrayList<>();
     private int index;
 
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
new file mode 100644
index 0000000000..c7ead4bbf6
--- /dev/null
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.List;
+import okhttp3.Dns;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.fail;
+
+public final class LoggingEventListenerTest {
+  private static final MediaType PLAIN = MediaType.get("text/plain");
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final HandshakeCertificates handshakeCertificates = localhost();
+  private final LogRecorder logRecorder = new LogRecorder();
+  private final LoggingEventListener.Factory loggingEventListenerFactory =
+      new LoggingEventListener.Factory(logRecorder);
+  private OkHttpClient client;
+  private HttpUrl url;
+
+  @Before
+  public void setUp() {
+    client =
+        new OkHttpClient.Builder()
+            .eventListenerFactory(loggingEventListenerFactory)
+            .sslSocketFactory(
+                handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+            .retryOnConnectionFailure(false)
+            .build();
+
+    url = server.url("/");
+  }
+
+  @Test
+  public void get() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hello!").setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    assertNotNull(response.body());
+    response.body().bytes();
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("dnsEnd: \\[.+\\]")
+        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
+        .assertLogMatch("connectEnd: http/1.1")
+        .assertLogMatch(
+            "connectionAcquired: Connection\\{"
+                + url.host()
+                + ":\\d+, proxy=DIRECT hostAddress="
+                + url.host()
+                + "/.+ cipherSuite=none protocol=http/1\\.1\\}")
+        .assertLogMatch("requestHeadersStart")
+        .assertLogMatch("requestHeadersEnd")
+        .assertLogMatch("responseHeadersStart")
+        .assertLogMatch(
+            "responseHeadersEnd: Response\\{protocol=http/1\\.1, code=200, message=OK, url="
+                + url
+                + "}")
+        .assertLogMatch("responseBodyStart")
+        .assertLogMatch("responseBodyEnd: byteCount=6")
+        .assertLogMatch("connectionReleased")
+        .assertLogMatch("callEnd")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void post() throws IOException {
+    server.enqueue(new MockResponse());
+    client.newCall(request().post(RequestBody.create(PLAIN, "Hello!")).build()).execute();
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=POST, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("dnsEnd: \\[.+\\]")
+        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
+        .assertLogMatch("connectEnd: http/1.1")
+        .assertLogMatch(
+            "connectionAcquired: Connection\\{"
+                + url.host()
+                + ":\\d+, proxy=DIRECT hostAddress="
+                + url.host()
+                + "/.+ cipherSuite=none protocol=http/1\\.1\\}")
+        .assertLogMatch("requestHeadersStart")
+        .assertLogMatch("requestHeadersEnd")
+        .assertLogMatch("requestBodyStart")
+        .assertLogMatch("requestBodyEnd: byteCount=6")
+        .assertLogMatch("responseHeadersStart")
+        .assertLogMatch(
+            "responseHeadersEnd: Response\\{protocol=http/1\\.1, code=200, message=OK, url="
+                + url
+                + "}")
+        .assertLogMatch("responseBodyStart")
+        .assertLogMatch("responseBodyEnd: byteCount=0")
+        .assertLogMatch("connectionReleased")
+        .assertLogMatch("callEnd")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void secureGet() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    url = server.url("/");
+
+    server.enqueue(new MockResponse());
+    Response response = client.newCall(request().build()).execute();
+    assertNotNull(response.body());
+    response.body().bytes();
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("dnsEnd: \\[.+\\]")
+        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
+        .assertLogMatch("secureConnectStart")
+        .assertLogMatch("secureConnectEnd: Handshake\\{"
+            + "tlsVersion=TLS_1_2 "
+            + "cipherSuite=TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 "
+            + "peerCertificates=\\[CN=localhost\\] "
+            + "localCertificates=\\[\\]}")
+        .assertLogMatch("connectEnd: h2")
+        .assertLogMatch(
+            "connectionAcquired: Connection\\{"
+                + url.host()
+                + ":\\d+, proxy=DIRECT hostAddress="
+                + url.host()
+                + "/.+ cipherSuite=.+ protocol=h2}")
+        .assertLogMatch("requestHeadersStart")
+        .assertLogMatch("requestHeadersEnd")
+        .assertLogMatch("responseHeadersStart")
+        .assertLogMatch(
+            "responseHeadersEnd: Response\\{protocol=h2, code=200, message=, url=" + url + "}")
+        .assertLogMatch("responseBodyStart")
+        .assertLogMatch("responseBodyEnd: byteCount=0")
+        .assertLogMatch("connectionReleased")
+        .assertLogMatch("callEnd")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void dnsFail() throws IOException {
+    client =
+        new OkHttpClient.Builder()
+            .dns(
+                new Dns() {
+                  @Override
+                  public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+                    throw new UnknownHostException("reason");
+                  }
+                })
+            .eventListenerFactory(loggingEventListenerFactory)
+            .build();
+
+    try {
+      client.newCall(request().build()).execute();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("callFailed: java.net.UnknownHostException: reason")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void connectFail() {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    url = server.url("/");
+
+    try {
+      client.newCall(request().build()).execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("dnsEnd: \\[.+\\]")
+        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
+        .assertLogMatch("secureConnectStart")
+        .assertLogMatch(
+            "connectFailed: null javax\\.net\\.ssl\\.SSLProtocolException: Handshake message sequence violation, 1")
+        .assertLogMatch(
+            "callFailed: javax.net.ssl.SSLProtocolException: Handshake message sequence violation, 1")
+        .assertNoMoreLogs();
+  }
+
+  private Request.Builder request() {
+    return new Request.Builder().url(url);
+  }
+
+  private static class LogRecorder extends HttpLoggingInterceptorTest.LogRecorder {
+    LogRecorder assertLogMatch(String pattern) {
+      return (LogRecorder) super.assertLogMatch("\\[\\d+ ms] " + pattern);
+    }
+  }
+}
diff --git a/okhttp-sse/README.md b/okhttp-sse/README.md
new file mode 100644
index 0000000000..2b1bc42830
--- /dev/null
+++ b/okhttp-sse/README.md
@@ -0,0 +1,5 @@
+OkHttp Server-Sent Events
+=========================
+
+Experimental support for server-sent events.
+API is not considered stable and may change at any time.
diff --git a/okhttp-sse/pom.xml b/okhttp-sse/pom.xml
new file mode 100644
index 0000000000..110c3a4456
--- /dev/null
+++ b/okhttp-sse/pom.xml
@@ -0,0 +1,78 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.13.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-sse</artifactId>
+  <name>OkHttp Server-Sent Events</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
+        <configuration>
+          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+          </links>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.sse</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java
new file mode 100644
index 0000000000..c49e49f4aa
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.EventListener;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Util;
+import okhttp3.sse.EventSource;
+import okhttp3.sse.EventSourceListener;
+
+public final class RealEventSource
+    implements EventSource, ServerSentEventReader.Callback, Callback {
+
+  private final Request request;
+  private final EventSourceListener listener;
+
+  private @Nullable Call call;
+
+  public RealEventSource(Request request, EventSourceListener listener) {
+    this.request = request;
+    this.listener = listener;
+  }
+
+  public void connect(OkHttpClient client) {
+    client = client.newBuilder()
+        .eventListener(EventListener.NONE)
+        .build();
+    call = client.newCall(request);
+    call.timeout().clearTimeout();
+    call.enqueue(this);
+  }
+
+  @Override public void onResponse(Call call, Response response) {
+    processResponse(response);
+  }
+
+  public void processResponse(Response response) {
+    try {
+      if (!response.isSuccessful()) {
+        listener.onFailure(this, null, response);
+        return;
+      }
+
+      ResponseBody body = response.body();
+
+      //noinspection ConstantConditions main body is never null
+      MediaType contentType = body.contentType();
+      if (!isEventStream(contentType)) {
+        listener.onFailure(this,
+            new IllegalStateException("Invalid content-type: " + contentType), response);
+        return;
+      }
+
+      // Replace the body with an empty one so the callbacks can't see real data.
+      response = response.newBuilder().body(Util.EMPTY_RESPONSE).build();
+
+      ServerSentEventReader reader = new ServerSentEventReader(body.source(), this);
+      try {
+        listener.onOpen(this, response);
+        while (reader.processNextEvent()) {
+        }
+      } catch (Exception e) {
+        listener.onFailure(this, e, response);
+        return;
+      }
+
+      listener.onClosed(this);
+    } finally {
+      response.close();
+    }
+  }
+
+  private static boolean isEventStream(@Nullable MediaType contentType) {
+    return contentType != null && contentType.type().equals("text") && contentType.subtype()
+        .equals("event-stream");
+  }
+
+  @Override public void onFailure(Call call, IOException e) {
+    listener.onFailure(this, e, null);
+  }
+
+  @Override public Request request() {
+    return request;
+  }
+
+  @Override public void cancel() {
+    call.cancel();
+  }
+
+  @Override public void onEvent(@Nullable String id, @Nullable String type, String data) {
+    listener.onEvent(this, id, type, data);
+  }
+
+  @Override public void onRetryChange(long timeMs) {
+    // Ignored. We do not auto-retry.
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
new file mode 100644
index 0000000000..0e0e775fb6
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+
+public final class ServerSentEventReader {
+  private static final ByteString CRLF = ByteString.encodeUtf8("\r\n");
+  private static final ByteString DATA = ByteString.encodeUtf8("data");
+  private static final ByteString ID = ByteString.encodeUtf8("id");
+  private static final ByteString EVENT = ByteString.encodeUtf8("event");
+  private static final ByteString RETRY = ByteString.encodeUtf8("retry");
+
+  public interface Callback {
+    void onEvent(@Nullable String id, @Nullable String type, String data);
+    void onRetryChange(long timeMs);
+  }
+
+  private final BufferedSource source;
+  private final Callback callback;
+
+  private String lastId = null;
+
+  public ServerSentEventReader(BufferedSource source, Callback callback) {
+    if (source == null) throw new NullPointerException("source == null");
+    if (callback == null) throw new NullPointerException("callback == null");
+    this.source = source;
+    this.callback = callback;
+  }
+
+  /**
+   * Process the next event. This will result in a single call to {@link Callback#onEvent}
+   * <em>unless</em> the data section was empty. Any number of calls to
+   * {@link Callback#onRetryChange} may occur while processing an event.
+   *
+   * @return false when EOF is reached
+   */
+  boolean processNextEvent() throws IOException {
+    String id = lastId;
+    String type = null;
+    Buffer data = new Buffer();
+
+    while (true) {
+      long lineEnd = source.indexOfElement(CRLF);
+      if (lineEnd == -1L) {
+        return false;
+      }
+
+      switch (source.buffer().getByte(0)) {
+        case '\r':
+        case '\n':
+          completeEvent(id, type, data);
+          return true;
+
+        case 'd':
+          if (isKey(DATA)) {
+            parseData(data, lineEnd);
+            continue;
+          }
+          break;
+
+        case 'e':
+          if (isKey(EVENT)) {
+            type = parseEvent(lineEnd);
+            continue;
+          }
+          break;
+
+        case 'i':
+          if (isKey(ID)) {
+            id = parseId(lineEnd);
+            continue;
+          }
+          break;
+
+        case 'r':
+          if (isKey(RETRY)) {
+            parseRetry(lineEnd);
+            continue;
+          }
+          break;
+      }
+
+      source.skip(lineEnd);
+      skipCrAndOrLf();
+    }
+  }
+
+  private void completeEvent(String id, String type, Buffer data) throws IOException {
+    skipCrAndOrLf();
+
+    if (data.size() != 0L) {
+      lastId = id;
+      data.skip(1L); // Leading newline.
+      callback.onEvent(id, type, data.readUtf8());
+    }
+  }
+
+  private void parseData(Buffer data, long end) throws IOException {
+    data.writeByte('\n');
+    end -= skipNameAndDivider(4L);
+    source.readFully(data, end);
+    skipCrAndOrLf();
+  }
+
+  private String parseEvent(long end) throws IOException {
+    String type = null;
+    end -= skipNameAndDivider(5L);
+    if (end != 0L) {
+      type = source.readUtf8(end);
+    }
+    skipCrAndOrLf();
+    return type;
+  }
+
+  private String parseId(long end) throws IOException {
+    String id;
+    end -= skipNameAndDivider(2L);
+    if (end != 0L) {
+      id = source.readUtf8(end);
+    } else {
+      id = null;
+    }
+    skipCrAndOrLf();
+    return id;
+  }
+
+  private void parseRetry(long end) throws IOException {
+    end -= skipNameAndDivider(5L);
+    String retryString = source.readUtf8(end);
+    long retryMs = -1L;
+    try {
+      retryMs = Long.parseLong(retryString);
+    } catch (NumberFormatException ignored) {
+    }
+    if (retryMs != -1L) {
+      callback.onRetryChange(retryMs);
+    }
+    skipCrAndOrLf();
+  }
+
+  /**
+   * Returns true if the first bytes of {@link #source} are {@code key} followed by a colon or
+   * a newline.
+   */
+  private boolean isKey(ByteString key) throws IOException {
+    if (source.rangeEquals(0, key)) {
+      byte nextByte = source.buffer().getByte(key.size());
+      return nextByte == ':'
+          || nextByte == '\r'
+          || nextByte == '\n';
+    }
+    return false;
+  }
+
+  /** Consumes {@code \r}, {@code \r\n}, or {@code \n} from {@link #source}. */
+  private void skipCrAndOrLf() throws IOException {
+    if ((source.readByte() & 0xff) == '\r'
+        && source.request(1)
+        && source.buffer().getByte(0) == '\n') {
+      source.skip(1);
+    }
+  }
+
+  /**
+   * Consumes the field name of the specified length and the optional colon and its optional
+   * trailing space. Returns the number of bytes skipped.
+   */
+  private long skipNameAndDivider(long length) throws IOException {
+    source.skip(length);
+
+    if (source.buffer().getByte(0) == ':') {
+      source.skip(1L);
+      length++;
+
+      if (source.buffer().getByte(0) == ' ') {
+        source.skip(1);
+        length++;
+      }
+    }
+
+    return length;
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java
new file mode 100644
index 0000000000..afcf5f4f9d
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java
@@ -0,0 +1,3 @@
+/** Private support classes for server-sent events. */
+@okhttp3.internal.annotations.EverythingIsNonNull
+package okhttp3.internal.sse;
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java
new file mode 100644
index 0000000000..fe703dc8c0
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.sse;
+
+import okhttp3.Request;
+
+public interface EventSource {
+  /** Returns the original request that initiated this event source. */
+  Request request();
+
+  /**
+   * Immediately and violently release resources held by this event source. This does nothing if
+   * the event source has already been closed or canceled.
+   */
+  void cancel();
+
+  interface Factory {
+    /**
+     * Creates a new event source and immediately returns it. Creating an event source initiates an
+     * asynchronous process to connect the socket. Once that succeeds or fails, {@code listener}
+     * will be notified. The caller must cancel the returned event source when it is no longer
+     * in use.
+     */
+    EventSource newEventSource(Request request, EventSourceListener listener);
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java
new file mode 100644
index 0000000000..4246625eca
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.sse;
+
+import javax.annotation.Nullable;
+import okhttp3.Response;
+
+public abstract class EventSourceListener {
+  /**
+   * Invoked when an event source has been accepted by the remote peer and may begin transmitting
+   * events.
+   */
+  public void onOpen(EventSource eventSource, Response response) {
+  }
+
+  /**
+   * TODO description.
+   */
+  public void onEvent(EventSource eventSource, @Nullable String id, @Nullable String type,
+      String data) {
+  }
+
+  /**
+   * TODO description.
+   * No further calls to this listener will be made.
+   */
+  public void onClosed(EventSource eventSource) {
+  }
+
+  /**
+   * Invoked when an event source has been closed due to an error reading from or writing to the
+   * network. Incoming events may have been lost. No further calls to this listener will be made.
+   */
+  public void onFailure(EventSource eventSource, @Nullable Throwable t,
+      @Nullable Response response) {
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java
new file mode 100644
index 0000000000..77f596c5f2
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.sse;
+
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.sse.RealEventSource;
+
+public final class EventSources {
+  public static EventSource.Factory createFactory(final OkHttpClient client) {
+    return new EventSource.Factory() {
+      @Override public EventSource newEventSource(Request request, EventSourceListener listener) {
+        RealEventSource eventSource = new RealEventSource(request, listener);
+        eventSource.connect(client);
+        return eventSource;
+      }
+    };
+  }
+
+  public static void processResponse(Response response, EventSourceListener listener) {
+    RealEventSource eventSource = new RealEventSource(response.request(), listener);
+    eventSource.processResponse(response);
+  }
+
+  private EventSources() {
+    throw new AssertionError();
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/package-info.java b/okhttp-sse/src/main/java/okhttp3/sse/package-info.java
new file mode 100644
index 0000000000..2a5f883883
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/package-info.java
@@ -0,0 +1,3 @@
+/** Support for server-sent events. */
+@okhttp3.internal.annotations.EverythingIsNonNull
+package okhttp3.sse;
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
new file mode 100644
index 0000000000..149be0014c
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import javax.annotation.Nullable;
+
+final class Event {
+  final @Nullable String id;
+  final @Nullable String type;
+  final String data;
+
+  Event(@Nullable String id, @Nullable String type, String data) {
+    if (data == null) throw new NullPointerException("data == null");
+    this.id = id;
+    this.type = type;
+    this.data = data;
+  }
+
+  @Override public String toString() {
+    return "Event{id='" + id + "', type='" + type + "', data='" + data + "'}";
+  }
+
+  @Override public boolean equals(Object o) {
+    if (this == o) return true;
+    if (!(o instanceof Event)) return false;
+    Event other = (Event) o;
+    return (id != null ? id.equals(other.id) : other.id == null)
+        && (type != null ? type.equals(other.type) : other.type == null)
+        && data.equals(other.data);
+  }
+
+  @Override public int hashCode() {
+    int result = (id != null ? id.hashCode() : 0);
+    result = 31 * result + (type != null ? type.hashCode() : 0);
+    result = 31 * result + data.hashCode();
+    return result;
+  }
+}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
new file mode 100644
index 0000000000..7f576eece9
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.util.concurrent.TimeUnit;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.sse.EventSource;
+import okhttp3.sse.EventSources;
+import org.junit.After;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+
+public final class EventSourceHttpTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final EventSourceRecorder listener = new EventSourceRecorder();
+  private OkHttpClient client = defaultClient();
+
+  @After public void after() {
+    listener.assertExhausted();
+  }
+
+  @Test public void event() {
+    server.enqueue(new MockResponse().setBody(""
+        + "data: hey\n"
+        + "\n").setHeader("content-type", "text/event-stream"));
+
+    EventSource source = newEventSource();
+
+    assertEquals("/", source.request().url().encodedPath());
+
+    listener.assertOpen();
+    listener.assertEvent(null, null, "hey");
+    listener.assertClose();
+  }
+
+  @Test public void badContentType() {
+    server.enqueue(new MockResponse().setBody(""
+        + "data: hey\n"
+        + "\n").setHeader("content-type", "text/plain"));
+
+    EventSource source = newEventSource();
+    listener.assertFailure("Invalid content-type: text/plain");
+  }
+
+  @Test public void badResponseCode() {
+    server.enqueue(new MockResponse().setBody(""
+        + "data: hey\n"
+        + "\n").setHeader("content-type", "text/event-stream").setResponseCode(401));
+
+    EventSource source = newEventSource();
+    listener.assertFailure(null);
+  }
+
+  @Test public void callTimeoutIsNotApplied() throws Exception {
+    client = client.newBuilder()
+        .callTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setBodyDelay(500, TimeUnit.MILLISECONDS)
+        .setHeader("content-type", "text/event-stream")
+        .setBody("data: hey\n\n"));
+
+    EventSource source = newEventSource();
+
+    assertEquals("/", source.request().url().encodedPath());
+
+    listener.assertOpen();
+    listener.assertEvent(null, null, "hey");
+    listener.assertClose();
+  }
+
+  private EventSource newEventSource() {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    EventSource.Factory factory = EventSources.createFactory(client);
+    return factory.newEventSource(request, listener);
+  }
+}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
new file mode 100644
index 0000000000..cf4afd4ec9
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingDeque;
+import javax.annotation.Nullable;
+import okhttp3.sse.EventSource;
+import okhttp3.sse.EventSourceListener;
+import okhttp3.Response;
+import okhttp3.internal.platform.Platform;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+public final class EventSourceRecorder extends EventSourceListener {
+  private final BlockingQueue<Object> events = new LinkedBlockingDeque<>();
+
+  @Override public void onOpen(EventSource eventSource, Response response) {
+    Platform.get().log(Platform.INFO, "[ES] onOpen", null);
+    events.add(new Open(eventSource, response));
+  }
+
+  @Override public void onEvent(EventSource eventSource, @Nullable String id, @Nullable String type,
+      String data) {
+    Platform.get().log(Platform.INFO, "[ES] onEvent", null);
+    events.add(new Event(id, type, data));
+  }
+
+  @Override public void onClosed(EventSource eventSource) {
+    Platform.get().log(Platform.INFO, "[ES] onClosed", null);
+    events.add(new Closed());
+  }
+
+  @Override
+  public void onFailure(EventSource eventSource, @Nullable Throwable t, @Nullable Response response) {
+    Platform.get().log(Platform.INFO, "[ES] onFailure", t);
+    events.add(new Failure(t, response));
+  }
+
+  private Object nextEvent() {
+    try {
+      Object event = events.poll(10, SECONDS);
+      if (event == null) {
+        throw new AssertionError("Timed out waiting for event.");
+      }
+      return event;
+    } catch (InterruptedException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public void assertExhausted() {
+    assertTrue("Remaining events: " + events, events.isEmpty());
+  }
+
+  public void assertEvent(@Nullable String id, @Nullable String type, String data) {
+    Object actual = nextEvent();
+    assertEquals(new Event(id, type, data), actual);
+  }
+
+  public EventSource assertOpen() {
+    Object event = nextEvent();
+    if (!(event instanceof Open)) {
+      throw new AssertionError("Expected Open but was " + event);
+    }
+    return ((Open) event).eventSource;
+  }
+
+  public void assertClose() {
+    Object event = nextEvent();
+    if (!(event instanceof Closed)) {
+      throw new AssertionError("Expected Open but was " + event);
+    }
+  }
+
+  public void assertFailure(@Nullable String message) {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    if (message != null) {
+      assertEquals(message, ((Failure) event).t.getMessage());
+    } else {
+      assertNull(((Failure) event).t);
+    }
+  }
+
+  static final class Open {
+    final EventSource eventSource;
+    final Response response;
+
+    Open(EventSource eventSource, Response response) {
+      this.eventSource = eventSource;
+      this.response = response;
+    }
+
+    @Override public String toString() {
+      return "Open[" + response + ']';
+    }
+  }
+
+  static final class Failure {
+    final Throwable t;
+    final Response response;
+    final String responseBody;
+
+    Failure(Throwable t, Response response) {
+      this.t = t;
+      this.response = response;
+      String responseBody = null;
+      if (response != null) {
+        try {
+          responseBody = response.body().string();
+        } catch (IOException ignored) {
+        }
+      }
+      this.responseBody = responseBody;
+    }
+
+    @Override public String toString() {
+      if (response == null) {
+        return "Failure[" + t + "]";
+      }
+      return "Failure[" + response + "]";
+    }
+  }
+
+  static final class Closed {
+    @Override public String toString() {
+      return "Closed[]";
+    }
+  }
+}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
new file mode 100644
index 0000000000..697a2d2019
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import javax.annotation.Nullable;
+import okio.Buffer;
+import org.junit.After;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+public final class ServerSentEventIteratorTest {
+  /** Either {@link Event} or {@link Long} items for events and retry changes, respectively. */
+  private final Deque<Object> callbacks = new ArrayDeque<>();
+
+  @After public void after() {
+    assertTrue("Unconsumed events: " + callbacks, callbacks.isEmpty());
+  }
+  
+  @Test public void multiline() throws IOException {
+    consumeEvents(""
+        + "data: YHOO\n"
+        + "data: +2\n"
+        + "data: 10\n"
+        + "\n");
+    assertEquals(new Event(null, null, "YHOO\n+2\n10"), callbacks.remove());
+  }
+
+  @Test public void multilineCr() throws IOException {
+    consumeEvents(""
+        + "data: YHOO\r"
+        + "data: +2\r"
+        + "data: 10\r"
+        + "\r");
+    assertEquals(new Event(null, null, "YHOO\n+2\n10"), callbacks.remove());
+  }
+
+  @Test public void multilineCrLf() throws IOException {
+    consumeEvents(""
+        + "data: YHOO\r\n"
+        + "data: +2\r\n"
+        + "data: 10\r\n"
+        + "\r\n");
+    assertEquals(new Event(null, null, "YHOO\n+2\n10"), callbacks.remove());
+  }
+
+  @Test public void eventType() throws IOException {
+    consumeEvents(""
+        + "event: add\n"
+        + "data: 73857293\n"
+        + "\n"
+        + "event: remove\n"
+        + "data: 2153\n"
+        + "\n"
+        + "event: add\n"
+        + "data: 113411\n"
+        + "\n");
+    assertEquals(new Event(null, "add", "73857293"), callbacks.remove());
+    assertEquals(new Event(null, "remove", "2153"), callbacks.remove());
+    assertEquals(new Event(null, "add", "113411"), callbacks.remove());
+  }
+
+  @Test public void commentsIgnored() throws IOException {
+    consumeEvents(""
+        + ": test stream\n"
+        + "\n"
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n");
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+  }
+
+  @Test public void idCleared() throws IOException {
+    consumeEvents(""
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n"
+        + "data: second event\n"
+        + "id\n"
+        + "\n"
+        + "data: third event\n"
+        + "\n");
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+    assertEquals(new Event(null, null, "second event"), callbacks.remove());
+    assertEquals(new Event(null, null, "third event"), callbacks.remove());
+  }
+
+  @Test public void nakedFieldNames() throws IOException {
+    consumeEvents(""
+        + "data\n"
+        + "\n"
+        + "data\n"
+        + "data\n"
+        + "\n"
+        + "data:\n");
+    assertEquals(new Event(null, null, ""), callbacks.remove());
+    assertEquals(new Event(null, null, "\n"), callbacks.remove());
+  }
+
+  @Test public void colonSpaceOptional() throws IOException {
+    consumeEvents(""
+        + "data:test\n"
+        + "\n"
+        + "data: test\n"
+        + "\n");
+    assertEquals(new Event(null, null, "test"), callbacks.remove());
+    assertEquals(new Event(null, null, "test"), callbacks.remove());
+  }
+
+  @Test public void leadingWhitespace() throws IOException {
+    consumeEvents(""
+        + "data:  test\n"
+        + "\n");
+    assertEquals(new Event(null, null, " test"), callbacks.remove());
+  }
+
+  @Test public void idReusedAcrossEvents() throws IOException {
+    consumeEvents(""
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n"
+        + "data: second event\n"
+        + "\n"
+        + "id: 2\n"
+        + "data: third event\n"
+        + "\n");
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+    assertEquals(new Event("1", null, "second event"), callbacks.remove());
+    assertEquals(new Event("2", null, "third event"), callbacks.remove());
+  }
+
+  @Test public void idIgnoredFromEmptyEvent() throws IOException {
+    consumeEvents(""
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n"
+        + "id: 2\n"
+        + "\n"
+        + "data: second event\n"
+        + "\n");
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+    assertEquals(new Event("1", null, "second event"), callbacks.remove());
+  }
+
+  @Test public void retry() throws IOException {
+    consumeEvents(""
+        + "retry: 22\n"
+        + "\n"
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n");
+    assertEquals(22L, callbacks.remove());
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+  }
+
+  @Test public void retryInvalidFormatIgnored() throws IOException {
+    consumeEvents(""
+        + "retry: 22\n"
+        + "\n"
+        + "retry: hey"
+        + "\n");
+    assertEquals(22L, callbacks.remove());
+  }
+  
+  private void consumeEvents(String source) throws IOException {
+    ServerSentEventReader.Callback callback = new ServerSentEventReader.Callback() {
+      @Override public void onEvent(@Nullable String id, @Nullable String type, String data) {
+        callbacks.add(new Event(id, type, data));
+      }
+      @Override public void onRetryChange(long timeMs) {
+        callbacks.add(timeMs);
+      }
+    };
+    Buffer buffer = new Buffer().writeUtf8(source);
+    ServerSentEventReader reader = new ServerSentEventReader(buffer, callback);
+    while (reader.processNextEvent());
+    assertEquals("Unconsumed buffer: " + buffer.readUtf8(), 0, buffer.size());
+  }
+}
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
index e96c41561f..19363356c3 100644
--- a/okhttp-testing-support/pom.xml
+++ b/okhttp-testing-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.10.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-testing-support</artifactId>
@@ -35,6 +35,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okhttp-tests/src/test/java/okhttp3/TestUtil.java b/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
similarity index 58%
rename from okhttp-tests/src/test/java/okhttp3/TestUtil.java
rename to okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
index fa7435ffc3..2a85617dc1 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestUtil.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
@@ -1,16 +1,44 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package okhttp3;
 
+import java.net.InetAddress;
 import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
-import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.http2.Header;
 
 public final class TestUtil {
   public static final InetSocketAddress UNREACHABLE_ADDRESS
       = new InetSocketAddress("198.51.100.1", 8080);
 
+  /**
+   * A network that resolves only one IP address per host. Use this when testing route selection
+   * fallbacks to prevent the host machine's various IP addresses from interfering.
+   */
+  private static final Dns SINGLE_INET_ADDRESS_DNS = new Dns() {
+    @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+      List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
+      return Collections.singletonList(addresses.get(0));
+    }
+  };
+
   private TestUtil() {
   }
 
@@ -30,7 +58,7 @@ public static OkHttpClient defaultClient() {
     return new OkHttpClient.Builder()
         .connectionPool(connectionPool)
         .dispatcher(dispatcher)
-        .dns(new SingleInetAddressDns()) // Prevent unexpected fallback addresses.
+        .dns(SINGLE_INET_ADDRESS_DNS) // Prevent unexpected fallback addresses.
         .build();
   }
 
@@ -53,7 +81,7 @@ public static String repeat(char c, int count) {
    * https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
    * java/lang/ref/FinalizationTester.java
    */
-  public static void awaitGarbageCollection() throws InterruptedException {
+  public static void awaitGarbageCollection() throws Exception {
     Runtime.getRuntime().gc();
     Thread.sleep(100);
     System.runFinalization();
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
index 38652c07de..ae034cd9a6 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
@@ -17,6 +17,9 @@
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import org.junit.internal.Throwables;
 import org.junit.runner.Description;
 import org.junit.runner.Result;
 import org.junit.runner.notification.RunListener;
@@ -30,8 +33,9 @@
 
   private Thread.UncaughtExceptionHandler oldDefaultUncaughtExceptionHandler;
   private Description lastTestStarted;
+  private final Map<Throwable, String> exceptions = new LinkedHashMap<>();
 
-  @Override public void testRunStarted(Description description) throws Exception {
+  @Override public void testRunStarted(Description description) {
     System.err.println("Installing aggressive uncaught exception handler");
     oldDefaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
     Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
@@ -48,17 +52,26 @@
           errorText.append("\n");
         }
         System.err.print(errorText.toString());
-        System.exit(-1);
+
+        synchronized (exceptions) {
+          exceptions.put(throwable, lastTestStarted.getDisplayName());
+        }
       }
     });
   }
 
-  @Override public void testStarted(Description description) throws Exception {
+  @Override public void testStarted(Description description) {
     lastTestStarted = description;
   }
 
   @Override public void testRunFinished(Result result) throws Exception {
     Thread.setDefaultUncaughtExceptionHandler(oldDefaultUncaughtExceptionHandler);
     System.err.println("Uninstalled aggressive uncaught exception handler");
+
+    synchronized (exceptions) {
+      if (!exceptions.isEmpty()) {
+        throw Throwables.rethrowAsException(exceptions.keySet().iterator().next());
+      }
+    }
   }
 }
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index 6959cd9a07..c25a0516b1 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.10.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
@@ -33,11 +33,21 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-urlconnection</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>org.conscrypt</groupId>
+      <artifactId>conscrypt-openjdk-uber</artifactId>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -50,6 +60,12 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>logging-interceptor</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 
   <build>
@@ -57,6 +73,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-assembly-plugin</artifactId>
+        <version>3.1.0</version>
         <configuration>
           <descriptorRefs>
             <descriptorRef>jar-with-dependencies</descriptorRef>
@@ -80,6 +97,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-deploy-plugin</artifactId>
+        <version>2.7</version>
         <configuration>
           <skip>true</skip>
         </configuration>
diff --git a/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java b/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java
new file mode 100644
index 0000000000..dfe5279985
--- /dev/null
+++ b/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java
@@ -0,0 +1,113 @@
+package okhttp3;
+
+import java.io.IOException;
+import java.security.Security;
+import java.util.Arrays;
+import java.util.List;
+import okhttp3.internal.platform.Platform;
+import org.conscrypt.Conscrypt;
+
+public class TestTls13Request {
+
+  // TLS 1.3
+  private static final CipherSuite[] TLS13_CIPHER_SUITES = new CipherSuite[] {
+      CipherSuite.TLS_AES_128_GCM_SHA256,
+      CipherSuite.TLS_AES_256_GCM_SHA384,
+      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_AES_128_CCM_SHA256,
+      CipherSuite.TLS_AES_256_CCM_8_SHA256
+  };
+
+  /**
+   * A TLS 1.3 only Connection Spec. This will be eventually be exposed
+   * as part of MODERN_TLS or folded into the default OkHttp client once published and
+   * available in JDK11 or Conscrypt.
+   */
+  private static final ConnectionSpec TLS_13 = new ConnectionSpec.Builder(true)
+      .cipherSuites(TLS13_CIPHER_SUITES)
+      .tlsVersions(TlsVersion.TLS_1_3)
+      .supportsTlsExtensions(true)
+      .build();
+
+
+  private static final ConnectionSpec TLS_12 =
+      new ConnectionSpec.Builder(ConnectionSpec.RESTRICTED_TLS).tlsVersions(TlsVersion.TLS_1_2)
+          .build();
+
+  private TestTls13Request() {
+  }
+
+  public static void main(String[] args) {
+    //System.setProperty("javax.net.debug", "ssl:handshake:verbose");
+    Security.insertProviderAt(Conscrypt.newProviderBuilder().provideTrustManager().build(), 1);
+
+    System.out.println(
+        "Running tests using " + Platform.get() + " " + System.getProperty("java.vm.version"));
+
+    // https://github.com/tlswg/tls13-spec/wiki/Implementations
+    List<String> urls =
+        Arrays.asList("https://enabled.tls13.com", "https://www.howsmyssl.com/a/check",
+            "https://tls13.cloudflare.com", "https://www.allizom.org/robots.txt",
+            "https://tls13.crypto.mozilla.org/", "https://tls.ctf.network/robots.txt",
+            "https://rustls.jbp.io/", "https://h2o.examp1e.net", "https://mew.org/",
+            "https://tls13.baishancloud.com/", "https://tls13.akamai.io/", "https://swifttls.org/",
+            "https://www.googleapis.com/robots.txt", "https://graph.facebook.com/robots.txt",
+            "https://api.twitter.com/robots.txt", "https://connect.squareup.com/robots.txt");
+
+    System.out.println("TLS1.3+TLS1.2");
+    testClient(urls, buildClient(ConnectionSpec.RESTRICTED_TLS));
+
+    System.out.println("\nTLS1.3 only");
+    testClient(urls, buildClient(TLS_13));
+
+    System.out.println("\nTLS1.3 then fallback");
+    testClient(urls, buildClient(TLS_13, TLS_12));
+  }
+
+  private static void testClient(List<String> urls, OkHttpClient client) {
+    try {
+      for (String url : urls) {
+        sendRequest(client, url);
+      }
+    } finally {
+      client.dispatcher.executorService().shutdownNow();
+      client.connectionPool.evictAll();
+    }
+  }
+
+  private static OkHttpClient buildClient(ConnectionSpec... specs) {
+    return new OkHttpClient.Builder().connectionSpecs(Arrays.asList(specs)).build();
+  }
+
+  private static void sendRequest(OkHttpClient client, String url) {
+    System.out.printf("%-40s ", url);
+    System.out.flush();
+
+    System.out.println(Platform.get());
+
+    Request request = new Request.Builder().url(url).build();
+
+    Response response = null;
+    try {
+      response = client.newCall(request).execute();
+
+      Handshake handshake = response.handshake();
+      System.out.println(handshake.tlsVersion()
+          + " "
+          + handshake.cipherSuite()
+          + " "
+          + response.protocol()
+          + " "
+          + response.code
+          + " "
+          + response.body.bytes().length
+          + "b");
+    } catch (IOException ioe) {
+      System.out.println(ioe.toString());
+    } finally {
+      if (response != null) {
+        response.close();
+      }
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
index 1537717124..0d9ca9fa75 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
@@ -38,10 +38,10 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.internal.platform.Platform;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -54,6 +54,7 @@
 
 import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -72,7 +73,7 @@
   @Rule public MockWebServer server2 = new MockWebServer();
   @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
-  private final SslClient sslClient = SslClient.localhost();
+  private final HandshakeCertificates handshakeCertificates = localhost();
   private OkHttpClient client;
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
@@ -253,14 +254,15 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCaching() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -349,7 +351,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -363,7 +365,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("DEF"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -389,7 +392,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
    * https://github.com/square/okhttp/issues/214
    */
   @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslClient.socketFactory, false);
+    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server2.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -404,7 +407,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Location: " + server2.url("/")));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -774,7 +778,7 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
 
   private RequestBody requestBodyOrNull(String requestMethod) {
     return (requestMethod.equals("POST") || requestMethod.equals("PUT"))
-        ? RequestBody.create(MediaType.parse("text/plain"), "foo")
+        ? RequestBody.create(MediaType.get("text/plain"), "foo")
         : null;
   }
 
@@ -862,7 +866,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
     Request request = new Request.Builder()
         .url(url)
-        .put(RequestBody.create(MediaType.parse("text/plain"), "foo"))
+        .put(RequestBody.create(MediaType.get("text/plain"), "foo"))
         .build();
     Response invalidate = client.newCall(request).execute();
     assertEquals("", invalidate.body().string());
@@ -1378,7 +1382,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
     Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
     DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
     String lastModifiedString = dateFormat.format(lastModifiedDate);
     String servedString = dateFormat.format(servedDate);
 
@@ -1756,7 +1760,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void varyAndHttps() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
@@ -1765,7 +1769,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("B"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -2519,7 +2524,7 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
 
   @Test public void immutableIsCached() throws Exception {
     server.enqueue(new MockResponse()
-        .addHeader("Cache-Control", "immutable")
+        .addHeader("Cache-Control", "immutable, max-age=10")
         .setBody("A"));
     server.enqueue(new MockResponse()
         .setBody("B"));
@@ -2533,7 +2538,7 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     server.enqueue(new MockResponse()
         .setBody("A"));
     server.enqueue(new MockResponse()
-        .addHeader("Cache-Control", "immutable")
+        .addHeader("Cache-Control", "immutable, max-age=10")
         .setBody("B"));
     server.enqueue(new MockResponse()
         .setBody("C"));
@@ -2544,6 +2549,19 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     assertEquals("B", get(url).body().string());
   }
 
+  @Test public void immutableIsNotCachedBeyondFreshnessLifetime() throws Exception {
+    //      last modified: 115 seconds ago
+    //             served:  15 seconds ago
+    //   default lifetime: (115 - 15) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds ago
+    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Cache-Control: immutable")
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
+    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+  }
+
   private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(response.setBody("B"));
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index 588dc45993..a58bc879c2 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.File;
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InterruptedIOException;
@@ -44,10 +45,13 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import java.util.logging.SimpleFormatter;
+import javax.annotation.Nullable;
+import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLProtocolException;
@@ -55,7 +59,6 @@
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
 import okhttp3.internal.http.RecordingProxySelector;
@@ -65,8 +68,8 @@
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.mockwebserver.internal.tls.HeldCertificate;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -83,6 +86,7 @@
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
 import static okhttp3.TestUtil.awaitGarbageCollection;
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -98,12 +102,11 @@
   @Rule public final MockWebServer server2 = new MockWebServer();
   @Rule public final InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
   private OkHttpClient client = defaultClient();
   private RecordingCallback callback = new RecordingCallback();
   private TestLogHandler logHandler = new TestLogHandler();
   private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-  private NullServer nullServer = new NullServer();
   private Logger logger = Logger.getLogger(OkHttpClient.class.getName());
 
   @Before public void setUp() throws Exception {
@@ -112,7 +115,6 @@
 
   @After public void tearDown() throws Exception {
     cache.delete();
-    nullServer.shutdown();
     logger.removeHandler(logHandler);
   }
 
@@ -155,7 +157,7 @@
       requestBuilder.url("ftp://hostname/path");
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals(expected.getMessage(), "unexpected url: ftp://hostname/path");
+      assertEquals("Expected URL scheme 'http' or 'https' but was 'ftp'", expected.getMessage());
     }
   }
 
@@ -165,7 +167,7 @@
       requestBuilder.url("http://localhost:65536/");
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals(expected.getMessage(), "unexpected url: http://localhost:65536/");
+      assertEquals("Invalid URL port: \"65536\"", expected.getMessage());
     }
   }
 
@@ -208,7 +210,7 @@
     server.enqueue(new MockResponse());
 
     try {
-      new Request.Builder().method("GET", RequestBody.create(MediaType.parse("text/plain"), "abc"));
+      new Request.Builder().method("GET", RequestBody.create(MediaType.get("text/plain"), "abc"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -302,7 +304,7 @@
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -395,7 +397,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     String credential = Credentials.basic("jesse", "secret");
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build();
 
     Response response = client.newCall(request).execute();
@@ -421,7 +423,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     String credential = Credentials.basic("jesse", "secret");
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build();
 
     executeSynchronously("/")
@@ -436,7 +438,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     String credential = Credentials.basic("jesse", "secret");
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build();
 
     try {
@@ -457,7 +459,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setResponseCode(401)
         .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
 
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(null);
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(null, null);
 
     client = client.newBuilder()
         .authenticator(authenticator)
@@ -503,7 +505,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .method("DELETE", RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .method("DELETE", RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -520,7 +522,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .put(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .put(RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -549,7 +551,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .patch(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .patch(RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -578,7 +580,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .method("CUSTOM", RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .method("CUSTOM", RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -895,14 +897,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
    * never responds. The manual retry will succeed.
    */
   @Test public void readTimeoutFails() throws Exception {
-    nullServer.start();
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
+    server2.enqueue(new MockResponse()
+        .setBody("success!"));
 
     RecordingProxySelector proxySelector = new RecordingProxySelector();
-    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, nullServer.address()));
     proxySelector.proxies.add(server.toProxyAddress());
-
-    server.enqueue(new MockResponse()
-        .setBody("success!"));
+    proxySelector.proxies.add(server2.toProxyAddress());
 
     client = client.newBuilder()
         .proxySelector(proxySelector)
@@ -939,7 +941,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     // Call 1: set a deadline on the request body.
     RequestBody requestBody1 = new RequestBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain");
+        return MediaType.get("text/plain");
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
@@ -957,7 +959,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     // Call 2: check for the absence of a deadline on the request body.
     RequestBody requestBody2 = new RequestBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain");
+        return MediaType.get("text/plain");
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
@@ -1068,11 +1070,12 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void tlsHandshakeFailure_noFallbackByDefault() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("response that will never be received"));
     RecordedResponse response = executeSynchronously("/");
     response.assertFailure(
+            SSLException.class, // JDK 11 response to the FAIL_HANDSHAKE
             SSLProtocolException.class, // RI response to the FAIL_HANDSHAKE
             SSLHandshakeException.class // Android's response to the FAIL_HANDSHAKE
     );
@@ -1080,16 +1083,16 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void recoverFromTlsHandshakeFailure() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("abc"));
 
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .dns(new SingleInetAddressDns())
-        // opt-in to fallback to COMPATIBLE_TLS
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build();
 
     executeSynchronously("/").assertBody("abc");
@@ -1098,23 +1101,22 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   @Test public void recoverFromTlsHandshakeFailure_tlsFallbackScsvEnabled() throws Exception {
     final String tlsFallbackScsv = "TLS_FALLBACK_SCSV";
     List<String> supportedCiphers =
-        Arrays.asList(sslClient.socketFactory.getSupportedCipherSuites());
+        Arrays.asList(handshakeCertificates.sslSocketFactory().getSupportedCipherSuites());
     if (!supportedCiphers.contains(tlsFallbackScsv)) {
       // This only works if the client socket supports TLS_FALLBACK_SCSV.
       return;
     }
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
 
     RecordingSSLSocketFactory clientSocketFactory =
-        new RecordingSSLSocketFactory(sslClient.socketFactory);
+        new RecordingSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     client = client.newBuilder()
-        .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
-        // opt-in to fallback to COMPATIBLE_TLS
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+        .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .dns(new SingleInetAddressDns())
         .build();
 
     Request request = new Request.Builder().url(server.url("/")).build();
@@ -1132,14 +1134,16 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void recoverFromTlsHandshakeFailure_Async() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("abc"));
 
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build();
 
     Request request = new Request.Builder()
@@ -1154,11 +1158,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client = client.newBuilder()
         .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT))
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .dns(new SingleInetAddressDns())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build();
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
 
     Request request = new Request.Builder().url(server.url("/")).build();
@@ -1169,6 +1173,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       // RI response to the FAIL_HANDSHAKE
     } catch (SSLHandshakeException expected) {
       // Android's response to the FAIL_HANDSHAKE
+    } catch (SSLException expected) {
+      // JDK 11 response to the FAIL_HANDSHAKE
+      String jvmVersion = System.getProperty("java.specification.version");
+      assertEquals("11", jvmVersion);
     }
   }
 
@@ -1189,6 +1197,25 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
   }
 
+  @Test public void httpsCallsFailWhenProtocolIsH2PriorKnowledge() throws Exception {
+    client = client.newBuilder()
+        .protocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE))
+        .build();
+
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (UnknownServiceException expected) {
+      assertEquals("H2_PRIOR_KNOWLEDGE cannot be used with HTTPS", expected.getMessage());
+    }
+  }
+
   @Test public void setFollowSslRedirectsFalse() throws Exception {
     enableTls();
     server.enqueue(new MockResponse()
@@ -1255,7 +1282,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
     client.newCall(request).enqueue(callback);
 
@@ -1281,7 +1308,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request2 = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "body!"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "body!"))
         .build();
     Response response2 = client.newCall(request2).execute();
     assertEquals("def", response2.body().string());
@@ -1597,7 +1624,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Response response = client.newCall(new Request.Builder()
         .url(server.url("/page1"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "Request Body"))
         .build()).execute();
     assertEquals("Page 2", response.body().string());
 
@@ -1651,7 +1678,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "Hello"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "Hello"))
         .build();
     Response response = client.newCall(request).execute();
 
@@ -1760,7 +1787,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     // when
     Response response = client.newCall(new Request.Builder()
         .url(server.url("/page1"))
-        .method("PROPFIND", RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
+        .method("PROPFIND", RequestBody.create(MediaType.get("text/plain"), "Request Body"))
         .build()).execute();
 
     // then
@@ -1851,7 +1878,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .addHeader("Location: " + server2.url("/b")));
 
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret"), null))
         .build();
 
     Request request = new Request.Builder().url(server.url("/a")).build();
@@ -2012,11 +2039,12 @@ private String stringFill(char fillChar, int length) {
 
   /** Cancel a call that's waiting for connect to complete. */
   private void cancelDuringConnect(String scheme) throws Exception {
-    nullServer.start();
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
 
     long cancelDelayMillis = 300L;
     Call call = client.newCall(new Request.Builder()
-        .url(nullServer.url(scheme))
+        .url(server.url("/").newBuilder().scheme(scheme).build())
         .build());
     cancelLater(call, cancelDelayMillis);
 
@@ -2032,11 +2060,27 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
   @Test public void cancelImmediatelyAfterEnqueue() throws Exception {
     server.enqueue(new MockResponse());
+    final CountDownLatch latch = new CountDownLatch(1);
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            try {
+              latch.await();
+            } catch (InterruptedException e) {
+              throw new AssertionError(e);
+            }
+            return chain.proceed(chain.request());
+          }
+        })
+        .build();
+
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/a"))
         .build());
     call.enqueue(callback);
     call.cancel();
+    latch.countDown();
+
     callback.await(server.url("/a")).assertFailure("Canceled", "Socket closed");
   }
 
@@ -2272,7 +2316,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .setBody(gzip("abcabcabc"))
         .addHeader("Content-Encoding: gzip"));
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator("password"))
+        .authenticator(new RecordingOkAuthenticator("password", null))
         .build();
 
     executeSynchronously("/").assertBody("abcabcabc");
@@ -2374,7 +2418,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     executeSynchronously(request)
@@ -2390,7 +2434,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), ""))
+        .post(RequestBody.create(MediaType.get("text/plain"), ""))
         .build();
 
     executeSynchronously(request)
@@ -2414,7 +2458,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     Call call = client.newCall(request);
@@ -2435,17 +2479,16 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
   @Test public void serverRespondsWithUnsolicited100Continue() throws Exception {
     server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 100 Continue"));
+        .setSocketPolicy(SocketPolicy.CONTINUE_ALWAYS));
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
-    Call call = client.newCall(request);
-    Response response = call.execute();
-    assertEquals(100, response.code());
-    assertEquals("", response.body().string());
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertSuccessful();
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("abc", recordedRequest.getBody().readUtf8());
@@ -2456,6 +2499,35 @@ private void cancelDuringConnect(String scheme) throws Exception {
     serverRespondsWithUnsolicited100Continue();
   }
 
+  @Test public void serverRespondsWith100ContinueOnly() throws Exception {
+    client = client.newBuilder()
+        .readTimeout(1, TimeUnit.SECONDS)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 100 Continue"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .build();
+
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("abc", recordedRequest.getBody().readUtf8());
+  }
+
+  @Test public void serverRespondsWith100ContinueOnly_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    serverRespondsWith100ContinueOnly();
+  }
+
   @Test public void successfulExpectContinuePermitsConnectionReuse() throws Exception {
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
@@ -2464,7 +2536,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build());
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
@@ -2486,7 +2558,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build());
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
@@ -2505,7 +2577,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build());
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
@@ -2596,7 +2668,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
   /** Test which headers are sent unencrypted to the HTTP proxy. */
   @Test public void proxyConnectOmitsApplicationHeaders() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
         .clearHeaders());
@@ -2605,7 +2677,8 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
         .hostnameVerifier(hostnameVerifier)
         .build();
@@ -2633,7 +2706,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
   /** Respond to a proxy authorization challenge. */
   @Test public void proxyAuthenticateOnConnect() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(new MockResponse()
         .setResponseCode(407)
         .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
@@ -2644,9 +2717,10 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
@@ -2679,7 +2753,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
     client = client.newBuilder()
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .build();
 
     Request request = new Request.Builder()
@@ -2702,7 +2776,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
    * TLS tunnel. https://github.com/square/okhttp/issues/2426
    */
   @Test public void proxyAuthenticateOnConnectWithConnectionClose() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
     server.enqueue(new MockResponse()
         .setResponseCode(407)
@@ -2715,9 +2789,10 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
@@ -2738,7 +2813,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
   }
 
   @Test public void tooManyProxyAuthFailuresWithConnectionClose() throws IOException {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
     for (int i = 0; i < 21; i++) {
       server.enqueue(new MockResponse()
@@ -2748,9 +2823,10 @@ private void cancelDuringConnect(String scheme) throws Exception {
     }
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
@@ -2769,8 +2845,8 @@ private void cancelDuringConnect(String scheme) throws Exception {
    * We used to have that behavior but it is problematic because unrelated requests end up sharing
    * credentials. Worse, that approach leaks proxy credentials to the origin server.
    */
-  @Test public void noProactiveProxyAuthorization() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+  @Test public void noPreemptiveProxyAuthorization() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
         .clearHeaders());
@@ -2778,7 +2854,8 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
@@ -2790,11 +2867,107 @@ private void cancelDuringConnect(String scheme) throws Exception {
     Response response = client.newCall(request).execute();
     assertEquals("response body", response.body().string());
 
+    RecordedRequest connect1 = server.takeRequest();
+    assertNull(connect1.getHeader("Proxy-Authorization"));
+
+    RecordedRequest connect2 = server.takeRequest();
+    assertEquals("password", connect2.getHeader("Proxy-Authorization"));
+  }
+
+  /** Confirm that we can send authentication information without being prompted first. */
+  @Test public void preemptiveProxyAuthentication() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("encrypted response from the origin server"));
+
+    final String credential = Credentials.basic("jesse", "password1");
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .proxy(server.toProxyAddress())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxyAuthenticator(new Authenticator() {
+          @Override public Request authenticate(Route route, Response response) {
+            assertEquals("CONNECT", response.request().method());
+            assertEquals(HttpURLConnection.HTTP_PROXY_AUTH, response.code());
+            assertEquals("android.com", response.request().url().host());
+
+            List<Challenge> challenges = response.challenges();
+            assertEquals("OkHttp-Preemptive", challenges.get(0).scheme());
+
+            return response.request().newBuilder()
+                .header("Proxy-Authorization", credential)
+                .build();
+          }
+        })
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+
+    executeSynchronously(request).assertSuccessful();
+
     RecordedRequest connect = server.takeRequest();
-    assertNull(connect.getHeader("Proxy-Authorization"));
+    assertEquals("CONNECT", connect.getMethod());
+    assertEquals(credential, connect.getHeader("Proxy-Authorization"));
+    assertEquals("/", connect.getPath());
 
     RecordedRequest get = server.takeRequest();
-    assertEquals("password", get.getHeader("Proxy-Authorization"));
+    assertEquals("GET", get.getMethod());
+    assertNull(get.getHeader("Proxy-Authorization"));
+    assertEquals("/foo", get.getPath());
+  }
+
+  @Test public void preemptiveThenReactiveProxyAuthentication() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_PROXY_AUTH)
+        .addHeader("Proxy-Authenticate", "Basic realm=\"localhost\"")
+        .setBody("proxy auth required"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse());
+
+    final List<String> challengeSchemes = new ArrayList<>();
+    final String credential = Credentials.basic("jesse", "password1");
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .proxy(server.toProxyAddress())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxyAuthenticator(new Authenticator() {
+          @Override public Request authenticate(Route route, Response response) {
+            List<Challenge> challenges = response.challenges();
+            challengeSchemes.add(challenges.get(0).scheme());
+            return response.request().newBuilder()
+                .header("Proxy-Authorization", credential)
+                .build();
+          }
+        })
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+
+    executeSynchronously(request).assertSuccessful();
+
+    RecordedRequest connect1 = server.takeRequest();
+    assertEquals("CONNECT", connect1.getMethod());
+    assertEquals(credential, connect1.getHeader("Proxy-Authorization"));
+
+    RecordedRequest connect2 = server.takeRequest();
+    assertEquals("CONNECT", connect2.getMethod());
+    assertEquals(credential, connect2.getHeader("Proxy-Authorization"));
+
+    assertEquals(Arrays.asList("OkHttp-Preemptive", "Basic"), challengeSchemes);
   }
 
   @Test public void interceptorGetsHttp2() throws Exception {
@@ -2910,7 +3083,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     executeSynchronously(request);
@@ -2920,7 +3093,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
   @Ignore // This may fail in DNS lookup, which we don't have timeouts for.
   @Test public void invalidHost() throws Exception {
     Request request = new Request.Builder()
-        .url(HttpUrl.parse("http://1234.1.1.1/"))
+        .url(HttpUrl.get("http://1234.1.1.1/"))
         .build();
 
     executeSynchronously(request)
@@ -2967,7 +3140,7 @@ private void upload(
   /** https://github.com/square/okhttp/issues/2344 */
   @Test public void ipv6HostHasSquareBraces() throws Exception {
     // Use a proxy to fake IPv6 connectivity, even if localhost doesn't have IPv6.
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
@@ -2976,7 +3149,8 @@ private void upload(
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .proxy(server.toProxyAddress())
         .build();
@@ -3002,7 +3176,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
 
     return new RequestBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain; charset=utf-8");
+        return MediaType.get("text/plain; charset=utf-8");
       }
 
       @Override public long contentLength() throws IOException {
@@ -3098,23 +3272,70 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     }
   }
 
+  @Test public void failedAuthenticatorReleasesConnection() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+
+    client.connectionPool().evictAll();
+    client = client.newBuilder()
+        .authenticator(new Authenticator() {
+          @Override public Request authenticate(Route route, Response response) throws IOException {
+            throw new IOException("IOException!");
+          }
+        })
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    executeSynchronously(request)
+        .assertFailure(IOException.class);
+
+    assertEquals(1, client.connectionPool().idleConnectionCount());
+  }
+
+  @Test public void failedProxyAuthenticatorReleasesConnection() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(407));
+
+    client.connectionPool().evictAll();
+    client = client.newBuilder()
+        .proxyAuthenticator(new Authenticator() {
+          @Override public Request authenticate(Route route, Response response) throws IOException {
+            throw new IOException("IOException!");
+          }
+        })
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    executeSynchronously(request)
+        .assertFailure(IOException.class);
+
+    assertEquals(1, client.connectionPool().idleConnectionCount());
+  }
+
   @Test public void httpsWithIpAddress() throws Exception {
     String localIpAddress = InetAddress.getLoopbackAddress().getHostAddress();
 
     // Create a certificate with an IP address in the subject alt name.
     HeldCertificate heldCertificate = new HeldCertificate.Builder()
         .commonName("example.com")
-        .subjectAlternativeName(localIpAddress)
+        .addSubjectAlternativeName(localIpAddress)
         .build();
-    SslClient sslClient = new SslClient.Builder()
-        .certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
-        .addTrustedCertificate(heldCertificate.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(heldCertificate)
+        .addTrustedCertificate(heldCertificate.certificate())
         .build();
 
     // Use that certificate on the server and trust it on the client.
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .protocols(Collections.singletonList(Protocol.HTTP_1_1))
         .build();
@@ -3135,6 +3356,31 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     assertEquals(localIpAddress + ":" + server.getPort(), recordedRequest.getHeader("Host"));
   }
 
+  @Test public void postWithFileNotFound() throws Exception {
+    final AtomicInteger called = new AtomicInteger(0);
+
+    RequestBody body = new RequestBody() {
+      @Nullable @Override public MediaType contentType() {
+        return MediaType.get("application/octet-stream");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        called.incrementAndGet();
+        throw new FileNotFoundException();
+      }
+    };
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(body)
+        .build();
+
+    executeSynchronously(request)
+        .assertFailure(FileNotFoundException.class);
+
+    assertEquals(1L, called.get());
+  }
+
   private void makeFailingCall() {
     RequestBody requestBody = new RequestBody() {
       @Override public MediaType contentType() {
@@ -3198,10 +3444,11 @@ private void enableProtocol(Protocol protocol) {
 
   private void enableTls() {
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
   }
 
   private Buffer gzip(String data) throws IOException {
@@ -3250,6 +3497,6 @@ protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
    * for details.
    */
   private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(sslClient.socketFactory);
+    return new FallbackTestClientSocketFactory(handshakeCertificates.sslSocketFactory());
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
index e76f0c2cdf..e61cb9f294 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -15,7 +15,6 @@
  */
 package okhttp3;
 
-import java.security.GeneralSecurityException;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
@@ -23,29 +22,29 @@
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.mockwebserver.internal.tls.HeldCertificate;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 public final class CertificateChainCleanerTest {
-  @Test public void equalsFromCertificate() throws Exception {
+  @Test public void equalsFromCertificate() {
     HeldCertificate rootA = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate rootB = new HeldCertificate.Builder()
-        .serialNumber("2")
+        .serialNumber(2L)
         .build();
     assertEquals(
-        CertificateChainCleaner.get(rootA.certificate, rootB.certificate),
-        CertificateChainCleaner.get(rootB.certificate, rootA.certificate));
+        CertificateChainCleaner.get(rootA.certificate(), rootB.certificate()),
+        CertificateChainCleaner.get(rootB.certificate(), rootA.certificate()));
   }
 
-  @Test public void equalsFromTrustManager() throws Exception {
-    SslClient client = new SslClient.Builder().build();
-    X509TrustManager x509TrustManager = client.trustManager;
+  @Test public void equalsFromTrustManager() {
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder().build();
+    X509TrustManager x509TrustManager = handshakeCertificates.trustManager();
     assertEquals(
         CertificateChainCleaner.get(x509TrustManager),
         CertificateChainCleaner.get(x509TrustManager));
@@ -53,15 +52,15 @@
 
   @Test public void normalizeSingleSelfSignedCertificate() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(root), cleaner.clean(list(root), "hostname"));
   }
 
-  @Test public void normalizeUnknownSelfSignedCertificate() throws Exception {
+  @Test public void normalizeUnknownSelfSignedCertificate() {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     CertificateChainCleaner cleaner = CertificateChainCleaner.get();
 
@@ -74,123 +73,123 @@
 
   @Test public void orderedChainOfCertificatesWithRoot() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(certB, certA, root), cleaner.clean(list(certB, certA, root), "hostname"));
   }
 
   @Test public void orderedChainOfCertificatesWithoutRoot() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(certB, certA, root),
         cleaner.clean(list(certB, certA), "hostname")); // Root is added!
   }
 
   @Test public void unorderedChainOfCertificatesWithRoot() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
     HeldCertificate certC = new HeldCertificate.Builder()
-        .serialNumber("4")
-        .issuedBy(certB)
+        .serialNumber(4L)
+        .signedBy(certB)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(certC, certB, certA, root),
         cleaner.clean(list(certC, certA, root, certB), "hostname"));
   }
 
   @Test public void unorderedChainOfCertificatesWithoutRoot() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
     HeldCertificate certC = new HeldCertificate.Builder()
-        .serialNumber("4")
-        .issuedBy(certB)
+        .serialNumber(4L)
+        .signedBy(certB)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(certC, certB, certA, root),
         cleaner.clean(list(certC, certA, certB), "hostname"));
   }
 
   @Test public void unrelatedCertificatesAreOmitted() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
     HeldCertificate certUnnecessary = new HeldCertificate.Builder()
-        .serialNumber("4")
+        .serialNumber(4L)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(certB, certA, root),
         cleaner.clean(list(certB, certUnnecessary, certA, root), "hostname"));
   }
 
   @Test public void chainGoesAllTheWayToSelfSignedRoot() throws Exception {
     HeldCertificate selfSigned = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate trusted = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(selfSigned)
+        .serialNumber(2L)
+        .signedBy(selfSigned)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(trusted)
+        .serialNumber(3L)
+        .signedBy(trusted)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("4")
-        .issuedBy(certA)
+        .serialNumber(4L)
+        .signedBy(certA)
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(
-        selfSigned.certificate, trusted.certificate);
+        selfSigned.certificate(), trusted.certificate());
     assertEquals(list(certB, certA, trusted, selfSigned),
         cleaner.clean(list(certB, certA), "hostname"));
     assertEquals(list(certB, certA, trusted, selfSigned),
@@ -201,22 +200,22 @@
 
   @Test public void trustedRootNotSelfSigned() throws Exception {
     HeldCertificate unknownSigner = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate trusted = new HeldCertificate.Builder()
-        .issuedBy(unknownSigner)
-        .serialNumber("2")
+        .signedBy(unknownSigner)
+        .serialNumber(2L)
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(trusted)
-        .serialNumber("3")
+        .signedBy(trusted)
+        .serialNumber(3L)
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
-        .serialNumber("4")
+        .signedBy(intermediateCa)
+        .serialNumber(4L)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(trusted.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(trusted.certificate());
     assertEquals(list(certificate, intermediateCa, trusted),
         cleaner.clean(list(certificate, intermediateCa), "hostname"));
     assertEquals(list(certificate, intermediateCa, trusted),
@@ -227,23 +226,23 @@
     List<HeldCertificate> heldCertificates = chainOfLength(10);
     List<Certificate> certificates = new ArrayList<>();
     for (HeldCertificate heldCertificate : heldCertificates) {
-      certificates.add(heldCertificate.certificate);
+      certificates.add(heldCertificate.certificate());
     }
 
-    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate();
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
     assertEquals(certificates, cleaner.clean(certificates, "hostname"));
     assertEquals(certificates, cleaner.clean(certificates.subList(0, 9), "hostname"));
   }
 
-  @Test public void chainTooLong() throws Exception {
+  @Test public void chainTooLong() {
     List<HeldCertificate> heldCertificates = chainOfLength(11);
     List<Certificate> certificates = new ArrayList<>();
     for (HeldCertificate heldCertificate : heldCertificates) {
-      certificates.add(heldCertificate.certificate);
+      certificates.add(heldCertificate.certificate());
     }
 
-    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate();
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
     try {
       cleaner.clean(certificates, "hostname");
@@ -253,12 +252,12 @@
   }
 
   /** Returns a chain starting at the leaf certificate and progressing to the root. */
-  private List<HeldCertificate> chainOfLength(int length) throws GeneralSecurityException {
+  private List<HeldCertificate> chainOfLength(int length) {
     List<HeldCertificate> result = new ArrayList<>();
     for (int i = 1; i <= length; i++) {
       result.add(0, new HeldCertificate.Builder()
-          .issuedBy(!result.isEmpty() ? result.get(0) : null)
-          .serialNumber(Integer.toString(i))
+          .signedBy(!result.isEmpty() ? result.get(0) : null)
+          .serialNumber(i)
           .build());
     }
     return result;
@@ -267,7 +266,7 @@
   private List<Certificate> list(HeldCertificate... heldCertificates) {
     List<Certificate> result = new ArrayList<>();
     for (HeldCertificate heldCertificate : heldCertificates) {
-      result.add(heldCertificate.certificate);
+      result.add(heldCertificate.certificate());
     }
     return result;
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
index 4de1f37f52..28e2af8423 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
@@ -15,13 +15,12 @@
  */
 package okhttp3;
 
-import java.security.GeneralSecurityException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okhttp3.CertificatePinner.Pin;
-import okhttp3.mockwebserver.internal.tls.HeldCertificate;
+import okhttp3.tls.HeldCertificate;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -40,24 +39,20 @@
   static String certC1Sha256Pin;
 
   static {
-    try {
-      certA1 = new HeldCertificate.Builder()
-          .serialNumber("100")
-          .build();
-      certA1Sha256Pin = "sha256/" + CertificatePinner.sha256(certA1.certificate).base64();
-
-      certB1 = new HeldCertificate.Builder()
-          .serialNumber("200")
-          .build();
-      certB1Sha256Pin = "sha256/" + CertificatePinner.sha256(certB1.certificate).base64();
-
-      certC1 = new HeldCertificate.Builder()
-          .serialNumber("300")
-          .build();
-      certC1Sha256Pin = "sha256/" + CertificatePinner.sha256(certC1.certificate).base64();
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError(e);
-    }
+    certA1 = new HeldCertificate.Builder()
+        .serialNumber(100L)
+        .build();
+    certA1Sha256Pin = "sha256/" + CertificatePinner.sha256(certA1.certificate()).base64();
+
+    certB1 = new HeldCertificate.Builder()
+        .serialNumber(200L)
+        .build();
+    certB1Sha256Pin = "sha256/" + CertificatePinner.sha256(certB1.certificate()).base64();
+
+    certC1 = new HeldCertificate.Builder()
+        .serialNumber(300L)
+        .build();
+    certC1Sha256Pin = "sha256/" + CertificatePinner.sha256(certC1.certificate()).base64();
   }
 
   @Test public void malformedPin() throws Exception {
@@ -81,16 +76,16 @@
   /** Multiple certificates generated from the same keypair have the same pin. */
   @Test public void sameKeypairSamePin() throws Exception {
     HeldCertificate heldCertificateA2 = new HeldCertificate.Builder()
-        .keyPair(certA1.keyPair)
-        .serialNumber("101")
+        .keyPair(certA1.keyPair())
+        .serialNumber(101L)
         .build();
-    String keypairACertificate2Pin = CertificatePinner.pin(heldCertificateA2.certificate);
+    String keypairACertificate2Pin = CertificatePinner.pin(heldCertificateA2.certificate());
 
     HeldCertificate heldCertificateB2 = new HeldCertificate.Builder()
-        .keyPair(certB1.keyPair)
-        .serialNumber("201")
+        .keyPair(certB1.keyPair())
+        .serialNumber(201L)
         .build();
-    String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate);
+    String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate());
 
     assertTrue(certA1Sha256Pin.equals(keypairACertificate2Pin));
     assertTrue(certB1Sha256Pin.equals(keypairBCertificate2Pin));
@@ -102,15 +97,15 @@
         .add("example.com", certA1Sha256Pin)
         .build();
 
-    certificatePinner.check("example.com", certA1.certificate);
+    certificatePinner.check("example.com", certA1.certificate());
   }
 
   @Test public void successfulCheckSha1Pin() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate).base64())
+        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate()).base64())
         .build();
 
-    certificatePinner.check("example.com", certA1.certificate);
+    certificatePinner.check("example.com", certA1.certificate());
   }
 
   @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
@@ -118,7 +113,7 @@
         .add("example.com", certB1Sha256Pin)
         .build();
 
-    certificatePinner.check("example.com", certA1.certificate, certB1.certificate);
+    certificatePinner.check("example.com", certA1.certificate(), certB1.certificate());
   }
 
   @Test public void unsuccessfulCheck() throws Exception {
@@ -127,7 +122,7 @@
         .build();
 
     try {
-      certificatePinner.check("example.com", certB1.certificate);
+      certificatePinner.check("example.com", certB1.certificate());
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
@@ -138,8 +133,8 @@
         .add("example.com", certA1Sha256Pin, certB1Sha256Pin)
         .build();
 
-    certificatePinner.check("example.com", certA1.certificate);
-    certificatePinner.check("example.com", certB1.certificate);
+    certificatePinner.check("example.com", certA1.certificate());
+    certificatePinner.check("example.com", certB1.certificate());
   }
 
   @Test public void multipleHostnamesForOneCertificate() throws Exception {
@@ -148,13 +143,13 @@
         .add("www.example.com", certA1Sha256Pin)
         .build();
 
-    certificatePinner.check("example.com", certA1.certificate);
-    certificatePinner.check("www.example.com", certA1.certificate);
+    certificatePinner.check("example.com", certA1.certificate());
+    certificatePinner.check("www.example.com", certA1.certificate());
   }
 
   @Test public void absentHostnameMatches() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder().build();
-    certificatePinner.check("example.com", certA1.certificate);
+    certificatePinner.check("example.com", certA1.certificate());
   }
 
   @Test public void successfulCheckForWildcardHostname() throws Exception {
@@ -162,7 +157,7 @@
         .add("*.example.com", certA1Sha256Pin)
         .build();
 
-    certificatePinner.check("a.example.com", certA1.certificate);
+    certificatePinner.check("a.example.com", certA1.certificate());
   }
 
   @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname()
@@ -171,7 +166,7 @@
         .add("*.example.com", certB1Sha256Pin)
         .build();
 
-    certificatePinner.check("a.example.com", certA1.certificate, certB1.certificate);
+    certificatePinner.check("a.example.com", certA1.certificate(), certB1.certificate());
   }
 
   @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
@@ -180,7 +175,7 @@
         .build();
 
     try {
-      certificatePinner.check("a.example.com", certB1.certificate);
+      certificatePinner.check("a.example.com", certB1.certificate());
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
@@ -191,8 +186,8 @@
         .add("*.example.com", certA1Sha256Pin, certB1Sha256Pin)
         .build();
 
-    certificatePinner.check("a.example.com", certA1.certificate);
-    certificatePinner.check("a.example.com", certB1.certificate);
+    certificatePinner.check("a.example.com", certA1.certificate());
+    certificatePinner.check("a.example.com", certB1.certificate());
   }
 
   @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate()
@@ -202,8 +197,8 @@
         .add("a.example.com", certB1Sha256Pin)
         .build();
 
-    certificatePinner.check("a.example.com", certA1.certificate);
-    certificatePinner.check("a.example.com", certB1.certificate);
+    certificatePinner.check("a.example.com", certA1.certificate());
+    certificatePinner.check("a.example.com", certB1.certificate());
   }
 
   @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate()
@@ -214,7 +209,7 @@
         .build();
 
     try {
-      certificatePinner.check("a.example.com", certC1.certificate);
+      certificatePinner.check("a.example.com", certC1.certificate());
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
diff --git a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java b/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
index 63b3023253..64754ad5c0 100644
--- a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
@@ -48,7 +48,7 @@
 
   @Test public void instancesAreInterned() {
     assertSame(forJavaName("TestCipherSuite"), forJavaName("TestCipherSuite"));
-    assertSame(CipherSuite.TLS_KRB5_WITH_DES_CBC_MD5,
+    assertSame(TLS_KRB5_WITH_DES_CBC_MD5,
         forJavaName(TLS_KRB5_WITH_DES_CBC_MD5.javaName()));
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
index cbb0152552..be741a0b53 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
@@ -26,10 +26,10 @@
 import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSession;
-import okhttp3.mockwebserver.internal.tls.HeldCertificate;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HeldCertificate;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
@@ -51,18 +51,18 @@
 
   @Before public void setUp() throws Exception {
     rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(0)
         .commonName("root")
         .build();
     certificate = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .serialNumber("2")
+        .signedBy(rootCa)
+        .serialNumber(2L)
         .commonName(server.getHostName())
-        .subjectAlternativeName(server.getHostName())
-        .subjectAlternativeName("san.com")
-        .subjectAlternativeName("*.wildcard.com")
-        .subjectAlternativeName("differentdns.com")
+        .addSubjectAlternativeName(server.getHostName())
+        .addSubjectAlternativeName("san.com")
+        .addSubjectAlternativeName("*.wildcard.com")
+        .addSubjectAlternativeName("differentdns.com")
         .build();
 
     serverIps = Dns.SYSTEM.lookup(server.getHostName());
@@ -73,18 +73,19 @@
     dns.set("www.wildcard.com", serverIps);
     dns.set("differentdns.com", Collections.<InetAddress>emptyList());
 
-    SslClient sslClient = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
         .build();
 
     client = new OkHttpClient.Builder().dns(dns)
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .build();
 
-    SslClient serverSslClient = new SslClient.Builder()
-        .certificateChain(certificate, rootCa)
+    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(certificate)
         .build();
-    server.useHttps(serverSslClient.socketFactory, false);
+    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
 
     url = server.url("/robots.txt");
   }
@@ -180,7 +181,7 @@
   /** Can still coalesce when pinning is used if pins match. */
   @Test public void coalescesWhenCertificatePinsMatch() throws Exception {
     CertificatePinner pinner = new CertificatePinner.Builder()
-        .add("san.com", "sha1/" + CertificatePinner.sha1(certificate.certificate).base64())
+        .add("san.com", "sha1/" + CertificatePinner.sha1(certificate.certificate()).base64())
         .build();
     client = client.newBuilder().certificatePinner(pinner).build();
 
@@ -319,7 +320,7 @@
   }
 
   private Response execute(String url) throws IOException {
-    return execute(HttpUrl.parse(url));
+    return execute(HttpUrl.get(url));
   }
 
   private Response execute(HttpUrl url) throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
index ae8b0a2f6c..d2c778ce65 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
@@ -193,7 +193,7 @@ private RealConnection newConnection(ConnectionPool pool, Route route, long idle
 
   private Address newAddress(String name) {
     return new Address(name, 1, Dns.SYSTEM, SocketFactory.getDefault(), null, null, null,
-        new RecordingOkAuthenticator("password"), null, Collections.<Protocol>emptyList(),
+        new RecordingOkAuthenticator("password", null), null, Collections.<Protocol>emptyList(),
         Collections.<ConnectionSpec>emptyList(),
         ProxySelector.getDefault());
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
index 399fbb2860..f5c8e75c85 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
@@ -19,16 +19,17 @@
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLException;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
 import org.junit.rules.Timeout;
 
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -37,7 +38,7 @@
   @Rule public final TestRule timeout = new Timeout(30_000);
   @Rule public final MockWebServer server = new MockWebServer();
 
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
   private OkHttpClient client = defaultClient();
 
   @Test public void connectionsAreReused() throws Exception {
@@ -191,7 +192,7 @@
 
     Request requestB = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "b"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "b"))
         .build();
     Response responseB = client.newCall(requestB).execute();
     assertEquals("b", responseB.body().string());
@@ -251,9 +252,10 @@
     response.body().close();
 
     // This client shares a connection pool but has a different SSL socket factory.
-    SslClient sslClient2 = new SslClient.Builder().build();
+    HandshakeCertificates handshakeCertificates2 = new HandshakeCertificates.Builder().build();
     OkHttpClient anotherClient = client.newBuilder()
-        .sslSocketFactory(sslClient2.socketFactory, sslClient2.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates2.sslSocketFactory(), handshakeCertificates2.trustManager())
         .build();
 
     // This client fails to connect because the new SSL socket factory refuses.
@@ -337,11 +339,12 @@ private void enableHttp2() {
 
   private void enableHttpsAndAlpn(Protocol... protocols) {
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .protocols(Arrays.asList(protocols))
         .build();
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.setProtocols(client.protocols());
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java b/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java
new file mode 100644
index 0000000000..2add4201e3
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.Security;
+import java.util.Arrays;
+import okhttp3.internal.platform.ConscryptPlatform;
+import okhttp3.internal.platform.Platform;
+import org.conscrypt.OpenSSLProvider;
+import org.junit.Assume;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+public class ConscryptTest {
+  public static final CipherSuite[] MANDATORY_CIPHER_SUITES = new CipherSuite[] {
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
+  };
+
+  private OkHttpClient client = buildClient();
+
+  private OkHttpClient buildClient() {
+    ConnectionSpec spec = new ConnectionSpec.Builder(true)
+        .cipherSuites(MANDATORY_CIPHER_SUITES) // Check we are using strong ciphers
+        .tlsVersions(TlsVersion.TLS_1_2) // and modern TLS
+        .supportsTlsExtensions(true)
+        .build();
+
+    return new OkHttpClient.Builder().connectionSpecs(Arrays.asList(spec)).build();
+  }
+
+  private static void assumeConscrypt() {
+    Assume.assumeTrue("conscrypt".equals(System.getProperty("okhttp.platform")));
+  }
+
+  private static void assumeNetwork() {
+    try {
+      InetAddress.getByName("www.google.com");
+    } catch (UnknownHostException uhe) {
+      Assume.assumeNoException(uhe);
+    }
+  }
+
+  @Test
+  public void testMozilla() throws IOException {
+    assumeNetwork();
+    assumeConscrypt();
+
+    Request request = new Request.Builder().url("https://mozilla.org/robots.txt").build();
+
+    Response response = client.newCall(request).execute();
+
+    assertEquals(Protocol.HTTP_2, response.protocol());
+  }
+
+  @Test
+  public void testGoogle() throws IOException {
+    assumeNetwork();
+    assumeConscrypt();
+
+    Request request = new Request.Builder().url("https://google.com/robots.txt").build();
+
+    Response response = client.newCall(request).execute();
+
+    assertEquals(Protocol.HTTP_2, response.protocol());
+  }
+
+  @Test
+  public void testBuild() {
+    assertNotNull(ConscryptPlatform.buildIfSupported());
+  }
+
+  @Test
+  public void testPreferred() {
+    Assume.assumeFalse(Platform.isConscryptPreferred());
+
+    try {
+      Security.insertProviderAt(new OpenSSLProvider(), 1);
+      assertTrue(Platform.isConscryptPreferred());
+    } finally {
+      Security.removeProvider("Conscrypt");
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CookieTest.java b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
index 12f543fac0..b38dd3dd9a 100644
--- a/okhttp-tests/src/test/java/okhttp3/CookieTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
@@ -33,7 +33,7 @@
 import static org.junit.Assert.fail;
 
 public final class CookieTest {
-  HttpUrl url = HttpUrl.parse("https://example.com/");
+  HttpUrl url = HttpUrl.get("https://example.com/");
 
   @Test public void simpleCookie() throws Exception {
     Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42");
@@ -216,83 +216,83 @@
 
   @Test public void domainMatches() throws Exception {
     Cookie cookie = Cookie.parse(url, "a=b; domain=example.com");
-    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://example.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://square.com")));
   }
 
   /** If no domain is present, match only the origin domain. */
   @Test public void domainMatchesNoDomain() throws Exception {
     Cookie cookie = Cookie.parse(url, "a=b");
-    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://square.com")));
   }
 
   /** Ignore an optional leading `.` in the domain. */
   @Test public void domainMatchesIgnoresLeadingDot() throws Exception {
     Cookie cookie = Cookie.parse(url, "a=b; domain=.example.com");
-    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://example.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://square.com")));
   }
 
   /** Ignore the entire attribute if the domain ends with `.`. */
   @Test public void domainIgnoredWithTrailingDot() throws Exception {
     Cookie cookie = Cookie.parse(url, "a=b; domain=example.com.");
-    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://square.com")));
   }
 
   @Test public void idnDomainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.parse("http://☃.net/"), "a=b; domain=☃.net");
-    assertTrue(cookie.matches(HttpUrl.parse("http://☃.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://xn--n3h.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.☃.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.xn--n3h.net/")));
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://☃.net/"), "a=b; domain=☃.net");
+    assertTrue(cookie.matches(HttpUrl.get("http://☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://xn--n3h.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.xn--n3h.net/")));
   }
 
   @Test public void punycodeDomainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.parse("http://xn--n3h.net/"), "a=b; domain=xn--n3h.net");
-    assertTrue(cookie.matches(HttpUrl.parse("http://☃.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://xn--n3h.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.☃.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.xn--n3h.net/")));
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://xn--n3h.net/"), "a=b; domain=xn--n3h.net");
+    assertTrue(cookie.matches(HttpUrl.get("http://☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://xn--n3h.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.☃.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.xn--n3h.net/")));
   }
 
   @Test public void domainMatchesIpAddress() throws Exception {
-    HttpUrl urlWithIp = HttpUrl.parse("http://123.45.234.56/");
+    HttpUrl urlWithIp = HttpUrl.get("http://123.45.234.56/");
     assertNull(Cookie.parse(urlWithIp, "a=b; domain=234.56"));
     assertEquals("123.45.234.56", Cookie.parse(urlWithIp, "a=b; domain=123.45.234.56").domain());
   }
 
   @Test public void domainMatchesIpv6Address() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.parse("http://[::1]/"), "a=b; domain=::1");
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::1");
     assertEquals("::1", cookie.domain());
-    assertTrue(cookie.matches(HttpUrl.parse("http://[::1]/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://[::1]/")));
   }
 
   @Test public void domainMatchesIpv6AddressWithCompression() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.parse("http://[0001:0000::]/"), "a=b; domain=0001:0000::");
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[0001:0000::]/"), "a=b; domain=0001:0000::");
     assertEquals("1::", cookie.domain());
-    assertTrue(cookie.matches(HttpUrl.parse("http://[1::]/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://[1::]/")));
   }
 
   @Test public void domainMatchesIpv6AddressWithIpv4Suffix() throws Exception {
     Cookie cookie = Cookie.parse(
-        HttpUrl.parse("http://[::1:ffff:ffff]/"), "a=b; domain=::1:255.255.255.255");
+        HttpUrl.get("http://[::1:ffff:ffff]/"), "a=b; domain=::1:255.255.255.255");
     assertEquals("::1:ffff:ffff", cookie.domain());
-    assertTrue(cookie.matches(HttpUrl.parse("http://[::1:ffff:ffff]/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://[::1:ffff:ffff]/")));
   }
 
   @Test public void ipv6AddressDoesntMatch() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.parse("http://[::1]/"), "a=b; domain=::2");
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::2");
     assertNull(cookie);
   }
 
   @Test public void ipv6AddressMalformed() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.parse("http://[::1]/"), "a=b; domain=::2::2");
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::2::2");
     assertEquals("::1", cookie.domain());
   }
 
@@ -302,16 +302,16 @@
    * present in the public suffix list.
    */
   @Test public void domainIsPublicSuffix() {
-    HttpUrl ascii = HttpUrl.parse("https://foo1.foo.bar.elb.amazonaws.com");
+    HttpUrl ascii = HttpUrl.get("https://foo1.foo.bar.elb.amazonaws.com");
     assertNotNull(Cookie.parse(ascii, "a=b; domain=foo.bar.elb.amazonaws.com"));
     assertNull(Cookie.parse(ascii, "a=b; domain=bar.elb.amazonaws.com"));
     assertNull(Cookie.parse(ascii, "a=b; domain=com"));
 
-    HttpUrl unicode = HttpUrl.parse("https://長.長.長崎.jp");
+    HttpUrl unicode = HttpUrl.get("https://長.長.長崎.jp");
     assertNotNull(Cookie.parse(unicode, "a=b; domain=長.長崎.jp"));
     assertNull(Cookie.parse(unicode, "a=b; domain=長崎.jp"));
 
-    HttpUrl punycode = HttpUrl.parse("https://xn--ue5a.xn--ue5a.xn--8ltr62k.jp");
+    HttpUrl punycode = HttpUrl.get("https://xn--ue5a.xn--ue5a.xn--8ltr62k.jp");
     assertNotNull(Cookie.parse(punycode, "a=b; domain=xn--ue5a.xn--8ltr62k.jp"));
     assertNull(Cookie.parse(punycode, "a=b; domain=xn--8ltr62k.jp"));
   }
@@ -322,23 +322,23 @@
   }
 
   @Test public void defaultPath() throws Exception {
-    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"), "a=b").path());
-    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/"), "a=b").path());
-    assertEquals("/", Cookie.parse(HttpUrl.parse("http://example.com/foo"), "a=b").path());
-    assertEquals("/", Cookie.parse(HttpUrl.parse("http://example.com/"), "a=b").path());
+    assertEquals("/foo", Cookie.parse(HttpUrl.get("http://example.com/foo/bar"), "a=b").path());
+    assertEquals("/foo", Cookie.parse(HttpUrl.get("http://example.com/foo/"), "a=b").path());
+    assertEquals("/", Cookie.parse(HttpUrl.get("http://example.com/foo"), "a=b").path());
+    assertEquals("/", Cookie.parse(HttpUrl.get("http://example.com/"), "a=b").path());
   }
 
   @Test public void defaultPathIsUsedIfPathDoesntHaveLeadingSlash() throws Exception {
-    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+    assertEquals("/foo", Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
         "a=b; path=quux").path());
-    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+    assertEquals("/foo", Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
         "a=b; path=").path());
   }
 
   @Test public void pathAttributeDoesntNeedToMatch() throws Exception {
-    assertEquals("/quux", Cookie.parse(HttpUrl.parse("http://example.com/"),
+    assertEquals("/quux", Cookie.parse(HttpUrl.get("http://example.com/"),
         "a=b; path=/quux").path());
-    assertEquals("/quux", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+    assertEquals("/quux", Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
         "a=b; path=/quux").path());
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/CookiesTest.java b/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
index ab2a955273..17489b045d 100644
--- a/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
@@ -276,7 +276,7 @@ public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
-    HttpUrl url = HttpUrl.parse("https://www.squareup.com/");
+    HttpUrl url = HttpUrl.get("https://www.squareup.com/");
     cookieJar.saveFromResponse(url, Arrays.asList(
         Cookie.parse(url, "a=android; Domain=squareup.com")));
     List<Cookie> actualCookies = cookieJar.loadForRequest(url);
@@ -289,7 +289,7 @@ public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
-    HttpUrl url = HttpUrl.parse("https://www.squareup.com/");
+    HttpUrl url = HttpUrl.get("https://www.squareup.com/");
     cookieJar.saveFromResponse(url, Arrays.asList(
         Cookie.parse(url, "a=android; Domain=.squareup.com")));
     List<Cookie> actualCookies = cookieJar.loadForRequest(url);
@@ -302,7 +302,7 @@ public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
-    HttpUrl url = HttpUrl.parse("https://squareup.com/");
+    HttpUrl url = HttpUrl.get("https://squareup.com/");
     cookieJar.saveFromResponse(url, Arrays.asList(
         Cookie.parse(url, "a=android; Domain=squareup.com")));
     List<Cookie> actualCookies = cookieJar.loadForRequest(url);
@@ -315,11 +315,11 @@ public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
-    HttpUrl url1 = HttpUrl.parse("https://api.squareup.com/");
+    HttpUrl url1 = HttpUrl.get("https://api.squareup.com/");
     cookieJar.saveFromResponse(url1, Arrays.asList(
         Cookie.parse(url1, "a=android; Domain=api.squareup.com")));
 
-    HttpUrl url2 = HttpUrl.parse("https://www.squareup.com/");
+    HttpUrl url2 = HttpUrl.get("https://www.squareup.com/");
     List<Cookie> actualCookies = cookieJar.loadForRequest(url2);
     assertEquals(Collections.<Cookie>emptyList(), actualCookies);
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
index 5c5350e61c..80cdb78cfd 100644
--- a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
@@ -1,6 +1,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -10,6 +11,7 @@
 import java.util.Set;
 import java.util.concurrent.AbstractExecutorService;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import okhttp3.RealCall.AsyncCall;
@@ -28,13 +30,16 @@
   RecordingCallback callback = new RecordingCallback();
   RecordingWebSocketListener webSocketListener = new RecordingWebSocketListener();
   Dispatcher dispatcher = new Dispatcher(executor);
+  RecordingEventListener listener = new RecordingEventListener();
   OkHttpClient client = defaultClient().newBuilder()
       .dispatcher(dispatcher)
+      .eventListener(listener)
       .build();
 
   @Before public void setUp() throws Exception {
     dispatcher.setMaxRequests(20);
     dispatcher.setMaxRequestsPerHost(10);
+    listener.forbidLock(dispatcher);
   }
 
   @Test public void maxRequestsZero() throws Exception {
@@ -225,7 +230,7 @@
     assertFalse(a4.isCanceled());
   }
 
-  @Test public void idleCallbackInvokedWhenIdle() throws InterruptedException {
+  @Test public void idleCallbackInvokedWhenIdle() throws Exception {
     final AtomicBoolean idle = new AtomicBoolean();
     dispatcher.setIdleCallback(new Runnable() {
       @Override public void run() {
@@ -264,6 +269,54 @@
     assertTrue(idle.get());
   }
 
+  @Test public void executionRejectedImmediately() throws Exception {
+    Request request = newRequest("http://a/1");
+    executor.shutdown();
+    client.newCall(request).enqueue(callback);
+    callback.await(request.url()).assertFailure(InterruptedIOException.class);
+    assertEquals(Arrays.asList("CallStart", "CallFailed"), listener.recordedEventTypes());
+  }
+
+  @Test public void executionRejectedAfterMaxRequestsChange() throws Exception {
+    Request request1 = newRequest("http://a/1");
+    Request request2 = newRequest("http://a/2");
+    dispatcher.setMaxRequests(1);
+    client.newCall(request1).enqueue(callback);
+    executor.shutdown();
+    client.newCall(request2).enqueue(callback);
+    dispatcher.setMaxRequests(2); // Trigger promotion.
+    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
+
+    assertEquals(Arrays.asList("CallStart", "CallStart", "CallFailed"),
+        listener.recordedEventTypes());
+  }
+
+  @Test public void executionRejectedAfterMaxRequestsPerHostChange() throws Exception {
+    Request request1 = newRequest("http://a/1");
+    Request request2 = newRequest("http://a/2");
+    dispatcher.setMaxRequestsPerHost(1);
+    client.newCall(request1).enqueue(callback);
+    executor.shutdown();
+    client.newCall(request2).enqueue(callback);
+    dispatcher.setMaxRequestsPerHost(2); // Trigger promotion.
+    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
+    assertEquals(Arrays.asList("CallStart", "CallStart", "CallFailed"),
+        listener.recordedEventTypes());
+  }
+
+  @Test public void executionRejectedAfterPrecedingCallFinishes() throws Exception {
+    Request request1 = newRequest("http://a/1");
+    Request request2 = newRequest("http://a/2");
+    dispatcher.setMaxRequests(1);
+    client.newCall(request1).enqueue(callback);
+    executor.shutdown();
+    client.newCall(request2).enqueue(callback);
+    executor.finishJob("http://a/1"); // Trigger promotion.
+    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
+    assertEquals(Arrays.asList("CallStart", "CallStart", "CallFailed"),
+        listener.recordedEventTypes());
+  }
+
   private <T> Set<T> set(T... values) {
     return set(Arrays.asList(values));
   }
@@ -287,9 +340,11 @@ private Thread makeSynchronousCall(final Call call) {
   }
 
   class RecordingExecutor extends AbstractExecutorService {
+    private boolean shutdown;
     private List<AsyncCall> calls = new ArrayList<>();
 
     @Override public void execute(Runnable command) {
+      if (shutdown) throw new RejectedExecutionException();
       calls.add((AsyncCall) command);
     }
 
@@ -314,7 +369,7 @@ public void finishJob(String url) {
     }
 
     @Override public void shutdown() {
-      throw new UnsupportedOperationException();
+      shutdown = true;
     }
 
     @Override public List<Runnable> shutdownNow() {
@@ -329,8 +384,7 @@ public void finishJob(String url) {
       throw new UnsupportedOperationException();
     }
 
-    @Override public boolean awaitTermination(long timeout, TimeUnit unit)
-        throws InterruptedException {
+    @Override public boolean awaitTermination(long timeout, TimeUnit unit) {
       throw new UnsupportedOperationException();
     }
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
index c31746a57c..14758e244c 100644
--- a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
@@ -42,11 +42,11 @@
 import okhttp3.RecordingEventListener.SecureConnectStart;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.logging.HttpLoggingInterceptor;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import org.hamcrest.BaseMatcher;
@@ -61,6 +61,7 @@
 
 import static java.util.Arrays.asList;
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.hamcrest.CoreMatchers.any;
 import static org.hamcrest.CoreMatchers.either;
 import static org.hamcrest.CoreMatchers.equalTo;
@@ -78,16 +79,14 @@
   public static final Matcher<Response> anyResponse = CoreMatchers.any(Response.class);
   @Rule public final MockWebServer server = new MockWebServer();
 
-  private final SingleInetAddressDns singleDns = new SingleInetAddressDns();
   private final RecordingEventListener listener = new RecordingEventListener();
-  private final SslClient sslClient = SslClient.localhost();
+  private final HandshakeCertificates handshakeCertificates = localhost();
 
   private OkHttpClient client;
   private SocksProxy socksProxy;
 
-  @Before public void setUp() throws IOException {
+  @Before public void setUp() {
     client = defaultClient().newBuilder()
-        .dns(singleDns)
         .eventListener(listener)
         .build();
 
@@ -134,7 +133,7 @@
         completionLatch.countDown();
       }
 
-      @Override public void onResponse(Call call, Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) {
         response.close();
         completionLatch.countDown();
       }
@@ -151,8 +150,8 @@
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
-  @Test public void failedCallEventSequence() throws IOException {
-    server.enqueue(new MockResponse().setBodyDelay(2, TimeUnit.SECONDS));
+  @Test public void failedCallEventSequence() {
+    server.enqueue(new MockResponse().setHeadersDelay(2, TimeUnit.SECONDS));
 
     client = client.newBuilder().readTimeout(250, TimeUnit.MILLISECONDS).build();
 
@@ -172,7 +171,38 @@
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
-  @Test public void canceledCallEventSequence() throws IOException {
+  @Test public void failedDribbledCallEventSequence() throws IOException {
+    server.enqueue(new MockResponse().setBody("0123456789")
+        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    client = client.newBuilder()
+        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
+        .readTimeout(250, TimeUnit.MILLISECONDS)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    try {
+      response.body.string();
+      fail();
+    } catch (IOException expected) {
+      assertThat(expected.getMessage(), equalTo("unexpected end of stream"));
+    }
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallFailed");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+    ResponseBodyEnd bodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);
+    assertEquals(5, bodyEnd.bytesRead);
+  }
+
+  @Test public void canceledCallEventSequence() {
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
@@ -404,8 +434,8 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     server.enqueue(new MockResponse());
 
     FakeDns dns = new FakeDns();
-    dns.set("fakeurl", singleDns.lookup(server.getHostName()));
-    dns.set("www.fakeurl", singleDns.lookup(server.getHostName()));
+    dns.set("fakeurl", client.dns().lookup(server.getHostName()));
+    dns.set("www.fakeurl", client.dns().lookup(server.getHostName()));
 
     client = client.newBuilder()
         .dns(dns)
@@ -446,7 +476,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
 
   @Test public void emptyDnsLookup() {
     Dns emptyDns = new Dns() {
-      @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+      @Override public List<InetAddress> lookup(String hostname) {
         return Collections.emptyList();
       }
     };
@@ -480,7 +510,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     assertEquals(200, response.code());
     response.body().close();
 
-    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
     InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
 
     ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
@@ -508,7 +538,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     } catch (IOException expected) {
     }
 
-    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
     InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
 
     ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
@@ -560,7 +590,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     assertEquals(200, response.code());
     response.body().close();
 
-    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
     InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
 
     ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
@@ -618,7 +648,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
 
     client = client.newBuilder()
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .build();
 
     Call call = client.newCall(new Request.Builder()
@@ -878,7 +908,6 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
     assertNotNull(callFailed.ioe);
   }
 
-  @Ignore("the CallEnd event is omitted")
   @Test public void emptyResponseBody() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("")
@@ -934,14 +963,14 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
     requestBodyFail();
   }
 
-  private void requestBodyFail() throws IOException {
+  private void requestBodyFail() {
     // Stream a 8 MiB body so the disconnect will happen before the server has read everything.
     RequestBody requestBody = new RequestBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain");
+        return MediaType.get("text/plain");
       }
 
-      @Override public long contentLength() throws IOException {
+      @Override public long contentLength() {
         return 1024 * 8192;
       }
 
@@ -973,26 +1002,26 @@ private void requestBodyFail() throws IOException {
   @Test public void requestBodySuccessHttp1OverHttps() throws IOException {
     enableTlsWithTunnel(false);
     server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
-    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), "Hello"), equalTo(5L),
+    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
         equalTo(19L));
   }
 
   @Test public void requestBodySuccessHttp2OverHttps() throws IOException {
     enableTlsWithTunnel(false);
     server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), "Hello"), equalTo(5L),
+    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
         equalTo(19L));
   }
 
   @Test public void requestBodySuccessHttp() throws IOException {
-    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), "Hello"), equalTo(5L),
+    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
         equalTo(19L));
   }
 
   @Test public void requestBodySuccessStreaming() throws IOException {
     RequestBody requestBody = new RequestBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain");
+        return MediaType.get("text/plain");
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
@@ -1005,10 +1034,31 @@ private void requestBodyFail() throws IOException {
   }
 
   @Test public void requestBodySuccessEmpty() throws IOException {
-    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), ""), equalTo(0L),
+    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), ""), equalTo(0L),
         equalTo(19L));
   }
 
+  @Test public void successfulCallEventSequenceWithListener() throws IOException {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    client = client.newBuilder().addNetworkInterceptor(new HttpLoggingInterceptor().setLevel(
+        HttpLoggingInterceptor.Level.BODY)).build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    assertEquals("abc", response.body().string());
+    response.body().close();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
   private void requestBodySuccess(RequestBody body, Matcher<Long> requestBodyBytes,
       Matcher<Long> responseHeaderLength) throws IOException {
     server.enqueue(new MockResponse().setResponseCode(200).setBody("World!"));
@@ -1026,9 +1076,10 @@ private void requestBodySuccess(RequestBody body, Matcher<Long> requestBodyBytes
 
   private void enableTlsWithTunnel(boolean tunnelProxy) {
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
-    server.useHttps(sslClient.socketFactory, tunnelProxy);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), tunnelProxy);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
index 24dfe878d1..494ac90b85 100644
--- a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
@@ -18,19 +18,25 @@
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.Date;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http2.Header;
 import okhttp3.internal.http2.Http2Codec;
+import org.junit.Ignore;
 import org.junit.Test;
 
+import static java.util.Collections.emptyList;
+import static java.util.Collections.emptyMap;
+import static java.util.Collections.singletonList;
+import static java.util.Collections.singletonMap;
 import static okhttp3.TestUtil.headerEntries;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -40,12 +46,12 @@
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
-    List<Header> headerBlock = headerEntries(
+    Headers headerBlock = Headers.of(
         ":status", "200 OK",
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = Http2Codec.readHttp2HeadersList(headerBlock).request(request).build();
+    Response response = Http2Codec.readHttp2HeadersList(headerBlock, Protocol.HTTP_2).request(request).build();
     Headers headers = response.headers();
     assertEquals(1, headers.size());
     assertEquals(":version", headers.name(0));
@@ -117,6 +123,25 @@
     }
   }
 
+  @Test public void addUnsafeNonAsciiRejectsUnicodeName() {
+    try {
+      Headers headers = new Headers.Builder()
+          .addUnsafeNonAscii("héader1", "value1")
+          .build();
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 1 in header name: héader1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void addUnsafeNonAsciiAcceptsUnicodeValue() {
+    Headers headers = new Headers.Builder()
+        .addUnsafeNonAscii("header1", "valué1")
+        .build();
+    assertEquals("header1: valué1\n", headers.toString());
+  }
+
   @Test public void ofThrowsOddNumberOfHeaders() {
     try {
       Headers.of("User-Agent", "OkHttp", "Content-Length");
@@ -156,7 +181,7 @@
     assertEquals("OkHttp", headers.value(0));
   }
 
-  @Test public void ofRejectsNulChar() {
+  @Test public void ofRejectsNullChar() {
     try {
       Headers.of("User-Agent", "Square\u0000OkHttp");
       fail();
@@ -174,7 +199,7 @@
 
   @Test public void ofMapThrowsOnEmptyName() {
     try {
-      Headers.of(Collections.singletonMap("", "OkHttp"));
+      Headers.of(singletonMap("", "OkHttp"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -182,24 +207,24 @@
 
   @Test public void ofMapThrowsOnBlankName() {
     try {
-      Headers.of(Collections.singletonMap(" ", "OkHttp"));
+      Headers.of(singletonMap(" ", "OkHttp"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
   @Test public void ofMapAcceptsEmptyValue() {
-    Headers headers = Headers.of(Collections.singletonMap("User-Agent", ""));
+    Headers headers = Headers.of(singletonMap("User-Agent", ""));
     assertEquals("", headers.value(0));
   }
 
   @Test public void ofMapTrimsKey() {
-    Headers headers = Headers.of(Collections.singletonMap(" User-Agent ", "OkHttp"));
+    Headers headers = Headers.of(singletonMap(" User-Agent ", "OkHttp"));
     assertEquals("User-Agent", headers.name(0));
   }
 
   @Test public void ofMapTrimsValue() {
-    Headers headers = Headers.of(Collections.singletonMap("User-Agent", " OkHttp "));
+    Headers headers = Headers.of(singletonMap("User-Agent", " OkHttp "));
     assertEquals("OkHttp", headers.value(0));
   }
 
@@ -212,17 +237,17 @@
     assertEquals("OkHttp", headers.value(0));
   }
 
-  @Test public void ofMapRejectsNulCharInName() {
+  @Test public void ofMapRejectsNullCharInName() {
     try {
-      Headers.of(Collections.singletonMap("User-Agent", "Square\u0000OkHttp"));
+      Headers.of(singletonMap("User-\u0000Agent", "OkHttp"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
-  @Test public void ofMapRejectsNulCharInValue() {
+  @Test public void ofMapRejectsNullCharInValue() {
     try {
-      Headers.of(Collections.singletonMap("User-\u0000Agent", "OkHttp"));
+      Headers.of(singletonMap("User-Agent", "Square\u0000OkHttp"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -250,8 +275,8 @@
 
   @Test public void toMultimapAllowsCaseInsensitiveGet() {
     Headers headers = Headers.of(
-            "cache-control", "no-store",
-            "Cache-Control", "no-cache");
+        "cache-control", "no-store",
+        "Cache-Control", "no-cache");
     Map<String, List<String>> headerMap = headers.toMultimap();
     assertEquals(2, headerMap.get("cache-control").size());
     assertEquals(2, headerMap.get("Cache-Control").size());
@@ -309,6 +334,46 @@
     }
   }
 
+  @Test public void varargFactoryRejectsUnicodeInHeaderName() {
+    try {
+      Headers.of("héader1", "value1");
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 1 in header name: héader1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void varargFactoryRejectsUnicodeInHeaderValue() {
+    try {
+      Headers.of("header1", "valué1");
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 4 in header1 value: valué1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void mapFactoryRejectsUnicodeInHeaderName() {
+    try {
+      Headers.of(singletonMap("héader1", "value1"));
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 1 in header name: héader1",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void mapFactoryRejectsUnicodeInHeaderValue() {
+    try {
+      Headers.of(singletonMap("header1", "valué1"));
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertEquals("Unexpected char 0xe9 at 4 in header1 value: valué1",
+          expected.getMessage());
+    }
+  }
+
   @Test public void headersEquals() {
     Headers headers1 = new Headers.Builder()
         .add("Connection", "close")
@@ -343,9 +408,22 @@
     assertEquals("A: a\nB: bb\n", headers.toString());
   }
 
+  @Test public void headersAddAll() {
+    Headers sourceHeaders = new Headers.Builder()
+        .add("A", "aa")
+        .add("a", "aa")
+        .add("B", "bb")
+        .build();
+    Headers headers = new Headers.Builder()
+        .add("A", "a")
+        .addAll(sourceHeaders)
+        .add("C", "c")
+        .build();
+    assertEquals("A: a\nA: aa\na: aa\nB: bb\nC: c\n", headers.toString());
+  }
+
   /** See https://github.com/square/okhttp/issues/2780. */
-  @Test public void testDigestChallenges() {
-    // Strict RFC 2617 header.
+  @Test public void testDigestChallengeWithStrictRfc2617Header() {
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
             + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
@@ -354,93 +432,160 @@
     assertEquals(1, challenges.size());
     assertEquals("Digest", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Not strict RFC 2617 header.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithDifferentlyOrderedAuthParams() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest qop=\"auth\", realm=\"myrealm\", nonce=\"fjalskdflwejrlask"
             + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("Digest", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Not strict RFC 2617 header #2.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithDifferentlyOrderedAuthParams2() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest qop=\"auth\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaksjdflk"
             + "asdf\", realm=\"myrealm\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("Digest", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Wrong header.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithMissingRealm() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest qop=\"auth\", underrealm=\"myrealm\", nonce=\"fjalskdflwej"
             + "rlaskdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(0, challenges.size());
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertNull(challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("underrealm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Not strict RFC 2617 header with some spaces.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithAdditionalSpaces() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest qop=\"auth\",    realm=\"myrealm\", nonce=\"fjalskdflwejrl"
             + "askdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("Digest", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Strict RFC 2617 header with some spaces.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithAdditionalSpacesBeforeFirstAuthParam() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest    realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjfl"
             + "aksjdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("Digest", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Not strict RFC 2617 camelcased.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithCamelCasedNames() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "DiGeSt qop=\"auth\", rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlask"
             + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("DiGeSt", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
+  @Test public void testDigestChallengeWithCamelCasedNames2() {
     // Strict RFC 2617 camelcased.
-    headers = new Headers.Builder()
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "DIgEsT rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
             + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
         .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(1, challenges.size());
     assertEquals("DIgEsT", challenges.get(0).scheme());
     assertEquals("myrealm", challenges.get(0).realm());
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+  }
 
-    // Unquoted.
-    headers = new Headers.Builder()
+  @Test public void testDigestChallengeWithTokenFormOfAuthParam() {
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest realm=myrealm").build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(0, challenges.size());
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertEquals("myrealm", challenges.get(0).realm());
+    assertEquals(singletonMap("realm", "myrealm"), challenges.get(0).authParams());
+  }
 
+  @Test public void testDigestChallengeWithoutAuthParams() {
     // Scheme only.
-    headers = new Headers.Builder()
+    Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest").build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(0, challenges.size());
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertEquals(1, challenges.size());
+    assertEquals("Digest", challenges.get(0).scheme());
+    assertNull(challenges.get(0).realm());
+    assertEquals(emptyMap(), challenges.get(0).authParams());
   }
 
   @Test public void basicChallenge() {
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate: Basic realm=\"protected area\"")
         .build();
-    assertEquals(Arrays.asList(new Challenge("Basic", "protected area")),
+    assertEquals(singletonList(new Challenge("Basic", singletonMap("realm", "protected area"))),
         HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
   }
 
@@ -448,7 +593,10 @@
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
         .build();
-    assertEquals(Arrays.asList(new Challenge("Basic", "protected area").withCharset(Util.UTF_8)),
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "protected area");
+    expectedAuthParams.put("charset", "UTF-8");
+    assertEquals(singletonList(new Challenge("Basic", expectedAuthParams)),
         HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
   }
 
@@ -456,7 +604,209 @@
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"US-ASCII\"")
         .build();
-    assertEquals(Collections.emptyList(), HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "protected area");
+    expectedAuthParams.put("charset", "US-ASCII");
+    assertEquals(singletonList(new Challenge("Basic", expectedAuthParams)),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void separatorsBeforeFirstChallenge() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", " ,  , Basic realm=myrealm")
+        .build();
+    assertEquals(singletonList(new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void spacesAroundKeyValueSeparator() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm = \"myrealm\"")
+        .build();
+    assertEquals(singletonList(new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleChallengesInOneHeader() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm = \"myrealm\",Digest")
+        .build();
+    assertEquals(Arrays.asList(
+        new Challenge("Basic", singletonMap("realm", "myrealm")),
+        new Challenge("Digest", Collections.<String, String>emptyMap())),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleChallengesWithSameSchemeButDifferentRealmInOneHeader() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm = \"myrealm\",Basic realm=myotherrealm")
+        .build();
+    assertEquals(Arrays.asList(
+        new Challenge("Basic", singletonMap("realm", "myrealm")),
+        new Challenge("Basic", singletonMap("realm", "myotherrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void separatorsBeforeFirstAuthParam() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest, Basic ,,realm=\"myrealm\"")
+        .build();
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void onlyCommaBetweenChallenges() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,Basic realm=\"myrealm\"")
+        .build();
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleSeparatorsBetweenChallenges() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,realm=\"myrealm\"")
+        .build();
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void unknownAuthParams() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,foo=bar,realm=\"myrealm\"")
+        .build();
+
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("foo", "bar");
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap()),
+        new Challenge("Basic", expectedAuthParams)),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void escapedCharactersInQuotedString() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\\\\\\\"r\\ealm\"")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "my\\\"realm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void commaInQuotedStringAndBeforeFirstChallenge() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", ",Digest,,,, Basic ,,,realm=\"my, realm,\"")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "my, realm,"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void unescapedDoubleQuoteInQuotedStringWithEvenNumberOfBackslashesInFront() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\\\\\\\\\"r\\ealm\"")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap())),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void unescapedDoubleQuoteInQuotedString() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\"realm\"")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap())),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Ignore("TODO(jwilson): reject parameters that use invalid characters")
+  @Test public void doubleQuoteInToken() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=my\"realm")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap())),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void token68InsteadOfAuthParams() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Other abc==")
+        .build();
+
+    assertEquals(singletonList(
+        new Challenge("Other", singletonMap(((String) null), "abc=="))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void token68AndAuthParams() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Other abc==, realm=myrealm")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Other", singletonMap((String) null, "abc=="))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void repeatedAuthParamKey() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Other realm=myotherrealm, realm=myrealm")
+        .build();
+
+    assertEquals(emptyList(), HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleAuthenticateHeaders() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest")
+        .add("WWW-Authenticate", "Basic realm=myrealm")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Digest", Collections.<String, String>emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "myrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleAuthenticateHeadersInDifferentOrder() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm=myrealm")
+        .add("WWW-Authenticate", "Digest")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Basic", singletonMap("realm", "myrealm")),
+        new Challenge("Digest", Collections.<String, String>emptyMap())),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void multipleBasicAuthenticateHeaders() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm=myrealm")
+        .add("WWW-Authenticate", "Basic realm=myotherrealm")
+        .build();
+
+    assertEquals(Arrays.asList(
+        new Challenge("Basic", singletonMap("realm", "myrealm")),
+        new Challenge("Basic", singletonMap("realm", "myotherrealm"))),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
   }
 
   @Test public void byteCount() {
@@ -471,4 +821,43 @@
         .build()
         .byteCount());
   }
+
+  @Test public void addDate() {
+    Date expected = new Date(0);
+    Headers headers = new Headers.Builder()
+        .add("testDate", expected)
+        .build();
+    assertEquals("Thu, 01 Jan 1970 00:00:00 GMT", headers.get("testDate"));
+  }
+
+  @Test public void addDateNull() {
+    try {
+      new Headers.Builder()
+          .add("testDate", (Date) null)
+          .build();
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("value for name testDate == null", expected.getMessage());
+    }
+  }
+
+  @Test public void setDate() {
+    Date expected = new Date(1000);
+    Headers headers = new Headers.Builder()
+        .add("testDate", new Date(0))
+        .set("testDate", expected)
+        .build();
+    assertEquals("Thu, 01 Jan 1970 00:00:01 GMT", headers.get("testDate"));
+  }
+
+  @Test public void setDateNull() {
+    try {
+      new Headers.Builder()
+          .set("testDate", (Date) null)
+          .build();
+      fail();
+    } catch (NullPointerException expected) {
+      assertEquals("value for name testDate == null", expected.getMessage());
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
index a51830e78c..e780d8bd9b 100644
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -15,109 +15,129 @@
  */
 package okhttp3;
 
-import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URL;
-import java.net.UnknownHostException;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import okhttp3.UrlComponentEncodingTester.Component;
 import okhttp3.UrlComponentEncodingTester.Encoding;
 import org.junit.Ignore;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
 import static java.util.Collections.singletonList;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
+@RunWith(Parameterized.class)
 public final class HttpUrlTest {
+  @Parameterized.Parameters(name = "Use get = {0}")
+  public static Collection<Object[]> parameters() {
+    return Arrays.asList(
+        new Object[] { true },
+        new Object[] { false }
+    );
+  }
+  
+  @Parameterized.Parameter
+  public boolean useGet;
+  
+  HttpUrl parse(String url) {
+    return useGet
+        ? HttpUrl.get(url)
+        : HttpUrl.parse(url);
+  }
+  
   @Test public void parseTrimsAsciiWhitespace() throws Exception {
-    HttpUrl expected = HttpUrl.parse("http://host/");
-    assertEquals(expected, HttpUrl.parse("http://host/\f\n\t \r")); // Leading.
-    assertEquals(expected, HttpUrl.parse("\r\n\f \thttp://host/")); // Trailing.
-    assertEquals(expected, HttpUrl.parse(" http://host/ ")); // Both.
-    assertEquals(expected, HttpUrl.parse("    http://host/    ")); // Both.
-    assertEquals(expected, HttpUrl.parse("http://host/").resolve("   "));
-    assertEquals(expected, HttpUrl.parse("http://host/").resolve("  .  "));
+    HttpUrl expected = parse("http://host/");
+    assertEquals(expected, parse("http://host/\f\n\t \r")); // Leading.
+    assertEquals(expected, parse("\r\n\f \thttp://host/")); // Trailing.
+    assertEquals(expected, parse(" http://host/ ")); // Both.
+    assertEquals(expected, parse("    http://host/    ")); // Both.
+    assertEquals(expected, parse("http://host/").resolve("   "));
+    assertEquals(expected, parse("http://host/").resolve("  .  "));
   }
 
   @Test public void parseHostAsciiNonPrintable() throws Exception {
     String host = "host\u0001";
-    assertNull(HttpUrl.parse("http://" + host + "/"));
+    assertInvalid("http://" + host + "/", "Invalid URL host: \"host\u0001\"");
+    // TODO make exception message escape non-printable characters
   }
 
   @Test public void parseDoesNotTrimOtherWhitespaceCharacters() throws Exception {
     // Whitespace characters list from Google's Guava team: http://goo.gl/IcR9RD
-    assertEquals("/%0B", HttpUrl.parse("http://h/\u000b").encodedPath()); // line tabulation
-    assertEquals("/%1C", HttpUrl.parse("http://h/\u001c").encodedPath()); // information separator 4
-    assertEquals("/%1D", HttpUrl.parse("http://h/\u001d").encodedPath()); // information separator 3
-    assertEquals("/%1E", HttpUrl.parse("http://h/\u001e").encodedPath()); // information separator 2
-    assertEquals("/%1F", HttpUrl.parse("http://h/\u001f").encodedPath()); // information separator 1
-    assertEquals("/%C2%85", HttpUrl.parse("http://h/\u0085").encodedPath()); // next line
-    assertEquals("/%C2%A0", HttpUrl.parse("http://h/\u00a0").encodedPath()); // non-breaking space
-    assertEquals("/%E1%9A%80", HttpUrl.parse("http://h/\u1680").encodedPath()); // ogham space mark
-    assertEquals("/%E1%A0%8E", HttpUrl.parse("http://h/\u180e").encodedPath()); // mongolian vowel separator
-    assertEquals("/%E2%80%80", HttpUrl.parse("http://h/\u2000").encodedPath()); // en quad
-    assertEquals("/%E2%80%81", HttpUrl.parse("http://h/\u2001").encodedPath()); // em quad
-    assertEquals("/%E2%80%82", HttpUrl.parse("http://h/\u2002").encodedPath()); // en space
-    assertEquals("/%E2%80%83", HttpUrl.parse("http://h/\u2003").encodedPath()); // em space
-    assertEquals("/%E2%80%84", HttpUrl.parse("http://h/\u2004").encodedPath()); // three-per-em space
-    assertEquals("/%E2%80%85", HttpUrl.parse("http://h/\u2005").encodedPath()); // four-per-em space
-    assertEquals("/%E2%80%86", HttpUrl.parse("http://h/\u2006").encodedPath()); // six-per-em space
-    assertEquals("/%E2%80%87", HttpUrl.parse("http://h/\u2007").encodedPath()); // figure space
-    assertEquals("/%E2%80%88", HttpUrl.parse("http://h/\u2008").encodedPath()); // punctuation space
-    assertEquals("/%E2%80%89", HttpUrl.parse("http://h/\u2009").encodedPath()); // thin space
-    assertEquals("/%E2%80%8A", HttpUrl.parse("http://h/\u200a").encodedPath()); // hair space
-    assertEquals("/%E2%80%8B", HttpUrl.parse("http://h/\u200b").encodedPath()); // zero-width space
-    assertEquals("/%E2%80%8C", HttpUrl.parse("http://h/\u200c").encodedPath()); // zero-width non-joiner
-    assertEquals("/%E2%80%8D", HttpUrl.parse("http://h/\u200d").encodedPath()); // zero-width joiner
-    assertEquals("/%E2%80%8E", HttpUrl.parse("http://h/\u200e").encodedPath()); // left-to-right mark
-    assertEquals("/%E2%80%8F", HttpUrl.parse("http://h/\u200f").encodedPath()); // right-to-left mark
-    assertEquals("/%E2%80%A8", HttpUrl.parse("http://h/\u2028").encodedPath()); // line separator
-    assertEquals("/%E2%80%A9", HttpUrl.parse("http://h/\u2029").encodedPath()); // paragraph separator
-    assertEquals("/%E2%80%AF", HttpUrl.parse("http://h/\u202f").encodedPath()); // narrow non-breaking space
-    assertEquals("/%E2%81%9F", HttpUrl.parse("http://h/\u205f").encodedPath()); // medium mathematical space
-    assertEquals("/%E3%80%80", HttpUrl.parse("http://h/\u3000").encodedPath()); // ideographic space
+    assertEquals("/%0B", parse("http://h/\u000b").encodedPath()); // line tabulation
+    assertEquals("/%1C", parse("http://h/\u001c").encodedPath()); // information separator 4
+    assertEquals("/%1D", parse("http://h/\u001d").encodedPath()); // information separator 3
+    assertEquals("/%1E", parse("http://h/\u001e").encodedPath()); // information separator 2
+    assertEquals("/%1F", parse("http://h/\u001f").encodedPath()); // information separator 1
+    assertEquals("/%C2%85", parse("http://h/\u0085").encodedPath()); // next line
+    assertEquals("/%C2%A0", parse("http://h/\u00a0").encodedPath()); // non-breaking space
+    assertEquals("/%E1%9A%80", parse("http://h/\u1680").encodedPath()); // ogham space mark
+    assertEquals("/%E1%A0%8E", parse("http://h/\u180e").encodedPath()); // mongolian vowel separator
+    assertEquals("/%E2%80%80", parse("http://h/\u2000").encodedPath()); // en quad
+    assertEquals("/%E2%80%81", parse("http://h/\u2001").encodedPath()); // em quad
+    assertEquals("/%E2%80%82", parse("http://h/\u2002").encodedPath()); // en space
+    assertEquals("/%E2%80%83", parse("http://h/\u2003").encodedPath()); // em space
+    assertEquals("/%E2%80%84", parse("http://h/\u2004").encodedPath()); // three-per-em space
+    assertEquals("/%E2%80%85", parse("http://h/\u2005").encodedPath()); // four-per-em space
+    assertEquals("/%E2%80%86", parse("http://h/\u2006").encodedPath()); // six-per-em space
+    assertEquals("/%E2%80%87", parse("http://h/\u2007").encodedPath()); // figure space
+    assertEquals("/%E2%80%88", parse("http://h/\u2008").encodedPath()); // punctuation space
+    assertEquals("/%E2%80%89", parse("http://h/\u2009").encodedPath()); // thin space
+    assertEquals("/%E2%80%8A", parse("http://h/\u200a").encodedPath()); // hair space
+    assertEquals("/%E2%80%8B", parse("http://h/\u200b").encodedPath()); // zero-width space
+    assertEquals("/%E2%80%8C", parse("http://h/\u200c").encodedPath()); // zero-width non-joiner
+    assertEquals("/%E2%80%8D", parse("http://h/\u200d").encodedPath()); // zero-width joiner
+    assertEquals("/%E2%80%8E", parse("http://h/\u200e").encodedPath()); // left-to-right mark
+    assertEquals("/%E2%80%8F", parse("http://h/\u200f").encodedPath()); // right-to-left mark
+    assertEquals("/%E2%80%A8", parse("http://h/\u2028").encodedPath()); // line separator
+    assertEquals("/%E2%80%A9", parse("http://h/\u2029").encodedPath()); // paragraph separator
+    assertEquals("/%E2%80%AF", parse("http://h/\u202f").encodedPath()); // narrow non-breaking space
+    assertEquals("/%E2%81%9F", parse("http://h/\u205f").encodedPath()); // medium mathematical space
+    assertEquals("/%E3%80%80", parse("http://h/\u3000").encodedPath()); // ideographic space
   }
 
   @Test public void scheme() throws Exception {
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host/"));
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("Http://host/"));
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host/"));
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("HTTP://host/"));
-    assertEquals(HttpUrl.parse("https://host/"), HttpUrl.parse("https://host/"));
-    assertEquals(HttpUrl.parse("https://host/"), HttpUrl.parse("HTTPS://host/"));
-    assertEquals(HttpUrl.Builder.ParseResult.UNSUPPORTED_SCHEME,
-        new HttpUrl.Builder().parse(null, "image640://480.png"));
-    assertEquals(null, HttpUrl.parse("httpp://host/"));
-    assertEquals(null, HttpUrl.parse("0ttp://host/"));
-    assertEquals(null, HttpUrl.parse("ht+tp://host/"));
-    assertEquals(null, HttpUrl.parse("ht.tp://host/"));
-    assertEquals(null, HttpUrl.parse("ht-tp://host/"));
-    assertEquals(null, HttpUrl.parse("ht1tp://host/"));
-    assertEquals(null, HttpUrl.parse("httpss://host/"));
+    assertEquals(parse("http://host/"), parse("http://host/"));
+    assertEquals(parse("http://host/"), parse("Http://host/"));
+    assertEquals(parse("http://host/"), parse("http://host/"));
+    assertEquals(parse("http://host/"), parse("HTTP://host/"));
+    assertEquals(parse("https://host/"), parse("https://host/"));
+    assertEquals(parse("https://host/"), parse("HTTPS://host/"));
+
+    assertInvalid("image640://480.png", "Expected URL scheme 'http' or 'https' but was 'image640'");
+    assertInvalid("httpp://host/", "Expected URL scheme 'http' or 'https' but was 'httpp'");
+    assertInvalid("0ttp://host/", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("ht+tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht+tp'");
+    assertInvalid("ht.tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht.tp'");
+    assertInvalid("ht-tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht-tp'");
+    assertInvalid("ht1tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht1tp'");
+    assertInvalid("httpss://host/", "Expected URL scheme 'http' or 'https' but was 'httpss'");
   }
 
   @Test public void parseNoScheme() throws Exception {
-    assertEquals(null, HttpUrl.parse("//host"));
-    assertEquals(null, HttpUrl.parse("/path"));
-    assertEquals(null, HttpUrl.parse("path"));
-    assertEquals(null, HttpUrl.parse("?query"));
-    assertEquals(null, HttpUrl.parse("#fragment"));
+    assertInvalid("//host", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("/path", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("path", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("?query", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("#fragment", "Expected URL scheme 'http' or 'https' but no colon was found");
   }
 
   @Test public void newBuilderResolve() throws Exception {
     // Non-exhaustive tests because implementation is the same as resolve.
-    HttpUrl base = HttpUrl.parse("http://host/a/b");
-    assertEquals(HttpUrl.parse("https://host2/"), base.newBuilder("https://host2").build());
-    assertEquals(HttpUrl.parse("http://host2/"), base.newBuilder("//host2").build());
-    assertEquals(HttpUrl.parse("http://host/path"), base.newBuilder("/path").build());
-    assertEquals(HttpUrl.parse("http://host/a/path"), base.newBuilder("path").build());
-    assertEquals(HttpUrl.parse("http://host/a/b?query"), base.newBuilder("?query").build());
-    assertEquals(HttpUrl.parse("http://host/a/b#fragment"), base.newBuilder("#fragment").build());
-    assertEquals(HttpUrl.parse("http://host/a/b"), base.newBuilder("").build());
+    HttpUrl base = parse("http://host/a/b");
+    assertEquals(parse("https://host2/"), base.newBuilder("https://host2").build());
+    assertEquals(parse("http://host2/"), base.newBuilder("//host2").build());
+    assertEquals(parse("http://host/path"), base.newBuilder("/path").build());
+    assertEquals(parse("http://host/a/path"), base.newBuilder("path").build());
+    assertEquals(parse("http://host/a/b?query"), base.newBuilder("?query").build());
+    assertEquals(parse("http://host/a/b#fragment"), base.newBuilder("#fragment").build());
+    assertEquals(parse("http://host/a/b"), base.newBuilder("").build());
     assertEquals(null, base.newBuilder("ftp://b"));
     assertEquals(null, base.newBuilder("ht+tp://b"));
     assertEquals(null, base.newBuilder("ht-tp://b"));
@@ -125,27 +145,27 @@
   }
 
   @Test public void redactedUrl() {
-    HttpUrl baseWithPasswordAndUsername = HttpUrl.parse("http://username:password@host/a/b#fragment");
-    HttpUrl baseWithUsernameOnly = HttpUrl.parse("http://username@host/a/b#fragment");
-    HttpUrl baseWithPasswordOnly = HttpUrl.parse("http://password@host/a/b#fragment");
+    HttpUrl baseWithPasswordAndUsername = parse("http://username:password@host/a/b#fragment");
+    HttpUrl baseWithUsernameOnly = parse("http://username@host/a/b#fragment");
+    HttpUrl baseWithPasswordOnly = parse("http://password@host/a/b#fragment");
     assertEquals("http://host/...", baseWithPasswordAndUsername.redact());
     assertEquals("http://host/...", baseWithUsernameOnly.redact());
     assertEquals("http://host/...", baseWithPasswordOnly.redact());
   }
 
   @Test public void resolveNoScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b");
-    assertEquals(HttpUrl.parse("http://host2/"), base.resolve("//host2"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("/path"));
-    assertEquals(HttpUrl.parse("http://host/a/path"), base.resolve("path"));
-    assertEquals(HttpUrl.parse("http://host/a/b?query"), base.resolve("?query"));
-    assertEquals(HttpUrl.parse("http://host/a/b#fragment"), base.resolve("#fragment"));
-    assertEquals(HttpUrl.parse("http://host/a/b"), base.resolve(""));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("\\path"));
+    HttpUrl base = parse("http://host/a/b");
+    assertEquals(parse("http://host2/"), base.resolve("//host2"));
+    assertEquals(parse("http://host/path"), base.resolve("/path"));
+    assertEquals(parse("http://host/a/path"), base.resolve("path"));
+    assertEquals(parse("http://host/a/b?query"), base.resolve("?query"));
+    assertEquals(parse("http://host/a/b#fragment"), base.resolve("#fragment"));
+    assertEquals(parse("http://host/a/b"), base.resolve(""));
+    assertEquals(parse("http://host/path"), base.resolve("\\path"));
   }
 
   @Test public void resolveUnsupportedScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://a/");
+    HttpUrl base = parse("http://a/");
     assertEquals(null, base.resolve("ftp://b"));
     assertEquals(null, base.resolve("ht+tp://b"));
     assertEquals(null, base.resolve("ht-tp://b"));
@@ -153,159 +173,159 @@
   }
 
   @Test public void resolveSchemeLikePath() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://a/");
-    assertEquals(HttpUrl.parse("http://a/http//b/"), base.resolve("http//b/"));
-    assertEquals(HttpUrl.parse("http://a/ht+tp//b/"), base.resolve("ht+tp//b/"));
-    assertEquals(HttpUrl.parse("http://a/ht-tp//b/"), base.resolve("ht-tp//b/"));
-    assertEquals(HttpUrl.parse("http://a/ht.tp//b/"), base.resolve("ht.tp//b/"));
+    HttpUrl base = parse("http://a/");
+    assertEquals(parse("http://a/http//b/"), base.resolve("http//b/"));
+    assertEquals(parse("http://a/ht+tp//b/"), base.resolve("ht+tp//b/"));
+    assertEquals(parse("http://a/ht-tp//b/"), base.resolve("ht-tp//b/"));
+    assertEquals(parse("http://a/ht.tp//b/"), base.resolve("ht.tp//b/"));
   }
 
   /** https://tools.ietf.org/html/rfc3986#section-5.4.1 */
   @Test public void rfc3886NormalExamples() {
-    HttpUrl url = HttpUrl.parse("http://a/b/c/d;p?q");
+    HttpUrl url = parse("http://a/b/c/d;p?q");
     assertEquals(null, url.resolve("g:h")); // No 'g:' scheme in HttpUrl.
-    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("./g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g/"), url.resolve("g/"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/g"));
-    assertEquals(HttpUrl.parse("http://g"), url.resolve("//g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/d;p?y"), url.resolve("?y"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g?y"), url.resolve("g?y"));
-    assertEquals(HttpUrl.parse("http://a/b/c/d;p?q#s"), url.resolve("#s"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g#s"), url.resolve("g#s"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g?y#s"), url.resolve("g?y#s"));
-    assertEquals(HttpUrl.parse("http://a/b/c/;x"), url.resolve(";x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g;x"), url.resolve("g;x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g;x?y#s"), url.resolve("g;x?y#s"));
-    assertEquals(HttpUrl.parse("http://a/b/c/d;p?q"), url.resolve(""));
-    assertEquals(HttpUrl.parse("http://a/b/c/"), url.resolve("."));
-    assertEquals(HttpUrl.parse("http://a/b/c/"), url.resolve("./"));
-    assertEquals(HttpUrl.parse("http://a/b/"), url.resolve(".."));
-    assertEquals(HttpUrl.parse("http://a/b/"), url.resolve("../"));
-    assertEquals(HttpUrl.parse("http://a/b/g"), url.resolve("../g"));
-    assertEquals(HttpUrl.parse("http://a/"), url.resolve("../.."));
-    assertEquals(HttpUrl.parse("http://a/"), url.resolve("../../"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../g"));
+    assertEquals(parse("http://a/b/c/g"), url.resolve("g"));
+    assertEquals(parse("http://a/b/c/g"), url.resolve("./g"));
+    assertEquals(parse("http://a/b/c/g/"), url.resolve("g/"));
+    assertEquals(parse("http://a/g"), url.resolve("/g"));
+    assertEquals(parse("http://g"), url.resolve("//g"));
+    assertEquals(parse("http://a/b/c/d;p?y"), url.resolve("?y"));
+    assertEquals(parse("http://a/b/c/g?y"), url.resolve("g?y"));
+    assertEquals(parse("http://a/b/c/d;p?q#s"), url.resolve("#s"));
+    assertEquals(parse("http://a/b/c/g#s"), url.resolve("g#s"));
+    assertEquals(parse("http://a/b/c/g?y#s"), url.resolve("g?y#s"));
+    assertEquals(parse("http://a/b/c/;x"), url.resolve(";x"));
+    assertEquals(parse("http://a/b/c/g;x"), url.resolve("g;x"));
+    assertEquals(parse("http://a/b/c/g;x?y#s"), url.resolve("g;x?y#s"));
+    assertEquals(parse("http://a/b/c/d;p?q"), url.resolve(""));
+    assertEquals(parse("http://a/b/c/"), url.resolve("."));
+    assertEquals(parse("http://a/b/c/"), url.resolve("./"));
+    assertEquals(parse("http://a/b/"), url.resolve(".."));
+    assertEquals(parse("http://a/b/"), url.resolve("../"));
+    assertEquals(parse("http://a/b/g"), url.resolve("../g"));
+    assertEquals(parse("http://a/"), url.resolve("../.."));
+    assertEquals(parse("http://a/"), url.resolve("../../"));
+    assertEquals(parse("http://a/g"), url.resolve("../../g"));
   }
 
   /** https://tools.ietf.org/html/rfc3986#section-5.4.2 */
   @Test public void rfc3886AbnormalExamples() {
-    HttpUrl url = HttpUrl.parse("http://a/b/c/d;p?q");
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../../g"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../../../g"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/./g"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/../g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g."), url.resolve("g."));
-    assertEquals(HttpUrl.parse("http://a/b/c/.g"), url.resolve(".g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g.."), url.resolve("g.."));
-    assertEquals(HttpUrl.parse("http://a/b/c/..g"), url.resolve("..g"));
-    assertEquals(HttpUrl.parse("http://a/b/g"), url.resolve("./../g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g/"), url.resolve("./g/."));
-    assertEquals(HttpUrl.parse("http://a/b/c/g/h"), url.resolve("g/./h"));
-    assertEquals(HttpUrl.parse("http://a/b/c/h"), url.resolve("g/../h"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g;x=1/y"), url.resolve("g;x=1/./y"));
-    assertEquals(HttpUrl.parse("http://a/b/c/y"), url.resolve("g;x=1/../y"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g?y/./x"), url.resolve("g?y/./x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g?y/../x"), url.resolve("g?y/../x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g#s/./x"), url.resolve("g#s/./x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g#s/../x"), url.resolve("g#s/../x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("http:g")); // "http:g" also okay.
+    HttpUrl url = parse("http://a/b/c/d;p?q");
+    assertEquals(parse("http://a/g"), url.resolve("../../../g"));
+    assertEquals(parse("http://a/g"), url.resolve("../../../../g"));
+    assertEquals(parse("http://a/g"), url.resolve("/./g"));
+    assertEquals(parse("http://a/g"), url.resolve("/../g"));
+    assertEquals(parse("http://a/b/c/g."), url.resolve("g."));
+    assertEquals(parse("http://a/b/c/.g"), url.resolve(".g"));
+    assertEquals(parse("http://a/b/c/g.."), url.resolve("g.."));
+    assertEquals(parse("http://a/b/c/..g"), url.resolve("..g"));
+    assertEquals(parse("http://a/b/g"), url.resolve("./../g"));
+    assertEquals(parse("http://a/b/c/g/"), url.resolve("./g/."));
+    assertEquals(parse("http://a/b/c/g/h"), url.resolve("g/./h"));
+    assertEquals(parse("http://a/b/c/h"), url.resolve("g/../h"));
+    assertEquals(parse("http://a/b/c/g;x=1/y"), url.resolve("g;x=1/./y"));
+    assertEquals(parse("http://a/b/c/y"), url.resolve("g;x=1/../y"));
+    assertEquals(parse("http://a/b/c/g?y/./x"), url.resolve("g?y/./x"));
+    assertEquals(parse("http://a/b/c/g?y/../x"), url.resolve("g?y/../x"));
+    assertEquals(parse("http://a/b/c/g#s/./x"), url.resolve("g#s/./x"));
+    assertEquals(parse("http://a/b/c/g#s/../x"), url.resolve("g#s/../x"));
+    assertEquals(parse("http://a/b/c/g"), url.resolve("http:g")); // "http:g" also okay.
   }
 
   @Test public void parseAuthoritySlashCountDoesntMatter() throws Exception {
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:///host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\//host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:////host/path"));
+    assertEquals(parse("http://host/path"), parse("http:host/path"));
+    assertEquals(parse("http://host/path"), parse("http:/host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http://host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\/host/path"));
+    assertEquals(parse("http://host/path"), parse("http:/\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http:///host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\//host/path"));
+    assertEquals(parse("http://host/path"), parse("http:/\\/host/path"));
+    assertEquals(parse("http://host/path"), parse("http://\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\\\/host/path"));
+    assertEquals(parse("http://host/path"), parse("http:/\\\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\\\\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http:////host/path"));
   }
 
   @Test public void resolveAuthoritySlashCountDoesntMatterWithDifferentScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("https://a/b/c");
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:///host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\//host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:////host/path"));
+    HttpUrl base = parse("https://a/b/c");
+    assertEquals(parse("http://host/path"), base.resolve("http:host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http://host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:///host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\//host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http://\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:////host/path"));
   }
 
   @Test public void resolveAuthoritySlashCountMattersWithSameScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://a/b/c");
-    assertEquals(HttpUrl.parse("http://a/b/host/path"), base.resolve("http:host/path"));
-    assertEquals(HttpUrl.parse("http://a/host/path"), base.resolve("http:/host/path"));
-    assertEquals(HttpUrl.parse("http://a/host/path"), base.resolve("http:\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:///host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\//host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:////host/path"));
+    HttpUrl base = parse("http://a/b/c");
+    assertEquals(parse("http://a/b/host/path"), base.resolve("http:host/path"));
+    assertEquals(parse("http://a/host/path"), base.resolve("http:/host/path"));
+    assertEquals(parse("http://a/host/path"), base.resolve("http:\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http://host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:///host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\//host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http://\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:////host/path"));
   }
 
   @Test public void username() throws Exception {
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://@host/path"));
-    assertEquals(HttpUrl.parse("http://user@host/path"), HttpUrl.parse("http://user@host/path"));
+    assertEquals(parse("http://host/path"), parse("http://@host/path"));
+    assertEquals(parse("http://user@host/path"), parse("http://user@host/path"));
   }
 
   /** Given multiple '@' characters, the last one is the delimiter. */
   @Test public void authorityWithMultipleAtSigns() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://foo@bar@baz/path");
+    HttpUrl httpUrl = parse("http://foo@bar@baz/path");
     assertEquals("foo@bar", httpUrl.username());
     assertEquals("", httpUrl.password());
-    assertEquals(HttpUrl.parse("http://foo%40bar@baz/path"), httpUrl);
+    assertEquals(parse("http://foo%40bar@baz/path"), httpUrl);
   }
 
   /** Given multiple ':' characters, the first one is the delimiter. */
   @Test public void authorityWithMultipleColons() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://foo:pass1@bar:pass2@baz/path");
+    HttpUrl httpUrl = parse("http://foo:pass1@bar:pass2@baz/path");
     assertEquals("foo", httpUrl.username());
     assertEquals("pass1@bar:pass2", httpUrl.password());
-    assertEquals(HttpUrl.parse("http://foo:pass1%40bar%3Apass2@baz/path"), httpUrl);
+    assertEquals(parse("http://foo:pass1%40bar%3Apass2@baz/path"), httpUrl);
   }
 
   @Test public void usernameAndPassword() throws Exception {
-    assertEquals(HttpUrl.parse("http://username:password@host/path"),
-        HttpUrl.parse("http://username:password@host/path"));
-    assertEquals(HttpUrl.parse("http://username@host/path"),
-        HttpUrl.parse("http://username:@host/path"));
+    assertEquals(parse("http://username:password@host/path"),
+        parse("http://username:password@host/path"));
+    assertEquals(parse("http://username@host/path"),
+        parse("http://username:@host/path"));
   }
 
   @Test public void passwordWithEmptyUsername() throws Exception {
     // Chrome doesn't mind, but Firefox rejects URLs with empty usernames and non-empty passwords.
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://:@host/path"));
-    assertEquals("password%40", HttpUrl.parse("http://:password@@host/path").encodedPassword());
+    assertEquals(parse("http://host/path"), parse("http://:@host/path"));
+    assertEquals("password%40", parse("http://:password@@host/path").encodedPassword());
   }
 
   @Test public void unprintableCharactersArePercentEncoded() throws Exception {
-    assertEquals("/%00", HttpUrl.parse("http://host/\u0000").encodedPath());
-    assertEquals("/%08", HttpUrl.parse("http://host/\u0008").encodedPath());
-    assertEquals("/%EF%BF%BD", HttpUrl.parse("http://host/\ufffd").encodedPath());
+    assertEquals("/%00", parse("http://host/\u0000").encodedPath());
+    assertEquals("/%08", parse("http://host/\u0008").encodedPath());
+    assertEquals("/%EF%BF%BD", parse("http://host/\ufffd").encodedPath());
   }
 
   @Test public void usernameCharacters() throws Exception {
@@ -325,188 +345,220 @@
   }
 
   @Test public void hostContainsIllegalCharacter() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://\n/"));
-    assertEquals(null, HttpUrl.parse("http:// /"));
-    assertEquals(null, HttpUrl.parse("http://%20/"));
+    assertInvalid("http://\n/", "Invalid URL host: \"\n\"");
+    assertInvalid("http:// /", "Invalid URL host: \" \"");
+    assertInvalid("http://%20/", "Invalid URL host: \"%20\"");
   }
 
   @Test public void hostnameLowercaseCharactersMappedDirectly() throws Exception {
-    assertEquals("abcd", HttpUrl.parse("http://abcd").host());
-    assertEquals("xn--4xa", HttpUrl.parse("http://σ").host());
+    assertEquals("abcd", parse("http://abcd").host());
+    assertEquals("xn--4xa", parse("http://σ").host());
   }
 
   @Test public void hostnameUppercaseCharactersConvertedToLowercase() throws Exception {
-    assertEquals("abcd", HttpUrl.parse("http://ABCD").host());
-    assertEquals("xn--4xa", HttpUrl.parse("http://Σ").host());
+    assertEquals("abcd", parse("http://ABCD").host());
+    assertEquals("xn--4xa", parse("http://Σ").host());
   }
 
   @Test public void hostnameIgnoredCharacters() throws Exception {
     // The soft hyphen (­) should be ignored.
-    assertEquals("abcd", HttpUrl.parse("http://AB\u00adCD").host());
+    assertEquals("abcd", parse("http://AB\u00adCD").host());
   }
 
   @Test public void hostnameMultipleCharacterMapping() throws Exception {
     // Map the single character telephone symbol (℡) to the string "tel".
-    assertEquals("tel", HttpUrl.parse("http://\u2121").host());
+    assertEquals("tel", parse("http://\u2121").host());
   }
 
   @Test public void hostnameMappingLastMappedCodePoint() throws Exception {
-    assertEquals("xn--pu5l", HttpUrl.parse("http://\uD87E\uDE1D").host());
+    assertEquals("xn--pu5l", parse("http://\uD87E\uDE1D").host());
   }
 
   @Ignore("The java.net.IDN implementation doesn't ignore characters that it should.")
   @Test public void hostnameMappingLastIgnoredCodePoint() throws Exception {
-    assertEquals("abcd", HttpUrl.parse("http://ab\uDB40\uDDEFcd").host());
+    assertEquals("abcd", parse("http://ab\uDB40\uDDEFcd").host());
   }
 
   @Test public void hostnameMappingLastDisallowedCodePoint() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://\uDBFF\uDFFF"));
+    assertInvalid("http://\uDBFF\uDFFF", "Invalid URL host: \"\uDBFF\uDFFF\"");
   }
 
   @Test public void hostIpv6() throws Exception {
     // Square braces are absent from host()...
-    assertEquals("::1", HttpUrl.parse("http://[::1]/").host());
+    assertEquals("::1", parse("http://[::1]/").host());
 
     // ... but they're included in toString().
-    assertEquals("http://[::1]/", HttpUrl.parse("http://[::1]/").toString());
+    assertEquals("http://[::1]/", parse("http://[::1]/").toString());
 
     // IPv6 colons don't interfere with port numbers or passwords.
-    assertEquals(8080, HttpUrl.parse("http://[::1]:8080/").port());
-    assertEquals("password", HttpUrl.parse("http://user:password@[::1]/").password());
-    assertEquals("::1", HttpUrl.parse("http://user:password@[::1]:8080/").host());
+    assertEquals(8080, parse("http://[::1]:8080/").port());
+    assertEquals("password", parse("http://user:password@[::1]/").password());
+    assertEquals("::1", parse("http://user:password@[::1]:8080/").host());
 
     // Permit the contents of IPv6 addresses to be percent-encoded...
-    assertEquals("::1", HttpUrl.parse("http://[%3A%3A%31]/").host());
+    assertEquals("::1", parse("http://[%3A%3A%31]/").host());
 
     // Including the Square braces themselves! (This is what Chrome does.)
-    assertEquals("::1", HttpUrl.parse("http://%5B%3A%3A1%5D/").host());
+    assertEquals("::1", parse("http://%5B%3A%3A1%5D/").host());
   }
 
   @Test public void hostIpv6AddressDifferentFormats() throws Exception {
     // Multiple representations of the same address; see http://tools.ietf.org/html/rfc5952.
     String a3 = "2001:db8::1:0:0:1";
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0:0:1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:0db8:0:0:1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8::1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8::0:1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:0db8::1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0:0:1::1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0000:0:1::1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:DB8:0:0:1::1]").host());
+    assertEquals(a3, parse("http://[2001:db8:0:0:1:0:0:1]").host());
+    assertEquals(a3, parse("http://[2001:0db8:0:0:1:0:0:1]").host());
+    assertEquals(a3, parse("http://[2001:db8::1:0:0:1]").host());
+    assertEquals(a3, parse("http://[2001:db8::0:1:0:0:1]").host());
+    assertEquals(a3, parse("http://[2001:0db8::1:0:0:1]").host());
+    assertEquals(a3, parse("http://[2001:db8:0:0:1::1]").host());
+    assertEquals(a3, parse("http://[2001:db8:0000:0:1::1]").host());
+    assertEquals(a3, parse("http://[2001:DB8:0:0:1::1]").host());
   }
 
   @Test public void hostIpv6AddressLeadingCompression() throws Exception {
-    assertEquals("::1", HttpUrl.parse("http://[::0001]").host());
-    assertEquals("::1", HttpUrl.parse("http://[0000::0001]").host());
-    assertEquals("::1", HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001]").host());
-    assertEquals("::1", HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000::0001]").host());
+    assertEquals("::1", parse("http://[::0001]").host());
+    assertEquals("::1", parse("http://[0000::0001]").host());
+    assertEquals("::1", parse("http://[0000:0000:0000:0000:0000:0000:0000:0001]").host());
+    assertEquals("::1", parse("http://[0000:0000:0000:0000:0000:0000::0001]").host());
   }
 
   @Test public void hostIpv6AddressTrailingCompression() throws Exception {
-    assertEquals("1::", HttpUrl.parse("http://[0001:0000::]").host());
-    assertEquals("1::", HttpUrl.parse("http://[0001::0000]").host());
-    assertEquals("1::", HttpUrl.parse("http://[0001::]").host());
-    assertEquals("1::", HttpUrl.parse("http://[1::]").host());
+    assertEquals("1::", parse("http://[0001:0000::]").host());
+    assertEquals("1::", parse("http://[0001::0000]").host());
+    assertEquals("1::", parse("http://[0001::]").host());
+    assertEquals("1::", parse("http://[1::]").host());
   }
 
   @Test public void hostIpv6AddressTooManyDigitsInGroup() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000:0000:0000:0000:0001]"));
-    assertEquals(null, HttpUrl.parse("http://[::00001]"));
+    assertInvalid("http://[00000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[00000:0000:0000:0000:0000:0000:0000:0001]\"");
+    assertInvalid("http://[::00001]", "Invalid URL host: \"[::00001]\"");
   }
 
   @Test public void hostIpv6AddressMisplacedColons() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[:0000:0000:0000:0000:0000:0000:0000:0001]"));
-    assertEquals(null, HttpUrl.parse("http://[:::0000:0000:0000:0000:0000:0000:0000:0001]"));
-    assertEquals(null, HttpUrl.parse("http://[:1]"));
-    assertEquals(null, HttpUrl.parse("http://[:::1]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0001:]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001:]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001::]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001:::]"));
-    assertEquals(null, HttpUrl.parse("http://[1:]"));
-    assertEquals(null, HttpUrl.parse("http://[1:::]"));
-    assertEquals(null, HttpUrl.parse("http://[1:::1]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000::0000:0000:0000:0001]"));
+    assertInvalid("http://[:0000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[:0000:0000:0000:0000:0000:0000:0000:0001]\"");
+    assertInvalid("http://[:::0000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[:::0000:0000:0000:0000:0000:0000:0000:0001]\"");
+    assertInvalid("http://[:1]", "Invalid URL host: \"[:1]\"");
+    assertInvalid("http://[:::1]", "Invalid URL host: \"[:::1]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0001:]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0001:]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001:]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001:]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001::]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001::]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001:::]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001:::]\"");
+    assertInvalid("http://[1:]", "Invalid URL host: \"[1:]\"");
+    assertInvalid("http://[1:::]", "Invalid URL host: \"[1:::]\"");
+    assertInvalid("http://[1:::1]", "Invalid URL host: \"[1:::1]\"");
+    assertInvalid("http://[0000:0000:0000:0000::0000:0000:0000:0001]",
+        "Invalid URL host: \"[0000:0000:0000:0000::0000:0000:0000:0001]\"");
   }
 
   @Test public void hostIpv6AddressTooManyGroups() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0000:0001]"));
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0000:0001]\"");
   }
 
   @Test public void hostIpv6AddressTooMuchCompression() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[0000::0000:0000:0000:0000::0001]"));
-    assertEquals(null, HttpUrl.parse("http://[::0000:0000:0000:0000::0001]"));
+    assertInvalid("http://[0000::0000:0000:0000:0000::0001]",
+        "Invalid URL host: \"[0000::0000:0000:0000:0000::0001]\"");
+    assertInvalid("http://[::0000:0000:0000:0000::0001]",
+        "Invalid URL host: \"[::0000:0000:0000:0000::0001]\"");
   }
 
   @Test public void hostIpv6ScopedAddress() throws Exception {
     // java.net.InetAddress parses scoped addresses. These aren't valid in URLs.
-    assertEquals(null, HttpUrl.parse("http://[::1%2544]"));
+    assertInvalid("http://[::1%2544]", "Invalid URL host: \"[::1%2544]\"");
+  }
+
+  @Test public void hostIpv6AddressTooManyLeadingZeros() throws Exception {
+    // Guava's been buggy on this case. https://github.com/google/guava/issues/3116
+    assertInvalid("http://[2001:db8:0:0:1:0:0:00001]",
+        "Invalid URL host: \"[2001:db8:0:0:1:0:0:00001]\"");
   }
 
   @Test public void hostIpv6WithIpv4Suffix() throws Exception {
-    assertEquals("::1:ffff:ffff", HttpUrl.parse("http://[::1:255.255.255.255]/").host());
-    assertEquals("::1:0:0", HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.0]/").host());
+    assertEquals("::1:ffff:ffff", parse("http://[::1:255.255.255.255]/").host());
+    assertEquals("::1:0:0", parse("http://[0:0:0:0:0:1:0.0.0.0]/").host());
   }
 
   @Test public void hostIpv6WithIpv4SuffixWithOctalPrefix() throws Exception {
     // Chrome interprets a leading '0' as octal; Firefox rejects them. (We reject them.)
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.000000]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.010.0.010]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.000001]/"));
+    assertInvalid("http://[0:0:0:0:0:1:0.0.0.000000]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.0.0.000000]\"");
+    assertInvalid("http://[0:0:0:0:0:1:0.010.0.010]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.010.0.010]\"");
+    assertInvalid("http://[0:0:0:0:0:1:0.0.0.000001]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.0.0.000001]\"");
   }
 
   @Test public void hostIpv6WithIpv4SuffixWithHexadecimalPrefix() throws Exception {
     // Chrome interprets a leading '0x' as hexadecimal; Firefox rejects them. (We reject them.)
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0x10.0.0x10]/"));
+    assertInvalid("http://[0:0:0:0:0:1:0.0x10.0.0x10]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.0x10.0.0x10]\"");
   }
 
   @Test public void hostIpv6WithMalformedIpv4Suffix() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0:0.0]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0-0.0]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255..255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255..255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:0:1:255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:256.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:ff.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:0:1:255.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:1:255.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:1:0.0.0.0:1]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0.0.0.0:1:0:0:0:0:1]/"));
-    assertEquals(null, HttpUrl.parse("http://[0.0.0.0:0:0:0:0:0:1]/"));
+    assertInvalid("http://[0:0:0:0:0:1:0.0:0.0]/", "Invalid URL host: \"[0:0:0:0:0:1:0.0:0.0]\"");
+    assertInvalid("http://[0:0:0:0:0:1:0.0-0.0]/", "Invalid URL host: \"[0:0:0:0:0:1:0.0-0.0]\"");
+    assertInvalid("http://[0:0:0:0:0:1:.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:255..255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255..255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:255.255..255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255.255..255]\"");
+    assertInvalid("http://[0:0:0:0:0:0:1:255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:0:1:255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:256.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:256.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:ff.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:ff.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:0:1:255.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:0:1:255.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:1:255.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:1:255.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:1:0.0.0.0:1]/", "Invalid URL host: \"[0:0:0:0:1:0.0.0.0:1]\"");
+    assertInvalid("http://[0:0.0.0.0:1:0:0:0:0:1]/",
+        "Invalid URL host: \"[0:0.0.0.0:1:0:0:0:0:1]\"");
+    assertInvalid("http://[0.0.0.0:0:0:0:0:0:1]/", "Invalid URL host: \"[0.0.0.0:0:0:0:0:0:1]\"");
   }
 
   @Test public void hostIpv6WithIncompleteIpv4Suffix() throws Exception {
     // To Chrome & Safari these are well-formed; Firefox disagrees. (We're consistent with Firefox).
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255.255.]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255.255]/"));
+    assertInvalid("http://[0:0:0:0:0:1:255.255.255.]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255.255.255.]\"");
+    assertInvalid("http://[0:0:0:0:0:1:255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255.255.255]\"");
   }
 
   @Test public void hostIpv6CanonicalForm() throws Exception {
     assertEquals("abcd:ef01:2345:6789:abcd:ef01:2345:6789",
-        HttpUrl.parse("http://[abcd:ef01:2345:6789:abcd:ef01:2345:6789]/").host());
-    assertEquals("a::b:0:0:0", HttpUrl.parse("http://[a:0:0:0:b:0:0:0]/").host());
-    assertEquals("a:b:0:0:c::", HttpUrl.parse("http://[a:b:0:0:c:0:0:0]/").host());
-    assertEquals("a:b::c:0:0", HttpUrl.parse("http://[a:b:0:0:0:c:0:0]/").host());
-    assertEquals("a::b:0:0:0", HttpUrl.parse("http://[a:0:0:0:b:0:0:0]/").host());
-    assertEquals("::a:b:0:0:0", HttpUrl.parse("http://[0:0:0:a:b:0:0:0]/").host());
-    assertEquals("::a:0:0:0:b", HttpUrl.parse("http://[0:0:0:a:0:0:0:b]/").host());
-    assertEquals("0:a:b:c:d:e:f:1", HttpUrl.parse("http://[0:a:b:c:d:e:f:1]/").host());
-    assertEquals("a:b:c:d:e:f:1:0", HttpUrl.parse("http://[a:b:c:d:e:f:1:0]/").host());
-    assertEquals("ff01::101", HttpUrl.parse("http://[FF01:0:0:0:0:0:0:101]/").host());
-    assertEquals("2001:db8::1", HttpUrl.parse("http://[2001:db8::1]/").host());
-    assertEquals("2001:db8::2:1", HttpUrl.parse("http://[2001:db8:0:0:0:0:2:1]/").host());
-    assertEquals("2001:db8:0:1:1:1:1:1", HttpUrl.parse("http://[2001:db8:0:1:1:1:1:1]/").host());
-    assertEquals("2001:db8::1:0:0:1", HttpUrl.parse("http://[2001:db8:0:0:1:0:0:1]/").host());
-    assertEquals("2001:0:0:1::1", HttpUrl.parse("http://[2001:0:0:1:0:0:0:1]/").host());
-    assertEquals("1::", HttpUrl.parse("http://[1:0:0:0:0:0:0:0]/").host());
-    assertEquals("::1", HttpUrl.parse("http://[0:0:0:0:0:0:0:1]/").host());
-    assertEquals("::", HttpUrl.parse("http://[0:0:0:0:0:0:0:0]/").host());
+        parse("http://[abcd:ef01:2345:6789:abcd:ef01:2345:6789]/").host());
+    assertEquals("a::b:0:0:0", parse("http://[a:0:0:0:b:0:0:0]/").host());
+    assertEquals("a:b:0:0:c::", parse("http://[a:b:0:0:c:0:0:0]/").host());
+    assertEquals("a:b::c:0:0", parse("http://[a:b:0:0:0:c:0:0]/").host());
+    assertEquals("a::b:0:0:0", parse("http://[a:0:0:0:b:0:0:0]/").host());
+    assertEquals("::a:b:0:0:0", parse("http://[0:0:0:a:b:0:0:0]/").host());
+    assertEquals("::a:0:0:0:b", parse("http://[0:0:0:a:0:0:0:b]/").host());
+    assertEquals("0:a:b:c:d:e:f:1", parse("http://[0:a:b:c:d:e:f:1]/").host());
+    assertEquals("a:b:c:d:e:f:1:0", parse("http://[a:b:c:d:e:f:1:0]/").host());
+    assertEquals("ff01::101", parse("http://[FF01:0:0:0:0:0:0:101]/").host());
+    assertEquals("2001:db8::1", parse("http://[2001:db8::1]/").host());
+    assertEquals("2001:db8::2:1", parse("http://[2001:db8:0:0:0:0:2:1]/").host());
+    assertEquals("2001:db8:0:1:1:1:1:1", parse("http://[2001:db8:0:1:1:1:1:1]/").host());
+    assertEquals("2001:db8::1:0:0:1", parse("http://[2001:db8:0:0:1:0:0:1]/").host());
+    assertEquals("2001:0:0:1::1", parse("http://[2001:0:0:1:0:0:0:1]/").host());
+    assertEquals("1::", parse("http://[1:0:0:0:0:0:0:0]/").host());
+    assertEquals("::1", parse("http://[0:0:0:0:0:0:0:1]/").host());
+    assertEquals("::", parse("http://[0:0:0:0:0:0:0:0]/").host());
   }
 
   /** The builder permits square braces but does not require them. */
   @Test public void hostIPv6Builder() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://example.com/");
+    HttpUrl base = parse("http://example.com/");
     assertEquals("http://[::1]/", base.newBuilder().host("[::1]").build().toString());
     assertEquals("http://[::1]/", base.newBuilder().host("[::0001]").build().toString());
     assertEquals("http://[::1]/", base.newBuilder().host("::1").build().toString());
@@ -514,26 +566,26 @@
   }
 
   @Test public void hostIpv4CanonicalForm() throws Exception {
-    assertEquals("255.255.255.255", HttpUrl.parse("http://255.255.255.255/").host());
-    assertEquals("1.2.3.4", HttpUrl.parse("http://1.2.3.4/").host());
-    assertEquals("0.0.0.0", HttpUrl.parse("http://0.0.0.0/").host());
+    assertEquals("255.255.255.255", parse("http://255.255.255.255/").host());
+    assertEquals("1.2.3.4", parse("http://1.2.3.4/").host());
+    assertEquals("0.0.0.0", parse("http://0.0.0.0/").host());
   }
 
   @Ignore("java.net.IDN strips trailing trailing dots on Java 7, but not on Java 8.")
   @Test public void hostWithTrailingDot() throws Exception {
-    assertEquals("host.", HttpUrl.parse("http://host./").host());
+    assertEquals("host.", parse("http://host./").host());
   }
 
   @Test public void port() throws Exception {
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host:80/"));
-    assertEquals(HttpUrl.parse("http://host:99/"), HttpUrl.parse("http://host:99/"));
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host:/"));
-    assertEquals(65535, HttpUrl.parse("http://host:65535/").port());
-    assertEquals(null, HttpUrl.parse("http://host:0/"));
-    assertEquals(null, HttpUrl.parse("http://host:65536/"));
-    assertEquals(null, HttpUrl.parse("http://host:-1/"));
-    assertEquals(null, HttpUrl.parse("http://host:a/"));
-    assertEquals(null, HttpUrl.parse("http://host:%39%39/"));
+    assertEquals(parse("http://host/"), parse("http://host:80/"));
+    assertEquals(parse("http://host:99/"), parse("http://host:99/"));
+    assertEquals(parse("http://host/"), parse("http://host:/"));
+    assertEquals(65535, parse("http://host:65535/").port());
+    assertInvalid("http://host:0/", "Invalid URL port: \"0\"");
+    assertInvalid("http://host:65536/", "Invalid URL port: \"65536\"");
+    assertInvalid("http://host:-1/", "Invalid URL port: \"-1\"");
+    assertInvalid("http://host:a/", "Invalid URL port: \"a\"");
+    assertInvalid("http://host:%39%39/", "Invalid URL port: \"%39%39\"");
   }
 
   @Test public void pathCharacters() throws Exception {
@@ -553,6 +605,15 @@
         .test(Component.QUERY);
   }
 
+  @Test public void queryValueCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.IDENTITY, '?', '`')
+        .override(Encoding.PERCENT, '\'')
+        .override(Encoding.SKIP, '#', '+')
+        .skipForUri('%', '\\', '^', '`', '{', '|', '}')
+        .test(Component.QUERY_VALUE);
+  }
+
   @Test public void fragmentCharacters() throws Exception {
     new UrlComponentEncodingTester()
         .override(Encoding.IDENTITY, ' ', '"', '#', '<', '>', '?', '`')
@@ -562,7 +623,7 @@
   }
 
   @Test public void fragmentNonAscii() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#Σ");
+    HttpUrl url = parse("http://host/#Σ");
     assertEquals("http://host/#Σ", url.toString());
     assertEquals("Σ", url.fragment());
     assertEquals("Σ", url.encodedFragment());
@@ -570,7 +631,7 @@
   }
 
   @Test public void fragmentNonAsciiThatOffendsJavaNetUri() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#\u0080");
+    HttpUrl url = parse("http://host/#\u0080");
     assertEquals("http://host/#\u0080", url.toString());
     assertEquals("\u0080", url.fragment());
     assertEquals("\u0080", url.encodedFragment());
@@ -578,7 +639,7 @@
   }
 
   @Test public void fragmentPercentEncodedNonAscii() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#%C2%80");
+    HttpUrl url = parse("http://host/#%C2%80");
     assertEquals("http://host/#%C2%80", url.toString());
     assertEquals("\u0080", url.fragment());
     assertEquals("%C2%80", url.encodedFragment());
@@ -586,7 +647,7 @@
   }
 
   @Test public void fragmentPercentEncodedPartialCodePoint() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#%80");
+    HttpUrl url = parse("http://host/#%80");
     assertEquals("http://host/#%80", url.toString());
     assertEquals("\ufffd", url.fragment()); // Unicode replacement character.
     assertEquals("%80", url.encodedFragment());
@@ -594,106 +655,106 @@
   }
 
   @Test public void relativePath() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("d/e/f"));
-    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("../../d/e/f"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".."));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../.."));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../.."));
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("././.."));
-    assertEquals(HttpUrl.parse("http://host/a/b/c/"), base.resolve("c/d/../e/../"));
-    assertEquals(HttpUrl.parse("http://host/a/b/..e/"), base.resolve("..e/"));
-    assertEquals(HttpUrl.parse("http://host/a/b/e/f../"), base.resolve("e/f../"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2E."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".%2E"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2E%2E"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2e."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".%2e"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2e%2e"));
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("%2E"));
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("%2e"));
+    HttpUrl base = parse("http://host/a/b/c");
+    assertEquals(parse("http://host/a/b/d/e/f"), base.resolve("d/e/f"));
+    assertEquals(parse("http://host/d/e/f"), base.resolve("../../d/e/f"));
+    assertEquals(parse("http://host/a/"), base.resolve(".."));
+    assertEquals(parse("http://host/"), base.resolve("../.."));
+    assertEquals(parse("http://host/"), base.resolve("../../.."));
+    assertEquals(parse("http://host/a/b/"), base.resolve("."));
+    assertEquals(parse("http://host/a/"), base.resolve("././.."));
+    assertEquals(parse("http://host/a/b/c/"), base.resolve("c/d/../e/../"));
+    assertEquals(parse("http://host/a/b/..e/"), base.resolve("..e/"));
+    assertEquals(parse("http://host/a/b/e/f../"), base.resolve("e/f../"));
+    assertEquals(parse("http://host/a/"), base.resolve("%2E."));
+    assertEquals(parse("http://host/a/"), base.resolve(".%2E"));
+    assertEquals(parse("http://host/a/"), base.resolve("%2E%2E"));
+    assertEquals(parse("http://host/a/"), base.resolve("%2e."));
+    assertEquals(parse("http://host/a/"), base.resolve(".%2e"));
+    assertEquals(parse("http://host/a/"), base.resolve("%2e%2e"));
+    assertEquals(parse("http://host/a/b/"), base.resolve("%2E"));
+    assertEquals(parse("http://host/a/b/"), base.resolve("%2e"));
   }
 
   @Test public void relativePathWithTrailingSlash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c/");
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve(".."));
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("../"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../.."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../../"));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../.."));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../"));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../.."));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../../"));
-    assertEquals(HttpUrl.parse("http://host/a"), base.resolve("../../../../a"));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../../a/.."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../../../../a/b/.."));
+    HttpUrl base = parse("http://host/a/b/c/");
+    assertEquals(parse("http://host/a/b/"), base.resolve(".."));
+    assertEquals(parse("http://host/a/b/"), base.resolve("../"));
+    assertEquals(parse("http://host/a/"), base.resolve("../.."));
+    assertEquals(parse("http://host/a/"), base.resolve("../../"));
+    assertEquals(parse("http://host/"), base.resolve("../../.."));
+    assertEquals(parse("http://host/"), base.resolve("../../../"));
+    assertEquals(parse("http://host/"), base.resolve("../../../.."));
+    assertEquals(parse("http://host/"), base.resolve("../../../../"));
+    assertEquals(parse("http://host/a"), base.resolve("../../../../a"));
+    assertEquals(parse("http://host/"), base.resolve("../../../../a/.."));
+    assertEquals(parse("http://host/a/"), base.resolve("../../../../a/b/.."));
   }
 
   @Test public void pathWithBackslash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("d\\e\\f"));
-    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("../..\\d\\e\\f"));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("..\\.."));
+    HttpUrl base = parse("http://host/a/b/c");
+    assertEquals(parse("http://host/a/b/d/e/f"), base.resolve("d\\e\\f"));
+    assertEquals(parse("http://host/d/e/f"), base.resolve("../..\\d\\e\\f"));
+    assertEquals(parse("http://host/"), base.resolve("..\\.."));
   }
 
   @Test public void relativePathWithSameScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("http:d/e/f"));
-    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("http:../../d/e/f"));
+    HttpUrl base = parse("http://host/a/b/c");
+    assertEquals(parse("http://host/a/b/d/e/f"), base.resolve("http:d/e/f"));
+    assertEquals(parse("http://host/d/e/f"), base.resolve("http:../../d/e/f"));
   }
 
   @Test public void decodeUsername() {
-    assertEquals("user", HttpUrl.parse("http://user@host/").username());
-    assertEquals("\uD83C\uDF69", HttpUrl.parse("http://%F0%9F%8D%A9@host/").username());
+    assertEquals("user", parse("http://user@host/").username());
+    assertEquals("\uD83C\uDF69", parse("http://%F0%9F%8D%A9@host/").username());
   }
 
   @Test public void decodePassword() {
-    assertEquals("password", HttpUrl.parse("http://user:password@host/").password());
-    assertEquals("", HttpUrl.parse("http://user:@host/").password());
-    assertEquals("\uD83C\uDF69", HttpUrl.parse("http://user:%F0%9F%8D%A9@host/").password());
+    assertEquals("password", parse("http://user:password@host/").password());
+    assertEquals("", parse("http://user:@host/").password());
+    assertEquals("\uD83C\uDF69", parse("http://user:%F0%9F%8D%A9@host/").password());
   }
 
   @Test public void decodeSlashCharacterInDecodedPathSegment() {
     assertEquals(Arrays.asList("a/b/c"),
-        HttpUrl.parse("http://host/a%2Fb%2Fc").pathSegments());
+        parse("http://host/a%2Fb%2Fc").pathSegments());
   }
 
   @Test public void decodeEmptyPathSegments() {
     assertEquals(Arrays.asList(""),
-        HttpUrl.parse("http://host/").pathSegments());
+        parse("http://host/").pathSegments());
   }
 
   @Test public void percentDecode() throws Exception {
     assertEquals(Arrays.asList("\u0000"),
-        HttpUrl.parse("http://host/%00").pathSegments());
+        parse("http://host/%00").pathSegments());
     assertEquals(Arrays.asList("a", "\u2603", "c"),
-        HttpUrl.parse("http://host/a/%E2%98%83/c").pathSegments());
+        parse("http://host/a/%E2%98%83/c").pathSegments());
     assertEquals(Arrays.asList("a", "\uD83C\uDF69", "c"),
-        HttpUrl.parse("http://host/a/%F0%9F%8D%A9/c").pathSegments());
+        parse("http://host/a/%F0%9F%8D%A9/c").pathSegments());
     assertEquals(Arrays.asList("a", "b", "c"),
-        HttpUrl.parse("http://host/a/%62/c").pathSegments());
+        parse("http://host/a/%62/c").pathSegments());
     assertEquals(Arrays.asList("a", "z", "c"),
-        HttpUrl.parse("http://host/a/%7A/c").pathSegments());
+        parse("http://host/a/%7A/c").pathSegments());
     assertEquals(Arrays.asList("a", "z", "c"),
-        HttpUrl.parse("http://host/a/%7a/c").pathSegments());
+        parse("http://host/a/%7a/c").pathSegments());
   }
 
   @Test public void malformedPercentEncoding() {
     assertEquals(Arrays.asList("a%f", "b"),
-        HttpUrl.parse("http://host/a%f/b").pathSegments());
+        parse("http://host/a%f/b").pathSegments());
     assertEquals(Arrays.asList("%", "b"),
-        HttpUrl.parse("http://host/%/b").pathSegments());
+        parse("http://host/%/b").pathSegments());
     assertEquals(Arrays.asList("%"),
-        HttpUrl.parse("http://host/%").pathSegments());
+        parse("http://host/%").pathSegments());
     assertEquals(Arrays.asList("%00"),
-        HttpUrl.parse("http://github.com/%%30%30").pathSegments());
+        parse("http://github.com/%%30%30").pathSegments());
   }
 
   @Test public void malformedUtf8Encoding() {
     // Replace a partial UTF-8 sequence with the Unicode replacement character.
     assertEquals(Arrays.asList("a", "\ufffdx", "c"),
-        HttpUrl.parse("http://host/a/%E2%98x/c").pathSegments());
+        parse("http://host/a/%E2%98x/c").pathSegments());
   }
 
   @Test public void incompleteUrlComposition() throws Exception {
@@ -711,6 +772,19 @@
     }
   }
 
+  @Test public void builderToString() {
+    assertEquals("https://host.com/path", parse("https://host.com/path").newBuilder().toString());
+  }
+
+  @Test public void incompleteBuilderToString() {
+    assertEquals("https:///path",
+        new HttpUrl.Builder().scheme("https").encodedPath("/path").toString());
+    assertEquals("//host.com/path",
+        new HttpUrl.Builder().host("host.com").encodedPath("/path").toString());
+    assertEquals("//host.com:8080/path",
+        new HttpUrl.Builder().host("host.com").encodedPath("/path").port(8080).toString());
+  }
+
   @Test public void minimalUrlComposition() throws Exception {
     HttpUrl url = new HttpUrl.Builder().scheme("http").host("host").build();
     assertEquals("http://host/", url.toString());
@@ -747,17 +821,17 @@
   }
 
   @Test public void changingSchemeChangesDefaultPort() throws Exception {
-    assertEquals(443, HttpUrl.parse("http://example.com")
+    assertEquals(443, parse("http://example.com")
         .newBuilder()
         .scheme("https")
         .build().port());
 
-    assertEquals(80, HttpUrl.parse("https://example.com")
+    assertEquals(80, parse("https://example.com")
         .newBuilder()
         .scheme("http")
         .build().port());
 
-    assertEquals(1234, HttpUrl.parse("https://example.com:1234")
+    assertEquals(1234, parse("https://example.com:1234")
         .newBuilder()
         .scheme("http")
         .build().port());
@@ -860,7 +934,7 @@
   }
 
   @Test public void composeWithAddSegment() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c/", base.newBuilder().addPathSegment("").build().encodedPath());
     assertEquals("/a/b/c/d",
         base.newBuilder().addPathSegment("").addPathSegment("d").build().encodedPath());
@@ -872,12 +946,12 @@
   }
 
   @Test public void pathSize() throws Exception {
-    assertEquals(1, HttpUrl.parse("http://host/").pathSize());
-    assertEquals(3, HttpUrl.parse("http://host/a/b/c").pathSize());
+    assertEquals(1, parse("http://host/").pathSize());
+    assertEquals(3, parse("http://host/a/b/c").pathSize());
   }
 
   @Test public void addPathSegments() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
 
     // Add a string with zero slashes: resulting URL gains one slash.
     assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
@@ -897,7 +971,7 @@
   }
 
   @Test public void addPathSegmentsOntoTrailingSlash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c/");
+    HttpUrl base = parse("http://host/a/b/c/");
 
     // Add a string with zero slashes: resulting URL gains zero slashes.
     assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
@@ -917,30 +991,30 @@
   }
 
   @Test public void addPathSegmentsWithBackslash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/");
+    HttpUrl base = parse("http://host/");
     assertEquals("/d/e", base.newBuilder().addPathSegments("d\\e").build().encodedPath());
     assertEquals("/d/e", base.newBuilder().addEncodedPathSegments("d\\e").build().encodedPath());
   }
 
   @Test public void addPathSegmentsWithEmptyPaths() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c//d/e///f",
         base.newBuilder().addPathSegments("/d/e///f").build().encodedPath());
   }
 
   @Test public void addEncodedPathSegments() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c/d/e/%20/",
         base.newBuilder().addEncodedPathSegments("d/e/%20/\n").build().encodedPath());
   }
 
   @Test public void addPathSegmentDotDoesNothing() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c", base.newBuilder().addPathSegment(".").build().encodedPath());
   }
 
   @Test public void addPathSegmentEncodes() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c/%252e",
         base.newBuilder().addPathSegment("%2e").build().encodedPath());
     assertEquals("/a/b/c/%252e%252e",
@@ -948,47 +1022,47 @@
   }
 
   @Test public void addPathSegmentDotDotPopsDirectory() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/", base.newBuilder().addPathSegment("..").build().encodedPath());
   }
 
   @Test public void addPathSegmentDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c/.%0A", base.newBuilder().addPathSegment(".\n").build().encodedPath());
   }
 
   @Test public void addEncodedPathSegmentDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c", base.newBuilder().addEncodedPathSegment(".\n").build().encodedPath());
   }
 
   @Test public void addEncodedPathSegmentDotDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/", base.newBuilder().addEncodedPathSegment("..\n").build().encodedPath());
   }
 
   @Test public void setPathSegment() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/d/b/c", base.newBuilder().setPathSegment(0, "d").build().encodedPath());
     assertEquals("/a/d/c", base.newBuilder().setPathSegment(1, "d").build().encodedPath());
     assertEquals("/a/b/d", base.newBuilder().setPathSegment(2, "d").build().encodedPath());
   }
 
   @Test public void setPathSegmentEncodes() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/%2525/b/c", base.newBuilder().setPathSegment(0, "%25").build().encodedPath());
     assertEquals("/.%0A/b/c", base.newBuilder().setPathSegment(0, ".\n").build().encodedPath());
     assertEquals("/%252e/b/c", base.newBuilder().setPathSegment(0, "%2e").build().encodedPath());
   }
 
   @Test public void setPathSegmentAcceptsEmpty() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("//b/c", base.newBuilder().setPathSegment(0, "").build().encodedPath());
     assertEquals("/a/b/", base.newBuilder().setPathSegment(2, "").build().encodedPath());
   }
 
   @Test public void setPathSegmentRejectsDot() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setPathSegment(0, ".");
       fail();
@@ -997,7 +1071,7 @@
   }
 
   @Test public void setPathSegmentRejectsDotDot() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setPathSegment(0, "..");
       fail();
@@ -1006,7 +1080,7 @@
   }
 
   @Test public void setPathSegmentWithSlash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     HttpUrl url = base.newBuilder().setPathSegment(1, "/").build();
     assertEquals("/a/%2F/c", url.encodedPath());
   }
@@ -1020,13 +1094,13 @@
   }
 
   @Test public void setEncodedPathSegmentEncodes() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/%25/b/c",
         base.newBuilder().setEncodedPathSegment(0, "%25").build().encodedPath());
   }
 
   @Test public void setEncodedPathSegmentRejectsDot() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setEncodedPathSegment(0, ".");
       fail();
@@ -1035,7 +1109,7 @@
   }
 
   @Test public void setEncodedPathSegmentRejectsDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setEncodedPathSegment(0, ".\n");
       fail();
@@ -1044,7 +1118,7 @@
   }
 
   @Test public void setEncodedPathSegmentRejectsDotDot() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setEncodedPathSegment(0, "..");
       fail();
@@ -1053,7 +1127,7 @@
   }
 
   @Test public void setEncodedPathSegmentRejectsDotDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setEncodedPathSegment(0, "..\n");
       fail();
@@ -1062,7 +1136,7 @@
   }
 
   @Test public void setEncodedPathSegmentWithSlash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     HttpUrl url = base.newBuilder().setEncodedPathSegment(1, "/").build();
     assertEquals("/a/%2F/c", url.encodedPath());
   }
@@ -1076,7 +1150,7 @@
   }
 
   @Test public void removePathSegment() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     HttpUrl url = base.newBuilder()
         .removePathSegment(0)
         .build();
@@ -1084,7 +1158,7 @@
   }
 
   @Test public void removePathSegmentDoesntRemovePath() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     HttpUrl url = base.newBuilder()
         .removePathSegment(0)
         .removePathSegment(0)
@@ -1103,19 +1177,19 @@
   }
 
   @Test public void toJavaNetUrl() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://username:password@host/path?query#fragment");
+    HttpUrl httpUrl = parse("http://username:password@host/path?query#fragment");
     URL javaNetUrl = httpUrl.url();
     assertEquals("http://username:password@host/path?query#fragment", javaNetUrl.toString());
   }
 
   @Test public void toUri() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://username:password@host/path?query#fragment");
+    HttpUrl httpUrl = parse("http://username:password@host/path?query#fragment");
     URI uri = httpUrl.uri();
     assertEquals("http://username:password@host/path?query#fragment", uri.toString());
   }
 
   @Test public void toUriSpecialQueryCharacters() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://host/?d=abc!@[]^`{}|\\");
+    HttpUrl httpUrl = parse("http://host/?d=abc!@[]^`{}|\\");
     URI uri = httpUrl.uri();
     assertEquals("http://host/?d=abc!@[]%5E%60%7B%7D%7C%5C", uri.toString());
   }
@@ -1168,8 +1242,11 @@
         .host("host")
         .addQueryParameter("=[]:;\"~|?#@^/$%*", "a")
         .build();
-    assertEquals("http://host/?%3D[]:;%22~|?%23@^/$%25*=a", url.toString());
-    assertEquals("http://host/?%3D[]:;%22~%7C?%23@%5E/$%25*=a", url.uri().toString());
+    assertEquals("http://host/?%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*=a",
+        url.toString());
+    assertEquals("http://host/?%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*=a",
+        url.uri().toString());
+    assertEquals("a", url.queryParameter("=[]:;\"~|?#@^/$%*"));
   }
 
   @Test public void toUriQueryParameterValueSpecialCharacters() throws Exception {
@@ -1178,8 +1255,11 @@
         .host("host")
         .addQueryParameter("a", "=[]:;\"~|?#@^/$%*")
         .build();
-    assertEquals("http://host/?a=%3D[]:;%22~|?%23@^/$%25*", url.toString());
-    assertEquals("http://host/?a=%3D[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
+    assertEquals("http://host/?a=%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*",
+        url.toString());
+    assertEquals("http://host/?a=%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*",
+        url.uri().toString());
+    assertEquals("=[]:;\"~|?#@^/$%*", url.queryParameter("a"));
   }
 
   @Test public void toUriQueryValueSpecialCharacters() throws Exception {
@@ -1192,6 +1272,42 @@
     assertEquals("http://host/?=[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
   }
 
+  @Test public void queryCharactersEncodedWhenComposed() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
+        .build();
+    assertEquals("http://host/?a=%21%24%28%29%2C%2F%3A%3B%3F%40%5B%5D%5C%5E%60%7B%7C%7D%7E",
+        url.toString());
+    assertEquals("!$(),/:;?@[]\\^`{|}~", url.queryParameter("a"));
+  }
+
+  /**
+   * When callers use {@code addEncodedQueryParameter()} we only encode what's strictly required.
+   * We retain the encoded (or non-encoded) state of the input.
+   */
+  @Test public void queryCharactersNotReencodedWhenComposedWithAddEncoded() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addEncodedQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
+        .build();
+    assertEquals("http://host/?a=!$(),/:;?@[]\\^`{|}~",
+        url.toString());
+    assertEquals("!$(),/:;?@[]\\^`{|}~", url.queryParameter("a"));
+  }
+
+  /**
+   * When callers parse a URL with query components that aren't encoded, we shouldn't convert them
+   * into a canonical form because doing so could be semantically different.
+   */
+  @Test public void queryCharactersNotReencodedWhenParsed() throws Exception {
+    HttpUrl url = parse("http://host/?a=!$(),/:;?@[]\\^`{|}~");
+    assertEquals("http://host/?a=!$(),/:;?@[]\\^`{|}~", url.toString());
+    assertEquals("!$(),/:;?@[]\\^`{|}~", url.queryParameter("a"));
+  }
+
   @Test public void toUriFragmentSpecialCharacters() throws Exception {
     HttpUrl url = new HttpUrl.Builder()
         .scheme("http")
@@ -1204,44 +1320,44 @@
 
   @Test public void toUriWithControlCharacters() throws Exception {
     // Percent-encoded in the path.
-    assertEquals(new URI("http://host/a%00b"), HttpUrl.parse("http://host/a\u0000b").uri());
-    assertEquals(new URI("http://host/a%C2%80b"), HttpUrl.parse("http://host/a\u0080b").uri());
-    assertEquals(new URI("http://host/a%C2%9Fb"), HttpUrl.parse("http://host/a\u009fb").uri());
+    assertEquals(new URI("http://host/a%00b"), parse("http://host/a\u0000b").uri());
+    assertEquals(new URI("http://host/a%C2%80b"), parse("http://host/a\u0080b").uri());
+    assertEquals(new URI("http://host/a%C2%9Fb"), parse("http://host/a\u009fb").uri());
     // Percent-encoded in the query.
-    assertEquals(new URI("http://host/?a%00b"), HttpUrl.parse("http://host/?a\u0000b").uri());
-    assertEquals(new URI("http://host/?a%C2%80b"), HttpUrl.parse("http://host/?a\u0080b").uri());
-    assertEquals(new URI("http://host/?a%C2%9Fb"), HttpUrl.parse("http://host/?a\u009fb").uri());
+    assertEquals(new URI("http://host/?a%00b"), parse("http://host/?a\u0000b").uri());
+    assertEquals(new URI("http://host/?a%C2%80b"), parse("http://host/?a\u0080b").uri());
+    assertEquals(new URI("http://host/?a%C2%9Fb"), parse("http://host/?a\u009fb").uri());
     // Stripped from the fragment.
-    assertEquals(new URI("http://host/#a%00b"), HttpUrl.parse("http://host/#a\u0000b").uri());
-    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u0080b").uri());
-    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u009fb").uri());
+    assertEquals(new URI("http://host/#a%00b"), parse("http://host/#a\u0000b").uri());
+    assertEquals(new URI("http://host/#ab"), parse("http://host/#a\u0080b").uri());
+    assertEquals(new URI("http://host/#ab"), parse("http://host/#a\u009fb").uri());
   }
 
   @Test public void toUriWithSpaceCharacters() throws Exception {
     // Percent-encoded in the path.
-    assertEquals(new URI("http://host/a%0Bb"), HttpUrl.parse("http://host/a\u000bb").uri());
-    assertEquals(new URI("http://host/a%20b"), HttpUrl.parse("http://host/a b").uri());
-    assertEquals(new URI("http://host/a%E2%80%89b"), HttpUrl.parse("http://host/a\u2009b").uri());
-    assertEquals(new URI("http://host/a%E3%80%80b"), HttpUrl.parse("http://host/a\u3000b").uri());
+    assertEquals(new URI("http://host/a%0Bb"), parse("http://host/a\u000bb").uri());
+    assertEquals(new URI("http://host/a%20b"), parse("http://host/a b").uri());
+    assertEquals(new URI("http://host/a%E2%80%89b"), parse("http://host/a\u2009b").uri());
+    assertEquals(new URI("http://host/a%E3%80%80b"), parse("http://host/a\u3000b").uri());
     // Percent-encoded in the query.
-    assertEquals(new URI("http://host/?a%0Bb"), HttpUrl.parse("http://host/?a\u000bb").uri());
-    assertEquals(new URI("http://host/?a%20b"), HttpUrl.parse("http://host/?a b").uri());
-    assertEquals(new URI("http://host/?a%E2%80%89b"), HttpUrl.parse("http://host/?a\u2009b").uri());
-    assertEquals(new URI("http://host/?a%E3%80%80b"), HttpUrl.parse("http://host/?a\u3000b").uri());
+    assertEquals(new URI("http://host/?a%0Bb"), parse("http://host/?a\u000bb").uri());
+    assertEquals(new URI("http://host/?a%20b"), parse("http://host/?a b").uri());
+    assertEquals(new URI("http://host/?a%E2%80%89b"), parse("http://host/?a\u2009b").uri());
+    assertEquals(new URI("http://host/?a%E3%80%80b"), parse("http://host/?a\u3000b").uri());
     // Stripped from the fragment.
-    assertEquals(new URI("http://host/#a%0Bb"), HttpUrl.parse("http://host/#a\u000bb").uri());
-    assertEquals(new URI("http://host/#a%20b"), HttpUrl.parse("http://host/#a b").uri());
-    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u2009b").uri());
-    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u3000b").uri());
+    assertEquals(new URI("http://host/#a%0Bb"), parse("http://host/#a\u000bb").uri());
+    assertEquals(new URI("http://host/#a%20b"), parse("http://host/#a b").uri());
+    assertEquals(new URI("http://host/#ab"), parse("http://host/#a\u2009b").uri());
+    assertEquals(new URI("http://host/#ab"), parse("http://host/#a\u3000b").uri());
   }
 
   @Test public void toUriWithNonHexPercentEscape() throws Exception {
-    assertEquals(new URI("http://host/%25xx"), HttpUrl.parse("http://host/%xx").uri());
+    assertEquals(new URI("http://host/%25xx"), parse("http://host/%xx").uri());
   }
 
   @Test public void toUriWithTruncatedPercentEscape() throws Exception {
-    assertEquals(new URI("http://host/%25a"), HttpUrl.parse("http://host/%a").uri());
-    assertEquals(new URI("http://host/%25"), HttpUrl.parse("http://host/%").uri());
+    assertEquals(new URI("http://host/%25a"), parse("http://host/%a").uri());
+    assertEquals(new URI("http://host/%25"), parse("http://host/%").uri());
   }
 
   @Test public void fromJavaNetUrl() throws Exception {
@@ -1271,29 +1387,8 @@
     assertEquals(null, HttpUrl.get(uri));
   }
 
-  @Test public void fromJavaNetUrl_checked() throws Exception {
-    HttpUrl httpUrl = HttpUrl.getChecked("http://username:password@host/path?query#fragment");
-    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
-  }
-
-  @Test public void fromJavaNetUrlUnsupportedScheme_checked() throws Exception {
-    try {
-      HttpUrl.getChecked("mailto:user@example.com");
-      fail();
-    } catch (MalformedURLException e) {
-    }
-  }
-
-  @Test public void fromJavaNetUrlBadHost_checked() throws Exception {
-    try {
-      HttpUrl.getChecked("http://hostw ithspace/");
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
   @Test public void composeQueryWithComponents() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/");
+    HttpUrl base = parse("http://host/");
     HttpUrl url = base.newBuilder().addQueryParameter("a+=& b", "c+=& d").build();
     assertEquals("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d", url.toString());
     assertEquals("c+=& d", url.queryParameterValue(0));
@@ -1307,14 +1402,14 @@
   }
 
   @Test public void composeQueryWithEncodedComponents() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/");
+    HttpUrl base = parse("http://host/");
     HttpUrl url = base.newBuilder().addEncodedQueryParameter("a+=& b", "c+=& d").build();
     assertEquals("http://host/?a+%3D%26%20b=c+%3D%26%20d", url.toString());
     assertEquals("c =& d", url.queryParameter("a =& b"));
   }
 
   @Test public void composeQueryRemoveQueryParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .addQueryParameter("a+=& b", "c+=& d")
         .removeAllQueryParameters("a+=& b")
         .build();
@@ -1323,7 +1418,7 @@
   }
 
   @Test public void composeQueryRemoveEncodedQueryParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .addEncodedQueryParameter("a+=& b", "c+=& d")
         .removeAllEncodedQueryParameters("a+=& b")
         .build();
@@ -1332,7 +1427,7 @@
   }
 
   @Test public void composeQuerySetQueryParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .addQueryParameter("a+=& b", "c+=& d")
         .setQueryParameter("a+=& b", "ef")
         .build();
@@ -1341,7 +1436,7 @@
   }
 
   @Test public void composeQuerySetEncodedQueryParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .addEncodedQueryParameter("a+=& b", "c+=& d")
         .setEncodedQueryParameter("a+=& b", "ef")
         .build();
@@ -1350,7 +1445,7 @@
   }
 
   @Test public void composeQueryMultipleEncodedValuesForParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .addQueryParameter("a+=& b", "c+=& d")
         .addQueryParameter("a+=& b", "e+=& f")
         .build();
@@ -1362,14 +1457,14 @@
   }
 
   @Test public void absentQueryIsZeroNameValuePairs() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .query(null)
         .build();
     assertEquals(0, url.querySize());
   }
 
   @Test public void emptyQueryIsSingleNameValuePairWithEmptyKey() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .query("")
         .build();
     assertEquals(1, url.querySize());
@@ -1378,7 +1473,7 @@
   }
 
   @Test public void ampersandQueryIsTwoNameValuePairsWithEmptyKeys() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .query("&")
         .build();
     assertEquals(2, url.querySize());
@@ -1389,7 +1484,7 @@
   }
 
   @Test public void removeAllDoesNotRemoveQueryIfNoParametersWereRemoved() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .query("")
         .removeAllQueryParameters("a")
         .build();
@@ -1397,7 +1492,7 @@
   }
 
   @Test public void queryParametersWithoutValues() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?foo&bar&baz");
+    HttpUrl url = parse("http://host/?foo&bar&baz");
     assertEquals(3, url.querySize());
     assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
         url.queryParameterNames());
@@ -1410,7 +1505,7 @@
   }
 
   @Test public void queryParametersWithEmptyValues() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?foo=&bar=&baz=");
+    HttpUrl url = parse("http://host/?foo=&bar=&baz=");
     assertEquals(3, url.querySize());
     assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
         url.queryParameterNames());
@@ -1423,7 +1518,7 @@
   }
 
   @Test public void queryParametersWithRepeatedName() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?foo[]=1&foo[]=2&foo[]=3");
+    HttpUrl url = parse("http://host/?foo[]=1&foo[]=2&foo[]=3");
     assertEquals(3, url.querySize());
     assertEquals(Collections.singleton("foo[]"), url.queryParameterNames());
     assertEquals("1", url.queryParameterValue(0));
@@ -1433,7 +1528,7 @@
   }
 
   @Test public void queryParameterLookupWithNonCanonicalEncoding() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?%6d=m&+=%20");
+    HttpUrl url = parse("http://host/?%6d=m&+=%20");
     assertEquals("m", url.queryParameterName(0));
     assertEquals(" ", url.queryParameterName(1));
     assertEquals("m", url.queryParameter("m"));
@@ -1441,7 +1536,7 @@
   }
 
   @Test public void parsedQueryDoesntIncludeFragment() {
-    HttpUrl url = HttpUrl.parse("http://host/?#fragment");
+    HttpUrl url = parse("http://host/?#fragment");
     assertEquals("fragment", url.fragment());
     assertEquals("", url.query());
     assertEquals("", url.encodedQuery());
@@ -1468,7 +1563,7 @@
    */
   @Test public void rawEncodingRetained() throws Exception {
     String urlString = "http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D#%6d%6D";
-    HttpUrl url = HttpUrl.parse(urlString);
+    HttpUrl url = parse(urlString);
     assertEquals("%6d%6D", url.encodedUsername());
     assertEquals("%6d%6D", url.encodedPassword());
     assertEquals("/%6d%6D", url.encodedPath());
@@ -1481,7 +1576,7 @@
   }
 
   @Test public void clearFragment() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#fragment")
+    HttpUrl url = parse("http://host/#fragment")
         .newBuilder()
         .fragment(null)
         .build();
@@ -1491,7 +1586,7 @@
   }
 
   @Test public void clearEncodedFragment() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#fragment")
+    HttpUrl url = parse("http://host/#fragment")
         .newBuilder()
         .encodedFragment(null)
         .build();
@@ -1501,17 +1596,30 @@
   }
 
   @Test public void topPrivateDomain() {
-    assertEquals("google.com", HttpUrl.parse("https://google.com").topPrivateDomain());
-    assertEquals("google.co.uk", HttpUrl.parse("https://adwords.google.co.uk").topPrivateDomain());
-    assertEquals("xn--ewv.xn--4pvxs.jp", HttpUrl.parse("https://栃.栃木.jp").topPrivateDomain());
+    assertEquals("google.com", parse("https://google.com").topPrivateDomain());
+    assertEquals("google.co.uk", parse("https://adwords.google.co.uk").topPrivateDomain());
+    assertEquals("xn--ewv.xn--4pvxs.jp", parse("https://栃.栃木.jp").topPrivateDomain());
     assertEquals("xn--ewv.xn--4pvxs.jp",
-        HttpUrl.parse("https://xn--ewv.xn--4pvxs.jp").topPrivateDomain());
-
-    assertNull(HttpUrl.parse("https://co.uk").topPrivateDomain());
-    assertNull(HttpUrl.parse("https://square").topPrivateDomain());
-    assertNull(HttpUrl.parse("https://栃木.jp").topPrivateDomain());
-    assertNull(HttpUrl.parse("https://xn--4pvxs.jp").topPrivateDomain());
-    assertNull(HttpUrl.parse("https://localhost").topPrivateDomain());
-    assertNull(HttpUrl.parse("https://127.0.0.1").topPrivateDomain());
+        parse("https://xn--ewv.xn--4pvxs.jp").topPrivateDomain());
+
+    assertNull(parse("https://co.uk").topPrivateDomain());
+    assertNull(parse("https://square").topPrivateDomain());
+    assertNull(parse("https://栃木.jp").topPrivateDomain());
+    assertNull(parse("https://xn--4pvxs.jp").topPrivateDomain());
+    assertNull(parse("https://localhost").topPrivateDomain());
+    assertNull(parse("https://127.0.0.1").topPrivateDomain());
+  }
+
+  private void assertInvalid(String string, String exceptionMessage) {
+    if (useGet) {
+      try {
+        parse(string);
+        fail("Expected get of \"" + string + "\" to throw with: " + exceptionMessage);
+      } catch (IllegalArgumentException e) {
+        assertEquals(exceptionMessage, e.getMessage());
+      }
+    } else {
+      assertNull(string, parse(string));
+    }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
index e01a360b9b..a1ad679f34 100644
--- a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
@@ -67,7 +67,7 @@
         .protocol(Protocol.HTTP_1_1)
         .code(200)
         .message("Intercepted!")
-        .body(ResponseBody.create(MediaType.parse("text/plain; charset=utf-8"), "abc"))
+        .body(ResponseBody.create(MediaType.get("text/plain; charset=utf-8"), "abc"))
         .build();
 
     client = client.newBuilder()
@@ -91,7 +91,7 @@
             .protocol(Protocol.HTTP_1_1)
             .code(200)
             .message("Intercepted!")
-            .body(ResponseBody.create(MediaType.parse("text/plain; charset=utf-8"), "abc"))
+            .body(ResponseBody.create(MediaType.get("text/plain; charset=utf-8"), "abc"))
             .build();
       }
     };
@@ -148,7 +148,7 @@
         String sameHost = address.url().host();
         int differentPort = address.url().port() + 1;
         return chain.proceed(chain.request().newBuilder()
-            .url(HttpUrl.parse("http://" + sameHost + ":" + differentPort + "/"))
+            .url("http://" + sameHost + ":" + differentPort + "/")
             .build());
       }
     };
@@ -234,7 +234,7 @@
     Interceptor interceptor = new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Request originalRequest = chain.request();
-        MediaType mediaType = MediaType.parse("text/plain");
+        MediaType mediaType = MediaType.get("text/plain");
         RequestBody body = RequestBody.create(mediaType, "abc");
         return chain.proceed(originalRequest.newBuilder()
             .method("POST", body)
@@ -283,7 +283,7 @@ private void rewriteRequestToServer(boolean network) throws Exception {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .addHeader("Original-Header", "foo")
-        .method("PUT", RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .method("PUT", RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     client.newCall(request).execute();
@@ -818,7 +818,7 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
     byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
     Request request1 = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), data))
+        .post(RequestBody.create(MediaType.get("text/plain"), data))
         .build();
     Call call = client.newCall(request1);
 
@@ -944,7 +944,7 @@ public ExceptionCatchingExecutor() {
       });
     }
 
-    public Exception takeException() throws InterruptedException {
+    public Exception takeException() throws Exception {
       return exceptions.take();
     }
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
index b2d3f396fa..f0b194713d 100644
--- a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
@@ -17,12 +17,17 @@
 package okhttp3;
 
 import java.nio.charset.Charset;
+import java.util.Arrays;
+import java.util.Collection;
 import okhttp3.internal.Util;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 /**
  * Test MediaType API and parsing.
@@ -30,16 +35,34 @@
  * <p>This test includes tests from <a href="https://code.google.com/p/guava-libraries/">Guava's</a>
  * MediaTypeTest.
  */
+@RunWith(Parameterized.class)
 public class MediaTypeTest {
+  @Parameterized.Parameters(name = "Use get = {0}")
+  public static Collection<Object[]> parameters() {
+    return Arrays.asList(
+        new Object[] { true },
+        new Object[] { false }
+    );
+  }
+
+  @Parameterized.Parameter
+  public boolean useGet;
+
+  private MediaType parse(String string) {
+    return useGet
+        ? MediaType.get(string)
+        : MediaType.parse(string);
+  }
+
   @Test public void testParse() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;boundary=foo;charset=utf-8");
+    MediaType mediaType = parse("text/plain;boundary=foo;charset=utf-8");
     assertEquals("text", mediaType.type());
     assertEquals("plain", mediaType.subtype());
     assertEquals("UTF-8", mediaType.charset().name());
     assertEquals("text/plain;boundary=foo;charset=utf-8", mediaType.toString());
-    assertTrue(mediaType.equals(MediaType.parse("text/plain;boundary=foo;charset=utf-8")));
+    assertTrue(mediaType.equals(parse("text/plain;boundary=foo;charset=utf-8")));
     assertEquals(mediaType.hashCode(),
-        MediaType.parse("text/plain;boundary=foo;charset=utf-8").hashCode());
+        parse("text/plain;boundary=foo;charset=utf-8").hashCode());
   }
 
   @Test public void testValidParse() throws Exception {
@@ -61,75 +84,86 @@
   }
 
   @Test public void testInvalidParse() throws Exception {
-    assertInvalid("");
-    assertInvalid("/");
-    assertInvalid("/");
-    assertInvalid("text");
-    assertInvalid("text/");
-    assertInvalid("te<t/plain");
-    assertInvalid("text/pl@in");
-    assertInvalid("text/plain; a");
-    assertInvalid("text/plain; a=");
-    assertInvalid("text/plain; a=@");
-    assertInvalid("text/plain; a=\"@");
-    assertInvalid("text/plain; a=1; b");
-    assertInvalid("text/plain; a=1; b=");
-    assertInvalid("text/plain; a=\u2025");
-    assertInvalid(" text/plain");
-    assertInvalid("te xt/plain");
-    assertInvalid("text /plain");
-    assertInvalid("text/ plain");
-    assertInvalid("text/pl ain");
-    assertInvalid("text/plain ");
-    assertInvalid("text/plain ; a=1");
+    assertInvalid("", "No subtype found for: \"\"");
+    assertInvalid("/", "No subtype found for: \"/\"");
+    assertInvalid("text", "No subtype found for: \"text\"");
+    assertInvalid("text/", "No subtype found for: \"text/\"");
+    assertInvalid("te<t/plain", "No subtype found for: \"te<t/plain\"");
+    assertInvalid(" text/plain", "No subtype found for: \" text/plain\"");
+    assertInvalid("te xt/plain", "No subtype found for: \"te xt/plain\"");
+    assertInvalid("text /plain", "No subtype found for: \"text /plain\"");
+    assertInvalid("text/ plain", "No subtype found for: \"text/ plain\"");
+
+    assertInvalid("text/pl@in",
+        "Parameter is not formatted correctly: \"@in\" for: \"text/pl@in\"");
+    assertInvalid("text/plain; a",
+        "Parameter is not formatted correctly: \"a\" for: \"text/plain; a\"");
+    assertInvalid("text/plain; a=",
+        "Parameter is not formatted correctly: \"a=\" for: \"text/plain; a=\"");
+    assertInvalid("text/plain; a=@",
+        "Parameter is not formatted correctly: \"a=@\" for: \"text/plain; a=@\"");
+    assertInvalid("text/plain; a=\"@",
+        "Parameter is not formatted correctly: \"a=\"@\" for: \"text/plain; a=\"@\"");
+    assertInvalid("text/plain; a=1; b",
+        "Parameter is not formatted correctly: \"b\" for: \"text/plain; a=1; b\"");
+    assertInvalid("text/plain; a=1; b=",
+        "Parameter is not formatted correctly: \"b=\" for: \"text/plain; a=1; b=\"");
+    assertInvalid("text/plain; a=\u2025",
+        "Parameter is not formatted correctly: \"a=‥\" for: \"text/plain; a=‥\"");
+    assertInvalid("text/pl ain",
+        "Parameter is not formatted correctly: \" ain\" for: \"text/pl ain\"");
+    assertInvalid("text/plain ",
+        "Parameter is not formatted correctly: \" \" for: \"text/plain \"");
+    assertInvalid("text/plain ; a=1",
+        "Parameter is not formatted correctly: \" ; a=1\" for: \"text/plain ; a=1\"");
   }
 
   @Test public void testDoubleQuotesAreSpecial() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;a=\";charset=utf-8;b=\"");
+    MediaType mediaType = parse("text/plain;a=\";charset=utf-8;b=\"");
     assertNull(mediaType.charset());
   }
 
   @Test public void testSingleQuotesAreNotSpecial() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;a=';charset=utf-8;b='");
+    MediaType mediaType = parse("text/plain;a=';charset=utf-8;b='");
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
   @Test public void testParseWithSpecialCharacters() throws Exception {
-    MediaType mediaType = MediaType.parse(
-        "!#$%&'*+-.{|}~/!#$%&'*+-.{|}~; !#$%&'*+-.{|}~=!#$%&'*+-.{|}~");
+    MediaType mediaType = parse("!#$%&'*+-.{|}~/!#$%&'*+-.{|}~; !#$%&'*+-.{|}~=!#$%&'*+-.{|}~");
     assertEquals("!#$%&'*+-.{|}~", mediaType.type());
     assertEquals("!#$%&'*+-.{|}~", mediaType.subtype());
   }
 
   @Test public void testCharsetIsOneOfManyParameters() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;a=1;b=2;charset=utf-8;c=3");
+    MediaType mediaType = parse("text/plain;a=1;b=2;charset=utf-8;c=3");
     assertEquals("text", mediaType.type());
     assertEquals("plain", mediaType.subtype());
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
   @Test public void testCharsetAndQuoting() throws Exception {
-    MediaType mediaType = MediaType.parse(
+    MediaType mediaType = parse(
         "text/plain;a=\";charset=us-ascii\";charset=\"utf-8\";b=\"iso-8859-1\"");
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
   @Test public void testDuplicatedCharsets() {
-    MediaType mediaType = MediaType.parse("text/plain; charset=utf-8; charset=UTF-8");
+    MediaType mediaType = parse("text/plain; charset=utf-8; charset=UTF-8");
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
   @Test public void testMultipleCharsets() {
-    assertNull(MediaType.parse("text/plain; charset=utf-8; charset=utf-16"));
+    assertInvalid("text/plain; charset=utf-8; charset=utf-16",
+        "Multiple charsets defined: \"utf-8\" and: \"utf-16\" for: \"text/plain; charset=utf-8; charset=utf-16\"");
   }
 
   @Test public void testIllegalCharsetName() {
-    MediaType mediaType = MediaType.parse("text/plain; charset=\"!@#$%^&*()\"");
+    MediaType mediaType = parse("text/plain; charset=\"!@#$%^&*()\"");
     assertNull(mediaType.charset());
   }
 
   @Test public void testUnsupportedCharset() {
-    MediaType mediaType = MediaType.parse("text/plain; charset=utf-wtf");
+    MediaType mediaType = parse("text/plain; charset=utf-wtf");
     assertNull(mediaType.charset());
   }
 
@@ -138,32 +172,32 @@
    * unpleasant IllegalCharsetNameException.
    */
   @Test public void testCharsetNameIsSingleQuoted() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;charset='utf-8'");
+    MediaType mediaType = parse("text/plain;charset='utf-8'");
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
   @Test public void testCharsetNameIsDoubleQuotedAndSingleQuoted() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;charset=\"'utf-8'\"");
+    MediaType mediaType = parse("text/plain;charset=\"'utf-8'\"");
     assertNull(mediaType.charset());
   }
 
   @Test public void testCharsetNameIsDoubleQuotedSingleQuote() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;charset=\"'\"");
+    MediaType mediaType = parse("text/plain;charset=\"'\"");
     assertNull(mediaType.charset());
   }
 
   @Test public void testDefaultCharset() throws Exception {
-    MediaType noCharset = MediaType.parse("text/plain");
+    MediaType noCharset = parse("text/plain");
     assertEquals("UTF-8", noCharset.charset(Util.UTF_8).name());
     assertEquals("US-ASCII", noCharset.charset(Charset.forName("US-ASCII")).name());
 
-    MediaType charset = MediaType.parse("text/plain; charset=iso-8859-1");
+    MediaType charset = parse("text/plain; charset=iso-8859-1");
     assertEquals("ISO-8859-1", charset.charset(Util.UTF_8).name());
     assertEquals("ISO-8859-1", charset.charset(Charset.forName("US-ASCII")).name());
   }
 
   @Test public void testParseDanglingSemicolon() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;");
+    MediaType mediaType = parse("text/plain;");
     assertEquals("text", mediaType.type());
     assertEquals("plain", mediaType.subtype());
     assertNull(mediaType.charset());
@@ -171,11 +205,19 @@
   }
 
   private void assertMediaType(String string) {
-    MediaType mediaType = MediaType.parse(string);
-    assertEquals(string, mediaType.toString());
-  }
-
-  private void assertInvalid(String string) {
-    assertNull(string, MediaType.parse(string));
+    assertEquals(string, parse(string).toString());
+  }
+
+  private void assertInvalid(String string, String exceptionMessage) {
+    if (useGet) {
+      try {
+        parse(string);
+        fail("Expected get of \"" + string + "\" to throw with: " + exceptionMessage);
+      } catch (IllegalArgumentException e) {
+        assertEquals(exceptionMessage, e.getMessage());
+      }
+    } else {
+      assertNull(string, parse(string));
+    }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
index 35d2f67906..f936d56a80 100644
--- a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
@@ -129,13 +129,13 @@
                 .addPart(
                     Headers.of("Content-Disposition", "file; filename=\"file1.txt\""),
                     RequestBody.create(
-                        MediaType.parse("text/plain"), "... contents of file1.txt ..."))
+                        MediaType.get("text/plain"), "... contents of file1.txt ..."))
                 .addPart(
                     Headers.of(
                         "Content-Disposition", "file; filename=\"file2.gif\"",
                         "Content-Transfer-Encoding", "binary"),
                     RequestBody.create(
-                        MediaType.parse("image/gif"),
+                        MediaType.get("image/gif"),
                         "... contents of file2.gif ...".getBytes(UTF_8)))
                 .build())
         .build();
@@ -171,7 +171,7 @@
         + "\r\n"
         + "%22\r\n"
         + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"field with \u0391\"\r\n"
+        + "Content-Disposition: form-data; name=\"field with \u007e\"\r\n"
         + "Content-Length: 5\r\n"
         + "\r\n"
         + "Alpha\r\n"
@@ -180,10 +180,10 @@
     MultipartBody body = new MultipartBody.Builder("AaB03x")
         .setType(MultipartBody.FORM)
         .addFormDataPart("field with spaces", "filename with spaces.txt",
-            RequestBody.create(MediaType.parse("text/plain; charset=utf-8"), "okay"))
+            RequestBody.create(MediaType.get("text/plain; charset=utf-8"), "okay"))
         .addFormDataPart("field with \"", "\"")
         .addFormDataPart("field with %22", "%22")
-        .addFormDataPart("field with \u0391", "Alpha")
+        .addFormDataPart("field with \u007e", "Alpha")
         .build();
 
     Buffer buffer = new Buffer();
diff --git a/okhttp-tests/src/test/java/okhttp3/NullServer.java b/okhttp-tests/src/test/java/okhttp3/NullServer.java
deleted file mode 100644
index 30a84f8ead..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/NullServer.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.ServerSocket;
-import javax.net.ServerSocketFactory;
-import okhttp3.internal.Util;
-
-public final class NullServer {
-  private InetSocketAddress address;
-  private ServerSocket nullServer;
-
-  public void start() throws Exception {
-    nullServer = ServerSocketFactory.getDefault().createServerSocket();
-    nullServer.bind(address, 0);
-    address = new InetSocketAddress(InetAddress.getByName("localhost"), nullServer.getLocalPort());
-  }
-
-  public void shutdown() {
-    Util.closeQuietly(nullServer);
-  }
-
-  public HttpUrl url(String scheme) {
-    return new HttpUrl.Builder()
-        .scheme(scheme)
-        .host(address.getHostName())
-        .port(nullServer.getLocalPort())
-        .build();
-  }
-
-  public InetSocketAddress address() {
-    return address;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
index 5582f3ce83..f84b557b56 100644
--- a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
@@ -22,7 +22,11 @@
 import java.net.ResponseCache;
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
@@ -35,8 +39,14 @@
   private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
   private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
   private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();
+  private final MockWebServer server = new MockWebServer();
+
+  @Before public void setUp() throws Exception {
+    server.start();
+  }
 
   @After public void tearDown() throws Exception {
+    server.shutdown();
     ProxySelector.setDefault(DEFAULT_PROXY_SELECTOR);
     CookieManager.setDefault(DEFAULT_COOKIE_HANDLER);
     ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
@@ -44,6 +54,7 @@
 
   @Test public void durationDefaults() {
     OkHttpClient client = defaultClient();
+    assertEquals(0, client.callTimeoutMillis());
     assertEquals(10_000, client.connectTimeoutMillis());
     assertEquals(10_000, client.readTimeoutMillis());
     assertEquals(10_000, client.writeTimeoutMillis());
@@ -52,6 +63,10 @@
 
   @Test public void timeoutValidRange() {
     OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.callTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
     try {
       builder.connectTimeout(1, TimeUnit.NANOSECONDS);
     } catch (IllegalArgumentException ignored) {
@@ -64,6 +79,10 @@
       builder.readTimeout(1, TimeUnit.NANOSECONDS);
     } catch (IllegalArgumentException ignored) {
     }
+    try {
+      builder.callTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
     try {
       builder.connectTimeout(365, TimeUnit.DAYS);
     } catch (IllegalArgumentException ignored) {
@@ -169,4 +188,56 @@
       assertEquals("Null network interceptor: [null]", expected.getMessage());
     }
   }
+
+  @Test public void testH2PriorKnowledgeOkHttpClientConstructionFallback() {
+    try {
+      new OkHttpClient.Builder()
+          .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
+          + "[h2_prior_knowledge, http/1.1]", expected.getMessage());
+    }
+  }
+
+  @Test public void testH2PriorKnowledgeOkHttpClientConstructionDuplicates() {
+    try {
+      new OkHttpClient.Builder()
+          .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
+          + "[h2_prior_knowledge, h2_prior_knowledge]", expected.getMessage());
+    }
+  }
+
+  @Test public void testH2PriorKnowledgeOkHttpClientConstructionSuccess() {
+    OkHttpClient okHttpClient = new OkHttpClient.Builder()
+        .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE))
+        .build();
+    assertEquals(1, okHttpClient.protocols().size());
+    assertEquals(Protocol.H2_PRIOR_KNOWLEDGE, okHttpClient.protocols().get(0));
+  }
+
+  @Test public void nullDefaultProxySelector() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    ProxySelector.setDefault(null);
+
+    OkHttpClient client = defaultClient().newBuilder()
+        .build();
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    Response response = client.newCall(request).execute();
+    assertEquals("abc", response.body().string());
+  }
+
+  @Test public void sslSocketFactorySetAsSocketFactory() throws Exception {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.socketFactory(SSLSocketFactory.getDefault());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java b/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java
new file mode 100644
index 0000000000..78b408093d
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class ProtocolTest {
+  @Test
+  public void testGetKnown() throws IOException {
+    assertEquals(Protocol.HTTP_1_0, Protocol.get("http/1.0"));
+    assertEquals(Protocol.HTTP_1_1, Protocol.get("http/1.1"));
+    assertEquals(Protocol.SPDY_3, Protocol.get("spdy/3.1"));
+    assertEquals(Protocol.HTTP_2, Protocol.get("h2"));
+    assertEquals(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.get("h2_prior_knowledge"));
+    assertEquals(Protocol.QUIC, Protocol.get("quic"));
+  }
+
+  @Test(expected = IOException.class)
+  public void testGetUnknown() throws IOException {
+    Protocol.get("tcp");
+  }
+
+  @Test
+  public void testToString() throws IOException {
+    assertEquals("http/1.0", Protocol.HTTP_1_0.toString());
+    assertEquals("http/1.1", Protocol.HTTP_1_1.toString());
+    assertEquals("spdy/3.1", Protocol.SPDY_3.toString());
+    assertEquals("h2", Protocol.HTTP_2.toString());
+    assertEquals("h2_prior_knowledge", Protocol.H2_PRIOR_KNOWLEDGE.toString());
+    assertEquals("quic", Protocol.QUIC.toString());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
index 5c205d7031..50b7bcb53d 100644
--- a/okhttp-tests/src/test/java/okhttp3/RequestTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
@@ -21,17 +21,19 @@
 import java.net.URI;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.UUID;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.fail;
 
 public final class RequestTest {
   @Test public void string() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain; charset=utf-8");
+    MediaType contentType = MediaType.get("text/plain; charset=utf-8");
     RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
@@ -40,15 +42,15 @@
   }
 
   @Test public void stringWithDefaultCharsetAdded() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain");
+    MediaType contentType = MediaType.get("text/plain");
     RequestBody body = RequestBody.create(contentType, "\u0800");
-    assertEquals(MediaType.parse("text/plain; charset=utf-8"), body.contentType());
+    assertEquals(MediaType.get("text/plain; charset=utf-8"), body.contentType());
     assertEquals(3, body.contentLength());
     assertEquals("e0a080", bodyToHex(body));
   }
 
   @Test public void stringWithNonDefaultCharsetSpecified() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain; charset=utf-16be");
+    MediaType contentType = MediaType.get("text/plain; charset=utf-16be");
     RequestBody body = RequestBody.create(contentType, "\u0800");
     assertEquals(contentType, body.contentType());
     assertEquals(2, body.contentLength());
@@ -56,7 +58,7 @@
   }
 
   @Test public void byteArray() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain");
+    MediaType contentType = MediaType.get("text/plain");
     RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
@@ -65,7 +67,7 @@
   }
 
   @Test public void byteArrayRange() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain");
+    MediaType contentType = MediaType.get("text/plain");
     RequestBody body = RequestBody.create(contentType, ".abcd".getBytes(Util.UTF_8), 1, 3);
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
@@ -79,7 +81,7 @@
     writer.write("abc");
     writer.close();
 
-    MediaType contentType = MediaType.parse("text/plain");
+    MediaType contentType = MediaType.get("text/plain");
     RequestBody body = RequestBody.create(contentType, file);
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
@@ -89,7 +91,7 @@
 
   /** Common verbs used for apis such as GitHub, AWS, and Google Cloud. */
   @Test public void crudVerbs() throws IOException {
-    MediaType contentType = MediaType.parse("application/json");
+    MediaType contentType = MediaType.get("application/json");
     RequestBody body = RequestBody.create(contentType, "{}");
 
     Request get = new Request.Builder().url("http://localhost/api").get().build();
@@ -120,24 +122,24 @@
   @Test public void uninitializedURI() throws Exception {
     Request request = new Request.Builder().url("http://localhost/api").build();
     assertEquals(new URI("http://localhost/api"), request.url().uri());
-    assertEquals(HttpUrl.parse("http://localhost/api"), request.url());
+    assertEquals(HttpUrl.get("http://localhost/api"), request.url());
   }
 
-  @Test public void newBuilderUrlResetsUrl() throws Exception {
+  @Test public void newBuilderUrlResetsUrl() {
     Request requestWithoutCache = new Request.Builder().url("http://localhost/api").build();
     Request builtRequestWithoutCache =
         requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
-    assertEquals(HttpUrl.parse("http://localhost/api/foo"), builtRequestWithoutCache.url());
+    assertEquals(HttpUrl.get("http://localhost/api/foo"), builtRequestWithoutCache.url());
 
     Request requestWithCache = new Request.Builder().url("http://localhost/api").build();
     // cache url object
     requestWithCache.url();
     Request builtRequestWithCache = requestWithCache.newBuilder().url(
         "http://localhost/api/foo").build();
-    assertEquals(HttpUrl.parse("http://localhost/api/foo"), builtRequestWithCache.url());
+    assertEquals(HttpUrl.get("http://localhost/api/foo"), builtRequestWithCache.url());
   }
 
-  @Test public void cacheControl() throws Exception {
+  @Test public void cacheControl() {
     Request request = new Request.Builder()
         .cacheControl(new CacheControl.Builder().noCache().build())
         .url("https://square.com")
@@ -145,7 +147,7 @@
     assertEquals(Arrays.asList("no-cache"), request.headers("Cache-Control"));
   }
 
-  @Test public void emptyCacheControlClearsAllCacheControlHeaders() throws Exception {
+  @Test public void emptyCacheControlClearsAllCacheControlHeaders() {
     Request request = new Request.Builder()
         .header("Cache-Control", "foo")
         .cacheControl(new CacheControl.Builder().build())
@@ -154,13 +156,13 @@
     assertEquals(Collections.<String>emptyList(), request.headers("Cache-Control"));
   }
 
-  @Test public void headerAcceptsPermittedCharacters() throws Exception {
+  @Test public void headerAcceptsPermittedCharacters() {
     Request.Builder builder = new Request.Builder();
     builder.header("AZab09~", "AZab09 ~");
     builder.addHeader("AZab09~", "AZab09 ~");
   }
 
-  @Test public void emptyNameForbidden() throws Exception {
+  @Test public void emptyNameForbidden() {
     Request.Builder builder = new Request.Builder();
     try {
       builder.header("", "Value");
@@ -174,7 +176,7 @@
     }
   }
 
-  @Test public void headerForbidsNullArguments() throws Exception {
+  @Test public void headerForbidsNullArguments() {
     Request.Builder builder = new Request.Builder();
     try {
       builder.header(null, "Value");
@@ -198,7 +200,7 @@
     }
   }
 
-  @Test public void headerAllowsTabOnlyInValues() throws Exception {
+  @Test public void headerAllowsTabOnlyInValues() {
     Request.Builder builder = new Request.Builder();
     builder.header("key", "sample\tvalue");
     try {
@@ -208,7 +210,7 @@
     }
   }
 
-  @Test public void headerForbidsControlCharacters() throws Exception {
+  @Test public void headerForbidsControlCharacters() {
     assertForbiddenHeader("\u0000");
     assertForbiddenHeader("\r");
     assertForbiddenHeader("\n");
@@ -242,6 +244,111 @@ private void assertForbiddenHeader(String s) {
     }
   }
 
+  @Test public void noTag() {
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .build();
+    assertNull(request.tag());
+    assertNull(request.tag(Object.class));
+    assertNull(request.tag(UUID.class));
+    assertNull(request.tag(String.class));
+  }
+
+  @Test public void defaultTag() {
+    UUID tag = UUID.randomUUID();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(tag)
+        .build();
+    assertSame(tag, request.tag());
+    assertSame(tag, request.tag(Object.class));
+    assertNull(request.tag(UUID.class));
+    assertNull(request.tag(String.class));
+  }
+
+  @Test public void nullRemovesTag() {
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag("a")
+        .tag(null)
+        .build();
+    assertNull(request.tag());
+  }
+
+  @Test public void removeAbsentTag() {
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(null)
+        .build();
+    assertNull(request.tag());
+  }
+
+  @Test public void objectTag() {
+    UUID tag = UUID.randomUUID();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(Object.class, tag)
+        .build();
+    assertSame(tag, request.tag());
+    assertSame(tag, request.tag(Object.class));
+    assertNull(request.tag(UUID.class));
+    assertNull(request.tag(String.class));
+  }
+
+  @Test public void typedTag() {
+    UUID uuidTag = UUID.randomUUID();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(UUID.class, uuidTag)
+        .build();
+    assertNull(request.tag());
+    assertNull(request.tag(Object.class));
+    assertSame(uuidTag, request.tag(UUID.class));
+    assertNull(request.tag(String.class));
+  }
+
+  @Test public void replaceOnlyTag() {
+    UUID uuidTag1 = UUID.randomUUID();
+    UUID uuidTag2 = UUID.randomUUID();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(UUID.class, uuidTag1)
+        .tag(UUID.class, uuidTag2)
+        .build();
+    assertSame(uuidTag2, request.tag(UUID.class));
+  }
+
+  @Test public void multipleTags() {
+    UUID uuidTag = UUID.randomUUID();
+    String stringTag = "dilophosaurus";
+    Long longTag = 20170815L;
+    Object objectTag = new Object();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(Object.class, objectTag)
+        .tag(UUID.class, uuidTag)
+        .tag(String.class, stringTag)
+        .tag(Long.class, longTag)
+        .build();
+    assertSame(objectTag, request.tag());
+    assertSame(objectTag, request.tag(Object.class));
+    assertSame(uuidTag, request.tag(UUID.class));
+    assertSame(stringTag, request.tag(String.class));
+    assertSame(longTag, request.tag(Long.class));
+  }
+
+  /** Confirm that we don't accidentally share the backing map between objects. */
+  @Test public void tagsAreImmutable() {
+    Request.Builder builder = new Request.Builder()
+        .url("https://square.com");
+    Request requestA = builder.tag(String.class, "a").build();
+    Request requestB = builder.tag(String.class, "b").build();
+    Request requestC = requestA.newBuilder().tag(String.class, "c").build();
+    assertSame("a", requestA.tag(String.class));
+    assertSame("b", requestB.tag(String.class));
+    assertSame("c", requestC.tag(String.class));
+  }
+
   private String bodyToHex(RequestBody body) throws IOException {
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
index 47feecacb6..40f994c526 100644
--- a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
@@ -396,8 +396,8 @@ static ResponseBody body(String hex) {
   }
 
   static ResponseBody body(String hex, String charset) {
-    MediaType mediaType = charset == null ? null : MediaType.parse("any/thing; charset=" + charset);
-    return ResponseBody.create(mediaType, ByteString.decodeHex(hex).toByteArray());
+    MediaType mediaType = charset == null ? null : MediaType.get("any/thing; charset=" + charset);
+    return ResponseBody.create(mediaType, ByteString.decodeHex(hex));
   }
 
   static String exhaust(Reader reader) throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
index 0ec9bc34fb..055b25e226 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
@@ -15,6 +15,8 @@
  */
 package okhttp3;
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
@@ -42,7 +44,13 @@
   @Override public void close() {
   }
 
-  public String take() throws InterruptedException {
+  public List<String> takeAll() {
+    List<String> list = new ArrayList<>();
+    logs.drainTo(list);
+    return list;
+  }
+
+  public String take() throws Exception {
     String message = logs.poll(10, TimeUnit.SECONDS);
     if (message == null) {
       throw new AssertionError("Timed out waiting for log message.");
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index eaaa4c071c..963f45f333 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -67,7 +67,6 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.RecordingAuthenticator;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
 import okhttp3.internal.huc.OkHttpURLConnection;
@@ -76,7 +75,7 @@
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -88,6 +87,7 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
+import static java.util.Locale.US;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static okhttp3.TestUtil.defaultClient;
@@ -102,6 +102,7 @@
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -116,12 +117,12 @@
   @Rule public final MockWebServer server2 = new MockWebServer();
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
 
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
   private OkUrlFactory urlFactory;
   private HttpURLConnection connection;
   private Cache cache;
 
-  @Before public void setUp() throws Exception {
+  @Before public void setUp() {
     server.setProtocolNegotiationEnabled(false);
     urlFactory = new OkUrlFactory(defaultClient());
   }
@@ -140,7 +141,7 @@
     }
   }
 
-  @Test public void requestHeaders() throws IOException, InterruptedException {
+  @Test public void requestHeaders() throws Exception {
     server.enqueue(new MockResponse());
 
     connection = urlFactory.open(server.url("/").url());
@@ -201,14 +202,14 @@
     }
   }
 
-  @Test public void getRequestPropertyReturnsLastValue() throws Exception {
+  @Test public void getRequestPropertyReturnsLastValue() {
     connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("A", "value1");
     connection.addRequestProperty("A", "value2");
     assertEquals("value2", connection.getRequestProperty("A"));
   }
 
-  @Test public void responseHeaders() throws IOException, InterruptedException {
+  @Test public void responseHeaders() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 Fantastic")
         .addHeader("A: c")
         .addHeader("B: d")
@@ -242,7 +243,7 @@
     connection.getInputStream().close();
   }
 
-  @Test public void serverSendsInvalidResponseHeaders() throws Exception {
+  @Test public void serverSendsInvalidResponseHeaders() {
     server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
 
     connection = urlFactory.open(server.url("/").url());
@@ -253,7 +254,7 @@
     }
   }
 
-  @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
+  @Test public void serverSendsInvalidCodeTooLarge() {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
 
     connection = urlFactory.open(server.url("/").url());
@@ -264,7 +265,7 @@
     }
   }
 
-  @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
+  @Test public void serverSendsInvalidCodeNotANumber() {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
 
     connection = urlFactory.open(server.url("/").url());
@@ -275,7 +276,7 @@
     }
   }
 
-  @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
+  @Test public void serverSendsUnnecessaryWhitespace() {
     server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
 
     connection = urlFactory.open(server.url("/").url());
@@ -386,7 +387,7 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
 
   // Check that we recognize a few basic mime types by extension.
   // http://code.google.com/p/android/issues/detail?id=10100
-  @Test public void bug10100() throws Exception {
+  @Test public void bug10100() {
     assertEquals("image/jpeg", URLConnection.guessContentTypeFromName("someFile.jpg"));
     assertEquals("application/pdf", URLConnection.guessContentTypeFromName("stuff.pdf"));
   }
@@ -554,11 +555,12 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void connectViaHttps() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = urlFactory.open(server.url("/foo").url());
@@ -570,11 +572,12 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void inspectHandshakeThroughoutRequestLifecycle() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse());
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
 
@@ -610,12 +613,12 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
 
     // The pool will only reuse sockets if the SSL socket factories are the same.
-    SSLSocketFactory clientSocketFactory = sslClient.socketFactory;
+    SSLSocketFactory clientSocketFactory = handshakeCertificates.sslSocketFactory();
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
     CookieJar cookieJar = new JavaNetCookieJar(new CookieManager());
@@ -625,7 +628,7 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
         .cache(cache)
         .connectionPool(connectionPool)
         .cookieJar(cookieJar)
-        .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
+        .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
     connection = urlFactory.open(server.url("/").url());
@@ -636,7 +639,7 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
           .cache(cache)
           .connectionPool(connectionPool)
           .cookieJar(cookieJar)
-          .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
+          .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
           .hostnameVerifier(hostnameVerifier)
           .build());
     }
@@ -649,13 +652,14 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
   }
 
   @Test public void connectViaHttpsReusingConnectionsDifferentFactories() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
 
     // install a custom SSL socket factory so the server can be authorized
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
@@ -684,14 +688,16 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
   // TODO(jwilson): tests below this marker need to be migrated to OkHttp's request/response API.
 
   @Test public void connectViaHttpsWithSSLFallback() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("this response comes via SSL"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build());
     connection = urlFactory.open(server.url("/foo").url());
 
@@ -702,19 +708,19 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
 
     RecordedRequest fallbackRequest = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", fallbackRequest.getRequestLine());
-    assertEquals(TlsVersion.TLS_1_0, fallbackRequest.getTlsVersion());
+    assertEquals(TlsVersion.TLS_1_2, fallbackRequest.getTlsVersion());
   }
 
-  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new SingleInetAddressDns())
         .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build());
     connection = urlFactory.open(server.url("/foo").url());
 
@@ -733,7 +739,7 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
    * https://github.com/square/okhttp/issues/515
    */
   @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .setSocketPolicy(DISCONNECT_AT_END));
@@ -741,7 +747,8 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build());
 
     assertContent("abc", urlFactory.open(server.url("/").url()));
@@ -766,8 +773,8 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
    *
    * http://code.google.com/p/android/issues/detail?id=13178
    */
-  @Test public void connectViaHttpsToUntrustedServer() throws IOException, InterruptedException {
-    server.useHttps(sslClient.socketFactory, false);
+  @Test public void connectViaHttpsToUntrustedServer() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()); // unused
 
     connection = urlFactory.open(server.url("/foo").url());
@@ -824,7 +831,7 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
     }
   }
 
-  public void testConnectViaSocketFactory(boolean useHttps) throws IOException {
+  private void testConnectViaSocketFactory(boolean useHttps) throws IOException {
     SocketFactory uselessSocketFactory = new SocketFactory() {
       public Socket createSocket() {
         throw new IllegalArgumentException("useless");
@@ -849,9 +856,10 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
     };
 
     if (useHttps) {
-      server.useHttps(sslClient.socketFactory, false);
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
       urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+          .sslSocketFactory(
+              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
           .hostnameVerifier(new RecordingHostnameVerifier())
           .build());
     }
@@ -929,12 +937,13 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
   }
 
   private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
 
     URL url = server.url("/foo").url();
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = proxyConfig.connect(server, urlFactory, url);
@@ -968,14 +977,15 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
   private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(
         new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
 
     URL url = new URL("https://android.com/foo");
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
     connection = proxyConfig.connect(server, urlFactory, url);
@@ -997,7 +1007,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
   @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
     initResponseCache();
 
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
     MockResponse badProxyResponse = new MockResponse()
         .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
@@ -1008,8 +1018,8 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     // Configure a single IP address for the host and a single configuration, so we only need one
     // failure to fail permanently.
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new SingleInetAddressDns())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .proxy(server.toProxyAddress())
@@ -1024,7 +1034,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     assertEquals("android.com:443", connect.getHeader("Host"));
   }
 
-  private void initResponseCache() throws IOException {
+  private void initResponseCache() {
     cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
     urlFactory.setClient(urlFactory.client().newBuilder()
         .cache(cache)
@@ -1032,18 +1042,18 @@ private void initResponseCache() throws IOException {
   }
 
   /** Test which headers are sent unencrypted to the HTTP proxy. */
-  @Test public void proxyConnectIncludesProxyHeadersOnly()
-      throws IOException, InterruptedException {
+  @Test public void proxyConnectIncludesProxyHeadersOnly() throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(
         new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
 
@@ -1068,7 +1078,7 @@ private void initResponseCache() throws IOException {
 
   @Test public void proxyAuthenticateOnConnect() throws Exception {
     Authenticator.setDefault(new RecordingAuthenticator());
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(new MockResponse().setResponseCode(407)
         .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
     server.enqueue(
@@ -1078,7 +1088,8 @@ private void initResponseCache() throws IOException {
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxyAuthenticator(new JavaNetAuthenticator())
         .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
 
@@ -1103,14 +1114,15 @@ private void initResponseCache() throws IOException {
   // Don't disconnect after building a tunnel with CONNECT
   // http://code.google.com/p/android/issues/detail?id=37221
   @Test public void proxyWithConnectionClose() throws IOException {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(
         new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
 
@@ -1122,7 +1134,7 @@ private void initResponseCache() throws IOException {
   }
 
   @Test public void proxyWithConnectionReuse() throws IOException {
-    SSLSocketFactory socketFactory = sslClient.socketFactory;
+    SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
     server.useHttps(socketFactory, true);
@@ -1133,7 +1145,7 @@ private void initResponseCache() throws IOException {
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxy(server.toProxyAddress())
-        .sslSocketFactory(socketFactory, sslClient.trustManager)
+        .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
     URL url = new URL("https://android.com/foo");
@@ -1162,7 +1174,7 @@ private void initResponseCache() throws IOException {
     in.close();
   }
 
-  @Test public void disconnectDuringConnect_cookieJar() throws Exception {
+  @Test public void disconnectDuringConnect_cookieJar() {
     final AtomicReference<HttpURLConnection> connectionHolder = new AtomicReference<>();
     class DisconnectingCookieJar implements CookieJar {
       @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) { }
@@ -1198,7 +1210,7 @@ private void initResponseCache() throws IOException {
     assertEquals(200, connection.getResponseCode());
   }
 
-  @SuppressWarnings("deprecation") @Test public void defaultRequestProperty() throws Exception {
+  @SuppressWarnings("deprecation") @Test public void defaultRequestProperty() {
     URLConnection.setDefaultRequestProperty("X-testSetDefaultRequestProperty", "A");
     assertNull(URLConnection.getDefaultRequestProperty("X-setDefaultRequestProperty"));
   }
@@ -1332,7 +1344,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
    * This test checks whether connections are gzipped by default. This behavior in not required by
    * the API, so a failure of this test does not imply a bug in the implementation.
    */
-  @Test public void gzipEncodingEnabledByDefault() throws IOException, InterruptedException {
+  @Test public void gzipEncodingEnabledByDefault() throws Exception {
     server.enqueue(new MockResponse()
         .setBody(gzip("ABCABCABC"))
         .addHeader("Content-Encoding: gzip"));
@@ -1398,11 +1410,11 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
   private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind transferKind,
       boolean tls) throws Exception {
     if (tls) {
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
+      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
       RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
       server.useHttps(socketFactory, false);
       urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(socketFactory, sslClient.trustManager)
+          .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
           .hostnameVerifier(hostnameVerifier)
           .build());
     }
@@ -1518,7 +1530,7 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
   }
 
-  @Test public void setChunkedStreamingMode() throws IOException, InterruptedException {
+  @Test public void setChunkedStreamingMode() throws Exception {
     server.enqueue(new MockResponse());
 
     String body = "ABCDEFGHIJKLMNOPQ";
@@ -1601,7 +1613,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     String credential = Credentials.basic("jesse", "secret");
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build());
 
     connection = urlFactory.open(server.url("/").url());
@@ -1655,7 +1667,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertTrue(call, call.contains("type=" + Authenticator.RequestorType.SERVER));
     assertTrue(call, call.contains("prompt=Bar"));
     assertTrue(call, call.contains("protocol=http"));
-    assertTrue(call, call.toLowerCase().contains("scheme=basic")); // lowercase for the RI.
+    assertTrue(call, call.toLowerCase(US).contains("scheme=basic")); // lowercase for the RI.
   }
 
   @Test public void allAttributesSetInProxyAuthenticationCallbacks() throws Exception {
@@ -1670,7 +1682,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertTrue(call, call.contains("type=" + Authenticator.RequestorType.PROXY));
     assertTrue(call, call.contains("prompt=Bar"));
     assertTrue(call, call.contains("protocol=http"));
-    assertTrue(call, call.toLowerCase().contains("scheme=basic")); // lowercase for the RI.
+    assertTrue(call, call.toLowerCase(US).contains("scheme=basic")); // lowercase for the RI.
   }
 
   private List<String> authCallsForHeader(String authHeader) throws IOException {
@@ -1718,15 +1730,15 @@ private void assertValidRequestMethod(String requestMethod) throws Exception {
     assertEquals(requestMethod, connection.getRequestMethod());
   }
 
-  @Test public void setInvalidRequestMethodLowercase() throws Exception {
+  @Test public void setInvalidRequestMethodLowercase() {
     assertInvalidRequestMethod("get");
   }
 
-  @Test public void setInvalidRequestMethodConnect() throws Exception {
+  @Test public void setInvalidRequestMethodConnect() {
     assertInvalidRequestMethod("CONNECT");
   }
 
-  private void assertInvalidRequestMethod(String requestMethod) throws Exception {
+  private void assertInvalidRequestMethod(String requestMethod) {
     connection = urlFactory.open(server.url("/").url());
     try {
       connection.setRequestMethod(requestMethod);
@@ -1760,7 +1772,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
     assertContent("mp3 data", connection);
   }
 
-  @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
+  @Test public void cannotSetNegativeFixedLengthStreamingMode() {
     connection = urlFactory.open(server.url("/").url());
     try {
       connection.setFixedLengthStreamingMode(-2);
@@ -1769,7 +1781,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
     }
   }
 
-  @Test public void canSetNegativeChunkedStreamingMode() throws Exception {
+  @Test public void canSetNegativeChunkedStreamingMode() {
     connection = urlFactory.open(server.url("/").url());
     connection.setChunkedStreamingMode(-2);
   }
@@ -1796,7 +1808,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
     }
   }
 
-  @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() throws Exception {
+  @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() {
     connection = urlFactory.open(server.url("/").url());
     connection.setChunkedStreamingMode(1);
     try {
@@ -1806,7 +1818,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
     }
   }
 
-  @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() throws Exception {
+  @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() {
     connection = urlFactory.open(server.url("/").url());
     connection.setFixedLengthStreamingMode(1);
     try {
@@ -1829,11 +1841,12 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
    * http://code.google.com/p/android/issues/detail?id=12860
    */
   private void testSecureStreamingPost(StreamingMode streamingMode) throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("Success!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = urlFactory.open(server.url("/").url());
@@ -2044,15 +2057,16 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     }
   }
 
-  @Test public void redirectedOnHttps() throws IOException, InterruptedException {
-    server.useHttps(sslClient.socketFactory, false);
+  @Test public void redirectedOnHttps() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /foo")
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("This is the new location!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = urlFactory.open(server.url("/").url());
@@ -2066,22 +2080,23 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
   }
 
-  @Test public void notRedirectedFromHttpsToHttp() throws IOException, InterruptedException {
-    server.useHttps(sslClient.socketFactory, false);
+  @Test public void notRedirectedFromHttpsToHttp() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: http://anyhost/foo")
         .setBody("This page has moved!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .followSslRedirects(false)
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = urlFactory.open(server.url("/").url());
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
-  @Test public void notRedirectedFromHttpToHttps() throws IOException, InterruptedException {
+  @Test public void notRedirectedFromHttpToHttps() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: https://anyhost/foo")
         .setBody("This page has moved!"));
@@ -2096,13 +2111,14 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
     server2.enqueue(new MockResponse().setBody("This is insecure HTTP!"));
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: " + server2.url("/").url())
         .setBody("This page has moved!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .followSslRedirects(true)
         .build());
@@ -2116,7 +2132,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   }
 
   @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
-    server2.useHttps(sslClient.socketFactory, false);
+    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server2.enqueue(new MockResponse().setBody("This is secure HTTPS!"));
 
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
@@ -2124,7 +2140,8 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .setBody("This page has moved!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .followSslRedirects(true)
         .build());
@@ -2143,11 +2160,12 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
 
   private void redirectToAnotherOriginServer(boolean https) throws Exception {
     if (https) {
-      server.useHttps(sslClient.socketFactory, false);
-      server2.useHttps(sslClient.socketFactory, false);
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+      server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
       server2.setProtocolNegotiationEnabled(false);
       urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+          .sslSocketFactory(
+              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
           .hostnameVerifier(new RecordingHostnameVerifier())
           .build());
     }
@@ -2214,7 +2232,7 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
         .addHeader("Location: " + server2.url("/b").url()));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret"), null))
         .build());
     assertContent("Page 2", urlFactory.open(server.url("/a").url()));
 
@@ -2424,7 +2442,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
 
   @Test public void httpsWithCustomTrustManager() throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    RecordingTrustManager trustManager = new RecordingTrustManager(sslClient.trustManager);
+    RecordingTrustManager trustManager = new RecordingTrustManager(handshakeCertificates.trustManager());
     SSLContext sslContext = Platform.get().getSSLContext();
     sslContext.init(null, new TrustManager[] { trustManager }, null);
 
@@ -2432,7 +2450,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
         .hostnameVerifier(hostnameVerifier)
         .sslSocketFactory(sslContext.getSocketFactory(), trustManager)
         .build());
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
     server.enqueue(new MockResponse().setBody("GHI"));
@@ -2443,8 +2461,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     assertContent("GHI", urlFactory.open(url));
 
     assertEquals(Arrays.asList("verify " + server.getHostName()), hostnameVerifier.calls);
-    assertEquals(Arrays.asList("checkServerTrusted [CN=" + server.getHostName() + " 1]"),
-        trustManager.calls);
+    assertEquals(Arrays.asList("checkServerTrusted [CN=localhost 1]"), trustManager.calls);
   }
 
   @Test public void getClientRequestTimeout() throws Exception {
@@ -2560,7 +2577,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
     }
   }
 
-  @Test public void setChunkedEncodingAsRequestProperty() throws IOException, InterruptedException {
+  @Test public void setChunkedEncodingAsRequestProperty() throws Exception {
     server.enqueue(new MockResponse());
 
     connection = urlFactory.open(server.url("/").url());
@@ -2573,7 +2590,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
     assertEquals("ABC", request.getBody().readUtf8());
   }
 
-  @Test public void connectionCloseInRequest() throws IOException, InterruptedException {
+  @Test public void connectionCloseInRequest() throws Exception {
     server.enqueue(new MockResponse()); // server doesn't honor the connection: close header!
     server.enqueue(new MockResponse());
 
@@ -2589,7 +2606,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
         server.takeRequest().getSequenceNumber());
   }
 
-  @Test public void connectionCloseInResponse() throws IOException, InterruptedException {
+  @Test public void connectionCloseInResponse() throws Exception {
     server.enqueue(new MockResponse().addHeader("Connection: close"));
     server.enqueue(new MockResponse());
 
@@ -2604,7 +2621,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
         server.takeRequest().getSequenceNumber());
   }
 
-  @Test public void connectionCloseWithRedirect() throws IOException, InterruptedException {
+  @Test public void connectionCloseWithRedirect() throws Exception {
     MockResponse response = new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /foo")
@@ -2627,9 +2644,6 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
    * https://code.google.com/p/android/issues/detail?id=41576
    */
   @Test public void sameConnectionRedirectAndReuse() throws Exception {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new SingleInetAddressDns())
-        .build());
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
@@ -2643,7 +2657,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
     assertEquals(0, server.takeRequest().getSequenceNumber());
   }
 
-  @Test public void responseCodeDisagreesWithHeaders() throws IOException, InterruptedException {
+  @Test public void responseCodeDisagreesWithHeaders() {
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
         .setBody("This body is not allowed!"));
@@ -2709,7 +2723,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     }
   }
 
-  @Test public void getHeadersThrows() throws IOException {
+  @Test public void getHeadersThrows() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
 
     connection = urlFactory.open(server.url("/").url());
@@ -3080,7 +3094,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertEquals("", connection.getHeaderField("A"));
   }
 
-  @Test public void emptyRequestHeaderNameIsStrict() throws Exception {
+  @Test public void emptyRequestHeaderNameIsStrict() {
     server.enqueue(new MockResponse().setBody("body"));
     connection = urlFactory.open(server.url("/").url());
     try {
@@ -3100,7 +3114,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     connection.getInputStream().close();
   }
 
-  @Test public void requestHeaderValidationIsStrict() throws Exception {
+  @Test public void requestHeaderValidationIsStrict() {
     connection = urlFactory.open(server.url("/").url());
     try {
       connection.addRequestProperty("a\tb", "Value");
@@ -3165,7 +3179,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("A"));
 
     String credential = Credentials.basic("jesse", "peanutbutter");
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential);
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential, null);
     urlFactory.setClient(urlFactory.client().newBuilder()
         .authenticator(authenticator)
         .build());
@@ -3187,7 +3201,8 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(pleaseAuthenticate);
     server.enqueue(new MockResponse().setBody("A"));
 
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator("oauthed abc123");
+    RecordingOkAuthenticator authenticator
+        = new RecordingOkAuthenticator("oauthed abc123", "Bearer");
     urlFactory.setClient(urlFactory.client().newBuilder()
         .authenticator(authenticator)
         .build());
@@ -3211,7 +3226,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("c"));
 
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
-        Credentials.basic("jesse", "peanutbutter"));
+        Credentials.basic("jesse", "peanutbutter"), "Basic");
     urlFactory.setClient(urlFactory.client().newBuilder()
         .authenticator(authenticator)
         .build());
@@ -3232,7 +3247,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     String credential = Credentials.basic("jesse", "peanutbutter");
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build());
 
     connection = urlFactory.open(server.url("/0").url());
@@ -3246,7 +3261,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     String credential = Credentials.basic("jesse", "peanutbutter");
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build());
 
     connection = urlFactory.open(server.url("/").url());
@@ -3275,14 +3290,14 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
     assertContent("A", connection);
   }
 
-  @Test public void http10SelectedProtocol() throws Exception {
+  @Test public void http10SelectedProtocol() {
     server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 OK"));
     connection = urlFactory.open(server.url("/").url());
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
     assertEquals(Arrays.asList("http/1.0"), protocolValues);
   }
 
-  @Test public void http11SelectedProtocol() throws Exception {
+  @Test public void http11SelectedProtocol() {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
     connection = urlFactory.open(server.url("/").url());
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
@@ -3290,7 +3305,7 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
   }
 
   /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
-  @Test public void zeroLengthPost() throws IOException, InterruptedException {
+  @Test public void zeroLengthPost() throws Exception {
     zeroLengthPayload("POST");
   }
 
@@ -3300,7 +3315,7 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
   }
 
   /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
-  @Test public void zeroLengthPut() throws IOException, InterruptedException {
+  @Test public void zeroLengthPut() throws Exception {
     zeroLengthPayload("PUT");
   }
 
@@ -3309,8 +3324,7 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
     zeroLengthPut();
   }
 
-  private void zeroLengthPayload(String method)
-      throws IOException, InterruptedException {
+  private void zeroLengthPayload(String method) throws Exception {
     server.enqueue(new MockResponse());
     connection = urlFactory.open(server.url("/").url());
     connection.setRequestProperty("Content-Length", "0");
@@ -3346,7 +3360,7 @@ private void zeroLengthPayload(String method)
     assertContent("A", urlFactory.open(server.url("/").url()));
   }
 
-  @Test public void setProtocolsWithoutHttp11() throws Exception {
+  @Test public void setProtocolsWithoutHttp11() {
     try {
       new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_2));
       fail();
@@ -3354,7 +3368,7 @@ private void zeroLengthPayload(String method)
     }
   }
 
-  @Test public void setProtocolsWithNull() throws Exception {
+  @Test public void setProtocolsWithNull() {
     try {
       new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_1_1, null));
       fail();
@@ -3384,12 +3398,12 @@ private void zeroLengthPayload(String method)
   }
 
   @Test public void testNoSslFallback() throws Exception {
-    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false /* tunnelProxy */);
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("Response that would have needed fallbacks"));
 
     HttpsURLConnection connection = (HttpsURLConnection) server.url("/").url().openConnection();
-    connection.setSSLSocketFactory(sslClient.socketFactory);
+    connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     try {
       connection.getInputStream();
       fail();
@@ -3397,6 +3411,9 @@ private void zeroLengthPayload(String method)
       // RI response to the FAIL_HANDSHAKE
     } catch (SSLHandshakeException expected) {
       // Android's response to the FAIL_HANDSHAKE
+    } catch (SSLException expected) {
+      // JDK 1.9 response to the FAIL_HANDSHAKE
+      // javax.net.ssl.SSLException: Unexpected handshake message: client_hello
     } catch (SocketException expected) {
       // Conscrypt's response to the FAIL_HANDSHAKE
     }
@@ -3429,6 +3446,16 @@ private void zeroLengthPayload(String method)
     assertEquals(1, requestB.getSequenceNumber());
   }
 
+  @Test public void nullSSLSocketFactory_throws() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false /* tunnelProxy */);
+    HttpsURLConnection connection = (HttpsURLConnection) server.url("/").url().openConnection();
+    try {
+      connection.setSSLSocketFactory(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   /**
    * We had a bug where we weren't closing Gzip streams on redirects.
    * https://github.com/square/okhttp/issues/441
@@ -3501,7 +3528,7 @@ private void zeroLengthPayload(String method)
 
   @Test public void interceptorsNotInvoked() throws Exception {
     Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
+      @Override public Response intercept(Chain chain) {
         throw new AssertionError();
       }
     };
@@ -3569,14 +3596,14 @@ private void zeroLengthPayload(String method)
     testInstanceFollowsRedirects("https://www.google.com/");
   }
 
-  @Test public void setSslSocketFactoryFailsOnJdk9() throws Exception {
+  @Test public void setSslSocketFactoryFailsOnJdk9() {
     assumeTrue(getPlatform().equals("jdk9"));
 
     enableProtocol(Protocol.HTTP_2);
     URL url = server.url("/").url();
     HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(url);
     try {
-      connection.setSSLSocketFactory(sslClient.socketFactory);
+      connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
       fail();
     } catch (UnsupportedOperationException expected) {
     }
@@ -3726,8 +3753,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setChunkedBody(content, chunkSize);
       }
 
@@ -3767,8 +3793,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
   enum ProxyConfig {
     NO_PROXY() {
       @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
         streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
             .proxy(Proxy.NO_PROXY)
             .build());
@@ -3778,8 +3803,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
 
     CREATE_ARG() {
       @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
         streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
             .proxy(server.toProxyAddress())
             .build());
@@ -3789,8 +3813,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
 
     PROXY_SYSTEM_PROPERTY() {
       @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
         System.setProperty("proxyHost", server.getHostName());
         System.setProperty("proxyPort", Integer.toString(server.getPort()));
         return streamHandlerFactory.open(url);
@@ -3799,8 +3822,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
 
     HTTP_PROXY_SYSTEM_PROPERTY() {
       @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
         System.setProperty("http.proxyHost", server.getHostName());
         System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
         return streamHandlerFactory.open(url);
@@ -3809,8 +3831,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
 
     HTTPS_PROXY_SYSTEM_PROPERTY() {
       @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
         System.setProperty("https.proxyHost", server.getHostName());
         System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
         return streamHandlerFactory.open(url);
@@ -3826,7 +3847,7 @@ public abstract HttpURLConnection connect(
     private final List<String> calls = new ArrayList<>();
     private final X509TrustManager delegate;
 
-    public RecordingTrustManager(X509TrustManager delegate) {
+    RecordingTrustManager(X509TrustManager delegate) {
       this.delegate = delegate;
     }
 
@@ -3834,13 +3855,11 @@ public RecordingTrustManager(X509TrustManager delegate) {
       return delegate.getAcceptedIssuers();
     }
 
-    public void checkClientTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
+    public void checkClientTrusted(X509Certificate[] chain, String authType) {
       calls.add("checkClientTrusted " + certificatesToString(chain));
     }
 
-    public void checkServerTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
+    public void checkServerTrusted(X509Certificate[] chain, String authType) {
       calls.add("checkServerTrusted " + certificatesToString(chain));
     }
 
@@ -3859,11 +3878,12 @@ private String certificatesToString(X509Certificate[] certificates) {
    */
   private void enableProtocol(Protocol protocol) {
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
         .build());
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.setProtocolNegotiationEnabled(true);
     server.setProtocols(urlFactory.client().protocols());
   }
@@ -3874,7 +3894,7 @@ private void enableProtocol(Protocol protocol) {
    * for details.
    */
   private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(sslClient.socketFactory);
+    return new FallbackTestClientSocketFactory(handshakeCertificates.sslSocketFactory());
   }
 
   private String getPlatform() {
diff --git a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
index 56611be40a..5875bc3970 100644
--- a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
+++ b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
@@ -230,7 +230,7 @@ public UrlComponentEncodingTester test(Component component) {
   private void testParseAlreadyEncoded(int codePoint, Encoding encoding, Component component) {
     String encoded = encoding.encode(codePoint);
     String urlString = component.urlString(encoded);
-    HttpUrl url = HttpUrl.parse(urlString);
+    HttpUrl url = HttpUrl.get(urlString);
     if (!component.encodedValue(url).equals(encoded)) {
       fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
     }
@@ -238,7 +238,7 @@ private void testParseAlreadyEncoded(int codePoint, Encoding encoding, Component
 
   private void testEncodeAndDecode(int codePoint, Component component) {
     String expected = Encoding.IDENTITY.encode(codePoint);
-    HttpUrl.Builder builder = HttpUrl.parse("http://host/").newBuilder();
+    HttpUrl.Builder builder = HttpUrl.get("http://host/").newBuilder();
     component.set(builder, expected);
     HttpUrl url = builder.build();
     String actual = component.get(url);
@@ -252,7 +252,7 @@ private void testParseOriginal(int codePoint, Encoding encoding, Component compo
     if (encoding != Encoding.PERCENT) return;
     String identity = Encoding.IDENTITY.encode(codePoint);
     String urlString = component.urlString(identity);
-    HttpUrl url = HttpUrl.parse(urlString);
+    HttpUrl url = HttpUrl.get(urlString);
 
     String s = component.encodedValue(url);
     if (!s.equals(encoded)) {
@@ -262,7 +262,7 @@ private void testParseOriginal(int codePoint, Encoding encoding, Component compo
 
   private void testToUrl(int codePoint, Encoding encoding, Component component) {
     String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
     URL javaNetUrl = httpUrl.url();
     if (!javaNetUrl.toString().equals(javaNetUrl.toString())) {
       fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
@@ -271,7 +271,7 @@ private void testToUrl(int codePoint, Encoding encoding, Component component) {
 
   private void testFromUrl(int codePoint, Encoding encoding, Component component) {
     String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
     HttpUrl toAndFromJavaNetUrl = HttpUrl.get(httpUrl.url());
     if (!toAndFromJavaNetUrl.equals(httpUrl)) {
       fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
@@ -282,7 +282,7 @@ private void testUri(
       int codePoint, Encoding encoding, Component component, boolean uriEscaped) {
     String string = new String(new int[] {codePoint}, 0, 1);
     String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
     URI uri = httpUrl.uri();
     HttpUrl toAndFromUri = HttpUrl.get(uri);
     if (uriEscaped) {
@@ -402,6 +402,25 @@ public String encode(int codePoint) {
         return query.substring(1, query.length() - 1);
       }
     },
+    QUERY_VALUE {
+      @Override public String urlString(String value) {
+        return "http://example.com/?q=a" + value + "z";
+      }
+
+      @Override public String encodedValue(HttpUrl url) {
+        String query = url.encodedQuery();
+        return query.substring(3, query.length() - 1);
+      }
+
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.addQueryParameter("q", "a" + value + "z");
+      }
+
+      @Override public String get(HttpUrl url) {
+        String value = url.queryParameter("q");
+        return value.substring(1, value.length() - 1);
+      }
+    },
     FRAGMENT {
       @Override public String urlString(String value) {
         return "http://example.com/#a" + value + "z";
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
index a15c57ea35..605d606fb0 100644
--- a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
@@ -98,7 +98,7 @@ private void testHttpUrl() {
     if (testData.base.equals("about:blank")) {
       url = HttpUrl.parse(testData.input);
     } else {
-      HttpUrl baseUrl = HttpUrl.parse(testData.base);
+      HttpUrl baseUrl = HttpUrl.get(testData.base);
       url = baseUrl.resolve(testData.input);
     }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/WholeOperationTimeoutTest.java b/okhttp-tests/src/test/java/okhttp3/WholeOperationTimeoutTest.java
new file mode 100644
index 0000000000..603f221397
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/WholeOperationTimeoutTest.java
@@ -0,0 +1,296 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.HttpURLConnection;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.BufferedSink;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class WholeOperationTimeoutTest {
+  /** A large response body. Smaller bodies might successfully read after the socket is closed! */
+  private static final String BIG_ENOUGH_BODY = TestUtil.repeat('a', 64 * 1024);
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private OkHttpClient client = defaultClient();
+
+  @Test public void defaultConfigIsNoTimeout() throws Exception {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+    assertEquals(0, call.timeout().timeoutNanos());
+  }
+
+  @Test public void configureClientDefault() throws Exception {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    OkHttpClient timeoutClient = client.newBuilder()
+        .callTimeout(456, TimeUnit.MILLISECONDS)
+        .build();
+
+    Call call = timeoutClient.newCall(request);
+    assertEquals(TimeUnit.MILLISECONDS.toNanos(456), call.timeout().timeoutNanos());
+  }
+
+  @Test public void timeoutWritingRequest() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(sleepingRequestBody(500))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void timeoutWritingRequestWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(sleepingRequestBody(500))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        exceptionRef.set(e);
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        response.close();
+        latch.countDown();
+      }
+    });
+
+    latch.await();
+    assertTrue(call.isCanceled());
+    assertNotNull(exceptionRef.get());
+  }
+
+  @Test public void timeoutProcessing() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void timeoutProcessingWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        exceptionRef.set(e);
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        response.close();
+        latch.countDown();
+      }
+    });
+
+    latch.await();
+    assertTrue(call.isCanceled());
+    assertNotNull(exceptionRef.get());
+  }
+
+  @Test public void timeoutReadingResponse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    Response response = call.execute();
+    Thread.sleep(500);
+    try {
+      response.body().source().readUtf8();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void timeoutReadingResponseWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try {
+          Thread.sleep(500);
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+        try {
+          response.body().source().readUtf8();
+          fail();
+        } catch (IOException e) {
+          exceptionRef.set(e);
+        } finally {
+          latch.countDown();
+        }
+      }
+    });
+
+    latch.await();
+    assertTrue(call.isCanceled());
+    assertNotNull(exceptionRef.get());
+  }
+
+  @Test public void singleTimeoutForAllFollowUpRequests() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/b")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/c")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/d")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/e")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/f")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/a"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void noTimeout() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(250, TimeUnit.MILLISECONDS)
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(sleepingRequestBody(250))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(1000, TimeUnit.MILLISECONDS);
+    Response response = call.execute();
+    Thread.sleep(250);
+    response.body().source().readUtf8();
+    response.close();
+    assertFalse(call.isCanceled());
+  }
+
+  private RequestBody sleepingRequestBody(final int sleepMillis) {
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        try {
+          sink.writeUtf8("abc");
+          sink.flush();
+          Thread.sleep(sleepMillis);
+          sink.writeUtf8("def");
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+    };
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
index 2464a910b4..126fce4d7e 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
@@ -18,7 +18,9 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nullable;
 import okhttp3.Authenticator;
+import okhttp3.Challenge;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.Route;
@@ -26,10 +28,12 @@
 public final class RecordingOkAuthenticator implements Authenticator {
   public final List<Response> responses = new ArrayList<>();
   public final List<Route> routes = new ArrayList<>();
-  public final String credential;
+  public @Nullable String credential;
+  public @Nullable String scheme;
 
-  public RecordingOkAuthenticator(String credential) {
+  public RecordingOkAuthenticator(@Nullable String credential, @Nullable String scheme) {
     this.credential = credential;
+    this.scheme = scheme;
   }
 
   public Response onlyResponse() {
@@ -49,10 +53,21 @@ public Route onlyRoute() {
     responses.add(response);
     routes.add(route);
 
-    if (credential == null) return null;
+    if (!schemeMatches(response) || credential == null) return null;
+
     String header = response.code() == 407 ? "Proxy-Authorization" : "Authorization";
     return response.request().newBuilder()
         .addHeader(header, credential)
         .build();
   }
+
+  private boolean schemeMatches(Response response) {
+    if (scheme == null) return true;
+
+    for (Challenge challenge : response.challenges()) {
+      if (challenge.scheme().equalsIgnoreCase(scheme)) return true;
+    }
+
+    return false;
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java b/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
index 47c97fff2d..af92f5eb84 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
@@ -15,17 +15,34 @@
   */
 package okhttp3.internal;
 
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertSame;
+import static org.junit.Assert.fail;
 
-public class UtilTest {
-  @Test
-  public void testAssertionError() {
+ public class UtilTest {
+  @Test public void testAssertionError() {
     NullPointerException nullPointerException = new NullPointerException();
     AssertionError ae = Util.assertionError("npe", nullPointerException);
     assertSame(nullPointerException, ae.getCause());
     assertEquals("npe", ae.getMessage());
   }
+
+  @Test public void immutableMap() {
+    Map<String, String> map = new LinkedHashMap<>();
+    map.put("a", "A");
+    Map<String, String> immutableCopy = Util.immutableMap(map);
+    assertEquals(immutableCopy, Collections.singletonMap("a", "A"));
+    map.clear();
+    assertEquals(immutableCopy, Collections.singletonMap("a", "A"));
+    try {
+      immutableCopy.clear();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
index 7dcbb7467e..e366e4081b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
@@ -25,9 +25,10 @@
 import okhttp3.ConnectionSpec;
 import okhttp3.TlsVersion;
 import okhttp3.internal.Internal;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Test;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -40,7 +41,7 @@
   public static final SSLHandshakeException RETRYABLE_EXCEPTION = new SSLHandshakeException(
       "Simulated handshake exception");
 
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
 
   @Test
   public void nonRetryableIOException() throws Exception {
@@ -121,7 +122,7 @@ private static ConnectionSpecSelector createConnectionSpecSelector(
   }
 
   private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) throws IOException {
-    SSLSocket socket = (SSLSocket) sslClient.socketFactory.createSocket();
+    SSLSocket socket = (SSLSocket) handshakeCertificates.sslSocketFactory().createSocket();
     socket.setEnabledProtocols(javaNames(tlsVersions));
     return socket;
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
index 209d79d5c5..44e939aaea 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import org.junit.Test;
 
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertSame;
 
 public class RouteExceptionTest {
@@ -25,6 +26,7 @@
   @Test public void getConnectionIOException_single() {
     IOException firstException = new IOException();
     RouteException re = new RouteException(firstException);
+    assertSame(firstException, re.getFirstConnectException());
     assertSame(firstException, re.getLastConnectException());
   }
 
@@ -36,12 +38,13 @@
     re.addConnectException(secondException);
     re.addConnectException(thirdException);
 
-    IOException connectionIOException = re.getLastConnectException();
-    assertSame(thirdException, connectionIOException);
-    Throwable[] thirdSuppressedExceptions = thirdException.getSuppressed();
-    assertSame(secondException, thirdSuppressedExceptions[0]);
+    IOException connectionIOException = re.getFirstConnectException();
+    assertSame(firstException, connectionIOException);
+    Throwable[] suppressedExceptions = connectionIOException.getSuppressed();
+    assertEquals(2, suppressedExceptions.length);
+    assertSame(secondException, suppressedExceptions[0]);
+    assertSame(thirdException, suppressedExceptions[1]);
 
-    Throwable[] secondSuppressedException = secondException.getSuppressed();
-    assertSame(firstException, secondSuppressedException[0]);
+    assertSame(thirdException, re.getLastConnectException());
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
index 26fbe3f031..6c4a0d2d9a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
@@ -39,11 +39,12 @@
 import okhttp3.Route;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.RecordingProxySelector;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Before;
 import org.junit.Test;
 
 import static java.net.Proxy.NO_PROXY;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertSame;
@@ -68,8 +69,8 @@
   private int uriPort = 1003;
 
   private SocketFactory socketFactory;
-  private final SslClient sslClient = SslClient.localhost();
-  private final SSLSocketFactory sslSocketFactory = sslClient.socketFactory;
+  private final HandshakeCertificates handshakeCertificates = localhost();
+  private final SSLSocketFactory sslSocketFactory = handshakeCertificates.sslSocketFactory();
   private HostnameVerifier hostnameVerifier;
 
   private final Authenticator authenticator = Authenticator.NONE;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
index 9ac3b93ecc..ed2b05085f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
@@ -36,6 +36,7 @@
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class ThreadInterruptTest {
@@ -92,6 +93,7 @@ protected Socket configureSocket(Socket socket) throws IOException {
       }
       fail("Expected thread to be interrupted");
     } catch (InterruptedIOException expected) {
+      assertTrue(Thread.interrupted());
     }
 
     connection.disconnect();
@@ -115,6 +117,7 @@ protected Socket configureSocket(Socket socket) throws IOException {
       }
       fail("Expected thread to be interrupted");
     } catch (InterruptedIOException expected) {
+      assertTrue(Thread.interrupted());
     }
 
     responseBody.close();
@@ -128,7 +131,7 @@ private void interruptLater(final int delayMillis) {
           sleep(delayMillis);
           toInterrupt.interrupt();
         } catch (InterruptedException e) {
-          throw new RuntimeException(e);
+          throw new AssertionError(e);
         }
       }
     };
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index c8af96913b..ea5b8ed60b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -18,12 +18,14 @@
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.Socket;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.Headers;
 import okhttp3.internal.Util;
 import okhttp3.internal.http2.MockHttp2Peer.InFrame;
 import okio.AsyncTimeout;
@@ -33,6 +35,7 @@
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
+import okio.Utf8;
 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
@@ -83,28 +86,6 @@
     assertTrue(ping.ack);
   }
 
-  @Test public void clientPingsServerHttp2() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 5);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Ping ping = connection.ping();
-    assertTrue(ping.roundTripTime() > 0);
-    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
-
-    // verify the peer received what was expected
-    InFrame pingFrame = peer.takeFrame();
-    assertEquals(0, pingFrame.streamId);
-    assertEquals(1, pingFrame.payload1);
-    assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
-    assertFalse(pingFrame.ack);
-  }
-
   @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
     Settings initial = new Settings();
     initial.set(INITIAL_WINDOW_SIZE, 1684);
@@ -130,7 +111,6 @@
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
 
     assertEquals(3368, connection.peerSettings.getInitialWindowSize());
-    assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
     // New Stream is has the most recent initial window size.
     assertEquals(3368, stream.bytesLeftInWriteWindow);
   }
@@ -195,7 +175,7 @@
 
     // Play it back.
     Http2Connection connection = connect(peer);
-    connection.ping().roundTripTime(); // Ensure the SETTINGS have been received.
+    connection.writePingAndAwaitPong(); // Ensure the SETTINGS have been received.
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
     BufferedSink sink = Okio.buffer(stream.getSink());
     sink.writeUtf8("abcdefghi");
@@ -215,6 +195,39 @@
     assertTrue(Arrays.equals("fghi".getBytes("UTF-8"), data2.data));
   }
 
+  /**
+   * Confirm that we account for discarded data frames. It's possible that data frames are in-flight
+   * just prior to us canceling a stream.
+   */
+  @Test public void discardedDataFramesAreCounted() throws Exception {
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM 3
+    peer.sendFrame().headers(3, headerEntries("a", "apple"));
+    peer.sendFrame().data(false, 3, data(1024), 1024);
+    peer.acceptFrame(); // RST_STREAM
+    peer.sendFrame().data(true, 3, data(1024), 1024);
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    Http2Connection connection = connect(peer);
+    Http2Stream stream1 = connection.newStream(headerEntries("b", "bark"), false);
+    Source source = stream1.getSource();
+    Buffer buffer = new Buffer();
+    while (buffer.size() != 1024) source.read(buffer, 1024);
+    stream1.close(ErrorCode.CANCEL);
+
+    InFrame frame1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, frame1.type);
+    InFrame frame2 = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, frame2.type);
+    InFrame frame3 = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, frame3.type);
+
+    assertEquals(2048, connection.unacknowledgedBytesRead);
+  }
+
   @Test public void receiveGoAwayHttp2() throws Exception {
     // write the mocking script
     peer.sendFrame().settings(new Settings());
@@ -231,7 +244,7 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
     Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
-    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    connection.writePingAndAwaitPong(); // Ensure the GO_AWAY that resets stream2 has been received.
     BufferedSink sink1 = Okio.buffer(stream1.getSink());
     BufferedSink sink2 = Okio.buffer(stream2.getSink());
     sink1.writeUtf8("abc");
@@ -291,7 +304,7 @@
     connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
     buffer.writeAll(in);
@@ -513,9 +526,141 @@
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("c3po");
     out.close();
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     assertStreamData("robot", stream.getSource());
-    connection.ping().roundTripTime();
+    connection.writePingAndAwaitPong();
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertFalse(synStream.outFinished);
+    assertEquals(3, synStream.streamId);
+    assertEquals(-1, synStream.associatedStreamId);
+    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
+    InFrame requestData = peer.takeFrame();
+    assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
+  }
+
+  static final class RecordingHeadersListener implements Header.Listener {
+    final ArrayDeque<Headers> receivedHeaders = new ArrayDeque<>();
+
+    @Override public void onHeaders(Headers headers) {
+      receivedHeaders.add(headers);
+    }
+
+    public List<Headers> takeAll() {
+      List<Headers> result = new ArrayList<>();
+      for (Headers headers; (headers = receivedHeaders.poll()) != null; ) {
+        result.add(headers);
+      }
+      return result;
+    }
+  }
+
+  @Test public void clientReadsHeadersDataHeadersData() throws Exception {
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(false, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("cyborg"), 6);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.play();
+
+    RecordingHeadersListener headersListener = new RecordingHeadersListener();
+
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries(), false);
+    stream.setHeadersListener(headersListener);
+    assertStreamData("robotcyborg", stream.getSource());
+    assertEquals(Arrays.asList(Headers.of("a", "android"), Headers.of("b", "banana")),
+        headersListener.takeAll());
+    connection.writePingAndAwaitPong();
+    assertEquals(0, connection.openStreamCount());
+  }
+
+  @Test public void clientReadsHeadersDataPingPongHeadersData() throws Exception {
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(false, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("cyborg"), 6);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.play();
+
+    RecordingHeadersListener headersListener = new RecordingHeadersListener();
+
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries(), false);
+    stream.setHeadersListener(headersListener);
+    BufferedSource source = Okio.buffer(stream.getSource());
+
+    assertStreamPrefix("robot", source);
+    assertEquals(Arrays.asList(Headers.of("a", "android")), headersListener.takeAll());
+    connection.writePingAndAwaitPong();
+
+    assertStreamPrefix("cyborg", source);
+    assertEquals(Arrays.asList(Headers.of("b", "banana")), headersListener.takeAll());
+    connection.writePingAndAwaitPong();
+
+    assertEquals(0, connection.openStreamCount());
+  }
+
+  @Test public void clientReadsHeadersDataHeadersClose() throws Exception {
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(false, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.play();
+
+    RecordingHeadersListener headersListener = new RecordingHeadersListener();
+
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries(), false);
+    stream.setHeadersListener(headersListener);
+    BufferedSource source = Okio.buffer(stream.getSource());
+
+    assertStreamPrefix("robot", source);
+    assertEquals(Arrays.asList(Headers.of("a", "android")), headersListener.takeAll());
+    connection.writePingAndAwaitPong();
+    source.close();
+    assertEquals(Arrays.asList(Headers.of("b", "banana")), headersListener.takeAll());
+
+    assertEquals(0, connection.openStreamCount());
+  }
+
+  @Test public void serverReadsHeadersDataHeaders() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // HEADERS
+    peer.sendFrame().synReply(true, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.writeUtf8("c3po");
+    out.close();
+    stream.writeHeaders(headerEntries("e", "elephant"), true);
+    connection.writePingAndAwaitPong();
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -527,6 +672,9 @@
     assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
     InFrame requestData = peer.takeFrame();
     assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
+
+    InFrame nextFrame = peer.takeFrame();
+    assertEquals(headerEntries("e", "elephant"), nextFrame.headerBlock);
   }
 
   @Test public void clientCreatesStreamAndServerRepliesWithFin() throws Exception {
@@ -543,7 +691,7 @@
     Http2Connection connection = connect(peer);
     connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(1, connection.openStreamCount());
-    connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
+    connection.writePingAndAwaitPong(); // Ensure that the SYN_REPLY has been received.
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -582,15 +730,18 @@
 
     // play it back
     Http2Connection connection = connect(peer);
-    Ping ping = connection.ping();
-    assertTrue(ping.roundTripTime() > 0);
-    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+    long pingAtNanos = System.nanoTime();
+    connection.writePingAndAwaitPong();
+    long elapsedNanos = System.nanoTime() - pingAtNanos;
+    assertTrue(elapsedNanos > 0);
+    assertTrue(elapsedNanos < TimeUnit.SECONDS.toNanos(1));
 
     // verify the peer received what was expected
     InFrame pingFrame = peer.takeFrame();
     assertEquals(Http2.TYPE_PING, pingFrame.type);
-    assertEquals(1, pingFrame.payload1);
-    assertEquals(new Buffer().writeUtf8("OKok").readInt(), pingFrame.payload2);
+    assertEquals(0, pingFrame.streamId);
+    assertEquals(0x4f4b6f6b, pingFrame.payload1); // OkOk
+    assertEquals(0xf09f8da9, pingFrame.payload2); // donut
     assertFalse(pingFrame.ack);
   }
 
@@ -759,7 +910,7 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
     BufferedSink out = Okio.buffer(stream.getSink());
-    connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
+    connection.writePingAndAwaitPong(); // Ensure that the RST_CANCEL has been received.
     try {
       out.writeUtf8("square");
       out.flush();
@@ -782,7 +933,6 @@
     assertFalse(synStream.outFinished);
     InFrame ping = peer.takeFrame();
     assertEquals(Http2.TYPE_PING, ping.type);
-    assertEquals(1, ping.payload1);
   }
 
   /**
@@ -890,7 +1040,7 @@
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     Source source = stream.getSource();
     assertStreamData("square", source);
-    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
+    connection.writePingAndAwaitPong(); // Ensure that inFinished has been received.
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -914,8 +1064,8 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("c", "cola"), false);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
-    connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
+    connection.writePingAndAwaitPong(); // Ensure that the 2nd SYN REPLY has been received.
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
@@ -940,7 +1090,7 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     assertStreamData("robot", stream.getSource());
 
     // verify the peer received what was expected
@@ -973,7 +1123,7 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    assertEquals(headerEntries("b", "banana"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("b", "banana"), stream.takeHeaders());
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
@@ -997,7 +1147,7 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     try {
-      stream.takeResponseHeaders();
+      stream.takeHeaders();
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
@@ -1028,7 +1178,7 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
     Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
-    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    connection.writePingAndAwaitPong(); // Ensure the GO_AWAY that resets stream2 has been received.
     BufferedSink sink1 = Okio.buffer(stream1.getSink());
     BufferedSink sink2 = Okio.buffer(stream2.getSink());
     sink1.writeUtf8("abc");
@@ -1077,10 +1227,15 @@
     // play it back
     Http2Connection connection = connect(peer);
     connection.newStream(headerEntries("a", "android"), false);
-    Ping ping = connection.ping();
+    synchronized (connection) {
+      if (connection.shutdown) {
+        throw new ConnectionShutdownException();
+      }
+    }
+    connection.writePing(false, 0x01, 0x02);
     connection.shutdown(ErrorCode.PROTOCOL_ERROR);
     assertEquals(1, connection.openStreamCount());
-    ping.roundTripTime(); // Prevent the peer from exiting prematurely.
+    connection.awaitPong(); // Prevent the peer from exiting prematurely.
 
     // verify the peer received what was expected
     InFrame synStream1 = peer.takeFrame();
@@ -1093,28 +1248,6 @@
     assertEquals(ErrorCode.PROTOCOL_ERROR, goaway.errorCode);
   }
 
-  @Test public void noPingsAfterShutdown() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // GOAWAY
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    connection.shutdown(ErrorCode.INTERNAL_ERROR);
-    try {
-      connection.ping();
-      fail();
-    } catch (ConnectionShutdownException expected) {
-    }
-
-    // verify the peer received what was expected
-    InFrame goaway = peer.takeFrame();
-    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
-    assertEquals(ErrorCode.INTERNAL_ERROR, goaway.errorCode);
-  }
-
   @Test public void close() throws Exception {
     // write the mocking script
     peer.sendFrame().settings(new Settings());
@@ -1160,21 +1293,6 @@
     assertEquals(3, rstStream.streamId);
   }
 
-  @Test public void closeCancelsPings() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // PING
-    peer.acceptFrame(); // GOAWAY
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Ping ping = connection.ping();
-    connection.close();
-    assertEquals(-1, ping.roundTripTime());
-  }
-
   @Test public void getResponseHeadersTimesOut() throws Exception {
     // write the mocking script
     peer.sendFrame().settings(new Settings());
@@ -1189,7 +1307,7 @@
     stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
     long startNanos = System.nanoTime();
     try {
-      stream.takeResponseHeaders();
+      stream.takeHeaders();
       fail();
     } catch (InterruptedIOException expected) {
     }
@@ -1250,7 +1368,7 @@
 
     // play it back
     Http2Connection connection = connect(peer);
-    connection.ping().roundTripTime(); // Make sure settings have been received.
+    connection.writePingAndAwaitPong(); // Make sure settings have been received.
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     Sink sink = stream.getSink();
     sink.write(new Buffer().writeUtf8("abcde"), 5);
@@ -1286,7 +1404,6 @@
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().windowUpdate(3, 5);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 3, 0);
     peer.acceptFrame(); // DATA
@@ -1295,9 +1412,9 @@
 
     // play it back
     Http2Connection connection = connect(peer);
-    connection.ping().roundTripTime(); // Make sure settings have been acked.
+    connection.writePingAndAwaitPong(); // Make sure settings have been acked.
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    connection.ping().roundTripTime(); // Make sure the window update has been received.
+    connection.writePingAndAwaitPong(); // Make sure the window update has been received.
     Sink sink = stream.getSink();
     stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
     sink.write(new Buffer().writeUtf8("abcdef"), 6);
@@ -1361,9 +1478,9 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
-    assertEquals(Arrays.asList(new Header("a", "android"), null, new Header("c", "c3po")),
-        stream.takeResponseHeaders());
+    connection.writePingAndAwaitPong(); // Ensure that the HEADERS has been received.
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
+    assertEquals(Headers.of("c", "c3po"), stream.takeHeaders());
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
@@ -1387,9 +1504,9 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     stream.getConnection().flush();
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
-    connection.ping().roundTripTime();
-    assertEquals(headerEntries("c", "cola"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
+    connection.writePingAndAwaitPong();
+    assertEquals(Headers.of("c", "cola"), stream.takeHeaders());
 
     // verify the peer received what was expected
     assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
@@ -1421,7 +1538,7 @@
     connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
     buffer.writeAll(in);
@@ -1499,7 +1616,7 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
     Source in = stream.getSource();
     try {
       Okio.buffer(in).readByteString(101);
@@ -1565,7 +1682,7 @@
 
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     try {
-      stream.takeResponseHeaders();
+      stream.takeHeaders();
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
@@ -1588,12 +1705,17 @@ private void assertStreamData(String expected, Source source) throws IOException
     assertEquals(expected, actual);
   }
 
+  /** Reads {@code prefix} from {@code source}. */
+  private void assertStreamPrefix(String prefix, BufferedSource source) throws IOException {
+    assertEquals(prefix, source.readUtf8(Utf8.size(prefix)));
+  }
+
   /**
    * Returns true when all work currently in progress by the watchdog have completed. This method
    * creates more work for the watchdog and waits for that work to be executed. When it is, we know
    * work that preceded this call is complete.
    */
-  private void awaitWatchdogIdle() throws InterruptedException {
+  private void awaitWatchdogIdle() throws Exception {
     final CountDownLatch latch = new CountDownLatch(1);
     AsyncTimeout watchdogJob = new AsyncTimeout() {
       @Override protected void timedOut() {
@@ -1663,7 +1785,7 @@ private Http2Connection connect(MockHttp2Peer peer, PushObserver pushObserver,
   private static class RecordingPushObserver implements PushObserver {
     final List<Object> events = new ArrayList<>();
 
-    public synchronized Object takeEvent() throws InterruptedException {
+    public synchronized Object takeEvent() throws Exception {
       while (events.isEmpty()) {
         wait();
       }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index e0a9c0d3ba..eb0acf4963 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -20,16 +20,17 @@
 import java.net.Authenticator;
 import java.net.HttpURLConnection;
 import java.net.SocketTimeoutException;
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
+import java.util.Collection;
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.SynchronousQueue;
-import javax.net.ssl.HostnameVerifier;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import okhttp3.Cache;
 import okhttp3.Call;
 import okhttp3.Callback;
@@ -46,14 +47,12 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.Route;
+import okhttp3.TestLogHandler;
 import okhttp3.TestUtil;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.internal.SocketRecorder;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -61,9 +60,9 @@
 import okhttp3.mockwebserver.QueueDispatcher;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
-import okio.BufferedSource;
 import okio.GzipSink;
 import okio.Okio;
 import org.junit.After;
@@ -72,39 +71,85 @@
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
 
-/** Test how SPDY interacts with HTTP/2 features. */
+/** Test how HTTP/2 interacts with HTTP features. */
+@RunWith(Parameterized.class)
 public final class HttpOverHttp2Test {
+  private static final Logger http2Logger = Logger.getLogger(Http2.class.getName());
+  private static final HandshakeCertificates handshakeCertificates = localhost();
+
+  @Parameters(name = "{0}")
+  public static Collection<Protocol> data() {
+    return Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_2);
+  }
+
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
   @Rule public final MockWebServer server = new MockWebServer();
 
-  private SslClient sslClient = SslClient.localhost();
-  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private OkHttpClient client;
   private Cache cache;
+  private TestLogHandler http2Handler = new TestLogHandler();
+  private Level previousLevel;
+  private String scheme;
+  private Protocol protocol;
+
+  public HttpOverHttp2Test(Protocol protocol) {
+    this.client = protocol == Protocol.HTTP_2 ? buildHttp2Client() : buildH2PriorKnowledgeClient();
+    this.scheme = protocol == Protocol.HTTP_2 ? "https" : "http";
+    this.protocol = protocol;
+  }
 
-  @Before public void setUp() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-    client = defaultClient().newBuilder()
+  private static OkHttpClient buildH2PriorKnowledgeClient() {
+    return defaultClient().newBuilder()
+        .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE))
+        .build();
+  }
+
+  private static OkHttpClient buildHttp2Client() {
+    return defaultClient().newBuilder()
         .protocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
-        .dns(new SingleInetAddressDns())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
   }
 
-  @After public void tearDown() throws Exception {
+  @Before public void setUp() {
+    if (protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
+      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE));
+    } else {
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    }
+
+    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
+
+    http2Logger.addHandler(http2Handler);
+    previousLevel = http2Logger.getLevel();
+    http2Logger.setLevel(Level.FINE);
+  }
+
+  @After public void tearDown() {
     Authenticator.setDefault(null);
+    http2Logger.removeHandler(http2Handler);
+    http2Logger.setLevel(previousLevel);
+
+    client.connectionPool().evictAll();
   }
 
   @Test public void get() throws Exception {
@@ -120,10 +165,11 @@
     assertEquals("ABCDE", response.body().string());
     assertEquals(200, response.code());
     assertEquals("", response.message());
+    assertEquals(protocol, response.protocol());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(scheme, request.getHeader(":scheme"));
     assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
   }
 
@@ -148,7 +194,7 @@
         .url(server.url("/foo"))
         .post(new RequestBody() {
           @Override public MediaType contentType() {
-            return MediaType.parse("text/plain; charset=utf-8");
+            return MediaType.get("text/plain; charset=utf-8");
           }
 
           @Override public void writeTo(BufferedSink sink) throws IOException {
@@ -175,10 +221,10 @@
         .url(server.url("/foo"))
         .post(new RequestBody() {
           @Override public MediaType contentType() {
-            return MediaType.parse("text/plain; charset=utf-8");
+            return MediaType.get("text/plain; charset=utf-8");
           }
 
-          @Override public long contentLength() throws IOException {
+          @Override public long contentLength() {
             return postBytes.length;
           }
 
@@ -206,10 +252,10 @@
         .url(server.url("/foo"))
         .post(new RequestBody() {
           @Override public MediaType contentType() {
-            return MediaType.parse("text/plain; charset=utf-8");
+            return MediaType.get("text/plain; charset=utf-8");
           }
 
-          @Override public long contentLength() throws IOException {
+          @Override public long contentLength() {
             return postBytes.length;
           }
 
@@ -254,6 +300,101 @@
     response2.close();
   }
 
+  @Test public void connectionWindowUpdateAfterCanceling() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1])));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
+
+    // Cancel the call and discard what we've buffered for the response body. This should free up
+    // the connection flow-control window so new requests can proceed.
+    call1.cancel();
+    assertFalse("Call should not have completed successfully.",
+        Util.discard(response1.body().source(), 1, TimeUnit.SECONDS));
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("abc", response2.body().string());
+  }
+
+  /** Wait for the client to receive {@code dataLength} DATA frames. */
+  private void waitForDataFrames(int dataLength) throws Exception {
+    int expectedFrameCount = dataLength / 16384;
+    int dataFrameCount = 0;
+    while (dataFrameCount < expectedFrameCount) {
+      String log = http2Handler.take();
+      if (log.equals("FINE: << 0x00000003 16384 DATA          ")) {
+        dataFrameCount++;
+      }
+    }
+  }
+
+  @Test public void connectionWindowUpdateOnClose() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1])));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
+
+    // Cancel the call and close the response body. This should discard the buffered data and update
+    // the connnection flow-control window.
+    call1.cancel();
+    response1.close();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("abc", response2.body().string());
+  }
+
+  @Test public void concurrentRequestWithEmptyFlowControlWindow() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE])));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
+
+    assertEquals(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE, response1.body().contentLength());
+    int read = response1.body().source().read(new byte[8192]);
+    assertEquals(8192, read);
+
+    // Make a second call that should transmit the response headers. The response body won't be
+    // transmitted until the flow-control window is updated from the first request.
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(200, response2.code());
+
+    // Close the response body. This should discard the buffered data and update the connection
+    // flow-control window.
+    response1.close();
+
+    assertEquals("abc", response2.body().string());
+  }
+
   /** https://github.com/square/okhttp/issues/373 */
   @Test @Ignore public void synchronousRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
@@ -291,7 +432,7 @@
 
     String credential = Credentials.basic("username", "password");
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, "Basic"))
         .build();
 
     Call call = client.newCall(new Request.Builder()
@@ -706,6 +847,70 @@
     assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
   }
 
+  @Test public void recoverFromCancelReusesConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBodyDelay(10, TimeUnit.SECONDS)
+        .setBody("abc"));
+    server.enqueue(new MockResponse()
+        .setBody("def"));
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    callAndCancel(0);
+
+    // Make a second request to ensure the connection is reused.
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("def", response.body().string());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void recoverFromMultipleCancelReusesConnection() throws Exception {
+    server.enqueue(new MockResponse()
+            .setBodyDelay(10, TimeUnit.SECONDS)
+            .setBody("abc"));
+    server.enqueue(new MockResponse()
+            .setBodyDelay(10, TimeUnit.SECONDS)
+            .setBody("def"));
+    server.enqueue(new MockResponse()
+            .setBody("ghi"));
+
+    client = client.newBuilder()
+            .dns(new DoubleInetAddressDns())
+            .build();
+
+    callAndCancel(0);
+    callAndCancel(1);
+
+    // Make a third request to ensure the connection is reused.
+    Call call = client.newCall(new Request.Builder()
+            .url(server.url("/"))
+            .build());
+    Response response = call.execute();
+    assertEquals("ghi", response.body().string());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  /** Make a call and canceling it as soon as it's accepted by the server. */
+  private void callAndCancel(int expectedSequenceNumber) throws Exception {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call1, IOException e) {
+      }
+
+      @Override public void onResponse(Call call1, Response response) {
+      }
+    });
+    assertEquals(expectedSequenceNumber, server.takeRequest().getSequenceNumber());
+    call.cancel();
+  }
+
   @Test public void noRecoveryFromRefusedStreamWithRetryDisabled() throws Exception {
     noRecoveryFromErrorWithRetryDisabled(ErrorCode.REFUSED_STREAM);
   }
@@ -736,12 +941,12 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     }
   }
 
-  @Test public void recoverFromConnectionNoNewStreamsOnFollowUp() throws InterruptedException {
+  @Test public void recoverFromConnectionNoNewStreamsOnFollowUp() throws Exception {
     server.enqueue(new MockResponse()
         .setResponseCode(401));
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(ErrorCode.CANCEL.httpCode));
+        .setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.httpCode));
     server.enqueue(new MockResponse()
         .setBody("DEF"));
     server.enqueue(new MockResponse()
@@ -838,7 +1043,7 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(scheme, request.getHeader(":scheme"));
     assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
 
     RecordedRequest pushedRequest = server.takeRequest();
@@ -864,7 +1069,7 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(scheme, request.getHeader(":scheme"));
     assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
 
     RecordedRequest pushedRequest = server.takeRequest();
@@ -876,12 +1081,6 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     server.enqueue(new MockResponse()
         .setBody("ABC"));
 
-    SocketRecorder socketRecorder = new SocketRecorder();
-    client = client.newBuilder()
-        .sslSocketFactory(socketRecorder.sslSocketFactory(sslClient.socketFactory),
-            sslClient.trustManager)
-        .build();
-
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .method("DELETE", null)
@@ -889,51 +1088,108 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     Response response = call.execute();
     assertEquals("ABC", response.body().string());
 
-    // Replay the bytes written by the client to confirm no data frames were sent.
-    SocketRecorder.RecordedSocket recordedSocket = socketRecorder.takeSocket();
-    Buffer buffer = new Buffer();
-    buffer.write(recordedSocket.bytesWritten());
+    assertEquals(protocol, response.protocol());
 
-    RecordingHandler handler = new RecordingHandler();
-    Http2Reader reader = new Http2Reader(buffer, false);
-    reader.readConnectionPreface(null);
-    while (reader.nextFrame(false, handler)) {
-    }
+    List<String> logs = http2Handler.takeAll();
 
-    assertEquals(1, handler.headerFrameCount);
-    assertTrue(handler.dataFrames.isEmpty());
+    assertThat("header logged", firstFrame(logs, "HEADERS"), containsString("HEADERS       END_STREAM|END_HEADERS"));
   }
 
   @Test public void emptyDataFrameSentWithEmptyBody() throws Exception {
     server.enqueue(new MockResponse()
         .setBody("ABC"));
 
-    SocketRecorder socketRecorder = new SocketRecorder();
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .method("DELETE", Util.EMPTY_REQUEST)
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    assertEquals(protocol, response.protocol());
+
+    List<String> logs = http2Handler.takeAll();
+
+    assertThat("header logged", firstFrame(logs, "HEADERS"), containsString("HEADERS       END_HEADERS"));
+    assertThat("data logged", firstFrame(logs, "DATA"), containsString("0 DATA          END_STREAM"));
+  }
+
+  @Test public void pingsTransmitted() throws Exception {
+    // Ping every 500 ms, starting at 500 ms.
     client = client.newBuilder()
-        .sslSocketFactory(socketRecorder.sslSocketFactory(sslClient.socketFactory),
-            sslClient.trustManager)
+        .pingInterval(500, TimeUnit.MILLISECONDS)
         .build();
 
+    // Delay the response to give 1 ping enough time to be sent and replied to.
+    server.enqueue(new MockResponse()
+        .setBodyDelay(750, TimeUnit.MILLISECONDS)
+        .setBody("ABC"));
+
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
-        .method("DELETE", Util.EMPTY_REQUEST)
         .build());
     Response response = call.execute();
     assertEquals("ABC", response.body().string());
 
-    // Replay the bytes written by the client to confirm an empty data frame was sent.
-    SocketRecorder.RecordedSocket recordedSocket = socketRecorder.takeSocket();
-    Buffer buffer = new Buffer();
-    buffer.write(recordedSocket.bytesWritten());
+    assertEquals(protocol, response.protocol());
+
+    // Confirm a single ping was sent and received, and its reply was sent and received.
+    List<String> logs = http2Handler.takeAll();
+    assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          "));
+    assertEquals(1, countFrames(logs, "FINE: << 0x00000000     8 PING          "));
+    assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          ACK"));
+    assertEquals(1, countFrames(logs, "FINE: << 0x00000000     8 PING          ACK"));
+  }
+
+  @Test public void missingPongsFailsConnection() throws Exception {
+    // Ping every 500 ms, starting at 500 ms.
+    client = client.newBuilder()
+        .readTimeout(10, TimeUnit.SECONDS) // Confirm we fail before the read timeout.
+        .pingInterval(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    // Set up the server to ignore the socket. It won't respond to pings!
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
 
-    RecordingHandler handler = new RecordingHandler();
-    Http2Reader reader = new Http2Reader(buffer, false);
-    reader.readConnectionPreface(null);
-    while (reader.nextFrame(false, handler)) {
+    // Make a call. It'll fail as soon as our pings detect a problem.
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    long executeAtNanos = System.nanoTime();
+    try {
+      call.execute();
+      fail();
+    } catch (StreamResetException expected) {
+      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
     }
 
-    assertEquals(1, handler.headerFrameCount);
-    assertEquals(Collections.singletonList(0), handler.dataFrames);
+    long elapsedUntilFailure = System.nanoTime() - executeAtNanos;
+    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+
+    // Confirm a single ping was sent but not acknowledged.
+    List<String> logs = http2Handler.takeAll();
+    assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          "));
+    assertEquals(0, countFrames(logs, "FINE: << 0x00000000     8 PING          ACK"));
+  }
+
+  private String firstFrame(List<String> logs, String type) {
+    for (String log: logs) {
+      if (log.contains(type)) {
+        return log;
+      }
+    }
+    return null;
+  }
+
+  private int countFrames(List<String> logs, String message) {
+    int result = 0;
+    for (String log: logs) {
+      if (log.equals(message)) {
+        result++;
+      }
+    }
+    return result;
   }
 
   /**
@@ -1083,7 +1339,9 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
    * <p>This test uses proxy tunnels to get a hook while a connection is being established.
    */
   @Test public void concurrentHttp2ConnectionsDeduplicated() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+    assumeTrue(protocol == Protocol.HTTP_2);
+
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
 
     // Force a fresh connection pool for the test.
     client.connectionPool().evictAll();
@@ -1190,7 +1448,7 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     assertEquals("privateobject.com", recordedRequest.getHeader(":authority"));
   }
 
-  public Buffer gzip(String bytes) throws IOException {
+  private Buffer gzip(String bytes) throws IOException {
     Buffer bytesOut = new Buffer();
     BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
     sink.writeUtf8(bytes);
@@ -1202,7 +1460,7 @@ public Buffer gzip(String bytes) throws IOException {
     String path;
     CountDownLatch countDownLatch;
 
-    public AsyncRequest(String path, CountDownLatch countDownLatch) {
+    AsyncRequest(String path, CountDownLatch countDownLatch) {
       this.path = path;
       this.countDownLatch = countDownLatch;
     }
@@ -1220,28 +1478,4 @@ public AsyncRequest(String path, CountDownLatch countDownLatch) {
       }
     }
   }
-
-  static final class RecordingHandler extends BaseTestHandler {
-    int headerFrameCount;
-    final List<Integer> dataFrames = new ArrayList<>();
-
-    @Override public void settings(boolean clearPrevious, Settings settings) {
-    }
-
-    @Override public void ackSettings() {
-    }
-
-    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-    }
-
-    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
-        throws IOException {
-      dataFrames.add(length);
-    }
-
-    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock) {
-      headerFrameCount++;
-    }
-  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
index fe5f82fd4a..376c46d1f3 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
@@ -100,7 +100,7 @@ public Http2Writer truncateLastFrame(int length) {
     return writer;
   }
 
-  public InFrame takeFrame() throws InterruptedException {
+  public InFrame takeFrame() throws Exception {
     return inFrames.take();
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
index ada8f78969..2889911d52 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
@@ -39,4 +39,9 @@ public void findsAlpnMethods() {
     assertEquals("getApplicationProtocol", platform.getProtocolMethod.getName());
     assertEquals("setApplicationProtocols", platform.setProtocolMethod.getName());
   }
+
+  @Test
+  public void testToStringIsClassname() {
+    assertEquals("Jdk9Platform", new Jdk9Platform(null, null).toString());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
index ffd5842e83..48504202b5 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
@@ -32,4 +32,9 @@
   public static String getPlatform() {
     return System.getProperty("okhttp.platform", "platform");
   }
+
+  @Test
+  public void testToStringIsClassname() {
+    assertEquals("Platform", new Platform().toString());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
index dad2e0e950..ffb116eea7 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
@@ -15,24 +15,37 @@
  */
 package okhttp3.internal.tls;
 
+import java.security.GeneralSecurityException;
+import java.security.SecureRandom;
+import java.security.cert.X509Certificate;
+import java.util.Collections;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
 import okhttp3.Call;
 import okhttp3.CertificatePinner;
 import okhttp3.OkHttpClient;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.platform.Platform;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.mockwebserver.internal.tls.HeldCertificate;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HeldCertificate;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Rule;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.internal.platform.PlatformTest.getPlatform;
+import static okhttp3.tls.internal.TlsUtil.newKeyManager;
+import static okhttp3.tls.internal.TlsUtil.newTrustManager;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -43,37 +56,38 @@
   /** The pinner should pull the root certificate from the trust manager. */
   @Test public void pinRootNotPresentInChain() throws Exception {
     HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("2")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("intermediate_ca")
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
-        .serialNumber("3")
+        .signedBy(intermediateCa)
+        .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(rootCa.certificate))
+        .add(server.getHostName(), CertificatePinner.pin(rootCa.certificate()))
         .build();
-    SslClient sslClient = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
         .build();
     OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
 
-    SslClient serverSslClient = new SslClient.Builder()
-        .certificateChain(certificate, intermediateCa)
+    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(certificate, intermediateCa.certificate())
         .build();
-    server.useHttps(serverSslClient.socketFactory, false);
+    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
 
     // The request should complete successfully.
     server.enqueue(new MockResponse()
@@ -99,37 +113,38 @@
   /** The pinner should accept an intermediate from the server's chain. */
   @Test public void pinIntermediatePresentInChain() throws Exception {
     HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("2")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("intermediate_ca")
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
-        .serialNumber("3")
+        .signedBy(intermediateCa)
+        .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(intermediateCa.certificate))
+        .add(server.getHostName(), CertificatePinner.pin(intermediateCa.certificate()))
         .build();
-    SslClient contextBuilder = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
         .build();
     OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(contextBuilder.socketFactory, contextBuilder.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
 
-    SslClient serverSslContext = new SslClient.Builder()
-        .certificateChain(certificate.keyPair, certificate.certificate, intermediateCa.certificate)
+    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(certificate, intermediateCa.certificate())
         .build();
-    server.useHttps(serverSslContext.socketFactory, false);
+    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
 
     // The request should complete successfully.
     server.enqueue(new MockResponse()
@@ -160,8 +175,8 @@
   @Test public void unrelatedPinnedLeafCertificateInChain() throws Exception {
     // Start with a trusted root CA certificate.
     HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
         .build();
 
@@ -169,24 +184,25 @@
     // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
     // certificate.
     HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("2")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("good_intermediate_ca")
         .build();
     HeldCertificate goodCertificate = new HeldCertificate.Builder()
-        .issuedBy(goodIntermediateCa)
-        .serialNumber("3")
+        .signedBy(goodIntermediateCa)
+        .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(goodCertificate.certificate))
+        .add(server.getHostName(), CertificatePinner.pin(goodCertificate.certificate()))
         .build();
-    SslClient clientContextBuilder = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
         .build();
     OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(clientContextBuilder.socketFactory, clientContextBuilder.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
@@ -196,32 +212,21 @@
     // trusted good certificate above. The attack is that by including the good certificate in the
     // chain, we may trick the certificate pinner into accepting the rouge certificate.
     HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("4")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(4L)
         .commonName("bad_intermediate_ca")
         .build();
     HeldCertificate rogueCertificate = new HeldCertificate.Builder()
-        .serialNumber("5")
-        .issuedBy(compromisedIntermediateCa)
+        .serialNumber(5L)
+        .signedBy(compromisedIntermediateCa)
         .commonName(server.getHostName())
         .build();
 
-    SslClient.Builder sslBuilder = new SslClient.Builder();
+    SSLSocketFactory socketFactory = newServerSocketFactory(rogueCertificate,
+        compromisedIntermediateCa.certificate(), goodCertificate.certificate());
 
-    // Test setup fails on JDK9
-    // java.security.KeyStoreException: Certificate chain is not valid
-    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
-    // http://openjdk.java.net/jeps/229
-    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
-    if (getPlatform().equals("jdk9")) {
-      sslBuilder.keyStoreType("JKS");
-    }
-
-    SslClient serverSslContext = sslBuilder.certificateChain(
-        rogueCertificate.keyPair, rogueCertificate.certificate, compromisedIntermediateCa.certificate, goodCertificate.certificate, rootCa.certificate)
-        .build();
-    server.useHttps(serverSslContext.socketFactory, false);
+    server.useHttps(socketFactory, false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .addHeader("Content-Type: text/plain"));
@@ -245,13 +250,13 @@
   @Test public void unrelatedPinnedIntermediateCertificateInChain() throws Exception {
     // Start with two root CA certificates, one is good and the other is compromised.
     HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
         .build();
     HeldCertificate compromisedRootCa = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .ca(3)
+        .serialNumber(2L)
+        .certificateAuthority(1)
         .commonName("compromised_root")
         .build();
 
@@ -259,20 +264,21 @@
     // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
     // certificate.
     HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("3")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(3L)
         .commonName("intermediate_ca")
         .build();
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(goodIntermediateCa.certificate))
+        .add(server.getHostName(), CertificatePinner.pin(goodIntermediateCa.certificate()))
         .build();
-    SslClient clientContextBuilder = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
-        .addTrustedCertificate(compromisedRootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
+        .addTrustedCertificate(compromisedRootCa.certificate())
         .build();
     OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(clientContextBuilder.socketFactory, clientContextBuilder.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
@@ -282,32 +288,20 @@
     // serves the good CAs certificate in the chain, which means the certificate pinner sees a
     // different set of certificates than the SSL verifier.
     HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(compromisedRootCa)
-        .ca(2)
-        .serialNumber("4")
+        .signedBy(compromisedRootCa)
+        .certificateAuthority(0)
+        .serialNumber(4L)
         .commonName("intermediate_ca")
         .build();
     HeldCertificate rogueCertificate = new HeldCertificate.Builder()
-        .serialNumber("5")
-        .issuedBy(compromisedIntermediateCa)
+        .serialNumber(5L)
+        .signedBy(compromisedIntermediateCa)
         .commonName(server.getHostName())
         .build();
 
-    SslClient.Builder sslBuilder = new SslClient.Builder();
-
-    // Test setup fails on JDK9
-    // java.security.KeyStoreException: Certificate chain is not valid
-    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
-    // http://openjdk.java.net/jeps/229
-    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
-    if (getPlatform().equals("jdk9")) {
-      sslBuilder.keyStoreType("JKS");
-    }
-
-    SslClient serverSslContext = sslBuilder.certificateChain(
-            rogueCertificate.keyPair, rogueCertificate.certificate, goodIntermediateCa.certificate, compromisedIntermediateCa.certificate, compromisedRootCa.certificate)
-        .build();
-    server.useHttps(serverSslContext.socketFactory, false);
+    SSLSocketFactory socketFactory = newServerSocketFactory(rogueCertificate,
+        goodIntermediateCa.certificate(), compromisedIntermediateCa.certificate());
+    server.useHttps(socketFactory, false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .addHeader("Content-Type: text/plain"));
@@ -331,4 +325,21 @@
       assertTrue(message, message.startsWith("Certificate pinning failure!"));
     }
   }
+
+  private SSLSocketFactory newServerSocketFactory(HeldCertificate heldCertificate,
+      X509Certificate... intermediates) throws GeneralSecurityException {
+    // Test setup fails on JDK9
+    // java.security.KeyStoreException: Certificate chain is not valid
+    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
+    // http://openjdk.java.net/jeps/229
+    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
+    String keystoreType = getPlatform().equals("jdk9") ? "JKS" : null;
+    X509KeyManager x509KeyManager = newKeyManager(keystoreType, heldCertificate, intermediates);
+    X509TrustManager trustManager = newTrustManager(
+        keystoreType, Collections.<X509Certificate>emptyList());
+    SSLContext sslContext = Platform.get().getSSLContext();
+    sslContext.init(new KeyManager[] { x509KeyManager }, new TrustManager[] { trustManager },
+        new SecureRandom());
+    return sslContext.getSocketFactory();
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
index 3f753de0d1..ff3fb12270 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
@@ -15,31 +15,37 @@
  */
 package okhttp3.internal.tls;
 
-import java.io.IOException;
 import java.net.SocketException;
 import java.security.GeneralSecurityException;
-import java.security.NoSuchAlgorithmException;
+import java.security.SecureRandom;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import javax.net.ssl.KeyManager;
 import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
 import javax.security.auth.x500.X500Principal;
 import okhttp3.Call;
-import okhttp3.DelegatingSSLSocketFactory;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.internal.tls.HeldCertificate;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HeldCertificate;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.internal.platform.PlatformTest.getPlatform;
+import static okhttp3.tls.internal.TlsUtil.newKeyManager;
+import static okhttp3.tls.internal.TlsUtil.newTrustManager;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -47,10 +53,6 @@
 public final class ClientAuthTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
-  public enum ClientAuth {
-    NONE, WANTS, NEEDS
-  }
-
   private HeldCertificate serverRootCa;
   private HeldCertificate serverIntermediateCa;
   private HeldCertificate serverCert;
@@ -59,56 +61,57 @@
   private HeldCertificate clientCert;
 
   @Before
-  public void setUp() throws GeneralSecurityException {
+  public void setUp() {
     serverRootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
-        .subjectAlternativeName("root_ca.com")
+        .addSubjectAlternativeName("root_ca.com")
         .build();
     serverIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(serverRootCa)
-        .ca(2)
-        .serialNumber("2")
+        .signedBy(serverRootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("intermediate_ca")
-        .subjectAlternativeName("intermediate_ca.com")
+        .addSubjectAlternativeName("intermediate_ca.com")
         .build();
 
     serverCert = new HeldCertificate.Builder()
-        .issuedBy(serverIntermediateCa)
-        .serialNumber("3")
+        .signedBy(serverIntermediateCa)
+        .serialNumber(3L)
         .commonName("Local Host")
-        .subjectAlternativeName(server.getHostName())
+        .addSubjectAlternativeName(server.getHostName())
         .build();
 
     clientRootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(13)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
-        .subjectAlternativeName("root_ca.com")
+        .addSubjectAlternativeName("root_ca.com")
         .build();
     clientIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(serverRootCa)
-        .ca(12)
-        .serialNumber("2")
+        .signedBy(serverRootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("intermediate_ca")
-        .subjectAlternativeName("intermediate_ca.com")
+        .addSubjectAlternativeName("intermediate_ca.com")
         .build();
 
     clientCert = new HeldCertificate.Builder()
-        .issuedBy(clientIntermediateCa)
-        .serialNumber("4")
+        .signedBy(clientIntermediateCa)
+        .serialNumber(4L)
         .commonName("Jethro Willis")
-        .subjectAlternativeName("jethrowillis.com")
+        .addSubjectAlternativeName("jethrowillis.com")
         .build();
   }
 
   @Test public void clientAuthForWants() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.WANTS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requestClientAuth();
     server.enqueue(new MockResponse().setBody("abc"));
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
@@ -119,11 +122,12 @@ public void setUp() throws GeneralSecurityException {
   }
 
   @Test public void clientAuthForNeeds() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requireClientAuth();
     server.enqueue(new MockResponse().setBody("abc"));
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
@@ -134,11 +138,12 @@ public void setUp() throws GeneralSecurityException {
   }
 
   @Test public void clientAuthSkippedForNone() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NONE);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.noClientAuth();
     server.enqueue(new MockResponse().setBody("abc"));
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
@@ -149,11 +154,12 @@ public void setUp() throws GeneralSecurityException {
   }
 
   @Test public void missingClientAuthSkippedForWantsOnly() throws Exception {
-    OkHttpClient client = buildClient(null, clientIntermediateCa);
+    OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.WANTS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requestClientAuth();
     server.enqueue(new MockResponse().setBody("abc"));
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
@@ -164,11 +170,12 @@ public void setUp() throws GeneralSecurityException {
   }
 
   @Test public void missingClientAuthFailsForNeeds() throws Exception {
-    OkHttpClient client = buildClient(null, clientIntermediateCa);
+    OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requireClientAuth();
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
 
@@ -176,25 +183,28 @@ public void setUp() throws GeneralSecurityException {
       call.execute();
       fail();
     } catch (SSLHandshakeException expected) {
+    } catch (SSLException expected) {
+      String jvmVersion = System.getProperty("java.specification.version");
+      assertEquals("11", jvmVersion);
     } catch (SocketException expected) {
-      // JDK 9
-      assertTrue(getPlatform().equals("jdk9"));
+      assertEquals("jdk9", getPlatform());
     }
   }
 
   @Test public void commonNameIsNotTrusted() throws Exception {
     serverCert = new HeldCertificate.Builder()
-        .issuedBy(serverIntermediateCa)
-        .serialNumber("3")
+        .signedBy(serverIntermediateCa)
+        .serialNumber(3L)
         .commonName(server.getHostName())
-        .subjectAlternativeName("different-host.com")
+        .addSubjectAlternativeName("different-host.com")
         .build();
 
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requireClientAuth();
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
 
@@ -207,15 +217,16 @@ public void setUp() throws GeneralSecurityException {
 
   @Test public void invalidClientAuthFails() throws Throwable {
     HeldCertificate clientCert2 = new HeldCertificate.Builder()
-        .serialNumber("4")
+        .serialNumber(4L)
         .commonName("Jethro Willis")
         .build();
 
     OkHttpClient client = buildClient(clientCert2);
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requireClientAuth();
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
 
@@ -223,54 +234,45 @@ public void setUp() throws GeneralSecurityException {
       call.execute();
       fail();
     } catch (SSLHandshakeException expected) {
+    } catch (SSLException expected) {
+      // javax.net.ssl.SSLException: readRecord
+      String jvmVersion = System.getProperty("java.specification.version");
+      assertEquals("11", jvmVersion);
     } catch (SocketException expected) {
-      // JDK 9
-      assertTrue(getPlatform().equals("jdk9"));
+      assertEquals("jdk9", getPlatform());
     }
   }
 
-  public OkHttpClient buildClient(HeldCertificate cert, HeldCertificate... chain) {
-    SslClient.Builder sslClientBuilder = new SslClient.Builder()
-        .addTrustedCertificate(serverRootCa.certificate);
+  private OkHttpClient buildClient(
+      HeldCertificate heldCertificate, X509Certificate... intermediates) {
+    HandshakeCertificates.Builder builder = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(serverRootCa.certificate());
 
-    if (cert != null) {
-      sslClientBuilder.certificateChain(cert, chain);
+    if (heldCertificate != null) {
+      builder.heldCertificate(heldCertificate, intermediates);
     }
 
-    SslClient sslClient = sslClientBuilder.build();
+    HandshakeCertificates handshakeCertificates = builder.build();
     return defaultClient().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .build();
   }
 
-  public SSLSocketFactory buildServerSslSocketFactory(final ClientAuth clientAuth) {
+  private SSLSocketFactory buildServerSslSocketFactory() {
     // The test uses JDK default SSL Context instead of the Platform provided one
     // as Conscrypt seems to have some differences, we only want to test client side here.
-    SslClient serverSslClient = new SslClient.Builder()
-        .addTrustedCertificate(serverRootCa.certificate)
-        .addTrustedCertificate(clientRootCa.certificate)
-        .certificateChain(serverCert, serverIntermediateCa)
-        .sslContext(getSslContext())
-        .build();
-
-    return new DelegatingSSLSocketFactory(serverSslClient.socketFactory) {
-      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
-        if (clientAuth == ClientAuth.NEEDS) {
-          sslSocket.setNeedClientAuth(true);
-        } else if (clientAuth == ClientAuth.WANTS) {
-          sslSocket.setWantClientAuth(true);
-        }
-
-        return super.configureSocket(sslSocket);
-      }
-    };
-  }
-
-  private SSLContext getSslContext() {
     try {
-      return SSLContext.getInstance("TLS");
-    } catch (NoSuchAlgorithmException e) {
-      throw new IllegalStateException("unable to build JDK default SSLContext");
+      X509KeyManager keyManager = newKeyManager(
+          null, serverCert, serverIntermediateCa.certificate());
+      X509TrustManager trustManager = newTrustManager(
+          null, Arrays.asList(serverRootCa.certificate(), clientRootCa.certificate()));
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(new KeyManager[] {keyManager}, new TrustManager[] {trustManager},
+          new SecureRandom());
+      return sslContext.getSocketFactory();
+    } catch (GeneralSecurityException e) {
+      throw new AssertionError(e);
     }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index af26aa095c..38b2762e6a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -18,6 +18,7 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
+import java.net.SocketTimeoutException;
 import java.util.Random;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Protocol;
@@ -304,6 +305,43 @@
     assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing3), 250d);
   }
 
+  @Test public void unacknowledgedPingFailsConnection() throws IOException {
+    long startNanos = System.nanoTime();
+    client.initWebSocket(random, 500);
+
+    // Don't process the ping and pong frames!
+    client.listener.assertFailure(SocketTimeoutException.class,
+        "sent ping but didn't receive pong within 500ms (after 0 successful ping/pongs)");
+    long elapsedUntilFailure = System.nanoTime() - startNanos;
+    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+  }
+
+  @Test public void unexpectedPongsDoNotInterfereWithFailureDetection() throws IOException {
+    long startNanos = System.nanoTime();
+    client.initWebSocket(random, 500);
+
+    // At 0ms the server sends 3 unexpected pongs. The client accepts 'em and ignores em.
+    server.webSocket.pong(ByteString.encodeUtf8("pong 1"));
+    client.processNextFrame();
+    server.webSocket.pong(ByteString.encodeUtf8("pong 2"));
+    client.processNextFrame();
+    server.webSocket.pong(ByteString.encodeUtf8("pong 3"));
+    client.processNextFrame();
+
+    // After 500ms the client automatically pings and the server pongs back.
+    server.processNextFrame(); // Ping.
+    client.processNextFrame(); // Pong.
+    long elapsedUntilPing = System.nanoTime() - startNanos;
+    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing), 250d);
+
+    // After 1000ms the client will attempt a ping 2, but we don't process it. That'll cause the
+    // client to fail at 1500ms when it's time to send ping 3 because pong 2 hasn't been received.
+    client.listener.assertFailure(SocketTimeoutException.class,
+        "sent ping but didn't receive pong within 500ms (after 1 successful ping/pongs)");
+    long elapsedUntilFailure = System.nanoTime() - startNanos;
+    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+  }
+
   /** One peer's streams, listener, and web socket in the test. */
   private static class TestStreams extends RealWebSocket.Streams {
     private final String name;
@@ -326,8 +364,8 @@ public void initWebSocket(Random random, int pingIntervalMillis) throws IOExcept
           .request(new Request.Builder().url(url).build())
           .protocol(Protocol.HTTP_1_1)
           .build();
-      webSocket = new RealWebSocket(response.request(), listener, random);
-      webSocket.initReaderAndWriter(name, pingIntervalMillis, this);
+      webSocket = new RealWebSocket(response.request(), listener, random, pingIntervalMillis);
+      webSocket.initReaderAndWriter(name, this);
     }
 
     public boolean processNextFrame() throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
index b4a0ba8a48..1e17baa9c2 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
@@ -17,15 +17,19 @@
 
 import java.io.EOFException;
 import java.io.IOException;
+import java.net.HttpURLConnection;
 import java.net.ProtocolException;
 import java.net.SocketTimeoutException;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Random;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Logger;
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
 import okhttp3.RecordingEventListener;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
@@ -33,12 +37,12 @@
 import okhttp3.TestLogHandler;
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.ByteString;
 import org.junit.After;
@@ -48,6 +52,7 @@
 
 import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.TestUtil.repeat;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -58,7 +63,7 @@
 public final class WebSocketHttpTest {
   @Rule public final MockWebServer webServer = new MockWebServer();
 
-  private final SslClient sslClient = SslClient.localhost();
+  private final HandshakeCertificates handshakeCertificates = localhost();
   private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
   private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
   private final Random random = new Random(0);
@@ -78,7 +83,7 @@
     clientListener.assertExhausted();
   }
 
-  @Test public void textMessage() throws IOException {
+  @Test public void textMessage() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
 
@@ -89,7 +94,7 @@
     serverListener.assertTextMessage("Hello, WebSockets!");
   }
 
-  @Test public void binaryMessage() throws IOException {
+  @Test public void binaryMessage() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
 
@@ -100,7 +105,7 @@
     serverListener.assertBinaryMessage(ByteString.of(new byte[] {'H', 'e', 'l', 'l', 'o', '!'}));
   }
 
-  @Test public void nullStringThrows() throws IOException {
+  @Test public void nullStringThrows() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
 
@@ -113,7 +118,7 @@
     }
   }
 
-  @Test public void nullByteStringThrows() throws IOException {
+  @Test public void nullByteStringThrows() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
 
@@ -126,7 +131,7 @@
     }
   }
 
-  @Test public void serverMessage() throws IOException {
+  @Test public void serverMessage() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     newWebSocket();
 
@@ -154,7 +159,7 @@
   }
 
   @Ignore("AsyncCall currently lets runtime exceptions propagate.")
-  @Test public void throwingOnFailLogs() throws InterruptedException {
+  @Test public void throwingOnFailLogs() throws Exception {
     TestLogHandler logs = new TestLogHandler();
     Logger logger = Logger.getLogger(OkHttpClient.class.getName());
     logger.addHandler(logs);
@@ -174,7 +179,7 @@
     logger.removeHandler(logs);
   }
 
-  @Test public void throwingOnMessageClosesImmediatelyAndFails() throws IOException {
+  @Test public void throwingOnMessageClosesImmediatelyAndFails() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     newWebSocket();
 
@@ -194,7 +199,7 @@
     serverListener.assertExhausted();
   }
 
-  @Test public void throwingOnClosingClosesImmediatelyAndFails() throws IOException {
+  @Test public void throwingOnClosingClosesImmediatelyAndFails() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     newWebSocket();
 
@@ -347,7 +352,7 @@
         "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
   }
 
-  @Test public void webSocketAndApplicationInterceptors() throws IOException {
+  @Test public void webSocketAndApplicationInterceptors() {
     final AtomicInteger interceptedCount = new AtomicInteger();
 
     client = client.newBuilder()
@@ -373,10 +378,10 @@
     server.close(1000, null);
   }
 
-  @Test public void webSocketAndNetworkInterceptors() throws IOException {
+  @Test public void webSocketAndNetworkInterceptors() {
     client = client.newBuilder()
         .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
+          @Override public Response intercept(Chain chain) {
             throw new AssertionError(); // Network interceptors don't execute.
           }
         }).build();
@@ -391,7 +396,7 @@
     server.close(1000, null);
   }
 
-  @Test public void overflowOutgoingQueue() throws IOException {
+  @Test public void overflowOutgoingQueue() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     WebSocket webSocket = newWebSocket();
@@ -424,7 +429,7 @@
     serverListener.assertClosed(1001, "");
   }
 
-  @Test public void closeReasonMaximumLength() throws IOException {
+  @Test public void closeReasonMaximumLength() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     String clientReason = repeat('C', 123);
@@ -444,7 +449,7 @@
     serverListener.assertClosed(1000, clientReason);
   }
 
-  @Test public void closeReasonTooLong() throws IOException {
+  @Test public void closeReasonTooLong() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     WebSocket webSocket = newWebSocket();
@@ -469,35 +474,37 @@
     serverListener.assertClosed(1000, "");
   }
 
-  @Test public void wsScheme() throws IOException {
+  @Test public void wsScheme() {
     websocketScheme("ws");
   }
 
-  @Test public void wsUppercaseScheme() throws IOException {
+  @Test public void wsUppercaseScheme() {
     websocketScheme("WS");
   }
 
-  @Test public void wssScheme() throws IOException {
-    webServer.useHttps(sslClient.socketFactory, false);
+  @Test public void wssScheme() {
+    webServer.useHttps(handshakeCertificates.sslSocketFactory(), false);
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
     websocketScheme("wss");
   }
 
-  @Test public void httpsScheme() throws IOException {
-    webServer.useHttps(sslClient.socketFactory, false);
+  @Test public void httpsScheme() {
+    webServer.useHttps(handshakeCertificates.sslSocketFactory(), false);
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
     websocketScheme("https");
   }
 
-  @Test public void readTimeoutAppliesToHttpRequest() throws IOException {
+  @Test public void readTimeoutAppliesToHttpRequest() {
     webServer.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.NO_RESPONSE));
 
@@ -512,9 +519,9 @@
    * reading a frame we enable the read timeout. In this test we have the server returning the first
    * byte of a frame but no more frames.
    */
-  @Test public void readTimeoutAppliesWithinFrames() throws IOException {
+  @Test public void readTimeoutAppliesWithinFrames() {
     webServer.setDispatcher(new Dispatcher() {
-      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+      @Override public MockResponse dispatch(RecordedRequest request) {
         return upgradeResponse(request)
             .setBody(new Buffer().write(ByteString.decodeHex("81"))) // Truncated frame.
             .removeHeader("Content-Length")
@@ -555,7 +562,7 @@
     RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
 
     long startNanos = System.nanoTime();
-    while (webSocket.pongCount() < 3) {
+    while (webSocket.receivedPongCount() < 3) {
       Thread.sleep(50);
     }
 
@@ -563,12 +570,13 @@
     assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3), 250d);
 
     // The client pinged the server 3 times, and it has ponged back 3 times.
-    assertEquals(3, server.pingCount());
-    assertEquals(3, webSocket.pongCount());
+    assertEquals(3, webSocket.sentPingCount());
+    assertEquals(3, server.receivedPingCount());
+    assertEquals(3, webSocket.receivedPongCount());
 
     // The server has never pinged the client.
-    assertEquals(0, server.pongCount());
-    assertEquals(0, webSocket.pingCount());
+    assertEquals(0, server.receivedPongCount());
+    assertEquals(0, webSocket.receivedPingCount());
   }
 
   @Test public void clientDoesNotPingServerByDefault() throws Exception {
@@ -581,14 +589,49 @@
     Thread.sleep(1000);
 
     // No pings and no pongs.
-    assertEquals(0, server.pingCount());
-    assertEquals(0, webSocket.pongCount());
-    assertEquals(0, server.pongCount());
-    assertEquals(0, webSocket.pingCount());
+    assertEquals(0, webSocket.sentPingCount());
+    assertEquals(0, webSocket.receivedPingCount());
+    assertEquals(0, webSocket.receivedPongCount());
+    assertEquals(0, server.sentPingCount());
+    assertEquals(0, server.receivedPingCount());
+    assertEquals(0, server.receivedPongCount());
+  }
+
+  /**
+   * Configure the websocket to send pings every 500 ms. Artificially prevent the server from
+   * responding to pings. The client should give up when attempting to send its 2nd ping, at about
+   * 1000 ms.
+   */
+  @Test public void unacknowledgedPingFailsConnection() {
+    client = client.newBuilder()
+        .pingInterval(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    // Stall in onOpen to prevent pongs from being sent.
+    final CountDownLatch latch = new CountDownLatch(1);
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(new WebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+        try {
+          latch.await(); // The server can't respond to pings!
+        } catch (InterruptedException e) {
+          throw new AssertionError(e);
+        }
+      }
+    }));
+
+    long openAtNanos = System.nanoTime();
+    newWebSocket();
+    clientListener.assertOpen();
+    clientListener.assertFailure(SocketTimeoutException.class,
+        "sent ping but didn't receive pong within 500ms (after 0 successful ping/pongs)");
+    latch.countDown();
+
+    long elapsedUntilFailure = System.nanoTime() - openAtNanos;
+    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
   }
 
   /** https://github.com/square/okhttp/issues/2788 */
-  @Test public void clientCancelsIfCloseIsNotAcknowledged() throws Exception {
+  @Test public void clientCancelsIfCloseIsNotAcknowledged() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     RealWebSocket webSocket = newWebSocket();
 
@@ -610,7 +653,7 @@
     serverListener.assertClosed(1000, "goodbye");
   }
 
-  @Test public void webSocketsDontTriggerEventListener() throws IOException {
+  @Test public void webSocketsDontTriggerEventListener() {
     RecordingEventListener listener = new RecordingEventListener();
 
     client = client.newBuilder()
@@ -637,6 +680,53 @@
     assertEquals(Collections.emptyList(), listener.recordedEventTypes());
   }
 
+  @Test public void callTimeoutIsNotApplied() throws Exception {
+    client = client.newBuilder()
+        .callTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    webServer.enqueue(new MockResponse()
+        .withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    Thread.sleep(500);
+
+    server.send("Hello, WebSockets!");
+    clientListener.assertTextMessage("Hello, WebSockets!");
+  }
+
+  /**
+   * We had a bug where web socket connections were leaked if the HTTP connection upgrade was not
+   * successful. This test confirms that connections are released back to the connection pool!
+   * https://github.com/square/okhttp/issues/4258
+   */
+  @Test public void webSocketConnectionIsReleased() throws Exception {
+    // This test assumes HTTP/1.1 pooling semantics.
+    client = client.newBuilder()
+        .protocols(Arrays.asList(Protocol.HTTP_1_1))
+        .build();
+
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_FOUND)
+        .setBody("not found!"));
+    webServer.enqueue(new MockResponse());
+
+    newWebSocket();
+    clientListener.assertFailure();
+
+    Request regularRequest = new Request.Builder()
+        .url(webServer.url("/"))
+        .build();
+    Response response = client.newCall(regularRequest).execute();
+    response.close();
+
+    assertEquals(0, webServer.takeRequest().getSequenceNumber());
+    assertEquals(1, webServer.takeRequest().getSequenceNumber());
+  }
+
   private MockResponse upgradeResponse(RecordedRequest request) {
     String key = request.getHeader("Sec-WebSocket-Key");
     return new MockResponse()
@@ -646,7 +736,7 @@ private MockResponse upgradeResponse(RecordedRequest request) {
         .setHeader("Sec-WebSocket-Accept", WebSocketProtocol.acceptHeader(key));
   }
 
-  private void websocketScheme(String scheme) throws IOException {
+  private void websocketScheme(String scheme) {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     Request request = new Request.Builder()
@@ -666,7 +756,8 @@ private RealWebSocket newWebSocket() {
   }
 
   private RealWebSocket newWebSocket(Request request) {
-    RealWebSocket webSocket = new RealWebSocket(request, clientListener, random);
+    RealWebSocket webSocket = new RealWebSocket(
+        request, clientListener, random, client.pingIntervalMillis());
     webSocket.connect(client);
     return webSocket;
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
index a303cc1052..e183d0e2a8 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -174,15 +174,19 @@
   }
 
   @Test public void serverBinaryMessage() throws IOException {
+    ByteString data = ByteString.decodeHex(""
+        + "60b420bb3851d9d47acb933dbe70399bf6c92da33af01d4fb7"
+        + "70e98c0325f41d3ebaf8986da712c82bcd4d554bf0b54023c2");
+
     BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_BINARY, -1));
 
-    sink.write(binaryData(50)).flush();
+    sink.write(data).flush();
     assertData("0232");
-    assertData(binaryData(50));
+    assertData(data);
 
-    sink.write(binaryData(50)).flush();
+    sink.write(data).flush();
     assertData("0032");
-    assertData(binaryData(50));
+    assertData(data);
 
     sink.close();
     assertData("8000");
@@ -229,28 +233,25 @@
   }
 
   @Test public void clientBinary() throws IOException {
-    byte[] maskKey1 = new byte[4];
-    random.nextBytes(maskKey1);
-    byte[] maskKey2 = new byte[4];
-    random.nextBytes(maskKey2);
-
-    random.setSeed(0); // Reset the seed so real data matches.
+    ByteString data = ByteString.decodeHex(""
+        + "60b420bb3851d9d47acb933dbe70399bf6c92da33af01d4fb7"
+        + "70e98c0325f41d3ebaf8986da712c82bcd4d554bf0b54023c2");
 
     BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_BINARY, -1));
 
-    byte[] part1 = binaryData(50);
-    sink.write(part1).flush();
-    toggleMask(part1, 50, maskKey1, 0);
+    sink.write(data).flush();
     assertData("02b2");
-    assertData(maskKey1);
-    assertData(part1);
+    assertData("60b420bb");
+    assertData(""
+        + "0000000058e5f96f1a7fb386dec41920967d0d185a443df4d7"
+        + "c4c9376391d4a65e0ed8230d1332734b796dee2b4495fb4376");
 
-    byte[] part2 = binaryData(50);
-    sink.write(part2).close();
-    toggleMask(part2, 50, maskKey2, 0);
+    sink.write(data).close();
     assertData("80b2");
-    assertData(maskKey2);
-    assertData(part2);
+    assertData("3851d9d4");
+    assertData(""
+        + "58e5f96f00000000429a4ae98621e04fce98f47702a1c49b8f"
+        + "2130583b742dc906eb214c55f6cb1c139c948173a16c941b93");
   }
 
   @Test public void serverEmptyClose() throws IOException {
@@ -385,7 +386,10 @@
   }
 
   private void assertData(String hex) throws EOFException {
-    ByteString expected = ByteString.decodeHex(hex);
+    assertData(ByteString.decodeHex(hex));
+  }
+
+  private void assertData(ByteString expected) throws EOFException {
     ByteString actual = data.readByteString(expected.size());
     assertEquals(expected, actual);
   }
diff --git a/okhttp-tls/README.md b/okhttp-tls/README.md
new file mode 100644
index 0000000000..2ecaa5c3bf
--- /dev/null
+++ b/okhttp-tls/README.md
@@ -0,0 +1,246 @@
+OkHttp TLS
+==========
+
+Approachable APIs for using TLS.
+
+A [`HeldCertificate`][held_certificate] is a certificate and its private key. Use the
+[builder][held_certificate_builder] to create a self-signed certificate that a test server can use
+for HTTPS:
+
+```java
+String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
+HeldCertificate localhostCertificate = new HeldCertificate.Builder()
+    .addSubjectAlternativeName(localhost)
+    .build();
+```
+
+[`HandshakeCertificates`][handshake_certificates] keeps the certificates for a TLS handshake.
+Use its [builder][handshake_certificates_builder] to define which certificates the HTTPS server
+returns to its clients. The returned instance can create an `SSLSocketFactory` that implements this
+policy:
+
+```java
+HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+    .heldCertificate(localhostCertificate)
+    .build();
+MockWebServer server = new MockWebServer();
+server.useHttps(serverCertificates.sslSocketFactory(), false);
+```
+
+`HandshakeCertificates` also works for clients where its job is to define which root certificates
+to trust. In this simplified example we trust the server's self-signed certificate:
+
+```java
+HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+    .addTrustedCertificate(localhostCertificate.certificate())
+    .build();
+OkHttpClient client = new OkHttpClient.Builder()
+    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+    .build();
+```
+
+With a server that holds a certificate and a client that trusts it we have enough for an HTTPS
+handshake. The best part of this example is that we don't need to make our test code insecure with a
+a fake `HostnameVerifier` or `X509TrustManager`.
+
+Certificate Authorities
+-----------------------
+
+The above example uses a self-signed certificate. This is convenient for testing but not
+representative of real-world HTTPS deployment. To get closer to that we can use `HeldCertificate`
+to generate a trusted root certificate, an intermediate certificate, and a server certificate.
+We use `certificateAuthority(int)` to create certificates that can sign other certificates. The
+int specifies how many intermediate certificates are allowed beneath it in the chain.
+
+```java
+HeldCertificate rootCertificate = new HeldCertificate.Builder()
+    .certificateAuthority(1)
+    .build();
+
+HeldCertificate intermediateCertificate = new HeldCertificate.Builder()
+    .certificateAuthority(0)
+    .signedBy(rootCertificate)
+    .build();
+
+String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
+HeldCertificate serverCertificate = new HeldCertificate.Builder()
+    .addSubjectAlternativeName(localhost)
+    .signedBy(intermediateCertificate)
+    .build();
+```
+
+To serve this configuration the server needs to provide its clients with a chain of certificates
+starting with its own and including everything up-to but not including the root. We don't need to
+include root certificates because the client already has them.
+
+```java
+HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+    .heldCertificate(serverCertificate, intermediateCertificate.certificate())
+    .build();
+```
+
+The client only needs to know the trusted root certificate. It checks the server's certificate by
+validating the signatures within the chain.
+
+```java
+HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+    .addTrustedCertificate(rootCertificate.certificate())
+    .build();
+OkHttpClient client = new OkHttpClient.Builder()
+    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+    .build();
+```
+
+Client Authentication
+---------------------
+
+The above scenario is representative of most TLS set ups: the client uses certificates to validate
+the identity of a server. The converse is also possible. Here we create a server that authenticates
+a client and a client that authenticates a server.
+
+```java
+// Create the root for client and server to trust. We could also use different roots for each!
+HeldCertificate rootCertificate = new HeldCertificate.Builder()
+    .certificateAuthority(0)
+    .build();
+
+// Create a server certificate and a server that uses it.
+HeldCertificate serverCertificate = new HeldCertificate.Builder()
+    .commonName("ingen")
+    .addSubjectAlternativeName(server.getHostName())
+    .signedBy(rootCertificate)
+    .build();
+HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+    .addTrustedCertificate(rootCertificate.certificate())
+    .heldCertificate(serverCertificate)
+    .build();
+MockWebServer server = new MockWebServer();
+server.useHttps(serverCertificates.sslSocketFactory(), false);
+server.requestClientAuth();
+server.enqueue(new MockResponse());
+
+// Create a client certificate and a client that uses it.
+HeldCertificate clientCertificate = new HeldCertificate.Builder()
+    .commonName("ianmalcolm")
+    .signedBy(rootCertificate)
+    .build();
+HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+    .addTrustedCertificate(rootCertificate.certificate())
+    .heldCertificate(clientCertificate)
+    .build();
+OkHttpClient client = new OkHttpClient.Builder()
+    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+    .build();
+
+// Connect 'em all together. Certificates are exchanged in the handshake.
+Call call = client.newCall(new Request.Builder()
+    .url(server.url("/"))
+    .build());
+Response response = call.execute();
+System.out.println(response.handshake().peerPrincipal());
+RecordedRequest recordedRequest = server.takeRequest();
+System.out.println(recordedRequest.getHandshake().peerPrincipal());
+```
+
+This handshake is successful because each party has prearranged to trust the root certificate that
+signs the other party's chain.
+
+Well-Known Certificate Authorities
+----------------------------------
+
+In these examples we've prearranged which root certificates to trust. But for regular HTTPS on the
+Internet this set of trusted root certificates is usually provided by default by the host platform.
+Such a set typically includes many root certificates from well-known certificate authorities like
+Entrust and Verisign.
+
+This is the behavior you'll get with your OkHttpClient if you don't specifically configure
+`HandshakeCertificates`. Or you can do it explicitly with `addPlatformTrustedCertificates()`:
+
+```java
+HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+    .addPlatformTrustedCertificates()
+    .build();
+OkHttpClient client = new OkHttpClient.Builder()
+    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+    .build();
+```
+
+PEM files
+---------
+
+You can encode a `HeldCertificate` in PEM format:
+
+```java
+HeldCertificate heldCertificate = ...
+System.out.println(heldCertificate.certificatePem())
+```
+
+```
+-----BEGIN CERTIFICATE-----
+MIIBSjCB8aADAgECAgEBMAoGCCqGSM49BAMCMC8xLTArBgNVBAMTJDJiYWY3NzVl
+LWE4MzUtNDM5ZS1hYWE2LTgzNmNiNDlmMGM3MTAeFw0xODA3MTMxMjA0MzJaFw0x
+ODA3MTQxMjA0MzJaMC8xLTArBgNVBAMTJDJiYWY3NzVlLWE4MzUtNDM5ZS1hYWE2
+LTgzNmNiNDlmMGM3MTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDmlOiZ3dxA2
+zw1KwqGNsKVUZbkUVj5cxV1jDbSTvTlOjSj6LR0Ovys9RFdrjcbbMLWvSvMQgHch
+k8Q50c6Kb34wCgYIKoZIzj0EAwIDSAAwRQIhAJkXiCbIR3zxuH5SQR5PEAPJ+ntg
+msOSMaAKwAePESf+AiBlxbEu6YpHt1ZJoAhMAv6raYnwSp/A94eJGlJynQ0igQ==
+-----END CERTIFICATE-----
+```
+
+You can also do so with the private key. Be careful with these!
+
+```java
+HeldCertificate heldCertificate = ...
+System.out.println(heldCertificate.privateKeyPkcs8Pem())
+```
+
+```
+-----BEGIN PRIVATE KEY-----
+MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgQbYDQiewSnregm9e
+IjXEHQgc6w3ELHdnH1houEUom9CgCgYIKoZIzj0DAQehRANCAAQ5pTomd3cQNs8N
+SsKhjbClVGW5FFY+XMVdYw20k705To0o+i0dDr8rPURXa43G2zC1r0rzEIB3IZPE
+OdHOim9+
+-----END PRIVATE KEY-----
+```
+
+Recommendations
+---------------
+
+Typically servers need a held certificate plus a chain of intermediates. Servers only need the
+private key for their own certificate. The chain served by a server doesn't need the root
+certificate.
+
+The trusted roots don't need to be the same for client and server when using client authentication.
+Clients might rely on the platform certificates and servers might use a private
+organization-specific certificate authority.
+
+By default `HeldCertificate` instances expire after 24 hours. Use `duration()` to adjust.
+
+By default server certificates need to identify which hostnames they're trusted for. You may add as
+many as necessary with `addSubjectAlternativeName()`. This mechanism also supports a very limited
+form of wildcards `*.example.com` where the `*` must be first and doesn't match nested subdomains.
+
+By default certificates use fast and secure 256-bit ECDSA keys. For interoperability with very old
+clients use `HeldCertificate.Builder.rsa2048()`.
+
+Download
+--------
+
+Get via Maven:
+```xml
+<dependency>
+  <groupId>com.squareup.okhttp3</groupId>
+  <artifactId>okhttp-tls</artifactId>
+  <version>(insert latest version)</version>
+</dependency>
+```
+
+or via Gradle
+```groovy
+implementation 'com.squareup.okhttp3:okhttp-tls:(insert latest version)'
+```
+
+ [held_certificate]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HeldCertificate.html
+ [held_certificate_builder]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HeldCertificate.Builder.html
+ [handshake_certificates]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HandshakeCertificates.html
+ [handshake_certificates_builder]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HandshakeCertificates.Builder.html
diff --git a/okhttp-tls/pom.xml b/okhttp-tls/pom.xml
new file mode 100644
index 0000000000..dfdde62651
--- /dev/null
+++ b/okhttp-tls/pom.xml
@@ -0,0 +1,71 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.13.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-tls</artifactId>
+  <name>OkHttp Transport Layer Security (TLS)</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.bouncycastle</groupId>
+      <artifactId>bcprov-jdk15on</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
+        <configuration>
+          <excludePackageNames>okhttp3.tls.internal:okhttp3.tls.internal.*</excludePackageNames>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+          </links>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.tls</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java
new file mode 100644
index 0000000000..34e9e9a497
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls;
+
+import java.security.GeneralSecurityException;
+import java.security.KeyManagementException;
+import java.security.SecureRandom;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import javax.annotation.Nullable;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.CertificatePinner;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+
+import static okhttp3.tls.internal.TlsUtil.newKeyManager;
+import static okhttp3.tls.internal.TlsUtil.newTrustManager;
+
+/**
+ * Certificates to identify which peers to trust and also to earn the trust of those peers in kind.
+ * Client and server exchange these certificates during the handshake phase of a TLS connection.
+ *
+ * <h3>Server Authentication</h3>
+ *
+ * <p>This is the most common form of TLS authentication: clients verify that servers are trusted
+ * and that they own the hostnames that they represent. Server authentication is required.
+ *
+ * <p>To perform server authentication:
+ *
+ * <ul>
+ *   <li>The server's handshake certificates must have a {@linkplain HeldCertificate held
+ *       certificate} (a certificate and its private key). The certificate's subject alternative
+ *       names must match the server's hostname. The server must also have is a (possibly-empty)
+ *       chain of intermediate certificates to establish trust from a root certificate to the
+ *       server's certificate. The root certificate is not included in this chain.
+ *   <li>The client's handshake certificates must include a set of trusted root certificates. They
+ *       will be used to authenticate the server's certificate chain. Typically this is a set of
+ *       well-known root certificates that is distributed with the HTTP client or its platform. It
+ *       may be augmented by certificates private to an organization or service.
+ * </ul>
+ *
+ * <h3>Client Authentication</h3>
+ *
+ * <p>This is authentication of the client by the server during the TLS handshake. Client
+ * authentication is optional.
+ *
+ * <p>To perform client authentication:
+ *
+ * <ul>
+ *   <li>The client's handshake certificates must have a {@linkplain HeldCertificate held
+ *       certificate} (a certificate and its private key). The client must also have a
+ *       (possibly-empty) chain of intermediate certificates to establish trust from a root
+ *       certificate to the client's certificate. The root certificate is not included in this
+ *       chain.
+ *   <li>The server's handshake certificates must include a set of trusted root certificates. They
+ *       will be used to authenticate the client's certificate chain. Typically this is not the same
+ *       set of root certificates used in server authentication. Instead it will be a small set of
+ *       roots private to an organization or service.
+ * </ul>
+ */
+public final class HandshakeCertificates {
+  private final X509KeyManager keyManager;
+  private final X509TrustManager trustManager;
+
+  private HandshakeCertificates(X509KeyManager keyManager, X509TrustManager trustManager) {
+    this.keyManager = keyManager;
+    this.trustManager = trustManager;
+  }
+
+  public X509KeyManager keyManager() {
+    return keyManager;
+  }
+
+  public X509TrustManager trustManager() {
+    return trustManager;
+  }
+
+  public SSLSocketFactory sslSocketFactory() {
+    return sslContext().getSocketFactory();
+  }
+
+  public SSLContext sslContext() {
+    try {
+      SSLContext sslContext = Platform.get().getSSLContext();
+      sslContext.init(new KeyManager[] { keyManager }, new TrustManager[] { trustManager },
+          new SecureRandom());
+      return sslContext;
+    } catch (KeyManagementException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public static final class Builder {
+    private @Nullable HeldCertificate heldCertificate;
+    private @Nullable X509Certificate[] intermediates;
+
+    private final List<X509Certificate> trustedCertificates = new ArrayList<>();
+
+    /**
+     * Configure the certificate chain to use when being authenticated. The first certificate is
+     * the held certificate, further certificates are included in the handshake so the peer can
+     * build a trusted path to a trusted root certificate.
+     *
+     * <p>The chain should include all intermediate certificates but does not need the root
+     * certificate that we expect to be known by the remote peer. The peer already has that
+     * certificate so transmitting it is unnecessary.
+     */
+    public Builder heldCertificate(HeldCertificate heldCertificate,
+        X509Certificate... intermediates) {
+      this.heldCertificate = heldCertificate;
+      this.intermediates = intermediates.clone(); // Defensive copy.
+      return this;
+    }
+
+    /**
+     * Add a trusted root certificate to use when authenticating a peer. Peers must provide
+     * a chain of certificates whose root is one of these.
+     */
+    public Builder addTrustedCertificate(X509Certificate certificate) {
+      this.trustedCertificates.add(certificate);
+      return this;
+    }
+
+    /**
+     * Add all of the host platform's trusted root certificates. This set varies by platform
+     * (Android vs. Java), by platform release (Android 4.4 vs. Android 9), and with user
+     * customizations.
+     *
+     * <p>Most TLS clients that connect to hosts on the public Internet should call this method.
+     * Otherwise it is necessary to manually prepare a comprehensive set of trusted roots.
+     *
+     * <p>If the host platform is compromised or misconfigured this may contain untrustworthy root
+     * certificates. Applications that connect to a known set of servers may be able to mitigate
+     * this problem with {@linkplain CertificatePinner certificate pinning}.
+     */
+    public Builder addPlatformTrustedCertificates() {
+      X509TrustManager platformTrustManager = Util.platformTrustManager();
+      Collections.addAll(trustedCertificates, platformTrustManager.getAcceptedIssuers());
+      return this;
+    }
+
+    public HandshakeCertificates build() {
+      try {
+        X509KeyManager keyManager = newKeyManager(null, heldCertificate, intermediates);
+        X509TrustManager trustManager = newTrustManager(null, trustedCertificates);
+        return new HandshakeCertificates(keyManager, trustManager);
+      } catch (GeneralSecurityException gse) {
+        throw new AssertionError(gse);
+      }
+    }
+  }
+}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java
new file mode 100644
index 0000000000..8709dc1438
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java
@@ -0,0 +1,434 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls;
+
+import java.io.IOException;
+import java.math.BigInteger;
+import java.security.GeneralSecurityException;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.PrivateKey;
+import java.security.PublicKey;
+import java.security.SecureRandom;
+import java.security.Security;
+import java.security.cert.CertificateEncodingException;
+import java.security.cert.X509Certificate;
+import java.security.interfaces.RSAPrivateKey;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import javax.security.auth.x500.X500Principal;
+import okio.ByteString;
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
+import org.bouncycastle.asn1.x509.BasicConstraints;
+import org.bouncycastle.asn1.x509.GeneralName;
+import org.bouncycastle.asn1.x509.X509Extensions;
+import org.bouncycastle.jce.provider.BouncyCastleProvider;
+import org.bouncycastle.x509.X509V3CertificateGenerator;
+
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
+/**
+ * A certificate and its private key. These are some properties of certificates that are used with
+ * TLS:
+ *
+ * <ul>
+ *   <li><strong>A common name.</strong> This is a string identifier for the certificate. It usually
+ *       describes the purpose of the certificate like "Entrust Root Certification Authority - G2"
+ *       or "www.squareup.com".
+ *   <li><strong>A set of hostnames.</strong> These are in the certificate's subject alternative
+ *       name (SAN) extension. A subject alternative name is either a literal hostname ({@code
+ *       squareup.com}), a literal IP address ({@code 74.122.190.80}), or a hostname pattern ({@code
+ *       *.api.squareup.com}).
+ *   <li><strong>A validity interval.</strong> A certificate should not be used before its validity
+ *       interval starts or after it ends.
+ *   <li><strong>A public key.</strong> This cryptographic key is used for asymmetric encryption
+ *       digital signatures. Note that the private key is not a part of the certificate!
+ *   <li><strong>A signature issued by another certificate's private key.</strong> This mechanism
+ *       allows a trusted third-party to endorse a certificate. Third parties should only endorse
+ *       certificates once they've confirmed that the owner of the private key is also the owner of
+ *       the certificate's other properties.
+ * </ul>
+ *
+ * <p>Certificates are signed by other certificates and a sequence of them is called a certificate
+ * chain. The chain terminates in a self-signed "root" certificate. Signing certificates in the
+ * middle of the chain are called "intermediates". Organizations that offer certificate signing are
+ * called certificate authorities (CAs).
+ *
+ * <p>Browsers and other HTTP clients need a set of trusted root certificates to authenticate their
+ * peers. Sets of root certificates are managed by either the HTTP client (like Firefox), or the
+ * host platform (like Android). In July 2018 Android had 134 trusted root certificates for its HTTP
+ * clients to trust.
+ *
+ * <p>For example, in order to establish a secure connection to {@code https://www.squareup.com/},
+ * these three certificates are used. <pre>{@code
+ *
+ * www.squareup.com certificate:
+ *
+ *   Common Name: www.squareup.com
+ *   Subject Alternative Names: www.squareup.com, squareup.com, account.squareup.com...
+ *   Validity: 2018-07-03T20:18:17Z – 2019-08-01T20:48:15Z
+ *   Public Key: d107beecc17325f55da976bcbab207ba4df68bd3f8fce7c3b5850311128264fd53e1baa342f58d93...
+ *   Signature: 1fb0e66fac05322721fe3a3917f7c98dee1729af39c99eab415f22d8347b508acdf0bab91781c3720...
+ *
+ * signed by intermediate certificate:
+ *
+ *   Common Name: Entrust Certification Authority - L1M
+ *   Subject Alternative Names: none
+ *   Validity: 2014-12-15T15:25:03Z – 2030-10-15T15:55:03Z
+ *   Public Key: d081c13923c2b1d1ecf757dd55243691202248f7fcca520ab0ab3f33b5b08407f6df4e7ab0fb9822...
+ *   Signature: b487c784221a29c0a478ecf54f1bb484976f77eed4cf59afa843962f1d58dea6f3155b2ed9439c4c4...
+ *
+ * signed by root certificate:
+ *
+ *   Common Name: Entrust Root Certification Authority - G2
+ *   Subject Alternative Names: none
+ *   Validity: 2009-07-07T17:25:54Z – 2030-12-07T17:55:54Z
+ *   Public Key: ba84b672db9e0c6be299e93001a776ea32b895411ac9da614e5872cffef68279bf7361060aa527d8...
+ *   Self-signed Signature: 799f1d96c6b6793f228d87d3870304606a6b9a2e59897311ac43d1f513ff8d392bc0f...
+ *
+ * }</pre>
+ *
+ * <p>In this example the HTTP client already knows and trusts the last certificate, "Entrust Root
+ * Certification Authority - G2". That certificate is used to verify the signature of the
+ * intermediate certificate, "Entrust Certification Authority - L1M". The intermediate certificate
+ * is used to verify the signature of the "www.squareup.com" certificate.
+ *
+ * <p>This roles are reversed for client authentication. In that case the client has a private key
+ * and a chain of certificates. The server uses a set of trusted root certificates to authenticate
+ * the client. Subject alternative names are not used for client authentication.
+ */
+public final class HeldCertificate {
+  private final X509Certificate certificate;
+  private final KeyPair keyPair;
+
+  public HeldCertificate(KeyPair keyPair, X509Certificate certificate) {
+    if (keyPair == null) throw new NullPointerException("keyPair == null");
+    if (certificate == null) throw new NullPointerException("certificate == null");
+    this.certificate = certificate;
+    this.keyPair = keyPair;
+  }
+
+  public X509Certificate certificate() {
+    return certificate;
+  }
+
+  public KeyPair keyPair() {
+    return keyPair;
+  }
+
+  /**
+   * Returns the certificate encoded in <a href="https://tools.ietf.org/html/rfc7468">PEM
+   * format</a>.
+   */
+  public String certificatePem() {
+    try {
+      StringBuilder result = new StringBuilder();
+      result.append("-----BEGIN CERTIFICATE-----\n");
+      encodeBase64Lines(result, ByteString.of(certificate.getEncoded()));
+      result.append("-----END CERTIFICATE-----\n");
+      return result.toString();
+    } catch (CertificateEncodingException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  /**
+   * Returns the RSA private key encoded in <a href="https://tools.ietf.org/html/rfc5208">PKCS
+   * #8</a> <a href="https://tools.ietf.org/html/rfc7468">PEM format</a>.
+   */
+  public String privateKeyPkcs8Pem() {
+    StringBuilder result = new StringBuilder();
+    result.append("-----BEGIN PRIVATE KEY-----\n");
+    encodeBase64Lines(result, ByteString.of(keyPair.getPrivate().getEncoded()));
+    result.append("-----END PRIVATE KEY-----\n");
+    return result.toString();
+  }
+
+  /**
+   * Returns the RSA private key encoded in <a href="https://tools.ietf.org/html/rfc8017">PKCS
+   * #1</a> <a href="https://tools.ietf.org/html/rfc7468">PEM format</a>.
+   */
+  public String privateKeyPkcs1Pem() {
+    if (!(keyPair.getPrivate() instanceof RSAPrivateKey)) {
+      throw new IllegalStateException("PKCS1 only supports RSA keys");
+    }
+    StringBuilder result = new StringBuilder();
+    result.append("-----BEGIN RSA PRIVATE KEY-----\n");
+    encodeBase64Lines(result, pkcs1Bytes());
+    result.append("-----END RSA PRIVATE KEY-----\n");
+    return result.toString();
+  }
+
+  private ByteString pkcs1Bytes() {
+    try {
+      PrivateKeyInfo privateKeyInfo = PrivateKeyInfo.getInstance(keyPair.getPrivate().getEncoded());
+      return ByteString.of(privateKeyInfo.parsePrivateKey().toASN1Primitive().getEncoded());
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  private void encodeBase64Lines(StringBuilder out, ByteString data) {
+    String base64 = data.base64();
+    for (int i = 0; i < base64.length(); i += 64) {
+      out.append(base64, i, Math.min(i + 64, base64.length())).append('\n');
+    }
+  }
+
+  /** Build a held certificate with reasonable defaults. */
+  public static final class Builder {
+    private static final long DEFAULT_DURATION_MILLIS = 1000L * 60 * 60 * 24; // 24 hours.
+
+    static {
+      Security.addProvider(new BouncyCastleProvider());
+    }
+
+    private long notBefore = -1L;
+    private long notAfter = -1L;
+    private @Nullable String cn;
+    private @Nullable String ou;
+    private final List<String> altNames = new ArrayList<>();
+    private @Nullable BigInteger serialNumber;
+    private @Nullable KeyPair keyPair;
+    private @Nullable HeldCertificate signedBy;
+    private int maxIntermediateCas = -1;
+    private @Nullable String keyAlgorithm;
+    private int keySize;
+
+    public Builder() {
+      ecdsa256();
+    }
+
+    /**
+     * Sets the certificate to be valid in {@code [notBefore..notAfter]}. Both endpoints are
+     * specified in the format of {@link System#currentTimeMillis()}. Specify -1L for both values
+     * to use the default interval, 24 hours starting when the certificate is created.
+     */
+    public Builder validityInterval(long notBefore, long notAfter) {
+      if (notBefore > notAfter || (notBefore == -1L) != (notAfter == -1L)) {
+        throw new IllegalArgumentException("invalid interval: " + notBefore + ".." + notAfter);
+      }
+      this.notBefore = notBefore;
+      this.notAfter = notAfter;
+      return this;
+    }
+
+    /**
+     * Sets the certificate to be valid immediately and until the specified duration has elapsed.
+     * The precision of this field is seconds; further precision will be truncated.
+     */
+    public Builder duration(long duration, TimeUnit unit) {
+      long now = System.currentTimeMillis();
+      return validityInterval(now, now + unit.toMillis(duration));
+    }
+
+    /**
+     * Adds a subject alternative name (SAN) to the certificate. This is usually a literal hostname,
+     * a literal IP address, or a hostname pattern. If no subject alternative names are added that
+     * extension will be omitted.
+     */
+    public Builder addSubjectAlternativeName(String altName) {
+      if (altName == null) throw new NullPointerException("altName == null");
+      altNames.add(altName);
+      return this;
+    }
+
+    /**
+     * Set this certificate's common name (CN). Historically this held the hostname of TLS
+     * certificate, but that practice was deprecated by <a
+     * href="https://tools.ietf.org/html/rfc2818">RFC 2818</a> and replaced with {@link
+     * #addSubjectAlternativeName(String) subject alternative names}. If unset a random string will
+     * be used.
+     */
+    public Builder commonName(String cn) {
+      this.cn = cn;
+      return this;
+    }
+
+    /** Sets the certificate's organizational unit (OU). If unset this field will be omitted. */
+    public Builder organizationalUnit(String ou) {
+      this.ou = ou;
+      return this;
+    }
+
+    /** Sets this certificate's serial number. If unset the serial number will be 1. */
+    public Builder serialNumber(BigInteger serialNumber) {
+      this.serialNumber = serialNumber;
+      return this;
+    }
+
+    /** Sets this certificate's serial number. If unset the serial number will be 1. */
+    public Builder serialNumber(long serialNumber) {
+      return serialNumber(BigInteger.valueOf(serialNumber));
+    }
+
+    /**
+     * Sets the public/private key pair used for this certificate. If unset a key pair will be
+     * generated.
+     */
+    public Builder keyPair(KeyPair keyPair) {
+      this.keyPair = keyPair;
+      return this;
+    }
+
+    /**
+     * Sets the public/private key pair used for this certificate. If unset a key pair will be
+     * generated.
+     */
+    public Builder keyPair(PublicKey publicKey, PrivateKey privateKey) {
+      return keyPair(new KeyPair(publicKey, privateKey));
+    }
+
+    /**
+     * Set the certificate that will issue this certificate. If unset the certificate will be
+     * self-signed.
+     */
+    public Builder signedBy(HeldCertificate signedBy) {
+      this.signedBy = signedBy;
+      return this;
+    }
+
+    /**
+     * Set this certificate to be a signing certificate, with up to {@code maxIntermediateCas}
+     * intermediate signing certificates beneath it.
+     *
+     * <p>By default this certificate cannot not sign other certificates. Set this to 0 so this
+     * certificate can sign other certificates (but those certificates cannot themselves sign
+     * certificates). Set this to 1 so this certificate can sign intermediate certificates that can
+     * themselves sign certificates. Add one for each additional layer of intermediates to permit.
+     */
+    public Builder certificateAuthority(int maxIntermediateCas) {
+      if (maxIntermediateCas < 0) {
+        throw new IllegalArgumentException("maxIntermediateCas < 0: " + maxIntermediateCas);
+      }
+      this.maxIntermediateCas = maxIntermediateCas;
+      return this;
+    }
+
+    /**
+     * Configure the certificate to generate a 256-bit ECDSA key, which provides about 128 bits of
+     * security. ECDSA keys are noticeably faster than RSA keys.
+     *
+     * <p>This is the default configuration and has been since this API was introduced in OkHttp
+     * 3.11.0. Note that the default may change in future releases.
+     */
+    public Builder ecdsa256() {
+      keyAlgorithm = "EC";
+      keySize = 256;
+      return this;
+    }
+
+    /**
+     * Configure the certificate to generate a 2048-bit RSA key, which provides about 112 bits of
+     * security. RSA keys are interoperable with very old clients that don't support ECDSA.
+     */
+    public Builder rsa2048() {
+      keyAlgorithm = "RSA";
+      keySize = 2048;
+      return this;
+    }
+
+    public HeldCertificate build() {
+      // Subject, public & private keys for this certificate.
+      KeyPair heldKeyPair = keyPair != null
+          ? keyPair
+          : generateKeyPair();
+
+      X500Principal subject = buildSubject();
+
+      // Subject, public & private keys for this certificate's signer. It may be self signed!
+      KeyPair signedByKeyPair;
+      X500Principal signedByPrincipal;
+      if (signedBy != null) {
+        signedByKeyPair = signedBy.keyPair;
+        signedByPrincipal = signedBy.certificate.getSubjectX500Principal();
+      } else {
+        signedByKeyPair = heldKeyPair;
+        signedByPrincipal = subject;
+      }
+
+      // Generate & sign the certificate.
+      long notBefore = this.notBefore != -1L ? this.notBefore : System.currentTimeMillis();
+      long notAfter = this.notAfter != -1L ? this.notAfter : notBefore + DEFAULT_DURATION_MILLIS;
+      BigInteger serialNumber = this.serialNumber != null ? this.serialNumber : BigInteger.ONE;
+      X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
+      generator.setSerialNumber(serialNumber);
+      generator.setIssuerDN(signedByPrincipal);
+      generator.setNotBefore(new Date(notBefore));
+      generator.setNotAfter(new Date(notAfter));
+      generator.setSubjectDN(subject);
+      generator.setPublicKey(heldKeyPair.getPublic());
+      generator.setSignatureAlgorithm(signedByKeyPair.getPrivate() instanceof RSAPrivateKey
+          ? "SHA256WithRSAEncryption"
+          : "SHA256withECDSA");
+
+      if (maxIntermediateCas != -1) {
+        generator.addExtension(X509Extensions.BasicConstraints, true,
+            new BasicConstraints(maxIntermediateCas));
+      }
+
+      if (!altNames.isEmpty()) {
+        ASN1Encodable[] encodableAltNames = new ASN1Encodable[altNames.size()];
+        for (int i = 0, size = altNames.size(); i < size; i++) {
+          String altName = altNames.get(i);
+          int tag = verifyAsIpAddress(altName)
+              ? GeneralName.iPAddress
+              : GeneralName.dNSName;
+          encodableAltNames[i] = new GeneralName(tag, altName);
+        }
+        generator.addExtension(X509Extensions.SubjectAlternativeName, true,
+            new DERSequence(encodableAltNames));
+      }
+
+      try {
+        X509Certificate certificate = generator.generateX509Certificate(
+            signedByKeyPair.getPrivate());
+        return new HeldCertificate(heldKeyPair, certificate);
+      } catch (GeneralSecurityException e) {
+        throw new AssertionError(e);
+      }
+    }
+
+    private X500Principal buildSubject() {
+      StringBuilder nameBuilder = new StringBuilder();
+      if (cn != null) {
+        nameBuilder.append("CN=").append(cn);
+      } else {
+        nameBuilder.append("CN=").append(UUID.randomUUID());
+      }
+      if (ou != null) {
+        nameBuilder.append(", OU=").append(ou);
+      }
+      return new X500Principal(nameBuilder.toString());
+    }
+
+    private KeyPair generateKeyPair() {
+      try {
+        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyAlgorithm);
+        keyPairGenerator.initialize(keySize, new SecureRandom());
+        return keyPairGenerator.generateKeyPair();
+      } catch (GeneralSecurityException e) {
+        throw new AssertionError(e);
+      }
+    }
+  }
+}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java b/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java
new file mode 100644
index 0000000000..b127b36861
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls.internal;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import java.util.List;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.tls.HeldCertificate;
+import okhttp3.tls.HandshakeCertificates;
+
+public final class TlsUtil {
+  public static final char[] password = "password".toCharArray();
+  private static HandshakeCertificates localhost; // Lazily initialized.
+
+  private TlsUtil() {
+  }
+
+  /** Returns an SSL client for this host's localhost address. */
+  public static synchronized HandshakeCertificates localhost() {
+    if (localhost != null) return localhost;
+
+    try {
+      // Generate a self-signed cert for the server to serve and the client to trust.
+      HeldCertificate heldCertificate = new HeldCertificate.Builder()
+          .commonName("localhost")
+          .addSubjectAlternativeName(InetAddress.getByName("localhost").getCanonicalHostName())
+          .build();
+
+      localhost = new HandshakeCertificates.Builder()
+          .heldCertificate(heldCertificate)
+          .addTrustedCertificate(heldCertificate.certificate())
+          .build();
+
+      return localhost;
+    } catch (UnknownHostException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  /** Returns a trust manager that trusts {@code trustedCertificates}. */
+  public static X509TrustManager newTrustManager(String keyStoreType,
+      List<X509Certificate> trustedCertificates) throws GeneralSecurityException {
+    KeyStore trustStore = newEmptyKeyStore(keyStoreType);
+    for (int i = 0; i < trustedCertificates.size(); i++) {
+      trustStore.setCertificateEntry("cert_" + i, trustedCertificates.get(i));
+    }
+    TrustManagerFactory factory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    factory.init(trustStore);
+    TrustManager[] result = factory.getTrustManagers();
+    if (result.length != 1 || !(result[0] instanceof X509TrustManager)) {
+      throw new IllegalStateException("Unexpected trust managers:" + Arrays.toString(result));
+    }
+    return (X509TrustManager) result[0];
+  }
+
+  /**
+   * Returns a key manager for the held certificate and its chain. Returns an empty key manager if
+   * {@code heldCertificate} is null.
+   */
+  public static X509KeyManager newKeyManager(String keyStoreType, HeldCertificate heldCertificate,
+      X509Certificate... intermediates) throws GeneralSecurityException {
+    KeyStore keyStore = newEmptyKeyStore(keyStoreType);
+
+    if (heldCertificate != null) {
+      Certificate[] chain = new Certificate[1 + intermediates.length];
+      chain[0] = heldCertificate.certificate();
+      System.arraycopy(intermediates, 0, chain, 1, intermediates.length);
+      keyStore.setKeyEntry("private", heldCertificate.keyPair().getPrivate(), password, chain);
+    }
+
+    KeyManagerFactory factory = KeyManagerFactory.getInstance(
+        KeyManagerFactory.getDefaultAlgorithm());
+    factory.init(keyStore, password);
+    KeyManager[] result = factory.getKeyManagers();
+    if (result.length != 1 || !(result[0] instanceof X509KeyManager)) {
+      throw new IllegalStateException("Unexpected key managers:" + Arrays.toString(result));
+    }
+    return (X509KeyManager) result[0];
+  }
+
+  private static KeyStore newEmptyKeyStore(String keyStoreType) throws GeneralSecurityException {
+    if (keyStoreType == null) {
+      keyStoreType = KeyStore.getDefaultType();
+    }
+
+    try {
+      KeyStore keyStore = KeyStore.getInstance(keyStoreType);
+      InputStream in = null; // By convention, 'null' creates an empty key store.
+      keyStore.load(in, password);
+      return keyStore;
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
+}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/package-info.java b/okhttp-tls/src/main/java/okhttp3/tls/package-info.java
new file mode 100644
index 0000000000..061e524be6
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/package-info.java
@@ -0,0 +1,3 @@
+/** OkHttp Transport Layer Security (TLS) library. */
+@okhttp3.internal.annotations.EverythingIsNonNull
+package okhttp3.tls;
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
new file mode 100644
index 0000000000..c2e4f3a45f
--- /dev/null
+++ b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
@@ -0,0 +1,198 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.security.PrivateKey;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import javax.net.ssl.SSLSocket;
+import okhttp3.Handshake;
+import okhttp3.internal.Util;
+import okio.ByteString;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+public final class HandshakeCertificatesTest {
+  private ExecutorService executorService;
+  private ServerSocket serverSocket;
+
+  @Before public void setUp() {
+    executorService = Executors.newCachedThreadPool();
+  }
+
+  @After public void tearDown() {
+    executorService.shutdown();
+    Util.closeQuietly(serverSocket);
+  }
+
+  @Test public void clientAndServer() throws Exception {
+    HeldCertificate clientRoot = new HeldCertificate.Builder()
+        .certificateAuthority(1)
+        .build();
+    HeldCertificate clientIntermediate = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .signedBy(clientRoot)
+        .build();
+    HeldCertificate clientCertificate = new HeldCertificate.Builder()
+        .signedBy(clientIntermediate)
+        .build();
+
+    HeldCertificate serverRoot = new HeldCertificate.Builder()
+        .certificateAuthority(1)
+        .build();
+    HeldCertificate serverIntermediate = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .signedBy(serverRoot)
+        .build();
+    HeldCertificate serverCertificate = new HeldCertificate.Builder()
+        .signedBy(serverIntermediate)
+        .build();
+
+    HandshakeCertificates server = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(clientRoot.certificate())
+        .heldCertificate(serverCertificate, serverIntermediate.certificate())
+        .build();
+
+    HandshakeCertificates client = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(serverRoot.certificate())
+        .heldCertificate(clientCertificate, clientIntermediate.certificate())
+        .build();
+
+    InetSocketAddress serverAddress = startTlsServer();
+    Future<Handshake> serverHandshakeFuture = doServerHandshake(server);
+    Future<Handshake> clientHandshakeFuture = doClientHandshake(client, serverAddress);
+
+    Handshake serverHandshake = serverHandshakeFuture.get();
+    assertEquals(serverHandshake.peerCertificates(),
+        Arrays.asList(clientCertificate.certificate(), clientIntermediate.certificate()));
+    assertEquals(serverHandshake.localCertificates(),
+        Arrays.asList(serverCertificate.certificate(), serverIntermediate.certificate()));
+
+    Handshake clientHandshake = clientHandshakeFuture.get();
+    assertEquals(clientHandshake.peerCertificates(),
+        Arrays.asList(serverCertificate.certificate(), serverIntermediate.certificate()));
+    assertEquals(clientHandshake.localCertificates(),
+        Arrays.asList(clientCertificate.certificate(), clientIntermediate.certificate()));
+
+  }
+
+  @Test public void keyManager() {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .certificateAuthority(1)
+        .build();
+    HeldCertificate intermediate = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .signedBy(root)
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .signedBy(intermediate)
+        .build();
+
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(certificate, intermediate.certificate())
+        .build();
+    assertPrivateKeysEquals(certificate.keyPair().getPrivate(),
+        handshakeCertificates.keyManager().getPrivateKey("private"));
+    assertEquals(Arrays.asList(certificate.certificate(), intermediate.certificate()),
+        Arrays.asList(handshakeCertificates.keyManager().getCertificateChain("private")));
+  }
+
+  @Test public void platformTrustedCertificates() {
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addPlatformTrustedCertificates()
+        .build();
+    Set<String> names = new LinkedHashSet<>();
+    for (X509Certificate certificate : handshakeCertificates.trustManager().getAcceptedIssuers()) {
+      // Abbreviate a long name like "CN=Entrust Root Certification Authority - G2, OU=..."
+      String name = certificate.getSubjectDN().getName();
+      names.add(name.substring(0, name.indexOf(" ")));
+    }
+    // It's safe to assume all platforms will have a major Internet certificate issuer.
+    assertTrue(names.toString(), names.contains("CN=Entrust"));
+  }
+
+  private InetSocketAddress startTlsServer() throws IOException {
+    ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
+    serverSocket = serverSocketFactory.createServerSocket();
+    InetAddress serverAddress = InetAddress.getByName("localhost");
+    serverSocket.bind(new InetSocketAddress(serverAddress, 0), 50);
+    return new InetSocketAddress(serverAddress, serverSocket.getLocalPort());
+  }
+
+  private Future<Handshake> doServerHandshake(final HandshakeCertificates server) {
+    return executorService.submit(new Callable<Handshake>() {
+      @Override public Handshake call() throws Exception {
+        Socket rawSocket = null;
+        SSLSocket sslSocket = null;
+        try {
+          rawSocket = serverSocket.accept();
+          sslSocket = (SSLSocket) server.sslSocketFactory().createSocket(rawSocket,
+              rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(),
+              true /* autoClose */);
+          sslSocket.setUseClientMode(false);
+          sslSocket.setWantClientAuth(true);
+          sslSocket.startHandshake();
+          return Handshake.get(sslSocket.getSession());
+        } finally {
+          Util.closeQuietly(rawSocket);
+          Util.closeQuietly(sslSocket);
+        }
+      }
+    });
+  }
+
+  private Future<Handshake> doClientHandshake(
+      final HandshakeCertificates client, final InetSocketAddress serverAddress) {
+    return executorService.submit(new Callable<Handshake>() {
+      @Override public Handshake call() throws Exception {
+        Socket rawSocket = SocketFactory.getDefault().createSocket();
+        rawSocket.connect(serverAddress);
+        SSLSocket sslSocket = null;
+        try {
+          sslSocket = (SSLSocket) client.sslSocketFactory().createSocket(rawSocket,
+              rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(),
+              true /* autoClose */);
+          sslSocket.startHandshake();
+          return Handshake.get(sslSocket.getSession());
+        } finally {
+          Util.closeQuietly(rawSocket);
+          Util.closeQuietly(sslSocket);
+        }
+      }
+    });
+  }
+
+  private void assertPrivateKeysEquals(PrivateKey expected, PrivateKey actual) {
+    assertEquals(ByteString.of(expected.getEncoded()), ByteString.of(actual.getEncoded()));
+  }
+}
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
new file mode 100644
index 0000000000..ffec150f32
--- /dev/null
+++ b/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls;
+
+import java.math.BigInteger;
+import java.security.KeyFactory;
+import java.security.PrivateKey;
+import java.security.PublicKey;
+import java.security.cert.CertificateParsingException;
+import java.security.cert.X509Certificate;
+import java.security.spec.PKCS8EncodedKeySpec;
+import java.security.spec.X509EncodedKeySpec;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import okio.ByteString;
+import org.bouncycastle.asn1.x509.GeneralName;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+public final class HeldCertificateTest {
+  @Test public void defaultCertificate() throws CertificateParsingException {
+    long now = System.currentTimeMillis();
+    HeldCertificate heldCertificate = new HeldCertificate.Builder().build();
+
+    X509Certificate certificate = heldCertificate.certificate();
+    assertEquals("self-signed",
+        certificate.getIssuerX500Principal().getName(),
+        certificate.getSubjectX500Principal().getName());
+    assertTrue(certificate.getIssuerX500Principal().getName().matches("CN=[0-9a-f-]{36}"));
+    assertEquals(BigInteger.ONE, certificate.getSerialNumber());
+    assertNull(certificate.getSubjectAlternativeNames());
+
+    double deltaMillis = 1000.0;
+    long durationMillis = TimeUnit.MINUTES.toMillis(60 * 24);
+    assertEquals((double) now, certificate.getNotBefore().getTime(), deltaMillis);
+    assertEquals((double) now + durationMillis, certificate.getNotAfter().getTime(), deltaMillis);
+  }
+
+  @Test public void customInterval() {
+    // 5 seconds starting on 1970-01-01.
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .validityInterval(5_000L, 10_000L)
+        .build();
+    X509Certificate certificate = heldCertificate.certificate();
+    assertEquals(5_000L, certificate.getNotBefore().getTime());
+    assertEquals(10_000L, certificate.getNotAfter().getTime());
+  }
+
+  @Test public void customDuration() {
+    long now = System.currentTimeMillis();
+
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .duration(5, TimeUnit.SECONDS)
+        .build();
+    X509Certificate certificate = heldCertificate.certificate();
+
+    double deltaMillis = 1000.0;
+    long durationMillis = 5_000L;
+    assertEquals((double) now, certificate.getNotBefore().getTime(), deltaMillis);
+    assertEquals((double) now + durationMillis, certificate.getNotAfter().getTime(), deltaMillis);
+  }
+
+  @Test public void subjectAlternativeNames() throws CertificateParsingException {
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .addSubjectAlternativeName("1.1.1.1")
+        .addSubjectAlternativeName("cash.app")
+        .build();
+
+    X509Certificate certificate = heldCertificate.certificate();
+    List<List<?>> subjectAlternativeNames = new ArrayList<>(
+        certificate.getSubjectAlternativeNames());
+    assertEquals(subjectAlternativeNames, Arrays.asList(
+        Arrays.asList(GeneralName.iPAddress, "1.1.1.1"),
+        Arrays.asList(GeneralName.dNSName, "cash.app")));
+  }
+
+  @Test public void commonName() {
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .commonName("cash.app")
+        .build();
+
+    X509Certificate certificate = heldCertificate.certificate();
+    assertEquals("CN=cash.app", certificate.getSubjectX500Principal().getName());
+  }
+
+  @Test public void organizationalUnit() {
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .commonName("cash.app")
+        .organizationalUnit("cash")
+        .build();
+
+    X509Certificate certificate = heldCertificate.certificate();
+    assertEquals("CN=cash.app,OU=cash", certificate.getSubjectX500Principal().getName());
+  }
+
+  /** Confirm golden values of encoded PEMs. */
+  @Test public void pems() throws Exception {
+    KeyFactory keyFactory = KeyFactory.getInstance("RSA");
+
+    ByteString publicKeyBytes = ByteString.decodeBase64("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCApF"
+        + "HhtrLan28q+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1wJ4YEoUCjDlPOtpht7XLbUmBnbIzN89XK4UJVM6Sqp3"
+        + "K88Km8z7gMrdrfTom/274wL25fICR+yDEQ5fUVYBmJAKXZF1aoI0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQAB");
+    PublicKey publicKey = keyFactory.generatePublic(
+        new X509EncodedKeySpec(publicKeyBytes.toByteArray()));
+
+    ByteString privateKeyBytes = ByteString.decodeBase64("MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbA"
+        + "gEAAoGBAICkUeG2stqfbyr6gyiVm5pN9YEDRXlowi+rfYGyWhC7ouW9fXAnhgShQKMOU862mG3tcttSYGdsjM3z1"
+        + "crhQlUzpKqncrzwqbzPuAyt2t9Oib/bvjAvbl8gJH7IMRDl9RVgGYkApdkXVqgjSYigTHTEWxCEgnrfu/YzEkO6l"
+        + "3rXAgMBAAECgYB99mhnB6piADOuddXv626NzUBTr4xbsYRTgSxHzwf50oFTTBSDuW+1IOBVyTWu94SSPyt0LllPb"
+        + "C8Di3sQSTnVGpSqAvEXknBMzIc0UO74Rn9p3gZjEenPt1l77fIBa2nK06/rdsJCoE/1P1JSfM9w7LU1RsTmseYML"
+        + "eJl5F79gQJBAO/BbAKqg1yzK7VijygvBoUrr+rt2lbmKgcUQ/rxu8IIQk0M/xgJqSkXDXuOnboGM7sQSKfJAZUtT"
+        + "7xozvLzV7ECQQCJW59w7NIM0qZ/gIX2gcNZr1B/V3zcGlolTDciRm+fnKGNt2EEDKnVL3swzbEfTCa48IT0QKgZJ"
+        + "qpXZERa26UHAkBLXmiP5f5pk8F3wcXzAeVw06z3k1IB41Tu6MX+CyPU+TeudRlz+wV8b0zDvK+EnRKCCbptVFj1B"
+        + "kt8lQ4JfcnhAkAk2Y3Gz+HySrkcT7Cg12M/NkdUQnZe3jr88pt/+IGNwomc6Wt/mJ4fcWONTkGMcfOZff1NQeNXD"
+        + "AZ6941XCsIVAkASOg02PlVHLidU7mIE65swMM5/RNhS4aFjez/MwxFNOHaxc9VgCwYPXCLOtdf7AVovdyG0XWgbU"
+        + "XH+NyxKwboE");
+    PrivateKey privateKey = keyFactory.generatePrivate(
+        new PKCS8EncodedKeySpec(privateKeyBytes.toByteArray()));
+
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .keyPair(publicKey, privateKey)
+        .commonName("cash.app")
+        .validityInterval(0L, 1_000L)
+        .rsa2048()
+        .build();
+
+    assertEquals(heldCertificate.certificatePem(), ""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIBmjCCAQOgAwIBAgIBATANBgkqhkiG9w0BAQsFADATMREwDwYDVQQDEwhjYXNo\n"
+        + "LmFwcDAeFw03MDAxMDEwMDAwMDBaFw03MDAxMDEwMDAwMDFaMBMxETAPBgNVBAMT\n"
+        + "CGNhc2guYXBwMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCApFHhtrLan28q\n"
+        + "+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1wJ4YEoUCjDlPOtpht7XLbUmBnbIzN\n"
+        + "89XK4UJVM6Sqp3K88Km8z7gMrdrfTom/274wL25fICR+yDEQ5fUVYBmJAKXZF1ao\n"
+        + "I0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQABMA0GCSqGSIb3DQEBCwUAA4GBADam\n"
+        + "UVwKh5Ry7es3OxtY3IgQunPUoLc0Gw71gl9Z+7t2FJ5VkcI5gWfutmdxZ2bDXCI8\n"
+        + "8V0vxo1pHXnbBrnxhS/Z3TBerw8RyQqcaWOdp+pBXyIWmR+jHk9cHZCqQveTIBsY\n"
+        + "jaA9VEhgdaVhxBsT2qzUNDsXlOzGsliznDfoqETb\n"
+        + "-----END CERTIFICATE-----\n");
+
+    assertEquals(heldCertificate.privateKeyPkcs1Pem(), ""
+        + "-----BEGIN RSA PRIVATE KEY-----\n"
+        + "MIICWwIBAAKBgQCApFHhtrLan28q+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1w\n"
+        + "J4YEoUCjDlPOtpht7XLbUmBnbIzN89XK4UJVM6Sqp3K88Km8z7gMrdrfTom/274w\n"
+        + "L25fICR+yDEQ5fUVYBmJAKXZF1aoI0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQAB\n"
+        + "AoGAffZoZweqYgAzrnXV7+tujc1AU6+MW7GEU4EsR88H+dKBU0wUg7lvtSDgVck1\n"
+        + "rveEkj8rdC5ZT2wvA4t7EEk51RqUqgLxF5JwTMyHNFDu+EZ/ad4GYxHpz7dZe+3y\n"
+        + "AWtpytOv63bCQqBP9T9SUnzPcOy1NUbE5rHmDC3iZeRe/YECQQDvwWwCqoNcsyu1\n"
+        + "Yo8oLwaFK6/q7dpW5ioHFEP68bvCCEJNDP8YCakpFw17jp26BjO7EEinyQGVLU+8\n"
+        + "aM7y81exAkEAiVufcOzSDNKmf4CF9oHDWa9Qf1d83BpaJUw3IkZvn5yhjbdhBAyp\n"
+        + "1S97MM2xH0wmuPCE9ECoGSaqV2REWtulBwJAS15oj+X+aZPBd8HF8wHlcNOs95NS\n"
+        + "AeNU7ujF/gsj1Pk3rnUZc/sFfG9Mw7yvhJ0Sggm6bVRY9QZLfJUOCX3J4QJAJNmN\n"
+        + "xs/h8kq5HE+woNdjPzZHVEJ2Xt46/PKbf/iBjcKJnOlrf5ieH3FjjU5BjHHzmX39\n"
+        + "TUHjVwwGeveNVwrCFQJAEjoNNj5VRy4nVO5iBOubMDDOf0TYUuGhY3s/zMMRTTh2\n"
+        + "sXPVYAsGD1wizrXX+wFaL3chtF1oG1Fx/jcsSsG6BA==\n"
+        + "-----END RSA PRIVATE KEY-----\n");
+
+    assertEquals(heldCertificate.privateKeyPkcs8Pem(), ""
+        + "-----BEGIN PRIVATE KEY-----\n"
+        + "MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAICkUeG2stqfbyr6\n"
+        + "gyiVm5pN9YEDRXlowi+rfYGyWhC7ouW9fXAnhgShQKMOU862mG3tcttSYGdsjM3z\n"
+        + "1crhQlUzpKqncrzwqbzPuAyt2t9Oib/bvjAvbl8gJH7IMRDl9RVgGYkApdkXVqgj\n"
+        + "SYigTHTEWxCEgnrfu/YzEkO6l3rXAgMBAAECgYB99mhnB6piADOuddXv626NzUBT\n"
+        + "r4xbsYRTgSxHzwf50oFTTBSDuW+1IOBVyTWu94SSPyt0LllPbC8Di3sQSTnVGpSq\n"
+        + "AvEXknBMzIc0UO74Rn9p3gZjEenPt1l77fIBa2nK06/rdsJCoE/1P1JSfM9w7LU1\n"
+        + "RsTmseYMLeJl5F79gQJBAO/BbAKqg1yzK7VijygvBoUrr+rt2lbmKgcUQ/rxu8II\n"
+        + "Qk0M/xgJqSkXDXuOnboGM7sQSKfJAZUtT7xozvLzV7ECQQCJW59w7NIM0qZ/gIX2\n"
+        + "gcNZr1B/V3zcGlolTDciRm+fnKGNt2EEDKnVL3swzbEfTCa48IT0QKgZJqpXZERa\n"
+        + "26UHAkBLXmiP5f5pk8F3wcXzAeVw06z3k1IB41Tu6MX+CyPU+TeudRlz+wV8b0zD\n"
+        + "vK+EnRKCCbptVFj1Bkt8lQ4JfcnhAkAk2Y3Gz+HySrkcT7Cg12M/NkdUQnZe3jr8\n"
+        + "8pt/+IGNwomc6Wt/mJ4fcWONTkGMcfOZff1NQeNXDAZ6941XCsIVAkASOg02PlVH\n"
+        + "LidU7mIE65swMM5/RNhS4aFjez/MwxFNOHaxc9VgCwYPXCLOtdf7AVovdyG0XWgb\n"
+        + "UXH+NyxKwboE\n"
+        + "-----END PRIVATE KEY-----\n");
+  }
+
+  @Test public void ecdsaSignedByRsa() {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .rsa2048()
+        .build();
+    HeldCertificate leaf = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .ecdsa256()
+        .signedBy(root)
+        .build();
+
+    assertEquals("SHA256WITHRSA", root.certificate().getSigAlgName());
+    assertEquals("SHA256WITHRSA", leaf.certificate().getSigAlgName());
+  }
+
+  @Test public void rsaSignedByEcdsa() {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .ecdsa256()
+        .build();
+    HeldCertificate leaf = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .rsa2048()
+        .signedBy(root)
+        .build();
+
+    assertEquals("SHA256WITHECDSA", root.certificate().getSigAlgName());
+    assertEquals("SHA256WITHECDSA", leaf.certificate().getSigAlgName());
+  }
+}
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index c22a40da68..86537f25b8 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.10.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
@@ -35,6 +35,12 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -54,6 +60,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
           <links>
@@ -64,6 +71,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
index 344a61e446..31e532d0ad 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
@@ -23,10 +23,12 @@
 import java.io.OutputStream;
 import java.net.HttpURLConnection;
 import java.net.InetSocketAddress;
+import java.net.MalformedURLException;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.SocketPermission;
 import java.net.URL;
+import java.net.UnknownHostException;
 import java.security.Permission;
 import java.util.Arrays;
 import java.util.Collections;
@@ -50,13 +52,13 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.JavaNetHeaders;
 import okhttp3.internal.URLFilter;
-import okhttp3.internal.Util;
 import okhttp3.internal.Version;
 import okhttp3.internal.http.HttpDate;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http.HttpMethod;
 import okhttp3.internal.http.StatusLine;
 import okhttp3.internal.platform.Platform;
+import okio.Buffer;
 
 import static okhttp3.internal.platform.Platform.WARN;
 
@@ -132,6 +134,7 @@ public OkHttpURLConnection(URL url, OkHttpClient client, URLFilter urlFilter) {
           throw propagate(callFailure);
         }
       } catch (InterruptedException e) {
+        Thread.currentThread().interrupt(); // Retain interrupted status.
         throw new InterruptedIOException();
       }
     }
@@ -369,8 +372,22 @@ private Call buildCall() throws IOException {
       requestBody.timeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
     }
 
+    HttpUrl url;
+    try {
+      url = HttpUrl.get(getURL().toString());
+    } catch (IllegalArgumentException e) {
+      if (Internal.instance.isInvalidHttpUrlHost(e)) {
+        UnknownHostException unknownHost = new UnknownHostException();
+        unknownHost.initCause(e);
+        throw unknownHost;
+      }
+      MalformedURLException malformedUrl = new MalformedURLException();
+      malformedUrl.initCause(e);
+      throw malformedUrl;
+    }
+
     Request request = new Request.Builder()
-        .url(Internal.instance.getHttpUrlChecked(getURL().toString()))
+        .url(url)
         .headers(requestHeaders.build())
         .method(method, requestBody)
         .build();
@@ -398,7 +415,25 @@ private Call buildCall() throws IOException {
 
   private String defaultUserAgent() {
     String agent = System.getProperty("http.agent");
-    return agent != null ? Util.toHumanReadableAscii(agent) : Version.userAgent();
+    return agent != null ? toHumanReadableAscii(agent) : Version.userAgent();
+  }
+
+  /** Returns {@code s} with control characters and non-ASCII characters replaced with '?'. */
+  private static String toHumanReadableAscii(String s) {
+    for (int i = 0, length = s.length(), c; i < length; i += Character.charCount(c)) {
+      c = s.codePointAt(i);
+      if (c > '\u001f' && c < '\u007f') continue;
+
+      Buffer buffer = new Buffer();
+      buffer.writeUtf8(s, 0, i);
+      buffer.writeUtf8CodePoint('?');
+      for (int j = i + Character.charCount(c); j < length; j += Character.charCount(c)) {
+        c = s.codePointAt(j);
+        buffer.writeUtf8CodePoint(c > '\u001f' && c < '\u007f' ? c : '?');
+      }
+      return buffer.readUtf8();
+    }
+    return s;
   }
 
   /**
@@ -427,6 +462,7 @@ private Response getResponse(boolean networkResponseOnError) throws IOException
             lock.wait(); // Wait until the response is returned or the call fails.
           }
         } catch (InterruptedException e) {
+          Thread.currentThread().interrupt(); // Retain interrupted status.
           throw new InterruptedIOException();
         }
       }
@@ -616,6 +652,7 @@ public void proceed() {
             lock.wait(); // Wait until proceed() is called.
           }
         } catch (InterruptedException e) {
+          Thread.currentThread().interrupt(); // Retain interrupted status.
           throw new InterruptedIOException();
         }
       }
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
index 0057174226..9dc40b80a2 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
@@ -58,6 +58,9 @@ public OkHttpsURLConnection(OkHttpURLConnection delegate) {
   }
 
   @Override public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
+    if (sslSocketFactory == null) {
+      throw new IllegalArgumentException("sslSocketFactory == null");
+    }
     // This fails in JDK 9 because OkHttp is unable to extract the trust manager.
     delegate.client = delegate.client.newBuilder()
         .sslSocketFactory(sslSocketFactory)
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/package-info.java b/okhttp-urlconnection/src/main/java/okhttp3/package-info.java
new file mode 100644
index 0000000000..1ded0dc6e6
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/package-info.java
@@ -0,0 +1,3 @@
+/** Support for JDK provider APIs. */
+@okhttp3.internal.annotations.EverythingIsNonNull
+package okhttp3;
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
index 21aea203d5..914725fb84 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
@@ -2,8 +2,11 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.io.InputStream;
 import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
 import java.net.URL;
+import java.net.UnknownHostException;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.Date;
@@ -14,9 +17,10 @@
 import okhttp3.internal.URLFilter;
 import okhttp3.internal.huc.OkHttpURLConnection;
 import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.tls.HandshakeCertificates;
 import okio.BufferedSource;
 import org.junit.After;
 import org.junit.Before;
@@ -24,6 +28,7 @@
 import org.junit.Test;
 
 import static java.nio.charset.StandardCharsets.US_ASCII;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static okio.Okio.buffer;
 import static okio.Okio.source;
 import static org.junit.Assert.assertEquals;
@@ -36,7 +41,7 @@
   private OkUrlFactory factory;
   private Cache cache;
 
-  @Before public void setUp() throws IOException {
+  @Before public void setUp() {
     cache = new Cache(new File("/cache/"), 10 * 1024 * 1024, fileSystem);
     OkHttpClient client = new OkHttpClient.Builder()
         .cache(cache)
@@ -52,7 +57,7 @@
    * Response code 407 should only come from proxy servers. Android's client throws if it is sent by
    * an origin server.
    */
-  @Test public void originServerSends407() throws Exception {
+  @Test public void originServerSends407() {
     server.enqueue(new MockResponse().setResponseCode(407));
 
     HttpURLConnection conn = factory.open(server.url("/").url());
@@ -177,16 +182,17 @@ public void checkURLPermitted(URL url) throws IOException {
   }
 
   @Test
-  public void testURLFilterRedirect() throws Exception {
+  public void testURLFilterRedirect() {
     MockWebServer cleartextServer = new MockWebServer();
     cleartextServer.enqueue(new MockResponse()
         .setBody("Blocked!"));
     final URL blockedURL = cleartextServer.url("/").url();
 
-    SslClient contextBuilder = SslClient.localhost();
-    server.useHttps(contextBuilder.socketFactory, false);
+    HandshakeCertificates handshakeCertificates = localhost();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     factory.setClient(factory.client().newBuilder()
-        .sslSocketFactory(contextBuilder.socketFactory, contextBuilder.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .followSslRedirects(true)
         .build());
     factory.setUrlFilter(new URLFilter() {
@@ -211,6 +217,71 @@ public void checkURLPermitted(URL url) throws IOException {
     }
   }
 
+  @Test public void usesValidHeaderValueForDefaultUserAgent() throws Exception {
+    String userAgent =  "🍩 " + "\u001F" + ('\u001f' + 1) + ('\u007f' - 1)+ '\u007f' + " 🍩";
+    String expected = "? ?" + ('\u001f' + 1) + ('\u007f' - 1) + "? ?";
+
+    System.setProperty("http.agent", userAgent);
+    server.enqueue(new MockResponse().setResponseCode(200));
+    InputStream inputStream = factory.open(server.url("/").url()).getInputStream();
+    long skipped;
+    do {
+      skipped = inputStream.skip(Long.MAX_VALUE);
+    } while (skipped != 0);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(expected, recordedRequest.getHeader("User-Agent"));
+  }
+
+  @Test public void usesSimpleDefaultUserAgentWithoutModification() throws Exception {
+    String userAgent = "OkHttp";
+    String expected = "OkHttp";
+
+    System.setProperty("http.agent", userAgent);
+    server.enqueue(new MockResponse().setResponseCode(200));
+    InputStream inputStream = factory.open(server.url("/").url()).getInputStream();
+    long skipped;
+    do {
+      skipped = inputStream.skip(Long.MAX_VALUE);
+    } while (skipped != 0);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(expected, recordedRequest.getHeader("User-Agent"));
+  }
+
+  @Test public void handlesBadUnicodeStringsInDefaultUserAgent() throws Exception {
+    String userAgent =  "🔊".substring(0, 1);
+    String expected = "?";
+
+    System.setProperty("http.agent", userAgent);
+    server.enqueue(new MockResponse().setResponseCode(200));
+    InputStream inputStream = factory.open(server.url("/").url()).getInputStream();
+    long skipped;
+    do {
+      skipped = inputStream.skip(Long.MAX_VALUE);
+    } while (skipped != 0);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(expected, recordedRequest.getHeader("User-Agent"));
+  }
+
+  @Test public void javaNetUrlMalformedUrl() throws Exception {
+    server.enqueue(new MockResponse());
+    HttpURLConnection connection = factory.open(new URL("http://example.com:-1"));
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (MalformedURLException expected) {
+    }
+  }
+
+  @Test public void javaNetUrlBadHost() throws Exception {
+    server.enqueue(new MockResponse());
+    HttpURLConnection connection = factory.open(new URL("http://hostw ithspace/"));
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
   private void assertResponseBody(HttpURLConnection connection, String expected) throws Exception {
     BufferedSource source = buffer(source(connection.getInputStream()));
     String actual = source.readString(US_ASCII);
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
index 104d719ddf..23ff40c89e 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
@@ -44,10 +44,10 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.internal.platform.Platform;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -58,6 +58,7 @@
 import org.junit.Test;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -79,12 +80,12 @@
   @Rule public MockWebServer server2 = new MockWebServer();
   @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
-  private final SslClient sslClient = SslClient.localhost();
+  private final HandshakeCertificates handshakeCertificates = localhost();
   private OkUrlFactory urlFactory = new OkUrlFactory(new OkHttpClient());
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
 
-  @Before public void setUp() throws Exception {
+  @Before public void setUp() {
     server.setProtocolNegotiationEnabled(false);
     cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
     urlFactory = new OkUrlFactory(new OkHttpClient.Builder()
@@ -98,7 +99,7 @@
     cache.delete();
   }
 
-  @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
+  @Test public void responseCacheAccessWithOkHttpMember() {
     assertSame(cache, urlFactory.client().cache());
   }
 
@@ -262,13 +263,14 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   @Test public void secureResponseCaching() throws IOException {
     assumeFalse(getPlatform().equals("jdk9"));
 
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
     HttpsURLConnection c1 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
-    c1.setSSLSocketFactory(sslClient.socketFactory);
+    c1.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     assertEquals("ABC", readAscii(c1));
 
@@ -280,7 +282,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Principal localPrincipal = c1.getLocalPrincipal();
 
     HttpsURLConnection c2 = (HttpsURLConnection) urlFactory.open(server.url("/").url()); // cached!
-    c2.setSSLSocketFactory(sslClient.socketFactory);
+    c2.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     assertEquals("ABC", readAscii(c2));
 
@@ -340,7 +342,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
@@ -351,7 +353,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setBody("DEF"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build());
 
@@ -377,7 +380,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
    * https://github.com/square/okhttp/issues/214
    */
   @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslClient.socketFactory, false);
+    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server2.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
@@ -389,7 +392,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Location: " + server2.url("/").url()));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build());
 
@@ -412,7 +416,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     testServerPrematureDisconnect(TransferKind.CHUNKED);
   }
 
-  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
+  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() {
     // Intentionally empty. This case doesn't make sense because there's no
     // such thing as a premature disconnect when the disconnect itself
     // indicates the end of the data stream.
@@ -1079,7 +1083,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
     Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
     DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
     String lastModifiedString = dateFormat.format(lastModifiedDate);
     String servedString = dateFormat.format(servedDate);
 
@@ -1407,7 +1411,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   @Test public void varyAndHttps() throws Exception {
     assumeFalse(getPlatform().equals("jdk9"));
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
@@ -1415,13 +1419,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
 
     URL url = server.url("/").url();
     HttpsURLConnection connection1 = (HttpsURLConnection) urlFactory.open(url);
-    connection1.setSSLSocketFactory(sslClient.socketFactory);
+    connection1.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
     HttpsURLConnection connection2 = (HttpsURLConnection) urlFactory.open(url);
-    connection2.setSSLSocketFactory(sslClient.socketFactory);
+    connection2.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     connection2.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection2));
@@ -1805,8 +1809,7 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setChunkedBody(content, chunkSize);
       }
     },
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index ae0cc676f1..a16a6c1b27 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.10.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
@@ -17,6 +17,11 @@
       <groupId>com.squareup.okio</groupId>
       <artifactId>okio</artifactId>
     </dependency>
+    <dependency>
+      <groupId>org.conscrypt</groupId>
+      <artifactId>conscrypt-openjdk-uber</artifactId>
+      <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>com.google.android</groupId>
       <artifactId>android</artifactId>
@@ -27,6 +32,12 @@
       <artifactId>jsr305</artifactId>
       <scope>provided</scope>
     </dependency>
+    <dependency>
+      <groupId>org.codehaus.mojo</groupId>
+      <artifactId>animal-sniffer-annotations</artifactId>
+      <version>1.17</version>
+      <scope>provided</scope>
+    </dependency>
   </dependencies>
 
   <build>
@@ -46,6 +57,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
           <links>
@@ -56,6 +68,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
         <configuration>
           <archive>
             <manifestEntries>
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
index 9e34bc9706..10482ffead 100644
--- a/okhttp/src/main/java/okhttp3/Authenticator.java
+++ b/okhttp/src/main/java/okhttp3/Authenticator.java
@@ -19,17 +19,50 @@
 import javax.annotation.Nullable;
 
 /**
- * Responds to an authentication challenge from either a remote web server or a proxy server.
- * Implementations may either attempt to satisfy the challenge by returning a request that includes
- * an authorization header, or they may refuse the challenge by returning null. In this case the
- * unauthenticated response will be returned to the caller that triggered it.
+ * Performs either <strong>preemptive</strong> authentication before connecting to a proxy server,
+ * or <strong>reactive</strong> authentication after receiving a challenge from either an origin web
+ * server or proxy server.
+ *
+ * <h3>Preemptive Authentication</h3>
+ *
+ * <p>To make HTTPS calls using an HTTP proxy server OkHttp must first negotiate a connection with
+ * the proxy. This proxy connection is called a "TLS Tunnel" and is specified by <a
+ * href="https://tools.ietf.org/html/rfc2817">RFC 2817</a>. The HTTP CONNECT request that creates
+ * this tunnel connection is special: it does not participate in any {@linkplain Interceptor
+ * interceptors} or {@linkplain EventListener event listeners}. It doesn't include the motivating
+ * request's HTTP headers or even its full URL; only the target server's hostname is sent to the
+ * proxy.
+ *
+ * <p>Prior to sending any CONNECT request OkHttp always calls the proxy authenticator so that it
+ * may prepare preemptive authentication. OkHttp will call {@link #authenticate} with a fake {@code
+ * HTTP/1.1 407 Proxy Authentication Required} response that has a {@code Proxy-Authenticate:
+ * OkHttp-Preemptive} challenge. The proxy authenticator may return either either an authenticated
+ * request, or null to connect without authentication.
+ * <pre>   {@code
+ *    for (Challenge challenge : response.challenges()) {
+ *      // If this is preemptive auth, use a preemptive credential.
+ *      if (challenge.scheme().equalsIgnoreCase("OkHttp-Preemptive")) {
+ *        return response.request().newBuilder()
+ *            .header("Proxy-Authorization", "secret")
+ *            .build();
+ *      }
+ *    }
+ *
+ *    return null; // Didn't find a preemptive auth scheme.
+ * }</pre>
+ *
+ * <h3>Reactive Authentication</h3>
+ *
+ * <p>Implementations authenticate by returning a follow-up request that includes an authorization
+ * header, or they may decline the challenge by returning null. In this case the unauthenticated
+ * response will be returned to the caller that triggered it.
  *
  * <p>Implementations should check if the initial request already included an attempt to
  * authenticate. If so it is likely that further attempts will not be useful and the authenticator
  * should give up.
  *
- * <p>When authentication is requested by an origin server, the response code is 401 and the
- * implementation should respond with a new request that sets the "Authorization" header.
+ * <p>When reactive authentication is requested by an origin web server, the response code is 401
+ * and the implementation should respond with a new request that sets the "Authorization" header.
  * <pre>   {@code
  *
  *    if (response.request().header("Authorization") != null) {
@@ -42,7 +75,7 @@
  *        .build();
  * }</pre>
  *
- * <p>When authentication is requested by a proxy server, the response code is 407 and the
+ * <p>When reactive authentication is requested by a proxy server, the response code is 407 and the
  * implementation should respond with a new request that sets the "Proxy-Authorization" header.
  * <pre>   {@code
  *
@@ -56,13 +89,16 @@
  *        .build();
  * }</pre>
  *
+ * <p>The proxy authenticator may implement preemptive authentication, reactive authentication, or
+ * both.
+ *
  * <p>Applications may configure OkHttp with an authenticator for origin servers, or proxy servers,
  * or both.
  */
 public interface Authenticator {
   /** An authenticator that knows no credentials and makes no attempt to authenticate. */
   Authenticator NONE = new Authenticator() {
-    @Override public Request authenticate(Route route, Response response) {
+    @Override public Request authenticate(@Nullable Route route, Response response) {
       return null;
     }
   };
@@ -70,6 +106,10 @@
   /**
    * Returns a request that includes a credential to satisfy an authentication challenge in {@code
    * response}. Returns null if the challenge cannot be satisfied.
+   *
+   * <p>The route is best effort, it currently may not always be provided even when logically
+   * available. It may also not be provided when an authenticator is re-used manually in an
+   * application interceptor, such as when implementing client-specific retries.
    */
-  @Nullable Request authenticate(Route route, Response response) throws IOException;
+  @Nullable Request authenticate(@Nullable Route route, Response response) throws IOException;
 }
diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
index d43d91d257..343df45113 100644
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -175,6 +175,9 @@
   private int hitCount;
   private int requestCount;
 
+  /**
+   * Create a cache of at most {@code maxSize} bytes in {@code directory}.
+   */
   public Cache(File directory, long maxSize) {
     this(directory, maxSize, FileSystem.SYSTEM);
   }
@@ -379,6 +382,7 @@ public long size() throws IOException {
     return cache.size();
   }
 
+  /** Max size of the cache (in bytes). */
   public long maxSize() {
     return cache.getMaxSize();
   }
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index 5b4669ad21..67d0f88d3d 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import okio.Timeout;
 
 /**
  * A call is a request that has been prepared for execution. A call can be canceled. As this object
@@ -32,7 +33,7 @@
    * <p>To avoid leaking resources callers should close the {@link Response} which in turn will
    * close the underlying {@link ResponseBody}.
    *
-   * <pre>@{code
+   * <pre>{@code
    *
    *   // ensure the response (and underlying response body) is closed
    *   try (Response response = client.newCall(request).execute()) {
@@ -80,6 +81,15 @@
 
   boolean isCanceled();
 
+  /**
+   * Returns a timeout that spans the entire call: resolving DNS, connecting, writing the request
+   * body, server processing, and reading the response body. If the call requires redirects or
+   * retries all must complete within one timeout period.
+   *
+   * <p>Configure the client's default timeout with {@link OkHttpClient.Builder#callTimeout}.
+   */
+  Timeout timeout();
+
   /**
    * Create a new, identical call to this one which can be enqueued or executed even if this call
    * has already been.
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index 6fab2cf1d1..d509364544 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -268,8 +268,8 @@ static ByteString sha256(X509Certificate x509Certificate) {
     Pin(String pattern, String pin) {
       this.pattern = pattern;
       this.canonicalHostname = pattern.startsWith(WILDCARD)
-          ? HttpUrl.parse("http://" + pattern.substring(WILDCARD.length())).host()
-          : HttpUrl.parse("http://" + pattern).host();
+          ? HttpUrl.get("http://" + pattern.substring(WILDCARD.length())).host()
+          : HttpUrl.get("http://" + pattern).host();
       if (pin.startsWith("sha1/")) {
         this.hashAlgorithm = "sha1/";
         this.hash = ByteString.decodeBase64(pin.substring("sha1/".length()));
diff --git a/okhttp/src/main/java/okhttp3/Challenge.java b/okhttp/src/main/java/okhttp3/Challenge.java
index 4b000eceda..bff1cb830e 100644
--- a/okhttp/src/main/java/okhttp3/Challenge.java
+++ b/okhttp/src/main/java/okhttp3/Challenge.java
@@ -16,32 +16,46 @@
 package okhttp3;
 
 import java.nio.charset.Charset;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
 import javax.annotation.Nullable;
 
+import static java.util.Collections.singletonMap;
+import static java.util.Collections.unmodifiableMap;
+import static java.util.Locale.US;
 import static okhttp3.internal.Util.ISO_8859_1;
 
-/** An RFC 7617 challenge. */
+/** An RFC 7235 challenge. */
 public final class Challenge {
   private final String scheme;
-  private final String realm;
-  private final Charset charset;
+  private final Map<String, String> authParams;
 
-  public Challenge(String scheme, String realm) {
-    this(scheme, realm, ISO_8859_1);
+  public Challenge(String scheme, Map<String, String> authParams) {
+    if (scheme == null) throw new NullPointerException("scheme == null");
+    if (authParams == null) throw new NullPointerException("authParams == null");
+    this.scheme = scheme;
+    Map<String, String> newAuthParams = new LinkedHashMap<>();
+    for (Entry<String, String> authParam : authParams.entrySet()) {
+      String key = (authParam.getKey() == null) ? null : authParam.getKey().toLowerCase(US);
+      newAuthParams.put(key, authParam.getValue());
+    }
+    this.authParams = unmodifiableMap(newAuthParams);
   }
 
-  private Challenge(String scheme, String realm, Charset charset) {
+  public Challenge(String scheme, String realm) {
     if (scheme == null) throw new NullPointerException("scheme == null");
     if (realm == null) throw new NullPointerException("realm == null");
-    if (charset == null) throw new NullPointerException("charset == null");
     this.scheme = scheme;
-    this.realm = realm;
-    this.charset = charset;
+    this.authParams = singletonMap("realm", realm);
   }
 
   /** Returns a copy of this charset that expects a credential encoded with {@code charset}. */
   public Challenge withCharset(Charset charset) {
-    return new Challenge(scheme, realm, charset);
+    if (charset == null) throw new NullPointerException("charset == null");
+    Map<String, String> authParams = new LinkedHashMap<>(this.authParams);
+    authParams.put("charset", charset.name());
+    return new Challenge(scheme, authParams);
   }
 
   /** Returns the authentication scheme, like {@code Basic}. */
@@ -49,34 +63,45 @@ public String scheme() {
     return scheme;
   }
 
+  /**
+   * Returns the auth params, including {@code realm} and {@code charset} if present, but as
+   * strings. The map's keys are lowercase and should be treated case-insensitively.
+   */
+  public Map<String, String> authParams() {
+    return authParams;
+  }
+
   /** Returns the protection space. */
   public String realm() {
-    return realm;
+    return authParams.get("realm");
   }
 
-  /** Returns the charset that should be used to encode the credential. */
+  /** Returns the charset that should be used to encode the credentials. */
   public Charset charset() {
-    return charset;
+    String charset = authParams.get("charset");
+    if (charset != null) {
+      try {
+        return Charset.forName(charset);
+      } catch (Exception ignore) {
+      }
+    }
+    return ISO_8859_1;
   }
 
   @Override public boolean equals(@Nullable Object other) {
     return other instanceof Challenge
         && ((Challenge) other).scheme.equals(scheme)
-        && ((Challenge) other).realm.equals(realm)
-        && ((Challenge) other).charset.equals(charset);
+        && ((Challenge) other).authParams.equals(authParams);
   }
 
   @Override public int hashCode() {
     int result = 29;
-    result = 31 * result + realm.hashCode();
     result = 31 * result + scheme.hashCode();
-    result = 31 * result + charset.hashCode();
+    result = 31 * result + authParams.hashCode();
     return result;
   }
 
   @Override public String toString() {
-    return scheme
-        + " realm=\"" + realm + "\""
-        + " charset=\"" + charset + "\"";
+    return scheme + " authParams=" + authParams;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.java b/okhttp/src/main/java/okhttp3/CipherSuite.java
index a71ddc5ed9..ec1875359b 100644
--- a/okhttp/src/main/java/okhttp3/CipherSuite.java
+++ b/okhttp/src/main/java/okhttp3/CipherSuite.java
@@ -18,9 +18,9 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.TreeMap;
 
 /**
  * <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml">TLS cipher
@@ -29,10 +29,16 @@
  * <p><strong>Not all cipher suites are supported on all platforms.</strong> As newer cipher suites
  * are created (for stronger privacy, better performance, etc.) they will be adopted by the platform
  * and then exposed here. Cipher suites that are not available on either Android (through API level
- * 20) or Java (through JDK 8) are omitted for brevity.
+ * 24) or Java (through JDK 9) are omitted for brevity.
  *
- * <p>See also <a href="https://android.googlesource.com/platform/external/conscrypt/+/master/src/main/java/org/conscrypt/NativeCrypto.java">NativeCrypto.java</a>
- * from conscrypt, which lists the cipher suites supported by Android.
+ * <p>See <a href="https://developer.android.com/reference/javax/net/ssl/SSLEngine.html">Android SSLEngine</a>
+ * which lists the cipher suites supported by Android.
+ *
+ * <p>See <a href="https://docs.oracle.com/javase/10/security/oracle-providers.htm">JDK 10 Providers</a>
+ * which lists the cipher suites supported by Oracle.
+ *
+ * <p>See <a href="https://github.com/google/conscrypt/blob/master/common/src/main/java/org/conscrypt/NativeCrypto.java">NativeCrypto.java</a>
+ * from conscrypt, which lists the cipher suites supported by Conscrypt.
  */
 public final class CipherSuite {
   /**
@@ -55,339 +61,346 @@
   };
 
   /**
-   * Holds interned instances. This needs to be above the of() calls below so that it's
+   * Holds interned instances. This needs to be above the init() calls below so that it's
    * initialized by the time those parts of {@code <clinit>()} run. Guarded by CipherSuite.class.
    */
-  private static final Map<String, CipherSuite> INSTANCES = new TreeMap<>(ORDER_BY_NAME);
+  private static final Map<String, CipherSuite> INSTANCES = new LinkedHashMap<>();
 
   // Last updated 2016-07-03 using cipher suites from Android 24 and Java 9.
 
-  // public static final CipherSuite TLS_NULL_WITH_NULL_NULL = of("TLS_NULL_WITH_NULL_NULL", 0x0000);
-  public static final CipherSuite TLS_RSA_WITH_NULL_MD5 = of("SSL_RSA_WITH_NULL_MD5", 0x0001);
-  public static final CipherSuite TLS_RSA_WITH_NULL_SHA = of("SSL_RSA_WITH_NULL_SHA", 0x0002);
-  public static final CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003);
-  public static final CipherSuite TLS_RSA_WITH_RC4_128_MD5 = of("SSL_RSA_WITH_RC4_128_MD5", 0x0004);
-  public static final CipherSuite TLS_RSA_WITH_RC4_128_SHA = of("SSL_RSA_WITH_RC4_128_SHA", 0x0005);
-  // public static final CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006);
-  // public static final CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = of("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007);
-  public static final CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008);
-  public static final CipherSuite TLS_RSA_WITH_DES_CBC_SHA = of("SSL_RSA_WITH_DES_CBC_SHA", 0x0009);
-  public static final CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a);
-  // public static final CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b);
-  // public static final CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA = of("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c);
-  // public static final CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d);
-  // public static final CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA = of("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010);
-  public static final CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011);
-  public static final CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA = of("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012);
-  public static final CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013);
-  public static final CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014);
-  public static final CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA = of("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015);
-  public static final CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016);
-  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = of("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017);
-  public static final CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = of("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018);
-  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019);
-  public static final CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA = of("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a);
-  public static final CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = of("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b);
-  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_SHA = of("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e);
-  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA = of("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f);
-  public static final CipherSuite TLS_KRB5_WITH_RC4_128_SHA = of("TLS_KRB5_WITH_RC4_128_SHA", 0x0020);
-  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA = of("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021);
-  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_MD5 = of("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022);
-  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = of("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023);
-  public static final CipherSuite TLS_KRB5_WITH_RC4_128_MD5 = of("TLS_KRB5_WITH_RC4_128_MD5", 0x0024);
-  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5 = of("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026);
-  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029);
-  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA = of("TLS_PSK_WITH_NULL_SHA", 0x002c);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA = of("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA = of("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = of("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = of("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = of("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = of("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a);
-  public static final CipherSuite TLS_RSA_WITH_NULL_SHA256 = of("TLS_RSA_WITH_NULL_SHA256", 0x003b);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040);
-  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043);
-  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044);
-  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d);
-  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086);
-  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087);
-  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089);
-  public static final CipherSuite TLS_PSK_WITH_RC4_128_SHA = of("TLS_PSK_WITH_RC4_128_SHA", 0x008a);
-  public static final CipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b);
-  public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA = of("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c);
-  public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA = of("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA = of("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA = of("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095);
-  public static final CipherSuite TLS_RSA_WITH_SEED_CBC_SHA = of("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096);
-  // public static final CipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA = of("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097);
-  // public static final CipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA = of("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA = of("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA = of("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a);
-  // public static final CipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA = of("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256 = of("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384 = of("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA256 = of("TLS_PSK_WITH_NULL_SHA256", 0x00b0);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA384 = of("TLS_PSK_WITH_NULL_SHA384", 0x00b1);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA256 = of("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA384 = of("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA256 = of("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA384 = of("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5);
-  public static final CipherSuite TLS_EMPTY_RENEGOTIATION_INFO_SCSV = of("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff);
-  public static final CipherSuite TLS_FALLBACK_SCSV = of("TLS_FALLBACK_SCSV", 0x5600);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA = of("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA = of("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA = of("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = of("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA = of("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA = of("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = of("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = of("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA = of("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA = of("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014);
-  public static final CipherSuite TLS_ECDH_anon_WITH_NULL_SHA = of("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015);
-  public static final CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA = of("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016);
-  public static final CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017);
-  public static final CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA = of("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018);
-  public static final CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA = of("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_RC4_128_SHA = of("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034);
-  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035);
-  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA = of("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA256 = of("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA384 = of("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b);
-  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM = of("TLS_RSA_WITH_AES_128_CCM", 0xc09c);
-  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM = of("TLS_RSA_WITH_AES_256_CCM", 0xc09d);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM = of("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM = of("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f);
-  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM_8 = of("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0);
-  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM_8 = of("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM_8 = of("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM_8 = of("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM = of("TLS_PSK_WITH_AES_128_CCM", 0xc0a4);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM = of("TLS_PSK_WITH_AES_256_CCM", 0xc0a5);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CCM = of("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CCM = of("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM_8 = of("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM_8 = of("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9);
-  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_128_CCM_8 = of("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa);
-  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_256_CCM_8 = of("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM = of("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa);
-  // public static final CipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccab);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccad);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccae);
+  // public static final CipherSuite TLS_NULL_WITH_NULL_NULL = init("TLS_NULL_WITH_NULL_NULL", 0x0000);
+  public static final CipherSuite TLS_RSA_WITH_NULL_MD5 = init("SSL_RSA_WITH_NULL_MD5", 0x0001);
+  public static final CipherSuite TLS_RSA_WITH_NULL_SHA = init("SSL_RSA_WITH_NULL_SHA", 0x0002);
+  public static final CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5 = init("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003);
+  public static final CipherSuite TLS_RSA_WITH_RC4_128_MD5 = init("SSL_RSA_WITH_RC4_128_MD5", 0x0004);
+  public static final CipherSuite TLS_RSA_WITH_RC4_128_SHA = init("SSL_RSA_WITH_RC4_128_SHA", 0x0005);
+  // public static final CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = init("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006);
+  // public static final CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = init("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007);
+  public static final CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008);
+  public static final CipherSuite TLS_RSA_WITH_DES_CBC_SHA = init("SSL_RSA_WITH_DES_CBC_SHA", 0x0009);
+  public static final CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = init("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a);
+  // public static final CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b);
+  // public static final CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA = init("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c);
+  // public static final CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = init("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d);
+  // public static final CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA = init("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010);
+  public static final CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011);
+  public static final CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA = init("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012);
+  public static final CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = init("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013);
+  public static final CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014);
+  public static final CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA = init("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015);
+  public static final CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = init("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016);
+  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = init("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017);
+  public static final CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = init("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018);
+  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019);
+  public static final CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA = init("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a);
+  public static final CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = init("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b);
+  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_SHA = init("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e);
+  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA = init("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f);
+  public static final CipherSuite TLS_KRB5_WITH_RC4_128_SHA = init("TLS_KRB5_WITH_RC4_128_SHA", 0x0020);
+  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA = init("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021);
+  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_MD5 = init("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022);
+  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = init("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023);
+  public static final CipherSuite TLS_KRB5_WITH_RC4_128_MD5 = init("TLS_KRB5_WITH_RC4_128_MD5", 0x0024);
+  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5 = init("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = init("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026);
+  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = init("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA = init("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = init("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029);
+  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = init("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a);
+  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = init("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA = init("TLS_PSK_WITH_NULL_SHA", 0x002c);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA = init("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA = init("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = init("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = init("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = init("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = init("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = init("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = init("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = init("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = init("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = init("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = init("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = init("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = init("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a);
+  public static final CipherSuite TLS_RSA_WITH_NULL_SHA256 = init("TLS_RSA_WITH_NULL_SHA256", 0x003b);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040);
+  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043);
+  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044);
+  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = init("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = init("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = init("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = init("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d);
+  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086);
+  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087);
+  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089);
+  public static final CipherSuite TLS_PSK_WITH_RC4_128_SHA = init("TLS_PSK_WITH_RC4_128_SHA", 0x008a);
+  public static final CipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b);
+  public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA = init("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c);
+  public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA = init("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA = init("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA = init("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA = init("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA = init("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA = init("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA = init("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095);
+  public static final CipherSuite TLS_RSA_WITH_SEED_CBC_SHA = init("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096);
+  // public static final CipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA = init("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097);
+  // public static final CipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA = init("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA = init("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA = init("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a);
+  // public static final CipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA = init("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b);
+  public static final CipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c);
+  public static final CipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e);
+  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0);
+  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2);
+  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4);
+  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256 = init("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6);
+  public static final CipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384 = init("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA256 = init("TLS_PSK_WITH_NULL_SHA256", 0x00b0);
+  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA384 = init("TLS_PSK_WITH_NULL_SHA384", 0x00b1);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA256 = init("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA384 = init("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA256 = init("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA384 = init("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5);
+  public static final CipherSuite TLS_EMPTY_RENEGOTIATION_INFO_SCSV = init("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff);
+  public static final CipherSuite TLS_FALLBACK_SCSV = init("TLS_FALLBACK_SCSV", 0x5600);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA = init("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA = init("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA = init("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = init("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA = init("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA = init("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = init("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = init("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA = init("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA = init("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014);
+  public static final CipherSuite TLS_ECDH_anon_WITH_NULL_SHA = init("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015);
+  public static final CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA = init("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016);
+  public static final CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017);
+  public static final CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA = init("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018);
+  public static final CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA = init("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f);
+  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020);
+  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021);
+  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d);
+  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031);
+  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_RC4_128_SHA = init("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034);
+  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035);
+  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA = init("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA256 = init("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA384 = init("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050);
+  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054);
+  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058);
+  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a);
+  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a);
+  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a);
+  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e);
+  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080);
+  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082);
+  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084);
+  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088);
+  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a);
+  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c);
+  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094);
+  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a);
+  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b);
+  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM = init("TLS_RSA_WITH_AES_128_CCM", 0xc09c);
+  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM = init("TLS_RSA_WITH_AES_256_CCM", 0xc09d);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM = init("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM = init("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f);
+  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM_8 = init("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0);
+  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM_8 = init("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM_8 = init("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2);
+  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM_8 = init("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM = init("TLS_PSK_WITH_AES_128_CCM", 0xc0a4);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM = init("TLS_PSK_WITH_AES_256_CCM", 0xc0a5);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CCM = init("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CCM = init("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7);
+  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM_8 = init("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8);
+  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM_8 = init("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9);
+  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_128_CCM_8 = init("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa);
+  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_256_CCM_8 = init("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM = init("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM = init("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = init("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae);
+  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = init("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af);
+  public static final CipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8);
+  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9);
+  public static final CipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa);
+  // public static final CipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccab);
+  public static final CipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac);
+  // public static final CipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccad);
+  // public static final CipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccae);
+
+  // TLS 1.3 https://tools.ietf.org/html/rfc8446
+  public static final CipherSuite TLS_AES_128_GCM_SHA256 = init("TLS_AES_128_GCM_SHA256", 0x1301);
+  public static final CipherSuite TLS_AES_256_GCM_SHA384 = init("TLS_AES_256_GCM_SHA384", 0x1302);
+  public static final CipherSuite TLS_CHACHA20_POLY1305_SHA256 = init("TLS_CHACHA20_POLY1305_SHA256", 0x1303);
+  public static final CipherSuite TLS_AES_128_CCM_SHA256 = init("TLS_AES_128_CCM_SHA256", 0x1304);
+  public static final CipherSuite TLS_AES_256_CCM_8_SHA256 = init("TLS_AES_256_CCM_8_SHA256", 0x1305);
 
   final String javaName;
 
@@ -398,12 +411,28 @@
   public static synchronized CipherSuite forJavaName(String javaName) {
     CipherSuite result = INSTANCES.get(javaName);
     if (result == null) {
-      result = new CipherSuite(javaName);
+      result = INSTANCES.get(secondaryName(javaName));
+
+      if (result == null) {
+        result = new CipherSuite(javaName);
+      }
+
+      // Add the new cipher suite, or a confirmed alias.
       INSTANCES.put(javaName, result);
     }
     return result;
   }
 
+  private static String secondaryName(String javaName) {
+    if (javaName.startsWith("TLS_")) {
+      return "SSL_" + javaName.substring(4);
+    } else if (javaName.startsWith("SSL_")) {
+      return "TLS_" + javaName.substring(4);
+    } else {
+      return javaName;
+    }
+  }
+
   static List<CipherSuite> forJavaNames(String... cipherSuites) {
     List<CipherSuite> result = new ArrayList<>(cipherSuites.length);
     for (String cipherSuite : cipherSuites) {
@@ -424,8 +453,10 @@ private CipherSuite(String javaName) {
    *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
    * @param value the integer identifier for this cipher suite. (Documentation only.)
    */
-  private static CipherSuite of(String javaName, int value) {
-    return forJavaName(javaName);
+  private static CipherSuite init(String javaName, int value) {
+    CipherSuite suite = new CipherSuite(javaName);
+    INSTANCES.put(javaName, suite);
+    return suite;
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
index 25b9ee328b..004a97065b 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -40,10 +40,34 @@
  */
 public final class ConnectionSpec {
 
+  // Most secure but generally supported list.
+  private static final CipherSuite[] RESTRICTED_CIPHER_SUITES = new CipherSuite[] {
+      // TLSv1.3
+      CipherSuite.TLS_AES_128_GCM_SHA256,
+      CipherSuite.TLS_AES_256_GCM_SHA384,
+      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_AES_128_CCM_SHA256,
+      CipherSuite.TLS_AES_256_CCM_8_SHA256,
+
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
+  };
+
   // This is nearly equal to the cipher suites supported in Chrome 51, current as of 2016-05-25.
   // All of these suites are available on Android 7.0; earlier releases support a subset of these
   // suites. https://github.com/square/okhttp/issues/1972
   private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
+      // TLSv1.3
+      CipherSuite.TLS_AES_128_GCM_SHA256,
+      CipherSuite.TLS_AES_256_GCM_SHA384,
+      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_AES_128_CCM_SHA256,
+      CipherSuite.TLS_AES_256_CCM_8_SHA256,
+
       CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
@@ -54,9 +78,7 @@
       // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
       // continue to include them until better suites are commonly available. For example, none
       // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,
@@ -65,6 +87,13 @@
       CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
   };
 
+  /** A secure TLS connection assuming a modern client platform and server. */
+  public static final ConnectionSpec RESTRICTED_TLS = new Builder(true)
+      .cipherSuites(RESTRICTED_CIPHER_SUITES)
+      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
+      .supportsTlsExtensions(true)
+      .build();
+
   /** A modern TLS connection with extensions like SNI and ALPN available. */
   public static final ConnectionSpec MODERN_TLS = new Builder(true)
       .cipherSuites(APPROVED_CIPHER_SUITES)
@@ -73,7 +102,8 @@
       .build();
 
   /** A backwards-compatible fallback connection for interop with obsolete servers. */
-  public static final ConnectionSpec COMPATIBLE_TLS = new Builder(MODERN_TLS)
+  public static final ConnectionSpec COMPATIBLE_TLS = new Builder(true)
+      .cipherSuites(APPROVED_CIPHER_SUITES)
       .tlsVersions(TlsVersion.TLS_1_0)
       .supportsTlsExtensions(true)
       .build();
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
index fbfa99c26d..7a4f24ba20 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -458,10 +458,10 @@ private static String parseDomain(String s) {
    * #domain() domain} values must all be set before calling {@link #build}.
    */
   public static final class Builder {
-    String name;
-    String value;
+    @Nullable String name;
+    @Nullable String value;
     long expiresAt = HttpDate.MAX_DATE;
-    String domain;
+    @Nullable String domain;
     String path = "/";
     boolean secure;
     boolean httpOnly;
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index 21013bda11..3e33dff6bf 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -75,12 +75,14 @@ public synchronized ExecutorService executorService() {
    * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
    * will remain in flight.
    */
-  public synchronized void setMaxRequests(int maxRequests) {
+  public void setMaxRequests(int maxRequests) {
     if (maxRequests < 1) {
       throw new IllegalArgumentException("max < 1: " + maxRequests);
     }
-    this.maxRequests = maxRequests;
-    promoteCalls();
+    synchronized (this) {
+      this.maxRequests = maxRequests;
+    }
+    promoteAndExecute();
   }
 
   public synchronized int getMaxRequests() {
@@ -98,12 +100,14 @@ public synchronized int getMaxRequests() {
    *
    * <p>WebSocket connections to hosts <b>do not</b> count against this limit.
    */
-  public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
+  public void setMaxRequestsPerHost(int maxRequestsPerHost) {
     if (maxRequestsPerHost < 1) {
       throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
     }
-    this.maxRequestsPerHost = maxRequestsPerHost;
-    promoteCalls();
+    synchronized (this) {
+      this.maxRequestsPerHost = maxRequestsPerHost;
+    }
+    promoteAndExecute();
   }
 
   public synchronized int getMaxRequestsPerHost() {
@@ -126,13 +130,11 @@ public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
     this.idleCallback = idleCallback;
   }
 
-  synchronized void enqueue(AsyncCall call) {
-    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
-      runningAsyncCalls.add(call);
-      executorService().execute(call);
-    } else {
+  void enqueue(AsyncCall call) {
+    synchronized (this) {
       readyAsyncCalls.add(call);
     }
+    promoteAndExecute();
   }
 
   /**
@@ -153,21 +155,38 @@ public synchronized void cancelAll() {
     }
   }
 
-  private void promoteCalls() {
-    if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.
-    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.
+  /**
+   * Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs
+   * them on the executor service. Must not be called with synchronization because executing calls
+   * can call into user code.
+   *
+   * @return true if the dispatcher is currently running calls.
+   */
+  private boolean promoteAndExecute() {
+    assert (!Thread.holdsLock(this));
+
+    List<AsyncCall> executableCalls = new ArrayList<>();
+    boolean isRunning;
+    synchronized (this) {
+      for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
+        AsyncCall asyncCall = i.next();
 
-    for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
-      AsyncCall call = i.next();
+        if (runningAsyncCalls.size() >= maxRequests) break; // Max capacity.
+        if (runningCallsForHost(asyncCall) >= maxRequestsPerHost) continue; // Host max capacity.
 
-      if (runningCallsForHost(call) < maxRequestsPerHost) {
         i.remove();
-        runningAsyncCalls.add(call);
-        executorService().execute(call);
+        executableCalls.add(asyncCall);
+        runningAsyncCalls.add(asyncCall);
       }
+      isRunning = runningCallsCount() > 0;
+    }
 
-      if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.
+    for (int i = 0, size = executableCalls.size(); i < size; i++) {
+      AsyncCall asyncCall = executableCalls.get(i);
+      asyncCall.executeOn(executorService());
     }
+
+    return isRunning;
   }
 
   /** Returns the number of running calls that share a host with {@code call}. */
@@ -187,25 +206,24 @@ synchronized void executed(RealCall call) {
 
   /** Used by {@code AsyncCall#run} to signal completion. */
   void finished(AsyncCall call) {
-    finished(runningAsyncCalls, call, true);
+    finished(runningAsyncCalls, call);
   }
 
   /** Used by {@code Call#execute} to signal completion. */
   void finished(RealCall call) {
-    finished(runningSyncCalls, call, false);
+    finished(runningSyncCalls, call);
   }
 
-  private <T> void finished(Deque<T> calls, T call, boolean promoteCalls) {
-    int runningCallsCount;
+  private <T> void finished(Deque<T> calls, T call) {
     Runnable idleCallback;
     synchronized (this) {
       if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
-      if (promoteCalls) promoteCalls();
-      runningCallsCount = runningCallsCount();
       idleCallback = this.idleCallback;
     }
 
-    if (runningCallsCount == 0 && idleCallback != null) {
+    boolean isRunning = promoteAndExecute();
+
+    if (!isRunning && idleCallback != null) {
       idleCallback.run();
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/EventListener.java b/okhttp/src/main/java/okhttp3/EventListener.java
index f64b06f7e6..fb8d4c7f4a 100644
--- a/okhttp/src/main/java/okhttp3/EventListener.java
+++ b/okhttp/src/main/java/okhttp3/EventListener.java
@@ -26,12 +26,6 @@
  * Listener for metrics events. Extend this class to monitor the quantity, size, and duration of
  * your application's HTTP calls.
  *
- * <h3>Warning: This is a non-final API.</h3>
- *
- * <p><strong>As of OkHttp 3.9, this feature is an unstable preview: the API is subject to change,
- * and the implementation is incomplete. We expect that OkHttp 3.10 or 3.11 will finalize this API.
- * Until then, expect API and behavior changes when you update your OkHttp dependency.</strong>
- *
  * <p>All start/connect/acquire events will eventually receive a matching end/release event,
  * either successful (non-null parameters), or failed (non-null throwable).  The first common
  * parameters of each event pair are used to link the event in case of concurrent or repeated
@@ -283,14 +277,6 @@ public void callEnd(Call call) {
   public void callFailed(Call call, IOException ioe) {
   }
 
-  /**
-   * <h3>Warning: This is a non-final API.</h3>
-   *
-   * <p><strong>As of OkHttp 3.9, this feature is an unstable preview: the API is subject to change,
-   * and the implementation is incomplete. We expect that OkHttp 3.10 or 3.11 will finalize this
-   * API. Until then, expect API and behavior changes when you update your OkHttp
-   * dependency.</strong>
-   */
   public interface Factory {
     /**
      * Creates an instance of the {@link EventListener} for a particular {@link Call}. The returned
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
index 486c6bbf0e..d3937834c3 100644
--- a/okhttp/src/main/java/okhttp3/FormBody.java
+++ b/okhttp/src/main/java/okhttp3/FormBody.java
@@ -28,8 +28,7 @@
 import static okhttp3.HttpUrl.percentDecode;
 
 public final class FormBody extends RequestBody {
-  private static final MediaType CONTENT_TYPE =
-      MediaType.parse("application/x-www-form-urlencoded");
+  private static final MediaType CONTENT_TYPE = MediaType.get("application/x-www-form-urlencoded");
 
   private final List<String> encodedNames;
   private final List<String> encodedValues;
diff --git a/okhttp/src/main/java/okhttp3/Handshake.java b/okhttp/src/main/java/okhttp3/Handshake.java
index 59a5418b86..e6c86bcad9 100644
--- a/okhttp/src/main/java/okhttp3/Handshake.java
+++ b/okhttp/src/main/java/okhttp3/Handshake.java
@@ -15,9 +15,11 @@
  */
 package okhttp3;
 
+import java.io.IOException;
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import javax.annotation.Nullable;
@@ -46,13 +48,17 @@ private Handshake(TlsVersion tlsVersion, CipherSuite cipherSuite,
     this.localCertificates = localCertificates;
   }
 
-  public static Handshake get(SSLSession session) {
+  public static Handshake get(SSLSession session) throws IOException {
     String cipherSuiteString = session.getCipherSuite();
     if (cipherSuiteString == null) throw new IllegalStateException("cipherSuite == null");
+    if ("SSL_NULL_WITH_NULL_NULL".equals(cipherSuiteString)) {
+      throw new IOException("cipherSuite == SSL_NULL_WITH_NULL_NULL");
+    }
     CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
 
     String tlsVersionString = session.getProtocol();
     if (tlsVersionString == null) throw new IllegalStateException("tlsVersion == null");
+    if ("NONE".equals(tlsVersionString)) throw new IOException("tlsVersion == NONE");
     TlsVersion tlsVersion = TlsVersion.forJavaName(tlsVersionString);
 
     Certificate[] peerCertificates;
@@ -135,4 +141,31 @@ public CipherSuite cipherSuite() {
     result = 31 * result + localCertificates.hashCode();
     return result;
   }
+
+  @Override public String toString() {
+    return "Handshake{"
+        + "tlsVersion="
+        + tlsVersion
+        + " cipherSuite="
+        + cipherSuite
+        + " peerCertificates="
+        + names(peerCertificates)
+        + " localCertificates="
+        + names(localCertificates)
+        + '}';
+  }
+
+  private List<String> names(List<Certificate> certificates) {
+    ArrayList<String> strings = new ArrayList<>();
+
+    for (Certificate cert : certificates) {
+      if (cert instanceof X509Certificate) {
+        strings.add(String.valueOf(((X509Certificate) cert).getSubjectDN()));
+      } else {
+        strings.add(cert.getType());
+      }
+    }
+
+    return strings;
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index d5ef33aa70..8b662c96ac 100644
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -220,9 +220,8 @@ public static Headers of(String... namesAndValues) {
     for (int i = 0; i < namesAndValues.length; i += 2) {
       String name = namesAndValues[i];
       String value = namesAndValues[i + 1];
-      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
-      }
+      checkName(name);
+      checkValue(value, name);
     }
 
     return new Headers(namesAndValues);
@@ -243,9 +242,8 @@ public static Headers of(Map<String, String> headers) {
       }
       String name = header.getKey().trim();
       String value = header.getValue().trim();
-      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
-      }
+      checkName(name);
+      checkValue(value, name);
       namesAndValues[i] = name;
       namesAndValues[i + 1] = value;
       i += 2;
@@ -254,6 +252,29 @@ public static Headers of(Map<String, String> headers) {
     return new Headers(namesAndValues);
   }
 
+  static void checkName(String name) {
+    if (name == null) throw new NullPointerException("name == null");
+    if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
+    for (int i = 0, length = name.length(); i < length; i++) {
+      char c = name.charAt(i);
+      if (c <= '\u0020' || c >= '\u007f') {
+        throw new IllegalArgumentException(Util.format(
+            "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
+      }
+    }
+  }
+
+  static void checkValue(String value, String name) {
+    if (value == null) throw new NullPointerException("value for name " + name + " == null");
+    for (int i = 0, length = value.length(); i < length; i++) {
+      char c = value.charAt(i);
+      if ((c <= '\u001f' && c != '\t') || c >= '\u007f') {
+        throw new IllegalArgumentException(Util.format(
+            "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
+      }
+    }
+  }
+
   public static final class Builder {
     final List<String> namesAndValues = new ArrayList<>(20);
 
@@ -283,12 +304,56 @@ public Builder add(String line) {
       return add(line.substring(0, index).trim(), line.substring(index + 1));
     }
 
-    /** Add a field with the specified value. */
+    /**
+     * Add a header with the specified name and value. Does validation of header names and values.
+     */
     public Builder add(String name, String value) {
-      checkNameAndValue(name, value);
+      checkName(name);
+      checkValue(value, name);
+      return addLenient(name, value);
+    }
+
+    /**
+     * Add a header with the specified name and value. Does validation of header names, allowing
+     * non-ASCII values.
+     */
+    public Builder addUnsafeNonAscii(String name, String value) {
+      checkName(name);
       return addLenient(name, value);
     }
 
+    /**
+     * Adds all headers from an existing collection.
+     */
+    public Builder addAll(Headers headers) {
+      int size = headers.size();
+      for (int i = 0; i < size; i++) {
+        addLenient(headers.name(i), headers.value(i));
+      }
+
+      return this;
+    }
+
+    /**
+     * Add a header with the specified name and formatted Date.
+     * Does validation of header names and values.
+     */
+    public Builder add(String name, Date value) {
+      if (value == null) throw new NullPointerException("value for name " + name + " == null");
+      add(name, HttpDate.format(value));
+      return this;
+    }
+
+    /**
+     * Set a field with the specified date. If the field is not found, it is added. If the field is
+     * found, the existing values are replaced.
+     */
+    public Builder set(String name, Date value) {
+      if (value == null) throw new NullPointerException("value for name " + name + " == null");
+      set(name, HttpDate.format(value));
+      return this;
+    }
+
     /**
      * Add a field with the specified value without any validation. Only appropriate for headers
      * from the remote peer or cache.
@@ -315,32 +380,13 @@ public Builder removeAll(String name) {
      * found, the existing values are replaced.
      */
     public Builder set(String name, String value) {
-      checkNameAndValue(name, value);
+      checkName(name);
+      checkValue(value, name);
       removeAll(name);
       addLenient(name, value);
       return this;
     }
 
-    private void checkNameAndValue(String name, String value) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
-      for (int i = 0, length = name.length(); i < length; i++) {
-        char c = name.charAt(i);
-        if (c <= '\u0020' || c >= '\u007f') {
-          throw new IllegalArgumentException(Util.format(
-              "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
-        }
-      }
-      if (value == null) throw new NullPointerException("value for name " + name + " == null");
-      for (int i = 0, length = value.length(); i < length; i++) {
-        char c = value.charAt(i);
-        if ((c <= '\u001f' && c != '\t') || c >= '\u007f') {
-          throw new IllegalArgumentException(Util.format(
-              "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
-        }
-      }
-    }
-
     /** Equivalent to {@code build().get(name)}, but potentially faster. */
     public String get(String name) {
       for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index 85292eec88..9ca007cefd 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -20,7 +20,6 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
-import java.net.UnknownHostException;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -281,7 +280,8 @@
  * {@code java.net.URL} it's possible to create an awkward URL like {@code http:/} with scheme and
  * path but no hostname. Building APIs that consume such malformed values is difficult!
  *
- * <p>This class has a modern API. It avoids punitive checked exceptions: {@link #parse parse()}
+ * <p>This class has a modern API. It avoids punitive checked exceptions: {@link #get get()}
+ * throws {@link IllegalArgumentException} on invalid input or {@link #parse parse()}
  * returns null if the input is an invalid URL. You can even be explicit about whether each
  * component has been encoded already.
  */
@@ -293,7 +293,8 @@
   static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
   static final String PATH_SEGMENT_ENCODE_SET_URI = "[]";
   static final String QUERY_ENCODE_SET = " \"'<>#";
-  static final String QUERY_COMPONENT_ENCODE_SET = " \"'<>#&=";
+  static final String QUERY_COMPONENT_REENCODE_SET = " \"'<>#&=";
+  static final String QUERY_COMPONENT_ENCODE_SET = " !\"#$&'(),/:;<=>?@[]\\^`{|}~";
   static final String QUERY_COMPONENT_ENCODE_SET_URI = "\\^`{|}";
   static final String FORM_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#&!$(),~";
   static final String FRAGMENT_ENCODE_SET = "";
@@ -887,9 +888,11 @@ public Builder newBuilder() {
    * or null if the resulting URL is not well-formed.
    */
   public @Nullable Builder newBuilder(String link) {
-    Builder builder = new Builder();
-    Builder.ParseResult result = builder.parse(this, link);
-    return result == Builder.ParseResult.SUCCESS ? builder : null;
+    try {
+      return new Builder().parse(this, link);
+    } catch (IllegalArgumentException ignored) {
+      return null;
+    }
   }
 
   /**
@@ -897,40 +900,28 @@ public Builder newBuilder() {
    * URL, or null if it isn't.
    */
   public static @Nullable HttpUrl parse(String url) {
-    Builder builder = new Builder();
-    Builder.ParseResult result = builder.parse(null, url);
-    return result == Builder.ParseResult.SUCCESS ? builder.build() : null;
+    try {
+      return get(url);
+    } catch (IllegalArgumentException ignored) {
+      return null;
+    }
   }
 
   /**
-   * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
-   * null if it has any other protocol.
+   * Returns a new {@code HttpUrl} representing {@code url}.
+   *
+   * @throws IllegalArgumentException If {@code url} is not a well-formed HTTP or HTTPS URL.
    */
-  public static @Nullable HttpUrl get(URL url) {
-    return parse(url.toString());
+  public static HttpUrl get(String url) {
+    return new Builder().parse(null, url).build();
   }
 
   /**
-   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
-   * URL, or throws an exception if it isn't.
-   *
-   * @throws MalformedURLException if there was a non-host related URL issue
-   * @throws UnknownHostException if the host was invalid
+   * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
+   * null if it has any other protocol.
    */
-  static HttpUrl getChecked(String url) throws MalformedURLException, UnknownHostException {
-    Builder builder = new Builder();
-    Builder.ParseResult result = builder.parse(null, url);
-    switch (result) {
-      case SUCCESS:
-        return builder.build();
-      case INVALID_HOST:
-        throw new UnknownHostException("Invalid host: " + url);
-      case UNSUPPORTED_SCHEME:
-      case MISSING_SCHEME:
-      case INVALID_PORT:
-      default:
-        throw new MalformedURLException("Invalid URL: " + result + " for " + url);
-    }
+  public static @Nullable HttpUrl get(URL url) {
+    return parse(url.toString());
   }
 
   public static @Nullable HttpUrl get(URI uri) {
@@ -1170,9 +1161,9 @@ public Builder addEncodedQueryParameter(String encodedName, @Nullable String enc
       if (encodedName == null) throw new NullPointerException("encodedName == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
-          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
+          canonicalize(encodedName, QUERY_COMPONENT_REENCODE_SET, true, false, true, true));
       encodedQueryNamesAndValues.add(encodedValue != null
-          ? canonicalize(encodedValue, QUERY_COMPONENT_ENCODE_SET, true, false, true, true)
+          ? canonicalize(encodedValue, QUERY_COMPONENT_REENCODE_SET, true, false, true, true)
           : null);
       return this;
     }
@@ -1202,7 +1193,7 @@ public Builder removeAllEncodedQueryParameters(String encodedName) {
       if (encodedName == null) throw new NullPointerException("encodedName == null");
       if (encodedQueryNamesAndValues == null) return this;
       removeAllCanonicalQueryParameters(
-          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
+          canonicalize(encodedName, QUERY_COMPONENT_REENCODE_SET, true, false, true, true));
       return this;
     }
 
@@ -1267,8 +1258,12 @@ public HttpUrl build() {
 
     @Override public String toString() {
       StringBuilder result = new StringBuilder();
-      result.append(scheme);
-      result.append("://");
+      if (scheme != null) {
+        result.append(scheme);
+        result.append("://");
+      } else {
+        result.append("//");
+      }
 
       if (!encodedUsername.isEmpty() || !encodedPassword.isEmpty()) {
         result.append(encodedUsername);
@@ -1279,19 +1274,23 @@ public HttpUrl build() {
         result.append('@');
       }
 
-      if (host.indexOf(':') != -1) {
-        // Host is an IPv6 address.
-        result.append('[');
-        result.append(host);
-        result.append(']');
-      } else {
-        result.append(host);
+      if (host != null) {
+        if (host.indexOf(':') != -1) {
+          // Host is an IPv6 address.
+          result.append('[');
+          result.append(host);
+          result.append(']');
+        } else {
+          result.append(host);
+        }
       }
 
-      int effectivePort = effectivePort();
-      if (effectivePort != defaultPort(scheme)) {
-        result.append(':');
-        result.append(effectivePort);
+      if (port != -1 || scheme != null) {
+        int effectivePort = effectivePort();
+        if (scheme == null || effectivePort != defaultPort(scheme)) {
+          result.append(':');
+          result.append(effectivePort);
+        }
       }
 
       pathSegmentsToString(result, encodedPathSegments);
@@ -1309,15 +1308,9 @@ public HttpUrl build() {
       return result.toString();
     }
 
-    enum ParseResult {
-      SUCCESS,
-      MISSING_SCHEME,
-      UNSUPPORTED_SCHEME,
-      INVALID_PORT,
-      INVALID_HOST,
-    }
+    static final String INVALID_HOST = "Invalid URL host";
 
-    ParseResult parse(@Nullable HttpUrl base, String input) {
+    Builder parse(@Nullable HttpUrl base, String input) {
       int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
       int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
 
@@ -1331,12 +1324,14 @@ ParseResult parse(@Nullable HttpUrl base, String input) {
           this.scheme = "http";
           pos += "http:".length();
         } else {
-          return ParseResult.UNSUPPORTED_SCHEME; // Not an HTTP scheme.
+          throw new IllegalArgumentException("Expected URL scheme 'http' or 'https' but was '"
+              + input.substring(0, schemeDelimiterOffset) + "'");
         }
       } else if (base != null) {
         this.scheme = base.scheme;
       } else {
-        return ParseResult.MISSING_SCHEME; // No scheme.
+        throw new IllegalArgumentException(
+            "Expected URL scheme 'http' or 'https' but no colon was found");
       }
 
       // Authority.
@@ -1395,14 +1390,20 @@ ParseResult parse(@Nullable HttpUrl base, String input) {
               // Host info precedes.
               int portColonOffset = portColonOffset(input, pos, componentDelimiterOffset);
               if (portColonOffset + 1 < componentDelimiterOffset) {
-                this.host = canonicalizeHost(input, pos, portColonOffset);
-                this.port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
-                if (this.port == -1) return ParseResult.INVALID_PORT; // Invalid port.
+                host = canonicalizeHost(input, pos, portColonOffset);
+                port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
+                if (port == -1) {
+                  throw new IllegalArgumentException("Invalid URL port: \""
+                      + input.substring(portColonOffset + 1, componentDelimiterOffset) + '"');
+                }
               } else {
-                this.host = canonicalizeHost(input, pos, portColonOffset);
-                this.port = defaultPort(this.scheme);
+                host = canonicalizeHost(input, pos, portColonOffset);
+                port = defaultPort(scheme);
+              }
+              if (host == null) {
+                throw new IllegalArgumentException(
+                    INVALID_HOST + ": \"" + input.substring(pos, portColonOffset) + '"');
               }
-              if (this.host == null) return ParseResult.INVALID_HOST; // Invalid host.
               pos = componentDelimiterOffset;
               break authority;
           }
@@ -1439,7 +1440,7 @@ ParseResult parse(@Nullable HttpUrl base, String input) {
             input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false, null);
       }
 
-      return ParseResult.SUCCESS;
+      return this;
     }
 
     private void resolvePath(String input, int pos, int limit) {
diff --git a/okhttp/src/main/java/okhttp3/MediaType.java b/okhttp/src/main/java/okhttp3/MediaType.java
index 95194c5711..ddbd8fcb16 100644
--- a/okhttp/src/main/java/okhttp3/MediaType.java
+++ b/okhttp/src/main/java/okhttp3/MediaType.java
@@ -45,12 +45,15 @@ private MediaType(String mediaType, String type, String subtype, @Nullable Strin
   }
 
   /**
-   * Returns a media type for {@code string}, or null if {@code string} is not a well-formed media
-   * type.
+   * Returns a media type for {@code string}.
+   *
+   * @throws IllegalArgumentException if {@code string} is not a well-formed media type.
    */
-  public static @Nullable MediaType parse(String string) {
+  public static MediaType get(String string) {
     Matcher typeSubtype = TYPE_SUBTYPE.matcher(string);
-    if (!typeSubtype.lookingAt()) return null;
+    if (!typeSubtype.lookingAt()) {
+      throw new IllegalArgumentException("No subtype found for: \"" + string + '"');
+    }
     String type = typeSubtype.group(1).toLowerCase(Locale.US);
     String subtype = typeSubtype.group(2).toLowerCase(Locale.US);
 
@@ -58,7 +61,13 @@ private MediaType(String mediaType, String type, String subtype, @Nullable Strin
     Matcher parameter = PARAMETER.matcher(string);
     for (int s = typeSubtype.end(); s < string.length(); s = parameter.end()) {
       parameter.region(s, string.length());
-      if (!parameter.lookingAt()) return null; // This is not a well-formed media type.
+      if (!parameter.lookingAt()) {
+        throw new IllegalArgumentException("Parameter is not formatted correctly: \""
+            + string.substring(s)
+            + "\" for: \""
+            + string
+            + '"');
+      }
 
       String name = parameter.group(1);
       if (name == null || !name.equalsIgnoreCase("charset")) continue;
@@ -74,7 +83,13 @@ private MediaType(String mediaType, String type, String subtype, @Nullable Strin
         charsetParameter = parameter.group(3);
       }
       if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
-        return null; // Multiple different charsets!
+        throw new IllegalArgumentException("Multiple charsets defined: \""
+            + charset
+            + "\" and: \""
+            + charsetParameter
+            + "\" for: \""
+            + string
+            + '"');
       }
       charset = charsetParameter;
     }
@@ -82,6 +97,18 @@ private MediaType(String mediaType, String type, String subtype, @Nullable Strin
     return new MediaType(string, type, subtype, charset);
   }
 
+  /**
+   * Returns a media type for {@code string}, or null if {@code string} is not a well-formed media
+   * type.
+   */
+  public static @Nullable MediaType parse(String string) {
+    try {
+      return get(string);
+    } catch (IllegalArgumentException ignored) {
+      return null;
+    }
+  }
+
   /**
    * Returns the high-level media type, such as "text", "image", "audio", "video", or
    * "application".
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.java b/okhttp/src/main/java/okhttp3/MultipartBody.java
index 09c1eaf2fe..800064cfb5 100644
--- a/okhttp/src/main/java/okhttp3/MultipartBody.java
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.java
@@ -32,34 +32,34 @@
    * need to be bundled in a particular order. Any "multipart" subtypes that an implementation does
    * not recognize must be treated as being of subtype "mixed".
    */
-  public static final MediaType MIXED = MediaType.parse("multipart/mixed");
+  public static final MediaType MIXED = MediaType.get("multipart/mixed");
 
   /**
    * The "multipart/alternative" type is syntactically identical to "multipart/mixed", but the
    * semantics are different. In particular, each of the body parts is an "alternative" version of
    * the same information.
    */
-  public static final MediaType ALTERNATIVE = MediaType.parse("multipart/alternative");
+  public static final MediaType ALTERNATIVE = MediaType.get("multipart/alternative");
 
   /**
    * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
    * particular, in a digest, the default {@code Content-Type} value for a body part is changed from
    * "text/plain" to "message/rfc822".
    */
-  public static final MediaType DIGEST = MediaType.parse("multipart/digest");
+  public static final MediaType DIGEST = MediaType.get("multipart/digest");
 
   /**
    * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
    * particular, in a parallel entity, the order of body parts is not significant.
    */
-  public static final MediaType PARALLEL = MediaType.parse("multipart/parallel");
+  public static final MediaType PARALLEL = MediaType.get("multipart/parallel");
 
   /**
    * The media-type multipart/form-data follows the rules of all multipart MIME data streams as
    * outlined in RFC 2046. In forms, there are a series of fields to be supplied by the user who
    * fills out the form. Each field has a name. Within a given form, the names are unique.
    */
-  public static final MediaType FORM = MediaType.parse("multipart/form-data");
+  public static final MediaType FORM = MediaType.get("multipart/form-data");
 
   private static final byte[] COLONSPACE = {':', ' '};
   private static final byte[] CRLF = {'\r', '\n'};
@@ -74,7 +74,7 @@
   MultipartBody(ByteString boundary, MediaType type, List<Part> parts) {
     this.boundary = boundary;
     this.originalType = type;
-    this.contentType = MediaType.parse(type + "; boundary=" + boundary.utf8());
+    this.contentType = MediaType.get(type + "; boundary=" + boundary.utf8());
     this.parts = Util.immutableList(parts);
   }
 
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 733855b2f9..c86d3b3456 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -15,15 +15,13 @@
  */
 package okhttp3;
 
-import java.net.MalformedURLException;
+import java.io.IOException;
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.net.Socket;
-import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
-import java.security.KeyStore;
+import java.time.Duration;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Random;
@@ -36,7 +34,6 @@
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
@@ -45,11 +42,13 @@
 import okhttp3.internal.connection.RouteDatabase;
 import okhttp3.internal.connection.StreamAllocation;
 import okhttp3.internal.platform.Platform;
+import okhttp3.internal.proxy.NullProxySelector;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.OkHostnameVerifier;
 import okhttp3.internal.ws.RealWebSocket;
 import okio.Sink;
 import okio.Source;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
 
 import static okhttp3.internal.Util.assertionError;
 import static okhttp3.internal.Util.checkDuration;
@@ -181,15 +180,18 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
         tlsConfiguration.apply(sslSocket, isFallback);
       }
 
-      @Override public HttpUrl getHttpUrlChecked(String url)
-          throws MalformedURLException, UnknownHostException {
-        return HttpUrl.getChecked(url);
+      @Override public boolean isInvalidHttpUrlHost(IllegalArgumentException e) {
+        return e.getMessage().startsWith(HttpUrl.Builder.INVALID_HOST);
       }
 
       @Override public StreamAllocation streamAllocation(Call call) {
         return ((RealCall) call).streamAllocation();
       }
 
+      @Override public @Nullable IOException timeoutExit(Call call, @Nullable IOException e) {
+        return ((RealCall) call).timeoutExit(e);
+      }
+
       @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
         return RealCall.newRealCall(client, originalRequest, true);
       }
@@ -208,8 +210,8 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
   final @Nullable Cache cache;
   final @Nullable InternalCache internalCache;
   final SocketFactory socketFactory;
-  final @Nullable SSLSocketFactory sslSocketFactory;
-  final @Nullable CertificateChainCleaner certificateChainCleaner;
+  final SSLSocketFactory sslSocketFactory;
+  final CertificateChainCleaner certificateChainCleaner;
   final HostnameVerifier hostnameVerifier;
   final CertificatePinner certificatePinner;
   final Authenticator proxyAuthenticator;
@@ -219,6 +221,7 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
   final boolean followSslRedirects;
   final boolean followRedirects;
   final boolean retryOnConnectionFailure;
+  final int callTimeout;
   final int connectTimeout;
   final int readTimeout;
   final int writeTimeout;
@@ -251,11 +254,15 @@ public OkHttpClient() {
       this.sslSocketFactory = builder.sslSocketFactory;
       this.certificateChainCleaner = builder.certificateChainCleaner;
     } else {
-      X509TrustManager trustManager = systemDefaultTrustManager();
-      this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);
+      X509TrustManager trustManager = Util.platformTrustManager();
+      this.sslSocketFactory = newSslSocketFactory(trustManager);
       this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
     }
 
+    if (sslSocketFactory != null) {
+      Platform.get().configureSslSocketFactory(sslSocketFactory);
+    }
+
     this.hostnameVerifier = builder.hostnameVerifier;
     this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
         certificateChainCleaner);
@@ -266,6 +273,7 @@ public OkHttpClient() {
     this.followSslRedirects = builder.followSslRedirects;
     this.followRedirects = builder.followRedirects;
     this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
+    this.callTimeout = builder.callTimeout;
     this.connectTimeout = builder.connectTimeout;
     this.readTimeout = builder.readTimeout;
     this.writeTimeout = builder.writeTimeout;
@@ -279,23 +287,7 @@ public OkHttpClient() {
     }
   }
 
-  private X509TrustManager systemDefaultTrustManager() {
-    try {
-      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-          TrustManagerFactory.getDefaultAlgorithm());
-      trustManagerFactory.init((KeyStore) null);
-      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-        throw new IllegalStateException("Unexpected default trust managers:"
-            + Arrays.toString(trustManagers));
-      }
-      return (X509TrustManager) trustManagers[0];
-    } catch (GeneralSecurityException e) {
-      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
-    }
-  }
-
-  private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustManager) {
+  private static SSLSocketFactory newSslSocketFactory(X509TrustManager trustManager) {
     try {
       SSLContext sslContext = Platform.get().getSSLContext();
       sslContext.init(null, new TrustManager[] { trustManager }, null);
@@ -305,6 +297,11 @@ private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustMan
     }
   }
 
+  /** Default call timeout (in milliseconds). */
+  public int callTimeoutMillis() {
+    return callTimeout;
+  }
+
   /** Default connect timeout (in milliseconds). */
   public int connectTimeoutMillis() {
     return connectTimeout;
@@ -325,7 +322,7 @@ public int pingIntervalMillis() {
     return pingInterval;
   }
 
-  public Proxy proxy() {
+  public @Nullable Proxy proxy() {
     return proxy;
   }
 
@@ -337,7 +334,7 @@ public CookieJar cookieJar() {
     return cookieJar;
   }
 
-  public Cache cache() {
+  public @Nullable Cache cache() {
     return cache;
   }
 
@@ -434,7 +431,7 @@ public Dispatcher dispatcher() {
    * Uses {@code request} to connect a new web socket.
    */
   @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {
-    RealWebSocket webSocket = new RealWebSocket(request, listener, new Random());
+    RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval);
     webSocket.connect(this);
     return webSocket;
   }
@@ -467,6 +464,7 @@ public Builder newBuilder() {
     boolean followSslRedirects;
     boolean followRedirects;
     boolean retryOnConnectionFailure;
+    int callTimeout;
     int connectTimeout;
     int readTimeout;
     int writeTimeout;
@@ -478,6 +476,9 @@ public Builder() {
       connectionSpecs = DEFAULT_CONNECTION_SPECS;
       eventListenerFactory = EventListener.factory(EventListener.NONE);
       proxySelector = ProxySelector.getDefault();
+      if (proxySelector == null) {
+        proxySelector = new NullProxySelector();
+      }
       cookieJar = CookieJar.NO_COOKIES;
       socketFactory = SocketFactory.getDefault();
       hostnameVerifier = OkHostnameVerifier.INSTANCE;
@@ -489,6 +490,7 @@ public Builder() {
       followSslRedirects = true;
       followRedirects = true;
       retryOnConnectionFailure = true;
+      callTimeout = 0;
       connectTimeout = 10_000;
       readTimeout = 10_000;
       writeTimeout = 10_000;
@@ -519,18 +521,46 @@ public Builder() {
       this.followSslRedirects = okHttpClient.followSslRedirects;
       this.followRedirects = okHttpClient.followRedirects;
       this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
+      this.callTimeout = okHttpClient.callTimeout;
       this.connectTimeout = okHttpClient.connectTimeout;
       this.readTimeout = okHttpClient.readTimeout;
       this.writeTimeout = okHttpClient.writeTimeout;
       this.pingInterval = okHttpClient.pingInterval;
     }
 
+    /**
+     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+     * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
+     * body, server processing, and reading the response body. If the call requires redirects or
+     * retries all must complete within one timeout period.
+     */
+    public Builder callTimeout(long timeout, TimeUnit unit) {
+      callTimeout = checkDuration("timeout", timeout, unit);
+      return this;
+    }
+
+    /**
+     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+     * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
+     * body, server processing, and reading the response body. If the call requires redirects or
+     * retries all must complete within one timeout period.
+     */
+    @IgnoreJRERequirement
+    public Builder callTimeout(Duration duration) {
+      callTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+      return this;
+    }
+
     /**
      * Sets the default connect timeout for new connections. A value of 0 means no timeout,
      * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
      * milliseconds.
      *
-     * <p>The connectTimeout is applied when connecting a TCP socket to the target host.
+     * <p>The connect timeout is applied when connecting a TCP socket to the target host.
      * The default value is 10 seconds.
      */
     public Builder connectTimeout(long timeout, TimeUnit unit) {
@@ -538,6 +568,20 @@ public Builder connectTimeout(long timeout, TimeUnit unit) {
       return this;
     }
 
+    /**
+     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
+     * milliseconds.
+     *
+     * <p>The connect timeout is applied when connecting a TCP socket to the target host.
+     * The default value is 10 seconds.
+     */
+    @IgnoreJRERequirement
+    public Builder connectTimeout(Duration duration) {
+      connectTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+      return this;
+    }
+
     /**
      * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
      * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
@@ -553,6 +597,22 @@ public Builder readTimeout(long timeout, TimeUnit unit) {
       return this;
     }
 
+    /**
+     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
+     * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
+     *
+     * @see Socket#setSoTimeout(int)
+     * @see Source#timeout()
+     */
+    @IgnoreJRERequirement
+    public Builder readTimeout(Duration duration) {
+      readTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+      return this;
+    }
+
     /**
      * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
      * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
@@ -568,10 +628,30 @@ public Builder writeTimeout(long timeout, TimeUnit unit) {
     }
 
     /**
-     * Sets the interval between web socket pings initiated by this client. Use this to
-     * automatically send web socket ping frames until either the web socket fails or it is closed.
-     * This keeps the connection alive and may detect connectivity failures early. No timeouts are
-     * enforced on the acknowledging pongs.
+     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The write timeout is applied for individual write IO operations.
+     * The default value is 10 seconds.
+     *
+     * @see Sink#timeout()
+     */
+    @IgnoreJRERequirement
+    public Builder writeTimeout(Duration duration) {
+      writeTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+      return this;
+    }
+
+    /**
+     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+     * automatically send ping frames until either the connection fails or it is closed. This keeps
+     * the connection alive and may detect connectivity failures.
+     *
+     * <p>If the server does not respond to each ping with a pong within {@code interval}, this
+     * client will assume that connectivity has been lost. When this happens on a web socket the
+     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
+     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
+     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
      *
      * <p>The default value of 0 disables client-initiated pings.
      */
@@ -580,10 +660,29 @@ public Builder pingInterval(long interval, TimeUnit unit) {
       return this;
     }
 
+    /**
+     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+     * automatically send ping frames until either the connection fails or it is closed. This keeps
+     * the connection alive and may detect connectivity failures.
+     *
+     * <p>If the server does not respond to each ping with a pong within {@code interval}, this
+     * client will assume that connectivity has been lost. When this happens on a web socket the
+     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
+     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
+     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
+     *
+     * <p>The default value of 0 disables client-initiated pings.
+     */
+    @IgnoreJRERequirement
+    public Builder pingInterval(Duration duration) {
+      pingInterval = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
+      return this;
+    }
+
     /**
      * Sets the HTTP proxy that will be used by connections created by this client. This takes
      * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
-     * it is by default). To disable proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
+     * it is by default). To disable proxy use completely, call {@code proxy(Proxy.NO_PROXY)}.
      */
     public Builder proxy(@Nullable Proxy proxy) {
       this.proxy = proxy;
@@ -599,6 +698,7 @@ public Builder proxy(@Nullable Proxy proxy) {
      * be used.
      */
     public Builder proxySelector(ProxySelector proxySelector) {
+      if (proxySelector == null) throw new NullPointerException("proxySelector == null");
       this.proxySelector = proxySelector;
       return this;
     }
@@ -649,6 +749,9 @@ public Builder dns(Dns dns) {
      */
     public Builder socketFactory(SocketFactory socketFactory) {
       if (socketFactory == null) throw new NullPointerException("socketFactory == null");
+      if (socketFactory instanceof SSLSocketFactory) {
+        throw new IllegalArgumentException("socketFactory instanceof SSLSocketFactory");
+      }
       this.socketFactory = socketFactory;
       return this;
     }
@@ -695,7 +798,7 @@ public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
      *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
      *
      *   OkHttpClient client = new OkHttpClient.Builder()
-     *       .sslSocketFactory(sslSocketFactory, trustManager);
+     *       .sslSocketFactory(sslSocketFactory, trustManager)
      *       .build();
      * }</pre>
      */
@@ -825,7 +928,9 @@ public Builder dispatcher(Dispatcher dispatcher) {
      *
      * <ul>
      *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-     *     <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
+     *     <li><a href="https://tools.ietf.org/html/rfc7540">h2</a>
+     *     <li><a href="https://tools.ietf.org/html/rfc7540#section-3.4">h2 with prior knowledge
+     *         (cleartext only)</a>
      * </ul>
      *
      * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
@@ -833,22 +938,30 @@ public Builder dispatcher(Dispatcher dispatcher) {
      *
      * <p>If multiple protocols are specified, <a
      * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
-     * negotiate a transport.
+     * negotiate a transport. Protocol negotiation is only attempted for HTTPS URLs.
      *
      * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
-     * HTTP/1.1} only. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
+     * HTTP/1.1}. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
      * Response#protocol()}.
      *
-     * @param protocols the protocols to use, in order of preference. The list must contain {@link
-     * Protocol#HTTP_1_1}. It must not contain null or {@link Protocol#HTTP_1_0}.
+     * @param protocols the protocols to use, in order of preference. If the list contains {@link
+     *     Protocol#H2_PRIOR_KNOWLEDGE} then that must be the only protocol and HTTPS URLs will not
+     *     be supported. Otherwise the list must contain {@link Protocol#HTTP_1_1}. The list must
+     *     not contain null or {@link Protocol#HTTP_1_0}.
      */
     public Builder protocols(List<Protocol> protocols) {
       // Create a private copy of the list.
       protocols = new ArrayList<>(protocols);
 
       // Validate that the list has everything we require and nothing we forbid.
-      if (!protocols.contains(Protocol.HTTP_1_1)) {
-        throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
+      if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
+          && !protocols.contains(Protocol.HTTP_1_1)) {
+        throw new IllegalArgumentException(
+            "protocols must contain h2_prior_knowledge or http/1.1: " + protocols);
+      }
+      if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
+        throw new IllegalArgumentException(
+            "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
       }
       if (protocols.contains(Protocol.HTTP_1_0)) {
         throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
diff --git a/okhttp/src/main/java/okhttp3/Protocol.java b/okhttp/src/main/java/okhttp3/Protocol.java
index 0723c2b858..a96070ed59 100644
--- a/okhttp/src/main/java/okhttp3/Protocol.java
+++ b/okhttp/src/main/java/okhttp3/Protocol.java
@@ -61,6 +61,15 @@
    */
   HTTP_2("h2"),
 
+  /**
+   * Cleartext HTTP/2 with no "upgrade" round trip. This option requires the client to have prior
+   * knowledge that the server supports cleartext HTTP/2.
+   *
+   * @see <a href="https://tools.ietf.org/html/rfc7540#section-3.4">Starting HTTP/2 with Prior
+   * Knowledge</a>
+   */
+  H2_PRIOR_KNOWLEDGE("h2_prior_knowledge"),
+
   /**
    * QUIC (Quick UDP Internet Connection) is a new multiplexed and secure transport atop UDP,
    * designed from the ground up and optimized for HTTP/2 semantics.
@@ -86,6 +95,7 @@ public static Protocol get(String protocol) throws IOException {
     // Unroll the loop over values() to save an allocation.
     if (protocol.equals(HTTP_1_0.protocol)) return HTTP_1_0;
     if (protocol.equals(HTTP_1_1.protocol)) return HTTP_1_1;
+    if (protocol.equals(H2_PRIOR_KNOWLEDGE.protocol)) return H2_PRIOR_KNOWLEDGE;
     if (protocol.equals(HTTP_2.protocol)) return HTTP_2;
     if (protocol.equals(SPDY_3.protocol)) return SPDY_3;
     if (protocol.equals(QUIC.protocol)) return QUIC;
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 808b3dc7ba..a9ba5be366 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -16,8 +16,12 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.RejectedExecutionException;
+import javax.annotation.Nullable;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.cache.CacheInterceptor;
 import okhttp3.internal.connection.ConnectInterceptor;
@@ -27,18 +31,22 @@
 import okhttp3.internal.http.RealInterceptorChain;
 import okhttp3.internal.http.RetryAndFollowUpInterceptor;
 import okhttp3.internal.platform.Platform;
+import okio.AsyncTimeout;
+import okio.Timeout;
 
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static okhttp3.internal.platform.Platform.INFO;
 
 final class RealCall implements Call {
   final OkHttpClient client;
   final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
+  final AsyncTimeout timeout;
 
   /**
    * There is a cycle between the {@link Call} and {@link EventListener} that makes this awkward.
    * This will be set after we create the call instance then create the event listener instance.
    */
-  private EventListener eventListener;
+  private @Nullable EventListener eventListener;
 
   /** The application's original request unadulterated by redirects or auth headers. */
   final Request originalRequest;
@@ -52,6 +60,12 @@ private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSoc
     this.originalRequest = originalRequest;
     this.forWebSocket = forWebSocket;
     this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
+    this.timeout = new AsyncTimeout() {
+      @Override protected void timedOut() {
+        cancel();
+      }
+    };
+    this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);
   }
 
   static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
@@ -71,6 +85,7 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
       executed = true;
     }
     captureCallStackTrace();
+    timeout.enter();
     eventListener.callStart(this);
     try {
       client.dispatcher().executed(this);
@@ -78,6 +93,7 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
       if (result == null) throw new IOException("Canceled");
       return result;
     } catch (IOException e) {
+      e = timeoutExit(e);
       eventListener.callFailed(this, e);
       throw e;
     } finally {
@@ -85,6 +101,16 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
     }
   }
 
+  @Nullable IOException timeoutExit(@Nullable IOException cause) {
+    if (!timeout.exit()) return cause;
+
+    InterruptedIOException e = new InterruptedIOException("timeout");
+    if (cause != null) {
+      e.initCause(cause);
+    }
+    return e;
+  }
+
   private void captureCallStackTrace() {
     Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
     retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
@@ -104,6 +130,10 @@ private void captureCallStackTrace() {
     retryAndFollowUpInterceptor.cancel();
   }
 
+  @Override public Timeout timeout() {
+    return timeout;
+  }
+
   @Override public synchronized boolean isExecuted() {
     return executed;
   }
@@ -141,8 +171,31 @@ RealCall get() {
       return RealCall.this;
     }
 
+    /**
+     * Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up
+     * if the executor has been shut down by reporting the call as failed.
+     */
+    void executeOn(ExecutorService executorService) {
+      assert (!Thread.holdsLock(client.dispatcher()));
+      boolean success = false;
+      try {
+        executorService.execute(this);
+        success = true;
+      } catch (RejectedExecutionException e) {
+        InterruptedIOException ioException = new InterruptedIOException("executor rejected");
+        ioException.initCause(e);
+        eventListener.callFailed(RealCall.this, ioException);
+        responseCallback.onFailure(RealCall.this, ioException);
+      } finally {
+        if (!success) {
+          client.dispatcher().finished(this); // This call is no longer running!
+        }
+      }
+    }
+
     @Override protected void execute() {
       boolean signalledCallback = false;
+      timeout.enter();
       try {
         Response response = getResponseWithInterceptorChain();
         if (retryAndFollowUpInterceptor.isCanceled()) {
@@ -153,6 +206,7 @@ RealCall get() {
           responseCallback.onResponse(RealCall.this, response);
         }
       } catch (IOException e) {
+        e = timeoutExit(e);
         if (signalledCallback) {
           // Do not signal the callback twice!
           Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index 6687dd3f9a..df0bebd021 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -16,7 +16,10 @@
 package okhttp3;
 
 import java.net.URL;
+import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpMethod;
@@ -30,16 +33,16 @@
   final String method;
   final Headers headers;
   final @Nullable RequestBody body;
-  final Object tag;
+  final Map<Class<?>, Object> tags;
 
-  private volatile CacheControl cacheControl; // Lazily initialized.
+  private volatile @Nullable CacheControl cacheControl; // Lazily initialized.
 
   Request(Builder builder) {
     this.url = builder.url;
     this.method = builder.method;
     this.headers = builder.headers.build();
     this.body = builder.body;
-    this.tag = builder.tag != null ? builder.tag : this;
+    this.tags = Util.immutableMap(builder.tags);
   }
 
   public HttpUrl url() {
@@ -66,8 +69,24 @@ public Headers headers() {
     return body;
   }
 
-  public Object tag() {
-    return tag;
+  /**
+   * Returns the tag attached with {@code Object.class} as a key, or null if no tag is attached with
+   * that key.
+   *
+   * <p>Prior to OkHttp 3.11, this method never returned null if no tag was attached. Instead it
+   * returned either this request, or the request upon which this request was derived with {@link
+   * #newBuilder()}.
+   */
+  public @Nullable Object tag() {
+    return tag(Object.class);
+  }
+
+  /**
+   * Returns the tag attached with {@code type} as a key, or null if no tag is attached with that
+   * key.
+   */
+  public @Nullable <T> T tag(Class<? extends T> type) {
+    return type.cast(tags.get(type));
   }
 
   public Builder newBuilder() {
@@ -92,17 +111,19 @@ public boolean isHttps() {
         + method
         + ", url="
         + url
-        + ", tag="
-        + (tag != this ? tag : null)
+        + ", tags="
+        + tags
         + '}';
   }
 
   public static class Builder {
-    HttpUrl url;
+    @Nullable HttpUrl url;
     String method;
     Headers.Builder headers;
-    RequestBody body;
-    Object tag;
+    @Nullable RequestBody body;
+
+    /** A mutable map of tags, or an immutable empty map if we don't have any. */
+    Map<Class<?>, Object> tags = Collections.emptyMap();
 
     public Builder() {
       this.method = "GET";
@@ -113,7 +134,9 @@ public Builder() {
       this.url = request.url;
       this.method = request.method;
       this.body = request.body;
-      this.tag = request.tag;
+      this.tags = request.tags.isEmpty()
+          ? Collections.<Class<?>, Object>emptyMap()
+          : new LinkedHashMap<>(request.tags);
       this.headers = request.headers.newBuilder();
     }
 
@@ -139,9 +162,7 @@ public Builder url(String url) {
         url = "https:" + url.substring(4);
       }
 
-      HttpUrl parsed = HttpUrl.parse(url);
-      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
-      return url(parsed);
+      return url(HttpUrl.get(url));
     }
 
     /**
@@ -152,9 +173,7 @@ public Builder url(String url) {
      */
     public Builder url(URL url) {
       if (url == null) throw new NullPointerException("url == null");
-      HttpUrl parsed = HttpUrl.get(url);
-      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
-      return url(parsed);
+      return url(HttpUrl.get(url.toString()));
     }
 
     /**
@@ -178,6 +197,7 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
+    /** Removes all headers named {@code name} on this builder. */
     public Builder removeHeader(String name) {
       headers.removeAll(name);
       return this;
@@ -242,12 +262,29 @@ public Builder method(String method, @Nullable RequestBody body) {
       return this;
     }
 
+    /** Attaches {@code tag} to the request using {@code Object.class} as a key. */
+    public Builder tag(@Nullable Object tag) {
+      return tag(Object.class, tag);
+    }
+
     /**
-     * Attaches {@code tag} to the request. It can be used later to cancel the request. If the tag
-     * is unspecified or null, the request is canceled by using the request itself as the tag.
+     * Attaches {@code tag} to the request using {@code type} as a key. Tags can be read from a
+     * request using {@link Request#tag}. Use null to remove any existing tag assigned for {@code
+     * type}.
+     *
+     * <p>Use this API to attach timing, debugging, or other application data to a request so that
+     * you may read it in interceptors, event listeners, or callbacks.
      */
-    public Builder tag(Object tag) {
-      this.tag = tag;
+    public <T> Builder tag(Class<? super T> type, @Nullable T tag) {
+      if (type == null) throw new NullPointerException("type == null");
+
+      if (tag == null) {
+        tags.remove(type);
+      } else {
+        if (tags.isEmpty()) tags = new LinkedHashMap<>();
+        tags.put(type, type.cast(tag));
+      }
+
       return this;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/RequestBody.java b/okhttp/src/main/java/okhttp3/RequestBody.java
index 3cb29477d3..baf33ce6c6 100644
--- a/okhttp/src/main/java/okhttp3/RequestBody.java
+++ b/okhttp/src/main/java/okhttp3/RequestBody.java
@@ -102,7 +102,7 @@ public static RequestBody create(final @Nullable MediaType contentType, final by
 
   /** Returns a new request body that transmits the content of {@code file}. */
   public static RequestBody create(final @Nullable MediaType contentType, final File file) {
-    if (file == null) throw new NullPointerException("content == null");
+    if (file == null) throw new NullPointerException("file == null");
 
     return new RequestBody() {
       @Override public @Nullable MediaType contentType() {
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
index 1e3ab454a5..c48c81484f 100644
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -54,7 +54,7 @@
   final long sentRequestAtMillis;
   final long receivedResponseAtMillis;
 
-  private volatile CacheControl cacheControl; // Lazily initialized.
+  private volatile @Nullable CacheControl cacheControl; // Lazily initialized.
 
   Response(Builder builder) {
     this.request = builder.request;
@@ -115,7 +115,7 @@ public String message() {
    * Returns the TLS handshake of the connection that carried this response, or null if the response
    * was received without TLS.
    */
-  public Handshake handshake() {
+  public @Nullable Handshake handshake() {
     return handshake;
   }
 
@@ -148,21 +148,11 @@ public Headers headers() {
    * applications should set a modest limit on {@code byteCount}, such as 1 MiB.
    */
   public ResponseBody peekBody(long byteCount) throws IOException {
-    BufferedSource source = body.source();
-    source.request(byteCount);
-    Buffer copy = source.buffer().clone();
-
-    // There may be more than byteCount bytes in source.buffer(). If there is, return a prefix.
-    Buffer result;
-    if (copy.size() > byteCount) {
-      result = new Buffer();
-      result.write(copy, byteCount);
-      copy.clear();
-    } else {
-      result = copy;
-    }
-
-    return ResponseBody.create(body.contentType(), result.size(), result);
+    BufferedSource peeked = body.source().peek();
+    Buffer buffer = new Buffer();
+    peeked.request(byteCount);
+    buffer.write(peeked, Math.min(byteCount, peeked.getBuffer().size()));
+    return ResponseBody.create(body.contentType(), buffer.size(), buffer);
   }
 
   /**
@@ -225,10 +215,15 @@ public boolean isRedirect() {
   }
 
   /**
-   * Returns the authorization challenges appropriate for this response's code. If the response code
-   * is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the response code is
-   * 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges. Otherwise this
-   * returns an empty list of challenges.
+   * Returns the RFC 7235 authorization challenges appropriate for this response's code. If the
+   * response code is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the
+   * response code is 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges.
+   * Otherwise this returns an empty list of challenges.
+   *
+   * <p>If a challenge uses the {@code token68} variant instead of auth params, there is exactly one
+   * auth param in the challenge at key {@code null}. Invalid headers and challenges are ignored.
+   * No semantic validation is done, for example that {@code Basic} auth must have a {@code realm}
+   * auth param, this is up to the caller that interprets these challenges.
    */
   public List<Challenge> challenges() {
     String responseField;
@@ -296,16 +291,16 @@ public long receivedResponseAtMillis() {
   }
 
   public static class Builder {
-    Request request;
-    Protocol protocol;
+    @Nullable Request request;
+    @Nullable Protocol protocol;
     int code = -1;
     String message;
     @Nullable Handshake handshake;
     Headers.Builder headers;
-    ResponseBody body;
-    Response networkResponse;
-    Response cacheResponse;
-    Response priorResponse;
+    @Nullable ResponseBody body;
+    @Nullable Response networkResponse;
+    @Nullable Response cacheResponse;
+    @Nullable Response priorResponse;
     long sentRequestAtMillis;
     long receivedResponseAtMillis;
 
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
index 2a78d7fbd8..9b06b6ea8f 100644
--- a/okhttp/src/main/java/okhttp3/ResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.java
@@ -25,6 +25,7 @@
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
+import okio.ByteString;
 
 import static okhttp3.internal.Util.UTF_8;
 
@@ -101,7 +102,7 @@
  */
 public abstract class ResponseBody implements Closeable {
   /** Multiple calls to {@link #charStream()} must return the same instance. */
-  private Reader reader;
+  private @Nullable Reader reader;
 
   public abstract @Nullable MediaType contentType();
 
@@ -210,6 +211,12 @@ public static ResponseBody create(final @Nullable MediaType contentType, byte[]
     return create(contentType, content.length, buffer);
   }
 
+  /** Returns a new response body that transmits {@code content}. */
+  public static ResponseBody create(@Nullable MediaType contentType, ByteString content) {
+    Buffer buffer = new Buffer().write(content);
+    return create(contentType, content.size(), buffer);
+  }
+
   /** Returns a new response body that transmits {@code content}. */
   public static ResponseBody create(final @Nullable MediaType contentType,
       final long contentLength, final BufferedSource content) {
@@ -234,7 +241,7 @@ public static ResponseBody create(final @Nullable MediaType contentType,
     private final Charset charset;
 
     private boolean closed;
-    private Reader delegate;
+    private @Nullable Reader delegate;
 
     BomAwareReader(BufferedSource source, Charset charset) {
       this.source = source;
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index 1be96fd3e7..62fcfaa732 100644
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -15,16 +15,15 @@
  */
 package okhttp3.internal;
 
-import java.net.MalformedURLException;
+import java.io.IOException;
 import java.net.Socket;
-import java.net.UnknownHostException;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Address;
 import okhttp3.Call;
 import okhttp3.ConnectionPool;
 import okhttp3.ConnectionSpec;
 import okhttp3.Headers;
-import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
@@ -72,10 +71,11 @@ public abstract Socket deduplicate(
   public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
       boolean isFallback);
 
-  public abstract HttpUrl getHttpUrlChecked(String url)
-      throws MalformedURLException, UnknownHostException;
+  public abstract boolean isInvalidHttpUrlHost(IllegalArgumentException e);
 
   public abstract StreamAllocation streamAllocation(Call call);
 
+  public abstract @Nullable IOException timeoutExit(Call call, @Nullable IOException e);
+
   public abstract Call newWebSocketCall(OkHttpClient client, Request request);
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 85c6cabcf1..66e559cc18 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -18,26 +18,37 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.net.IDN;
 import java.net.InetAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.UnknownHostException;
 import java.nio.charset.Charset;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map;
 import java.util.TimeZone;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
+import okhttp3.internal.http2.Header;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -73,6 +84,27 @@
     }
   };
 
+  private static final Method addSuppressedExceptionMethod;
+
+  static {
+    Method m;
+    try {
+      m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
+    } catch (Exception e) {
+      m = null;
+    }
+    addSuppressedExceptionMethod = m;
+  }
+
+  public static void addSuppressedIfPossible(Throwable e, Throwable suppressed) {
+    if (addSuppressedExceptionMethod != null) {
+      try {
+        addSuppressedExceptionMethod.invoke(e, suppressed);
+      } catch (InvocationTargetException | IllegalAccessException ignored) {
+      }
+    }
+  }
+
   /**
    * Quick and dirty pattern to differentiate IP addresses from hostnames. This is an approximation
    * of Android's private InetAddress#isNumeric API.
@@ -192,6 +224,13 @@ public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) th
     return Collections.unmodifiableList(new ArrayList<>(list));
   }
 
+  /** Returns an immutable copy of {@code map}. */
+  public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {
+    return map.isEmpty()
+        ? Collections.<K, V>emptyMap()
+        : Collections.unmodifiableMap(new LinkedHashMap<>(map));
+  }
+
   /** Returns an immutable list containing {@code elements}. */
   public static <T> List<T> immutableList(T... elements) {
     return Collections.unmodifiableList(Arrays.asList(elements.clone()));
@@ -256,23 +295,6 @@ public static String hostHeader(HttpUrl url, boolean includeDefaultPort) {
         : host;
   }
 
-  /** Returns {@code s} with control characters and non-ASCII characters replaced with '?'. */
-  public static String toHumanReadableAscii(String s) {
-    for (int i = 0, length = s.length(), c; i < length; i += Character.charCount(c)) {
-      c = s.codePointAt(i);
-      if (c > '\u001f' && c < '\u007f') continue;
-
-      Buffer buffer = new Buffer();
-      buffer.writeUtf8(s, 0, i);
-      for (int j = i; j < length; j += Character.charCount(c)) {
-        c = s.codePointAt(j);
-        buffer.writeUtf8CodePoint(c > '\u001f' && c < '\u007f' ? c : '?');
-      }
-      return buffer.readUtf8();
-    }
-    return s;
-  }
-
   /**
    * Returns true if {@code e} is due to a firmware bug fixed after Android 4.2.2.
    * https://code.google.com/p/android/issues/detail?id=54072
@@ -636,4 +658,28 @@ private static String inet6AddressToAscii(byte[] address) {
     }
     return result.readUtf8();
   }
+
+  public static X509TrustManager platformTrustManager() {
+    try {
+      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+          TrustManagerFactory.getDefaultAlgorithm());
+      trustManagerFactory.init((KeyStore) null);
+      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+        throw new IllegalStateException("Unexpected default trust managers:"
+            + Arrays.toString(trustManagers));
+      }
+      return (X509TrustManager) trustManagers[0];
+    } catch (GeneralSecurityException e) {
+      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
+    }
+  }
+
+  public static Headers toHeaders(List<Header> headerBlock) {
+    Headers.Builder builder = new Headers.Builder();
+    for (Header header : headerBlock) {
+      Internal.instance.addLenient(builder, header.name.utf8(), header.value.utf8());
+    }
+    return builder.build();
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java b/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java
new file mode 100644
index 0000000000..e97bb4d9cb
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.internal.annotations;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierDefault;
+
+/**
+ * Extends {@code ParametersAreNonnullByDefault} to also apply to Method results and fields.
+ *
+ * @see javax.annotation.ParametersAreNonnullByDefault
+ */
+@Documented
+@Nonnull
+@TypeQualifierDefault({
+    ElementType.FIELD,
+    ElementType.METHOD,
+    ElementType.PARAMETER
+})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface EverythingIsNonNull { }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
index 3ae1926650..c7fb69ceba 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -205,9 +205,6 @@ private CacheStrategy getCandidate() {
       }
 
       CacheControl responseCaching = cacheResponse.cacheControl();
-      if (responseCaching.immutable()) {
-        return new CacheStrategy(null, cacheResponse);
-      }
 
       long ageMillis = cacheResponseAge();
       long freshMillis = computeFreshnessLifetime();
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
index b1326cddc9..b4ce63012f 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
@@ -17,7 +17,6 @@
 
 import java.io.EOFException;
 import java.io.IOException;
-import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
 import okio.Buffer;
 import okio.Okio;
@@ -35,10 +34,6 @@
  * </ul>
  */
 final class FileOperator {
-  private static final int BUFFER_SIZE = 8192;
-
-  private final byte[] byteArray = new byte[BUFFER_SIZE];
-  private final ByteBuffer byteBuffer = ByteBuffer.wrap(byteArray);
   private final FileChannel fileChannel;
 
   FileOperator(FileChannel fileChannel) {
@@ -50,22 +45,9 @@ public void write(long pos, Buffer source, long byteCount) throws IOException {
     if (byteCount < 0 || byteCount > source.size()) throw new IndexOutOfBoundsException();
 
     while (byteCount > 0L) {
-      try {
-        // Write bytes to the byte[], and tell the ByteBuffer wrapper about 'em.
-        int toWrite = (int) Math.min(BUFFER_SIZE, byteCount);
-        source.read(byteArray, 0, toWrite);
-        byteBuffer.limit(toWrite);
-
-        // Copy bytes from the ByteBuffer to the file.
-        do {
-          int bytesWritten = fileChannel.write(byteBuffer, pos);
-          pos += bytesWritten;
-        } while (byteBuffer.hasRemaining());
-
-        byteCount -= toWrite;
-      } finally {
-        byteBuffer.clear();
-      }
+      long bytesWritten = fileChannel.transferFrom(source, pos, byteCount);
+      pos += bytesWritten;
+      byteCount -= bytesWritten;
     }
   }
 
@@ -78,19 +60,9 @@ public void read(long pos, Buffer sink, long byteCount) throws IOException {
     if (byteCount < 0) throw new IndexOutOfBoundsException();
 
     while (byteCount > 0L) {
-      try {
-        // Read up to byteCount bytes.
-        byteBuffer.limit((int) Math.min(BUFFER_SIZE, byteCount));
-        if (fileChannel.read(byteBuffer, pos) == -1) throw new EOFException();
-        int bytesRead = byteBuffer.position();
-
-        // Write those bytes to sink.
-        sink.write(byteArray, 0, bytesRead);
-        pos += bytesRead;
-        byteCount -= bytesRead;
-      } finally {
-        byteBuffer.clear();
-      }
+      long bytesRead = fileChannel.transferTo(pos, byteCount, sink);
+      pos += bytesRead;
+      byteCount -= bytesRead;
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
index 0b438bfa1f..34a116464d 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
@@ -22,6 +22,7 @@
 import java.security.cert.CertificateException;
 import java.util.Arrays;
 import java.util.List;
+import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLProtocolException;
@@ -123,7 +124,9 @@ public boolean connectionFailed(IOException e) {
 
     // On Android, SSLProtocolExceptions can be caused by TLS_FALLBACK_SCSV failures, which means we
     // retry those when we probably should not.
-    return (e instanceof SSLHandshakeException || e instanceof SSLProtocolException);
+    return (e instanceof SSLHandshakeException
+        || e instanceof SSLProtocolException
+        || e instanceof SSLException);
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index b3d8924ae8..25445fac50 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -19,6 +19,7 @@
 import java.io.IOException;
 import java.lang.ref.Reference;
 import java.net.ConnectException;
+import java.net.HttpURLConnection;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.Socket;
@@ -128,7 +129,8 @@ public static RealConnection testConnection(
   }
 
   public void connect(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled, Call call, EventListener eventListener) {
+      int pingIntervalMillis, boolean connectionRetryEnabled, Call call,
+      EventListener eventListener) {
     if (protocol != null) throw new IllegalStateException("already connected");
 
     RouteException routeException = null;
@@ -145,6 +147,11 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
         throw new RouteException(new UnknownServiceException(
             "CLEARTEXT communication to " + host + " not permitted by network security policy"));
       }
+    } else {
+      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
+        throw new RouteException(new UnknownServiceException(
+            "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS"));
+      }
     }
 
     while (true) {
@@ -158,7 +165,7 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
         } else {
           connectSocket(connectTimeout, readTimeout, call, eventListener);
         }
-        establishProtocol(connectionSpecSelector, call, eventListener);
+        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);
         eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);
         break;
       } catch (IOException e) {
@@ -257,11 +264,18 @@ private void connectSocket(int connectTimeout, int readTimeout, Call call,
     }
   }
 
-  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector, Call call,
-      EventListener eventListener) throws IOException {
+  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector,
+      int pingIntervalMillis, Call call, EventListener eventListener) throws IOException {
     if (route.address().sslSocketFactory() == null) {
-      protocol = Protocol.HTTP_1_1;
+      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
+        socket = rawSocket;
+        protocol = Protocol.H2_PRIOR_KNOWLEDGE;
+        startHttp2(pingIntervalMillis);
+        return;
+      }
+
       socket = rawSocket;
+      protocol = Protocol.HTTP_1_1;
       return;
     }
 
@@ -270,15 +284,20 @@ private void establishProtocol(ConnectionSpecSelector connectionSpecSelector, Ca
     eventListener.secureConnectEnd(call, handshake);
 
     if (protocol == Protocol.HTTP_2) {
-      socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.
-      http2Connection = new Http2Connection.Builder(true)
-          .socket(socket, route.address().url().host(), source, sink)
-          .listener(this)
-          .build();
-      http2Connection.start();
+      startHttp2(pingIntervalMillis);
     }
   }
 
+  private void startHttp2(int pingIntervalMillis) throws IOException {
+    socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.
+    http2Connection = new Http2Connection.Builder(true)
+        .socket(socket, route.address().url().host(), source, sink)
+        .listener(this)
+        .pingIntervalMillis(pingIntervalMillis)
+        .build();
+    http2Connection.start();
+  }
+
   private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException {
     Address address = route.address();
     SSLSocketFactory sslSocketFactory = address.sslSocketFactory();
@@ -300,13 +319,10 @@ private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IO
       sslSocket.startHandshake();
       // block for session establishment
       SSLSession sslSocketSession = sslSocket.getSession();
-      if (!isValid(sslSocketSession)) {
-        throw new IOException("a valid ssl session was not established");
-      }
       Handshake unverifiedHandshake = Handshake.get(sslSocketSession);
 
       // Verify that the socket's certificates are acceptable for the target host.
-      if (!address.hostnameVerifier().verify(address.url().host(), sslSocket.getSession())) {
+      if (!address.hostnameVerifier().verify(address.url().host(), sslSocketSession)) {
         X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0);
         throw new SSLPeerUnverifiedException("Hostname " + address.url().host() + " not verified:"
             + "\n    certificate: " + CertificatePinner.pin(cert)
@@ -343,12 +359,6 @@ private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IO
     }
   }
 
-  private boolean isValid(SSLSession sslSocketSession) {
-    // don't use SslSocket.getSession since for failed results it returns SSL_NULL_WITH_NULL_NULL
-    return !"NONE".equals(sslSocketSession.getProtocol()) && !"SSL_NULL_WITH_NULL_NULL".equals(
-        sslSocketSession.getCipherSuite());
-  }
-
   /**
    * To make an HTTPS connection over an HTTP proxy, send an unencrypted CONNECT request to create
    * the proxy connection. This may need to be retried if the proxy requires authorization.
@@ -407,14 +417,37 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
    * Returns a request that creates a TLS tunnel via an HTTP proxy. Everything in the tunnel request
    * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
    * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
+   *
+   * <p>In order to support preemptive authentication we pass a fake “Auth Failed” response to the
+   * authenticator. This gives the authenticator the option to customize the CONNECT request. It can
+   * decline to do so by returning null, in which case OkHttp will use it as-is
    */
-  private Request createTunnelRequest() {
-    return new Request.Builder()
+  private Request createTunnelRequest() throws IOException {
+    Request proxyConnectRequest = new Request.Builder()
         .url(route.address().url())
+        .method("CONNECT", null)
         .header("Host", Util.hostHeader(route.address().url(), true))
         .header("Proxy-Connection", "Keep-Alive") // For HTTP/1.0 proxies like Squid.
         .header("User-Agent", Version.userAgent())
         .build();
+
+    Response fakeAuthChallengeResponse = new Response.Builder()
+        .request(proxyConnectRequest)
+        .protocol(Protocol.HTTP_1_1)
+        .code(HttpURLConnection.HTTP_PROXY_AUTH)
+        .message("Preemptive Authenticate")
+        .body(Util.EMPTY_RESPONSE)
+        .sentRequestAtMillis(-1L)
+        .receivedResponseAtMillis(-1L)
+        .header("Proxy-Authenticate", "OkHttp-Preemptive")
+        .build();
+
+    Request authenticatedRequest = route.address().proxyAuthenticator()
+        .authenticate(route, fakeAuthChallengeResponse);
+
+    return authenticatedRequest != null
+        ? authenticatedRequest
+        : proxyConnectRequest;
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
index 5f50576611..4ba0168621 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
@@ -16,48 +16,33 @@
 package okhttp3.internal.connection;
 
 import java.io.IOException;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
+
+import static okhttp3.internal.Util.addSuppressedIfPossible;
 
 /**
  * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
  * have been made with alternative protocols, none of which were successful.
  */
 public final class RouteException extends RuntimeException {
-  private static final Method addSuppressedExceptionMethod;
-
-  static {
-    Method m;
-    try {
-      m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
-    } catch (Exception e) {
-      m = null;
-    }
-    addSuppressedExceptionMethod = m;
-  }
-
+  private IOException firstException;
   private IOException lastException;
 
   public RouteException(IOException cause) {
     super(cause);
+    firstException = cause;
     lastException = cause;
   }
 
+  public IOException getFirstConnectException() {
+    return firstException;
+  }
+
   public IOException getLastConnectException() {
     return lastException;
   }
 
   public void addConnectException(IOException e) {
-    addSuppressedIfPossible(e, lastException);
+    addSuppressedIfPossible(firstException, e);
     lastException = e;
   }
-
-  private void addSuppressedIfPossible(IOException e, IOException suppressed) {
-    if (addSuppressedExceptionMethod != null) {
-      try {
-        addSuppressedExceptionMethod.invoke(e, suppressed);
-      } catch (InvocationTargetException | IllegalAccessException ignored) {
-      }
-    }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 3bf7f51a22..dcad3d80db 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -107,11 +107,12 @@ public HttpCodec newStream(
     int connectTimeout = chain.connectTimeoutMillis();
     int readTimeout = chain.readTimeoutMillis();
     int writeTimeout = chain.writeTimeoutMillis();
+    int pingIntervalMillis = client.pingIntervalMillis();
     boolean connectionRetryEnabled = client.retryOnConnectionFailure();
 
     try {
       RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
-          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
+          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
       HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);
 
       synchronized (connectionPool) {
@@ -128,11 +129,11 @@ public HttpCodec newStream(
    * until a healthy connection is found.
    */
   private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
-      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
-      throws IOException {
+      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
+      boolean doExtensiveHealthChecks) throws IOException {
     while (true) {
       RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
-          connectionRetryEnabled);
+          pingIntervalMillis, connectionRetryEnabled);
 
       // If this is a brand new connection, we can skip the extensive health checks.
       synchronized (connectionPool) {
@@ -157,7 +158,7 @@ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout
    * then the pool, finally building a new connection.
    */
   private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled) throws IOException {
+      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
     boolean foundPooledConnection = false;
     RealConnection result = null;
     Route selectedRoute = null;
@@ -253,8 +254,8 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
     }
 
     // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(
-        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);
+    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
+        connectionRetryEnabled, call, eventListener);
     routeDatabase().connected(result.route());
 
     Socket socket = null;
@@ -316,8 +317,10 @@ public void streamFinished(boolean noNewStreams, HttpCodec codec, long bytesRead
     }
 
     if (e != null) {
+      e = Internal.instance.timeoutExit(call, e);
       eventListener.callFailed(call, e);
     } else if (callEnd) {
+      Internal.instance.timeoutExit(call, null);
       eventListener.callEnd(call);
     }
   }
@@ -350,7 +353,9 @@ public void release() {
     }
     closeQuietly(socket);
     if (releasedConnection != null) {
+      Internal.instance.timeoutExit(call, null);
       eventListener.connectionReleased(call, releasedConnection);
+      eventListener.callEnd(call);
     }
   }
 
@@ -426,13 +431,16 @@ public void streamFailed(IOException e) {
 
     synchronized (connectionPool) {
       if (e instanceof StreamResetException) {
-        StreamResetException streamResetException = (StreamResetException) e;
-        if (streamResetException.errorCode == ErrorCode.REFUSED_STREAM) {
+        ErrorCode errorCode = ((StreamResetException) e).errorCode;
+        if (errorCode == ErrorCode.REFUSED_STREAM) {
+          // Retry REFUSED_STREAM errors once on the same connection.
           refusedStreamCount++;
-        }
-        // On HTTP/2 stream errors, retry REFUSED_STREAM errors once on the same connection. All
-        // other errors must be retried on a new connection.
-        if (streamResetException.errorCode != ErrorCode.REFUSED_STREAM || refusedStreamCount > 1) {
+          if (refusedStreamCount > 1) {
+            noNewStreams = true;
+            route = null;
+          }
+        } else if (errorCode != ErrorCode.CANCEL) {
+          // Keep the connection for CANCEL errors. Everything else wants a fresh connection.
           noNewStreams = true;
           route = null;
         }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index b7aba87d6a..62531aa514 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -95,10 +95,25 @@ public CallServerInterceptor(boolean forWebSocket) {
         .receivedResponseAtMillis(System.currentTimeMillis())
         .build();
 
+    int code = response.code();
+    if (code == 100) {
+      // server sent a 100-continue even though we did not request one.
+      // try again to read the actual response
+      responseBuilder = httpCodec.readResponseHeaders(false);
+
+      response = responseBuilder
+              .request(request)
+              .handshake(streamAllocation.connection().handshake())
+              .sentRequestAtMillis(sentRequestMillis)
+              .receivedResponseAtMillis(System.currentTimeMillis())
+              .build();
+
+      code = response.code();
+    }
+
     realChain.eventListener()
-        .responseHeadersEnd(realChain.call(), response);
+            .responseHeadersEnd(realChain.call(), response);
 
-    int code = response.code();
     if (forWebSocket && code == 101) {
       // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
       response = response.newBuilder()
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
index a1d6712906..479fe07a24 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
@@ -15,13 +15,15 @@
  */
 package okhttp3.internal.http;
 
+import java.io.EOFException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 import okhttp3.Challenge;
 import okhttp3.Cookie;
 import okhttp3.CookieJar;
@@ -29,7 +31,8 @@
 import okhttp3.HttpUrl;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.ByteString;
 
 import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
 import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
@@ -38,10 +41,8 @@
 
 /** Headers and utilities for internal use by OkHttp. */
 public final class HttpHeaders {
-  private static final String TOKEN = "([^ \"=]*)";
-  private static final String QUOTED_STRING = "\"([^\"]*)\"";
-  private static final Pattern PARAMETER
-      = Pattern.compile(" +" + TOKEN + "=(:?" + QUOTED_STRING + "|" + TOKEN + ") *(:?,|$)");
+  private static final ByteString QUOTED_STRING_DELIMITERS = ByteString.encodeUtf8("\"\\");
+  private static final ByteString TOKEN_DELIMITERS = ByteString.encodeUtf8("\t ,=");
 
   private HttpHeaders() {
   }
@@ -144,55 +145,168 @@ public static Headers varyHeaders(Headers requestHeaders, Headers responseHeader
   }
 
   /**
-   * Parse RFC 7617 challenges, also wrong ordered ones.
-   * This API is only interested in the scheme name and realm.
+   * Parse RFC 7235 challenges. This is awkward because we need to look ahead to know how to
+   * interpret a token.
+   *
+   * <p>For example, the first line has a parameter name/value pair and the second line has a single
+   * token68:
+   *
+   * <pre>   {@code
+   *
+   *   WWW-Authenticate: Digest foo=bar
+   *   WWW-Authenticate: Digest foo=
+   * }</pre>
+   *
+   * <p>Similarly, the first line has one challenge and the second line has two challenges:
+   *
+   * <pre>   {@code
+   *
+   *   WWW-Authenticate: Digest ,foo=bar
+   *   WWW-Authenticate: Digest ,foo
+   * }</pre>
    */
-  public static List<Challenge> parseChallenges(Headers responseHeaders, String challengeHeader) {
-    // auth-scheme = token
-    // auth-param  = token "=" ( token | quoted-string )
-    // challenge   = auth-scheme 1*SP 1#auth-param
-    // realm       = "realm" "=" realm-value
-    // realm-value = quoted-string
-    List<Challenge> challenges = new ArrayList<>();
-    List<String> authenticationHeaders = responseHeaders.values(challengeHeader);
-    for (String header : authenticationHeaders) {
-      int index = header.indexOf(' ');
-      if (index == -1) continue;
-
-      String scheme = header.substring(0, index);
-      String realm = null;
-      String charset = null;
-
-      Matcher matcher = PARAMETER.matcher(header);
-      for (int i = index; matcher.find(i); i = matcher.end()) {
-        if (header.regionMatches(true, matcher.start(1), "realm", 0, 5)) {
-          realm = matcher.group(3);
-        } else if (header.regionMatches(true, matcher.start(1), "charset", 0, 7)) {
-          charset = matcher.group(3);
-        }
+  public static List<Challenge> parseChallenges(Headers responseHeaders, String headerName) {
+    List<Challenge> result = new ArrayList<>();
+    for (int h = 0; h < responseHeaders.size(); h++) {
+      if (headerName.equalsIgnoreCase(responseHeaders.name(h))) {
+        Buffer header = new Buffer().writeUtf8(responseHeaders.value(h));
+        parseChallengeHeader(result, header);
+      }
+    }
+    return result;
+  }
 
-        if (realm != null && charset != null) {
-          break;
-        }
+  private static void parseChallengeHeader(List<Challenge> result, Buffer header) {
+    String peek = null;
+
+    while (true) {
+      // Read a scheme name for this challenge if we don't have one already.
+      if (peek == null) {
+        skipWhitespaceAndCommas(header);
+        peek = readToken(header);
+        if (peek == null) return;
       }
 
-      // "realm" is required.
-      if (realm == null) continue;
+      String schemeName = peek;
+
+      // Read a token68, a sequence of parameters, or nothing.
+      boolean commaPrefixed = skipWhitespaceAndCommas(header);
+      peek = readToken(header);
+      if (peek == null) {
+        if (!header.exhausted()) return; // Expected a token; got something else.
+        result.add(new Challenge(schemeName, Collections.<String, String>emptyMap()));
+        return;
+      }
 
-      Challenge challenge = new Challenge(scheme, realm);
+      int eqCount = skipAll(header, (byte) '=');
+      boolean commaSuffixed = skipWhitespaceAndCommas(header);
 
-      // If a charset is provided, RFC 7617 says it must be "UTF-8".
-      if (charset != null) {
-        if (charset.equalsIgnoreCase("UTF-8")) {
-          challenge = challenge.withCharset(Util.UTF_8);
-        } else {
-          continue;
+      // It's a token68 because there isn't a value after it.
+      if (!commaPrefixed && (commaSuffixed || header.exhausted())) {
+        result.add(new Challenge(schemeName, Collections.singletonMap(
+            (String) null, peek + repeat('=', eqCount))));
+        peek = null;
+        continue;
+      }
+
+      // It's a series of parameter names and values.
+      Map<String, String> parameters = new LinkedHashMap<>();
+      eqCount += skipAll(header, (byte) '=');
+      while (true) {
+        if (peek == null) {
+          peek = readToken(header);
+          if (skipWhitespaceAndCommas(header)) break; // We peeked a scheme name followed by ','.
+          eqCount = skipAll(header, (byte) '=');
         }
+        if (eqCount == 0) break; // We peeked a scheme name.
+        if (eqCount > 1) return; // Unexpected '=' characters.
+        if (skipWhitespaceAndCommas(header)) return; // Unexpected ','.
+
+        String parameterValue = !header.exhausted() && header.getByte(0) == '"'
+            ? readQuotedString(header)
+            : readToken(header);
+        if (parameterValue == null) return; // Expected a value.
+        String replaced = parameters.put(peek, parameterValue);
+        peek = null;
+        if (replaced != null) return; // Unexpected duplicate parameter.
+        if (!skipWhitespaceAndCommas(header) && !header.exhausted()) return; // Expected ',' or EOF.
+      }
+      result.add(new Challenge(schemeName, parameters));
+    }
+  }
+
+  /** Returns true if any commas were skipped. */
+  private static boolean skipWhitespaceAndCommas(Buffer buffer) {
+    boolean commaFound = false;
+    while (!buffer.exhausted()) {
+      byte b = buffer.getByte(0);
+      if (b == ',') {
+        buffer.readByte(); // Consume ','.
+        commaFound = true;
+      } else if (b == ' ' || b == '\t') {
+        buffer.readByte(); // Consume space or tab.
+      } else {
+        break;
+      }
+    }
+    return commaFound;
+  }
+
+  private static int skipAll(Buffer buffer, byte b) {
+    int count = 0;
+    while (!buffer.exhausted() && buffer.getByte(0) == b) {
+      count++;
+      buffer.readByte();
+    }
+    return count;
+  }
+
+  /**
+   * Reads a double-quoted string, unescaping quoted pairs like {@code \"} to the 2nd character in
+   * each sequence. Returns the unescaped string, or null if the buffer isn't prefixed with a
+   * double-quoted string.
+   */
+  private static String readQuotedString(Buffer buffer) {
+    if (buffer.readByte() != '\"') throw new IllegalArgumentException();
+    Buffer result = new Buffer();
+    while (true) {
+      long i = buffer.indexOfElement(QUOTED_STRING_DELIMITERS);
+      if (i == -1L) return null; // Unterminated quoted string.
+
+      if (buffer.getByte(i) == '"') {
+        result.write(buffer, i);
+        buffer.readByte(); // Consume '"'.
+        return result.readUtf8();
       }
 
-      challenges.add(challenge);
+      if (buffer.size() == i + 1L) return null; // Dangling escape.
+      result.write(buffer, i);
+      buffer.readByte(); // Consume '\'.
+      result.write(buffer, 1L); // The escaped character.
     }
-    return challenges;
+  }
+
+  /**
+   * Consumes and returns a non-empty token, terminating at special characters in {@link
+   * #TOKEN_DELIMITERS}. Returns null if the buffer is empty or prefixed with a delimiter.
+   */
+  private static String readToken(Buffer buffer) {
+    try {
+      long tokenSize = buffer.indexOfElement(TOKEN_DELIMITERS);
+      if (tokenSize == -1L) tokenSize = buffer.size();
+
+      return tokenSize != 0L
+          ? buffer.readUtf8(tokenSize)
+          : null;
+    } catch (EOFException e) {
+      throw new AssertionError();
+    }
+  }
+
+  private static String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
   }
 
   public static void receiveHeaders(CookieJar cookieJar, HttpUrl url, Headers headers) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 07df5e9b08..d682de8bf0 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -128,7 +128,7 @@ public StreamAllocation streamAllocation() {
       } catch (RouteException e) {
         // The attempt to connect via a route failed. The request will not have been sent.
         if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {
-          throw e.getLastConnectException();
+          throw e.getFirstConnectException();
         }
         releaseConnection = false;
         continue;
@@ -155,12 +155,16 @@ public StreamAllocation streamAllocation() {
             .build();
       }
 
-      Request followUp = followUpRequest(response, streamAllocation.route());
+      Request followUp;
+      try {
+        followUp = followUpRequest(response, streamAllocation.route());
+      } catch (IOException e) {
+        streamAllocation.release();
+        throw e;
+      }
 
       if (followUp == null) {
-        if (!forWebSocket) {
-          streamAllocation.release();
-        }
+        streamAllocation.release();
         return response;
       }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 83780ff863..6c7b4373c4 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -196,6 +196,9 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
 
       if (expectContinue && statusLine.code == HTTP_CONTINUE) {
         return null;
+      } else if (statusLine.code == HTTP_CONTINUE) {
+        state = STATE_READ_RESPONSE_HEADERS;
+        return responseBuilder;
       }
 
       state = STATE_OPEN_RESPONSE_BODY;
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Header.java b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
index 3cfd7be8d7..362570a2bc 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Header.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
@@ -15,6 +15,7 @@
  */
 package okhttp3.internal.http2;
 
+import okhttp3.Headers;
 import okhttp3.internal.Util;
 import okio.ByteString;
 
@@ -22,11 +23,19 @@
 public final class Header {
   // Special header names defined in HTTP/2 spec.
   public static final ByteString PSEUDO_PREFIX = ByteString.encodeUtf8(":");
-  public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(":status");
-  public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(":method");
-  public static final ByteString TARGET_PATH = ByteString.encodeUtf8(":path");
-  public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(":scheme");
-  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority");
+
+  public static final String RESPONSE_STATUS_UTF8 = ":status";
+  public static final String TARGET_METHOD_UTF8 = ":method";
+  public static final String TARGET_PATH_UTF8 = ":path";
+  public static final String TARGET_SCHEME_UTF8 = ":scheme";
+  public static final String TARGET_AUTHORITY_UTF8 = ":authority";
+
+  public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(RESPONSE_STATUS_UTF8);
+  public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(TARGET_METHOD_UTF8);
+  public static final ByteString TARGET_PATH = ByteString.encodeUtf8(TARGET_PATH_UTF8);
+  public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(TARGET_SCHEME_UTF8);
+  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(TARGET_AUTHORITY_UTF8);
+
 
   /** Name in case-insensitive ASCII encoding. */
   public final ByteString name;
@@ -68,4 +77,9 @@ public Header(ByteString name, ByteString value) {
   @Override public String toString() {
     return Util.format("%s: %s", name.utf8(), value.utf8());
   }
+
+  // TODO(jwilson): move this to Headers?
+  interface Listener {
+    void onHeaders(Headers headers);
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
index 5268aa2c91..9a81d536f2 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -44,25 +44,29 @@
 import okio.Source;
 
 import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
-import static okhttp3.internal.http2.Header.RESPONSE_STATUS;
+import static okhttp3.internal.http2.Header.RESPONSE_STATUS_UTF8;
 import static okhttp3.internal.http2.Header.TARGET_AUTHORITY;
+import static okhttp3.internal.http2.Header.TARGET_AUTHORITY_UTF8;
 import static okhttp3.internal.http2.Header.TARGET_METHOD;
+import static okhttp3.internal.http2.Header.TARGET_METHOD_UTF8;
 import static okhttp3.internal.http2.Header.TARGET_PATH;
+import static okhttp3.internal.http2.Header.TARGET_PATH_UTF8;
 import static okhttp3.internal.http2.Header.TARGET_SCHEME;
+import static okhttp3.internal.http2.Header.TARGET_SCHEME_UTF8;
 
 /** Encode requests and responses using HTTP/2 frames. */
 public final class Http2Codec implements HttpCodec {
-  private static final ByteString CONNECTION = ByteString.encodeUtf8("connection");
-  private static final ByteString HOST = ByteString.encodeUtf8("host");
-  private static final ByteString KEEP_ALIVE = ByteString.encodeUtf8("keep-alive");
-  private static final ByteString PROXY_CONNECTION = ByteString.encodeUtf8("proxy-connection");
-  private static final ByteString TRANSFER_ENCODING = ByteString.encodeUtf8("transfer-encoding");
-  private static final ByteString TE = ByteString.encodeUtf8("te");
-  private static final ByteString ENCODING = ByteString.encodeUtf8("encoding");
-  private static final ByteString UPGRADE = ByteString.encodeUtf8("upgrade");
+  private static final String CONNECTION = "connection";
+  private static final String HOST = "host";
+  private static final String KEEP_ALIVE = "keep-alive";
+  private static final String PROXY_CONNECTION = "proxy-connection";
+  private static final String TRANSFER_ENCODING = "transfer-encoding";
+  private static final String TE = "te";
+  private static final String ENCODING = "encoding";
+  private static final String UPGRADE = "upgrade";
 
   /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
-  private static final List<ByteString> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
+  private static final List<String> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
       CONNECTION,
       HOST,
       KEEP_ALIVE,
@@ -71,11 +75,11 @@
       TRANSFER_ENCODING,
       ENCODING,
       UPGRADE,
-      TARGET_METHOD,
-      TARGET_PATH,
-      TARGET_SCHEME,
-      TARGET_AUTHORITY);
-  private static final List<ByteString> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
+      TARGET_METHOD_UTF8,
+      TARGET_PATH_UTF8,
+      TARGET_SCHEME_UTF8,
+      TARGET_AUTHORITY_UTF8);
+  private static final List<String> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
       CONNECTION,
       HOST,
       KEEP_ALIVE,
@@ -85,18 +89,20 @@
       ENCODING,
       UPGRADE);
 
-  private final OkHttpClient client;
   private final Interceptor.Chain chain;
   final StreamAllocation streamAllocation;
   private final Http2Connection connection;
   private Http2Stream stream;
+  private final Protocol protocol;
 
   public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation streamAllocation,
       Http2Connection connection) {
-    this.client = client;
     this.chain = chain;
     this.streamAllocation = streamAllocation;
     this.connection = connection;
+    this.protocol = client.protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)
+        ? Protocol.H2_PRIOR_KNOWLEDGE
+        : Protocol.HTTP_2;
   }
 
   @Override public Sink createRequestBody(Request request, long contentLength) {
@@ -122,8 +128,8 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
   }
 
   @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
-    List<Header> headers = stream.takeResponseHeaders();
-    Response.Builder responseBuilder = readHttp2HeadersList(headers);
+    Headers headers = stream.takeHeaders();
+    Response.Builder responseBuilder = readHttp2HeadersList(headers, protocol);
     if (expectContinue && Internal.instance.code(responseBuilder) == HTTP_CONTINUE) {
       return null;
     }
@@ -144,7 +150,7 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
     for (int i = 0, size = headers.size(); i < size; i++) {
       // header names must be lowercase.
       ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
-      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name)) {
+      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name.utf8())) {
         result.add(new Header(name, headers.value(i)));
       }
     }
@@ -152,34 +158,23 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
   }
 
   /** Returns headers for a name value block containing an HTTP/2 response. */
-  public static Response.Builder readHttp2HeadersList(List<Header> headerBlock) throws IOException {
+  public static Response.Builder readHttp2HeadersList(Headers headerBlock,
+      Protocol protocol) throws IOException {
     StatusLine statusLine = null;
     Headers.Builder headersBuilder = new Headers.Builder();
     for (int i = 0, size = headerBlock.size(); i < size; i++) {
-      Header header = headerBlock.get(i);
-
-      // If there were multiple header blocks they will be delimited by nulls. Discard existing
-      // header blocks if the existing header block is a '100 Continue' intermediate response.
-      if (header == null) {
-        if (statusLine != null && statusLine.code == HTTP_CONTINUE) {
-          statusLine = null;
-          headersBuilder = new Headers.Builder();
-        }
-        continue;
-      }
-
-      ByteString name = header.name;
-      String value = header.value.utf8();
-      if (name.equals(RESPONSE_STATUS)) {
+      String name = headerBlock.name(i);
+      String value = headerBlock.value(i);
+      if (name.equals(RESPONSE_STATUS_UTF8)) {
         statusLine = StatusLine.parse("HTTP/1.1 " + value);
       } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
-        Internal.instance.addLenient(headersBuilder, name.utf8(), value);
+        Internal.instance.addLenient(headersBuilder, name, value);
       }
     }
     if (statusLine == null) throw new ProtocolException("Expected ':status' header not present");
 
     return new Response.Builder()
-        .protocol(Protocol.HTTP_2)
+        .protocol(protocol)
         .code(statusLine.code)
         .message(statusLine.message)
         .headers(headersBuilder.build());
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index d5e2c02454..aa77584e23 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -27,9 +27,13 @@
 import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import okhttp3.Headers;
 import okhttp3.Protocol;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Util;
@@ -40,6 +44,7 @@
 import okio.ByteString;
 import okio.Okio;
 
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static okhttp3.internal.http2.ErrorCode.REFUSED_STREAM;
 import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.platform.Platform.INFO;
@@ -67,7 +72,13 @@
   // operations must synchronize on 'this' last. This ensures that we never
   // wait for a blocking operation while holding 'this'.
 
-  static final ExecutorService executor = new ThreadPoolExecutor(0,
+  static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
+
+  /**
+   * Shared executor to send notifications of incoming streams. This executor requires multiple
+   * threads because listeners are not required to return promptly.
+   */
+  private static final ExecutorService listenerExecutor = new ThreadPoolExecutor(0,
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
       Util.threadFactory("OkHttp Http2Connection", true));
 
@@ -76,7 +87,7 @@
 
   /**
    * User code to run in response to incoming streams or settings. Calls to this are always invoked
-   * on {@link #executor}.
+   * on {@link #listenerExecutor}.
    */
   final Listener listener;
   final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
@@ -85,14 +96,17 @@
   int nextStreamId;
   boolean shutdown;
 
+  /** Asynchronously writes frames to the outgoing socket. */
+  private final ScheduledExecutorService writerExecutor;
+
   /** Ensures push promise callbacks events are sent in order per stream. */
   private final ExecutorService pushExecutor;
 
-  /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
-  private Map<Integer, Ping> pings;
   /** User code to run in response to push promise events. */
   final PushObserver pushObserver;
-  private int nextPingId;
+
+  /** True if we have sent a ping that is still awaiting a reply. */
+  private boolean awaitingPong;
 
   /**
    * The total number of bytes consumed by the application, but not yet acknowledged by sending a
@@ -110,8 +124,6 @@
   /** Settings we communicate to the peer. */
   Settings okHttpSettings = new Settings();
 
-  private static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
-
   /** Settings we receive from the peer. */
   // TODO: MWS will need to guard on this setting before attempting to push.
   final Settings peerSettings = new Settings();
@@ -133,8 +145,6 @@
       nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
     }
 
-    nextPingId = builder.client ? 1 : 2;
-
     // Flow control was designed more for servers, or proxies than edge clients.
     // If we are a client, set the flow control window to 16MiB.  This avoids
     // thrashing window updates every 64KiB, yet small enough to avoid blowing
@@ -145,6 +155,13 @@
 
     hostname = builder.hostname;
 
+    writerExecutor = new ScheduledThreadPoolExecutor(1,
+        Util.threadFactory(Util.format("OkHttp %s Writer", hostname), false));
+    if (builder.pingIntervalMillis != 0) {
+      writerExecutor.scheduleAtFixedRate(new PingRunnable(false, 0, 0),
+          builder.pingIntervalMillis, builder.pingIntervalMillis, MILLISECONDS);
+    }
+
     // Like newSingleThreadExecutor, except lazy creates the thread.
     pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
         new LinkedBlockingQueue<Runnable>(),
@@ -184,6 +201,14 @@ public synchronized int maxConcurrentStreams() {
     return peerSettings.getMaxConcurrentStreams(Integer.MAX_VALUE);
   }
 
+  synchronized void updateConnectionFlowControl(long read) {
+    unacknowledgedBytesRead += read;
+    if (unacknowledgedBytesRead >= okHttpSettings.getInitialWindowSize() / 2) {
+      writeWindowUpdateLater(0, unacknowledgedBytesRead);
+      unacknowledgedBytesRead = 0;
+    }
+  }
+
   /**
    * Returns a new server-initiated stream.
    *
@@ -224,7 +249,7 @@ private Http2Stream newStream(
         }
         streamId = nextStreamId;
         nextStreamId += 2;
-        stream = new Http2Stream(streamId, this, outFinished, inFinished, requestHeaders);
+        stream = new Http2Stream(streamId, this, outFinished, inFinished, null);
         flushHeaders = !out || bytesLeftInWriteWindow == 0L || stream.bytesLeftInWriteWindow == 0L;
         if (stream.isOpen()) {
           streams.put(streamId, stream);
@@ -283,6 +308,7 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
             Http2Connection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
           }
         } catch (InterruptedException e) {
+          Thread.currentThread().interrupt(); // Retain interrupted status.
           throw new InterruptedIOException();
         }
 
@@ -296,23 +322,20 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
     }
   }
 
-  /**
-   * {@code delta} will be negative if a settings frame initial window is smaller than the last.
-   */
-  void addBytesToWriteWindow(long delta) {
-    bytesLeftInWriteWindow += delta;
-    if (delta > 0) Http2Connection.this.notifyAll();
-  }
-
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
-    executor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
-      @Override public void execute() {
-        try {
-          writeSynReset(streamId, errorCode);
-        } catch (IOException ignored) {
+    try {
+      writerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
+        @Override public void execute() {
+          try {
+            writeSynReset(streamId, errorCode);
+          } catch (IOException e) {
+            failConnection();
+          }
         }
-      }
-    });
+      });
+    } catch (RejectedExecutionException ignored) {
+      // This connection has been closed.
+    }
   }
 
   void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
@@ -320,59 +343,70 @@ void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
   }
 
   void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
-    executor.execute(new NamedRunnable("OkHttp Window Update %s stream %d", hostname, streamId) {
-      @Override public void execute() {
-        try {
-          writer.windowUpdate(streamId, unacknowledgedBytesRead);
-        } catch (IOException ignored) {
-        }
-      }
-    });
+    try {
+      writerExecutor.execute(
+          new NamedRunnable("OkHttp Window Update %s stream %d", hostname, streamId) {
+            @Override public void execute() {
+              try {
+                writer.windowUpdate(streamId, unacknowledgedBytesRead);
+              } catch (IOException e) {
+                failConnection();
+              }
+            }
+          });
+    } catch (RejectedExecutionException ignored) {
+      // This connection has been closed.
+    }
   }
 
-  /**
-   * Sends a ping frame to the peer. Use the returned object to await the ping's response and
-   * observe its round trip time.
-   */
-  public Ping ping() throws IOException {
-    Ping ping = new Ping();
-    int pingId;
-    synchronized (this) {
-      if (shutdown) {
-        throw new ConnectionShutdownException();
-      }
-      pingId = nextPingId;
-      nextPingId += 2;
-      if (pings == null) pings = new LinkedHashMap<>();
-      pings.put(pingId, ping);
+  final class PingRunnable extends NamedRunnable {
+    final boolean reply;
+    final int payload1;
+    final int payload2;
+
+    PingRunnable(boolean reply, int payload1, int payload2) {
+      super("OkHttp %s ping %08x%08x", hostname, payload1, payload2);
+      this.reply = reply;
+      this.payload1 = payload1;
+      this.payload2 = payload2;
+    }
+
+    @Override public void execute() {
+      writePing(reply, payload1, payload2);
     }
-    writePing(false, pingId, 0x4f4b6f6b /* ASCII "OKok" */, ping);
-    return ping;
   }
 
-  void writePingLater(
-      final boolean reply, final int payload1, final int payload2, final Ping ping) {
-    executor.execute(new NamedRunnable("OkHttp %s ping %08x%08x",
-        hostname, payload1, payload2) {
-      @Override public void execute() {
-        try {
-          writePing(reply, payload1, payload2, ping);
-        } catch (IOException ignored) {
-        }
+  void writePing(boolean reply, int payload1, int payload2) {
+    if (!reply) {
+      boolean failedDueToMissingPong;
+      synchronized (this) {
+        failedDueToMissingPong = awaitingPong;
+        awaitingPong = true;
       }
-    });
-  }
+      if (failedDueToMissingPong) {
+        failConnection();
+        return;
+      }
+    }
 
-  void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
-    synchronized (writer) {
-      // Observe the sent time immediately before performing I/O.
-      if (ping != null) ping.send();
+    try {
       writer.ping(reply, payload1, payload2);
+    } catch (IOException e) {
+      failConnection();
     }
   }
 
-  synchronized Ping removePing(int id) {
-    return pings != null ? pings.remove(id) : null;
+  /** For testing: sends a ping and waits for a pong. */
+  void writePingAndAwaitPong() throws InterruptedException {
+    writePing(false, 0x4f4b6f6b /* "OKok" */, 0xf09f8da9 /* donut */);
+    awaitPong();
+  }
+
+  /** For testing: waits until {@code requiredPongCount} pings have been received from the peer. */
+  synchronized void awaitPong() throws InterruptedException {
+    while (awaitingPong) {
+      wait();
+    }
   }
 
   public void flush() throws IOException {
@@ -418,16 +452,11 @@ void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
     }
 
     Http2Stream[] streamsToClose = null;
-    Ping[] pingsToCancel = null;
     synchronized (this) {
       if (!streams.isEmpty()) {
         streamsToClose = streams.values().toArray(new Http2Stream[streams.size()]);
         streams.clear();
       }
-      if (pings != null) {
-        pingsToCancel = pings.values().toArray(new Ping[pings.size()]);
-        pings = null;
-      }
     }
 
     if (streamsToClose != null) {
@@ -440,12 +469,6 @@ void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
       }
     }
 
-    if (pingsToCancel != null) {
-      for (Ping ping : pingsToCancel) {
-        ping.cancel();
-      }
-    }
-
     // Close the writer to release its resources (such as deflaters).
     try {
       writer.close();
@@ -460,9 +483,20 @@ void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
       thrown = e;
     }
 
+    // Release the threads.
+    writerExecutor.shutdown();
+    pushExecutor.shutdown();
+
     if (thrown != null) throw thrown;
   }
 
+  private void failConnection() {
+    try {
+      close(ErrorCode.PROTOCOL_ERROR, ErrorCode.PROTOCOL_ERROR);
+    } catch (IOException ignored) {
+    }
+  }
+
   /**
    * Sends any initial frames and starts reading frames from the remote peer. This should be called
    * after {@link Builder#build} for all new connections.
@@ -495,8 +529,8 @@ public void setSettings(Settings settings) throws IOException {
           throw new ConnectionShutdownException();
         }
         okHttpSettings.merge(settings);
-        writer.settings(settings);
       }
+      writer.settings(settings);
     }
   }
 
@@ -512,6 +546,7 @@ public synchronized boolean isShutdown() {
     Listener listener = Listener.REFUSE_INCOMING_STREAMS;
     PushObserver pushObserver = PushObserver.CANCEL;
     boolean client;
+    int pingIntervalMillis;
 
     /**
      * @param client true if this peer initiated the connection; false if this peer accepted the
@@ -545,6 +580,11 @@ public Builder pushObserver(PushObserver pushObserver) {
       return this;
     }
 
+    public Builder pingIntervalMillis(int pingIntervalMillis) {
+      this.pingIntervalMillis = pingIntervalMillis;
+      return this;
+    }
+
     public Http2Connection build() {
       return new Http2Connection(this);
     }
@@ -592,6 +632,7 @@ public Http2Connection build() {
       Http2Stream dataStream = getStream(streamId);
       if (dataStream == null) {
         writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
+        updateConnectionFlowControl(length);
         source.skip(length);
         return;
       }
@@ -622,11 +663,12 @@ public Http2Connection build() {
           if (streamId % 2 == nextStreamId % 2) return;
 
           // Create a stream.
+          Headers headers = Util.toHeaders(headerBlock);
           final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this,
-              false, inFinished, headerBlock);
+              false, inFinished, headers);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
-          executor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
+          listenerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
             @Override public void execute() {
               try {
                 listener.onStream(newStream);
@@ -671,14 +713,13 @@ public Http2Connection build() {
         if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
           delta = peerInitialWindowSize - priorWriteWindowSize;
           if (!receivedInitialPeerSettings) {
-            addBytesToWriteWindow(delta);
             receivedInitialPeerSettings = true;
           }
           if (!streams.isEmpty()) {
             streamsToNotify = streams.values().toArray(new Http2Stream[streams.size()]);
           }
         }
-        executor.execute(new NamedRunnable("OkHttp %s settings", hostname) {
+        listenerExecutor.execute(new NamedRunnable("OkHttp %s settings", hostname) {
           @Override public void execute() {
             listener.onSettings(Http2Connection.this);
           }
@@ -694,14 +735,19 @@ public Http2Connection build() {
     }
 
     private void applyAndAckSettings(final Settings peerSettings) {
-      executor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostname) {
-        @Override public void execute() {
-          try {
-            writer.applyAndAckSettings(peerSettings);
-          } catch (IOException ignored) {
+      try {
+        writerExecutor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostname) {
+          @Override public void execute() {
+            try {
+              writer.applyAndAckSettings(peerSettings);
+            } catch (IOException e) {
+              failConnection();
+            }
           }
-        }
-      });
+        });
+      } catch (RejectedExecutionException ignored) {
+        // This connection has been closed.
+      }
     }
 
     @Override public void ackSettings() {
@@ -710,13 +756,17 @@ private void applyAndAckSettings(final Settings peerSettings) {
 
     @Override public void ping(boolean reply, int payload1, int payload2) {
       if (reply) {
-        Ping ping = removePing(payload1);
-        if (ping != null) {
-          ping.receive();
+        synchronized (Http2Connection.this) {
+          awaitingPong = false;
+          Http2Connection.this.notifyAll();
         }
       } else {
-        // Send a reply to a client ping if this is a server and vice versa.
-        writePingLater(true, payload1, payload2, null);
+        try {
+          // Send a reply to a client ping if this is a server and vice versa.
+          writerExecutor.execute(new PingRunnable(true, payload1, payload2));
+        } catch (RejectedExecutionException ignored) {
+          // This connection has been closed.
+        }
       }
     }
 
@@ -788,38 +838,46 @@ void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
       }
       currentPushRequests.add(streamId);
     }
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Request[%s]", hostname, streamId) {
-      @Override public void execute() {
-        boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
-        try {
-          if (cancel) {
-            writer.rstStream(streamId, ErrorCode.CANCEL);
-            synchronized (Http2Connection.this) {
-              currentPushRequests.remove(streamId);
+    try {
+      pushExecutorExecute(new NamedRunnable("OkHttp %s Push Request[%s]", hostname, streamId) {
+        @Override public void execute() {
+          boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
+          try {
+            if (cancel) {
+              writer.rstStream(streamId, ErrorCode.CANCEL);
+              synchronized (Http2Connection.this) {
+                currentPushRequests.remove(streamId);
+              }
             }
+          } catch (IOException ignored) {
           }
-        } catch (IOException ignored) {
         }
-      }
-    });
+      });
+    } catch (RejectedExecutionException ignored) {
+      // This connection has been closed.
+    }
   }
 
   void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
       final boolean inFinished) {
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostname, streamId) {
-      @Override public void execute() {
-        boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
-        try {
-          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);
-          if (cancel || inFinished) {
-            synchronized (Http2Connection.this) {
-              currentPushRequests.remove(streamId);
+    try {
+      pushExecutorExecute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostname, streamId) {
+        @Override public void execute() {
+          boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
+          try {
+            if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);
+            if (cancel || inFinished) {
+              synchronized (Http2Connection.this) {
+                currentPushRequests.remove(streamId);
+              }
             }
+          } catch (IOException ignored) {
           }
-        } catch (IOException ignored) {
         }
-      }
-    });
+      });
+    } catch (RejectedExecutionException ignored) {
+      // This connection has been closed.
+    }
   }
 
   /**
@@ -832,7 +890,7 @@ void pushDataLater(final int streamId, final BufferedSource source, final int by
     source.require(byteCount); // Eagerly read the frame before firing client thread.
     source.read(buffer, byteCount);
     if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Data[%s]", hostname, streamId) {
+    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Data[%s]", hostname, streamId) {
       @Override public void execute() {
         try {
           boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
@@ -849,7 +907,7 @@ void pushDataLater(final int streamId, final BufferedSource source, final int by
   }
 
   void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostname, streamId) {
+    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostname, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
         synchronized (Http2Connection.this) {
@@ -859,6 +917,12 @@ void pushResetLater(final int streamId, final ErrorCode errorCode) {
     });
   }
 
+  private synchronized void pushExecutorExecute(NamedRunnable namedRunnable) {
+    if (!isShutdown()) {
+      pushExecutor.execute(namedRunnable);
+    }
+  }
+
   /** Listener of streams and settings initiated by the peer. */
   public abstract static class Listener {
     public static final Listener REFUSE_INCOMING_STREAMS = new Listener() {
@@ -869,7 +933,7 @@ void pushResetLater(final int streamId, final ErrorCode errorCode) {
 
     /**
      * Handle a new stream from this connection's peer. Implementations should respond by either
-     * {@linkplain Http2Stream#sendResponseHeaders replying to the stream} or {@linkplain
+     * {@linkplain Http2Stream#writeHeaders replying to the stream} or {@linkplain
      * Http2Stream#close closing it}. This response does not need to be synchronous.
      */
     public abstract void onStream(Http2Stream stream) throws IOException;
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
index 19ac954d7e..c391b38952 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -19,8 +19,13 @@
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.SocketTimeoutException;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Deque;
 import java.util.List;
+import javax.annotation.Nullable;
+import okhttp3.Headers;
+import okhttp3.internal.Util;
 import okio.AsyncTimeout;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -51,11 +56,12 @@
   final int id;
   final Http2Connection connection;
 
-  /** Request headers. Immutable and non null. */
-  private final List<Header> requestHeaders;
-
-  /** Response headers yet to be {@linkplain #takeResponseHeaders taken}. */
-  private List<Header> responseHeaders;
+  /**
+   * Received headers yet to be {@linkplain #takeHeaders taken}, or {@linkplain FramingSource#read
+   * read}.
+   */
+  private final Deque<Headers> headersQueue = new ArrayDeque<>();
+  private Header.Listener headersListener;
 
   /** True if response headers have been sent or received. */
   private boolean hasResponseHeaders;
@@ -73,9 +79,9 @@
   ErrorCode errorCode = null;
 
   Http2Stream(int id, Http2Connection connection, boolean outFinished, boolean inFinished,
-      List<Header> requestHeaders) {
+      @Nullable Headers headers) {
     if (connection == null) throw new NullPointerException("connection == null");
-    if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
+
     this.id = id;
     this.connection = connection;
     this.bytesLeftInWriteWindow =
@@ -84,7 +90,15 @@
     this.sink = new FramingSink();
     this.source.finished = inFinished;
     this.sink.finished = outFinished;
-    this.requestHeaders = requestHeaders;
+    if (headers != null) {
+      headersQueue.add(headers);
+    }
+
+    if (isLocallyInitiated() && headers != null) {
+      throw new IllegalStateException("locally-initiated streams shouldn't have headers yet");
+    } else if (!isLocallyInitiated() && headers == null) {
+      throw new IllegalStateException("remotely-initiated streams should have headers");
+    }
   }
 
   public int getId() {
@@ -124,31 +138,22 @@ public Http2Connection getConnection() {
     return connection;
   }
 
-  public List<Header> getRequestHeaders() {
-    return requestHeaders;
-  }
-
   /**
    * Removes and returns the stream's received response headers, blocking if necessary until headers
    * have been received. If the returned list contains multiple blocks of headers the blocks will be
    * delimited by 'null'.
    */
-  public synchronized List<Header> takeResponseHeaders() throws IOException {
-    if (!isLocallyInitiated()) {
-      throw new IllegalStateException("servers cannot read response headers");
-    }
+  public synchronized Headers takeHeaders() throws IOException {
     readTimeout.enter();
     try {
-      while (responseHeaders == null && errorCode == null) {
+      while (headersQueue.isEmpty() && errorCode == null) {
         waitForIo();
       }
     } finally {
       readTimeout.exitAndThrowIfTimedOut();
     }
-    List<Header> result = responseHeaders;
-    if (result != null) {
-      responseHeaders = null;
-      return result;
+    if (!headersQueue.isEmpty()) {
+      return headersQueue.removeFirst();
     }
     throw new StreamResetException(errorCode);
   }
@@ -167,22 +172,34 @@ public synchronized ErrorCode getErrorCode() {
    * @param out true to create an output stream that we can use to send data to the remote peer.
    * Corresponds to {@code FLAG_FIN}.
    */
-  public void sendResponseHeaders(List<Header> responseHeaders, boolean out) throws IOException {
+  public void writeHeaders(List<Header> responseHeaders, boolean out) throws IOException {
     assert (!Thread.holdsLock(Http2Stream.this));
     if (responseHeaders == null) {
-      throw new NullPointerException("responseHeaders == null");
+      throw new NullPointerException("headers == null");
     }
     boolean outFinished = false;
+    boolean flushHeaders = false;
     synchronized (this) {
       this.hasResponseHeaders = true;
       if (!out) {
         this.sink.finished = true;
+        flushHeaders = true;
         outFinished = true;
       }
     }
+
+    // Only DATA frames are subject to flow-control. Transmit the HEADER frame if the connection
+    // flow-control window is fully depleted.
+    if (!flushHeaders) {
+      synchronized (connection) {
+        flushHeaders = connection.bytesLeftInWriteWindow == 0L;
+      }
+    }
+
+    // TODO(jwilson): rename to writeHeaders
     connection.writeSynReply(id, outFinished, responseHeaders);
 
-    if (outFinished) {
+    if (flushHeaders) {
       connection.flush();
     }
   }
@@ -204,7 +221,7 @@ public Source getSource() {
    * Returns a sink that can be used to write data to the peer.
    *
    * @throws IllegalStateException if this stream was initiated by the peer and a {@link
-   * #sendResponseHeaders} has not yet been sent.
+   * #writeHeaders} has not yet been sent.
    */
   public Sink getSink() {
     synchronized (this) {
@@ -254,22 +271,18 @@ private boolean closeInternal(ErrorCode errorCode) {
     return true;
   }
 
+  /**
+   * Accept headers from the network and store them until the client calls {@link #takeHeaders}, or
+   * {@link FramingSource#read} them.
+   */
   void receiveHeaders(List<Header> headers) {
     assert (!Thread.holdsLock(Http2Stream.this));
-    boolean open = true;
+    boolean open;
     synchronized (this) {
       hasResponseHeaders = true;
-      if (responseHeaders == null) {
-        responseHeaders = headers;
-        open = isOpen();
-        notifyAll();
-      } else {
-        List<Header> newHeaders = new ArrayList<>();
-        newHeaders.addAll(responseHeaders);
-        newHeaders.add(null); // Delimit separate blocks of headers with null.
-        newHeaders.addAll(headers);
-        this.responseHeaders = newHeaders;
-      }
+      headersQueue.add(Util.toHeaders(headers));
+      open = isOpen();
+      notifyAll();
     }
     if (!open) {
       connection.removeStream(id);
@@ -301,6 +314,13 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     }
   }
 
+  public synchronized void setHeadersListener(Header.Listener headersListener) {
+    this.headersListener = headersListener;
+    if (!headersQueue.isEmpty() && headersListener != null) {
+      notifyAll(); // We now have somewhere to deliver headers!
+    }
+  }
+
   /**
    * A source that reads the incoming data frames of a stream. Although this class uses
    * synchronization to safely receive incoming data frames, it is not intended for use by multiple
@@ -332,49 +352,83 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     @Override public long read(Buffer sink, long byteCount) throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
 
-      long read;
-      synchronized (Http2Stream.this) {
-        waitUntilReadable();
-        checkNotClosed();
-        if (readBuffer.size() == 0) return -1; // This source is exhausted.
-
-        // Move bytes from the read buffer into the caller's buffer.
-        read = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
-
-        // Flow control: notify the peer that we're ready for more data!
-        unacknowledgedBytesRead += read;
-        if (unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
-          connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
-          unacknowledgedBytesRead = 0;
+      while (true) {
+        Headers headersToDeliver = null;
+        Header.Listener headersListenerToNotify = null;
+        long readBytesDelivered = -1;
+        ErrorCode errorCodeToDeliver = null;
+
+        // 1. Decide what to do in a synchronized block.
+
+        synchronized (Http2Stream.this) {
+          readTimeout.enter();
+          try {
+            if (errorCode != null) {
+              // Prepare to deliver an error.
+              errorCodeToDeliver = errorCode;
+            }
+
+            if (closed) {
+              throw new IOException("stream closed");
+
+            } else if (!headersQueue.isEmpty() && headersListener != null) {
+              // Prepare to deliver headers.
+              headersToDeliver = headersQueue.removeFirst();
+              headersListenerToNotify = headersListener;
+
+            } else if (readBuffer.size() > 0) {
+              // Prepare to read bytes. Start by moving them to the caller's buffer.
+              readBytesDelivered = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
+              unacknowledgedBytesRead += readBytesDelivered;
+
+              if (errorCodeToDeliver == null
+                  && unacknowledgedBytesRead
+                  >= connection.okHttpSettings.getInitialWindowSize() / 2) {
+                // Flow control: notify the peer that we're ready for more data! Only send a
+                // WINDOW_UPDATE if the stream isn't in error.
+                connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
+                unacknowledgedBytesRead = 0;
+              }
+            } else if (!finished && errorCodeToDeliver == null) {
+              // Nothing to do. Wait until that changes then try again.
+              waitForIo();
+              continue;
+            }
+          } finally {
+            readTimeout.exitAndThrowIfTimedOut();
+          }
         }
-      }
 
-      // Update connection.unacknowledgedBytesRead outside the stream lock.
-      synchronized (connection) { // Multiple application threads may hit this section.
-        connection.unacknowledgedBytesRead += read;
-        if (connection.unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
-          connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
-          connection.unacknowledgedBytesRead = 0;
+        // 2. Do it outside of the synchronized block and timeout.
+
+        if (headersToDeliver != null && headersListenerToNotify != null) {
+          headersListenerToNotify.onHeaders(headersToDeliver);
+          continue;
         }
-      }
 
-      return read;
-    }
+        if (readBytesDelivered != -1) {
+          // Update connection.unacknowledgedBytesRead outside the synchronized block.
+          updateConnectionFlowControl(readBytesDelivered);
+          return readBytesDelivered;
+        }
 
-    /** Returns once the source is either readable or finished. */
-    private void waitUntilReadable() throws IOException {
-      readTimeout.enter();
-      try {
-        while (readBuffer.size() == 0 && !finished && !closed && errorCode == null) {
-          waitForIo();
+        if (errorCodeToDeliver != null) {
+          // We defer throwing the exception until now so that we can refill the connection
+          // flow-control window. This is necessary because we don't transmit window updates until
+          // the application reads the data. If we throw this prior to updating the connection
+          // flow-control window, we risk having it go to 0 preventing the server from sending data.
+          throw new StreamResetException(errorCodeToDeliver);
         }
-      } finally {
-        readTimeout.exitAndThrowIfTimedOut();
+
+        return -1; // This source is exhausted.
       }
     }
 
+    private void updateConnectionFlowControl(long read) {
+      assert (!Thread.holdsLock(Http2Stream.this));
+      connection.updateConnectionFlowControl(read);
+    }
+
     void receive(BufferedSource in, long byteCount) throws IOException {
       assert (!Thread.holdsLock(Http2Stream.this));
 
@@ -420,20 +474,28 @@ void receive(BufferedSource in, long byteCount) throws IOException {
     }
 
     @Override public void close() throws IOException {
+      long bytesDiscarded;
+      List<Headers> headersToDeliver = null;
+      Header.Listener headersListenerToNotify = null;
       synchronized (Http2Stream.this) {
         closed = true;
+        bytesDiscarded = readBuffer.size();
         readBuffer.clear();
-        Http2Stream.this.notifyAll();
+        if (!headersQueue.isEmpty() && headersListener != null) {
+          headersToDeliver = new ArrayList<>(headersQueue);
+          headersQueue.clear();
+          headersListenerToNotify = headersListener;
+        }
+        Http2Stream.this.notifyAll(); // TODO(jwilson): Unnecessary?
       }
-      cancelStreamIfNecessary();
-    }
-
-    private void checkNotClosed() throws IOException {
-      if (closed) {
-        throw new IOException("stream closed");
+      if (bytesDiscarded > 0) {
+        updateConnectionFlowControl(bytesDiscarded);
       }
-      if (errorCode != null) {
-        throw new StreamResetException(errorCode);
+      cancelStreamIfNecessary();
+      if (headersListenerToNotify != null) {
+        for (Headers headers : headersToDeliver) {
+          headersListenerToNotify.onHeaders(headers);
+        }
       }
     }
   }
@@ -576,6 +638,7 @@ void waitForIo() throws InterruptedIOException {
     try {
       wait();
     } catch (InterruptedException e) {
+      Thread.currentThread().interrupt(); // Retain interrupted status.
       throw new InterruptedIOException();
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Ping.java b/okhttp/src/main/java/okhttp3/internal/http2/Ping.java
deleted file mode 100644
index 7847db7aab..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Ping.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-/**
- * A locally-originated ping.
- */
-final class Ping {
-  private final CountDownLatch latch = new CountDownLatch(1);
-  private long sent = -1;
-  private long received = -1;
-
-  Ping() {
-  }
-
-  void send() {
-    if (sent != -1) throw new IllegalStateException();
-    sent = System.nanoTime();
-  }
-
-  void receive() {
-    if (received != -1 || sent == -1) throw new IllegalStateException();
-    received = System.nanoTime();
-    latch.countDown();
-  }
-
-  void cancel() {
-    if (received != -1 || sent == -1) throw new IllegalStateException();
-    received = sent - 1;
-    latch.countDown();
-  }
-
-  /**
-   * Returns the round trip time for this ping in nanoseconds, waiting for the response to arrive if
-   * necessary. Returns -1 if the response was canceled.
-   */
-  public long roundTripTime() throws InterruptedException {
-    latch.await();
-    return received - sent;
-  }
-
-  /**
-   * Returns the round trip time for this ping in nanoseconds, or -1 if the response was canceled,
-   * or -2 if the timeout elapsed before the round trip completed.
-   */
-  public long roundTripTime(long timeout, TimeUnit unit) throws InterruptedException {
-    if (latch.await(timeout, unit)) {
-      return received - sent;
-    } else {
-      return -2;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
index 342e91f150..08b102c6e0 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
@@ -23,11 +23,14 @@
 import java.lang.reflect.Method;
 import java.net.InetSocketAddress;
 import java.net.Socket;
+import java.security.NoSuchAlgorithmException;
 import java.security.Security;
 import java.security.cert.Certificate;
 import java.security.cert.TrustAnchor;
 import java.security.cert.X509Certificate;
 import java.util.List;
+import javax.annotation.Nullable;
+import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
@@ -90,7 +93,7 @@
     }
   }
 
-  @Override protected X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+  @Override protected @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
     Object context = readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters");
     if (context == null) {
       // If that didn't work, try the Google Play Services SSL provider before giving up. This
@@ -127,7 +130,7 @@
     }
   }
 
-  @Override public String getSelectedProtocol(SSLSocket socket) {
+  @Override public @Nullable String getSelectedProtocol(SSLSocket socket) {
     if (getAlpnSelectedProtocol == null) return null;
     if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
 
@@ -135,7 +138,7 @@
     return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
   }
 
-  @Override public void log(int level, String message, Throwable t) {
+  @Override public void log(int level, String message, @Nullable Throwable t) {
     int logLevel = level == WARN ? Log.WARN : Log.DEBUG;
     if (t != null) message = message + '\n' + Log.getStackTraceString(t);
 
@@ -426,4 +429,29 @@ public int hashCode() {
       return trustManager.hashCode() + 31 * findByIssuerAndSignatureMethod.hashCode();
     }
   }
+
+  @Override public SSLContext getSSLContext() {
+    boolean tryTls12;
+    try {
+      tryTls12 = (Build.VERSION.SDK_INT >= 16 && Build.VERSION.SDK_INT < 22);
+    } catch (NoClassDefFoundError e) {
+      // Not a real Android runtime; probably RoboVM or MoE
+      // Try to load TLS 1.2 explicitly.
+      tryTls12 = true;
+    }
+
+    if (tryTls12) {
+      try {
+        return SSLContext.getInstance("TLSv1.2");
+      } catch (NoSuchAlgorithmException e) {
+        // fallback to TLS
+      }
+    }
+
+    try {
+      return SSLContext.getInstance("TLS");
+    } catch (NoSuchAlgorithmException e) {
+      throw new IllegalStateException("No TLS provider", e);
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java
new file mode 100644
index 0000000000..e460595329
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import java.security.NoSuchAlgorithmException;
+import java.security.Provider;
+import java.util.List;
+import javax.annotation.Nullable;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.Protocol;
+import org.conscrypt.Conscrypt;
+
+/**
+ * Platform using Conscrypt (conscrypt.org) if installed as the first Security Provider.
+ *
+ * Requires org.conscrypt:conscrypt-openjdk-uber on the classpath.
+ */
+public class ConscryptPlatform extends Platform {
+  private ConscryptPlatform() {
+  }
+
+  private Provider getProvider() {
+    return Conscrypt.newProviderBuilder().provideTrustManager().build();
+  }
+
+  @Override public @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+    if (!Conscrypt.isConscrypt(sslSocketFactory)) {
+      return super.trustManager(sslSocketFactory);
+    }
+
+    try {
+      // org.conscrypt.SSLParametersImpl
+      Object sp =
+          readFieldOrNull(sslSocketFactory, Object.class, "sslParameters");
+
+      if (sp != null) {
+        return readFieldOrNull(sp, X509TrustManager.class, "x509TrustManager");
+      }
+
+      return null;
+    } catch (Exception e) {
+      throw new UnsupportedOperationException(
+          "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on Conscrypt", e);
+    }
+  }
+
+  @Override public void configureTlsExtensions(
+      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+    if (Conscrypt.isConscrypt(sslSocket)) {
+      // Enable SNI and session tickets.
+      if (hostname != null) {
+        Conscrypt.setUseSessionTickets(sslSocket, true);
+        Conscrypt.setHostname(sslSocket, hostname);
+      }
+
+      // Enable ALPN.
+      List<String> names = Platform.alpnProtocolNames(protocols);
+      Conscrypt.setApplicationProtocols(sslSocket, names.toArray(new String[0]));
+    } else {
+      super.configureTlsExtensions(sslSocket, hostname, protocols);
+    }
+  }
+
+  @Override public @Nullable String getSelectedProtocol(SSLSocket sslSocket) {
+    if (Conscrypt.isConscrypt(sslSocket)) {
+      return Conscrypt.getApplicationProtocol(sslSocket);
+    } else {
+      return super.getSelectedProtocol(sslSocket);
+    }
+  }
+
+  @Override public SSLContext getSSLContext() {
+    try {
+      return SSLContext.getInstance("TLSv1.3", getProvider());
+    } catch (NoSuchAlgorithmException e) {
+      try {
+        // Allow for Conscrypt 1.2
+        return SSLContext.getInstance("TLS", getProvider());
+      } catch (NoSuchAlgorithmException e2) {
+        throw new IllegalStateException("No TLS provider", e);
+      }
+    }
+  }
+
+  public static ConscryptPlatform buildIfSupported() {
+    try {
+      // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
+      Class.forName("org.conscrypt.Conscrypt");
+
+      if (!Conscrypt.isAvailable()) {
+        return null;
+      }
+
+      return new ConscryptPlatform();
+    } catch (ClassNotFoundException e) {
+      return null;
+    }
+  }
+
+  @Override
+  public void configureSslSocketFactory(SSLSocketFactory socketFactory) {
+    if (Conscrypt.isConscrypt(socketFactory)) {
+      Conscrypt.setUseEngineSocket(socketFactory, true);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
index 24b75217b0..455e8bcbb8 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
@@ -18,6 +18,7 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.List;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLParameters;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
@@ -56,7 +57,7 @@ public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
   }
 
   @Override
-  public String getSelectedProtocol(SSLSocket socket) {
+  public @Nullable String getSelectedProtocol(SSLSocket socket) {
     try {
       String protocol = (String) getProtocolMethod.invoke(socket);
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
index bfb4ed8c89..dee0b3fe53 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.util.List;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Protocol;
 import okhttp3.internal.Util;
@@ -66,7 +67,7 @@
     }
   }
 
-  @Override public String getSelectedProtocol(SSLSocket socket) {
+  @Override public @Nullable String getSelectedProtocol(SSLSocket socket) {
     try {
       JettyNegoProvider provider =
           (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
index f8725af47b..ac15233867 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
@@ -21,10 +21,12 @@
 import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.security.NoSuchAlgorithmException;
+import java.security.Security;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
@@ -87,7 +89,7 @@ public String getPrefix() {
     return "OkHttp";
   }
 
-  protected X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+  protected @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
     // Attempt to get the trust manager from an OpenJDK socket factory. We attempt this on all
     // platforms in order to support Robolectric, which mixes classes from both Android and the
     // Oracle JDK. Note that we don't support HTTP/2 or other nice features on Robolectric.
@@ -106,7 +108,7 @@ protected X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
    *
    * @param hostname non-null for client-side handshakes; null for server-side handshakes.
    */
-  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
+  public void configureTlsExtensions(SSLSocket sslSocket, @Nullable String hostname,
       List<Protocol> protocols) {
   }
 
@@ -118,16 +120,16 @@ public void afterHandshake(SSLSocket sslSocket) {
   }
 
   /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  public String getSelectedProtocol(SSLSocket socket) {
+  public @Nullable String getSelectedProtocol(SSLSocket socket) {
     return null;
   }
 
-  public void connectSocket(Socket socket, InetSocketAddress address,
-      int connectTimeout) throws IOException {
+  public void connectSocket(Socket socket, InetSocketAddress address, int connectTimeout)
+      throws IOException {
     socket.connect(address, connectTimeout);
   }
 
-  public void log(int level, String message, Throwable t) {
+  public void log(int level, String message, @Nullable Throwable t) {
     Level logLevel = level == WARN ? Level.WARNING : Level.INFO;
     logger.log(logLevel, message, t);
   }
@@ -174,13 +176,26 @@ public CertificateChainCleaner buildCertificateChainCleaner(SSLSocketFactory ssl
     X509TrustManager trustManager = trustManager(sslSocketFactory);
 
     if (trustManager == null) {
-      throw new IllegalStateException("Unable to extract the trust manager on " + Platform.get()
-          + ", sslSocketFactory is " + sslSocketFactory.getClass());
+      throw new IllegalStateException("Unable to extract the trust manager on "
+          + Platform.get()
+          + ", sslSocketFactory is "
+          + sslSocketFactory.getClass());
     }
 
     return buildCertificateChainCleaner(trustManager);
   }
 
+  public static boolean isConscryptPreferred() {
+    // mainly to allow tests to run cleanly
+    if ("conscrypt".equals(System.getProperty("okhttp.platform"))) {
+      return true;
+    }
+
+    // check if Provider manually installed
+    String preferredProvider = Security.getProviders()[0].getName();
+    return "Conscrypt".equals(preferredProvider);
+  }
+
   /** Attempt to match the host runtime to a capable Platform implementation. */
   private static Platform findPlatform() {
     Platform android = AndroidPlatform.buildIfSupported();
@@ -189,6 +204,14 @@ private static Platform findPlatform() {
       return android;
     }
 
+    if (isConscryptPreferred()) {
+      Platform conscrypt = ConscryptPlatform.buildIfSupported();
+
+      if (conscrypt != null) {
+        return conscrypt;
+      }
+    }
+
     Platform jdk9 = Jdk9Platform.buildIfSupported();
 
     if (jdk9 != null) {
@@ -220,7 +243,7 @@ private static Platform findPlatform() {
     return result.readByteArray();
   }
 
-  static <T> T readFieldOrNull(Object instance, Class<T> fieldType, String fieldName) {
+  static @Nullable <T> T readFieldOrNull(Object instance, Class<T> fieldType, String fieldName) {
     for (Class<?> c = instance.getClass(); c != Object.class; c = c.getSuperclass()) {
       try {
         Field field = c.getDeclaredField(fieldName);
@@ -244,6 +267,16 @@ private static Platform findPlatform() {
   }
 
   public SSLContext getSSLContext() {
+    String jvmVersion = System.getProperty("java.specification.version");
+    if ("1.7".equals(jvmVersion)) {
+      try {
+        // JDK 1.7 (public version) only support > TLSv1 with named protocols
+        return SSLContext.getInstance("TLSv1.2");
+      } catch (NoSuchAlgorithmException e) {
+        // fallback to TLS
+      }
+    }
+
     try {
       return SSLContext.getInstance("TLS");
     } catch (NoSuchAlgorithmException e) {
@@ -254,4 +287,11 @@ public SSLContext getSSLContext() {
   public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
     return new BasicTrustRootIndex(trustManager.getAcceptedIssuers());
   }
+
+  public void configureSslSocketFactory(SSLSocketFactory socketFactory) {
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName();
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java b/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java
new file mode 100644
index 0000000000..d18b6335f1
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.proxy;
+
+import java.io.IOException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A proxy selector that always returns the {@link Proxy#NO_PROXY}.
+ */
+public class NullProxySelector extends ProxySelector {
+  @Override public List<Proxy> select(URI uri) {
+    if (uri == null) {
+      throw new IllegalArgumentException("uri must not be null");
+    }
+    return Collections.singletonList(Proxy.NO_PROXY);
+  }
+
+  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
index 75dafdd0a3..0e39bd0f87 100644
--- a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
@@ -63,12 +63,14 @@ public static PublicSuffixDatabase get() {
 
   /**
    * Returns the effective top-level domain plus one (eTLD+1) by referencing the public suffix list.
-   * Returns null if the domain is a public suffix.
+   * Returns null if the domain is a public suffix or a private address.
    *
    * <p>Here are some examples: <pre>{@code
    * assertEquals("google.com", getEffectiveTldPlusOne("google.com"));
    * assertEquals("google.com", getEffectiveTldPlusOne("www.google.com"));
    * assertNull(getEffectiveTldPlusOne("com"));
+   * assertNull(getEffectiveTldPlusOne("localhost"));
+   * assertNull(getEffectiveTldPlusOne("mymacbook"));
    * }</pre>
    *
    * @param domain A canonicalized domain. An International Domain Name (IDN) should be punycode
@@ -112,6 +114,7 @@ public String getEffectiveTldPlusOne(String domain) {
       try {
         readCompleteLatch.await();
       } catch (InterruptedException ignored) {
+        Thread.currentThread().interrupt(); // Retain interrupted status.
       }
     }
 
@@ -289,6 +292,7 @@ private void readTheListUninterruptibly() {
           readTheList();
           return;
         } catch (InterruptedIOException e) {
+          Thread.interrupted(); // Temporarily clear the interrupted state.
           interrupted = true;
         } catch (IOException e) {
           Platform.get().log(Platform.WARN, "Failed to read public suffix list", e);
@@ -297,7 +301,7 @@ private void readTheListUninterruptibly() {
       }
     } finally {
       if (interrupted) {
-        Thread.currentThread().interrupt();
+        Thread.currentThread().interrupt(); // Retain interrupted status.
       }
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
index 0d39abc8d5..baee049f1b 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -18,6 +18,7 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.net.ProtocolException;
+import java.net.SocketTimeoutException;
 import java.util.ArrayDeque;
 import java.util.Collections;
 import java.util.List;
@@ -72,6 +73,7 @@
 
   final WebSocketListener listener;
   private final Random random;
+  private final long pingIntervalMillis;
   private final String key;
 
   /** Non-null for client web sockets. These can be canceled. */
@@ -125,19 +127,27 @@
   /** True if this web socket failed and the listener has been notified. */
   private boolean failed;
 
-  /** For testing. */
-  int pingCount;
+  /** Total number of pings sent by this web socket. */
+  private int sentPingCount;
 
-  /** For testing. */
-  int pongCount;
+  /** Total number of pings received by this web socket. */
+  private int receivedPingCount;
 
-  public RealWebSocket(Request request, WebSocketListener listener, Random random) {
+  /** Total number of pongs received by this web socket. */
+  private int receivedPongCount;
+
+  /** True if we have sent a ping that is still awaiting a reply. */
+  private boolean awaitingPong;
+
+  public RealWebSocket(Request request, WebSocketListener listener, Random random,
+      long pingIntervalMillis) {
     if (!"GET".equals(request.method())) {
       throw new IllegalArgumentException("Request must be GET: " + request.method());
     }
     this.originalRequest = request;
     this.listener = listener;
     this.random = random;
+    this.pingIntervalMillis = pingIntervalMillis;
 
     byte[] nonce = new byte[16];
     random.nextBytes(nonce);
@@ -172,7 +182,6 @@ public void connect(OkHttpClient client) {
         .eventListener(EventListener.NONE)
         .protocols(ONLY_HTTP1)
         .build();
-    final int pingIntervalMillis = client.pingIntervalMillis();
     final Request request = originalRequest.newBuilder()
         .header("Upgrade", "websocket")
         .header("Connection", "Upgrade")
@@ -180,6 +189,7 @@ public void connect(OkHttpClient client) {
         .header("Sec-WebSocket-Version", "13")
         .build();
     call = Internal.instance.newWebSocketCall(client, request);
+    call.timeout().clearTimeout();
     call.enqueue(new Callback() {
       @Override public void onResponse(Call call, Response response) {
         try {
@@ -199,7 +209,7 @@ public void connect(OkHttpClient client) {
         try {
           listener.onOpen(RealWebSocket.this, response);
           String name = "OkHttp WebSocket " + request.url().redact();
-          initReaderAndWriter(name, pingIntervalMillis, streams);
+          initReaderAndWriter(name, streams);
           streamAllocation.connection().socket().setSoTimeout(0);
           loopReader();
         } catch (Exception e) {
@@ -240,8 +250,7 @@ void checkResponse(Response response) throws ProtocolException {
     }
   }
 
-  public void initReaderAndWriter(
-      String name, long pingIntervalMillis, Streams streams) throws IOException {
+  public void initReaderAndWriter(String name, Streams streams) throws IOException {
     synchronized (this) {
       this.streams = streams;
       this.writer = new WebSocketWriter(streams.client, streams.sink, random);
@@ -298,12 +307,16 @@ void tearDown() throws InterruptedException {
     executor.awaitTermination(10, TimeUnit.SECONDS);
   }
 
-  synchronized int pingCount() {
-    return pingCount;
+  synchronized int sentPingCount() {
+    return sentPingCount;
+  }
+
+  synchronized int receivedPingCount() {
+    return receivedPingCount;
   }
 
-  synchronized int pongCount() {
-    return pongCount;
+  synchronized int receivedPongCount() {
+    return receivedPongCount;
   }
 
   @Override public void onReadMessage(String text) throws IOException {
@@ -320,12 +333,13 @@ synchronized int pongCount() {
 
     pongQueue.add(payload);
     runWriter();
-    pingCount++;
+    receivedPingCount++;
   }
 
   @Override public synchronized void onReadPong(ByteString buffer) {
     // This API doesn't expose pings.
-    pongCount++;
+    receivedPongCount++;
+    awaitingPong = false;
   }
 
   @Override public void onReadClose(int code, String reason) {
@@ -519,9 +533,20 @@ boolean writeOneFrame() throws IOException {
 
   void writePingFrame() {
     WebSocketWriter writer;
+    int failedPing;
     synchronized (this) {
       if (failed) return;
       writer = this.writer;
+      failedPing = awaitingPong ? sentPingCount : -1;
+      sentPingCount++;
+      awaitingPong = true;
+    }
+
+    if (failedPing != -1) {
+      failWebSocket(new SocketTimeoutException("sent ping but didn't receive pong within "
+          + pingIntervalMillis + "ms (after " + (failedPing - 1) + " successful ping/pongs)"),
+          null);
+      return;
     }
 
     try {
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
index 5be61eea5f..489979845e 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
@@ -15,8 +15,7 @@
  */
 package okhttp3.internal.ws;
 
-import java.io.IOException;
-import java.net.ProtocolException;
+import okio.Buffer;
 import okio.ByteString;
 
 public final class WebSocketProtocol {
@@ -90,19 +89,19 @@
 
   /** Used when an unchecked exception was thrown in a listener. */
   static final int CLOSE_CLIENT_GOING_AWAY = 1001;
-  /** Used when a {@link ProtocolException} was thrown by the reader or writer. */
-  static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
   /** Used when an empty close frame was received (i.e., without a status code). */
   static final int CLOSE_NO_STATUS_CODE = 1005;
-  /** Used when a non-{@link ProtocolException} {@link IOException} was thrown by the reader. */
-  static final int CLOSE_ABNORMAL_TERMINATION = 1006;
 
-  static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameBytesRead) {
+  static void toggleMask(Buffer.UnsafeCursor cursor, byte[] key) {
+    int keyIndex = 0;
     int keyLength = key.length;
-    for (int i = 0; i < byteCount; i++, frameBytesRead++) {
-      int keyIndex = (int) (frameBytesRead % keyLength);
-      buffer[i] = (byte) (buffer[i] ^ key[keyIndex]);
-    }
+    do {
+      byte[] buffer = cursor.data;
+      for (int i = cursor.start, end = cursor.end; i < end; i++, keyIndex++) {
+        keyIndex %= keyLength; // Reassign to prevent overflow breaking counter.
+        buffer[i] = (byte) (buffer[i] ^ key[keyIndex]);
+      }
+    } while (cursor.next() != -1);
   }
 
   static String closeCodeExceptionMessage(int code) {
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
index f2844737cc..6d5d22e67d 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
@@ -15,7 +15,6 @@
  */
 package okhttp3.internal.ws;
 
-import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.concurrent.TimeUnit;
@@ -67,13 +66,14 @@
   // Stateful data about the current frame.
   int opcode;
   long frameLength;
-  long frameBytesRead;
   boolean isFinalFrame;
   boolean isControlFrame;
-  boolean isMasked;
 
-  final byte[] maskKey = new byte[4];
-  final byte[] maskBuffer = new byte[8192];
+  private final Buffer controlFrameBuffer = new Buffer();
+  private final Buffer messageFrameBuffer = new Buffer();
+
+  private final byte[] maskKey;
+  private final Buffer.UnsafeCursor maskCursor;
 
   WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
     if (source == null) throw new NullPointerException("source == null");
@@ -81,6 +81,10 @@
     this.isClient = isClient;
     this.source = source;
     this.frameCallback = frameCallback;
+
+    // Masks are only a concern for server writers.
+    maskKey = isClient ? null : new byte[4];
+    maskCursor = isClient ? null : new Buffer.UnsafeCursor();
   }
 
   /**
@@ -134,7 +138,7 @@ private void readHeader() throws IOException {
 
     int b1 = source.readByte() & 0xff;
 
-    isMasked = (b1 & B1_FLAG_MASK) != 0;
+    boolean isMasked = (b1 & B1_FLAG_MASK) != 0;
     if (isMasked == isClient) {
       // Masked payloads must be read on the server. Unmasked payloads must be read on the client.
       throw new ProtocolException(isClient
@@ -153,7 +157,6 @@ private void readHeader() throws IOException {
             "Frame length 0x" + Long.toHexString(frameLength) + " > 0x7FFFFFFFFFFFFFFF");
       }
     }
-    frameBytesRead = 0;
 
     if (isControlFrame && frameLength > PAYLOAD_BYTE_MAX) {
       throw new ProtocolException("Control frame must be less than " + PAYLOAD_BYTE_MAX + "B.");
@@ -166,38 +169,33 @@ private void readHeader() throws IOException {
   }
 
   private void readControlFrame() throws IOException {
-    Buffer buffer = new Buffer();
-    if (frameBytesRead < frameLength) {
-      if (isClient) {
-        source.readFully(buffer, frameLength);
-      } else {
-        while (frameBytesRead < frameLength) {
-          int toRead = (int) Math.min(frameLength - frameBytesRead, maskBuffer.length);
-          int read = source.read(maskBuffer, 0, toRead);
-          if (read == -1) throw new EOFException();
-          toggleMask(maskBuffer, read, maskKey, frameBytesRead);
-          buffer.write(maskBuffer, 0, read);
-          frameBytesRead += read;
-        }
+    if (frameLength > 0) {
+      source.readFully(controlFrameBuffer, frameLength);
+
+      if (!isClient) {
+        controlFrameBuffer.readAndWriteUnsafe(maskCursor);
+        maskCursor.seek(0);
+        toggleMask(maskCursor, maskKey);
+        maskCursor.close();
       }
     }
 
     switch (opcode) {
       case OPCODE_CONTROL_PING:
-        frameCallback.onReadPing(buffer.readByteString());
+        frameCallback.onReadPing(controlFrameBuffer.readByteString());
         break;
       case OPCODE_CONTROL_PONG:
-        frameCallback.onReadPong(buffer.readByteString());
+        frameCallback.onReadPong(controlFrameBuffer.readByteString());
         break;
       case OPCODE_CONTROL_CLOSE:
         int code = CLOSE_NO_STATUS_CODE;
         String reason = "";
-        long bufferSize = buffer.size();
+        long bufferSize = controlFrameBuffer.size();
         if (bufferSize == 1) {
           throw new ProtocolException("Malformed close payload length of 1.");
         } else if (bufferSize != 0) {
-          code = buffer.readShort();
-          reason = buffer.readUtf8();
+          code = controlFrameBuffer.readShort();
+          reason = controlFrameBuffer.readUtf8();
           String codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code);
           if (codeExceptionMessage != null) throw new ProtocolException(codeExceptionMessage);
         }
@@ -215,18 +213,17 @@ private void readMessageFrame() throws IOException {
       throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
     }
 
-    Buffer message = new Buffer();
-    readMessage(message);
+    readMessage();
 
     if (opcode == OPCODE_TEXT) {
-      frameCallback.onReadMessage(message.readUtf8());
+      frameCallback.onReadMessage(messageFrameBuffer.readUtf8());
     } else {
-      frameCallback.onReadMessage(message.readByteString());
+      frameCallback.onReadMessage(messageFrameBuffer.readByteString());
     }
   }
 
   /** Read headers and process any control frames until we reach a non-control frame. */
-  void readUntilNonControlFrame() throws IOException {
+  private void readUntilNonControlFrame() throws IOException {
     while (!closed) {
       readHeader();
       if (!isControlFrame) {
@@ -241,37 +238,27 @@ void readUntilNonControlFrame() throws IOException {
    * fragments will be processed. If the message payload is masked this will unmask as it's being
    * processed.
    */
-  private void readMessage(Buffer sink) throws IOException {
+  private void readMessage() throws IOException {
     while (true) {
       if (closed) throw new IOException("closed");
 
-      if (frameBytesRead == frameLength) {
-        if (isFinalFrame) return; // We are exhausted and have no continuations.
+      if (frameLength > 0) {
+        source.readFully(messageFrameBuffer, frameLength);
 
-        readUntilNonControlFrame();
-        if (opcode != OPCODE_CONTINUATION) {
-          throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
-        }
-        if (isFinalFrame && frameLength == 0) {
-          return; // Fast-path for empty final frame.
+        if (!isClient) {
+          messageFrameBuffer.readAndWriteUnsafe(maskCursor);
+          maskCursor.seek(messageFrameBuffer.size() - frameLength);
+          toggleMask(maskCursor, maskKey);
+          maskCursor.close();
         }
       }
 
-      long toRead = frameLength - frameBytesRead;
-
-      long read;
-      if (isMasked) {
-        toRead = Math.min(toRead, maskBuffer.length);
-        read = source.read(maskBuffer, 0, (int) toRead);
-        if (read == -1) throw new EOFException();
-        toggleMask(maskBuffer, read, maskKey, frameBytesRead);
-        sink.write(maskBuffer, 0, (int) read);
-      } else {
-        read = source.read(sink, toRead);
-        if (read == -1) throw new EOFException();
-      }
+      if (isFinalFrame) break; // We are exhausted and have no continuations.
 
-      frameBytesRead += read;
+      readUntilNonControlFrame();
+      if (opcode != OPCODE_CONTINUATION) {
+        throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
+      }
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
index 321b5ae475..baffe06b19 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -45,9 +45,9 @@
   final boolean isClient;
   final Random random;
 
-  /** Writes must be guarded by synchronizing on 'this'. */
   final BufferedSink sink;
-  /** Access must be guarded by synchronizing on 'this'. */
+  /** The {@link Buffer} of {@link #sink}. Write to this and then flush/emit {@link #sink}. */
+  final Buffer sinkBuffer;
   boolean writerClosed;
 
   final Buffer buffer = new Buffer();
@@ -55,19 +55,20 @@
 
   boolean activeWriter;
 
-  final byte[] maskKey;
-  final byte[] maskBuffer;
+  private final byte[] maskKey;
+  private final Buffer.UnsafeCursor maskCursor;
 
   WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
     if (sink == null) throw new NullPointerException("sink == null");
     if (random == null) throw new NullPointerException("random == null");
     this.isClient = isClient;
     this.sink = sink;
+    this.sinkBuffer = sink.buffer();
     this.random = random;
 
     // Masks are only a concern for client writers.
     maskKey = isClient ? new byte[4] : null;
-    maskBuffer = isClient ? new byte[8192] : null;
+    maskCursor = isClient ? new Buffer.UnsafeCursor() : null;
   }
 
   /** Send a ping with the supplied {@code payload}. */
@@ -118,22 +119,28 @@ private void writeControlFrame(int opcode, ByteString payload) throws IOExceptio
     }
 
     int b0 = B0_FLAG_FIN | opcode;
-    sink.writeByte(b0);
+    sinkBuffer.writeByte(b0);
 
     int b1 = length;
     if (isClient) {
       b1 |= B1_FLAG_MASK;
-      sink.writeByte(b1);
+      sinkBuffer.writeByte(b1);
 
       random.nextBytes(maskKey);
-      sink.write(maskKey);
+      sinkBuffer.write(maskKey);
 
-      byte[] bytes = payload.toByteArray();
-      toggleMask(bytes, bytes.length, maskKey, 0);
-      sink.write(bytes);
+      if (length > 0) {
+        long payloadStart = sinkBuffer.size();
+        sinkBuffer.write(payload);
+
+        sinkBuffer.readAndWriteUnsafe(maskCursor);
+        maskCursor.seek(payloadStart);
+        toggleMask(maskCursor, maskKey);
+        maskCursor.close();
+      }
     } else {
-      sink.writeByte(b1);
-      sink.write(payload);
+      sinkBuffer.writeByte(b1);
+      sinkBuffer.write(payload);
     }
 
     sink.flush();
@@ -166,7 +173,7 @@ void writeMessageFrame(int formatOpcode, long byteCount, boolean isFirstFrame,
     if (isFinal) {
       b0 |= B0_FLAG_FIN;
     }
-    sink.writeByte(b0);
+    sinkBuffer.writeByte(b0);
 
     int b1 = 0;
     if (isClient) {
@@ -174,31 +181,32 @@ void writeMessageFrame(int formatOpcode, long byteCount, boolean isFirstFrame,
     }
     if (byteCount <= PAYLOAD_BYTE_MAX) {
       b1 |= (int) byteCount;
-      sink.writeByte(b1);
+      sinkBuffer.writeByte(b1);
     } else if (byteCount <= PAYLOAD_SHORT_MAX) {
       b1 |= PAYLOAD_SHORT;
-      sink.writeByte(b1);
-      sink.writeShort((int) byteCount);
+      sinkBuffer.writeByte(b1);
+      sinkBuffer.writeShort((int) byteCount);
     } else {
       b1 |= PAYLOAD_LONG;
-      sink.writeByte(b1);
-      sink.writeLong(byteCount);
+      sinkBuffer.writeByte(b1);
+      sinkBuffer.writeLong(byteCount);
     }
 
     if (isClient) {
       random.nextBytes(maskKey);
-      sink.write(maskKey);
-
-      for (long written = 0; written < byteCount; ) {
-        int toRead = (int) Math.min(byteCount, maskBuffer.length);
-        int read = buffer.read(maskBuffer, 0, toRead);
-        if (read == -1) throw new AssertionError();
-        toggleMask(maskBuffer, read, maskKey, written);
-        sink.write(maskBuffer, 0, read);
-        written += read;
+      sinkBuffer.write(maskKey);
+
+      if (byteCount > 0) {
+        long bufferStart = sinkBuffer.size();
+        sinkBuffer.write(buffer, byteCount);
+
+        sinkBuffer.readAndWriteUnsafe(maskCursor);
+        maskCursor.seek(bufferStart);
+        toggleMask(maskCursor, maskKey);
+        maskCursor.close();
       }
     } else {
-      sink.write(buffer, byteCount);
+      sinkBuffer.write(buffer, byteCount);
     }
 
     sink.emit();
diff --git a/okhttp/src/main/java/okhttp3/package-info.java b/okhttp/src/main/java/okhttp3/package-info.java
index a34c5bbf86..725b054363 100644
--- a/okhttp/src/main/java/okhttp3/package-info.java
+++ b/okhttp/src/main/java/okhttp3/package-info.java
@@ -1,3 +1,3 @@
 /** An HTTP+HTTP/2 client for Android and Java applications. */
-@javax.annotation.ParametersAreNonnullByDefault
+@okhttp3.internal.annotations.EverythingIsNonNull
 package okhttp3;
diff --git a/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro b/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
new file mode 100644
index 0000000000..0c6f707575
--- /dev/null
+++ b/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
@@ -0,0 +1,11 @@
+# JSR 305 annotations are for embedding nullability information.
+-dontwarn javax.annotation.**
+
+# A resource is loaded with a relative path so the package of this class must be preserved.
+-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase
+
+# Animal Sniffer compileOnly dependency to ensure APIs are compatible with older versions of Java.
+-dontwarn org.codehaus.mojo.animal_sniffer.*
+
+# OkHttp platform used only on JVM and when Conscrypt dependency is available.
+-dontwarn okhttp3.internal.platform.ConscryptPlatform
diff --git a/pom.xml b/pom.xml
index 4b81396e12..339b59a04d 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>parent</artifactId>
-  <version>3.10.0-SNAPSHOT</version>
+  <version>3.13.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
@@ -25,13 +25,18 @@
     <module>okhttp-android-support</module>
 
     <module>okhttp-apache</module>
+    <module>okhttp-sse</module>
     <module>okhttp-testing-support</module>
+    <module>okhttp-tls</module>
     <module>okhttp-urlconnection</module>
 
     <module>okhttp-logging-interceptor</module>
 
+    <module>okhttp-dnsoverhttps</module>
+
     <module>okcurl</module>
     <module>mockwebserver</module>
+    <module>bom</module>
     <module>samples</module>
     <module>benchmarks</module>
   </modules>
@@ -45,12 +50,14 @@
     <alpn.jdk7.version>7.1.2.v20141202</alpn.jdk7.version>
     <android.version>4.1.1.4</android.version>
     <animal.sniffer.version>1.15</animal.sniffer.version>
-    <apache.http.version>4.2.2</apache.http.version>
-    <bouncycastle.version>1.50</bouncycastle.version>
+    <apache.http.version>4.2.6</apache.http.version>
+    <bouncycastle.version>1.60</bouncycastle.version>
     <guava.version>16.0</guava.version>
     <java.version>1.7</java.version>
     <moshi.version>1.1.0</moshi.version>
-    <okio.version>1.13.0</okio.version>
+    <jnr-unixsocket.version>0.19</jnr-unixsocket.version>
+    <okio.version>1.16.0</okio.version>
+    <conscrypt.version>1.4.0</conscrypt.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
@@ -126,6 +133,16 @@
         <artifactId>moshi</artifactId>
         <version>${moshi.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.github.jnr</groupId>
+        <artifactId>jnr-unixsocket</artifactId>
+        <version>${jnr-unixsocket.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.conscrypt</groupId>
+        <artifactId>conscrypt-openjdk-uber</artifactId>
+        <version>${conscrypt.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
@@ -135,7 +152,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.6.1</version>
+          <version>3.7.0</version>
           <configuration>
             <compilerId>javac-with-errorprone</compilerId>
             <forceJavacCompilerUse>true</forceJavacCompilerUse>
@@ -146,12 +163,12 @@
             <dependency>
               <groupId>org.codehaus.plexus</groupId>
               <artifactId>plexus-compiler-javac-errorprone</artifactId>
-              <version>2.8.1</version>
+              <version>2.8.4</version>
             </dependency>
             <dependency>
               <groupId>com.google.errorprone</groupId>
               <artifactId>error_prone_core</artifactId>
-              <version>2.0.16</version>
+              <version>2.3.1</version>
             </dependency>
           </dependencies>
         </plugin>
@@ -159,11 +176,12 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-surefire-plugin</artifactId>
-          <version>2.17</version>
+          <version>2.21.0</version>
           <configuration>
             <systemPropertyVariables>
               <okhttp.platform>${okhttp.platform}</okhttp.platform>
             </systemPropertyVariables>
+            <redirectTestOutputToFile>true</redirectTestOutputToFile>
             <properties>
               <!--
                 Configure a listener for enforcing that no uncaught exceptions issue from OkHttp
@@ -180,7 +198,7 @@
             <dependency>
               <groupId>org.apache.maven.surefire</groupId>
               <artifactId>surefire-junit47</artifactId>
-              <version>2.17</version>
+              <version>2.21.0</version>
             </dependency>
           </dependencies>
         </plugin>
@@ -188,7 +206,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-javadoc-plugin</artifactId>
-          <version>2.9</version>
+          <version>2.10.4</version>
         </plugin>
       </plugins>
     </pluginManagement>
@@ -333,6 +351,18 @@
         <okhttp.platform>jdk9</okhttp.platform>
       </properties>
     </profile>
+    <profile>
+      <id>conscrypt</id>
+      <properties>
+        <okhttp.platform>conscrypt</okhttp.platform>
+      </properties>
+      <dependencies>
+        <dependency>
+          <groupId>org.conscrypt</groupId>
+          <artifactId>conscrypt-openjdk-uber</artifactId>
+        </dependency>
+      </dependencies>
+    </profile>
     <!-- ALPN Versions targeted for each Java 8 minor release -->
     <!-- Check versions with this page: -->
     <!-- http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html#alpn-chapterchapterversions -->
@@ -606,5 +636,50 @@
         <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
       </properties>
     </profile>
+    <profile>
+      <id>alpn-when-jdk8_171</id>
+      <activation>
+        <jdk>1.8.0_171</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_172</id>
+      <activation>
+        <jdk>1.8.0_172</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_181</id>
+      <activation>
+        <jdk>1.8.0_181</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_191</id>
+      <activation>
+        <jdk>1.8.0_191</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.13.v20181017</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_192</id>
+      <activation>
+        <jdk>1.8.0_192</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.13.v20181017</alpn.jdk8.version>
+      </properties>
+    </profile>
   </profiles>
 </project>
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index 77eea94b1b..121f522335 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.10.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
diff --git a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
index 72f59d32c2..07f61032d3 100644
--- a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
+++ b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
@@ -140,7 +140,7 @@ public static void main(String[] args) throws IOException {
         .build();
 
     Crawler crawler = new Crawler(client);
-    crawler.queue.add(HttpUrl.parse(args[1]));
+    crawler.queue.add(HttpUrl.get(args[1]));
     crawler.parallelDrainQueue(threadCount);
   }
 }
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index c654656624..85f5d36f73 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.10.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
@@ -18,6 +18,16 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>com.squareup.moshi</groupId>
       <artifactId>moshi</artifactId>
diff --git a/samples/guide/src/main/java/okhttp3/guide/PostExample.java b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
index b6e70ccc7d..ddaacb6c5e 100644
--- a/samples/guide/src/main/java/okhttp3/guide/PostExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
@@ -8,8 +8,7 @@
 import okhttp3.Response;
 
 public class PostExample {
-  public static final MediaType JSON
-      = MediaType.parse("application/json; charset=utf-8");
+  public static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
 
   OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CurrentDateHeader.java b/samples/guide/src/main/java/okhttp3/recipes/CurrentDateHeader.java
new file mode 100644
index 0000000000..6c15d700df
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/CurrentDateHeader.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.util.Date;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class CurrentDateHeader {
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .addInterceptor(new CurrentDateInterceptor())
+      .build();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      System.out.println(response.request().header("Date"));
+    }
+  }
+
+  static class CurrentDateInterceptor implements Interceptor {
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+      Headers newHeaders = request.headers()
+          .newBuilder()
+          .add("Date", new Date())
+          .build();
+      Request newRequest = request.newBuilder()
+          .headers(newHeaders)
+          .build();
+      return chain.proceed(newRequest);
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CurrentDateHeader().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java b/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
new file mode 100644
index 0000000000..dd537f52b2
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.net.InetAddress;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
+
+/**
+ * Create an HTTPS server with a self-signed certificate that OkHttp trusts.
+ */
+public class HttpsServer {
+  public void run() throws Exception {
+    String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
+    HeldCertificate localhostCertificate = new HeldCertificate.Builder()
+        .addSubjectAlternativeName(localhost)
+        .build();
+
+    HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(localhostCertificate)
+        .build();
+    MockWebServer server = new MockWebServer();
+    server.useHttps(serverCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse());
+
+    HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(localhostCertificate.certificate())
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    System.out.println(response.handshake().tlsVersion());
+  }
+
+  public static void main(String... args) throws Exception {
+    new HttpsServer().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
index b216b24b3b..0e52cddd26 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
@@ -25,7 +25,7 @@
 
 public final class PostFile {
   public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
+      = MediaType.get("text/x-markdown; charset=utf-8");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
index 3e93a00e82..60534d7de2 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
@@ -30,7 +30,7 @@
    * these examples, please request your own client ID! https://api.imgur.com/oauth2
    */
   private static final String IMGUR_CLIENT_ID = "9199fdef135c122";
-  private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
+  private static final MediaType MEDIA_TYPE_PNG = MediaType.get("image/png");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
index 440c7768ea..90ec01c6b8 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
@@ -25,7 +25,7 @@
 
 public final class PostStreaming {
   public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
+      = MediaType.get("text/x-markdown; charset=utf-8");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
index b313ce0d1a..c73b9154ed 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
@@ -27,7 +27,7 @@
 
 public final class PostStreamingWithPipe {
   public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
+      = MediaType.get("text/x-markdown; charset=utf-8");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostString.java b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
index 8a312bde8a..6c8ea4f9e3 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostString.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
@@ -24,7 +24,7 @@
 
 public final class PostString {
   public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
+      = MediaType.get("text/x-markdown; charset=utf-8");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PreemptiveAuth.java b/samples/guide/src/main/java/okhttp3/recipes/PreemptiveAuth.java
new file mode 100644
index 0000000000..abbf0eb0c0
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PreemptiveAuth.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.Credentials;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class PreemptiveAuth {
+  private final OkHttpClient client;
+
+  public PreemptiveAuth() {
+    client = new OkHttpClient.Builder()
+        .addInterceptor(
+            new BasicAuthInterceptor("publicobject.com", "jesse", "password1"))
+        .build();
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/secrets/hellosecret.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PreemptiveAuth().run();
+  }
+
+  static final class BasicAuthInterceptor implements Interceptor {
+    private final String credentials;
+    private final String host;
+
+    BasicAuthInterceptor(String host, String username, String password) {
+      this.credentials = Credentials.basic(username, password);
+      this.host = host;
+    }
+
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+      if (request.url().host().equals(host)) {
+        request = request.newBuilder()
+            .header("Authorization", credentials)
+            .build();
+      }
+      return chain.proceed(request);
+    }
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
index b1a62c0fa3..5473f67011 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
@@ -39,7 +39,7 @@
    * https://console.developers.google.com/project
    */
   public static final String GOOGLE_API_KEY = "AIzaSyAx2WZYe0My0i-uGurpvraYJxO7XNbwiGs";
-  public static final MediaType MEDIA_TYPE_JSON = MediaType.parse("application/json");
+  public static final MediaType MEDIA_TYPE_JSON = MediaType.get("application/json");
 
   private final OkHttpClient client = new OkHttpClient.Builder()
       .addInterceptor(new GzipRequestInterceptor())
diff --git a/samples/pom.xml b/samples/pom.xml
index 4bb53c9d5b..4cb343bce2 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.10.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp3.sample</groupId>
@@ -20,6 +20,7 @@
     <module>simple-client</module>
     <module>slack</module>
     <module>static-server</module>
+    <module>unixdomainsockets</module>
   </modules>
 
   <build>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index 347edefa27..9b193b2033 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.10.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/slack/pom.xml b/samples/slack/pom.xml
index c76577e6c7..ea003abc2e 100644
--- a/samples/slack/pom.xml
+++ b/samples/slack/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.10.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>slack</artifactId>
diff --git a/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java b/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
index 04ba201c96..c0ad139aed 100644
--- a/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
+++ b/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
@@ -76,7 +76,7 @@ private HttpUrl redirectUrl() {
   }
 
   /** When the browser hits the redirect URL, use the provided code to ask Slack for a session. */
-  @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+  @Override public MockResponse dispatch(RecordedRequest request) {
     HttpUrl requestUrl = mockWebServer.url(request.getPath());
     String code = requestUrl.queryParameter("code");
     String stateString = requestUrl.queryParameter("state");
diff --git a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
index 0ec0ef7a45..4ab8565942 100644
--- a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
+++ b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
@@ -38,7 +38,7 @@
  * http://localhost:53203/oauth/}, passing the same port to this class’ constructor.
  */
 public final class SlackApi {
-  private final HttpUrl baseUrl = HttpUrl.parse("https://slack.com/api/");
+  private final HttpUrl baseUrl = HttpUrl.get("https://slack.com/api/");
   private final OkHttpClient httpClient;
   private final Moshi moshi;
 
@@ -120,7 +120,7 @@ public WebSocket rtm(HttpUrl url, WebSocketListener listener) {
     @FromJson HttpUrl urlFromJson(String urlString) {
       if (urlString.startsWith("wss:")) urlString = "https:" + urlString.substring(4);
       if (urlString.startsWith("ws:")) urlString = "http:" + urlString.substring(3);
-      return HttpUrl.parse(urlString);
+      return HttpUrl.get(urlString);
     }
   }
 }
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index 30b3cb8689..058d63f0ef 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.10.0-SNAPSHOT</version>
+    <version>3.13.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
diff --git a/samples/unixdomainsockets/pom.xml b/samples/unixdomainsockets/pom.xml
new file mode 100644
index 0000000000..0f1c5459fb
--- /dev/null
+++ b/samples/unixdomainsockets/pom.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3.sample</groupId>
+    <artifactId>sample-parent</artifactId>
+    <version>3.13.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>unixdomainsockets</artifactId>
+  <name>Sample: UNIX domain sockets</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.github.jnr</groupId>
+      <artifactId>jnr-unixsocket</artifactId>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java
new file mode 100644
index 0000000000..8512c2d38d
--- /dev/null
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.unixdomainsockets;
+
+import java.io.File;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+/**
+ * Create UNIX domain sockets for MockWebServer and OkHttp and connect 'em together. Note that we
+ * cannot do TLS over domain sockets.
+ */
+public class ClientAndServer {
+  public void run() throws Exception {
+    File socketFile = new File("/tmp/ClientAndServer.sock");
+    socketFile.delete(); // Clean up from previous runs.
+
+    MockWebServer server = new MockWebServer();
+    server.setServerSocketFactory(new UnixDomainServerSocketFactory(socketFile));
+    server.enqueue(new MockResponse().setBody("hello"));
+    server.start();
+
+    OkHttpClient client = new OkHttpClient.Builder()
+        .socketFactory(new UnixDomainSocketFactory(socketFile))
+        .build();
+
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      System.out.println(response.body().string());
+    }
+
+    server.shutdown();
+    socketFile.delete();
+  }
+
+  public static void main(String... args) throws Exception {
+    new ClientAndServer().run();
+  }
+}
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java
new file mode 100644
index 0000000000..f9ec4a08f8
--- /dev/null
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.unixdomainsockets;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketAddress;
+import javax.net.ServerSocketFactory;
+import jnr.unixsocket.UnixServerSocketChannel;
+import jnr.unixsocket.UnixSocket;
+import jnr.unixsocket.UnixSocketAddress;
+import jnr.unixsocket.UnixSocketChannel;
+
+/** Impersonate TCP-style ServerSocketFactory over UNIX domain sockets. */
+public final class UnixDomainServerSocketFactory extends ServerSocketFactory {
+  private final File path;
+
+  public UnixDomainServerSocketFactory(File path) {
+    this.path = path;
+  }
+
+  private ServerSocket createUnixDomainSocket() throws IOException {
+    return new UnixDomainServerSocket();
+  }
+
+  @Override public ServerSocket createServerSocket() throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public ServerSocket createServerSocket(int port) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public ServerSocket createServerSocket(int port, int backlog) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public ServerSocket createServerSocket(
+      int port, int backlog, InetAddress inetAddress) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  final class UnixDomainServerSocket extends ServerSocket {
+    private UnixServerSocketChannel serverSocketChannel;
+    private InetSocketAddress endpoint;
+
+    UnixDomainServerSocket() throws IOException {
+    }
+
+    @Override public void bind(SocketAddress endpoint, int backlog) throws IOException {
+      this.endpoint = (InetSocketAddress) endpoint;
+
+      UnixSocketAddress address = new UnixSocketAddress(path);
+      serverSocketChannel = UnixServerSocketChannel.open();
+      serverSocketChannel.configureBlocking(true);
+      serverSocketChannel.socket().bind(address);
+    }
+
+    @Override public int getLocalPort() {
+      return 1; // A white lie. There is no local port.
+    }
+
+    @Override public SocketAddress getLocalSocketAddress() {
+      return endpoint;
+    }
+
+    @Override public Socket accept() throws IOException {
+      UnixSocketChannel socketChannel = serverSocketChannel.accept();
+
+      return new UnixSocket(socketChannel) {
+        @Override public InetAddress getInetAddress() {
+          return endpoint.getAddress(); // TODO(jwilson): fake the remote address?
+        }
+      };
+    }
+
+    @Override public void close() throws IOException {
+      serverSocketChannel.close();
+    }
+  }
+}
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java
new file mode 100644
index 0000000000..8b16e398f7
--- /dev/null
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.unixdomainsockets;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.net.SocketAddress;
+import javax.net.SocketFactory;
+import jnr.unixsocket.UnixSocket;
+import jnr.unixsocket.UnixSocketAddress;
+import jnr.unixsocket.UnixSocketChannel;
+
+/** Impersonate TCP-style SocketFactory over UNIX domain sockets. */
+public final class UnixDomainSocketFactory extends SocketFactory {
+  private final File path;
+
+  public UnixDomainSocketFactory(File path) {
+    this.path = path;
+  }
+
+  private Socket createUnixDomainSocket() throws IOException {
+    UnixSocketChannel channel = UnixSocketChannel.open();
+
+    return new UnixSocket(channel) {
+      private InetSocketAddress inetSocketAddress;
+
+      @Override public void connect(SocketAddress endpoint) throws IOException {
+        connect(endpoint, Integer.valueOf(0));
+      }
+
+      @Override public void connect(SocketAddress endpoint, int timeout) throws IOException {
+        connect(endpoint, Integer.valueOf(timeout));
+      }
+
+      @Override public void connect(SocketAddress endpoint, Integer timeout) throws IOException {
+        this.inetSocketAddress = (InetSocketAddress) endpoint;
+        super.connect(new UnixSocketAddress(path), timeout);
+      }
+
+      @Override public InetAddress getInetAddress() {
+        return inetSocketAddress.getAddress(); // TODO(jwilson): fake the remote address?
+      }
+    };
+  }
+
+  @Override public Socket createSocket() throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public Socket createSocket(String host, int port) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public Socket createSocket(
+      String host, int port, InetAddress localHost, int localPort) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public Socket createSocket(InetAddress host, int port) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public Socket createSocket(
+      InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
+    return createUnixDomainSocket();
+  }
+}
diff --git a/website/index.html b/website/index.html
index 110901dab7..0725793100 100644
--- a/website/index.html
+++ b/website/index.html
@@ -8,7 +8,7 @@
     <link href="static/bootstrap-combined.min.css" rel="stylesheet">
     <link href="static/app.css" rel="stylesheet">
     <link href="static/app-theme.css" rel="stylesheet">
-    <link href="http://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
+    <link href="https://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
     <!--[if lt IE 9]><script src="static/html5shiv.min.js"></script><![endif]-->
   </head>
   <body data-target=".content-nav">
@@ -22,8 +22,8 @@ <h1>OkHttp</h1>
             <menu>
               <ul>
                 <li><a href="#download" class="menu download">Download <span class="version-tag">Latest</span></a></li>
-                <li><a href="http://github.com/square/okhttp" data-title="View GitHub Project" class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
-                <li><a href="http://square.github.io/" data-title="Square Open Source Portal" class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
+                <li><a href="https://github.com/square/okhttp" data-title="View GitHub Project" class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
+                <li><a href="https://square.github.io/" data-title="Square Open Source Portal" class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
               </ul>
             </menu>
           </div>
@@ -88,7 +88,7 @@ <h4>Post to a Server</h4>
 
 <pre class="prettyprint">
 public static final MediaType JSON
-    = MediaType.parse("application/json; charset=utf-8");
+    = MediaType.get("application/json; charset=utf-8");
 
 OkHttpClient client = new OkHttpClient();
 
@@ -106,10 +106,10 @@ <h4>Post to a Server</h4>
 
             <h3 id="download">Download</h3>
             <p><a href="https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
-            <p>You'll also need <a href="http://github.com/square/okio">Okio</a>, which OkHttp
+            <p>You'll also need <a href="https://github.com/square/okio">Okio</a>, which OkHttp
                 uses for fast I/O and resizable buffers. Download the
                 <a href="https://search.maven.org/remote_content?g=com.squareup.okio&a=okio&v=LATEST">latest JAR</a>.
-            <p>The source code to OkHttp, its samples, and this website is <a href="http://github.com/square/okhttp">available on GitHub</a>.</p>
+            <p>The source code to OkHttp, its samples, and this website is <a href="https://github.com/square/okhttp">available on GitHub</a>.</p>
 
             <h4>Maven</h4>
             <pre class="prettyprint">&lt;dependency>
@@ -119,12 +119,22 @@ <h4>Maven</h4>
 &lt;/dependency></pre>
 
             <h4>Gradle</h4>
-            <pre class="prettyprint">compile 'com.squareup.okhttp3:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
+            <pre class="prettyprint">implementation 'com.squareup.okhttp3:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
 
             <h3 id="contributing">Contributing</h3>
             <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
             <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
-            <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
+            
+            <p>Some general advice</p>
+            <ul>
+                <li>Don’t change public API lightly, avoid if possible, and include your reasoning in the PR if essential. It causes pain for developers who use OkHttp and sometimes runtime errors.</li>
+                <li>Favour a working external library if appropriate. There are many examples of OkHttp libraries that can sit on top or hook in via existing APIs.</li>
+                <li>Get working code on a personal branch with tests before you submit a PR.</li>
+                <li>OkHttp is a small and light dependency. Don't introduce new dependencies or major new functionality.</li>
+                <li>OkHttp targets the intersection of RFC correct and widely implemented. Incorrect implementations that are very widely implemented e.g. a bug in Apache, Nginx, Google, Firefox should also be handled.</li>
+            </ul>
+            
+            <p>Before your code can be accepted into the project you must also sign the <a href="https://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
 
             <h3 id="license">License</h3>
             <pre>Copyright 2016 Square, Inc.
@@ -153,7 +163,7 @@ <h3 id="license">License</h3>
               <ul class="nav nav-pills nav-stacked secondary">
                 <li><a href="https://github.com/square/okhttp/wiki">Wiki</a></li>
                 <li><a href="3.x/okhttp/">Javadoc</a></li>
-                <li><a href="http://stackoverflow.com/questions/tagged/okhttp?sort=active">StackOverflow</a></li>
+                <li><a href="https://stackoverflow.com/questions/tagged/okhttp?sort=active">StackOverflow</a></li>
               </ul>
             </div>
           </div>
@@ -165,7 +175,7 @@ <h3 id="license">License</h3>
         </div>
       </div>
     </section>
-    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
+    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
     <script src="static/bootstrap.min.js"></script>
     <script src="static/jquery.smooth-scroll.min.js"></script>
     <script src="static/jquery-maven-artifact.min.js"></script>
diff --git a/website/static/jquery-maven-artifact.min.js b/website/static/jquery-maven-artifact.min.js
index 4b78fe23ac..6e134dd857 100644
--- a/website/static/jquery-maven-artifact.min.js
+++ b/website/static/jquery-maven-artifact.min.js
@@ -4,4 +4,4 @@
  * Version: 2.0.0
  * Author: Jake Wharton
  * License: Apache 2.0
- */(function(e){function n(e,t){var n=e.groupId.replace(/\./g,"/"),r="http://repo1.maven.org/maven2/"+n+"/"+e.artifactId+"/"+t+"/"+e.artifactId+"-"+t;return typeof e.classifier!="undefined"&&(r+="-"+e.classifier),r+="."+e.packaging,r}function r(e){var t={groupId:"g",artifactId:"a",packaging:"p",classifier:"l"},n="";for(var r in t)t.hasOwnProperty(r)&&e.hasOwnProperty(r)&&(n!==""&&(n+="+AND+"),n+=t[r]+':"'+e[r]+'"');return n}var t={packaging:"jar"};e.fn.artifactVersion=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="http://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;var r=t[0].latestVersion||t[0].v,o=n(i,r);s(r,o)})},e.fn.artifactVersions=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="http://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&rows=10&core=gav&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;t.sort(function(e,t){return e.v>t.v?-1:1});var r=[];for(var o=0;o<t.length;o++){var u=t[o].v;r.push({name:u,url:n(i,u)})}s(r)})}})(jQuery);
\ No newline at end of file
+ */(function(e){function n(e,t){var n=e.groupId.replace(/\./g,"/"),r="https://repo1.maven.org/maven2/"+n+"/"+e.artifactId+"/"+t+"/"+e.artifactId+"-"+t;return typeof e.classifier!="undefined"&&(r+="-"+e.classifier),r+="."+e.packaging,r}function r(e){var t={groupId:"g",artifactId:"a",packaging:"p",classifier:"l"},n="";for(var r in t)t.hasOwnProperty(r)&&e.hasOwnProperty(r)&&(n!==""&&(n+="+AND+"),n+=t[r]+':"'+e[r]+'"');return n}var t={packaging:"jar"};e.fn.artifactVersion=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="https://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;var r=t[0].latestVersion||t[0].v,o=n(i,r);s(r,o)})},e.fn.artifactVersions=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="https://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&rows=10&core=gav&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;t.sort(function(e,t){return e.v>t.v?-1:1});var r=[];for(var o=0;o<t.length;o++){var u=t[o].v;r.push({name:u,url:n(i,u)})}s(r)})}})(jQuery);
