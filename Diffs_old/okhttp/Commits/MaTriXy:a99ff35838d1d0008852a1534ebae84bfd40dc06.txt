diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
new file mode 100755
index 0000000000..4e141cad64
--- /dev/null
+++ b/.buildscript/deploy_snapshot.sh
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
+#
+# Adapted from https://coderwall.com/p/9b_lfq and
+# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
+
+SLUG="square/okhttp"
+JDK="oraclejdk8"
+BRANCH="master"
+
+set -e
+
+if [ "$TRAVIS_REPO_SLUG" != "$SLUG" ]; then
+  echo "Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'."
+elif [ "$TRAVIS_JDK_VERSION" != "$JDK" ]; then
+  echo "Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'."
+elif [ "$TRAVIS_PULL_REQUEST" != "false" ]; then
+  echo "Skipping snapshot deployment: was pull request."
+elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
+  echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
+else
+  echo "Deploying snapshot..."
+  mvn clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -Dmaven.test.skip=true
+  echo "Snapshot deployed!"
+fi
diff --git a/.buildscript/settings.xml b/.buildscript/settings.xml
new file mode 100644
index 0000000000..91f444b228
--- /dev/null
+++ b/.buildscript/settings.xml
@@ -0,0 +1,9 @@
+<settings>
+  <servers>
+    <server>
+      <id>sonatype-nexus-snapshots</id>
+      <username>${env.CI_DEPLOY_USERNAME}</username>
+      <password>${env.CI_DEPLOY_PASSWORD}</password>
+    </server>
+  </servers>
+</settings>
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000000..d29f0b1218
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "okhttp-hpacktests/src/test/resources/hpack-test-case"]
+	path = okhttp-hpacktests/src/test/resources/hpack-test-case
+	url = git://github.com/http2jp/hpack-test-case.git
diff --git a/.travis.yml b/.travis.yml
index 7769867d9d..ed135a7902 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,7 +1,26 @@
 language: java
 
+jdk:
+  - oraclejdk7
+  - oraclejdk8
+
+after_success:
+  - .buildscript/deploy_snapshot.sh
+
+env:
+  global:
+    - secure: "S0BTJVrF4fUCwhTdmoQY6LYr5r1wgXZ/p8lc5bIgUUsc1Ckalwt7s/GDwPuLJ4702sI5t56Eye2iEIMUjeFJKqebZRsX1C5oYsYFxGi3BGlepstYpmj0gLXuSWqCLniS9zmHXCxLhLkC6KxPVjhDlbq76XQx0o3K1J8oEIj/PCE="
+    - secure: "awV7yLXURjlPbTOladsNDZk74KYCNXoiZpAP0gQFfK4Sc0fc7+kg8z/yhdWXeTxjsIZ6m0dVDHTqnH8ytnydwXpBam8JdQJ+EAWA6R3Svq1BR1bzl/PcZUoz+Xn8lMXdU3yA1p4qtQlUhMxwsE3MOVe24HSDJPAu4XeWFj1j3qo="
+
+branches:
+  except:
+    - gh-pages
+
 notifications:
   email: false
 
-jdk:
-  - oraclejdk7
+sudo: false
+
+cache:
+  directories:
+    - $HOME/.m2
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 57820a45c4..71a504176d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,15 +1,422 @@
 Change Log
 ==========
 
-Version 1.2.1 *(2013-08-23)*
-----------------------------
+## VERSION 2.2.0
+
+_2014-12-30_
+
+ *  **`RequestBody.contentLength()` now throws `IOException`.**
+    This is a source-incompatible change. If you have code that calls
+    `RequestBody.contentLength()`, your compile will break with this
+    update. The change is binary-compatible, however: code compiled
+    for OkHttp 2.0 and 2.1 will continue work with this update.
+
+ *  **`COMPATIBLE_TLS` no longer supports SSLv3.** In response to the
+    [POODLE](http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html)
+    vulnerability, OkHttp no longer offers SSLv3 when negotiation an
+    HTTPS connection. If you continue to need to connect to webservers
+    running SSLv3, you must manually configure your own `ConnectionSpec`.
+
+ *  **OkHttp now offers interceptors.** Interceptors are a powerful mechanism
+    that can monitor, rewrite, and retry calls. The [project
+    wiki](https://github.com/square/okhttp/wiki/Interceptors) has a full
+    introduction to this new API.
+
+ *  New: APIs to iterate and selectively clear the response cache.
+ *  New: Support for SOCKS proxies.
+ *  New: Support for `TLS_FALLBACK_SCSV`.
+ *  New: Update HTTP/2 support to to `h2-16` and `hpack-10`.
+ *  New: APIs to prevent retrying non-idempotent requests.
+ *  Fix: Drop NPN support. Going forward we support ALPN only.
+ *  Fix: The hostname verifier is now strict. This is consistent with the hostname
+    verifier in modern browsers.
+ *  Fix: Improve `CONNECT` handling for misbehaving HTTP proxies.
+ *  Fix: Don't retry requests that failed due to timeouts.
+ *  Fix: Cache 302s and 308s that include appropriate response headers.
+ *  Fix: Improve pooling of connections that use proxy selectors.
+ *  Fix: Don't leak connections when using ALPN on the desktop.
+ *  Fix: Update Jetty ALPN to `7.1.2.v20141202` (Java 7) and `8.1.2.v20141202` (Java 8).
+    This fixes a bug in resumed TLS sessions where the wrong protocol could be
+    selected.
+ *  Fix: Don't crash in SPDY and HTTP/2 when disconnecting before connecting.
+ *  Fix: Avoid a reverse DNS-lookup for a numeric proxy address
+ *  Fix: Resurrect http/2 frame logging.
+ *  Fix: Limit to 20 authorization attempts.
+
+## VERSION 2.1.0
+
+_2014-11-11_
+
+ *  New: Typesafe APIs for interacting with cipher suites and TLS versions.
+ *  Fix: Don't crash when mixing authorization challenges with upload retries.
+
+
+## VERSION 2.1.0-RC1
+
+_2014-11-04_
+
+ *  **OkHttp now caches private responses**. We've changed from a shared cache
+    to a private cache, and will now store responses that use an `Authorization`
+    header. This means OkHttp's cache shouldn't be used on middleboxes that sit
+    between user agents and the origin server.
+
+ *  **TLS configuration updated.** OkHttp now explicitly enables TLSv1.2,
+    TLSv1.1 and TLSv1.0 where they are supported. It will continue to perform
+    only one fallback, to SSLv3. Applications can now configure this with the
+    `ConnectionSpec` class.
+
+    To disable TLS fallback:
+
+    ```
+    client.setConnectionSpecs(Arrays.asList(
+        ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT));
+    ```
+
+    To disable cleartext connections, permitting `https` URLs only:
+
+    ```
+    client.setConnectionSpecs(Arrays.asList(
+        ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS));
+    ```
+
+ *  **New cipher suites.** Please confirm that your webservers are reachable
+    with this limited set of cipher suites.
+
+    ```
+                                             Android
+    Name                                     Version
+
+    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256  5.0
+    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256    5.0
+    TLS_DHE_RSA_WITH_AES_128_GCM_SHA256      5.0
+    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA     4.0
+    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA     4.0
+    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA       4.0
+    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA       4.0
+    TLS_ECDHE_ECDSA_WITH_RC4_128_SHA         4.0
+    TLS_ECDHE_RSA_WITH_RC4_128_SHA           4.0
+    TLS_DHE_RSA_WITH_AES_128_CBC_SHA         2.3
+    TLS_DHE_DSS_WITH_AES_128_CBC_SHA         2.3
+    TLS_DHE_RSA_WITH_AES_256_CBC_SHA         2.3
+    TLS_RSA_WITH_AES_128_GCM_SHA256          5.0
+    TLS_RSA_WITH_AES_128_CBC_SHA             2.3
+    TLS_RSA_WITH_AES_256_CBC_SHA             2.3
+    SSL_RSA_WITH_3DES_EDE_CBC_SHA            2.3  (Deprecated in 5.0)
+    SSL_RSA_WITH_RC4_128_SHA                 2.3
+    SSL_RSA_WITH_RC4_128_MD5                 2.3  (Deprecated in 5.0)
+    ```
+
+ *  **Okio updated to 1.0.1.**
+
+    ```
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+      <version>1.0.1</version>
+    </dependency>
+    ```
+
+ *  **New APIs to permit easy certificate pinning.** Be warned, certificate
+    pinning is dangerous and could prevent your application from trusting your
+    server!
+
+ *  **Cache improvements.** This release fixes some severe cache problems
+    including a bug where the cache could be corrupted upon certain access
+    patterns. We also fixed a bug where the cache was being cleared due to a
+    corrupted journal. We've added APIs to configure a request's `Cache-Control`
+    headers, and to manually clear the cache.
+
+ *  **Request cancellation fixes.** This update fixes a bug where synchronous
+    requests couldn't be canceled by tag. This update avoids crashing when
+    `onResponse()` throws an `IOException`. That failure will now be logged
+    instead of notifying the thread's uncaught exception handler. We've added a
+    new API, `Call.isCanceled()` to check if a call has been canceled.
+
+ *  New: Update `MultipartBuilder` to support content length.
+ *  New: Make it possible to mock `OkHttpClient` and `Call`.
+ *  New: Update to h2-14 and hpack-9.
+ *  New: OkHttp includes a user-agent by default, like `okhttp/2.1.0-RC1`.
+ *  Fix: Handle response code `308 Permanent Redirect`.
+ *  Fix: Don't skip the callback if a call is canceled.
+ *  Fix: Permit hostnames with underscores.
+ *  Fix: Permit overriding the content-type in `OkApacheClient`.
+ *  Fix: Use the socket factory for direct connections.
+ *  Fix: Honor `OkUrlFactory` APIs that disable redirects.
+ *  Fix: Don't crash on concurrent modification of `SPDY` SPDY settings.
+
+## Version 2.0.0
+
+This release commits to a stable 2.0 API. Read the 2.0.0-RC1 changes for advice
+on upgrading from 1.x to 2.x.
+
+_2014-06-21_
+
+ *  **API Change**: Use `IOException` in `Callback.onFailure()`. This is
+    a source-incompatible change, and is different from OkHttp 2.0.0-RC2 which
+    used `Throwable`.
+ *  Fix: Fixed a caching bug where we weren't storing rewritten request headers
+    like `Accept-Encoding`.
+ *  Fix: Fixed bugs in handling the SPDY window size. This was stalling certain
+    large downloads
+ *  Update the language level to Java 7. (OkHttp requires Android 2.3+ or Java 7+.)
+
+## Version 2.0.0-RC2
+
+_2014-06-11_
+
+This update fixes problems in 2.0.0-RC1. Read the 2.0.0-RC1 changes for
+advice on upgrading from 1.x to 2.x.
+
+ *  Fix: Don't leak connections! There was a regression in 2.0.0-RC1 where
+    connections were neither closed nor pooled.
+ *  Fix: Revert builder-style return types from OkHttpClient's timeout methods
+    for binary compatibility with OkHttp 1.x.
+ *  Fix: Don't skip client stream 1 on SPDY/3.1. This fixes SPDY connectivity to
+    `https://google.com`, which doesn't follow the SPDY/3.1 spec!
+ *  Fix: Always configure NPN headers. This fixes connectivity to
+    `https://facebook.com` when SPDY and HTTP/2 are both disabled. Otherwise an
+    unexpected NPN response is received and OkHttp crashes.
+ *  Fix: Write continuation frames when HPACK data is larger than 16383 bytes.
+ *  Fix: Don't drop uncaught exceptions thrown in async calls.
+ *  Fix: Throw an exception eagerly when a request body is not legal. Previously
+    we ignored the problem at request-building time, only to crash later with a
+    `NullPointerException`.
+ *  Fix: Include a backwards-compatible `OkHttp-Response-Source` header with
+    `OkUrlFactory `responses.
+ *  Fix: Don't include a default User-Agent header in requests made with the Call
+    API. Requests made with OkUrlFactory will continue to have a default user
+    agent.
+ *  New: Guava-like API to create headers:
+
+    ```
+    Headers headers = Headers.of(name1, value1, name2, value2, ...).
+    ```
+
+ *  New: Make the content-type header optional for request bodies.
+ *  New: `Response.isSuccessful()` is a convenient API to check response codes.
+ *  New: The response body can now be read outside of the callback. Response
+    bodies must always be closed, otherwise they will leak connections!
+ *  New: APIs to create multipart request bodies (`MultipartBuilder`) and form
+    encoding bodies (`FormEncodingBuilder`).
+
+## Version 2.0.0-RC1
+
+_2014-05-23_
+
+OkHttp 2 is designed around a new API that is true to HTTP, with classes for
+requests, responses, headers, and calls. It uses modern Java patterns like
+immutability and chained builders. The API now offers asynchronous callbacks
+in addition to synchronous blocking calls.
+
+#### API Changes
+
+ *  **New Request and Response types,** each with their own builder. There's also
+    a `RequestBody` class to write the request body to the network and a
+    `ResponseBody` to read the response body from the network. The standalone
+    `Headers` class offers full access to the HTTP headers.
+
+ *  **Okio dependency added.** OkHttp now depends on
+    [Okio](https://github.com/square/okio), an I/O library that makes it easier
+    to access, store and process data. Using this library internally makes OkHttp
+    faster while consuming less memory. You can write a `RequestBody` as an Okio
+    `BufferedSink` and a `ResponseBody` as an Okio `BufferedSource`. Standard
+    `InputStream` and `OutputStream` access is also available.
+
+ *  **New Call and Callback types** execute requests and receive their
+    responses. Both types of calls can be canceled via the `Call` or the
+    `OkHttpClient`.
+
+ *  **URLConnection support has moved to the okhttp-urlconnection module.**
+    If you're upgrading from 1.x, this change will impact you. You will need to
+    add the `okhttp-urlconnection` module to your project and use the
+    `OkUrlFactory` to create new instances of `HttpURLConnection`:
+
+    ```
+    // OkHttp 1.x:
+    HttpURLConnection connection = client.open(url);
+
+    // OkHttp 2.x:
+    HttpURLConnection connection = new OkUrlFactory(client).open(url);
+    ```
+
+ *  **Custom caches are no longer supported.** In OkHttp 1.x it was possible to
+    define your own response cache with the `java.net.ResponseCache` and OkHttp's
+    `OkResponseCache` interfaces. Both of these APIs have been dropped. In
+    OkHttp 2 the built-in disk cache is the only supported response cache.
+
+ *  **HttpResponseCache has been renamed to Cache.** Install it with
+    `OkHttpClient.setCache(...)` instead of `OkHttpClient.setResponseCache(...)`.
+
+ *  **OkAuthenticator has been replaced with Authenticator.** This new
+    authenticator has access to the full incoming response and can respond with
+    whichever followup request is appropriate. The `Challenge` class is now a
+    top-level class and `Credential` is replaced with a utility class called
+    `Credentials`.
+
+ *  **OkHttpClient.getFollowProtocolRedirects() renamed to
+    getFollowSslRedirects()**. We reserve the word _protocol_ for the HTTP
+    version being used (HTTP/1.1, HTTP/2). The old name of this method was
+    misleading; it was always used to configure redirects between `https://` and
+    `http://` schemes.
+
+ *  **RouteDatabase is no longer public API.** OkHttp continues to track which
+    routes have failed but this is no exposed in the API.
+
+ *  **ResponseSource is gone.** This enum exposed whether a response came from
+    the cache, network, or both. OkHttp 2 offers more detail with raw access to
+    the cache and network responses in the new `Response` class.
+
+ *  **TunnelRequest is gone.** It specified how to connect to an HTTP proxy.
+    OkHttp 2 uses the new `Request` class for this.
+
+ *  **Dispatcher** is a new class to manages the queue of asynchronous calls. It
+    implements limits on total in-flight calls and in-flight calls per host.
+
+#### Implementation changes
+
+ * Support Android `TrafficStats` socket tagging.
+ * Drop authentication headers on redirect.
+ * Added support for compressed data frames.
+ * Process push promise callbacks in order.
+ * Update to http/2 draft 12.
+ * Update to HPACK draft 07.
+ * Add ALPN support. Maven will use ALPN on OpenJDK 8.
+ * Update NPN dependency to target `jdk7u60-b13` and `Oracle jdk7u55-b13`.
+ * Ensure SPDY variants support zero-length DELETE and POST.
+ * Prevent leaking a cache item's InputStreams when metadata read fails.
+ * Use a string to identify TLS versions in routes.
+ * Add frame logger for HTTP/2.
+ * Replacing `httpMinorVersion` with `Protocol`. Expose HTTP/1.0 as a potential protocol.
+ * Use `Protocol` to describe framing.
+ * Implement write timeouts for HTTP/1.1 streams.
+ * Avoid use of SPDY stream ID 1, as that's typically used for UPGRADE.
+ * Support OAuth in `Authenticator`.
+ * Permit a dangling semicolon in media type parsing.
+
+## Version 1.6.0
+
+_2014-05-23_
+
+ * Offer bridges to make it easier to migrate from OkHttp 1.x to OkHttp 2.0.
+   This adds `OkUrlFactory`, `Cache`, and `@Deprecated` annotations for APIs
+   dropped in 2.0.
+
+## Version 1.5.4
+
+_2014-04-14_
+
+ * Drop ALPN support in Android. There's a concurrency bug in all
+   currently-shipping versions.
+ * Support asynchronous disconnects by breaking the socket only. This should
+   prevent flakiness from multiple threads concurrently accessing a stream.
+
+## Version 1.5.3
+
+_2014-03-29_
+
+ * Fix bug where the Content-Length header was not always dropped when
+   following a redirect from a POST to a GET.
+ * Implement basic support for `Thread.interrupt()`. OkHttp now checks
+   for an interruption before doing a blocking call. If it is interrupted,
+   it throws an `InterruptedIOException`.
+
+## Version 1.5.2
+
+_2014-03-17_
+
+ * Fix bug where deleting a file that was absent from the `HttpResponseCache`
+   caused an IOException.
+ * Fix bug in HTTP/2 where our HPACK decoder wasn't emitting entries in
+   certain eviction scenarios, leading to dropped response headers.
+
+## Version 1.5.1
+
+_2014-03-11_
+
+ * Fix 1.5.0 regression where connections should not have been recycled.
+ * Fix 1.5.0 regression where transparent Gzip was broken by attempting to
+   recover from another I/O failure.
+ * Fix problems where spdy/3.1 headers may not have been compressed properly.
+ * Fix problems with spdy/3.1 and http/2 where the wrong window size was being
+   used.
+ * Fix 1.5.0 regression where conditional cache responses could corrupt the
+   connection pool.
+
+
+## Version 1.5.0
+
+_2014-03-07_
+
+
+##### OkHttp no longer uses the default SSL context.
+
+Applications that want to use the global SSL context with OkHttp should configure their
+OkHttpClient instances with the following:
+
+```java
+okHttpClient.setSslSocketFactory(HttpsURLConnection.getDefaultSSLSocketFactory());
+```
+
+A simpler solution is to avoid the shared default SSL socket factory. Instead, if you
+need to customize SSL, do so for your specific OkHttpClient instance only.
+
+##### Synthetic headers have changed
+
+Previously OkHttp added a synthetic response header, `OkHttp-Selected-Transport`. It
+has been replaced with a new synthetic header, `OkHttp-Selected-Protocol`.
+
+##### Changes
+
+ * New: Support for `HTTP-draft-09/2.0`.
+ * New: Support for `spdy/3.1`. Dropped support for `spdy/3`.
+ * New: Use ALPN on Android platforms that support it (4.4+)
+ * New: CacheControl model and parser.
+ * New: Protocol selection in MockWebServer.
+ * Fix: Route selection shouldn't use TLS modes that we know will fail.
+ * Fix: Cache SPDY responses even if the response body is closed prematurely.
+ * Fix: Use strict timeouts when aborting a download.
+ * Fix: Support Shoutcast HTTP responses like `ICY 200 OK`.
+ * Fix: Don't unzip if there isn't a response body.
+ * Fix: Don't leak gzip streams on redirects.
+ * Fix: Don't do DNS lookups on invalid hosts.
+ * Fix: Exhaust the underlying stream when reading gzip streams.
+ * Fix: Support the `PATCH` method.
+ * Fix: Support request bodies on `DELETE` method.
+ * Fix: Drop the `okhttp-protocols` module.
+ * Internal: Replaced internal byte array buffers with pooled buffers ("OkBuffer").
+
+
+## Version 1.3.0
+
+_2014-01-11_
+
+ * New: Support for "PATCH" HTTP method in client and MockWebServer.
+ * Fix: Drop `Content-Length` header when redirected from POST to GET.
+ * Fix: Correctly read cached header entries with malformed header names.
+ * Fix: Do not directly support any authentication schemes other than "Basic".
+ * Fix: Respect read timeouts on recycled connections.
+ * Fix: Transmit multiple cookie values as a single header with delimiter.
+ * Fix: Ensure `null` is never returned from a connection's `getHeaderFields()`.
+ * Fix: Persist proper `Content-Encoding` header to cache for GZip responses.
+ * Fix: Eliminate rare race condition in SPDY streams that would prevent connection reuse.
+ * Fix: Change HTTP date formats to UTC to conform to RFC2616 section 3.3.
+ * Fix: Support SPDY header blocks with trailing bytes.
+ * Fix: Allow `;` as separator for `Cache-Control` header.
+ * Fix: Correct bug where HTTPS POST requests were always automatically buffered.
+ * Fix: Honor read timeout when parsing SPDY headers.
+
+
+## Version 1.2.1
+
+_2013-08-23_
 
  * Resolve issue with 'jar-with-dependencies' artifact creation.
  * Fix: Support empty SPDY header values.
 
 
-Version 1.2.0 *(2013-08-11)*
-----------------------------
+## Version 1.2.0
+
+_2013-08-11_
 
  *  New APIs on OkHttpClient to set default timeouts for connect and read.
  *  Fix bug when caching SPDY responses.
@@ -34,15 +441,17 @@ Version 1.2.0 *(2013-08-11)*
  *  Bring MockWebServer into OkHttp and teach it SPDY.
 
 
-Version 1.1.1 *(2013-06-23)*
-----------------------------
+## Version 1.1.1
+
+_2013-06-23_
 
  * Fix: ClassCastException when caching responses that were redirected from
    HTTP to HTTPS.
 
 
-Version 1.1.0 *(2013-06-15)*
-----------------------------
+## Version 1.1.0
+
+_2013-06-15_
 
  * Fix: Connection reuse was broken for most HTTPS connections due to a bug in
    the way the hostname verifier was selected.
@@ -54,22 +463,26 @@ Version 1.1.0 *(2013-06-15)*
    Use `X-Android-Transports` to write the preferred transports and
    `X-Android-Selected-Transport` to read the negotiated transport.
 
-Version 1.0.2 *(2013-05-11)*
-----------------------------
+
+## Version 1.0.2
+
+_2013-05-11_
 
  * Fix: Remove use of Java 6-only APIs.
  * Fix: Properly handle exceptions from `NetworkInterface` when querying MTU.
  * Fix: Ensure MTU has a reasonable default and upper-bound.
 
 
-Version 1.0.1 *(2013-05-06)*
-----------------------------
+## Version 1.0.1
+
+_2013-05-06_
 
  * Correct casing of SSL in method names (`getSslSocketFactory`/`setSslSocketFactory`).
 
 
-Version 1.0.0 *(2013-05-06)*
-----------------------------
+## Version 1.0.0
+
+_2013-05-06_
 
 Initial release.
 
diff --git a/README.md b/README.md
index e206f237ec..4cb0f5613b 100644
--- a/README.md
+++ b/README.md
@@ -1,57 +1,52 @@
 OkHttp
 ======
 
-An HTTP & SPDY client for Android and Java applications.
-
-For more information please see [the website][1].
-
-
+An HTTP & SPDY client for Android and Java applications. For more information see [the website][1] and [the wiki][2].
 
 Download
 --------
 
-Download [the latest JAR][2] or grab via Maven:
-
+Download [the latest JAR][3] or grab via Maven:
 ```xml
 <dependency>
-    <groupId>com.squareup.okhttp</groupId>
-    <artifactId>okhttp</artifactId>
-    <version>(insert latest version)</version>
+  <groupId>com.squareup.okhttp</groupId>
+  <artifactId>okhttp</artifactId>
+  <version>2.1.0</version>
 </dependency>
 ```
+or Gradle:
+```groovy
+compile 'com.squareup.okhttp:okhttp:2.1.0'
+```
 
+Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
 
-Building
---------
-
-### On the Desktop
-
-Run OkHttp tests on the desktop with Maven. Running SPDY tests on the desktop uses
-[Jetty-NPN][3] which requires OpenJDK 7+.
 
-```
-mvn clean test
-```
+MockWebServer
+-------------
 
-### On a Device
+A library for testing HTTP, HTTPS, HTTP/2.0, and SPDY clients.
 
-OkHttp's test suite creates an in-process HTTPS server. Prior to Android 2.3, SSL server sockets
-were broken, and so HTTPS tests will time out when run on such devices.
+MockWebServer coupling with OkHttp is essential for proper testing of SPDY and HTTP/2.0 so that code can be shared.
 
-Test on a USB-attached Android using [Vogar][4]. Unfortunately `dx` requires that you build with
-Java 6, otherwise the test class will be silently omitted from the `.dex` file.
+### Download
 
+Download [the latest JAR][4] or grab via Maven:
+```xml
+<dependency>
+  <groupId>com.squareup.okhttp</groupId>
+  <artifactId>mockwebserver</artifactId>
+  <version>2.1.0</version>
+  <scope>test</scope>
+</dependency>
 ```
-mvn clean
-mvn package -DskipTests
-vogar \
-    --classpath ~/.m2/repository/org/bouncycastle/bcprov-jdk15on/1.47/bcprov-jdk15on-1.47.jar \
-    --classpath ~/.m2/repository/com/google/mockwebserver/mockwebserver/20130122/mockwebserver-20130122.jar \
-    --classpath target/okhttp-0.9-SNAPSHOT.jar \
-    ./src/test/java
+or Gradle:
+```groovy
+testCompile 'com.squareup.okhttp:mockwebserver:2.1.0'
 ```
 
 
+
 License
 -------
 
@@ -68,9 +63,8 @@ License
     limitations under the License.
 
 
-
-
  [1]: http://square.github.io/okhttp
- [2]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=okhttp&v=LATEST
- [3]: http://wiki.eclipse.org/Jetty/Feature/NPN
- [4]: https://code.google.com/p/vogar/
+ [2]: https://github.com/square/okhttp/wiki
+ [3]: https://search.maven.org/remote_content?g=com.squareup.okhttp&a=okhttp&v=LATEST
+ [4]: https://search.maven.org/remote_content?g=com.squareup.okhttp&a=mockwebserver&v=LATEST
+ [snap]: https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/benchmarks/README.md b/benchmarks/README.md
new file mode 100644
index 0000000000..59f571fc55
--- /dev/null
+++ b/benchmarks/README.md
@@ -0,0 +1,8 @@
+OkHttp Benchmarks
+=======================================
+
+This module allows you to test the performance of HTTP clients.
+
+### Running
+  1. If you made modifications to `com.squareup.okhttp.benchmarks.Benchmark` run `mvn compile`.
+  2. Run `mvn exec:exec` to launch a new JVM, which will execute the benchmark.
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
new file mode 100644
index 0000000000..4fde956949
--- /dev/null
+++ b/benchmarks/pom.xml
@@ -0,0 +1,142 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.3.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>benchmarks</artifactId>
+  <name>Benchmarks</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.google.caliper</groupId>
+      <artifactId>caliper</artifactId>
+      <version>1.0-beta-1</version>
+    </dependency>
+    <!-- caliper needs to be updated to be compatible with guava 16 -->
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <version>14.0.1</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-urlconnection</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.bouncycastle</groupId>
+      <artifactId>bcprov-jdk15on</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.httpcomponents</groupId>
+      <artifactId>httpclient</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-transport</artifactId>
+      <version>4.0.15.Final</version>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-handler</artifactId>
+      <version>4.0.15.Final</version>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-codec-http</artifactId>
+      <version>4.0.15.Final</version>
+    </dependency>
+    <!-- Netty needs this if gzip is enabled. -->
+    <dependency>
+      <groupId>com.jcraft</groupId>
+      <artifactId>jzlib</artifactId>
+      <version>1.1.2</version>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>exec-maven-plugin</artifactId>
+        <executions>
+          <execution>
+            <goals>
+              <goal>java</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <executable>java</executable>
+          <arguments>
+            <argument>-Xms512m</argument>
+            <argument>-Xmx512m</argument>
+            <commandlineArgs>-Xbootclasspath/p:${bootclasspath}</commandlineArgs>
+            <argument>-classpath</argument>
+            <classpath />
+            <argument>com.squareup.okhttp.benchmarks.Benchmark</argument>
+          </arguments>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+  <profiles>
+    <profile>
+      <id>alpn-when-jdk7</id>
+      <activation>
+        <jdk>1.7</jdk>
+      </activation>
+      <dependencies>
+        <dependency>
+          <groupId>org.mortbay.jetty.alpn</groupId>
+          <artifactId>alpn-boot</artifactId>
+          <version>${alpn.jdk7.version}</version>
+          <scope>provided</scope>
+        </dependency>
+      </dependencies>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8</id>
+      <activation>
+        <jdk>1.8</jdk>
+      </activation>
+      <dependencies>
+        <dependency>
+          <groupId>org.mortbay.jetty.alpn</groupId>
+          <artifactId>alpn-boot</artifactId>
+          <version>${alpn.jdk8.version}</version>
+          <scope>provided</scope>
+        </dependency>
+      </dependencies>
+      <build>
+        <plugins>
+          <plugin>
+            <!-- Fails on caliper's ASM on OpenJDK 8. -->
+            <groupId>org.codehaus.mojo</groupId>
+            <artifactId>animal-sniffer-maven-plugin</artifactId>
+            <executions>
+              <execution>
+                <phase>none</phase>
+              </execution>
+            </executions>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+  </profiles>
+</project>
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java
new file mode 100644
index 0000000000..cb8e719111
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.internal.SslContextBuilder;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.concurrent.TimeUnit;
+import java.util.zip.GZIPInputStream;
+import javax.net.ssl.SSLContext;
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.conn.ssl.SSLSocketFactory;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.conn.PoolingClientConnectionManager;
+
+/** Benchmark Apache HTTP client. */
+class ApacheHttpClient extends SynchronousHttpClient {
+  private static final boolean VERBOSE = false;
+
+  private HttpClient client;
+
+  @Override public void prepare(Benchmark benchmark) {
+    super.prepare(benchmark);
+    ClientConnectionManager connectionManager = new PoolingClientConnectionManager();
+    if (benchmark.tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      connectionManager.getSchemeRegistry().register(
+          new Scheme("https", 443, new SSLSocketFactory(sslContext)));
+    }
+    client = new DefaultHttpClient(connectionManager);
+  }
+
+  @Override public Runnable request(URL url) {
+    return new ApacheHttpClientRequest(url);
+  }
+
+  class ApacheHttpClientRequest implements Runnable {
+    private final URL url;
+
+    public ApacheHttpClientRequest(URL url) {
+      this.url = url;
+    }
+
+    public void run() {
+      long start = System.nanoTime();
+      try {
+        HttpResponse response = client.execute(new HttpGet(url.toString()));
+        InputStream in = response.getEntity().getContent();
+        Header contentEncoding = response.getFirstHeader("Content-Encoding");
+        if (contentEncoding != null && contentEncoding.getValue().equals("gzip")) {
+          in = new GZIPInputStream(in);
+        }
+
+        long total = readAllAndClose(in);
+        long finish = System.nanoTime();
+
+        if (VERBOSE) {
+          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+        }
+      } catch (IOException e) {
+        System.out.println("Failed: " + e);
+      }
+    }
+  }
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
new file mode 100644
index 0000000000..0ae5127ac5
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.google.caliper.Param;
+import com.google.caliper.model.ArbitraryMeasurement;
+import com.google.caliper.runner.CaliperMain;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.Dispatcher;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import java.util.zip.GZIPOutputStream;
+import javax.net.ssl.SSLContext;
+import okio.Buffer;
+
+/**
+ * This benchmark is fake, but may be useful for certain relative comparisons.
+ * It uses a local connection to a MockWebServer to measure how many identical
+ * requests per second can be carried over a fixed number of threads.
+ */
+public class Benchmark extends com.google.caliper.Benchmark {
+  private static final int NUM_REPORTS = 10;
+  private static final boolean VERBOSE = false;
+
+  private final Random random = new Random(0);
+
+  /** Which client to run.*/
+  @Param
+  Client client;
+
+  /** How many concurrent requests to execute. */
+  @Param({ "1", "10" })
+  int concurrencyLevel;
+
+  /** How many requests to enqueue to await threads to execute them. */
+  @Param({ "10" })
+  int targetBacklog;
+
+  /** True to use TLS. */
+  // TODO: compare different ciphers?
+  @Param
+  boolean tls;
+
+  /** True to use gzip content-encoding for the response body. */
+  @Param
+  boolean gzip;
+
+  /** Don't combine chunked with SPDY_3 or HTTP_2; that's not allowed. */
+  @Param
+  boolean chunked;
+
+  /** The size of the HTTP response body, in uncompressed bytes. */
+  @Param({ "128", "1048576" })
+  int bodyByteCount;
+
+  /** How many additional headers were included, beyond the built-in ones. */
+  @Param({ "0", "20" })
+  int headerCount;
+
+  /** Which ALPN protocols are in use. Only useful with TLS. */
+  List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
+
+  public static void main(String[] args) {
+    List<String> allArgs = new ArrayList<>();
+    allArgs.add("--instrument");
+    allArgs.add("arbitrary");
+    allArgs.addAll(Arrays.asList(args));
+
+    CaliperMain.main(Benchmark.class, allArgs.toArray(new String[allArgs.size()]));
+  }
+
+  @ArbitraryMeasurement(description = "requests per second")
+  public double run() throws Exception {
+    if (VERBOSE) System.out.println(toString());
+    HttpClient httpClient = client.create();
+
+    // Prepare the client & server
+    httpClient.prepare(this);
+    MockWebServer server = startServer();
+    URL url = server.getUrl("/");
+
+    int requestCount = 0;
+    long reportStart = System.nanoTime();
+    long reportPeriod = TimeUnit.SECONDS.toNanos(1);
+    int reports = 0;
+    double best = 0.0;
+
+    // Run until we've printed enough reports.
+    while (reports < NUM_REPORTS) {
+      // Print a report if we haven't recently.
+      long now = System.nanoTime();
+      double reportDuration = now - reportStart;
+      if (reportDuration > reportPeriod) {
+        double requestsPerSecond = requestCount / reportDuration * TimeUnit.SECONDS.toNanos(1);
+        if (VERBOSE) {
+          System.out.println(String.format("Requests per second: %.1f", requestsPerSecond));
+        }
+        best = Math.max(best, requestsPerSecond);
+        requestCount = 0;
+        reportStart = now;
+        reports++;
+      }
+
+      // Fill the job queue with work.
+      while (httpClient.acceptingJobs()) {
+        httpClient.enqueue(url);
+        requestCount++;
+      }
+
+      // The job queue is full. Take a break.
+      sleep(1);
+    }
+
+    return best;
+  }
+
+  @Override public String toString() {
+    List<Object> modifiers = new ArrayList<>();
+    if (tls) modifiers.add("tls");
+    if (gzip) modifiers.add("gzip");
+    if (chunked) modifiers.add("chunked");
+    modifiers.addAll(protocols);
+
+    return String.format("%s %s\nbodyByteCount=%s headerCount=%s concurrencyLevel=%s",
+        client, modifiers, bodyByteCount, headerCount, concurrencyLevel);
+  }
+
+  private void sleep(int millis) {
+    try {
+      Thread.sleep(millis);
+    } catch (InterruptedException ignored) {
+    }
+  }
+
+  private MockWebServer startServer() throws IOException {
+    Logger.getLogger(MockWebServer.class.getName()).setLevel(Level.WARNING);
+    MockWebServer server = new MockWebServer();
+
+    if (tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      server.useHttps(sslContext.getSocketFactory(), false);
+      server.setProtocols(protocols);
+    }
+
+    final MockResponse response = newResponse();
+    server.setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        return response;
+      }
+    });
+
+    server.play();
+    return server;
+  }
+
+  private MockResponse newResponse() throws IOException {
+    byte[] body = new byte[bodyByteCount];
+    random.nextBytes(body);
+
+    MockResponse result = new MockResponse();
+
+    if (gzip) {
+      body = gzip(body);
+      result.addHeader("Content-Encoding: gzip");
+    }
+
+    if (chunked) {
+      result.setChunkedBody(new Buffer().write(body), 1024);
+    } else {
+      result.setBody(body);
+    }
+
+    for (int i = 0; i < headerCount; i++) {
+      result.addHeader(randomString(12), randomString(20));
+    }
+
+    return result;
+  }
+
+  private String randomString(int length) {
+    String alphabet = "-abcdefghijklmnopqrstuvwxyz";
+    char[] result = new char[length];
+    for (int i = 0; i < length; i++) {
+      result[i] = alphabet.charAt(random.nextInt(alphabet.length()));
+    }
+    return new String(result);
+  }
+
+  /** Returns a gzipped copy of {@code bytes}. */
+  private byte[] gzip(byte[] bytes) throws IOException {
+    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
+    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
+    gzippedOut.write(bytes);
+    gzippedOut.close();
+    return bytesOut.toByteArray();
+  }
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java
new file mode 100644
index 0000000000..bd777aa359
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+enum Client {
+  OkHttp {
+    @Override HttpClient create() {
+      return new OkHttp();
+    }
+  },
+
+  OkHttpAsync {
+    @Override HttpClient create() {
+      return new OkHttpAsync();
+    }
+  },
+
+  Apache {
+    @Override HttpClient create() {
+      return new ApacheHttpClient();
+    }
+  },
+
+  UrlConnection {
+    @Override HttpClient create() {
+      return new UrlConnection();
+    }
+  },
+
+  Netty {
+    @Override HttpClient create() {
+      return new NettyHttpClient();
+    }
+  };
+
+  abstract HttpClient create();
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java
new file mode 100644
index 0000000000..136c5d86d3
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import java.net.URL;
+
+/** An HTTP client to benchmark. */
+interface HttpClient {
+  void prepare(Benchmark benchmark);
+  void enqueue(URL url) throws Exception;
+  boolean acceptingJobs();
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
new file mode 100644
index 0000000000..5d8cec5291
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
+import io.netty.bootstrap.Bootstrap;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.PooledByteBufAllocator;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.SimpleChannelInboundHandler;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.codec.http.DefaultFullHttpRequest;
+import io.netty.handler.codec.http.HttpClientCodec;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpContentDecompressor;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpMethod;
+import io.netty.handler.codec.http.HttpObject;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpVersion;
+import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.handler.ssl.SslHandler;
+import java.net.URL;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+
+/** Netty isn't an HTTP client, but it's almost one. */
+class NettyHttpClient implements HttpClient {
+  private static final boolean VERBOSE = false;
+
+  // Guarded by this. Real apps need more capable connection management.
+  private final Deque<HttpChannel> freeChannels = new ArrayDeque<>();
+  private final Deque<URL> backlog = new ArrayDeque<>();
+
+  private int totalChannels = 0;
+  private int concurrencyLevel;
+  private int targetBacklog;
+  private Bootstrap bootstrap;
+
+  @Override public void prepare(final Benchmark benchmark) {
+    this.concurrencyLevel = benchmark.concurrencyLevel;
+    this.targetBacklog = benchmark.targetBacklog;
+
+    ChannelInitializer<SocketChannel> channelInitializer = new ChannelInitializer<SocketChannel>() {
+      @Override public void initChannel(SocketChannel channel) throws Exception {
+        ChannelPipeline pipeline = channel.pipeline();
+
+        if (benchmark.tls) {
+          SSLContext sslContext = SslContextBuilder.localhost();
+          SSLEngine engine = sslContext.createSSLEngine();
+          engine.setUseClientMode(true);
+          pipeline.addLast("ssl", new SslHandler(engine));
+        }
+
+        pipeline.addLast("codec", new HttpClientCodec());
+        pipeline.addLast("inflater", new HttpContentDecompressor());
+        pipeline.addLast("handler", new HttpChannel(channel));
+      }
+    };
+
+    bootstrap = new Bootstrap();
+    bootstrap.group(new NioEventLoopGroup(concurrencyLevel))
+        .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
+        .channel(NioSocketChannel.class)
+        .handler(channelInitializer);
+  }
+
+  @Override public void enqueue(URL url) throws Exception {
+    HttpChannel httpChannel = null;
+    synchronized (this) {
+      if (!freeChannels.isEmpty()) {
+        httpChannel = freeChannels.pop();
+      } else if (totalChannels < concurrencyLevel) {
+        totalChannels++; // Create a new channel. (outside of the synchronized block).
+      } else {
+        backlog.add(url); // Enqueue this for later, to be picked up when another request completes.
+        return;
+      }
+    }
+    if (httpChannel == null) {
+      Channel channel = bootstrap.connect(url.getHost(), Util.getEffectivePort(url))
+          .sync().channel();
+      httpChannel = (HttpChannel) channel.pipeline().last();
+    }
+    httpChannel.sendRequest(url);
+  }
+
+  @Override public synchronized boolean acceptingJobs() {
+    return backlog.size() < targetBacklog || hasFreeChannels();
+  }
+
+  private boolean hasFreeChannels() {
+    int activeChannels = totalChannels - freeChannels.size();
+    return activeChannels < concurrencyLevel;
+  }
+
+  private void release(HttpChannel httpChannel) {
+    URL url;
+    synchronized (this) {
+      url = backlog.pop();
+      if (url == null) {
+        // There were no URLs in the backlog. Pool this channel for later.
+        freeChannels.push(httpChannel);
+        return;
+      }
+    }
+
+    // We removed a URL from the backlog. Schedule it right away.
+    httpChannel.sendRequest(url);
+  }
+
+  class HttpChannel extends SimpleChannelInboundHandler<HttpObject> {
+    private final SocketChannel channel;
+    byte[] buffer = new byte[1024];
+    int total;
+    long start;
+
+    public HttpChannel(SocketChannel channel) {
+      this.channel = channel;
+    }
+
+    private void sendRequest(URL url) {
+      start = System.nanoTime();
+      total = 0;
+      HttpRequest request = new DefaultFullHttpRequest(
+          HttpVersion.HTTP_1_1, HttpMethod.GET, url.getPath());
+      request.headers().set(HttpHeaders.Names.HOST, url.getHost());
+      request.headers().set(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
+      channel.writeAndFlush(request);
+    }
+
+    @Override protected void channelRead0(
+        ChannelHandlerContext context, HttpObject message) throws Exception {
+      if (message instanceof HttpResponse) {
+        receive((HttpResponse) message);
+      }
+      if (message instanceof HttpContent) {
+        receive((HttpContent) message);
+        if (message instanceof LastHttpContent) {
+          release(this);
+        }
+      }
+    }
+
+    @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+      super.channelInactive(ctx);
+    }
+
+    void receive(HttpResponse response) {
+      // Don't do anything with headers.
+    }
+
+    void receive(HttpContent content) {
+      // Consume the response body.
+      ByteBuf byteBuf = content.content();
+      for (int toRead; (toRead = byteBuf.readableBytes()) > 0; ) {
+        byteBuf.readBytes(buffer, 0, Math.min(buffer.length, toRead));
+        total += toRead;
+      }
+
+      if (VERBOSE && content instanceof LastHttpContent) {
+        long finish = System.nanoTime();
+        System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+            total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+      }
+    }
+
+    @Override public void exceptionCaught(ChannelHandlerContext context, Throwable cause) {
+      System.out.println("Failed: " + cause);
+    }
+  }
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
new file mode 100644
index 0000000000..3885ed7f53
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+
+class OkHttp extends SynchronousHttpClient {
+  private static final boolean VERBOSE = false;
+
+  private OkHttpClient client;
+
+  @Override public void prepare(Benchmark benchmark) {
+    super.prepare(benchmark);
+    client = new OkHttpClient();
+    client.setProtocols(benchmark.protocols);
+
+    if (benchmark.tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
+        @Override public boolean verify(String s, SSLSession session) {
+          return true;
+        }
+      };
+      client.setSslSocketFactory(socketFactory);
+      client.setHostnameVerifier(hostnameVerifier);
+    }
+  }
+
+  @Override public Runnable request(URL url) {
+    return new OkHttpRequest(url);
+  }
+
+  class OkHttpRequest implements Runnable {
+    private final URL url;
+
+    public OkHttpRequest(URL url) {
+      this.url = url;
+    }
+
+    public void run() {
+      long start = System.nanoTime();
+      try {
+        HttpURLConnection urlConnection = new OkUrlFactory(client).open(url);
+        long total = readAllAndClose(urlConnection.getInputStream());
+        long finish = System.nanoTime();
+
+        if (VERBOSE) {
+          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+        }
+      } catch (IOException e) {
+        System.out.println("Failed: " + e);
+      }
+    }
+  }
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
new file mode 100644
index 0000000000..ab7849017c
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.Callback;
+import com.squareup.okhttp.Dispatcher;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import java.io.IOException;
+import java.net.URL;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+
+class OkHttpAsync implements HttpClient {
+  private static final boolean VERBOSE = false;
+
+  private final AtomicInteger requestsInFlight = new AtomicInteger();
+
+  private OkHttpClient client;
+  private Callback callback;
+  private int concurrencyLevel;
+  private int targetBacklog;
+
+  @Override public void prepare(final Benchmark benchmark) {
+    concurrencyLevel = benchmark.concurrencyLevel;
+    targetBacklog = benchmark.targetBacklog;
+
+    client = new OkHttpClient();
+    client.setProtocols(benchmark.protocols);
+    client.setDispatcher(new Dispatcher(new ThreadPoolExecutor(benchmark.concurrencyLevel,
+        benchmark.concurrencyLevel, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>())));
+
+    if (benchmark.tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
+        @Override public boolean verify(String s, SSLSession session) {
+          return true;
+        }
+      };
+      client.setSslSocketFactory(socketFactory);
+      client.setHostnameVerifier(hostnameVerifier);
+    }
+
+    callback = new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        System.out.println("Failed: " + e);
+      }
+
+      @Override public void onResponse(Response response) throws IOException {
+        ResponseBody body = response.body();
+        long total = SynchronousHttpClient.readAllAndClose(body.byteStream());
+        long finish = System.nanoTime();
+        if (VERBOSE) {
+          long start = (Long) response.request().tag();
+          System.out.printf("Transferred % 8d bytes in %4d ms%n",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start));
+        }
+        requestsInFlight.decrementAndGet();
+      }
+    };
+  }
+
+  @Override public void enqueue(URL url) throws Exception {
+    requestsInFlight.incrementAndGet();
+    client.newCall(new Request.Builder().tag(System.nanoTime()).url(url).build()).enqueue(callback);
+  }
+
+  @Override public synchronized boolean acceptingJobs() {
+    return requestsInFlight.get() < (concurrencyLevel + targetBacklog);
+  }
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
new file mode 100644
index 0000000000..b15eedcd88
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+/** Any HTTP client with a blocking API. */
+abstract class SynchronousHttpClient implements HttpClient {
+  ThreadPoolExecutor executor;
+  int targetBacklog;
+
+  @Override public void prepare(Benchmark benchmark) {
+    this.targetBacklog = benchmark.targetBacklog;
+    executor = new ThreadPoolExecutor(benchmark.concurrencyLevel, benchmark.concurrencyLevel,
+        1, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
+  }
+
+  @Override public void enqueue(URL url) {
+    executor.execute(request(url));
+  }
+
+  @Override public boolean acceptingJobs() {
+    return executor.getQueue().size() < targetBacklog;
+  }
+
+  static long readAllAndClose(InputStream in) throws IOException {
+    byte[] buffer = new byte[1024];
+    long total = 0;
+    for (int count; (count = in.read(buffer)) != -1; ) {
+      total += count;
+    }
+    in.close();
+    return total;
+  }
+
+  abstract Runnable request(URL url);
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
new file mode 100644
index 0000000000..630ec91c54
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.internal.SslContextBuilder;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.concurrent.TimeUnit;
+import java.util.zip.GZIPInputStream;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+
+class UrlConnection extends SynchronousHttpClient {
+  private static final boolean VERBOSE = false;
+
+  @Override public void prepare(Benchmark benchmark) {
+    super.prepare(benchmark);
+    if (benchmark.tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
+        @Override public boolean verify(String s, SSLSession session) {
+          return true;
+        }
+      };
+      HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);
+      HttpsURLConnection.setDefaultSSLSocketFactory(socketFactory);
+    }
+  }
+
+  @Override public Runnable request(URL url) {
+    return new UrlConnectionRequest(url);
+  }
+
+  static class UrlConnectionRequest implements Runnable {
+    private final URL url;
+
+    public UrlConnectionRequest(URL url) {
+      this.url = url;
+    }
+
+    public void run() {
+      long start = System.nanoTime();
+      try {
+        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
+        InputStream in = urlConnection.getInputStream();
+        if ("gzip".equals(urlConnection.getHeaderField("Content-Encoding"))) {
+          in = new GZIPInputStream(in);
+        }
+
+        long total = readAllAndClose(in);
+        long finish = System.nanoTime();
+
+        if (VERBOSE) {
+          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+        }
+      } catch (IOException e) {
+        System.out.println("Failed: " + e);
+      }
+    }
+  }
+}
diff --git a/checkstyle.xml b/checkstyle.xml
index 794af42b68..f725be3381 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -56,7 +56,9 @@
     <module name="IllegalImport"/>
     <!-- defaults to sun.* packages -->
     <module name="RedundantImport"/>
-    <module name="UnusedImports"/>
+    <module name="UnusedImports">
+      <property name="processJavadoc" value="true"/>
+    </module>
 
 
     <!-- Checks for Size Violations.                    -->
diff --git a/deploy_website.sh b/deploy_website.sh
index bac2744198..bbeedc2c36 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -26,10 +26,20 @@ rm -rf *
 # Copy website files from real repo
 cp -R ../website/* .
 
-# Download the latest javadoc
-curl -L "http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
-mkdir javadoc
-unzip javadoc.zip -d javadoc
+# Download the latest javadoc to directories like 'javadoc' or 'javadoc-urlconnection'.
+for DOCUMENTED_ARTIFACT in okhttp okhttp-urlconnection okhttp-apache
+do
+  curl -L "https://search.maven.org/remote_content?g=$GROUP_ID&a=$DOCUMENTED_ARTIFACT&v=LATEST&c=javadoc" > javadoc.zip
+  JAVADOC_DIR="javadoc${DOCUMENTED_ARTIFACT//okhttp/}"
+  mkdir $JAVADOC_DIR
+  unzip javadoc.zip -d $JAVADOC_DIR
+  rm javadoc.zip
+done
+
+# Download the 1.6.0 javadoc to '1.x/javadoc'.
+curl -L "https://search.maven.org/remote_content?g=$GROUP_ID&a=$ARTIFACT_ID&v=1.6.0&c=javadoc" > javadoc.zip
+mkdir -p 1.x/javadoc
+unzip javadoc.zip -d 1.x/javadoc
 rm javadoc.zip
 
 # Stage all files in git and create a commit
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
new file mode 100644
index 0000000000..9596ec1639
--- /dev/null
+++ b/mockwebserver/README.md
@@ -0,0 +1,146 @@
+MockWebServer
+=============
+
+A scriptable web server for testing HTTP clients
+
+
+### Motivation
+
+This library makes it easy to test that your app Does The Right Thing when it
+makes HTTP and HTTPS calls. It lets you specify which responses to return and
+then verify that requests were made as expected.
+
+Because it exercises your full HTTP stack, you can be confident that you're
+testing everything. You can even copy & paste HTTP responses from your real web
+server to create representative test cases. Or test that your code survives in
+awkward-to-reproduce situations like 500 errors or slow-loading responses.
+
+
+### Example
+
+Use MockWebServer the same way that you use mocking frameworks like
+[Mockito](https://code.google.com/p/mockito/):
+
+1. Script the mocks.
+2. Run application code.
+3. Verify that the expected requests were made.
+
+Here's a complete example:
+
+```java
+public void test() throws Exception {
+  // Create a MockWebServer. These are lean enough that you can create a new
+  // instance for every unit test.
+  MockWebServer server = new MockWebServer();
+
+  // Schedule some responses.
+  server.enqueue(new MockResponse().setBody("hello, world!"));
+  server.enqueue(new MockResponse().setBody("sup, bra?"));
+  server.enqueue(new MockResponse().setBody("yo dog"));
+
+  // Start the server.
+  server.play();
+
+  // Ask the server for its URL. You'll need this to make HTTP requests.
+  URL baseUrl = server.getUrl("/v1/chat/");
+
+  // Exercise your application code, which should make those HTTP requests.
+  // Responses are returned in the same order that they are enqueued.
+  Chat chat = new Chat(baseUrl);
+
+  chat.loadMore();
+  assertEquals("hello, world!", chat.messages());
+
+  chat.loadMore();
+  chat.loadMore();
+  assertEquals(""
+      + "hello, world!\n"
+      + "sup, bra?\n"
+      + "yo dog", chat.messages());
+
+  // Optional: confirm that your app made the HTTP requests you were expecting.
+  RecordedRequest request1 = server.takeRequest();
+  assertEquals("/v1/chat/messages/", request1.getPath());
+  assertNotNull(request1.getHeader("Authorization"));
+
+  RecordedRequest request2 = server.takeRequest();
+  assertEquals("/v1/chat/messages/2", request2.getPath());
+
+  RecordedRequest request3 = server.takeRequest();
+  assertEquals("/v1/chat/messages/3", request3.getPath());
+
+  // Shut down the server. Instances cannot be reused.
+  server.shutdown();
+}
+```
+
+Your unit tests might move the `server` into a field so you can shut it down
+from your test's `tearDown()`.
+
+### API
+
+#### MockResponse
+
+Mock responses default to an empty response body and a `200` status code.
+You can set a custom body with a string, input stream or byte array. Also
+add headers with a fluent builder API.
+
+```java
+MockResponse response = new MockResponse()
+    .addHeader("Content-Type", "application/json; charset=utf-8")
+    .addHeader("Cache-Control", "no-cache")
+    .setBody("{}");
+```
+
+MockResponse can be used to simulate a slow network. This is useful for
+testing timeouts and interactive testing.
+
+```java
+response.throttleBody(1024, 1, TimeUnit.SECONDS);
+```
+
+
+#### RecordedRequest
+
+Verify requests by their method, path, HTTP version, body, and headers.
+
+```java
+RecordedRequest request = server.takeRequest();
+assertEquals("POST /v1/chat/send HTTP/1.1", request.getRequestLine());
+assertEquals("application/json; charset=utf-8", request.getHeader("Content-Type"));
+assertEquals("{}", request.getUtf8Body());
+```
+
+#### Dispatcher
+
+By default MockWebServer uses a queue to specify a series of responses. Use a
+Dispatcher to handle requests using another policy. One natural policy is to
+dispatch on the request path.
+
+
+### Download
+
+The best way to get MockWebServer is via Maven:
+
+```xml
+<dependency>
+  <groupId>com.squareup.okhttp</groupId>
+  <artifactId>mockwebserver</artifactId>
+  <version>(insert latest version)</version>
+  <scope>test</scope>
+</dependency>
+```
+
+### License
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index f33f156ea1..b710a1e115 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
@@ -15,38 +15,38 @@
   <dependencies>
     <dependency>
       <groupId>com.squareup.okhttp</groupId>
-      <artifactId>okhttp-protocols</artifactId>
+      <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
       <groupId>org.bouncycastle</groupId>
       <artifactId>bcprov-jdk15on</artifactId>
     </dependency>
-    <dependency>
-      <groupId>org.mortbay.jetty.npn</groupId>
-      <artifactId>npn-boot</artifactId>
-      <optional>true</optional>
-    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
-      <scope>test</scope>
+      <optional>true</optional>
     </dependency>
   </dependencies>
 
   <build>
-    <!-- Don't restrict test code to Java 1.5 APIs. -->
     <plugins>
       <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
         <configuration>
-          <signature>
-            <groupId>org.codehaus.mojo.signature</groupId>
-            <artifactId>java16</artifactId>
-            <version>1.0</version>
-          </signature>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
         </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
       </plugin>
     </plugins>
   </build>
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
index 067726354f..3d61d73b05 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
@@ -19,6 +19,8 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.math.BigInteger;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
 import java.security.KeyPair;
 import java.security.KeyPairGenerator;
@@ -48,6 +50,8 @@
   }
 
   private static final long ONE_DAY_MILLIS = 1000L * 60 * 60 * 24;
+  private static SSLContext localhost; // Lazily initialized.
+
   private final String hostName;
   private long notBefore = System.currentTimeMillis();
   private long notAfter = System.currentTimeMillis() + ONE_DAY_MILLIS;
@@ -60,12 +64,26 @@ public SslContextBuilder(String hostName) {
     this.hostName = hostName;
   }
 
+  /** Returns a new SSL context for this host's current localhost address. */
+  public static synchronized SSLContext localhost() {
+    if (localhost == null) {
+      try {
+        localhost = new SslContextBuilder(InetAddress.getByName(null).getHostName()).build();
+      } catch (GeneralSecurityException e) {
+        throw new RuntimeException(e);
+      } catch (UnknownHostException e) {
+        throw new RuntimeException(e);
+      }
+    }
+    return localhost;
+  }
+
   public SSLContext build() throws GeneralSecurityException {
     char[] password = "password".toCharArray();
 
     // Generate public and private keys and use them to make a self-signed certificate.
     KeyPair keyPair = generateKeyPair();
-    X509Certificate certificate = selfSignedCertificate(keyPair);
+    X509Certificate certificate = selfSignedCertificate(keyPair, "1");
 
     // Put 'em in a key store.
     KeyStore keyStore = newEmptyKeyStore(password);
@@ -86,7 +104,7 @@ public SSLContext build() throws GeneralSecurityException {
     return sslContext;
   }
 
-  private KeyPair generateKeyPair() throws GeneralSecurityException {
+  public KeyPair generateKeyPair() throws GeneralSecurityException {
     KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC");
     keyPairGenerator.initialize(1024, new SecureRandom());
     return keyPairGenerator.generateKeyPair();
@@ -97,11 +115,12 @@ private KeyPair generateKeyPair() throws GeneralSecurityException {
    * public key, signed by {@code keyPair}'s private key.
    */
   @SuppressWarnings("deprecation") // use the old Bouncy Castle APIs to reduce dependencies.
-  private X509Certificate selfSignedCertificate(KeyPair keyPair) throws GeneralSecurityException {
+  public X509Certificate selfSignedCertificate(KeyPair keyPair, String serialNumber)
+      throws GeneralSecurityException {
     X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
     X500Principal issuer = new X500Principal("CN=" + hostName);
     X500Principal subject = new X500Principal("CN=" + hostName);
-    generator.setSerialNumber(BigInteger.ONE);
+    generator.setSerialNumber(new BigInteger(serialNumber));
     generator.setIssuerDN(issuer);
     generator.setNotBefore(new Date(notBefore));
     generator.setNotAfter(new Date(notAfter));
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
index 7371f2e3dc..fb21a088d0 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
@@ -16,28 +16,29 @@
 
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.net.InetAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.Arrays;
 import java.util.List;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
-import org.eclipse.jetty.npn.NextProtoNego;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Source;
 
-/** A basic SPDY server that serves the contents of a local directory. */
+/** A basic SPDY/HTTP_2 server that serves the contents of a local directory. */
 public final class SpdyServer implements IncomingStreamHandler {
+  private final List<Protocol> spdyProtocols = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3);
+
   private final File baseDirectory;
   private SSLSocketFactory sslSocketFactory;
+  private Protocol protocol;
 
   public SpdyServer(File baseDirectory) {
     this.baseDirectory = baseDirectory;
@@ -56,7 +57,7 @@ private void run() throws Exception {
       if (sslSocketFactory != null) {
         socket = doSsl(socket);
       }
-      new SpdyConnection.Builder(false, socket).handler(this).build();
+      new SpdyConnection.Builder(false, socket).protocol(protocol).handler(this).build();
     }
   }
 
@@ -65,27 +66,22 @@ private Socket doSsl(Socket socket) throws IOException {
         (SSLSocket) sslSocketFactory.createSocket(socket, socket.getInetAddress().getHostAddress(),
             socket.getPort(), true);
     sslSocket.setUseClientMode(false);
-    NextProtoNego.put(sslSocket, new NextProtoNego.ServerProvider() {
-      @Override public void unsupported() {
-        System.out.println("UNSUPPORTED");
-      }
-      @Override public List<String> protocols() {
-        return Arrays.asList("spdy/3");
-      }
-      @Override public void protocolSelected(String protocol) {
-        System.out.println("PROTOCOL SELECTED: " + protocol);
-      }
-    });
+    Platform.get().configureTlsExtensions(sslSocket, null, spdyProtocols);
+    sslSocket.startHandshake();
+    String protocolString = Platform.get().getSelectedProtocol(sslSocket);
+    protocol = protocolString != null ? Protocol.get(protocolString) : null;
+    if (protocol == null || !spdyProtocols.contains(protocol)) {
+      throw new IllegalStateException("Protocol " + protocol + " unsupported");
+    }
     return sslSocket;
   }
 
   @Override public void receive(final SpdyStream stream) throws IOException {
-    List<String> requestHeaders = stream.getRequestHeaders();
+    List<Header> requestHeaders = stream.getRequestHeaders();
     String path = null;
-    for (int i = 0; i < requestHeaders.size(); i += 2) {
-      String s = requestHeaders.get(i);
-      if (":path".equals(s)) {
-        path = requestHeaders.get(i + 1);
+    for (int i = 0, size = requestHeaders.size(); i < size; i++) {
+      if (requestHeaders.get(i).name.equals(Header.TARGET_PATH)) {
+        path = requestHeaders.get(i).value.utf8();
         break;
       }
     }
@@ -107,40 +103,46 @@ private Socket doSsl(Socket socket) throws IOException {
   }
 
   private void send404(SpdyStream stream, String path) throws IOException {
-    List<String> responseHeaders =
-        Arrays.asList(":status", "404", ":version", "HTTP/1.1", "content-type", "text/plain");
+    List<Header> responseHeaders = Arrays.asList(
+        new Header(":status", "404"),
+        new Header(":version", "HTTP/1.1"),
+        new Header("content-type", "text/plain")
+    );
     stream.reply(responseHeaders, true);
-    OutputStream out = stream.getOutputStream();
-    String text = "Not found: " + path;
-    out.write(text.getBytes("UTF-8"));
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.writeUtf8("Not found: " + path);
     out.close();
   }
 
   private void serveDirectory(SpdyStream stream, String[] files) throws IOException {
-    List<String> responseHeaders =
-        Arrays.asList(":status", "200", ":version", "HTTP/1.1", "content-type",
-            "text/html; charset=UTF-8");
+    List<Header> responseHeaders = Arrays.asList(
+        new Header(":status", "200"),
+        new Header(":version", "HTTP/1.1"),
+        new Header("content-type", "text/html; charset=UTF-8")
+    );
     stream.reply(responseHeaders, true);
-    OutputStream out = stream.getOutputStream();
-    Writer writer = new OutputStreamWriter(out, "UTF-8");
+    BufferedSink out = Okio.buffer(stream.getSink());
     for (String file : files) {
-      writer.write("<a href='" + file + "'>" + file + "</a><br>");
+      out.writeUtf8("<a href='" + file + "'>" + file + "</a><br>");
     }
-    writer.close();
+    out.close();
   }
 
   private void serveFile(SpdyStream stream, File file) throws IOException {
-    InputStream in = new FileInputStream(file);
-    byte[] buffer = new byte[8192];
-    stream.reply(
-        Arrays.asList(":status", "200", ":version", "HTTP/1.1", "content-type", contentType(file)),
-        true);
-    OutputStream out = stream.getOutputStream();
-    int count;
-    while ((count = in.read(buffer)) != -1) {
-      out.write(buffer, 0, count);
+    List<Header> responseHeaders = Arrays.asList(
+        new Header(":status", "200"),
+        new Header(":version", "HTTP/1.1"),
+        new Header("content-type", contentType(file))
+    );
+    stream.reply(responseHeaders, true);
+    Source source = Okio.source(file);
+    try {
+      BufferedSink out = Okio.buffer(stream.getSink());
+      out.writeAll(source);
+      out.close();
+    } finally {
+      Util.closeQuietly(source);
     }
-    out.close();
   }
 
   private String contentType(File file) {
@@ -154,8 +156,7 @@ public static void main(String... args) throws Exception {
     }
 
     SpdyServer server = new SpdyServer(new File(args[0]));
-    SSLContext sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    server.useHttps(sslContext.getSocketFactory());
+    server.useHttps(SslContextBuilder.localhost().getSocketFactory());
     server.run();
   }
 }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java
index ac6bac4a0b..b7de9b67d4 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/Dispatcher.java
@@ -24,11 +24,18 @@
   public abstract MockResponse dispatch(RecordedRequest request) throws InterruptedException;
 
   /**
-   * Returns the socket policy of the next request.  Default implementation
-   * returns {@link SocketPolicy#KEEP_OPEN}. Mischievous implementations can
-   * return other values to test HTTP edge cases.
+   * Returns an early guess of the next response, used for policy on how an
+   * incoming request should be received. The default implementation returns an
+   * empty response. Mischievous implementations can return other values to test
+   * HTTP edge cases, such as unhappy socket policies or throttled request
+   * bodies.
    */
-  public SocketPolicy peekSocketPolicy() {
-    return SocketPolicy.KEEP_OPEN;
+  public MockResponse peek() {
+    return new MockResponse().setSocketPolicy(SocketPolicy.KEEP_OPEN);
+  }
+
+  /** @deprecated replaced with {@link #peek}. */
+  protected final SocketPolicy peekSocketPolicy() {
+    throw new UnsupportedOperationException("This API is obsolete. Override peek() instead!");
   }
 }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
index b073c11a7d..350c6f65ac 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
@@ -15,40 +15,45 @@
  */
 package com.squareup.okhttp.mockwebserver;
 
-import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
 import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
+import okio.Buffer;
 
 /** A scripted response to be replayed by the mock web server. */
 public final class MockResponse implements Cloneable {
   private static final String CHUNKED_BODY_HEADER = "Transfer-encoding: chunked";
 
   private String status = "HTTP/1.1 200 OK";
-  private List<String> headers = new ArrayList<String>();
+  private List<String> headers = new ArrayList<>();
 
   /** The response body content, or null if {@code bodyStream} is set. */
-  private byte[] body;
+  private Buffer body;
   /** The response body content, or null if {@code body} is set. */
   private InputStream bodyStream;
 
-  private int bytesPerSecond = Integer.MAX_VALUE;
+  private int throttleBytesPerPeriod = Integer.MAX_VALUE;
+  private long throttlePeriod = 1;
+  private TimeUnit throttleUnit = TimeUnit.SECONDS;
+
   private SocketPolicy socketPolicy = SocketPolicy.KEEP_OPEN;
 
+  private int bodyDelayTimeMs = 0;
+
+  private List<PushPromise> promises = new ArrayList<>();
+
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
-    setBody(new byte[0]);
+    setBody(new Buffer());
   }
 
   @Override public MockResponse clone() {
     try {
       MockResponse result = (MockResponse) super.clone();
-      result.headers = new ArrayList<String>(result.headers);
+      result.headers = new ArrayList<>(headers);
+      result.promises = new ArrayList<>(promises);
       return result;
     } catch (CloneNotSupportedException e) {
       throw new AssertionError();
@@ -123,18 +128,22 @@ public MockResponse removeHeader(String name) {
   }
 
   /** Returns the raw HTTP payload, or null if this response is streamed. */
-  public byte[] getBody() {
-    return body;
+  public Buffer getBody() {
+    return body != null ? body.clone() : null; // Defensive copy.
   }
 
   /** Returns an input stream containing the raw HTTP payload. */
   InputStream getBodyStream() {
-    return bodyStream != null ? bodyStream : new ByteArrayInputStream(body);
+    return bodyStream != null ? bodyStream : getBody().inputStream();
   }
 
   public MockResponse setBody(byte[] body) {
-    setHeader("Content-Length", body.length);
-    this.body = body;
+    return setBody(new Buffer().write(body));
+  }
+
+  public MockResponse setBody(Buffer body) {
+    setHeader("Content-Length", body.size());
+    this.body = body.clone(); // Defensive copy.
     this.bodyStream = null;
     return this;
   }
@@ -148,39 +157,29 @@ public MockResponse setBody(InputStream bodyStream, long bodyLength) {
 
   /** Sets the response body to the UTF-8 encoded bytes of {@code body}. */
   public MockResponse setBody(String body) {
-    try {
-      return setBody(body.getBytes("UTF-8"));
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
+    return setBody(new Buffer().writeUtf8(body));
   }
 
   /**
    * Sets the response body to {@code body}, chunked every {@code maxChunkSize}
    * bytes.
    */
-  public MockResponse setChunkedBody(byte[] body, int maxChunkSize) {
+  public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
     removeHeader("Content-Length");
     headers.add(CHUNKED_BODY_HEADER);
 
-    try {
-      ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-      int pos = 0;
-      while (pos < body.length) {
-        int chunkSize = Math.min(body.length - pos, maxChunkSize);
-        bytesOut.write(Integer.toHexString(chunkSize).getBytes(Util.US_ASCII));
-        bytesOut.write("\r\n".getBytes(Util.US_ASCII));
-        bytesOut.write(body, pos, chunkSize);
-        bytesOut.write("\r\n".getBytes(Util.US_ASCII));
-        pos += chunkSize;
-      }
-      bytesOut.write("0\r\n\r\n".getBytes(Util.US_ASCII)); // Last chunk + empty trailer + crlf.
-
-      this.body = bytesOut.toByteArray();
-      return this;
-    } catch (IOException e) {
-      throw new AssertionError(); // In-memory I/O doesn't throw IOExceptions.
+    Buffer bytesOut = new Buffer();
+    while (!body.exhausted()) {
+      long chunkSize = Math.min(body.size(), maxChunkSize);
+      bytesOut.writeUtf8(Long.toHexString(chunkSize));
+      bytesOut.writeUtf8("\r\n");
+      bytesOut.write(body, chunkSize);
+      bytesOut.writeUtf8("\r\n");
     }
+    bytesOut.writeUtf8("0\r\n\r\n"); // Last chunk + empty trailer + CRLF.
+
+    this.body = bytesOut;
+    return this;
   }
 
   /**
@@ -188,11 +187,7 @@ public MockResponse setChunkedBody(byte[] body, int maxChunkSize) {
    * every {@code maxChunkSize} bytes.
    */
   public MockResponse setChunkedBody(String body, int maxChunkSize) {
-    try {
-      return setChunkedBody(body.getBytes("UTF-8"), maxChunkSize);
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
+    return setChunkedBody(new Buffer().writeUtf8(body), maxChunkSize);
   }
 
   public SocketPolicy getSocketPolicy() {
@@ -204,19 +199,58 @@ public MockResponse setSocketPolicy(SocketPolicy socketPolicy) {
     return this;
   }
 
-  public int getBytesPerSecond() {
-    return bytesPerSecond;
+  /**
+   * Throttles the response body writer to sleep for the given period after each
+   * series of {@code bytesPerPeriod} bytes are written. Use this to simulate
+   * network behavior.
+   */
+  public MockResponse throttleBody(int bytesPerPeriod, long period, TimeUnit unit) {
+    this.throttleBytesPerPeriod = bytesPerPeriod;
+    this.throttlePeriod = period;
+    this.throttleUnit = unit;
+    return this;
+  }
+
+  public int getThrottleBytesPerPeriod() {
+    return throttleBytesPerPeriod;
+  }
+
+  public long getThrottlePeriod() {
+    return throttlePeriod;
+  }
+
+  public TimeUnit getThrottleUnit() {
+    return throttleUnit;
   }
 
   /**
-   * Set simulated network speed, in bytes per second. This applies to the
-   * response body only; response headers are not throttled.
+   * Set the delayed time of the response body to {@code delay}. This applies to the
+   * response body only; response headers are not affected.
    */
-  public MockResponse setBytesPerSecond(int bytesPerSecond) {
-    this.bytesPerSecond = bytesPerSecond;
+  public MockResponse setBodyDelayTimeMs(int delay) {
+    bodyDelayTimeMs = delay;
     return this;
   }
 
+  public int getBodyDelayTimeMs() {
+    return bodyDelayTimeMs;
+  }
+
+  /**
+   * When {@link MockWebServer#setProtocols(java.util.List) protocols}
+   * include {@linkplain com.squareup.okhttp.Protocol#HTTP_2}, this attaches a
+   * pushed stream to this response.
+   */
+  public MockResponse withPush(PushPromise promise) {
+    this.promises.add(promise);
+    return this;
+  }
+
+  /** Returns the streams the server will push with this response. */
+  public List<PushPromise> getPushPromises() {
+    return promises;
+  }
+
   @Override public String toString() {
     return status;
   }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 235c8b07ee..7e07204760 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -17,8 +17,12 @@
 
 package com.squareup.okhttp.mockwebserver;
 
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.spdy.ErrorCode;
+import com.squareup.okhttp.internal.spdy.Header;
 import com.squareup.okhttp.internal.spdy.IncomingStreamHandler;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
@@ -31,35 +35,41 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.MalformedURLException;
+import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketException;
 import java.net.URL;
-import java.net.UnknownHostException;
 import java.security.SecureRandom;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
-import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import javax.net.ServerSocketFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
@@ -69,22 +79,6 @@
  * replays them upon request in sequence.
  */
 public final class MockWebServer {
-  private static final byte[] NPN_PROTOCOLS = {
-      // TODO: support HTTP/2.0.
-      // 17, 'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '4', '/', '2', '.', '0',
-      6, 's', 'p', 'd', 'y', '/', '3',
-      8, 'h', 't', 't', 'p', '/', '1', '.', '1'
-  };
-  private static final byte[] SPDY3 = new byte[] {
-      's', 'p', 'd', 'y', '/', '3'
-  };
-  private static final byte[] HTTP_20_DRAFT_04 = new byte[] {
-      'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '4', '/', '2', '.', '0'
-  };
-  private static final byte[] HTTP_11 = new byte[] {
-      'h', 't', 't', 'p', '/', '1', '.', '1'
-  };
-
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
     @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
         throws CertificateException {
@@ -102,15 +96,15 @@
 
   private static final Logger logger = Logger.getLogger(MockWebServer.class.getName());
 
-  private final BlockingQueue<RecordedRequest> requestQueue =
-      new LinkedBlockingQueue<RecordedRequest>();
+  private final BlockingQueue<RecordedRequest> requestQueue = new LinkedBlockingQueue<>();
 
-  /** All map values are Boolean.TRUE. (Collections.newSetFromMap isn't available in Froyo) */
-  private final Map<Socket, Boolean> openClientSockets = new ConcurrentHashMap<Socket, Boolean>();
-  private final Map<SpdyConnection, Boolean> openSpdyConnections
-      = new ConcurrentHashMap<SpdyConnection, Boolean>();
+  private final Set<Socket> openClientSockets =
+      Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
+  private final Set<SpdyConnection> openSpdyConnections =
+      Collections.newSetFromMap(new ConcurrentHashMap<SpdyConnection, Boolean>());
   private final AtomicInteger requestCount = new AtomicInteger();
   private int bodyLimit = Integer.MAX_VALUE;
+  private ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
   private ServerSocket serverSocket;
   private SSLSocketFactory sslSocketFactory;
   private ExecutorService executor;
@@ -118,23 +112,29 @@
   private Dispatcher dispatcher = new QueueDispatcher();
 
   private int port = -1;
-  private boolean npnEnabled = true;
+  private InetAddress inetAddress;
+  private boolean protocolNegotiationEnabled = true;
+  private List<Protocol> protocols
+      = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
+
+  public void setServerSocketFactory(ServerSocketFactory serverSocketFactory) {
+    if (serverSocketFactory == null) throw new IllegalArgumentException("null serverSocketFactory");
+    this.serverSocketFactory = serverSocketFactory;
+  }
 
   public int getPort() {
-    if (port == -1) throw new IllegalStateException("Cannot retrieve port before calling play()");
+    if (port == -1) throw new IllegalStateException("Call play() before getPort()");
     return port;
   }
 
   public String getHostName() {
-    try {
-      return InetAddress.getLocalHost().getHostName();
-    } catch (UnknownHostException e) {
-      throw new AssertionError(e);
-    }
+    if (inetAddress == null) throw new IllegalStateException("Call play() before getHostName()");
+    return inetAddress.getHostName();
   }
 
   public Proxy toProxyAddress() {
-    return new Proxy(Proxy.Type.HTTP, new InetSocketAddress(getHostName(), getPort()));
+    if (inetAddress == null) throw new IllegalStateException("Call play() before toProxyAddress()");
+    return new Proxy(Proxy.Type.HTTP, new InetSocketAddress(inetAddress, getPort()));
   }
 
   /**
@@ -170,12 +170,31 @@ public void setBodyLimit(int maxBodyLength) {
   }
 
   /**
-   * Sets whether NPN is used on incoming HTTPS connections to negotiate a
-   * transport like HTTP/1.1 or SPDY/3. Call this method to disable NPN and
-   * SPDY.
+   * Sets whether ALPN is used on incoming HTTPS connections to
+   * negotiate a protocol like HTTP/1.1 or HTTP/2. Call this method to disable
+   * negotiation and restrict connections to HTTP/1.1.
    */
-  public void setNpnEnabled(boolean npnEnabled) {
-    this.npnEnabled = npnEnabled;
+  public void setProtocolNegotiationEnabled(boolean protocolNegotiationEnabled) {
+    this.protocolNegotiationEnabled = protocolNegotiationEnabled;
+  }
+
+  /**
+   * Indicates the protocols supported by ALPN on incoming HTTPS
+   * connections. This list is ignored when
+   * {@link #setProtocolNegotiationEnabled negotiation is disabled}.
+   *
+   * @param protocols the protocols to use, in order of preference. The list
+   *     must contain {@linkplain Protocol#HTTP_1_1}. It must not contain null.
+   */
+  public void setProtocols(List<Protocol> protocols) {
+    protocols = Util.immutableList(protocols);
+    if (!protocols.contains(Protocol.HTTP_1_1)) {
+      throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
+    }
+    if (protocols.contains(null)) {
+      throw new IllegalArgumentException("protocols must not contain null");
+    }
+    this.protocols = protocols;
   }
 
   /**
@@ -190,12 +209,30 @@ public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
 
   /**
    * Awaits the next HTTP request, removes it, and returns it. Callers should
-   * use this to verify the request was sent as intended.
+   * use this to verify the request was sent as intended. This method will block until the
+   * request is available, possibly forever.
+   *
+   * @return the head of the request queue
    */
   public RecordedRequest takeRequest() throws InterruptedException {
     return requestQueue.take();
   }
 
+  /**
+   * Awaits the next HTTP request (waiting up to the
+   * specified wait time if necessary), removes it, and returns it. Callers should
+   * use this to verify the request was sent as intended within the given time.
+   *
+   * @param timeout how long to wait before giving up, in units of
+  *        {@code unit}
+   * @param unit a {@code TimeUnit} determining how to interpret the
+   *        {@code timeout} parameter
+   * @return the head of the request queue
+   */
+  public RecordedRequest takeRequest(int timeout, TimeUnit unit) throws InterruptedException {
+    return requestQueue.poll(timeout, unit);
+  }
+
   /**
    * Returns the number of HTTP requests received thus far by this server. This
    * may exceed the number of HTTP connections when connection reuse is in
@@ -231,27 +268,29 @@ public void play() throws IOException {
    */
   public void play(int port) throws IOException {
     if (executor != null) throw new IllegalStateException("play() already called");
-    executor = Executors.newCachedThreadPool();
-    serverSocket = new ServerSocket(port);
-    serverSocket.setReuseAddress(true);
+    executor = Executors.newCachedThreadPool(Util.threadFactory("MockWebServer", false));
+    inetAddress = InetAddress.getByName(null);
+    serverSocket = serverSocketFactory.createServerSocket();
+    serverSocket.setReuseAddress(port != 0); // Reuse the port if the port number was specified.
+    serverSocket.bind(new InetSocketAddress(inetAddress, port), 50);
 
     this.port = serverSocket.getLocalPort();
-    executor.execute(namedRunnable("MockWebServer-accept-" + port, new Runnable() {
-      public void run() {
+    executor.execute(new NamedRunnable("MockWebServer %s", this.port) {
+      @Override protected void execute() {
         try {
+          logger.info(MockWebServer.this + " starting to accept connections");
           acceptConnections();
         } catch (Throwable e) {
-          logger.log(Level.WARNING, "MockWebServer connection failed", e);
+          logger.log(Level.WARNING, MockWebServer.this + " failed unexpectedly", e);
         }
 
-        // This gnarly block of code will release all sockets and all thread,
-        // even if any close fails.
+        // Release all sockets and all threads, even if any close fails.
         Util.closeQuietly(serverSocket);
-        for (Iterator<Socket> s = openClientSockets.keySet().iterator(); s.hasNext(); ) {
+        for (Iterator<Socket> s = openClientSockets.iterator(); s.hasNext(); ) {
           Util.closeQuietly(s.next());
           s.remove();
         }
-        for (Iterator<SpdyConnection> s = openSpdyConnections.keySet().iterator(); s.hasNext(); ) {
+        for (Iterator<SpdyConnection> s = openSpdyConnections.iterator(); s.hasNext(); ) {
           Util.closeQuietly(s.next());
           s.remove();
         }
@@ -264,48 +303,60 @@ private void acceptConnections() throws Exception {
           try {
             socket = serverSocket.accept();
           } catch (SocketException e) {
+            logger.info(MockWebServer.this + " done accepting connections: " + e.getMessage());
             return;
           }
-          SocketPolicy socketPolicy = dispatcher.peekSocketPolicy();
+          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
           if (socketPolicy == DISCONNECT_AT_START) {
             dispatchBookkeepingRequest(0, socket);
             socket.close();
           } else {
-            openClientSockets.put(socket, true);
+            openClientSockets.add(socket);
             serveConnection(socket);
           }
         }
       }
-    }));
+    });
   }
 
   public void shutdown() throws IOException {
-    if (serverSocket != null) {
-      serverSocket.close(); // Should cause acceptConnections() to break out.
+    // Cause acceptConnections() to break out.
+    serverSocket.close();
+
+    // Await shutdown.
+    try {
+      if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
+        throw new IOException("Gave up waiting for executor to shut down");
+      }
+    } catch (InterruptedException e) {
+      throw new AssertionError();
     }
   }
 
   private void serveConnection(final Socket raw) {
-    String name = "MockWebServer-" + raw.getRemoteSocketAddress();
-    executor.execute(namedRunnable(name, new Runnable() {
+    executor.execute(new NamedRunnable("MockWebServer %s", raw.getRemoteSocketAddress()) {
       int sequenceNumber = 0;
 
-      public void run() {
+      @Override protected void execute() {
         try {
           processConnection();
+        } catch (IOException e) {
+          logger.info(MockWebServer.this + " connection from "
+              + raw.getInetAddress() + " failed: " + e);
         } catch (Exception e) {
-          logger.log(Level.WARNING, "MockWebServer connection failed", e);
+          logger.log(Level.SEVERE, MockWebServer.this + " connection from "
+              + raw.getInetAddress() + " crashed", e);
         }
       }
 
       public void processConnection() throws Exception {
-        Transport transport = Transport.HTTP_11;
+        Protocol protocol = Protocol.HTTP_1_1;
         Socket socket;
         if (sslSocketFactory != null) {
           if (tunnelProxy) {
             createTunnel();
           }
-          SocketPolicy socketPolicy = dispatcher.peekSocketPolicy();
+          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
           if (socketPolicy == FAIL_HANDSHAKE) {
             dispatchBookkeepingRequest(sequenceNumber, raw);
             processHandshakeFailure(raw);
@@ -315,45 +366,32 @@ public void processConnection() throws Exception {
               raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);
           SSLSocket sslSocket = (SSLSocket) socket;
           sslSocket.setUseClientMode(false);
-          openClientSockets.put(socket, true);
+          openClientSockets.add(socket);
 
-          if (npnEnabled) {
-            Platform.get().setNpnProtocols(sslSocket, NPN_PROTOCOLS);
+          if (protocolNegotiationEnabled) {
+            Platform.get().configureTlsExtensions(sslSocket, null, protocols);
           }
 
           sslSocket.startHandshake();
 
-          if (npnEnabled) {
-            byte[] selectedProtocol = Platform.get().getNpnSelectedProtocol(sslSocket);
-            if (selectedProtocol == null || Arrays.equals(selectedProtocol, HTTP_11)) {
-              transport = Transport.HTTP_11;
-            } else if (Arrays.equals(selectedProtocol, HTTP_20_DRAFT_04)) {
-              transport = Transport.HTTP_20_DRAFT_04;
-            } else if (Arrays.equals(selectedProtocol, SPDY3)) {
-              transport = Transport.SPDY_3;
-            } else {
-              throw new IllegalStateException(
-                  "Unexpected transport: " + new String(selectedProtocol, Util.US_ASCII));
-            }
+          if (protocolNegotiationEnabled) {
+            String protocolString = Platform.get().getSelectedProtocol(sslSocket);
+            protocol = protocolString != null
+                ? Protocol.get(protocolString)
+                : Protocol.HTTP_1_1;
           }
           openClientSockets.remove(raw);
         } else {
           socket = raw;
         }
 
-        if (transport == Transport.SPDY_3 || transport == Transport.HTTP_20_DRAFT_04) {
-          SpdySocketHandler spdySocketHandler = new SpdySocketHandler(socket, transport);
-          SpdyConnection.Builder builder = new SpdyConnection.Builder(false, socket)
-              .handler(spdySocketHandler);
-          if (transport == Transport.SPDY_3) {
-            builder.spdy3();
-          } else {
-            builder.http20Draft04();
-          }
-          SpdyConnection spdyConnection = builder.build();
-          openSpdyConnections.put(spdyConnection, Boolean.TRUE);
+        if (protocol != Protocol.HTTP_1_1) {
+          SpdySocketHandler spdySocketHandler = new SpdySocketHandler(socket, protocol);
+          SpdyConnection spdyConnection = new SpdyConnection.Builder(false, socket)
+              .protocol(protocol)
+              .handler(spdySocketHandler).build();
+          openSpdyConnections.add(spdyConnection);
           openClientSockets.remove(socket);
-          spdyConnection.readConnectionHeader();
           return;
         }
 
@@ -364,7 +402,8 @@ public void processConnection() throws Exception {
         }
 
         if (sequenceNumber == 0) {
-          logger.warning("MockWebServer connection didn't make a request");
+          logger.warning(MockWebServer.this + " connection from " + raw.getInetAddress()
+              + " didn't make a request");
         }
 
         in.close();
@@ -379,7 +418,7 @@ public void processConnection() throws Exception {
        */
       private void createTunnel() throws IOException, InterruptedException {
         while (true) {
-          SocketPolicy socketPolicy = dispatcher.peekSocketPolicy();
+          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
           if (!processOneRequest(raw, raw.getInputStream(), raw.getOutputStream())) {
             throw new IllegalStateException("Tunnel without any CONNECT!");
           }
@@ -398,7 +437,16 @@ private boolean processOneRequest(Socket socket, InputStream in, OutputStream ou
         requestCount.incrementAndGet();
         requestQueue.add(request);
         MockResponse response = dispatcher.dispatch(request);
-        writeResponse(out, response);
+        if (response.getSocketPolicy() == SocketPolicy.DISCONNECT_AFTER_REQUEST) {
+          socket.close();
+          return false;
+        }
+        if (response.getSocketPolicy() == SocketPolicy.NO_RESPONSE) {
+          // This read should block until the socket is closed. (Because nobody is writing.)
+          if (in.read() == -1) return false;
+          throw new ProtocolException("unexpected data");
+        }
+        writeResponse(socket, out, response);
         if (response.getSocketPolicy() == SocketPolicy.DISCONNECT_AT_END) {
           in.close();
           out.close();
@@ -407,20 +455,22 @@ private boolean processOneRequest(Socket socket, InputStream in, OutputStream ou
         } else if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_OUTPUT_AT_END) {
           socket.shutdownOutput();
         }
-        logger.info("Received request: " + request + " and responded: " + response);
+        if (logger.isLoggable(Level.INFO)) {
+          logger.info(MockWebServer.this + " received request: " + request
+              + " and responded: " + response);
+        }
         sequenceNumber++;
         return true;
       }
-    }));
+    });
   }
 
   private void processHandshakeFailure(Socket raw) throws Exception {
     SSLContext context = SSLContext.getInstance("TLS");
     context.init(null, new TrustManager[] { UNTRUSTED_TRUST_MANAGER }, new SecureRandom());
     SSLSocketFactory sslSocketFactory = context.getSocketFactory();
-    SSLSocket socket =
-        (SSLSocket) sslSocketFactory.createSocket(raw, raw.getInetAddress().getHostAddress(),
-            raw.getPort(), true);
+    SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(
+        raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);
     try {
       socket.startHandshake(); // we're testing a handshake failure
       throw new AssertionError();
@@ -448,7 +498,7 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
       return null; // no request because the stream is exhausted
     }
 
-    List<String> headers = new ArrayList<String>();
+    List<String> headers = new ArrayList<>();
     long contentLength = -1;
     boolean chunked = false;
     boolean expectContinue = false;
@@ -478,10 +528,11 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
 
     boolean hasBody = false;
     TruncatingOutputStream requestBody = new TruncatingOutputStream();
-    List<Integer> chunkSizes = new ArrayList<Integer>();
+    List<Integer> chunkSizes = new ArrayList<>();
+    MockResponse throttlePolicy = dispatcher.peek();
     if (contentLength != -1) {
-      hasBody = true;
-      transfer(contentLength, in, requestBody);
+      hasBody = contentLength > 0;
+      throttledTransfer(throttlePolicy, socket, in, requestBody, contentLength);
     } else if (chunked) {
       hasBody = true;
       while (true) {
@@ -491,7 +542,7 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
           break;
         }
         chunkSizes.add(chunkSize);
-        transfer(chunkSize, in, requestBody);
+        throttledTransfer(throttlePolicy, socket, in, requestBody, chunkSize);
         readEmptyLine(in);
       }
     }
@@ -499,13 +550,15 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
     if (request.startsWith("OPTIONS ")
         || request.startsWith("GET ")
         || request.startsWith("HEAD ")
-        || request.startsWith("DELETE ")
         || request.startsWith("TRACE ")
         || request.startsWith("CONNECT ")) {
       if (hasBody) {
         throw new IllegalArgumentException("Request must not have a body: " + request);
       }
-    } else if (!request.startsWith("POST ") && !request.startsWith("PUT ")) {
+    } else if (!request.startsWith("POST ")
+        && !request.startsWith("PUT ")
+        && !request.startsWith("PATCH ")
+        && !request.startsWith("DELETE ")) { // Permitted as spec is ambiguous.
       throw new UnsupportedOperationException("Unexpected method: " + request);
     }
 
@@ -513,9 +566,12 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
         requestBody.toByteArray(), sequenceNumber, socket);
   }
 
-  private void writeResponse(OutputStream out, MockResponse response) throws IOException {
+  private void writeResponse(Socket socket, OutputStream out, MockResponse response)
+      throws IOException {
     out.write((response.getStatus() + "\r\n").getBytes(Util.US_ASCII));
-    for (String header : response.getHeaders()) {
+    List<String> headers = response.getHeaders();
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String header = headers.get(i);
       out.write((header + "\r\n").getBytes(Util.US_ASCII));
     }
     out.write(("\r\n").getBytes(Util.US_ASCII));
@@ -523,43 +579,50 @@ private void writeResponse(OutputStream out, MockResponse response) throws IOExc
 
     InputStream in = response.getBodyStream();
     if (in == null) return;
-    int bytesPerSecond = response.getBytesPerSecond();
-
-    // Stream data in MTU-sized increments, with a minimum of one packet per second.
-    byte[] buffer = bytesPerSecond >= 1452 ? new byte[1452] : new byte[bytesPerSecond];
-    long delayMs = bytesPerSecond == Integer.MAX_VALUE
-        ? 0
-        : (1000 * buffer.length) / bytesPerSecond;
-
-    int read;
-    long sinceDelay = 0;
-    while ((read = in.read(buffer)) != -1) {
-      out.write(buffer, 0, read);
-      out.flush();
+    sleepIfDelayed(response);
+    throttledTransfer(response, socket, in, out, Long.MAX_VALUE);
+  }
 
-      sinceDelay += read;
-      if (sinceDelay >= buffer.length && delayMs > 0) {
-        sinceDelay %= buffer.length;
-        try {
-          Thread.sleep(delayMs);
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
+  private void sleepIfDelayed(MockResponse response) {
+    if (response.getBodyDelayTimeMs() != 0) {
+      try {
+        Thread.sleep(response.getBodyDelayTimeMs());
+      } catch (InterruptedException e) {
+        throw new AssertionError(e);
       }
     }
   }
 
   /**
    * Transfer bytes from {@code in} to {@code out} until either {@code length}
-   * bytes have been transferred or {@code in} is exhausted.
+   * bytes have been transferred or {@code in} is exhausted. The transfer is
+   * throttled according to {@code throttlePolicy}.
    */
-  private void transfer(long length, InputStream in, OutputStream out) throws IOException {
+  private void throttledTransfer(MockResponse throttlePolicy, Socket socket, InputStream in,
+      OutputStream out, long limit) throws IOException {
     byte[] buffer = new byte[1024];
-    while (length > 0) {
-      int count = in.read(buffer, 0, (int) Math.min(buffer.length, length));
-      if (count == -1) return;
-      out.write(buffer, 0, count);
-      length -= count;
+    int bytesPerPeriod = throttlePolicy.getThrottleBytesPerPeriod();
+    long delayMs = throttlePolicy.getThrottleUnit().toMillis(throttlePolicy.getThrottlePeriod());
+
+    while (!socket.isClosed()) {
+      for (int b = 0; b < bytesPerPeriod; ) {
+        int toRead = (int) Math.min(Math.min(buffer.length, limit), bytesPerPeriod - b);
+        int read = in.read(buffer, 0, toRead);
+        if (read == -1) return;
+
+        out.write(buffer, 0, read);
+        out.flush();
+        b += read;
+        limit -= read;
+
+        if (limit == 0) return;
+      }
+
+      try {
+        if (delayMs != 0) Thread.sleep(delayMs);
+      } catch (InterruptedException e) {
+        throw new AssertionError();
+      }
     }
   }
 
@@ -598,6 +661,10 @@ public void setDispatcher(Dispatcher dispatcher) {
     this.dispatcher = dispatcher;
   }
 
+  @Override public String toString() {
+    return "MockWebServer[" + port + "]";
+  }
+
   /** An output stream that drops data after bodyLimit bytes. */
   private class TruncatingOutputStream extends ByteArrayOutputStream {
     private long numBytesReceived = 0;
@@ -615,28 +682,15 @@ public void setDispatcher(Dispatcher dispatcher) {
     }
   }
 
-  private static Runnable namedRunnable(final String name, final Runnable runnable) {
-    return new Runnable() {
-      public void run() {
-        String originalName = Thread.currentThread().getName();
-        Thread.currentThread().setName(name);
-        try {
-          runnable.run();
-        } finally {
-          Thread.currentThread().setName(originalName);
-        }
-      }
-    };
-  }
-
   /** Processes HTTP requests layered over SPDY/3. */
   private class SpdySocketHandler implements IncomingStreamHandler {
     private final Socket socket;
-    private final Transport transport;
+    private final Protocol protocol;
+    private final AtomicInteger sequenceNumber = new AtomicInteger();
 
-    private SpdySocketHandler(Socket socket, Transport transport) {
+    private SpdySocketHandler(Socket socket, Protocol protocol) {
       this.socket = socket;
-      this.transport = transport;
+      this.protocol = protocol;
     }
 
     @Override public void receive(SpdyStream stream) throws IOException {
@@ -649,73 +703,126 @@ private SpdySocketHandler(Socket socket, Transport transport) {
         throw new AssertionError(e);
       }
       writeResponse(stream, response);
-      logger.info("Received request: " + request + " and responded: " + response
-          + " transport is " + transport);
+      if (logger.isLoggable(Level.INFO)) {
+        logger.info(MockWebServer.this + " received request: " + request
+            + " and responded: " + response + " protocol is " + protocol.toString());
+      }
     }
 
     private RecordedRequest readRequest(SpdyStream stream) throws IOException {
-      List<String> spdyHeaders = stream.getRequestHeaders();
-      List<String> httpHeaders = new ArrayList<String>();
+      List<Header> spdyHeaders = stream.getRequestHeaders();
+      List<String> httpHeaders = new ArrayList<>();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
-      String version = "<:version omitted>";
-      for (Iterator<String> i = spdyHeaders.iterator(); i.hasNext(); ) {
-        String name = i.next();
-        String value = i.next();
-        if (":method".equals(name)) {
+      String version = protocol == Protocol.SPDY_3 ? "<:version omitted>" : "HTTP/1.1";
+      for (int i = 0, size = spdyHeaders.size(); i < size; i++) {
+        ByteString name = spdyHeaders.get(i).name;
+        String value = spdyHeaders.get(i).value.utf8();
+        if (name.equals(Header.TARGET_METHOD)) {
           method = value;
-        } else if (":path".equals(name)) {
+        } else if (name.equals(Header.TARGET_PATH)) {
           path = value;
-        } else if (":version".equals(name)) {
+        } else if (name.equals(Header.VERSION)) {
           version = value;
         } else {
-          httpHeaders.add(name + ": " + value);
+          httpHeaders.add(name.utf8() + ": " + value);
         }
       }
 
-      InputStream bodyIn = stream.getInputStream();
-      ByteArrayOutputStream bodyOut = new ByteArrayOutputStream();
-      byte[] buffer = new byte[8192];
-      int count;
-      while ((count = bodyIn.read(buffer)) != -1) {
-        bodyOut.write(buffer, 0, count);
-      }
+      BufferedSource bodyIn = Okio.buffer(stream.getSource());
+      byte[] bodyOut = bodyIn.readByteArray();
       bodyIn.close();
+
       String requestLine = method + ' ' + path + ' ' + version;
       List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
-      return new RecordedRequest(requestLine, httpHeaders, chunkSizes, bodyOut.size(),
-          bodyOut.toByteArray(), 0, socket);
+      return new RecordedRequest(requestLine, httpHeaders, chunkSizes, bodyOut.length,
+          bodyOut, sequenceNumber.getAndIncrement(), socket);
     }
 
     private void writeResponse(SpdyStream stream, MockResponse response) throws IOException {
-      List<String> spdyHeaders = new ArrayList<String>();
+      if (response.getSocketPolicy() == SocketPolicy.NO_RESPONSE) {
+        return;
+      }
+      List<Header> spdyHeaders = new ArrayList<>();
       String[] statusParts = response.getStatus().split(" ", 2);
       if (statusParts.length != 2) {
         throw new AssertionError("Unexpected status: " + response.getStatus());
       }
-      spdyHeaders.add(":status");
-      spdyHeaders.add(statusParts[1]);
-      // TODO: no ":version" header for HTTP/2.0, only SPDY.
-      spdyHeaders.add(":version");
-      spdyHeaders.add(statusParts[0]);
-      for (String header : response.getHeaders()) {
+      // TODO: constants for well-known header names.
+      spdyHeaders.add(new Header(Header.RESPONSE_STATUS, statusParts[1]));
+      if (protocol == Protocol.SPDY_3) {
+        spdyHeaders.add(new Header(Header.VERSION, statusParts[0]));
+      }
+      List<String> headers = response.getHeaders();
+      for (int i = 0, size = headers.size(); i < size; i++) {
+        String header = headers.get(i);
         String[] headerParts = header.split(":", 2);
         if (headerParts.length != 2) {
           throw new AssertionError("Unexpected header: " + header);
         }
-        spdyHeaders.add(headerParts[0].toLowerCase(Locale.US).trim());
-        spdyHeaders.add(headerParts[1].trim());
+        spdyHeaders.add(new Header(headerParts[0], headerParts[1]));
       }
-      byte[] body = response.getBody();
-      stream.reply(spdyHeaders, body.length > 0);
-      if (body.length > 0) {
-        stream.getOutputStream().write(body);
-        stream.getOutputStream().close();
+      Buffer body = response.getBody();
+      if (body == null) body = new Buffer();
+      boolean closeStreamAfterHeaders = body.size() > 0 || !response.getPushPromises().isEmpty();
+      stream.reply(spdyHeaders, closeStreamAfterHeaders);
+      pushPromises(stream, response.getPushPromises());
+      if (body.size() > 0) {
+        if (response.getBodyDelayTimeMs() != 0) {
+          try {
+            Thread.sleep(response.getBodyDelayTimeMs());
+          } catch (InterruptedException e) {
+            throw new AssertionError(e);
+          }
+        }
+        BufferedSink sink = Okio.buffer(stream.getSink());
+        if (response.getThrottleBytesPerPeriod() == Integer.MAX_VALUE) {
+          sink.writeAll(body);
+          sink.flush();
+        } else {
+          while (body.size() > 0) {
+            long toWrite = Math.min(body.size(), response.getThrottleBytesPerPeriod());
+            sink.write(body, toWrite);
+            sink.flush();
+            try {
+              long delayMs = response.getThrottleUnit().toMillis(response.getThrottlePeriod());
+              if (delayMs != 0) Thread.sleep(delayMs);
+            } catch (InterruptedException e) {
+              throw new AssertionError();
+            }
+          }
+        }
+        sink.close();
+      } else if (closeStreamAfterHeaders) {
+        stream.close(ErrorCode.NO_ERROR);
       }
     }
-  }
 
-  enum Transport {
-    HTTP_11, SPDY_3, HTTP_20_DRAFT_04
+    private void pushPromises(SpdyStream stream, List<PushPromise> promises) throws IOException {
+      for (PushPromise pushPromise : promises) {
+        List<Header> pushedHeaders = new ArrayList<>();
+        pushedHeaders.add(new Header(stream.getConnection().getProtocol() == Protocol.SPDY_3
+            ? Header.TARGET_HOST
+            : Header.TARGET_AUTHORITY, getUrl(pushPromise.getPath()).getHost()));
+        pushedHeaders.add(new Header(Header.TARGET_METHOD, pushPromise.getMethod()));
+        pushedHeaders.add(new Header(Header.TARGET_PATH, pushPromise.getPath()));
+        for (int i = 0, size = pushPromise.getHeaders().size(); i < size; i++) {
+          String header = pushPromise.getHeaders().get(i);
+          String[] headerParts = header.split(":", 2);
+          if (headerParts.length != 2) {
+            throw new AssertionError("Unexpected header: " + header);
+          }
+          pushedHeaders.add(new Header(headerParts[0], headerParts[1].trim()));
+        }
+        String requestLine = pushPromise.getMethod() + ' ' + pushPromise.getPath() + " HTTP/1.1";
+        List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
+        requestQueue.add(new RecordedRequest(requestLine, pushPromise.getHeaders(), chunkSizes, 0,
+            Util.EMPTY_BYTE_ARRAY, sequenceNumber.getAndIncrement(), socket));
+        Buffer pushedBody = pushPromise.getResponse().getBody();
+        SpdyStream pushedStream =
+            stream.getConnection().pushStream(stream.getId(), pushedHeaders, pushedBody.size() > 0);
+        writeResponse(pushedStream, pushPromise.getResponse());
+      }
+    }
   }
 }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java
new file mode 100644
index 0000000000..d9dd01978b
--- /dev/null
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.mockwebserver;
+
+import java.util.List;
+
+/** An HTTP request initiated by the server. */
+public final class PushPromise {
+  private final String method;
+  private final String path;
+  private final List<String> headers;
+  private final MockResponse response;
+
+  public PushPromise(String method, String path, List<String> headers, MockResponse response) {
+    this.method = method;
+    this.path = path;
+    this.headers = headers;
+    this.response = response;
+  }
+
+  public String getMethod() {
+    return method;
+  }
+
+  public String getPath() {
+    return path;
+  }
+
+  public List<String> getHeaders() {
+    return headers;
+  }
+
+  public MockResponse getResponse() {
+    return response;
+  }
+}
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java
index 0f0cb280e6..c9c206c17c 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java
@@ -24,8 +24,7 @@
  * by calling {@link #enqueueResponse(MockResponse)}.
  */
 public class QueueDispatcher extends Dispatcher {
-  protected final BlockingQueue<MockResponse> responseQueue
-      = new LinkedBlockingQueue<MockResponse>();
+  protected final BlockingQueue<MockResponse> responseQueue = new LinkedBlockingQueue<>();
   private MockResponse failFastResponse;
 
   @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
@@ -44,14 +43,11 @@
     return responseQueue.take();
   }
 
-  @Override public SocketPolicy peekSocketPolicy() {
+  @Override public MockResponse peek() {
     MockResponse peek = responseQueue.peek();
-    if (peek == null) {
-      return failFastResponse != null
-          ? failFastResponse.getSocketPolicy()
-          : SocketPolicy.KEEP_OPEN;
-    }
-    return peek.getSocketPolicy();
+    if (peek != null) return peek;
+    if (failFastResponse != null) return failFastResponse;
+    return super.peek();
   }
 
   public void enqueueResponse(MockResponse response) {
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
index aceacd1845..a62c62d2b0 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
@@ -16,6 +16,8 @@
 
 package com.squareup.okhttp.mockwebserver;
 
+import com.squareup.okhttp.TlsVersion;
+import com.squareup.okhttp.internal.Internal;
 import java.io.UnsupportedEncodingException;
 import java.net.Socket;
 import java.util.ArrayList;
@@ -32,7 +34,7 @@
   private final long bodySize;
   private final byte[] body;
   private final int sequenceNumber;
-  private final String sslProtocol;
+  private final TlsVersion tlsVersion;
 
   public RecordedRequest(String requestLine, List<String> headers, List<Integer> chunkSizes,
       long bodySize, byte[] body, int sequenceNumber, Socket socket) {
@@ -42,8 +44,8 @@ public RecordedRequest(String requestLine, List<String> headers, List<Integer> c
     this.bodySize = bodySize;
     this.body = body;
     this.sequenceNumber = sequenceNumber;
-    this.sslProtocol = socket instanceof SSLSocket
-        ? ((SSLSocket) socket).getSession().getProtocol()
+    this.tlsVersion = socket instanceof SSLSocket
+        ? Internal.instance.tlsVersionForJavaName(((SSLSocket) socket).getSession().getProtocol())
         : null;
 
     if (requestLine != null) {
@@ -80,7 +82,8 @@ public String getPath() {
    */
   public String getHeader(String name) {
     name += ":";
-    for (String header : headers) {
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String header = headers.get(i);
       if (name.regionMatches(true, 0, header, 0, name.length())) {
         return header.substring(name.length()).trim();
       }
@@ -90,9 +93,10 @@ public String getHeader(String name) {
 
   /** Returns the headers named {@code name}. */
   public List<String> getHeaders(String name) {
-    List<String> result = new ArrayList<String>();
+    List<String> result = new ArrayList<>();
     name += ":";
-    for (String header : headers) {
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String header = headers.get(i);
       if (name.regionMatches(true, 0, header, 0, name.length())) {
         result.add(header.substring(name.length()).trim());
       }
@@ -139,12 +143,14 @@ public int getSequenceNumber() {
     return sequenceNumber;
   }
 
-  /**
-   * Returns the connection's SSL protocol like {@code TLSv1}, {@code SSLv3},
-   * {@code NONE} or null if the connection doesn't use SSL.
-   */
+  /** @deprecated Use {@link #getTlsVersion()}. */
   public String getSslProtocol() {
-    return sslProtocol;
+    return tlsVersion != null ? tlsVersion.name() : null;
+  }
+
+  /** Returns the connection's TLS version or null if the connection doesn't use SSL. */
+  public TlsVersion getTlsVersion() {
+    return tlsVersion;
   }
 
   @Override public String toString() {
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
index 7912f3a773..e2d5f28481 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
@@ -44,6 +44,12 @@
    */
   DISCONNECT_AT_START,
 
+  /**
+   * Close connection after reading the request but before writing the response.
+   * Use this to simulate late connection pool failures.
+   */
+  DISCONNECT_AFTER_REQUEST,
+
   /** Don't trust the client during the SSL handshake. */
   FAIL_HANDSHAKE,
 
@@ -57,5 +63,11 @@
    * Shutdown the socket output after sending the response. For testing bad
    * behavior.
    */
-  SHUTDOWN_OUTPUT_AT_END
+  SHUTDOWN_OUTPUT_AT_END,
+
+  /**
+   * Don't response to the request but keep the socket open. For testing
+   * read response header timeout issue.
+   */
+  NO_RESPONSE
 }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java
new file mode 100644
index 0000000000..05c94cf1f6
--- /dev/null
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRule.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.mockwebserver.rule;
+
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.IOException;
+import java.net.URL;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.junit.rules.ExternalResource;
+
+/**
+ * Allows you to use {@link MockWebServer} as a JUnit test rule.
+ *
+ * <p>This rule starts {@link MockWebServer} on an available port before your test runs, and shuts
+ * it down after it completes.
+ */
+public class MockWebServerRule extends ExternalResource {
+  private static final Logger logger = Logger.getLogger(MockWebServerRule.class.getName());
+
+  private final MockWebServer server = new MockWebServer();
+  private boolean started;
+
+  @Override protected void before() {
+    if (started) return;
+    started = true;
+    try {
+      server.play();
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override protected void after() {
+    try {
+      server.shutdown();
+    } catch (IOException e) {
+      logger.log(Level.WARNING, "MockWebServer shutdown failed", e);
+    }
+  }
+
+  public int getPort() {
+    if (!started) before();
+    return server.getPort();
+  }
+
+  public int getRequestCount() {
+    return server.getRequestCount();
+  }
+
+  public void enqueue(MockResponse response) {
+    server.enqueue(response);
+  }
+
+  public RecordedRequest takeRequest() throws InterruptedException {
+    return server.takeRequest();
+  }
+
+  public URL getUrl(String path) {
+    return server.getUrl(path);
+  }
+
+  /** For any other functionality, use the {@linkplain MockWebServer} directly. */
+  public MockWebServer get() {
+    return server;
+  }
+}
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
index 22e6a95916..efd34742c5 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
@@ -15,8 +15,6 @@
  */
 package com.squareup.okhttp.mockwebserver;
 
-import junit.framework.TestCase;
-
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.net.URL;
@@ -24,77 +22,78 @@
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
+import org.junit.After;
+import org.junit.Test;
 
-public class CustomDispatcherTest extends TestCase {
-
-    private MockWebServer mockWebServer = new MockWebServer();
+import static org.junit.Assert.assertEquals;
 
-    @Override
-    public void tearDown() throws Exception {
-        mockWebServer.shutdown();
-    }
+public class CustomDispatcherTest {
+  private MockWebServer mockWebServer = new MockWebServer();
 
-    public void testSimpleDispatch() throws Exception {
-        mockWebServer.play();
-        final List<RecordedRequest> requestsMade = new ArrayList<RecordedRequest>();
-        final Dispatcher dispatcher = new Dispatcher() {
-            @Override
-            public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
-                requestsMade.add(request);
-                return new MockResponse();
-            }
-        };
-        assertEquals(0, requestsMade.size());
-        mockWebServer.setDispatcher(dispatcher);
-        final URL url = mockWebServer.getUrl("/");
-        final HttpURLConnection conn = (HttpURLConnection) url.openConnection();
-        conn.getResponseCode(); // Force the connection to hit the "server".
-        // Make sure our dispatcher got the request.
-        assertEquals(1, requestsMade.size());
-    }
+  @After public void tearDown() throws Exception {
+    mockWebServer.shutdown();
+  }
 
-    public void testOutOfOrderResponses() throws Exception {
-        AtomicInteger firstResponseCode = new AtomicInteger();
-        AtomicInteger secondResponseCode = new AtomicInteger();
-        mockWebServer.play();
-        final String secondRequest = "/bar";
-        final String firstRequest = "/foo";
-        final CountDownLatch latch = new CountDownLatch(1);
-        final Dispatcher dispatcher = new Dispatcher() {
-            @Override
-            public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
-                if (request.getPath().equals(firstRequest)) {
-                    latch.await();
-                }
-                return new MockResponse();
-            }
-        };
-        mockWebServer.setDispatcher(dispatcher);
-        final Thread startsFirst = buildRequestThread(firstRequest, firstResponseCode);
-        startsFirst.start();
-        final Thread endsFirst = buildRequestThread(secondRequest, secondResponseCode);
-        endsFirst.start();
-        endsFirst.join();
-        assertEquals(0, firstResponseCode.get()); // First response is still waiting.
-        assertEquals(200, secondResponseCode.get()); // Second response is done.
-        latch.countDown();
-        startsFirst.join();
-        assertEquals(200, firstResponseCode.get()); // And now it's done!
-        assertEquals(200, secondResponseCode.get()); // (Still done).
-    }
+  @Test public void simpleDispatch() throws Exception {
+    mockWebServer.play();
+    final List<RecordedRequest> requestsMade = new ArrayList<>();
+    final Dispatcher dispatcher = new Dispatcher() {
+      @Override
+      public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        requestsMade.add(request);
+        return new MockResponse();
+      }
+    };
+    assertEquals(0, requestsMade.size());
+    mockWebServer.setDispatcher(dispatcher);
+    final URL url = mockWebServer.getUrl("/");
+    final HttpURLConnection conn = (HttpURLConnection) url.openConnection();
+    conn.getResponseCode(); // Force the connection to hit the "server".
+    // Make sure our dispatcher got the request.
+    assertEquals(1, requestsMade.size());
+  }
 
-    private Thread buildRequestThread(final String path, final AtomicInteger responseCode) {
-        return new Thread(new Runnable() {
-            @Override public void run() {
-                final URL url = mockWebServer.getUrl(path);
-                final HttpURLConnection conn;
-                try {
-                    conn = (HttpURLConnection) url.openConnection();
-                    responseCode.set(conn.getResponseCode()); // Force the connection to hit the "server".
-                } catch (IOException e) {
-                }
-            }
-        });
-    }
+  @Test public void outOfOrderResponses() throws Exception {
+    AtomicInteger firstResponseCode = new AtomicInteger();
+    AtomicInteger secondResponseCode = new AtomicInteger();
+    mockWebServer.play();
+    final String secondRequest = "/bar";
+    final String firstRequest = "/foo";
+    final CountDownLatch latch = new CountDownLatch(1);
+    final Dispatcher dispatcher = new Dispatcher() {
+      @Override
+      public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        if (request.getPath().equals(firstRequest)) {
+          latch.await();
+        }
+        return new MockResponse();
+      }
+    };
+    mockWebServer.setDispatcher(dispatcher);
+    final Thread startsFirst = buildRequestThread(firstRequest, firstResponseCode);
+    startsFirst.start();
+    final Thread endsFirst = buildRequestThread(secondRequest, secondResponseCode);
+    endsFirst.start();
+    endsFirst.join();
+    assertEquals(0, firstResponseCode.get()); // First response is still waiting.
+    assertEquals(200, secondResponseCode.get()); // Second response is done.
+    latch.countDown();
+    startsFirst.join();
+    assertEquals(200, firstResponseCode.get()); // And now it's done!
+    assertEquals(200, secondResponseCode.get()); // (Still done).
+  }
 
+  private Thread buildRequestThread(final String path, final AtomicInteger responseCode) {
+    return new Thread(new Runnable() {
+      @Override public void run() {
+        final URL url = mockWebServer.getUrl(path);
+        final HttpURLConnection conn;
+        try {
+          conn = (HttpURLConnection) url.openConnection();
+          responseCode.set(conn.getResponseCode()); // Force the connection to hit the "server".
+        } catch (IOException e) {
+        }
+      }
+    });
+  }
 }
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
index 98efc44971..7c45150ee7 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/MockWebServerTest.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.squareup.okhttp.mockwebserver;
 
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.BufferedReader;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
@@ -28,262 +28,321 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
-import junit.framework.TestCase;
-
-public final class MockWebServerTest extends TestCase {
-
-    private MockWebServer server = new MockWebServer();
-
-    @Override protected void tearDown() throws Exception {
-        server.shutdown();
-        super.tearDown();
-    }
-
-    public void testRecordedRequestAccessors() {
-        List<String> headers = Arrays.asList(
-                "User-Agent: okhttp",
-                "Cookie: s=square",
-                "Cookie: a=android",
-                "X-Whitespace:  left",
-                "X-Whitespace:right  ",
-                "X-Whitespace:  both  "
-        );
-        List<Integer> chunkSizes = Collections.emptyList();
-        byte[] body = {'A', 'B', 'C'};
-        String requestLine = "GET / HTTP/1.1";
-        RecordedRequest request = new RecordedRequest(
-                requestLine, headers, chunkSizes, body.length, body, 0, null);
-        assertEquals("s=square", request.getHeader("cookie"));
-        assertEquals(Arrays.asList("s=square", "a=android"), request.getHeaders("cookie"));
-        assertEquals("left", request.getHeader("x-whitespace"));
-        assertEquals(Arrays.asList("left", "right", "both"), request.getHeaders("x-whitespace"));
-        assertEquals("ABC", request.getUtf8Body());
-    }
-
-    public void testDefaultMockResponse() {
-        MockResponse response = new MockResponse();
-        assertEquals(Arrays.asList("Content-Length: 0"), response.getHeaders());
-        assertEquals("HTTP/1.1 200 OK", response.getStatus());
-    }
-
-    public void testSetBodyAdjustsHeaders() throws IOException {
-        MockResponse response = new MockResponse().setBody("ABC");
-        assertEquals(Arrays.asList("Content-Length: 3"), response.getHeaders());
-        InputStream in = response.getBodyStream();
-        assertEquals('A', in.read());
-        assertEquals('B', in.read());
-        assertEquals('C', in.read());
-        assertEquals(-1, in.read());
-        assertEquals("HTTP/1.1 200 OK", response.getStatus());
-    }
-
-    public void testMockResponseAddHeader() {
-        MockResponse response = new MockResponse()
-                .clearHeaders()
-                .addHeader("Cookie: s=square")
-                .addHeader("Cookie", "a=android");
-        assertEquals(Arrays.asList("Cookie: s=square", "Cookie: a=android"),
-                response.getHeaders());
-    }
-
-    public void testMockResponseSetHeader() {
-        MockResponse response = new MockResponse()
-                .clearHeaders()
-                .addHeader("Cookie: s=square")
-                .addHeader("Cookie: a=android")
-                .addHeader("Cookies: delicious");
-        response.setHeader("cookie", "r=robot");
-        assertEquals(Arrays.asList("Cookies: delicious", "cookie: r=robot"),
-                response.getHeaders());
-    }
-
-    /**
-     * Clients who adhere to <a
-     * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.3">100
-     * Status</a> expect the server to send an interim response with status code
-     * 100 before they send their payload.
-     * 
-     * <h4>Note</h4>
-     * 
-     * JRE 6 only passes this test if
-     * {@code -Dsun.net.http.allowRestrictedHeaders=true} is set.
-     */
-    public void testExpect100ContinueWithBody() throws Exception {
-        server.enqueue(new MockResponse());
-        server.play();
-
-        URL url = server.getUrl("/");
-        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-        connection.setRequestMethod("PUT");
-        connection.setAllowUserInteraction(false);
-        connection.setRequestProperty("Expect", "100-continue");
-        connection.setDoOutput(true);
-        connection.getOutputStream().write("hello".getBytes());
-        assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
-
-        assertEquals(server.getRequestCount(), 1);
-        RecordedRequest request = server.takeRequest();
-        assertEquals(request.getRequestLine(), "PUT / HTTP/1.1");
-        assertEquals("5", request.getHeader("Content-Length"));
-        assertEquals(5, request.getBodySize());
-        assertEquals("hello", new String(request.getBody()));
-        // below fails on JRE 6 unless -Dsun.net.http.allowRestrictedHeaders=true is set
-        assertEquals("100-continue", request.getHeader("Expect"));
-    }
-
-    public void testExpect100ContinueWithNoBody() throws Exception {
-        server.enqueue(new MockResponse());
-        server.play();
-
-        URL url = server.getUrl("/");
-        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-        connection.setRequestMethod("PUT");
-        connection.setAllowUserInteraction(false);
-        connection.setRequestProperty("Expect", "100-continue");
-        connection.setRequestProperty("Content-Length", "0");
-        connection.setDoOutput(true);
-        connection.setFixedLengthStreamingMode(0);
-        assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
-
-        assertEquals(server.getRequestCount(), 1);
-        RecordedRequest request = server.takeRequest();
-        assertEquals(request.getRequestLine(), "PUT / HTTP/1.1");
-        assertEquals("0", request.getHeader("Content-Length"));
-        assertEquals(0, request.getBodySize());
-        // below fails on JRE 6 unless -Dsun.net.http.allowRestrictedHeaders=true is set
-        assertEquals("100-continue", request.getHeader("Expect"));
-    }
-
-    public void testRegularResponse() throws Exception {
-        server.enqueue(new MockResponse().setBody("hello world"));
-        server.play();
-
-        URL url = server.getUrl("/");
-        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-        connection.setRequestProperty("Accept-Language", "en-US");
-        InputStream in = connection.getInputStream();
-        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-        assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
-        assertEquals("hello world", reader.readLine());
-
-        RecordedRequest request = server.takeRequest();
-        assertEquals("GET / HTTP/1.1", request.getRequestLine());
-        assertTrue(request.getHeaders().contains("Accept-Language: en-US"));
-    }
-
-    public void testRedirect() throws Exception {
-        server.play();
-        server.enqueue(new MockResponse()
-                .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-                .addHeader("Location: " + server.getUrl("/new-path"))
-                .setBody("This page has moved!"));
-        server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-        URLConnection connection = server.getUrl("/").openConnection();
-        InputStream in = connection.getInputStream();
-        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-        assertEquals("This is the new location!", reader.readLine());
-
-        RecordedRequest first = server.takeRequest();
-        assertEquals("GET / HTTP/1.1", first.getRequestLine());
-        RecordedRequest redirect = server.takeRequest();
-        assertEquals("GET /new-path HTTP/1.1", redirect.getRequestLine());
-    }
-
-    /**
-     * Test that MockWebServer blocks for a call to enqueue() if a request
-     * is made before a mock response is ready.
-     */
-    public void testDispatchBlocksWaitingForEnqueue() throws Exception {
-        server.play();
-
-        new Thread() {
-            @Override public void run() {
-                try {
-                    Thread.sleep(1000);
-                } catch (InterruptedException ignored) {
-                }
-                server.enqueue(new MockResponse().setBody("enqueued in the background"));
-            }
-        }.start();
-
-        URLConnection connection = server.getUrl("/").openConnection();
-        InputStream in = connection.getInputStream();
-        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-        assertEquals("enqueued in the background", reader.readLine());
-    }
-
-    public void testNonHexadecimalChunkSize() throws Exception {
-        server.enqueue(new MockResponse()
-                .setBody("G\r\nxxxxxxxxxxxxxxxx\r\n0\r\n\r\n")
-                .clearHeaders()
-                .addHeader("Transfer-encoding: chunked"));
-        server.play();
-
-        URLConnection connection = server.getUrl("/").openConnection();
-        InputStream in = connection.getInputStream();
+import java.util.concurrent.TimeUnit;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class MockWebServerTest {
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  @Test public void recordedRequestAccessors() {
+    List<String> headers = Arrays.asList(
+        "User-Agent: okhttp",
+        "Cookie: s=square",
+        "Cookie: a=android",
+        "X-Whitespace:  left",
+        "X-Whitespace:right  ",
+        "X-Whitespace:  both  "
+    );
+    List<Integer> chunkSizes = Collections.emptyList();
+    byte[] body = {'A', 'B', 'C'};
+    String requestLine = "GET / HTTP/1.1";
+    RecordedRequest request = new RecordedRequest(
+        requestLine, headers, chunkSizes, body.length, body, 0, null);
+    assertEquals("s=square", request.getHeader("cookie"));
+    assertEquals(Arrays.asList("s=square", "a=android"), request.getHeaders("cookie"));
+    assertEquals("left", request.getHeader("x-whitespace"));
+    assertEquals(Arrays.asList("left", "right", "both"), request.getHeaders("x-whitespace"));
+    assertEquals("ABC", request.getUtf8Body());
+  }
+
+  @Test public void defaultMockResponse() {
+    MockResponse response = new MockResponse();
+    assertEquals(Arrays.asList("Content-Length: 0"), response.getHeaders());
+    assertEquals("HTTP/1.1 200 OK", response.getStatus());
+  }
+
+  @Test public void setBodyAdjustsHeaders() throws IOException {
+    MockResponse response = new MockResponse().setBody("ABC");
+    assertEquals(Arrays.asList("Content-Length: 3"), response.getHeaders());
+    InputStream in = response.getBodyStream();
+    assertEquals('A', in.read());
+    assertEquals('B', in.read());
+    assertEquals('C', in.read());
+    assertEquals(-1, in.read());
+    assertEquals("HTTP/1.1 200 OK", response.getStatus());
+  }
+
+  @Test public void mockResponseAddHeader() {
+    MockResponse response = new MockResponse()
+        .clearHeaders()
+        .addHeader("Cookie: s=square")
+        .addHeader("Cookie", "a=android");
+    assertEquals(Arrays.asList("Cookie: s=square", "Cookie: a=android"), response.getHeaders());
+  }
+
+  @Test public void mockResponseSetHeader() {
+    MockResponse response = new MockResponse()
+        .clearHeaders()
+        .addHeader("Cookie: s=square")
+        .addHeader("Cookie: a=android")
+        .addHeader("Cookies: delicious");
+    response.setHeader("cookie", "r=robot");
+    assertEquals(Arrays.asList("Cookies: delicious", "cookie: r=robot"), response.getHeaders());
+  }
+
+  /**
+   * Clients who adhere to <a
+   * href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.3">100
+   * Status</a> expect the server to send an interim response with status code
+   * 100 before they send their payload.
+   *
+   * <h4>Note</h4>
+   *
+   * JRE 6 only passes this test if
+   * {@code -Dsun.net.http.allowRestrictedHeaders=true} is set.
+   */
+  @Test public void expect100ContinueWithBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    URL url = server.getUrl("/");
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    connection.setRequestMethod("PUT");
+    connection.setAllowUserInteraction(false);
+    connection.setRequestProperty("Expect", "100-continue");
+    connection.setDoOutput(true);
+    connection.getOutputStream().write("hello".getBytes());
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+
+    assertEquals(server.getRequestCount(), 1);
+    RecordedRequest request = server.takeRequest();
+    assertEquals(request.getRequestLine(), "PUT / HTTP/1.1");
+    assertEquals("5", request.getHeader("Content-Length"));
+    assertEquals(5, request.getBodySize());
+    assertEquals("hello", new String(request.getBody()));
+    // below fails on JRE 6 unless -Dsun.net.http.allowRestrictedHeaders=true is set
+    assertEquals("100-continue", request.getHeader("Expect"));
+  }
+
+  @Test public void expect100ContinueWithNoBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    URL url = server.getUrl("/");
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    connection.setRequestMethod("PUT");
+    connection.setAllowUserInteraction(false);
+    connection.setRequestProperty("Expect", "100-continue");
+    connection.setRequestProperty("Content-Length", "0");
+    connection.setDoOutput(true);
+    connection.setFixedLengthStreamingMode(0);
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+
+    assertEquals(server.getRequestCount(), 1);
+    RecordedRequest request = server.takeRequest();
+    assertEquals(request.getRequestLine(), "PUT / HTTP/1.1");
+    assertEquals("0", request.getHeader("Content-Length"));
+    assertEquals(0, request.getBodySize());
+    // below fails on JRE 6 unless -Dsun.net.http.allowRestrictedHeaders=true is set
+    assertEquals("100-continue", request.getHeader("Expect"));
+  }
+
+  @Test public void regularResponse() throws Exception {
+    server.enqueue(new MockResponse().setBody("hello world"));
+
+    URL url = server.getUrl("/");
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    connection.setRequestProperty("Accept-Language", "en-US");
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+    assertEquals("hello world", reader.readLine());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET / HTTP/1.1", request.getRequestLine());
+    assertTrue(request.getHeaders().contains("Accept-Language: en-US"));
+  }
+
+  @Test public void redirect() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server.getUrl("/new-path"))
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("This is the new location!"));
+
+    URLConnection connection = server.getUrl("/").openConnection();
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals("This is the new location!", reader.readLine());
+
+    RecordedRequest first = server.takeRequest();
+    assertEquals("GET / HTTP/1.1", first.getRequestLine());
+    RecordedRequest redirect = server.takeRequest();
+    assertEquals("GET /new-path HTTP/1.1", redirect.getRequestLine());
+  }
+
+  /**
+   * Test that MockWebServer blocks for a call to enqueue() if a request
+   * is made before a mock response is ready.
+   */
+  @Test public void dispatchBlocksWaitingForEnqueue() throws Exception {
+    new Thread() {
+      @Override public void run() {
         try {
-            in.read();
-            fail();
-        } catch (IOException expected) {
+          Thread.sleep(1000);
+        } catch (InterruptedException ignored) {
         }
+        server.enqueue(new MockResponse().setBody("enqueued in the background"));
+      }
+    }.start();
+
+    URLConnection connection = server.getUrl("/").openConnection();
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals("enqueued in the background", reader.readLine());
+  }
+
+  @Test public void nonHexadecimalChunkSize() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("G\r\nxxxxxxxxxxxxxxxx\r\n0\r\n\r\n")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked"));
+
+    URLConnection connection = server.getUrl("/").openConnection();
+    InputStream in = connection.getInputStream();
+    try {
+      in.read();
+      fail();
+    } catch (IOException expected) {
     }
-
-    public void testResponseTimeout() throws Exception {
-        server.enqueue(new MockResponse()
-                .setBody("ABC")
-                .clearHeaders()
-                .addHeader("Content-Length: 4"));
-        server.enqueue(new MockResponse()
-                .setBody("DEF"));
-        server.play();
-
-        URLConnection urlConnection = server.getUrl("/").openConnection();
-        urlConnection.setReadTimeout(1000);
-        InputStream in = urlConnection.getInputStream();
-        assertEquals('A', in.read());
-        assertEquals('B', in.read());
-        assertEquals('C', in.read());
-        try {
-            in.read(); // if Content-Length was accurate, this would return -1 immediately
-            fail();
-        } catch (SocketTimeoutException expected) {
-        }
-
-        URLConnection urlConnection2 = server.getUrl("/").openConnection();
-        InputStream in2 = urlConnection2.getInputStream();
-        assertEquals('D', in2.read());
-        assertEquals('E', in2.read());
-        assertEquals('F', in2.read());
-        assertEquals(-1, in2.read());
-
-        assertEquals(0, server.takeRequest().getSequenceNumber());
-        assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void responseTimeout() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABC")
+        .clearHeaders()
+        .addHeader("Content-Length: 4"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+
+    URLConnection urlConnection = server.getUrl("/").openConnection();
+    urlConnection.setReadTimeout(1000);
+    InputStream in = urlConnection.getInputStream();
+    assertEquals('A', in.read());
+    assertEquals('B', in.read());
+    assertEquals('C', in.read());
+    try {
+      in.read(); // if Content-Length was accurate, this would return -1 immediately
+      fail();
+    } catch (SocketTimeoutException expected) {
     }
 
-    public void testDisconnectAtStart() throws Exception {
-        server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
-        server.enqueue(new MockResponse()); // The jdk's HttpUrlConnection is a bastard.
-        server.enqueue(new MockResponse());
-        server.play();
-        try {
-            server.getUrl("/a").openConnection().getInputStream();
-        } catch (IOException e) {
-            // Expected.
-        }
-        server.getUrl("/b").openConnection().getInputStream(); // Should succeed.
-    }
-
-    public void testStreamingResponseBody() throws Exception {
-        InputStream responseBody = new ByteArrayInputStream("ABC".getBytes("UTF-8"));
-        server.enqueue(new MockResponse().setBody(responseBody, 3));
-        server.play();
-
-        InputStream in = server.getUrl("/").openConnection().getInputStream();
-        assertEquals('A', in.read());
-        assertEquals('B', in.read());
-        assertEquals('C', in.read());
-
-        assertEquals(-1, responseBody.read()); // The body is exhausted.
+    URLConnection urlConnection2 = server.getUrl("/").openConnection();
+    InputStream in2 = urlConnection2.getInputStream();
+    assertEquals('D', in2.read());
+    assertEquals('E', in2.read());
+    assertEquals('F', in2.read());
+    assertEquals(-1, in2.read());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void disconnectAtStart() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+    server.enqueue(new MockResponse()); // The jdk's HttpUrlConnection is a bastard.
+    server.enqueue(new MockResponse());
+    try {
+      server.getUrl("/a").openConnection().getInputStream();
+    } catch (IOException expected) {
     }
+    server.getUrl("/b").openConnection().getInputStream(); // Should succeed.
+  }
+
+  @Test public void streamingResponseBody() throws Exception {
+    InputStream responseBody = new ByteArrayInputStream("ABC".getBytes("UTF-8"));
+    server.enqueue(new MockResponse().setBody(responseBody, 3));
+
+    InputStream in = server.getUrl("/").openConnection().getInputStream();
+    assertEquals('A', in.read());
+    assertEquals('B', in.read());
+    assertEquals('C', in.read());
+
+    assertEquals(-1, responseBody.read()); // The body is exhausted.
+  }
+
+  /**
+   * Throttle the request body by sleeping 500ms after every 3 bytes. With a
+   * 6-byte request, this should yield one sleep for a total delay of 500ms.
+   */
+  @Test public void throttleRequest() throws Exception {
+    server.enqueue(new MockResponse()
+        .throttleBody(3, 500, TimeUnit.MILLISECONDS));
+
+    long startNanos = System.nanoTime();
+    URLConnection connection = server.getUrl("/").openConnection();
+    connection.setDoOutput(true);
+    connection.getOutputStream().write("ABCDEF".getBytes("UTF-8"));
+    InputStream in = connection.getInputStream();
+    assertEquals(-1, in.read());
+    long elapsedNanos = System.nanoTime() - startNanos;
+    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
+
+    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
+    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
+  }
+
+  /**
+   * Throttle the response body by sleeping 500ms after every 3 bytes. With a
+   * 6-byte response, this should yield one sleep for a total delay of 500ms.
+   */
+  @Test public void throttleResponse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABCDEF")
+        .throttleBody(3, 500, TimeUnit.MILLISECONDS));
+
+    long startNanos = System.nanoTime();
+    URLConnection connection = server.getUrl("/").openConnection();
+    InputStream in = connection.getInputStream();
+    assertEquals('A', in.read());
+    assertEquals('B', in.read());
+    assertEquals('C', in.read());
+    assertEquals('D', in.read());
+    assertEquals('E', in.read());
+    assertEquals('F', in.read());
+    assertEquals(-1, in.read());
+    long elapsedNanos = System.nanoTime() - startNanos;
+    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
+
+    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
+    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
+  }
+
+  /**
+   * Delay the response body by sleeping 1000ms.
+   */
+  @Test public void delayResponse() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("ABCDEF")
+        .setBodyDelayTimeMs(1000));
+
+    long startNanos = System.nanoTime();
+    URLConnection connection = server.getUrl("/").openConnection();
+    InputStream in = connection.getInputStream();
+    assertEquals('A', in.read());
+    assertEquals('B', in.read());
+    assertEquals('C', in.read());
+    assertEquals('D', in.read());
+    assertEquals('E', in.read());
+    assertEquals('F', in.read());
+    assertEquals(-1, in.read());
+    long elapsedNanos = System.nanoTime() - startNanos;
+    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
+
+    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 1000);
+    assertTrue(String.format("Request + Response: %sms", elapsedMillis), elapsedMillis <= 1100);
+  }
 }
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java
new file mode 100644
index 0000000000..43ceebc6bb
--- /dev/null
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.mockwebserver.rule;
+
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.net.ConnectException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import org.junit.After;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class MockWebServerRuleTest {
+
+  private MockWebServerRule server = new MockWebServerRule();
+
+  @After public void tearDown() {
+    server.after();
+  }
+
+  @Test public void whenRuleCreatedPortIsAvailable() throws IOException {
+    assertTrue(server.getPort() > 0);
+  }
+
+  @Test public void differentRulesGetDifferentPorts() throws IOException {
+    assertNotEquals(server.getPort(), new MockWebServerRule().getPort());
+  }
+
+  @Test public void beforePlaysServer() throws Exception {
+    server.before();
+    assertEquals(server.getPort(), server.get().getPort());
+    server.getUrl("/").openConnection().connect();
+  }
+
+  @Test public void afterStopsServer() throws Exception {
+    server.before();
+    server.after();
+
+    try {
+      server.getUrl("/").openConnection().connect();
+      fail();
+    } catch (ConnectException e) {
+    }
+  }
+
+  @Test public void typicalUsage() throws Exception {
+    server.before(); // Implicitly called when @Rule.
+
+    server.enqueue(new MockResponse().setBody("hello world"));
+
+    URL url = server.getUrl("/aaa");
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals("hello world", reader.readLine());
+
+    assertEquals(1, server.getRequestCount());
+    assertEquals("GET /aaa HTTP/1.1", server.takeRequest().getRequestLine());
+
+    server.after(); // Implicitly called when @Rule.
+  }
+}
+
diff --git a/okcurl/README.md b/okcurl/README.md
new file mode 100644
index 0000000000..cea5be4064
--- /dev/null
+++ b/okcurl/README.md
@@ -0,0 +1,7 @@
+OkCurl
+======
+
+_A curl for the next-generation web._
+
+OkCurl is an OkHttp-backed curl clone which allows you to test OkHttp's HTTP engine (including
+SPDY and HTTP/2) against web servers.
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
new file mode 100644
index 0000000000..047983440b
--- /dev/null
+++ b/okcurl/pom.xml
@@ -0,0 +1,90 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.3.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okcurl</artifactId>
+  <name>OkCurl</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.bouncycastle</groupId>
+      <artifactId>bcprov-jdk15on</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>io.airlift</groupId>
+      <artifactId>airline</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <resources>
+      <resource>
+        <directory>src/main/resources</directory>
+        <filtering>true</filtering>
+      </resource>
+    </resources>
+
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <configuration>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
+          <archive>
+            <manifest>
+              <mainClass>com.squareup.okhttp.curl.Main</mainClass>
+            </manifest>
+          </archive>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>org.skife.maven</groupId>
+        <artifactId>really-executable-jar-maven-plugin</artifactId>
+        <version>1.1.0</version>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>really-executable-jar</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <flags>-Xbootclasspath/p:$0</flags>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
new file mode 100644
index 0000000000..e1054c9b1d
--- /dev/null
+++ b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
@@ -0,0 +1,280 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.curl;
+
+import com.google.common.base.Joiner;
+import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.http.StatusLine;
+import com.squareup.okhttp.internal.spdy.Http20Draft16;
+
+import io.airlift.command.Arguments;
+import io.airlift.command.Command;
+import io.airlift.command.HelpOption;
+import io.airlift.command.Option;
+import io.airlift.command.SingleCommand;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+import java.util.List;
+import java.util.Properties;
+import java.util.logging.ConsoleHandler;
+import java.util.logging.Level;
+import java.util.logging.LogRecord;
+import java.util.logging.Logger;
+import java.util.logging.SimpleFormatter;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+import okio.Okio;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+@Command(name = Main.NAME, description = "A curl for the next-generation web.")
+public class Main extends HelpOption implements Runnable {
+  static final String NAME = "okcurl";
+  static final int DEFAULT_TIMEOUT = -1;
+
+  static Main fromArgs(String... args) {
+    return SingleCommand.singleCommand(Main.class).parse(args);
+  }
+
+  public static void main(String... args) {
+    fromArgs(args).run();
+  }
+
+  private static String versionString() {
+    try {
+      Properties prop = new Properties();
+      InputStream in = Main.class.getResourceAsStream("/okcurl-version.properties");
+      prop.load(in);
+      in.close();
+      return prop.getProperty("version");
+    } catch (IOException e) {
+      throw new AssertionError("Could not load okcurl-version.properties.");
+    }
+  }
+
+  private static String protocols() {
+    return Joiner.on(", ").join(Protocol.values());
+  }
+
+  @Option(name = { "-X", "--request" }, description = "Specify request command to use")
+  public String method;
+
+  @Option(name = { "-d", "--data" }, description = "HTTP POST data")
+  public String data;
+
+  @Option(name = { "-H", "--header" }, description = "Custom header to pass to server")
+  public List<String> headers;
+
+  @Option(name = { "-A", "--user-agent" }, description = "User-Agent to send to server")
+  public String userAgent = NAME + "/" + versionString();
+
+  @Option(name = "--connect-timeout", description = "Maximum time allowed for connection (seconds)")
+  public int connectTimeout = DEFAULT_TIMEOUT;
+
+  @Option(name = "--read-timeout", description = "Maximum time allowed for reading data (seconds)")
+  public int readTimeout = DEFAULT_TIMEOUT;
+
+  @Option(name = { "-L", "--location" }, description = "Follow redirects")
+  public boolean followRedirects;
+
+  @Option(name = { "-k", "--insecure" },
+      description = "Allow connections to SSL sites without certs")
+  public boolean allowInsecure;
+
+  @Option(name = { "-i", "--include" }, description = "Include protocol headers in the output")
+  public boolean showHeaders;
+
+  @Option(name = "--frames", description = "Log HTTP/2 frames to STDERR")
+  public boolean showHttp2Frames;
+
+  @Option(name = { "-e", "--referer" }, description = "Referer URL")
+  public String referer;
+
+  @Option(name = { "-V", "--version" }, description = "Show version number and quit")
+  public boolean version;
+
+  @Arguments(title = "url", description = "Remote resource URL")
+  public String url;
+
+  private OkHttpClient client;
+
+  @Override public void run() {
+    if (showHelpIfRequested()) {
+      return;
+    }
+    if (version) {
+      System.out.println(NAME + " " + versionString());
+      System.out.println("Protocols: " + protocols());
+      return;
+    }
+
+    if (showHttp2Frames) {
+      enableHttp2FrameLogging();
+    }
+
+    client = createClient();
+    Request request = createRequest();
+    try {
+      Response response = client.newCall(request).execute();
+      if (showHeaders) {
+        System.out.println(StatusLine.get(response));
+        Headers headers = response.headers();
+        for (int i = 0, size = headers.size(); i < size; i++) {
+          System.out.println(headers.name(i) + ": " + headers.value(i));
+        }
+        System.out.println();
+      }
+
+      response.body().source().readAll(Okio.sink(System.out));
+      response.body().close();
+      System.out.flush();
+    } catch (IOException e) {
+      e.printStackTrace();
+    } finally {
+      close();
+    }
+  }
+
+  private OkHttpClient createClient() {
+    OkHttpClient client = new OkHttpClient();
+    client.setFollowSslRedirects(followRedirects);
+    if (connectTimeout != DEFAULT_TIMEOUT) {
+      client.setConnectTimeout(connectTimeout, SECONDS);
+    }
+    if (readTimeout != DEFAULT_TIMEOUT) {
+      client.setReadTimeout(readTimeout, SECONDS);
+    }
+    if (allowInsecure) {
+      client.setSslSocketFactory(createInsecureSslSocketFactory());
+      client.setHostnameVerifier(createInsecureHostnameVerifier());
+    }
+    // If we don't set this reference, there's no way to clean shutdown persistent connections.
+    client.setConnectionPool(ConnectionPool.getDefault());
+    return client;
+  }
+
+  private String getRequestMethod() {
+    if (method != null) {
+      return method;
+    }
+    if (data != null) {
+      return "POST";
+    }
+    return "GET";
+  }
+
+  private RequestBody getRequestBody() {
+    if (data == null) {
+      return null;
+    }
+    String bodyData = data;
+
+    String mimeType = "application/x-form-urlencoded";
+    if (headers != null) {
+      for (String header : headers) {
+        String[] parts = header.split(":", -1);
+        if ("Content-Type".equalsIgnoreCase(parts[0])) {
+          mimeType = parts[1].trim();
+          headers.remove(header);
+          break;
+        }
+      }
+    }
+
+    return RequestBody.create(MediaType.parse(mimeType), bodyData);
+  }
+
+  Request createRequest() {
+    Request.Builder request = new Request.Builder();
+
+    request.url(url);
+    request.method(getRequestMethod(), getRequestBody());
+
+    if (headers != null) {
+      for (String header : headers) {
+        String[] parts = header.split(":", 2);
+        request.header(parts[0], parts[1]);
+      }
+    }
+    if (referer != null) {
+      request.header("Referer", referer);
+    }
+    request.header("User-Agent", userAgent);
+
+    return request.build();
+  }
+
+  private void close() {
+    client.getConnectionPool().evictAll(); // Close any persistent connections.
+  }
+
+  private static SSLSocketFactory createInsecureSslSocketFactory() {
+    try {
+      SSLContext context = SSLContext.getInstance("TLS");
+      TrustManager permissive = new X509TrustManager() {
+        @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
+            throws CertificateException {
+        }
+
+        @Override public void checkServerTrusted(X509Certificate[] chain, String authType)
+            throws CertificateException {
+        }
+
+        @Override public X509Certificate[] getAcceptedIssuers() {
+          return null;
+        }
+      };
+      context.init(null, new TrustManager[] { permissive }, null);
+      return context.getSocketFactory();
+    } catch (Exception e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  private static HostnameVerifier createInsecureHostnameVerifier() {
+    return new HostnameVerifier() {
+      @Override public boolean verify(String s, SSLSession sslSession) {
+        return true;
+      }
+    };
+  }
+
+  private static void enableHttp2FrameLogging() {
+    Logger logger = Logger.getLogger(Http20Draft16.class.getName() + "$FrameLogger");
+    logger.setLevel(Level.FINE);
+    ConsoleHandler handler = new ConsoleHandler();
+    handler.setLevel(Level.FINE);
+    handler.setFormatter(new SimpleFormatter() {
+      @Override public String format(LogRecord record) {
+        return String.format("%s%n", record.getMessage());
+      }
+    });
+    logger.addHandler(handler);
+  }
+}
diff --git a/okcurl/src/main/resources/okcurl-version.properties b/okcurl/src/main/resources/okcurl-version.properties
new file mode 100644
index 0000000000..defbd48204
--- /dev/null
+++ b/okcurl/src/main/resources/okcurl-version.properties
@@ -0,0 +1 @@
+version=${project.version}
diff --git a/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java b/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
new file mode 100644
index 0000000000..0cc065c6c0
--- /dev/null
+++ b/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.curl;
+
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+import okio.Buffer;
+import org.junit.Test;
+
+import static com.squareup.okhttp.curl.Main.fromArgs;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+public class MainTest {
+  @Test public void simple() {
+    Request request = fromArgs("http://example.com").createRequest();
+    assertEquals("GET", request.method());
+    assertEquals("http://example.com", request.urlString());
+    assertNull(request.body());
+  }
+
+  @Test public void put() throws IOException {
+    Request request = fromArgs("-X", "PUT", "http://example.com").createRequest();
+    assertEquals("PUT", request.method());
+    assertEquals("http://example.com", request.urlString());
+    assertEquals(0, request.body().contentLength());
+  }
+
+  @Test public void dataPost() {
+    Request request = fromArgs("-d", "foo", "http://example.com").createRequest();
+    RequestBody body = request.body();
+    assertEquals("POST", request.method());
+    assertEquals("http://example.com", request.urlString());
+    assertEquals("application/x-form-urlencoded; charset=utf-8", body.contentType().toString());
+    assertEquals("foo", bodyAsString(body));
+  }
+
+  @Test public void dataPut() {
+    Request request = fromArgs("-d", "foo", "-X", "PUT", "http://example.com").createRequest();
+    RequestBody body = request.body();
+    assertEquals("PUT", request.method());
+    assertEquals("http://example.com", request.urlString());
+    assertEquals("application/x-form-urlencoded; charset=utf-8", body.contentType().toString());
+    assertEquals("foo", bodyAsString(body));
+  }
+
+  @Test public void contentTypeHeader() {
+    Request request = fromArgs("-d", "foo", "-H", "Content-Type: application/json",
+        "http://example.com").createRequest();
+    RequestBody body = request.body();
+    assertEquals("POST", request.method());
+    assertEquals("http://example.com", request.urlString());
+    assertEquals("application/json; charset=utf-8", body.contentType().toString());
+    assertEquals("foo", bodyAsString(body));
+  }
+
+  @Test public void referer() {
+    Request request = fromArgs("-e", "foo", "http://example.com").createRequest();
+    assertEquals("GET", request.method());
+    assertEquals("http://example.com", request.urlString());
+    assertEquals("foo", request.header("Referer"));
+    assertNull(request.body());
+  }
+
+  @Test public void userAgent() {
+    Request request = fromArgs("-A", "foo", "http://example.com").createRequest();
+    assertEquals("GET", request.method());
+    assertEquals("http://example.com", request.urlString());
+    assertEquals("foo", request.header("User-Agent"));
+    assertNull(request.body());
+  }
+
+  @Test public void headerSplitWithDate() {
+    Request request = fromArgs("-H", "If-Modified-Since: Mon, 18 Aug 2014 15:16:06 GMT",
+        "http://example.com").createRequest();
+    assertEquals("Mon, 18 Aug 2014 15:16:06 GMT", request.header("If-Modified-Since"));
+  }
+
+  private static String bodyAsString(RequestBody body) {
+    try {
+      Buffer buffer = new Buffer();
+      body.writeTo(buffer);
+      return buffer.readString(body.contentType().charset());
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index f8fa6a4a2d..4031304958 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
@@ -18,12 +18,6 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
     <dependency>
       <groupId>org.apache.httpcomponents</groupId>
       <artifactId>httpclient</artifactId>
@@ -35,5 +29,27 @@
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+            <link>http://hc.apache.org/httpcomponents-client-4.3.x/httpclient/apidocs/</link>
+            <link>https://hc.apache.org/httpcomponents-core-4.3.x/httpcore/apidocs/</link>
+          </links>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/HttpEntityBody.java b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/HttpEntityBody.java
new file mode 100644
index 0000000000..fd7884cd80
--- /dev/null
+++ b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/HttpEntityBody.java
@@ -0,0 +1,41 @@
+package com.squareup.okhttp.apache;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import java.io.IOException;
+import okio.BufferedSink;
+import org.apache.http.HttpEntity;
+
+/** Adapts an {@link HttpEntity} to OkHttp's {@link RequestBody}. */
+final class HttpEntityBody extends RequestBody {
+  private static final MediaType DEFAULT_MEDIA_TYPE = MediaType.parse("application/octet-stream");
+
+  private final HttpEntity entity;
+  private final MediaType mediaType;
+
+  HttpEntityBody(HttpEntity entity, String contentTypeHeader) {
+    this.entity = entity;
+
+    if (contentTypeHeader != null) {
+      mediaType = MediaType.parse(contentTypeHeader);
+    } else if (entity.getContentType() != null) {
+      mediaType = MediaType.parse(entity.getContentType().getValue());
+    } else {
+      // Apache is forgiving and lets you skip specifying a content type with an entity. OkHttp is
+      // not forgiving so we fall back to a generic type if it's missing.
+      mediaType = DEFAULT_MEDIA_TYPE;
+    }
+  }
+
+  @Override public long contentLength() {
+    return entity.getContentLength();
+  }
+
+  @Override public MediaType contentType() {
+    return mediaType;
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    entity.writeTo(sink.outputStream());
+  }
+}
diff --git a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
index 2c40f9aa8c..e1b1dd9cbc 100644
--- a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
+++ b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
@@ -1,13 +1,15 @@
 // Copyright 2013 Square, Inc.
 package com.squareup.okhttp.apache;
 
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
-import java.net.URL;
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpEntityEnclosingRequest;
@@ -21,7 +23,6 @@
 import org.apache.http.conn.ClientConnectionManager;
 import org.apache.http.conn.params.ConnRouteParams;
 import org.apache.http.entity.InputStreamEntity;
-import org.apache.http.message.BasicHeader;
 import org.apache.http.message.BasicHttpResponse;
 import org.apache.http.params.AbstractHttpParams;
 import org.apache.http.params.HttpParams;
@@ -37,8 +38,65 @@
  * API. This includes the keep-alive strategy, cookie store, credentials provider, route planner
  * and others.
  */
-public class OkApacheClient implements HttpClient {
-  protected final OkHttpClient client;
+public final class OkApacheClient implements HttpClient {
+  private static Request transformRequest(HttpRequest request) {
+    Request.Builder builder = new Request.Builder();
+
+    RequestLine requestLine = request.getRequestLine();
+    String method = requestLine.getMethod();
+    builder.url(requestLine.getUri());
+
+    String contentType = null;
+    for (Header header : request.getAllHeaders()) {
+      String name = header.getName();
+      if ("Content-Type".equals(name)) {
+        contentType = header.getValue();
+      } else {
+        builder.header(name, header.getValue());
+      }
+    }
+
+    RequestBody body = null;
+    if (request instanceof HttpEntityEnclosingRequest) {
+      HttpEntity entity = ((HttpEntityEnclosingRequest) request).getEntity();
+      if (entity != null) {
+        // Wrap the entity in a custom Body which takes care of the content, length, and type.
+        body = new HttpEntityBody(entity, contentType);
+
+        Header encoding = entity.getContentEncoding();
+        if (encoding != null) {
+          builder.header(encoding.getName(), encoding.getValue());
+        }
+      }
+    }
+    builder.method(method, body);
+
+    return builder.build();
+  }
+
+  private static HttpResponse transformResponse(Response response) {
+    int code = response.code();
+    String message = response.message();
+    BasicHttpResponse httpResponse = new BasicHttpResponse(HTTP_1_1, code, message);
+
+    ResponseBody body = response.body();
+    InputStreamEntity entity = new InputStreamEntity(body.byteStream(), body.contentLength());
+    httpResponse.setEntity(entity);
+
+    Headers headers = response.headers();
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String name = headers.name(i);
+      String value = headers.value(i);
+      httpResponse.addHeader(name, value);
+      if ("Content-Type".equalsIgnoreCase(name)) {
+        entity.setContentType(value);
+      } else if ("Content-Encoding".equalsIgnoreCase(name)) {
+        entity.setContentEncoding(value);
+      }
+    }
+
+    return httpResponse;
+  }
 
   private final HttpParams params = new AbstractHttpParams() {
     @Override public Object getParameter(String name) {
@@ -75,6 +133,8 @@
     }
   };
 
+  private final OkHttpClient client;
+
   public OkApacheClient() {
     this(new OkHttpClient());
   }
@@ -83,14 +143,6 @@ public OkApacheClient(OkHttpClient client) {
     this.client = client;
   }
 
-  /**
-   * Returns a new HttpURLConnection customized for this application. Subclasses should override
-   * this to customize the connection.
-   */
-  protected HttpURLConnection openConnection(URL url) {
-    return client.open(url);
-  }
-
   @Override public HttpParams getParams() {
     return params;
   }
@@ -114,66 +166,9 @@ protected HttpURLConnection openConnection(URL url) {
 
   @Override public HttpResponse execute(HttpHost host, HttpRequest request, HttpContext context)
       throws IOException {
-    // Prepare the request headers.
-    RequestLine requestLine = request.getRequestLine();
-    URL url = new URL(requestLine.getUri());
-    HttpURLConnection connection = openConnection(url);
-    connection.setRequestMethod(requestLine.getMethod());
-    for (Header header : request.getAllHeaders()) {
-      connection.addRequestProperty(header.getName(), header.getValue());
-    }
-
-    // Stream the request body.
-    if (request instanceof HttpEntityEnclosingRequest) {
-      HttpEntity entity = ((HttpEntityEnclosingRequest) request).getEntity();
-      if (entity != null) {
-        connection.setDoOutput(true);
-        Header type = entity.getContentType();
-        if (type != null) {
-          connection.addRequestProperty(type.getName(), type.getValue());
-        }
-        Header encoding = entity.getContentEncoding();
-        if (encoding != null) {
-          connection.addRequestProperty(encoding.getName(), encoding.getValue());
-        }
-        if (entity.isChunked() || entity.getContentLength() < 0) {
-          connection.setChunkedStreamingMode(0);
-        } else if (entity.getContentLength() <= 8192) {
-          // Buffer short, fixed-length request bodies. This costs memory, but permits the request
-          // to be transparently retried if there is a connection failure.
-          connection.addRequestProperty("Content-Length", Long.toString(entity.getContentLength()));
-        } else {
-          connection.setFixedLengthStreamingMode((int) entity.getContentLength());
-        }
-        entity.writeTo(connection.getOutputStream());
-      }
-    }
-
-    // Read the response headers.
-    int responseCode = connection.getResponseCode();
-    String message = connection.getResponseMessage();
-    BasicHttpResponse response = new BasicHttpResponse(HTTP_1_1, responseCode, message);
-    // Get the response body ready to stream.
-    InputStream responseBody =
-        responseCode < HttpURLConnection.HTTP_BAD_REQUEST ? connection.getInputStream()
-            : connection.getErrorStream();
-    InputStreamEntity entity = new InputStreamEntity(responseBody, connection.getContentLength());
-    for (int i = 0; true; i++) {
-      String name = connection.getHeaderFieldKey(i);
-      if (name == null) {
-        break;
-      }
-      BasicHeader header = new BasicHeader(name, connection.getHeaderField(i));
-      response.addHeader(header);
-      if (name.equalsIgnoreCase("Content-Type")) {
-          entity.setContentType(header);
-      } else if (name.equalsIgnoreCase("Content-Encoding")) {
-          entity.setContentEncoding(header);
-      }
-    }
-    response.setEntity(entity);
-
-    return response;
+    Request okRequest = transformRequest(request);
+    Response okResponse = client.newCall(okRequest).execute();
+    return transformResponse(okResponse);
   }
 
   @Override public <T> T execute(HttpUriRequest request, ResponseHandler<? extends T> handler)
diff --git a/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java b/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
index 766e69c60e..0f1d092b8b 100644
--- a/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
+++ b/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
@@ -4,25 +4,27 @@
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStreamWriter;
-import java.nio.charset.Charset;
 import java.util.Arrays;
 import java.util.zip.GZIPInputStream;
-import java.util.zip.GZIPOutputStream;
+import okio.Buffer;
+import okio.GzipSink;
+import okio.Okio;
 import org.apache.http.Header;
+import org.apache.http.HttpEntity;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.entity.ByteArrayEntity;
 import org.apache.http.entity.InputStreamEntity;
+import org.apache.http.entity.StringEntity;
 import org.apache.http.util.EntityUtils;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
+import static com.squareup.okhttp.internal.Util.UTF_8;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
@@ -57,7 +59,7 @@
 
     HttpGet request = new HttpGet(server.getUrl("/").toURI());
     HttpResponse response = client.execute(request);
-    String actual = EntityUtils.toString(response.getEntity());
+    String actual = EntityUtils.toString(response.getEntity(), UTF_8);
     assertEquals("Hello, Redirect!", actual);
   }
 
@@ -87,18 +89,11 @@
     assertEquals("Baz", headers2[1].getValue());
   }
 
-  @Test public void noEntity() throws Exception {
-    server.enqueue(new MockResponse());
-
-    HttpPost post = new HttpPost(server.getUrl("/").toURI());
-    client.execute(post);
-  }
-
   @Test public void postByteEntity() throws Exception {
     server.enqueue(new MockResponse());
 
     final HttpPost post = new HttpPost(server.getUrl("/").toURI());
-    byte[] body = "Hello, world!".getBytes("UTF-8");
+    byte[] body = "Hello, world!".getBytes(UTF_8);
     post.setEntity(new ByteArrayEntity(body));
     client.execute(post);
 
@@ -111,7 +106,7 @@
     server.enqueue(new MockResponse());
 
     final HttpPost post = new HttpPost(server.getUrl("/").toURI());
-    byte[] body = "Hello, world!".getBytes("UTF-8");
+    byte[] body = "Hello, world!".getBytes(UTF_8);
     post.setEntity(new InputStreamEntity(new ByteArrayInputStream(body), body.length));
     client.execute(post);
 
@@ -120,6 +115,19 @@
     assertEquals(request.getHeader("Content-Length"), "13");
   }
 
+  @Test public void postOverrideContentType() throws Exception {
+    server.enqueue(new MockResponse());
+
+    HttpPost httpPost = new HttpPost();
+    httpPost.setURI(server.getUrl("/").toURI());
+    httpPost.addHeader("Content-Type", "application/xml");
+    httpPost.setEntity(new StringEntity("<yo/>"));
+    client.execute(httpPost);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals(request.getHeader("Content-Type"), "application/xml");
+  }
+
   @Test public void contentType() throws Exception {
     server.enqueue(new MockResponse().setBody("<html><body><h1>Hello, World!</h1></body></html>")
         .setHeader("Content-Type", "text/html"));
@@ -152,102 +160,93 @@
 
   @Test public void contentEncoding() throws Exception {
     String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
-    ByteArrayOutputStream bodyBytes = new ByteArrayOutputStream();
-    OutputStreamWriter body = new OutputStreamWriter(new GZIPOutputStream(bodyBytes),
-        Charset.forName("UTF-8"));
-    body.write(text);
-    body.close();
-    server.enqueue(new MockResponse().setBody(bodyBytes.toByteArray())
+    server.enqueue(new MockResponse().setBody(gzip(text))
         .setHeader("Content-Encoding", "gzip"));
 
-    byte[] tmp = new byte[32];
+    HttpGet request = new HttpGet(server.getUrl("/").toURI());
+    request.setHeader("Accept-encoding", "gzip"); // Not transparent gzip.
+    HttpResponse response = client.execute(request);
+    HttpEntity entity = response.getEntity();
 
-    HttpGet request1 = new HttpGet(server.getUrl("/").toURI());
-    request1.setHeader("Accept-encoding", "gzip"); // not transparent gzip
-    HttpResponse response1 = client.execute(request1);
-    Header[] headers1 = response1.getHeaders("Content-Encoding");
-    assertEquals(1, headers1.length);
-    assertEquals("gzip", headers1[0].getValue());
-    assertNotNull(response1.getEntity().getContentEncoding());
-    assertEquals("gzip", response1.getEntity().getContentEncoding().getValue());
-    InputStream content = new GZIPInputStream(response1.getEntity().getContent());
-    ByteArrayOutputStream rspBodyBytes = new ByteArrayOutputStream();
-    for (int len = content.read(tmp); len >= 0; len = content.read(tmp)) {
-      rspBodyBytes.write(tmp, 0, len);
-    }
-    String decodedContent = rspBodyBytes.toString("UTF-8");
-    assertEquals(text, decodedContent);
+    Header[] encodingHeaders = response.getHeaders("Content-Encoding");
+    assertEquals(1, encodingHeaders.length);
+    assertEquals("gzip", encodingHeaders[0].getValue());
+    assertNotNull(entity.getContentEncoding());
+    assertEquals("gzip", entity.getContentEncoding().getValue());
+
+    assertEquals(text, gunzip(entity));
   }
 
   @Test public void jsonGzipResponse() throws Exception {
     String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
-    ByteArrayOutputStream bodyBytes = new ByteArrayOutputStream();
-    OutputStreamWriter body = new OutputStreamWriter(new GZIPOutputStream(bodyBytes),
-        Charset.forName("UTF-8"));
-    body.write(text);
-    body.close();
-    server.enqueue(new MockResponse().setBody(bodyBytes.toByteArray())
+    server.enqueue(new MockResponse().setBody(gzip(text))
         .setHeader("Content-Encoding", "gzip")
         .setHeader("Content-Type", "application/json"));
 
-    byte[] tmp = new byte[32];
-
     HttpGet request1 = new HttpGet(server.getUrl("/").toURI());
-    request1.setHeader("Accept-encoding", "gzip"); // not transparent gzip
-    HttpResponse response1 = client.execute(request1);
-    Header[] headers1a = response1.getHeaders("Content-Encoding");
-    assertEquals(1, headers1a.length);
-    assertEquals("gzip", headers1a[0].getValue());
-    assertNotNull(response1.getEntity().getContentEncoding());
-    assertEquals("gzip", response1.getEntity().getContentEncoding().getValue());
-    Header[] headers1b = response1.getHeaders("Content-Type");
-    assertEquals(1, headers1b.length);
-    assertEquals("application/json", headers1b[0].getValue());
-    assertNotNull(response1.getEntity().getContentType());
-    assertEquals("application/json", response1.getEntity().getContentType().getValue());
-    InputStream content = new GZIPInputStream(response1.getEntity().getContent());
-    ByteArrayOutputStream rspBodyBytes = new ByteArrayOutputStream();
-    for (int len = content.read(tmp); len >= 0; len = content.read(tmp)) {
-      rspBodyBytes.write(tmp, 0, len);
-    }
-    String decodedContent = rspBodyBytes.toString("UTF-8");
-    assertEquals(text, decodedContent);
+    request1.setHeader("Accept-encoding", "gzip"); // Not transparent gzip.
+
+    HttpResponse response = client.execute(request1);
+    HttpEntity entity = response.getEntity();
+
+    Header[] encodingHeaders = response.getHeaders("Content-Encoding");
+    assertEquals(1, encodingHeaders.length);
+    assertEquals("gzip", encodingHeaders[0].getValue());
+    assertNotNull(entity.getContentEncoding());
+    assertEquals("gzip", entity.getContentEncoding().getValue());
+
+    Header[] typeHeaders = response.getHeaders("Content-Type");
+    assertEquals(1, typeHeaders.length);
+    assertEquals("application/json", typeHeaders[0].getValue());
+    assertNotNull(entity.getContentType());
+    assertEquals("application/json", entity.getContentType().getValue());
+
+    assertEquals(text, gunzip(entity));
   }
 
   @Test public void jsonTransparentGzipResponse() throws Exception {
     String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
-    ByteArrayOutputStream bodyBytes = new ByteArrayOutputStream();
-    OutputStreamWriter body = new OutputStreamWriter(new GZIPOutputStream(bodyBytes),
-        Charset.forName("UTF-8"));
-    body.write(text);
-    body.close();
-    server.enqueue(new MockResponse().setBody(bodyBytes.toByteArray())
+    server.enqueue(new MockResponse().setBody(gzip(text))
         .setHeader("Content-Encoding", "gzip")
         .setHeader("Content-Type", "application/json"));
 
-    byte[] tmp = new byte[32];
+    HttpGet request = new HttpGet(server.getUrl("/").toURI());
+    HttpResponse response = client.execute(request);
+    HttpEntity entity = response.getEntity();
 
-    HttpGet request1 = new HttpGet(server.getUrl("/").toURI());
-    // expecting transparent gzip response by not adding header "Accept-encoding: gzip"
-    HttpResponse response1 = client.execute(request1);
-    Header[] headers1a = response1.getHeaders("Content-Encoding");
-    assertEquals(0, headers1a.length);
-    assertNull(response1.getEntity().getContentEncoding());
-    // content length should also be absent
-    Header[] headers1b = response1.getHeaders("Content-Length");
-    assertEquals(0, headers1b.length);
-    assertTrue(response1.getEntity().getContentLength() < 0);
-    Header[] headers1c = response1.getHeaders("Content-Type");
-    assertEquals(1, headers1c.length);
-    assertEquals("application/json", headers1c[0].getValue());
-    assertNotNull(response1.getEntity().getContentType());
-    assertEquals("application/json", response1.getEntity().getContentType().getValue());
-    InputStream content = response1.getEntity().getContent();
-    ByteArrayOutputStream rspBodyBytes = new ByteArrayOutputStream();
-    for (int len = content.read(tmp); len >= 0; len = content.read(tmp)) {
-      rspBodyBytes.write(tmp, 0, len);
+    // Expecting transparent gzip response by not adding header "Accept-encoding: gzip"
+    Header[] encodingHeaders = response.getHeaders("Content-Encoding");
+    assertEquals(0, encodingHeaders.length);
+    assertNull(entity.getContentEncoding());
+
+    // Content length should be absent.
+    Header[] lengthHeaders = response.getHeaders("Content-Length");
+    assertEquals(0, lengthHeaders.length);
+    assertEquals(-1, entity.getContentLength());
+
+    Header[] typeHeaders = response.getHeaders("Content-Type");
+    assertEquals(1, typeHeaders.length);
+    assertEquals("application/json", typeHeaders[0].getValue());
+    assertNotNull(entity.getContentType());
+    assertEquals("application/json", entity.getContentType().getValue());
+
+    assertEquals(text, EntityUtils.toString(entity, UTF_8));
+  }
+
+  private static Buffer gzip(String body) throws IOException {
+    Buffer buffer = new Buffer();
+    Okio.buffer(new GzipSink(buffer)).writeUtf8(body).close();
+    return buffer;
+  }
+
+  private static String gunzip(HttpEntity body) throws IOException {
+    InputStream in = new GZIPInputStream(body.getContent());
+    Buffer buffer = new Buffer();
+    byte[] temp = new byte[1024];
+    int read;
+    while ((read = in.read(temp)) != -1) {
+      buffer.write(temp, 0, read);
     }
-    String decodedContent = rspBodyBytes.toString("UTF-8");
-    assertEquals(text, decodedContent);
+    return buffer.readUtf8();
   }
 }
diff --git a/okhttp-hpacktests/README.md b/okhttp-hpacktests/README.md
new file mode 100644
index 0000000000..6b85c9a000
--- /dev/null
+++ b/okhttp-hpacktests/README.md
@@ -0,0 +1,19 @@
+OkHttp HPACK tests
+==================
+
+These tests use the [hpack-test-case][1] project to validate OkHttp's HPACK
+implementation.  The HPACK test cases are in a separate git submodule, so to
+initialize them, you must run:
+
+    git submodule init
+    git submodule update
+
+TODO
+----
+
+ * Add maven goal to avoid manual call to git submodule init.
+ * Make hpack-test-case update itself from git, and run new tests.
+ * Add maven goal to generate stories and a pull request to hpack-test-case
+   to have others validate our output.
+
+[1]: https://github.com/http2jp/hpack-test-case 
diff --git a/okhttp-hpacktests/pom.xml b/okhttp-hpacktests/pom.xml
new file mode 100644
index 0000000000..70a59f2ad6
--- /dev/null
+++ b/okhttp-hpacktests/pom.xml
@@ -0,0 +1,56 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.2.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-hpacktests</artifactId>
+  <name>OkHttp HPACK Tests</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <!--  Gson: Java to Json conversion -->
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+      <scope>compile</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <!-- Do not deploy this as an artifact to Maven central. -->
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-deploy-plugin</artifactId>
+        <configuration>
+          <skip>true</skip>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropTest.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropTest.java
new file mode 100644
index 0000000000..30e1a7b47f
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.spdy.hpackjson.Story;
+import java.util.Collection;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static com.squareup.okhttp.internal.spdy.hpackjson.HpackJsonUtil.storiesForCurrentDraft;
+
+@RunWith(Parameterized.class)
+public class HpackDecodeInteropTest extends HpackDecodeTestBase {
+
+  public HpackDecodeInteropTest(Story story) {
+    super(story);
+  }
+
+  @Parameterized.Parameters(name="{0}")
+  public static Collection<Story[]> createStories() throws Exception {
+    return createStories(storiesForCurrentDraft());
+  }
+
+  @Test
+  public void testGoodDecoderInterop() throws Exception {
+    testDecoder();
+  }
+}
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java
new file mode 100644
index 0000000000..1bd9b006f2
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.spdy.hpackjson.Case;
+import com.squareup.okhttp.internal.spdy.hpackjson.HpackJsonUtil;
+import com.squareup.okhttp.internal.spdy.hpackjson.Story;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+import okio.Buffer;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests Hpack implementation using https://github.com/http2jp/hpack-test-case/
+ */
+public class HpackDecodeTestBase {
+
+  /**
+   * Reads all stories in the folders provided, asserts if no story found.
+   */
+  protected static Collection<Story[]> createStories(String[] interopTests)
+      throws Exception {
+    List<Story[]> result = new ArrayList<>();
+    for (String interopTestName : interopTests) {
+      List<Story> stories = HpackJsonUtil.readStories(interopTestName);
+      if (stories.isEmpty()) {
+        fail("No stories for: " + interopTestName);
+      }
+      for (Story story : stories) {
+        result.add(new Story[] { story });
+      }
+    }
+    return result;
+  }
+
+  private final Buffer bytesIn = new Buffer();
+  private final HpackDraft10.Reader hpackReader = new HpackDraft10.Reader(4096, bytesIn);
+
+  private final Story story;
+
+  public HpackDecodeTestBase(Story story) {
+    this.story = story;
+  }
+
+  /**
+   * Expects wire to be set for all cases, and compares the decoder's output to
+   * expected headers.
+   */
+  protected void testDecoder() throws Exception {
+    testDecoder(story);
+  }
+
+  protected void testDecoder(Story story) throws Exception {
+    for (Case caze : story.getCases()) {
+      bytesIn.write(caze.getWire());
+      hpackReader.readHeaders();
+      assertSetEquals(String.format("seqno=%d", caze.getSeqno()), caze.getHeaders(),
+          hpackReader.getAndResetHeaderList());
+    }
+  }
+  /**
+   * Checks if {@code expected} and {@code observed} are equal when viewed as a
+   * set and headers are deduped.
+   *
+   * TODO: See if duped headers should be preserved on decode and verify.
+   */
+  private static void assertSetEquals(
+      String message, List<Header> expected, List<Header> observed) {
+    assertEquals(message, new LinkedHashSet<>(expected), new LinkedHashSet<>(observed));
+  }
+
+  protected Story getStory() {
+    return story;
+  }
+}
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java
new file mode 100644
index 0000000000..a78dab5abf
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.spdy.hpackjson.Case;
+import com.squareup.okhttp.internal.spdy.hpackjson.Story;
+import okio.Buffer;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Collection;
+
+/**
+ * Tests for round-tripping headers through hpack..
+ */
+// TODO: update hpack-test-case with the output of our encoder.
+// This test will hide complementary bugs in the encoder and decoder,
+// We should test that the encoder is producing responses that are
+// d]
+@RunWith(Parameterized.class)
+public class HpackRoundTripTest extends HpackDecodeTestBase {
+
+  private static final String[] RAW_DATA = { "raw-data" };
+
+  @Parameterized.Parameters(name="{0}")
+  public static Collection<Story[]> getStories() throws Exception {
+    return createStories(RAW_DATA);
+  }
+
+  private Buffer bytesOut = new Buffer();
+  private HpackDraft10.Writer hpackWriter = new HpackDraft10.Writer(bytesOut);
+
+  public HpackRoundTripTest(Story story) {
+    super(story);
+  }
+
+  @Test
+  public void testRoundTrip() throws Exception {
+    Story story = getStory().clone();
+    // Mutate cases in base class.
+    for (Case caze : story.getCases()) {
+      hpackWriter.writeHeaders(caze.getHeaders());
+      caze.setWire(bytesOut.readByteString());
+    }
+
+    testDecoder(story);
+  }
+
+}
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java
new file mode 100644
index 0000000000..d5d272872c
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy.hpackjson;
+
+import com.squareup.okhttp.internal.spdy.Header;
+import okio.ByteString;
+
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Representation of an individual case (set of headers and wire format).
+ * There are many cases for a single story.  This class is used reflectively
+ * with Gson to parse stories.
+ */
+public class Case implements Cloneable {
+
+  private int seqno;
+  private String wire;
+  private List<Map<String, String>> headers;
+
+  public List<Header> getHeaders() {
+    List<Header> result = new ArrayList<>();
+    for (Map<String, String> inputHeader : headers) {
+      Map.Entry<String, String> entry = inputHeader.entrySet().iterator().next();
+      result.add(new Header(entry.getKey(), entry.getValue()));
+    }
+    return result;
+  }
+
+  public ByteString getWire() {
+    return ByteString.decodeHex(wire);
+  }
+
+  public int getSeqno() {
+    return seqno;
+  }
+
+  public void setWire(ByteString wire) {
+    this.wire = wire.hex();
+  }
+
+  @Override
+  protected Case clone() throws CloneNotSupportedException {
+    Case result = new Case();
+    result.seqno = seqno;
+    result.wire = wire;
+    result.headers = new ArrayList<>();
+    for (Map<String, String> header : headers) {
+      result.headers.add(new LinkedHashMap<String, String>(header));
+    }
+    return result;
+  }
+}
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java
new file mode 100644
index 0000000000..9d721abc96
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy.hpackjson;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.net.URISyntaxException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Utilities for reading HPACK tests.
+ */
+public final class HpackJsonUtil {
+  private static final int CURRENT_DRAFT = 9;
+
+  private static final String STORY_RESOURCE_FORMAT = "/hpack-test-case/%s/story_%02d.json";
+
+  private static final Gson GSON = new GsonBuilder().create();
+
+  private static Story readStory(InputStream jsonResource) throws IOException {
+    return GSON.fromJson(new InputStreamReader(jsonResource, "UTF-8"), Story.class);
+  }
+
+  /** Iterate through the hpack-test-case resources, only picking stories for the current draft. */
+  public static String[] storiesForCurrentDraft() throws URISyntaxException {
+    File testCaseDirectory = new File(HpackJsonUtil.class.getResource("/hpack-test-case").toURI());
+    List<String> storyNames = new ArrayList<String>();
+    for (File path : testCaseDirectory.listFiles()) {
+      if (path.isDirectory() && Arrays.asList(path.list()).contains("story_00.json")) {
+        try {
+          Story firstStory = readStory(new FileInputStream(new File(path, "story_00.json")));
+          if (firstStory.getDraft() == CURRENT_DRAFT) {
+            storyNames.add(path.getName());
+          }
+        } catch (IOException ignored) {
+          // Skip this path.
+        }
+      }
+    }
+    return storyNames.toArray(new String[storyNames.size()]);
+  }
+
+  /**
+   * Reads stories named "story_xx.json" from the folder provided.
+   */
+  public static List<Story> readStories(String testFolderName) throws Exception {
+    List<Story> result = new ArrayList<>();
+    int i = 0;
+    while (true) { // break after last test.
+      String storyResourceName = String.format(STORY_RESOURCE_FORMAT, testFolderName, i);
+      InputStream storyInputStream = HpackJsonUtil.class.getResourceAsStream(storyResourceName);
+      if (storyInputStream == null) {
+        break;
+      }
+      try {
+        Story story = readStory(storyInputStream);
+        story.setFileName(storyResourceName);
+        result.add(story);
+        i++;
+      } finally {
+        storyInputStream.close();
+      }
+    }
+    return result;
+  }
+
+  private HpackJsonUtil() { } // Utilities only.
+}
\ No newline at end of file
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java
new file mode 100644
index 0000000000..5ff2b07675
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy.hpackjson;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Representation of one story, a set of request headers to encode or decode.
+ * This class is used reflectively with Gson to parse stories from files.
+ */
+public class Story implements Cloneable {
+
+  private transient String fileName;
+  private List<Case> cases;
+  private int draft;
+  private String description;
+
+  /**
+   * The filename is only used in the toString representation.
+   */
+  void setFileName(String fileName) {
+    this.fileName = fileName;
+  }
+
+  public List<Case> getCases() {
+    return cases;
+  }
+
+  /** We only expect stories that match the draft we've implemented to pass. */
+  public int getDraft() {
+    return draft;
+  }
+
+  @Override
+  public Story clone() throws CloneNotSupportedException {
+    Story story = new Story();
+    story.fileName = this.fileName;
+    story.cases = new ArrayList<>();
+    for (Case caze : cases) {
+      story.cases.add(caze.clone());
+    }
+    story.draft = draft;
+    story.description = description;
+    return story;
+  }
+
+  @Override
+  public String toString() {
+    // Used as the test name.
+    return fileName;
+  }
+}
diff --git a/okhttp-hpacktests/src/test/resources/hpack-test-case b/okhttp-hpacktests/src/test/resources/hpack-test-case
new file mode 160000
index 0000000000..a5652bc2bc
--- /dev/null
+++ b/okhttp-hpacktests/src/test/resources/hpack-test-case
@@ -0,0 +1 @@
+Subproject commit a5652bc2bc3d2a992f39446369fb004a72e881d4
diff --git a/okhttp-protocols/pom.xml b/okhttp-protocols/pom.xml
deleted file mode 100644
index 0ecb915146..0000000000
--- a/okhttp-protocols/pom.xml
+++ /dev/null
@@ -1,27 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp</groupId>
-    <artifactId>parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-protocols</artifactId>
-  <name>OkHttp SPDY and HTTP/2.0 internals</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>org.mortbay.jetty.npn</groupId>
-      <artifactId>npn-boot</artifactId>
-      <optional>true</optional>
-    </dependency>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
deleted file mode 100644
index 905641a30a..0000000000
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ /dev/null
@@ -1,422 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.net.InetSocketAddress;
-import java.net.NetworkInterface;
-import java.net.Socket;
-import java.net.SocketException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import java.util.zip.Deflater;
-import java.util.zip.DeflaterOutputStream;
-import javax.net.ssl.SSLSocket;
-
-/**
- * Access to Platform-specific features necessary for SPDY and advanced TLS.
- *
- * <h3>SPDY</h3>
- * SPDY requires a TLS extension called NPN (Next Protocol Negotiation) that's
- * available in Android 4.1+ and OpenJDK 7+ (with the npn-boot extension). It
- * also requires a recent version of {@code DeflaterOutputStream} that is
- * public API in Java 7 and callable via reflection in Android 4.1+.
- */
-public class Platform {
-  private static final Platform PLATFORM = findPlatform();
-
-  private Constructor<DeflaterOutputStream> deflaterConstructor;
-
-  public static Platform get() {
-    return PLATFORM;
-  }
-
-  /** Prefix used on custom headers. */
-  public String getPrefix() {
-    return "OkHttp";
-  }
-
-  public void logW(String warning) {
-    System.out.println(warning);
-  }
-
-  public void tagSocket(Socket socket) throws SocketException {
-  }
-
-  public void untagSocket(Socket socket) throws SocketException {
-  }
-
-  public URI toUriLenient(URL url) throws URISyntaxException {
-    return url.toURI(); // this isn't as good as the built-in toUriLenient
-  }
-
-  /**
-   * Attempt a TLS connection with useful extensions enabled. This mode
-   * supports more features, but is less likely to be compatible with older
-   * HTTPS servers.
-   */
-  public void enableTlsExtensions(SSLSocket socket, String uriHost) {
-  }
-
-  /**
-   * Attempt a secure connection with basic functionality to maximize
-   * compatibility. Currently this uses SSL 3.0.
-   */
-  public void supportTlsIntolerantServer(SSLSocket socket) {
-    socket.setEnabledProtocols(new String[] {"SSLv3"});
-  }
-
-  /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  public byte[] getNpnSelectedProtocol(SSLSocket socket) {
-    return null;
-  }
-
-  /**
-   * Sets client-supported protocols on a socket to send to a server. The
-   * protocols are only sent if the socket implementation supports NPN.
-   */
-  public void setNpnProtocols(SSLSocket socket, byte[] npnProtocols) {
-  }
-
-  public void connectSocket(Socket socket, InetSocketAddress address,
-      int connectTimeout) throws IOException {
-    socket.connect(address, connectTimeout);
-  }
-
-  /**
-   * Returns a deflater output stream that supports SYNC_FLUSH for SPDY name
-   * value blocks. This throws an {@link UnsupportedOperationException} on
-   * Java 6 and earlier where there is no built-in API to do SYNC_FLUSH.
-   */
-  public OutputStream newDeflaterOutputStream(OutputStream out, Deflater deflater,
-      boolean syncFlush) {
-    try {
-      Constructor<DeflaterOutputStream> constructor = deflaterConstructor;
-      if (constructor == null) {
-        constructor = deflaterConstructor = DeflaterOutputStream.class.getConstructor(
-            OutputStream.class, Deflater.class, boolean.class);
-      }
-      return constructor.newInstance(out, deflater, syncFlush);
-    } catch (NoSuchMethodException e) {
-      throw new UnsupportedOperationException("Cannot SPDY; no SYNC_FLUSH available");
-    } catch (InvocationTargetException e) {
-      throw e.getCause() instanceof RuntimeException ? (RuntimeException) e.getCause()
-          : new RuntimeException(e.getCause());
-    } catch (InstantiationException e) {
-      throw new RuntimeException(e);
-    } catch (IllegalAccessException e) {
-      throw new AssertionError();
-    }
-  }
-
-  /**
-   * Returns the maximum transmission unit of the network interface used by
-   * {@code socket}, or a reasonable default if this platform doesn't expose the
-   * MTU to the application layer.
-   *
-   * <p>The returned value should only be used as an optimization; such as to
-   * size buffers efficiently.
-   */
-  public int getMtu(Socket socket) throws IOException {
-    return 1400; // Smaller than 1500 to leave room for headers on interfaces like PPPoE.
-  }
-
-  /** Attempt to match the host runtime to a capable Platform implementation. */
-  private static Platform findPlatform() {
-    Method getMtu;
-    try {
-      getMtu = NetworkInterface.class.getMethod("getMTU");
-    } catch (NoSuchMethodException e) {
-      return new Platform(); // No Java 1.6 APIs. It's either Java 1.5, Android 2.2 or earlier.
-    }
-
-    // Attempt to find Android 2.3+ APIs.
-    Class<?> openSslSocketClass;
-    Method setUseSessionTickets;
-    Method setHostname;
-    try {
-      try {
-        openSslSocketClass = Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl");
-      } catch (ClassNotFoundException ignored) {
-        // Older platform before being unbundled.
-        openSslSocketClass = Class.forName(
-            "org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl");
-      }
-
-      setUseSessionTickets = openSslSocketClass.getMethod("setUseSessionTickets", boolean.class);
-      setHostname = openSslSocketClass.getMethod("setHostname", String.class);
-
-      // Attempt to find Android 4.1+ APIs.
-      try {
-        Method setNpnProtocols = openSslSocketClass.getMethod("setNpnProtocols", byte[].class);
-        Method getNpnSelectedProtocol = openSslSocketClass.getMethod("getNpnSelectedProtocol");
-        return new Android41(getMtu, openSslSocketClass, setUseSessionTickets, setHostname,
-            setNpnProtocols, getNpnSelectedProtocol);
-      } catch (NoSuchMethodException ignored) {
-        return new Android23(getMtu, openSslSocketClass, setUseSessionTickets, setHostname);
-      }
-    } catch (ClassNotFoundException ignored) {
-      // This isn't an Android runtime.
-    } catch (NoSuchMethodException ignored) {
-      // This isn't Android 2.3 or better.
-    }
-
-    // Attempt to find the Jetty's NPN extension for OpenJDK.
-    try {
-      String npnClassName = "org.eclipse.jetty.npn.NextProtoNego";
-      Class<?> nextProtoNegoClass = Class.forName(npnClassName);
-      Class<?> providerClass = Class.forName(npnClassName + "$Provider");
-      Class<?> clientProviderClass = Class.forName(npnClassName + "$ClientProvider");
-      Class<?> serverProviderClass = Class.forName(npnClassName + "$ServerProvider");
-      Method putMethod = nextProtoNegoClass.getMethod("put", SSLSocket.class, providerClass);
-      Method getMethod = nextProtoNegoClass.getMethod("get", SSLSocket.class);
-      return new JdkWithJettyNpnPlatform(getMtu, putMethod, getMethod, clientProviderClass,
-          serverProviderClass);
-    } catch (ClassNotFoundException ignored) {
-      // NPN isn't on the classpath.
-    } catch (NoSuchMethodException ignored) {
-      // The NPN version isn't what we expect.
-    }
-
-    return new Java6(getMtu);
-  }
-
-  private static class Java6 extends Platform {
-    private final Method getMtu;
-
-    private Java6(Method getMtu) {
-      this.getMtu = getMtu;
-    }
-
-    @Override public int getMtu(Socket socket) throws IOException {
-      try {
-        NetworkInterface networkInterface = NetworkInterface.getByInetAddress(
-            socket.getLocalAddress());
-        if (networkInterface == null) {
-          return super.getMtu(socket); // There's no longer an interface with this local address.
-        }
-        return (Integer) getMtu.invoke(networkInterface);
-      } catch (NullPointerException e) {
-        // Certain Alcatel devices throw on getByInetAddress. Return default.
-        return super.getMtu(socket);
-      } catch (SocketException e) {
-        // Certain Motorola devices always throw on getByInetAddress. Return the default for those.
-        return super.getMtu(socket);
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      } catch (InvocationTargetException e) {
-        if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
-        throw new RuntimeException(e.getCause());
-      }
-    }
-  }
-
-  /** Android version 2.3 and newer support TLS session tickets and server name indication (SNI). */
-  private static class Android23 extends Java6 {
-    protected final Class<?> openSslSocketClass;
-    private final Method setUseSessionTickets;
-    private final Method setHostname;
-
-    private Android23(Method getMtu, Class<?> openSslSocketClass, Method setUseSessionTickets,
-        Method setHostname) {
-      super(getMtu);
-      this.openSslSocketClass = openSslSocketClass;
-      this.setUseSessionTickets = setUseSessionTickets;
-      this.setHostname = setHostname;
-    }
-
-    @Override public void connectSocket(Socket socket, InetSocketAddress address,
-        int connectTimeout) throws IOException {
-      try {
-        socket.connect(address, connectTimeout);
-      } catch (SecurityException se) {
-        // Before android 4.3, socket.connect could throw a SecurityException
-        // if opening a socket resulted in an EACCES error.
-        IOException ioException = new IOException("Exception in connect");
-        ioException.initCause(se);
-        throw ioException;
-      }
-    }
-
-    @Override public void enableTlsExtensions(SSLSocket socket, String uriHost) {
-      super.enableTlsExtensions(socket, uriHost);
-      if (openSslSocketClass.isInstance(socket)) {
-        // This is Android: use reflection on OpenSslSocketImpl.
-        try {
-          setUseSessionTickets.invoke(socket, true);
-          setHostname.invoke(socket, uriHost);
-        } catch (InvocationTargetException e) {
-          throw new RuntimeException(e);
-        } catch (IllegalAccessException e) {
-          throw new AssertionError(e);
-        }
-      }
-    }
-  }
-
-  /** Android version 4.1 and newer support NPN. */
-  private static class Android41 extends Android23 {
-    private final Method setNpnProtocols;
-    private final Method getNpnSelectedProtocol;
-
-    private Android41(Method getMtu, Class<?> openSslSocketClass, Method setUseSessionTickets,
-        Method setHostname, Method setNpnProtocols, Method getNpnSelectedProtocol) {
-      super(getMtu, openSslSocketClass, setUseSessionTickets, setHostname);
-      this.setNpnProtocols = setNpnProtocols;
-      this.getNpnSelectedProtocol = getNpnSelectedProtocol;
-    }
-
-    @Override public void setNpnProtocols(SSLSocket socket, byte[] npnProtocols) {
-      if (!openSslSocketClass.isInstance(socket)) {
-        return;
-      }
-      try {
-        setNpnProtocols.invoke(socket, new Object[] {npnProtocols});
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      } catch (InvocationTargetException e) {
-        throw new RuntimeException(e);
-      }
-    }
-
-    @Override public byte[] getNpnSelectedProtocol(SSLSocket socket) {
-      if (!openSslSocketClass.isInstance(socket)) {
-        return null;
-      }
-      try {
-        return (byte[]) getNpnSelectedProtocol.invoke(socket);
-      } catch (InvocationTargetException e) {
-        throw new RuntimeException(e);
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      }
-    }
-  }
-
-  /** OpenJDK 7 plus {@code org.mortbay.jetty.npn/npn-boot} on the boot class path. */
-  private static class JdkWithJettyNpnPlatform extends Java6 {
-    private final Method getMethod;
-    private final Method putMethod;
-    private final Class<?> clientProviderClass;
-    private final Class<?> serverProviderClass;
-
-    public JdkWithJettyNpnPlatform(Method getMtu, Method putMethod, Method getMethod,
-        Class<?> clientProviderClass, Class<?> serverProviderClass) {
-      super(getMtu);
-      this.putMethod = putMethod;
-      this.getMethod = getMethod;
-      this.clientProviderClass = clientProviderClass;
-      this.serverProviderClass = serverProviderClass;
-    }
-
-    @Override public void setNpnProtocols(SSLSocket socket, byte[] npnProtocols) {
-      try {
-        List<String> strings = new ArrayList<String>();
-        for (int i = 0; i < npnProtocols.length; ) {
-          int length = npnProtocols[i++];
-          strings.add(new String(npnProtocols, i, length, "US-ASCII"));
-          i += length;
-        }
-        Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
-            new Class[] {clientProviderClass, serverProviderClass},
-            new JettyNpnProvider(strings));
-        putMethod.invoke(null, socket, provider);
-      } catch (UnsupportedEncodingException e) {
-        throw new AssertionError(e);
-      } catch (InvocationTargetException e) {
-        throw new AssertionError(e);
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      }
-    }
-
-    @Override public byte[] getNpnSelectedProtocol(SSLSocket socket) {
-      try {
-        JettyNpnProvider provider =
-            (JettyNpnProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
-        if (!provider.unsupported && provider.selected == null) {
-          Logger logger = Logger.getLogger("com.squareup.okhttp.OkHttpClient");
-          logger.log(Level.INFO,
-              "NPN callback dropped so SPDY is disabled. " + "Is npn-boot on the boot class path?");
-          return null;
-        }
-        return provider.unsupported ? null : provider.selected.getBytes("US-ASCII");
-      } catch (UnsupportedEncodingException e) {
-        throw new AssertionError();
-      } catch (InvocationTargetException e) {
-        throw new AssertionError();
-      } catch (IllegalAccessException e) {
-        throw new AssertionError();
-      }
-    }
-  }
-
-  /**
-   * Handle the methods of NextProtoNego's ClientProvider and ServerProvider
-   * without a compile-time dependency on those interfaces.
-   */
-  private static class JettyNpnProvider implements InvocationHandler {
-    private final List<String> protocols;
-    private boolean unsupported;
-    private String selected;
-
-    public JettyNpnProvider(List<String> protocols) {
-      this.protocols = protocols;
-    }
-
-    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-      String methodName = method.getName();
-      Class<?> returnType = method.getReturnType();
-      if (args == null) {
-        args = Util.EMPTY_STRING_ARRAY;
-      }
-      if (methodName.equals("supports") && boolean.class == returnType) {
-        return true;
-      } else if (methodName.equals("unsupported") && void.class == returnType) {
-        this.unsupported = true;
-        return null;
-      } else if (methodName.equals("protocols") && args.length == 0) {
-        return protocols;
-      } else if (methodName.equals("selectProtocol")
-          && String.class == returnType
-          && args.length == 1
-          && (args[0] == null || args[0] instanceof List)) {
-        // TODO: use OpenSSL's algorithm which uses both lists
-        List<?> serverProtocols = (List) args[0];
-        this.selected = protocols.get(0);
-        return selected;
-      } else if (methodName.equals("protocolSelected") && args.length == 1) {
-        this.selected = (String) args[0];
-        return null;
-      } else {
-        return method.invoke(this, args);
-      }
-    }
-  }
-}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
deleted file mode 100644
index 29c6c255f0..0000000000
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
+++ /dev/null
@@ -1,378 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal;
-
-import java.io.Closeable;
-import java.io.EOFException;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.Reader;
-import java.io.StringWriter;
-import java.io.UnsupportedEncodingException;
-import java.net.Socket;
-import java.net.URI;
-import java.net.URL;
-import java.nio.ByteOrder;
-import java.nio.charset.Charset;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.atomic.AtomicReference;
-
-/** Junk drawer of utility methods. */
-public final class Util {
-  public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
-  public static final String[] EMPTY_STRING_ARRAY = new String[0];
-
-  /** A cheap and type-safe constant for the ISO-8859-1 Charset. */
-  public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
-
-  /** A cheap and type-safe constant for the US-ASCII Charset. */
-  public static final Charset US_ASCII = Charset.forName("US-ASCII");
-
-  /** A cheap and type-safe constant for the UTF-8 Charset. */
-  public static final Charset UTF_8 = Charset.forName("UTF-8");
-  private static AtomicReference<byte[]> skipBuffer = new AtomicReference<byte[]>();
-
-  private static final char[] DIGITS =
-      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
-
-  private Util() {
-  }
-
-  public static int getEffectivePort(URI uri) {
-    return getEffectivePort(uri.getScheme(), uri.getPort());
-  }
-
-  public static int getEffectivePort(URL url) {
-    return getEffectivePort(url.getProtocol(), url.getPort());
-  }
-
-  private static int getEffectivePort(String scheme, int specifiedPort) {
-    return specifiedPort != -1 ? specifiedPort : getDefaultPort(scheme);
-  }
-
-  public static int getDefaultPort(String scheme) {
-    if ("http".equalsIgnoreCase(scheme)) {
-      return 80;
-    } else if ("https".equalsIgnoreCase(scheme)) {
-      return 443;
-    } else {
-      return -1;
-    }
-  }
-
-  public static void checkOffsetAndCount(int arrayLength, int offset, int count) {
-    if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
-      throw new ArrayIndexOutOfBoundsException();
-    }
-  }
-
-  public static void pokeInt(byte[] dst, int offset, int value, ByteOrder order) {
-    if (order == ByteOrder.BIG_ENDIAN) {
-      dst[offset++] = (byte) ((value >> 24) & 0xff);
-      dst[offset++] = (byte) ((value >> 16) & 0xff);
-      dst[offset++] = (byte) ((value >> 8) & 0xff);
-      dst[offset] = (byte) ((value >> 0) & 0xff);
-    } else {
-      dst[offset++] = (byte) ((value >> 0) & 0xff);
-      dst[offset++] = (byte) ((value >> 8) & 0xff);
-      dst[offset++] = (byte) ((value >> 16) & 0xff);
-      dst[offset] = (byte) ((value >> 24) & 0xff);
-    }
-  }
-
-  /** Returns true if two possibly-null objects are equal. */
-  public static boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  /**
-   * Closes {@code closeable}, ignoring any checked exceptions. Does nothing
-   * if {@code closeable} is null.
-   */
-  public static void closeQuietly(Closeable closeable) {
-    if (closeable != null) {
-      try {
-        closeable.close();
-      } catch (RuntimeException rethrown) {
-        throw rethrown;
-      } catch (Exception ignored) {
-      }
-    }
-  }
-
-  /**
-   * Closes {@code socket}, ignoring any checked exceptions. Does nothing if
-   * {@code socket} is null.
-   */
-  public static void closeQuietly(Socket socket) {
-    if (socket != null) {
-      try {
-        socket.close();
-      } catch (RuntimeException rethrown) {
-        throw rethrown;
-      } catch (Exception ignored) {
-      }
-    }
-  }
-
-  /**
-   * Closes {@code a} and {@code b}. If either close fails, this completes
-   * the other close and rethrows the first encountered exception.
-   */
-  public static void closeAll(Closeable a, Closeable b) throws IOException {
-    Throwable thrown = null;
-    try {
-      a.close();
-    } catch (Throwable e) {
-      thrown = e;
-    }
-    try {
-      b.close();
-    } catch (Throwable e) {
-      if (thrown == null) thrown = e;
-    }
-    if (thrown == null) return;
-    if (thrown instanceof IOException) throw (IOException) thrown;
-    if (thrown instanceof RuntimeException) throw (RuntimeException) thrown;
-    if (thrown instanceof Error) throw (Error) thrown;
-    throw new AssertionError(thrown);
-  }
-
-  /**
-   * Deletes the contents of {@code dir}. Throws an IOException if any file
-   * could not be deleted, or if {@code dir} is not a readable directory.
-   */
-  public static void deleteContents(File dir) throws IOException {
-    File[] files = dir.listFiles();
-    if (files == null) {
-      throw new IOException("not a readable directory: " + dir);
-    }
-    for (File file : files) {
-      if (file.isDirectory()) {
-        deleteContents(file);
-      }
-      if (!file.delete()) {
-        throw new IOException("failed to delete file: " + file);
-      }
-    }
-  }
-
-  /**
-   * Implements InputStream.read(int) in terms of InputStream.read(byte[], int, int).
-   * InputStream assumes that you implement InputStream.read(int) and provides default
-   * implementations of the others, but often the opposite is more efficient.
-   */
-  public static int readSingleByte(InputStream in) throws IOException {
-    byte[] buffer = new byte[1];
-    int result = in.read(buffer, 0, 1);
-    return (result != -1) ? buffer[0] & 0xff : -1;
-  }
-
-  /**
-   * Implements OutputStream.write(int) in terms of OutputStream.write(byte[], int, int).
-   * OutputStream assumes that you implement OutputStream.write(int) and provides default
-   * implementations of the others, but often the opposite is more efficient.
-   */
-  public static void writeSingleByte(OutputStream out, int b) throws IOException {
-    byte[] buffer = new byte[1];
-    buffer[0] = (byte) (b & 0xff);
-    out.write(buffer);
-  }
-
-  /**
-   * Fills 'dst' with bytes from 'in', throwing EOFException if insufficient bytes are available.
-   */
-  public static void readFully(InputStream in, byte[] dst) throws IOException {
-    readFully(in, dst, 0, dst.length);
-  }
-
-  /**
-   * Reads exactly 'byteCount' bytes from 'in' (into 'dst' at offset 'offset'), and throws
-   * EOFException if insufficient bytes are available.
-   *
-   * Used to implement {@link java.io.DataInputStream#readFully(byte[], int, int)}.
-   */
-  public static void readFully(InputStream in, byte[] dst, int offset, int byteCount)
-      throws IOException {
-    if (byteCount == 0) {
-      return;
-    }
-    if (in == null) {
-      throw new NullPointerException("in == null");
-    }
-    if (dst == null) {
-      throw new NullPointerException("dst == null");
-    }
-    checkOffsetAndCount(dst.length, offset, byteCount);
-    while (byteCount > 0) {
-      int bytesRead = in.read(dst, offset, byteCount);
-      if (bytesRead < 0) {
-        throw new EOFException();
-      }
-      offset += bytesRead;
-      byteCount -= bytesRead;
-    }
-  }
-
-  /** Returns the remainder of 'reader' as a string, closing it when done. */
-  public static String readFully(Reader reader) throws IOException {
-    try {
-      StringWriter writer = new StringWriter();
-      char[] buffer = new char[1024];
-      int count;
-      while ((count = reader.read(buffer)) != -1) {
-        writer.write(buffer, 0, count);
-      }
-      return writer.toString();
-    } finally {
-      reader.close();
-    }
-  }
-
-  public static void skipAll(InputStream in) throws IOException {
-    do {
-      in.skip(Long.MAX_VALUE);
-    } while (in.read() != -1);
-  }
-
-  /**
-   * Call {@code in.read()} repeatedly until either the stream is exhausted or
-   * {@code byteCount} bytes have been read.
-   *
-   * <p>This method reuses the skip buffer but is careful to never use it at
-   * the same time that another stream is using it. Otherwise streams that use
-   * the caller's buffer for consistency checks like CRC could be clobbered by
-   * other threads. A thread-local buffer is also insufficient because some
-   * streams may call other streams in their skip() method, also clobbering the
-   * buffer.
-   */
-  public static long skipByReading(InputStream in, long byteCount) throws IOException {
-    if (byteCount == 0) return 0L;
-
-    // acquire the shared skip buffer.
-    byte[] buffer = skipBuffer.getAndSet(null);
-    if (buffer == null) {
-      buffer = new byte[4096];
-    }
-
-    long skipped = 0;
-    while (skipped < byteCount) {
-      int toRead = (int) Math.min(byteCount - skipped, buffer.length);
-      int read = in.read(buffer, 0, toRead);
-      if (read == -1) {
-        break;
-      }
-      skipped += read;
-      if (read < toRead) {
-        break;
-      }
-    }
-
-    // release the shared skip buffer.
-    skipBuffer.set(buffer);
-
-    return skipped;
-  }
-
-  /**
-   * Copies all of the bytes from {@code in} to {@code out}. Neither stream is closed.
-   * Returns the total number of bytes transferred.
-   */
-  public static int copy(InputStream in, OutputStream out) throws IOException {
-    int total = 0;
-    byte[] buffer = new byte[8192];
-    int c;
-    while ((c = in.read(buffer)) != -1) {
-      total += c;
-      out.write(buffer, 0, c);
-    }
-    return total;
-  }
-
-  /**
-   * Returns the ASCII characters up to but not including the next "\r\n", or
-   * "\n".
-   *
-   * @throws java.io.EOFException if the stream is exhausted before the next newline
-   * character.
-   */
-  public static String readAsciiLine(InputStream in) throws IOException {
-    // TODO: support UTF-8 here instead
-    StringBuilder result = new StringBuilder(80);
-    while (true) {
-      int c = in.read();
-      if (c == -1) {
-        throw new EOFException();
-      } else if (c == '\n') {
-        break;
-      }
-
-      result.append((char) c);
-    }
-    int length = result.length();
-    if (length > 0 && result.charAt(length - 1) == '\r') {
-      result.setLength(length - 1);
-    }
-    return result.toString();
-  }
-
-  /** Returns a 32 character string containing a hash of {@code s}. */
-  public static String hash(String s) {
-    try {
-      MessageDigest messageDigest = MessageDigest.getInstance("MD5");
-      byte[] md5bytes = messageDigest.digest(s.getBytes("UTF-8"));
-      return bytesToHexString(md5bytes);
-    } catch (NoSuchAlgorithmException e) {
-      throw new AssertionError(e);
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  private static String bytesToHexString(byte[] bytes) {
-    char[] digits = DIGITS;
-    char[] buf = new char[bytes.length * 2];
-    int c = 0;
-    for (byte b : bytes) {
-      buf[c++] = digits[(b >> 4) & 0xf];
-      buf[c++] = digits[b & 0xf];
-    }
-    return new String(buf);
-  }
-
-  /** Returns an immutable copy of {@code list}. */
-  public static <T> List<T> immutableList(List<T> list) {
-    return Collections.unmodifiableList(new ArrayList<T>(list));
-  }
-
-  public static ThreadFactory daemonThreadFactory(final String name) {
-    return new ThreadFactory() {
-      @Override public Thread newThread(Runnable runnable) {
-        Thread result = new Thread(runnable, name);
-        result.setDaemon(true);
-        return result;
-      }
-    };
-  }
-}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
deleted file mode 100644
index 1371262e6c..0000000000
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.spdy;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.List;
-
-/** Reads transport frames for SPDY/3 or HTTP/2.0. */
-public interface FrameReader extends Closeable {
-  void readConnectionHeader() throws IOException;
-  boolean nextFrame(Handler handler) throws IOException;
-
-  public interface Handler {
-    void data(boolean inFinished, int streamId, InputStream in, int length) throws IOException;
-    /**
-     * Create or update incoming headers, creating the corresponding streams
-     * if necessary. Frames that trigger this are SPDY SYN_STREAM, HEADERS, and
-     * SYN_REPLY, and HTTP/2.0 HEADERS and PUSH_PROMISE.
-     *
-     * @param inFinished true if the sender will not send further frames.
-     * @param outFinished true if the receiver should not send further frames.
-     * @param streamId the stream owning these headers.
-     * @param associatedStreamId the stream that triggered the sender to create
-     *     this stream.
-     * @param priority or -1 for no priority. For SPDY, priorities range from 0
-     *     (highest) thru 7 (lowest). For HTTP/2.0, priorities range from 0
-     *     (highest) thru 2**31-1 (lowest).
-     */
-    void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-        int priority, List<String> nameValueBlock, HeadersMode headersMode);
-    void rstStream(int streamId, ErrorCode errorCode);
-    void settings(boolean clearPrevious, Settings settings);
-    void noop();
-    void ping(boolean reply, int payload1, int payload2);
-    void goAway(int lastGoodStreamId, ErrorCode errorCode);
-    void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl);
-    void priority(int streamId, int priority);
-  }
-}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
deleted file mode 100644
index 354f43d1d1..0000000000
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.spdy;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.util.List;
-
-/** Writes transport frames for SPDY/3 or HTTP/2.0. */
-public interface FrameWriter extends Closeable {
-  /** HTTP/2.0 only. */
-  void connectionHeader() throws IOException;
-
-  /** SPDY/3 only. */
-  void flush() throws IOException;
-  void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      int priority, int slot, List<String> nameValueBlock) throws IOException;
-  void synReply(boolean outFinished, int streamId, List<String> nameValueBlock) throws IOException;
-  void headers(int streamId, List<String> nameValueBlock) throws IOException;
-  void rstStream(int streamId, ErrorCode errorCode) throws IOException;
-  void data(boolean outFinished, int streamId, byte[] data) throws IOException;
-  void data(boolean outFinished, int streamId, byte[] data, int offset, int byteCount)
-      throws IOException;
-  void settings(Settings settings) throws IOException;
-  void noop() throws IOException;
-  void ping(boolean reply, int payload1, int payload2) throws IOException;
-  void goAway(int lastGoodStreamId, ErrorCode errorCode) throws IOException;
-  void windowUpdate(int streamId, int deltaWindowSize) throws IOException;
-}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
deleted file mode 100644
index 1e799b4994..0000000000
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
+++ /dev/null
@@ -1,360 +0,0 @@
-package com.squareup.okhttp.internal.spdy;
-
-import java.io.DataInputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.BitSet;
-import java.util.List;
-
-/**
- * Read and write HPACK v01.
- * http://http2.github.io/compression-spec/compression-spec.html#rfc.status
- */
-final class Hpack {
-  static final int PREFIX_5_BITS = 0x1f;
-  static final int PREFIX_6_BITS = 0x3f;
-  static final int PREFIX_7_BITS = 0x7f;
-  static final int PREFIX_8_BITS = 0xff;
-
-  static final List<String> INITIAL_CLIENT_TO_SERVER_HEADER_TABLE = Arrays.asList(
-      ":scheme", "http",
-      ":scheme", "https",
-      ":host", "",
-      ":path", "/",
-      ":method", "GET",
-      "accept", "",
-      "accept-charset", "",
-      "accept-encoding", "",
-      "accept-language", "",
-      "cookie", "",
-      "if-modified-since", "",
-      "user-agent", "",
-      "referer", "",
-      "authorization", "",
-      "allow", "",
-      "cache-control", "",
-      "connection", "",
-      "content-length", "",
-      "content-type", "",
-      "date", "",
-      "expect", "",
-      "from", "",
-      "if-match", "",
-      "if-none-match", "",
-      "if-range", "",
-      "if-unmodified-since", "",
-      "max-forwards", "",
-      "proxy-authorization", "",
-      "range", "",
-      "via", ""
-  );
-
-  static final List<String> INITIAL_SERVER_TO_CLIENT_HEADER_TABLE = Arrays.asList(
-      ":status", "200",
-      "age", "",
-      "cache-control", "",
-      "content-length", "",
-      "content-type", "",
-      "date", "",
-      "etag", "",
-      "expires", "",
-      "last-modified", "",
-      "server", "",
-      "set-cookie", "",
-      "vary", "",
-      "via", "",
-      "access-control-allow-origin", "",
-      "accept-ranges", "",
-      "allow", "",
-      "connection", "",
-      "content-disposition", "",
-      "content-encoding", "",
-      "content-language", "",
-      "content-location", "",
-      "content-range", "",
-      "link", "",
-      "location", "",
-      "proxy-authenticate", "",
-      "refresh", "",
-      "retry-after", "",
-      "strict-transport-security", "",
-      "transfer-encoding", "",
-      "www-authenticate", ""
-  );
-
-  private Hpack() {
-  }
-
-  static class Reader {
-    private final long maxBufferSize = 4096; // TODO: needs to come from settings.
-    private final DataInputStream in;
-
-    private final BitSet referenceSet = new BitSet();
-    private final List<String> headerTable;
-    private final List<String> emittedHeaders = new ArrayList<String>();
-    private long bufferSize = 4096;
-    private long bytesLeft = 0;
-
-    Reader(DataInputStream in, boolean client) {
-      this.in = in;
-      this.headerTable = new ArrayList<String>(client
-          ? INITIAL_CLIENT_TO_SERVER_HEADER_TABLE
-          : INITIAL_SERVER_TO_CLIENT_HEADER_TABLE);
-    }
-
-    /**
-     * Read {@code byteCount} bytes of headers from the source stream into the
-     * set of emitted headers.
-     */
-    public void readHeaders(int byteCount) throws IOException {
-      bytesLeft += byteCount;
-      // TODO: limit to 'byteCount' bytes?
-
-      while (bytesLeft > 0) {
-        int b = readByte();
-
-        if ((b & 0x80) != 0) {
-          int index = readInt(b, PREFIX_7_BITS);
-          readIndexedHeader(index);
-        } else if (b == 0x60) {
-          readLiteralHeaderWithoutIndexingNewName();
-        } else if ((b & 0xe0) == 0x60) {
-          int index = readInt(b, PREFIX_5_BITS);
-          readLiteralHeaderWithoutIndexingIndexedName(index - 1);
-        } else if (b == 0x40) {
-          readLiteralHeaderWithIncrementalIndexingNewName();
-        } else if ((b & 0xe0) == 0x40) {
-          int index = readInt(b, PREFIX_5_BITS);
-          readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
-        } else if (b == 0) {
-          readLiteralHeaderWithSubstitutionIndexingNewName();
-        } else if ((b & 0xc0) == 0) {
-          int index = readInt(b, PREFIX_6_BITS);
-          readLiteralHeaderWithSubstitutionIndexingIndexedName(index - 1);
-        } else {
-          throw new AssertionError();
-        }
-      }
-    }
-
-    public void emitReferenceSet() {
-      for (int i = referenceSet.nextSetBit(0); i != -1; i = referenceSet.nextSetBit(i + 1)) {
-        emittedHeaders.add(getName(i));
-        emittedHeaders.add(getValue(i));
-      }
-    }
-
-    /**
-     * Returns all headers emitted since they were last cleared, then clears the
-     * emitted headers.
-     */
-    public List<String> getAndReset() {
-      List<String> result = new ArrayList<String>(emittedHeaders);
-      emittedHeaders.clear();
-      return result;
-    }
-
-    private void readIndexedHeader(int index) {
-      if (referenceSet.get(index)) {
-        referenceSet.clear(index);
-      } else {
-        referenceSet.set(index);
-        emittedHeaders.add(getName(index));
-        emittedHeaders.add(getValue(index));
-      }
-    }
-
-    private void readLiteralHeaderWithoutIndexingIndexedName(int index)
-        throws IOException {
-      String name = getName(index);
-      String value = readString();
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-    }
-
-    private void readLiteralHeaderWithoutIndexingNewName()
-        throws IOException {
-      String name = readString();
-      String value = readString();
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-    }
-
-    private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
-        throws IOException {
-      int index = headerTable.size();
-      String name = getName(nameIndex);
-      String value = readString();
-      appendToHeaderTable(name, value);
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-      referenceSet.set(index);
-    }
-
-    private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
-      int index = headerTable.size();
-      String name = readString();
-      String value = readString();
-      appendToHeaderTable(name, value);
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-      referenceSet.set(index);
-    }
-
-    private void readLiteralHeaderWithSubstitutionIndexingIndexedName(int nameIndex)
-        throws IOException {
-      int index = readInt(readByte(), PREFIX_8_BITS);
-      String name = getName(nameIndex);
-      String value = readString();
-      replaceInHeaderTable(index, name, value);
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-      referenceSet.set(index);
-    }
-
-    private void readLiteralHeaderWithSubstitutionIndexingNewName() throws IOException {
-      String name = readString();
-      int index = readInt(readByte(), PREFIX_8_BITS);
-      String value = readString();
-      replaceInHeaderTable(index, name, value);
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-      referenceSet.set(index);
-    }
-
-    private String getName(int index) {
-      return headerTable.get(index * 2);
-    }
-
-    private String getValue(int index) {
-      return headerTable.get(index * 2 + 1);
-    }
-
-    private void appendToHeaderTable(String name, String value) {
-      insertIntoHeaderTable(headerTable.size() * 2, name, value);
-    }
-
-    private void replaceInHeaderTable(int index, String name, String value) {
-      remove(index);
-      insertIntoHeaderTable(index, name, value);
-    }
-
-    private void insertIntoHeaderTable(int index, String name, String value) {
-      // TODO: This needs to be the length in UTF-8 bytes, not the length in chars.
-
-      int delta = 32 + name.length() + value.length();
-
-      // Prune headers to the required length.
-      while (bufferSize + delta > maxBufferSize) {
-        remove(0);
-        index--;
-      }
-
-      if (delta > maxBufferSize) {
-        return; // New values won't fit in the buffer; skip 'em.
-      }
-
-      if (index == 0) index = 0;
-
-      headerTable.add(index * 2, name);
-      headerTable.add(index * 2 + 1, value);
-      bufferSize += delta;
-    }
-
-    private void remove(int index) {
-      String name = headerTable.remove(index * 2);
-      String value = headerTable.remove(index * 2); // No +1 because it's shifted by remove() above.
-      // TODO: This needs to be the length in UTF-8 bytes, not the length in chars.
-      bufferSize -= (32 + name.length() + value.length());
-    }
-
-    private int readByte() throws IOException {
-      bytesLeft--;
-      return in.readByte() & 0xff;
-    }
-
-    int readInt(int firstByte, int prefixMask) throws IOException {
-      int prefix = firstByte & prefixMask;
-      if (prefix < prefixMask) {
-        return prefix; // This was a single byte value.
-      }
-
-      // This is a multibyte value. Read 7 bits at a time.
-      int result = prefixMask;
-      int shift = 0;
-      while (true) {
-        int b = readByte();
-        if ((b & 0x80) != 0) { // Equivalent to (b >= 128) since b is in [0..255].
-          result += (b & 0x7f) << shift;
-          shift += 7;
-        } else {
-          result += b << shift; // Last byte.
-          break;
-        }
-      }
-      return result;
-    }
-
-    /**
-     * Reads a UTF-8 encoded string. Since ASCII is a subset of UTF-8, this method
-     * may be used to read strings that are known to be ASCII-only.
-     */
-    public String readString() throws IOException {
-      int firstByte = readByte();
-      int length = readInt(firstByte, PREFIX_8_BITS);
-      byte[] encoded = new byte[length];
-      bytesLeft -= length;
-      in.readFully(encoded);
-      return new String(encoded, "UTF-8");
-    }
-  }
-
-  static class Writer {
-    private final OutputStream out;
-
-    Writer(OutputStream out) {
-      this.out = out;
-    }
-
-    public void writeHeaders(List<String> nameValueBlock) throws IOException {
-      // TODO: implement a compression strategy.
-      for (int i = 0, size = nameValueBlock.size(); i < size; i += 2) {
-        out.write(0x60); // Literal Header without Indexing - New Name.
-        writeString(nameValueBlock.get(i));
-        writeString(nameValueBlock.get(i + 1));
-      }
-    }
-
-    public void writeInt(int value, int prefixMask, int bits) throws IOException {
-      // Write the raw value for a single byte value.
-      if (value < prefixMask) {
-        out.write(bits | value);
-        return;
-      }
-
-      // Write the mask to start a multibyte value.
-      out.write(bits | prefixMask);
-      value -= prefixMask;
-
-      // Write 7 bits at a time 'til we're done.
-      while (value >= 0x80) {
-        int b = value & 0x7f;
-        out.write(b | 0x80);
-        value >>>= 7;
-      }
-      out.write(value);
-    }
-
-    /**
-     * Writes a UTF-8 encoded string. Since ASCII is a subset of UTF-8, this
-     * method can be used to write strings that are known to be ASCII-only.
-     */
-    public void writeString(String headerName) throws IOException {
-      byte[] bytes = headerName.getBytes("UTF-8");
-      writeInt(bytes.length, PREFIX_8_BITS, 0);
-      out.write(bytes);
-    }
-  }
-}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft04.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft04.java
deleted file mode 100644
index 1d48defe51..0000000000
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft04.java
+++ /dev/null
@@ -1,371 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.spdy;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
-import java.util.Arrays;
-import java.util.List;
-
-final class Http20Draft04 implements Variant {
-  private static final byte[] CONNECTION_HEADER;
-  static {
-    try {
-      CONNECTION_HEADER = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n".getBytes("UTF-8");
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
-  }
-
-  static final int TYPE_DATA = 0x0;
-  static final int TYPE_HEADERS = 0x1;
-  static final int TYPE_PRIORITY = 0x2;
-  static final int TYPE_RST_STREAM = 0x3;
-  static final int TYPE_SETTINGS = 0x4;
-  static final int TYPE_PUSH_PROMISE = 0x5;
-  static final int TYPE_PING = 0x6;
-  static final int TYPE_GOAWAY = 0x7;
-  static final int TYPE_WINDOW_UPDATE = 0x9;
-
-  static final int FLAG_END_STREAM = 0x1;
-  static final int FLAG_END_HEADERS = 0x4;
-  static final int FLAG_PRIORITY = 0x8;
-  static final int FLAG_PONG = 0x1;
-  static final int FLAG_END_FLOW_CONTROL = 0x1;
-
-  @Override public FrameReader newReader(InputStream in, boolean client) {
-    return new Reader(in, client);
-  }
-
-  @Override public FrameWriter newWriter(OutputStream out, boolean client) {
-    return new Writer(out, client);
-  }
-
-  static final class Reader implements FrameReader {
-    private final DataInputStream in;
-    private final boolean client;
-    private final Hpack.Reader hpackReader;
-
-    Reader(InputStream in, boolean client) {
-      this.in = new DataInputStream(in);
-      this.client = client;
-      this.hpackReader = new Hpack.Reader(this.in, client);
-    }
-
-    @Override public void readConnectionHeader() throws IOException {
-      if (client) return; // Nothing to read; servers don't send connection headers!
-      byte[] connectionHeader = new byte[CONNECTION_HEADER.length];
-      in.readFully(connectionHeader);
-      if (!Arrays.equals(connectionHeader, CONNECTION_HEADER)) {
-        throw ioException("Expected a connection header but was "
-            + Arrays.toString(connectionHeader));
-      }
-    }
-
-    @Override public boolean nextFrame(Handler handler) throws IOException {
-      int w1;
-      try {
-        w1 = in.readInt();
-      } catch (IOException e) {
-        return false; // This might be a normal socket close.
-      }
-      int w2 = in.readInt();
-
-      int length = (w1 & 0xffff0000) >> 16;
-      int type = (w1 & 0xff00) >> 8;
-      int flags = w1 & 0xff;
-      // boolean r = (w2 & 0x80000000) != 0; // Reserved.
-      int streamId = (w2 & 0x7fffffff);
-
-      switch (type) {
-        case TYPE_DATA:
-          readData(handler, flags, length, streamId);
-          return true;
-
-        case TYPE_HEADERS:
-          readHeaders(handler, flags, length, streamId);
-          return true;
-
-        case TYPE_PRIORITY:
-          readPriority(handler, flags, length, streamId);
-          return true;
-
-        case TYPE_RST_STREAM:
-          readRstStream(handler, flags, length, streamId);
-          return true;
-
-        case TYPE_SETTINGS:
-          readSettings(handler, flags, length, streamId);
-          return true;
-
-        case TYPE_PUSH_PROMISE:
-          readPushPromise(handler, flags, length, streamId);
-          return true;
-
-        case TYPE_PING:
-          readPing(handler, flags, length, streamId);
-          return true;
-
-        case TYPE_GOAWAY:
-          readGoAway(handler, flags, length, streamId);
-          return true;
-
-        case TYPE_WINDOW_UPDATE:
-          readWindowUpdate(handler, flags, length, streamId);
-          return true;
-      }
-
-      throw new UnsupportedOperationException("TODO");
-    }
-
-    private void readHeaders(Handler handler, int flags, int length, int streamId)
-        throws IOException {
-      if (streamId == 0) throw ioException("TYPE_HEADERS streamId == 0");
-
-      while (true) {
-        hpackReader.readHeaders(length);
-
-        if ((flags & FLAG_END_HEADERS) != 0) {
-          hpackReader.emitReferenceSet();
-          List<String> namesAndValues = hpackReader.getAndReset();
-          boolean inFinished = (flags & FLAG_END_STREAM) != 0;
-          int priority = -1; // TODO: priority
-          handler.headers(false, inFinished, streamId, -1, priority, namesAndValues,
-              HeadersMode.HTTP_20_HEADERS);
-          return;
-        }
-
-        // Read another frame of headers.
-        int w1 = in.readInt();
-        int w2 = in.readInt();
-
-        length = (w1 & 0xffff0000) >> 16;
-        int newType = (w1 & 0xff00) >> 8;
-        flags = w1 & 0xff;
-        // boolean r = (w2 & 0x80000000) != 0; // Reserved.
-        int newStreamId = (w2 & 0x7fffffff);
-
-        if (newType != TYPE_HEADERS) throw ioException("TYPE_HEADERS didn't have FLAG_END_HEADERS");
-        if (newStreamId != streamId) throw ioException("TYPE_HEADERS streamId changed");
-      }
-    }
-
-    private void readData(Handler handler, int flags, int length, int streamId) throws IOException {
-      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
-      handler.data(inFinished, streamId, in, length);
-    }
-
-    private void readPriority(Handler handler, int flags, int length, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_PRIORITY length: %d != 4", length);
-      if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
-      int w1 = in.readInt();
-      // boolean r = (w1 & 0x80000000) != 0; // Reserved.
-      int priority = (w1 & 0x7fffffff);
-      handler.priority(streamId, priority);
-    }
-
-    private void readRstStream(Handler handler, int flags, int length, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
-      if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
-      int errorCodeInt = in.readInt();
-      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
-      }
-      handler.rstStream(streamId, errorCode);
-    }
-
-    private void readSettings(Handler handler, int flags, int length, int streamId)
-        throws IOException {
-      if (length % 8 != 0) throw ioException("TYPE_SETTINGS length %% 8 != 0: %s", length);
-      if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
-      Settings settings = new Settings();
-      for (int i = 0; i < length; i += 8) {
-        int w1 = in.readInt();
-        int value = in.readInt();
-        // int r = (w1 & 0xff000000) >>> 24; // Reserved.
-        int id = w1 & 0xffffff;
-        settings.set(id, 0, value);
-      }
-      handler.settings(false, settings);
-    }
-
-    private void readPushPromise(Handler handler, int flags, int length, int streamId) {
-      // TODO:
-    }
-
-    private void readPing(Handler handler, int flags, int length, int streamId) throws IOException {
-      if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
-      if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
-      int payload1 = in.readInt();
-      int payload2 = in.readInt();
-      boolean reply = (flags & FLAG_PONG) != 0;
-      handler.ping(reply, payload1, payload2);
-    }
-
-    private void readGoAway(Handler handler, int flags, int length, int streamId)
-        throws IOException {
-      if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
-      int lastStreamId = in.readInt();
-      int errorCodeInt = in.readInt();
-      int opaqueDataLength = length - 8;
-      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
-      }
-      if (Util.skipByReading(in, opaqueDataLength) != opaqueDataLength) {
-        throw new IOException("TYPE_GOAWAY opaque data was truncated");
-      }
-      handler.goAway(lastStreamId, errorCode);
-    }
-
-    private void readWindowUpdate(Handler handler, int flags, int length, int streamId)
-        throws IOException {
-      int w1 = in.readInt();
-      // boolean r = (w1 & 0x80000000) != 0; // Reserved.
-      int windowSizeIncrement = (w1 & 0x7fffffff);
-      boolean endFlowControl = (flags & FLAG_END_FLOW_CONTROL) != 0;
-      handler.windowUpdate(streamId, windowSizeIncrement, endFlowControl);
-    }
-
-    private static IOException ioException(String message, Object... args) throws IOException {
-      throw new IOException(String.format(message, args));
-    }
-
-    @Override public void close() throws IOException {
-      in.close();
-    }
-  }
-
-  static final class Writer implements FrameWriter {
-    private final DataOutputStream out;
-    private final boolean client;
-    private final ByteArrayOutputStream hpackBuffer;
-    private final Hpack.Writer hpackWriter;
-
-    Writer(OutputStream out, boolean client) {
-      this.out = new DataOutputStream(out);
-      this.client = client;
-      this.hpackBuffer = new ByteArrayOutputStream();
-      this.hpackWriter = new Hpack.Writer(hpackBuffer);
-    }
-
-    @Override public synchronized void flush() throws IOException {
-      out.flush();
-    }
-
-    @Override public synchronized void connectionHeader() throws IOException {
-      if (!client) return; // Nothing to write; servers don't send connection headers!
-      out.write(CONNECTION_HEADER);
-    }
-
-    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, int priority, int slot, List<String> nameValueBlock)
-        throws IOException {
-      if (inFinished) throw new UnsupportedOperationException();
-      headers(outFinished, streamId, priority, nameValueBlock);
-    }
-
-    @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<String> nameValueBlock) throws IOException {
-      headers(outFinished, streamId, -1, nameValueBlock);
-    }
-
-    @Override public synchronized void headers(int streamId, List<String> nameValueBlock)
-        throws IOException {
-      headers(false, streamId, -1, nameValueBlock);
-    }
-
-    private void headers(boolean outFinished, int streamId, int priority,
-        List<String> nameValueBlock) throws IOException {
-      hpackBuffer.reset();
-      hpackWriter.writeHeaders(nameValueBlock);
-      int type = TYPE_HEADERS;
-      int length = hpackBuffer.size();
-      int flags = FLAG_END_HEADERS;
-      if (outFinished) flags |= FLAG_END_STREAM;
-      if (priority != -1) flags |= FLAG_PRIORITY;
-      out.writeInt((length & 0xffff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
-      out.writeInt(streamId & 0x7fffffff);
-      if (priority != -1) out.writeInt(priority & 0x7fffffff);
-      hpackBuffer.writeTo(out);
-    }
-
-    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
-        throws IOException {
-      throw new UnsupportedOperationException("TODO");
-    }
-
-    @Override public void data(boolean outFinished, int streamId, byte[] data) throws IOException {
-      data(outFinished, streamId, data, 0, data.length);
-    }
-
-    @Override public synchronized void data(boolean outFinished, int streamId, byte[] data,
-        int offset, int byteCount) throws IOException {
-      int type = TYPE_DATA;
-      int flags = 0;
-      if (outFinished) flags |= FLAG_END_STREAM;
-      out.writeInt((byteCount & 0xffff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
-      out.writeInt(streamId & 0x7fffffff);
-      out.write(data, offset, byteCount);
-    }
-
-    @Override public synchronized void settings(Settings settings) throws IOException {
-      int type = TYPE_SETTINGS;
-      int length = settings.size() * 8;
-      int flags = 0;
-      int streamId = 0;
-      out.writeInt((length & 0xffff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
-      out.writeInt(streamId & 0x7fffffff);
-      for (int i = 0; i < Settings.COUNT; i++) {
-        if (!settings.isSet(i)) continue;
-        out.writeInt(i & 0xffffff);
-        out.writeInt(settings.get(i));
-      }
-    }
-
-    @Override public synchronized void noop() throws IOException {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public synchronized void ping(boolean reply, int payload1, int payload2)
-        throws IOException {
-      // TODO
-    }
-
-    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode)
-        throws IOException {
-      // TODO
-    }
-
-    @Override public synchronized void windowUpdate(int streamId, int deltaWindowSize)
-        throws IOException {
-      // TODO
-    }
-
-    @Override public void close() throws IOException {
-      out.close();
-    }
-  }
-}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
deleted file mode 100644
index f6c5533376..0000000000
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ /dev/null
@@ -1,596 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.spdy;
-
-import com.squareup.okhttp.internal.NamedRunnable;
-import com.squareup.okhttp.internal.Util;
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.Socket;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-
-/**
- * A socket connection to a remote peer. A connection hosts streams which can
- * send and receive data.
- *
- * <p>Many methods in this API are <strong>synchronous:</strong> the call is
- * completed before the method returns. This is typical for Java but atypical
- * for SPDY. This is motivated by exception transparency: an IOException that
- * was triggered by a certain caller can be caught and handled by that caller.
- */
-public final class SpdyConnection implements Closeable {
-
-  // Internal state of this connection is guarded by 'this'. No blocking
-  // operations may be performed while holding this lock!
-  //
-  // Socket writes are guarded by frameWriter.
-  //
-  // Socket reads are unguarded but are only made by the reader thread.
-  //
-  // Certain operations (like SYN_STREAM) need to synchronize on both the
-  // frameWriter (to do blocking I/O) and this (to create streams). Such
-  // operations must synchronize on 'this' last. This ensures that we never
-  // wait for a blocking operation while holding 'this'.
-
-  private static final ExecutorService executor = new ThreadPoolExecutor(0,
-      Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
-      Util.daemonThreadFactory("OkHttp SpdyConnection"));
-
-  /** The protocol variant, like SPDY/3 or HTTP-draft-04/2.0. */
-  final Variant variant;
-
-  /** True if this peer initiated the connection. */
-  final boolean client;
-
-  /**
-   * User code to run in response to an incoming stream. Callbacks must not be
-   * run on the callback executor.
-   */
-  private final IncomingStreamHandler handler;
-  private final FrameReader frameReader;
-  private final FrameWriter frameWriter;
-
-  private final Map<Integer, SpdyStream> streams = new HashMap<Integer, SpdyStream>();
-  private final String hostName;
-  private int lastGoodStreamId;
-  private int nextStreamId;
-  private boolean shutdown;
-  private long idleStartTimeNs = System.nanoTime();
-
-  /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
-  private Map<Integer, Ping> pings;
-  private int nextPingId;
-
-  /** Lazily-created settings for the peer. */
-  Settings settings;
-
-  private SpdyConnection(Builder builder) {
-    variant = builder.variant;
-    client = builder.client;
-    handler = builder.handler;
-    frameReader = variant.newReader(builder.in, client);
-    frameWriter = variant.newWriter(builder.out, client);
-    nextStreamId = builder.client ? 1 : 2;
-    nextPingId = builder.client ? 1 : 2;
-
-    hostName = builder.hostName;
-
-    new Thread(new Reader(), "Spdy Reader " + hostName).start();
-  }
-
-  /**
-   * Returns the number of {@link SpdyStream#isOpen() open streams} on this
-   * connection.
-   */
-  public synchronized int openStreamCount() {
-    return streams.size();
-  }
-
-  private synchronized SpdyStream getStream(int id) {
-    return streams.get(id);
-  }
-
-  synchronized SpdyStream removeStream(int streamId) {
-    SpdyStream stream = streams.remove(streamId);
-    if (stream != null && streams.isEmpty()) {
-      setIdle(true);
-    }
-    return stream;
-  }
-
-  private synchronized void setIdle(boolean value) {
-    idleStartTimeNs = value ? System.nanoTime() : 0L;
-  }
-
-  /** Returns true if this connection is idle. */
-  public synchronized boolean isIdle() {
-    return idleStartTimeNs != 0L;
-  }
-
-  /** Returns the time in ns when this connection became idle or 0L if connection is not idle. */
-  public synchronized long getIdleStartTimeNs() {
-    return idleStartTimeNs;
-  }
-
-  /**
-   * Returns a new locally-initiated stream.
-   *
-   * @param out true to create an output stream that we can use to send data
-   *     to the remote peer. Corresponds to {@code FLAG_FIN}.
-   * @param in true to create an input stream that the remote peer can use to
-   *     send data to us. Corresponds to {@code FLAG_UNIDIRECTIONAL}.
-   */
-  public SpdyStream newStream(List<String> requestHeaders, boolean out, boolean in)
-      throws IOException {
-    boolean outFinished = !out;
-    boolean inFinished = !in;
-    int associatedStreamId = 0;  // TODO: permit the caller to specify an associated stream?
-    int priority = 0; // TODO: permit the caller to specify a priority?
-    int slot = 0; // TODO: permit the caller to specify a slot?
-    SpdyStream stream;
-    int streamId;
-
-    synchronized (frameWriter) {
-      synchronized (this) {
-        if (shutdown) {
-          throw new IOException("shutdown");
-        }
-        streamId = nextStreamId;
-        nextStreamId += 2;
-        stream = new SpdyStream(
-            streamId, this, outFinished, inFinished, priority, requestHeaders, settings);
-        if (stream.isOpen()) {
-          streams.put(streamId, stream);
-          setIdle(false);
-        }
-      }
-
-      frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId, priority, slot,
-          requestHeaders);
-    }
-
-    return stream;
-  }
-
-  void writeSynReply(int streamId, boolean outFinished, List<String> alternating)
-      throws IOException {
-    frameWriter.synReply(outFinished, streamId, alternating);
-  }
-
-  public void writeData(int streamId, boolean outFinished, byte[] buffer, int offset, int byteCount)
-      throws IOException {
-    frameWriter.data(outFinished, streamId, buffer, offset, byteCount);
-  }
-
-  void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
-    executor.submit(new NamedRunnable("OkHttp SPDY Writer %s stream %d", hostName, streamId) {
-      @Override public void execute() {
-        try {
-          writeSynReset(streamId, errorCode);
-        } catch (IOException ignored) {
-        }
-      }
-    });
-  }
-
-  void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
-    frameWriter.rstStream(streamId, statusCode);
-  }
-
-  void writeWindowUpdateLater(final int streamId, final int deltaWindowSize) {
-    executor.submit(new NamedRunnable("OkHttp SPDY Writer %s stream %d", hostName, streamId) {
-      @Override public void execute() {
-        try {
-          writeWindowUpdate(streamId, deltaWindowSize);
-        } catch (IOException ignored) {
-        }
-      }
-    });
-  }
-
-  void writeWindowUpdate(int streamId, int deltaWindowSize) throws IOException {
-    frameWriter.windowUpdate(streamId, deltaWindowSize);
-  }
-
-  /**
-   * Sends a ping frame to the peer. Use the returned object to await the
-   * ping's response and observe its round trip time.
-   */
-  public Ping ping() throws IOException {
-    Ping ping = new Ping();
-    int pingId;
-    synchronized (this) {
-      if (shutdown) {
-        throw new IOException("shutdown");
-      }
-      pingId = nextPingId;
-      nextPingId += 2;
-      if (pings == null) pings = new HashMap<Integer, Ping>();
-      pings.put(pingId, ping);
-    }
-    writePing(false, pingId, 0x4f4b6f6b /* ASCII "OKok" */, ping);
-    return ping;
-  }
-
-  private void writePingLater(
-      final boolean reply, final int payload1, final int payload2, final Ping ping) {
-    executor.submit(new NamedRunnable("OkHttp SPDY Writer %s ping %08x%08x",
-        hostName, payload1, payload2) {
-      @Override public void execute() {
-        try {
-          writePing(reply, payload1, payload2, ping);
-        } catch (IOException ignored) {
-        }
-      }
-    });
-  }
-
-  private void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
-    synchronized (frameWriter) {
-      // Observe the sent time immediately before performing I/O.
-      if (ping != null) ping.send();
-      frameWriter.ping(reply, payload1, payload2);
-    }
-  }
-
-  private synchronized Ping removePing(int id) {
-    return pings != null ? pings.remove(id) : null;
-  }
-
-  /** Sends a noop frame to the peer. */
-  public void noop() throws IOException {
-    frameWriter.noop();
-  }
-
-  public void flush() throws IOException {
-    frameWriter.flush();
-  }
-
-  /**
-   * Degrades this connection such that new streams can neither be created
-   * locally, nor accepted from the remote peer. Existing streams are not
-   * impacted. This is intended to permit an endpoint to gracefully stop
-   * accepting new requests without harming previously established streams.
-   */
-  public void shutdown(ErrorCode statusCode) throws IOException {
-    synchronized (frameWriter) {
-      int lastGoodStreamId;
-      synchronized (this) {
-        if (shutdown) {
-          return;
-        }
-        shutdown = true;
-        lastGoodStreamId = this.lastGoodStreamId;
-      }
-      frameWriter.goAway(lastGoodStreamId, statusCode);
-    }
-  }
-
-  /**
-   * Closes this connection. This cancels all open streams and unanswered
-   * pings. It closes the underlying input and output streams and shuts down
-   * internal executor services.
-   */
-  @Override public void close() throws IOException {
-    close(ErrorCode.NO_ERROR, ErrorCode.CANCEL);
-  }
-
-  private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
-    assert (!Thread.holdsLock(this));
-    IOException thrown = null;
-    try {
-      shutdown(connectionCode);
-    } catch (IOException e) {
-      thrown = e;
-    }
-
-    SpdyStream[] streamsToClose = null;
-    Ping[] pingsToCancel = null;
-    synchronized (this) {
-      if (!streams.isEmpty()) {
-        streamsToClose = streams.values().toArray(new SpdyStream[streams.size()]);
-        streams.clear();
-        setIdle(false);
-      }
-      if (pings != null) {
-        pingsToCancel = pings.values().toArray(new Ping[pings.size()]);
-        pings = null;
-      }
-    }
-
-    if (streamsToClose != null) {
-      for (SpdyStream stream : streamsToClose) {
-        try {
-          stream.close(streamCode);
-        } catch (IOException e) {
-          if (thrown != null) thrown = e;
-        }
-      }
-    }
-
-    if (pingsToCancel != null) {
-      for (Ping ping : pingsToCancel) {
-        ping.cancel();
-      }
-    }
-
-    try {
-      frameReader.close();
-    } catch (IOException e) {
-      thrown = e;
-    }
-    try {
-      frameWriter.close();
-    } catch (IOException e) {
-      if (thrown == null) thrown = e;
-    }
-
-    if (thrown != null) throw thrown;
-  }
-
-  /**
-   * Sends a connection header if the current variant requires it. This should
-   * be called after {@link Builder#build} for all new connections.
-   */
-  public void sendConnectionHeader() throws IOException {
-    frameWriter.connectionHeader();
-    frameWriter.settings(new Settings());
-  }
-
-  /**
-   * Reads a connection header if the current variant requires it. This should
-   * be called after {@link Builder#build} for all new connections.
-   */
-  public void readConnectionHeader() throws IOException {
-    frameReader.readConnectionHeader();
-  }
-
-  public static class Builder {
-    private String hostName;
-    private InputStream in;
-    private OutputStream out;
-    private IncomingStreamHandler handler = IncomingStreamHandler.REFUSE_INCOMING_STREAMS;
-    private Variant variant = Variant.SPDY3;
-    private boolean client;
-
-    public Builder(boolean client, Socket socket) throws IOException {
-      this("", client, socket.getInputStream(), socket.getOutputStream());
-    }
-
-    public Builder(boolean client, InputStream in, OutputStream out) {
-      this("", client, in, out);
-    }
-
-    /**
-     * @param client true if this peer initiated the connection; false if
-     * this peer accepted the connection.
-     */
-    public Builder(String hostName, boolean client, Socket socket) throws IOException {
-      this(hostName, client, socket.getInputStream(), socket.getOutputStream());
-    }
-
-    /**
-     * @param client true if this peer initiated the connection; false if this
-     * peer accepted the connection.
-     */
-    public Builder(String hostName, boolean client, InputStream in, OutputStream out) {
-      this.hostName = hostName;
-      this.client = client;
-      this.in = in;
-      this.out = out;
-    }
-
-    public Builder handler(IncomingStreamHandler handler) {
-      this.handler = handler;
-      return this;
-    }
-
-    public Builder spdy3() {
-      this.variant = Variant.SPDY3;
-      return this;
-    }
-
-    public Builder http20Draft04() {
-      this.variant = Variant.HTTP_20_DRAFT_04;
-      return this;
-    }
-
-    public SpdyConnection build() {
-      return new SpdyConnection(this);
-    }
-  }
-
-  private class Reader implements Runnable, FrameReader.Handler {
-    @Override public void run() {
-      ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
-      ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
-      try {
-        while (frameReader.nextFrame(this)) {
-        }
-        connectionErrorCode = ErrorCode.NO_ERROR;
-        streamErrorCode = ErrorCode.CANCEL;
-      } catch (IOException e) {
-        connectionErrorCode = ErrorCode.PROTOCOL_ERROR;
-        streamErrorCode = ErrorCode.PROTOCOL_ERROR;
-      } finally {
-        try {
-          close(connectionErrorCode, streamErrorCode);
-        } catch (IOException ignored) {
-        }
-      }
-    }
-
-    @Override public void data(boolean inFinished, int streamId, InputStream in, int length)
-        throws IOException {
-      SpdyStream dataStream = getStream(streamId);
-      if (dataStream == null) {
-        writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
-        Util.skipByReading(in, length);
-        return;
-      }
-      dataStream.receiveData(in, length);
-      if (inFinished) {
-        dataStream.receiveFin();
-      }
-    }
-
-    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<String> nameValueBlock,
-        HeadersMode headersMode) {
-      SpdyStream stream;
-      synchronized (SpdyConnection.this) {
-        // If we're shutdown, don't bother with this stream.
-        if (shutdown) return;
-
-        stream = getStream(streamId);
-
-        if (stream == null) {
-          // The headers claim to be for an existing stream, but we don't have one.
-          if (headersMode.failIfStreamAbsent()) {
-            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
-            return;
-          }
-
-          // If the stream ID is less than the last created ID, assume it's already closed.
-          if (streamId <= lastGoodStreamId) return;
-
-          // If the stream ID is in the client's namespace, assume it's already closed.
-          if (streamId % 2 == nextStreamId % 2) return;
-
-          // Create a stream.
-          final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,
-              inFinished, priority, nameValueBlock, settings);
-          lastGoodStreamId = streamId;
-          streams.put(streamId, newStream);
-          executor.submit(new NamedRunnable("OkHttp Callback %s stream %d", hostName, streamId) {
-            @Override public void execute() {
-              try {
-                handler.receive(newStream);
-              } catch (IOException e) {
-                throw new RuntimeException(e);
-              }
-            }
-          });
-          return;
-        }
-      }
-
-      // The headers claim to be for a new stream, but we already have one.
-      if (headersMode.failIfStreamPresent()) {
-        stream.closeLater(ErrorCode.PROTOCOL_ERROR);
-        removeStream(streamId);
-        return;
-      }
-
-      // Update an existing stream.
-      stream.receiveHeaders(nameValueBlock, headersMode);
-      if (inFinished) stream.receiveFin();
-    }
-
-    @Override public void rstStream(int streamId, ErrorCode errorCode) {
-      SpdyStream rstStream = removeStream(streamId);
-      if (rstStream != null) {
-        rstStream.receiveRstStream(errorCode);
-      }
-    }
-
-    @Override public void settings(boolean clearPrevious, Settings newSettings) {
-      SpdyStream[] streamsToNotify = null;
-      synchronized (SpdyConnection.this) {
-        if (settings == null || clearPrevious) {
-          settings = newSettings;
-        } else {
-          settings.merge(newSettings);
-        }
-        if (!streams.isEmpty()) {
-          streamsToNotify = streams.values().toArray(new SpdyStream[streams.size()]);
-        }
-      }
-      if (streamsToNotify != null) {
-        for (SpdyStream stream : streamsToNotify) {
-          // The synchronization here is ugly. We need to synchronize on 'this' to guard
-          // reads to 'settings'. We synchronize on 'stream' to guard the state change.
-          // And we need to acquire the 'stream' lock first, since that may block.
-          // TODO: this can block the reader thread until a write completes. That's bad!
-          synchronized (stream) {
-            synchronized (SpdyConnection.this) {
-              stream.receiveSettings(settings);
-            }
-          }
-        }
-      }
-    }
-
-    @Override public void noop() {
-    }
-
-    @Override public void ping(boolean reply, int payload1, int payload2) {
-      if (reply) {
-        Ping ping = removePing(payload1);
-        if (ping != null) {
-          ping.receive();
-        }
-      } else {
-        // Send a reply to a client ping if this is a server and vice versa.
-        writePingLater(true, payload1, payload2, null);
-      }
-    }
-
-    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode) {
-      synchronized (SpdyConnection.this) {
-        shutdown = true;
-
-        // Fail all streams created after the last good stream ID.
-        for (Iterator<Map.Entry<Integer, SpdyStream>> i = streams.entrySet().iterator();
-            i.hasNext(); ) {
-          Map.Entry<Integer, SpdyStream> entry = i.next();
-          int streamId = entry.getKey();
-          if (streamId > lastGoodStreamId && entry.getValue().isLocallyInitiated()) {
-            entry.getValue().receiveRstStream(ErrorCode.REFUSED_STREAM);
-            i.remove();
-          }
-        }
-      }
-    }
-
-    @Override public void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl) {
-      if (streamId == 0) {
-        // TODO: honor whole-stream flow control
-        return;
-      }
-
-      // TODO: honor endFlowControl
-      SpdyStream stream = getStream(streamId);
-      if (stream != null) {
-        stream.receiveWindowUpdate(deltaWindowSize);
-      }
-    }
-
-    @Override public void priority(int streamId, int priority) {
-      // TODO: honor priority.
-    }
-  }
-}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
deleted file mode 100644
index e550022030..0000000000
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ /dev/null
@@ -1,670 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.spdy;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InterruptedIOException;
-import java.io.OutputStream;
-import java.net.SocketTimeoutException;
-import java.util.ArrayList;
-import java.util.List;
-
-import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
-
-/** A logical bidirectional stream. */
-public final class SpdyStream {
-
-  // Internal state is guarded by this. No long-running or potentially
-  // blocking operations are performed while the lock is held.
-
-  /**
-   * The number of unacknowledged bytes at which the input stream will send
-   * the peer a {@code WINDOW_UPDATE} frame. Must be less than this client's
-   * window size, otherwise the remote peer will stop sending data on this
-   * stream. (Chrome 25 uses 5 MiB.)
-   */
-  public static final int WINDOW_UPDATE_THRESHOLD = Settings.DEFAULT_INITIAL_WINDOW_SIZE / 2;
-
-  private final int id;
-  private final SpdyConnection connection;
-  private final int priority;
-  private long readTimeoutMillis = 0;
-  private int writeWindowSize;
-
-  /** Headers sent by the stream initiator. Immutable and non null. */
-  private final List<String> requestHeaders;
-
-  /** Headers sent in the stream reply. Null if reply is either not sent or not sent yet. */
-  private List<String> responseHeaders;
-
-  private final SpdyDataInputStream in = new SpdyDataInputStream();
-  private final SpdyDataOutputStream out = new SpdyDataOutputStream();
-
-  /**
-   * The reason why this stream was abnormally closed. If there are multiple
-   * reasons to abnormally close this stream (such as both peers closing it
-   * near-simultaneously) then this is the first reason known to this peer.
-   */
-  private ErrorCode errorCode = null;
-
-  SpdyStream(int id, SpdyConnection connection, boolean outFinished, boolean inFinished,
-      int priority, List<String> requestHeaders, Settings settings) {
-    if (connection == null) throw new NullPointerException("connection == null");
-    if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
-    this.id = id;
-    this.connection = connection;
-    this.in.finished = inFinished;
-    this.out.finished = outFinished;
-    this.priority = priority;
-    this.requestHeaders = requestHeaders;
-
-    setSettings(settings);
-  }
-
-  /**
-   * Returns true if this stream is open. A stream is open until either:
-   * <ul>
-   * <li>A {@code SYN_RESET} frame abnormally terminates the stream.
-   * <li>Both input and output streams have transmitted all data and
-   * headers.
-   * </ul>
-   * Note that the input stream may continue to yield data even after a stream
-   * reports itself as not open. This is because input data is buffered.
-   */
-  public synchronized boolean isOpen() {
-    if (errorCode != null) {
-      return false;
-    }
-    if ((in.finished || in.closed) && (out.finished || out.closed) && responseHeaders != null) {
-      return false;
-    }
-    return true;
-  }
-
-  /** Returns true if this stream was created by this peer. */
-  public boolean isLocallyInitiated() {
-    boolean streamIsClient = (id % 2 == 1);
-    return connection.client == streamIsClient;
-  }
-
-  public SpdyConnection getConnection() {
-    return connection;
-  }
-
-  public List<String> getRequestHeaders() {
-    return requestHeaders;
-  }
-
-  /**
-   * Returns the stream's response headers, blocking if necessary if they
-   * have not been received yet.
-   */
-  public synchronized List<String> getResponseHeaders() throws IOException {
-    try {
-      while (responseHeaders == null && errorCode == null) {
-        wait();
-      }
-      if (responseHeaders != null) {
-        return responseHeaders;
-      }
-      throw new IOException("stream was reset: " + errorCode);
-    } catch (InterruptedException e) {
-      InterruptedIOException rethrow = new InterruptedIOException();
-      rethrow.initCause(e);
-      throw rethrow;
-    }
-  }
-
-  /**
-   * Returns the reason why this stream was closed, or null if it closed
-   * normally or has not yet been closed.
-   */
-  public synchronized ErrorCode getErrorCode() {
-    return errorCode;
-  }
-
-  /**
-   * Sends a reply to an incoming stream.
-   *
-   * @param out true to create an output stream that we can use to send data
-   * to the remote peer. Corresponds to {@code FLAG_FIN}.
-   */
-  public void reply(List<String> responseHeaders, boolean out) throws IOException {
-    assert (!Thread.holdsLock(SpdyStream.this));
-    boolean outFinished = false;
-    synchronized (this) {
-      if (responseHeaders == null) {
-        throw new NullPointerException("responseHeaders == null");
-      }
-      if (isLocallyInitiated()) {
-        throw new IllegalStateException("cannot reply to a locally initiated stream");
-      }
-      if (this.responseHeaders != null) {
-        throw new IllegalStateException("reply already sent");
-      }
-      this.responseHeaders = responseHeaders;
-      if (!out) {
-        this.out.finished = true;
-        outFinished = true;
-      }
-    }
-    connection.writeSynReply(id, outFinished, responseHeaders);
-  }
-
-  /**
-   * Sets the maximum time to wait on input stream reads before failing with a
-   * {@code SocketTimeoutException}, or {@code 0} to wait indefinitely.
-   */
-  public void setReadTimeout(long readTimeoutMillis) {
-    this.readTimeoutMillis = readTimeoutMillis;
-  }
-
-  public long getReadTimeoutMillis() {
-    return readTimeoutMillis;
-  }
-
-  /** Returns an input stream that can be used to read data from the peer. */
-  public InputStream getInputStream() {
-    return in;
-  }
-
-  /**
-   * Returns an output stream that can be used to write data to the peer.
-   *
-   * @throws IllegalStateException if this stream was initiated by the peer
-   * and a {@link #reply} has not yet been sent.
-   */
-  public OutputStream getOutputStream() {
-    synchronized (this) {
-      if (responseHeaders == null && !isLocallyInitiated()) {
-        throw new IllegalStateException("reply before requesting the output stream");
-      }
-    }
-    return out;
-  }
-
-  /**
-   * Abnormally terminate this stream. This blocks until the {@code RST_STREAM}
-   * frame has been transmitted.
-   */
-  public void close(ErrorCode rstStatusCode) throws IOException {
-    if (!closeInternal(rstStatusCode)) {
-      return; // Already closed.
-    }
-    connection.writeSynReset(id, rstStatusCode);
-  }
-
-  /**
-   * Abnormally terminate this stream. This enqueues a {@code RST_STREAM}
-   * frame and returns immediately.
-   */
-  public void closeLater(ErrorCode errorCode) {
-    if (!closeInternal(errorCode)) {
-      return; // Already closed.
-    }
-    connection.writeSynResetLater(id, errorCode);
-  }
-
-  /** Returns true if this stream was closed. */
-  private boolean closeInternal(ErrorCode errorCode) {
-    assert (!Thread.holdsLock(this));
-    synchronized (this) {
-      if (this.errorCode != null) {
-        return false;
-      }
-      if (in.finished && out.finished) {
-        return false;
-      }
-      this.errorCode = errorCode;
-      notifyAll();
-    }
-    connection.removeStream(id);
-    return true;
-  }
-
-  void receiveHeaders(List<String> headers, HeadersMode headersMode) {
-    assert (!Thread.holdsLock(SpdyStream.this));
-    ErrorCode errorCode = null;
-    boolean open = true;
-    synchronized (this) {
-      if (responseHeaders == null) {
-        if (headersMode.failIfHeadersAbsent()) {
-          errorCode = ErrorCode.PROTOCOL_ERROR;
-        } else {
-          responseHeaders = headers;
-          open = isOpen();
-          notifyAll();
-        }
-      } else {
-        if (headersMode.failIfHeadersPresent()) {
-          errorCode = ErrorCode.STREAM_IN_USE;
-        } else {
-          List<String> newHeaders = new ArrayList<String>();
-          newHeaders.addAll(responseHeaders);
-          newHeaders.addAll(headers);
-          this.responseHeaders = newHeaders;
-        }
-      }
-    }
-    if (errorCode != null) {
-      closeLater(errorCode);
-    } else if (!open) {
-      connection.removeStream(id);
-    }
-  }
-
-  void receiveData(InputStream in, int length) throws IOException {
-    assert (!Thread.holdsLock(SpdyStream.this));
-    this.in.receive(in, length);
-  }
-
-  void receiveFin() {
-    assert (!Thread.holdsLock(SpdyStream.this));
-    boolean open;
-    synchronized (this) {
-      this.in.finished = true;
-      open = isOpen();
-      notifyAll();
-    }
-    if (!open) {
-      connection.removeStream(id);
-    }
-  }
-
-  synchronized void receiveRstStream(ErrorCode errorCode) {
-    if (this.errorCode == null) {
-      this.errorCode = errorCode;
-      notifyAll();
-    }
-  }
-
-  private void setSettings(Settings settings) {
-    // TODO: For HTTP/2.0, also adjust the stream flow control window size
-    // by the difference between the new value and the old value.
-    assert (Thread.holdsLock(connection)); // Because 'settings' is guarded by 'connection'.
-    this.writeWindowSize = settings != null
-        ? settings.getInitialWindowSize(Settings.DEFAULT_INITIAL_WINDOW_SIZE)
-        : Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-  }
-
-  void receiveSettings(Settings settings) {
-    assert (Thread.holdsLock(this));
-    setSettings(settings);
-    notifyAll();
-  }
-
-  synchronized void receiveWindowUpdate(int deltaWindowSize) {
-    out.unacknowledgedBytes -= deltaWindowSize;
-    notifyAll();
-  }
-
-  int getPriority() {
-    return priority;
-  }
-
-  /**
-   * An input stream that reads the incoming data frames of a stream. Although
-   * this class uses synchronization to safely receive incoming data frames,
-   * it is not intended for use by multiple readers.
-   */
-  private final class SpdyDataInputStream extends InputStream {
-    // Store incoming data bytes in a circular buffer. When the buffer is
-    // empty, pos == -1. Otherwise pos is the first byte to read and limit
-    // is the first byte to write.
-    //
-    // { - - - X X X X - - - }
-    //         ^       ^
-    //        pos    limit
-    //
-    // { X X X - - - - X X X }
-    //         ^       ^
-    //       limit    pos
-
-    private final byte[] buffer = new byte[Settings.DEFAULT_INITIAL_WINDOW_SIZE];
-
-    /** the next byte to be read, or -1 if the buffer is empty. Never buffer.length */
-    private int pos = -1;
-
-    /** the last byte to be read. Never buffer.length */
-    private int limit;
-
-    /** True if the caller has closed this stream. */
-    private boolean closed;
-
-    /**
-     * True if either side has cleanly shut down this stream. We will
-     * receive no more bytes beyond those already in the buffer.
-     */
-    private boolean finished;
-
-    /**
-     * The total number of bytes consumed by the application (with {@link
-     * #read}), but not yet acknowledged by sending a {@code WINDOW_UPDATE}
-     * frame.
-     */
-    private int unacknowledgedBytes = 0;
-
-    @Override public int available() throws IOException {
-      synchronized (SpdyStream.this) {
-        checkNotClosed();
-        if (pos == -1) {
-          return 0;
-        } else if (limit > pos) {
-          return limit - pos;
-        } else {
-          return limit + (buffer.length - pos);
-        }
-      }
-    }
-
-    @Override public int read() throws IOException {
-      return Util.readSingleByte(this);
-    }
-
-    @Override public int read(byte[] b, int offset, int count) throws IOException {
-      synchronized (SpdyStream.this) {
-        checkOffsetAndCount(b.length, offset, count);
-        waitUntilReadable();
-        checkNotClosed();
-
-        if (pos == -1) {
-          return -1;
-        }
-
-        int copied = 0;
-
-        // drain from [pos..buffer.length)
-        if (limit <= pos) {
-          int bytesToCopy = Math.min(count, buffer.length - pos);
-          System.arraycopy(buffer, pos, b, offset, bytesToCopy);
-          pos += bytesToCopy;
-          copied += bytesToCopy;
-          if (pos == buffer.length) {
-            pos = 0;
-          }
-        }
-
-        // drain from [pos..limit)
-        if (copied < count) {
-          int bytesToCopy = Math.min(limit - pos, count - copied);
-          System.arraycopy(buffer, pos, b, offset + copied, bytesToCopy);
-          pos += bytesToCopy;
-          copied += bytesToCopy;
-        }
-
-        // Flow control: notify the peer that we're ready for more data!
-        unacknowledgedBytes += copied;
-        if (unacknowledgedBytes >= WINDOW_UPDATE_THRESHOLD) {
-          connection.writeWindowUpdateLater(id, unacknowledgedBytes);
-          unacknowledgedBytes = 0;
-        }
-
-        if (pos == limit) {
-          pos = -1;
-          limit = 0;
-        }
-
-        return copied;
-      }
-    }
-
-    /**
-     * Returns once the input stream is either readable or finished. Throws
-     * a {@link SocketTimeoutException} if the read timeout elapses before
-     * that happens.
-     */
-    private void waitUntilReadable() throws IOException {
-      long start = 0;
-      long remaining = 0;
-      if (readTimeoutMillis != 0) {
-        start = (System.nanoTime() / 1000000);
-        remaining = readTimeoutMillis;
-      }
-      try {
-        while (pos == -1 && !finished && !closed && errorCode == null) {
-          if (readTimeoutMillis == 0) {
-            SpdyStream.this.wait();
-          } else if (remaining > 0) {
-            SpdyStream.this.wait(remaining);
-            remaining = start + readTimeoutMillis - (System.nanoTime() / 1000000);
-          } else {
-            throw new SocketTimeoutException();
-          }
-        }
-      } catch (InterruptedException e) {
-        throw new InterruptedIOException();
-      }
-    }
-
-    void receive(InputStream in, int byteCount) throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
-
-      if (byteCount == 0) {
-        return;
-      }
-
-      int pos;
-      int limit;
-      int firstNewByte;
-      boolean finished;
-      boolean flowControlError;
-      synchronized (SpdyStream.this) {
-        finished = this.finished;
-        pos = this.pos;
-        firstNewByte = this.limit;
-        limit = this.limit;
-        flowControlError = byteCount > buffer.length - available();
-      }
-
-      // If the peer sends more data than we can handle, discard it and close the connection.
-      if (flowControlError) {
-        Util.skipByReading(in, byteCount);
-        closeLater(ErrorCode.FLOW_CONTROL_ERROR);
-        return;
-      }
-
-      // Discard data received after the stream is finished. It's probably a benign race.
-      if (finished) {
-        Util.skipByReading(in, byteCount);
-        return;
-      }
-
-      // Fill the buffer without holding any locks. First fill [limit..buffer.length) if that
-      // won't overwrite unread data. Then fill [limit..pos). We can't hold a lock, otherwise
-      // writes will be blocked until reads complete.
-      if (pos < limit) {
-        int firstCopyCount = Math.min(byteCount, buffer.length - limit);
-        Util.readFully(in, buffer, limit, firstCopyCount);
-        limit += firstCopyCount;
-        byteCount -= firstCopyCount;
-        if (limit == buffer.length) {
-          limit = 0;
-        }
-      }
-      if (byteCount > 0) {
-        Util.readFully(in, buffer, limit, byteCount);
-        limit += byteCount;
-      }
-
-      synchronized (SpdyStream.this) {
-        // Update the new limit, and mark the position as readable if necessary.
-        this.limit = limit;
-        if (this.pos == -1) {
-          this.pos = firstNewByte;
-          SpdyStream.this.notifyAll();
-        }
-      }
-    }
-
-    @Override public void close() throws IOException {
-      synchronized (SpdyStream.this) {
-        closed = true;
-        SpdyStream.this.notifyAll();
-      }
-      cancelStreamIfNecessary();
-    }
-
-    private void checkNotClosed() throws IOException {
-      if (closed) {
-        throw new IOException("stream closed");
-      }
-      if (errorCode != null) {
-        throw new IOException("stream was reset: " + errorCode);
-      }
-    }
-  }
-
-  private void cancelStreamIfNecessary() throws IOException {
-    assert (!Thread.holdsLock(SpdyStream.this));
-    boolean open;
-    boolean cancel;
-    synchronized (this) {
-      cancel = !in.finished && in.closed && (out.finished || out.closed);
-      open = isOpen();
-    }
-    if (cancel) {
-      // RST this stream to prevent additional data from being sent. This
-      // is safe because the input stream is closed (we won't use any
-      // further bytes) and the output stream is either finished or closed
-      // (so RSTing both streams doesn't cause harm).
-      SpdyStream.this.close(ErrorCode.CANCEL);
-    } else if (!open) {
-      connection.removeStream(id);
-    }
-  }
-
-  /**
-   * An output stream that writes outgoing data frames of a stream. This class
-   * is not thread safe.
-   */
-  private final class SpdyDataOutputStream extends OutputStream {
-    private final byte[] buffer = new byte[8192];
-    private int pos = 0;
-
-    /** True if the caller has closed this stream. */
-    private boolean closed;
-
-    /**
-     * True if either side has cleanly shut down this stream. We shall send
-     * no more bytes.
-     */
-    private boolean finished;
-
-    /**
-     * The total number of bytes written out to the peer, but not yet
-     * acknowledged with an incoming {@code WINDOW_UPDATE} frame. Writes
-     * block if they cause this to exceed the {@code WINDOW_SIZE}.
-     */
-    private int unacknowledgedBytes = 0;
-
-    @Override public void write(int b) throws IOException {
-      Util.writeSingleByte(this, b);
-    }
-
-    @Override public void write(byte[] bytes, int offset, int count) throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
-      checkOffsetAndCount(bytes.length, offset, count);
-      checkNotClosed();
-
-      while (count > 0) {
-        if (pos == buffer.length) {
-          writeFrame(false);
-        }
-        int bytesToCopy = Math.min(count, buffer.length - pos);
-        System.arraycopy(bytes, offset, buffer, pos, bytesToCopy);
-        pos += bytesToCopy;
-        offset += bytesToCopy;
-        count -= bytesToCopy;
-      }
-    }
-
-    @Override public void flush() throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
-      checkNotClosed();
-      if (pos > 0) {
-        writeFrame(false);
-        connection.flush();
-      }
-    }
-
-    @Override public void close() throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
-      synchronized (SpdyStream.this) {
-        if (closed) {
-          return;
-        }
-        closed = true;
-      }
-      if (!out.finished) {
-        writeFrame(true);
-      }
-      connection.flush();
-      cancelStreamIfNecessary();
-    }
-
-    private void writeFrame(boolean outFinished) throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
-
-      int length = pos;
-      synchronized (SpdyStream.this) {
-        waitUntilWritable(length, outFinished);
-        unacknowledgedBytes += length;
-      }
-      connection.writeData(id, outFinished, buffer, 0, pos);
-      pos = 0;
-    }
-
-    /**
-     * Returns once the peer is ready to receive {@code count} bytes.
-     *
-     * @throws IOException if the stream was finished or closed, or the
-     * thread was interrupted.
-     */
-    private void waitUntilWritable(int count, boolean last) throws IOException {
-      try {
-        while (unacknowledgedBytes + count >= writeWindowSize) {
-          SpdyStream.this.wait(); // Wait until we receive a WINDOW_UPDATE.
-
-          // The stream may have been closed or reset while we were waiting!
-          if (!last && closed) {
-            throw new IOException("stream closed");
-          } else if (finished) {
-            throw new IOException("stream finished");
-          } else if (errorCode != null) {
-            throw new IOException("stream was reset: " + errorCode);
-          }
-        }
-      } catch (InterruptedException e) {
-        throw new InterruptedIOException();
-      }
-    }
-
-    private void checkNotClosed() throws IOException {
-      synchronized (SpdyStream.this) {
-        if (closed) {
-          throw new IOException("stream closed");
-        } else if (finished) {
-          throw new IOException("stream finished");
-        } else if (errorCode != null) {
-          throw new IOException("stream was reset: " + errorCode);
-        }
-      }
-    }
-  }
-}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackTest.java
deleted file mode 100644
index 0bcadce36e..0000000000
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackTest.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.spdy;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-public class HpackTest {
-  private ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-  private final Hpack.Writer hpackWriter = new Hpack.Writer(new DataOutputStream(bytesOut));
-
-  @Test public void readSingleByteInt() throws IOException {
-    assertEquals(10, new Hpack.Reader(byteStream(), true).readInt(10, 31));
-    assertEquals(10, new Hpack.Reader(byteStream(), true).readInt(0xe0 | 10, 31));
-  }
-
-  @Test public void readMultibyteInt() throws IOException {
-    assertEquals(1337, new Hpack.Reader(byteStream(154, 10), true).readInt(31, 31));
-  }
-
-  @Test public void writeSingleByteInt() throws IOException {
-    hpackWriter.writeInt(10, 31, 0);
-    assertBytes(10);
-    hpackWriter.writeInt(10, 31, 0xe0);
-    assertBytes(0xe0 | 10);
-  }
-
-  @Test public void writeMultibyteInt() throws IOException {
-    hpackWriter.writeInt(1337, 31, 0);
-    assertBytes(31, 154, 10);
-    hpackWriter.writeInt(1337, 31, 0xe0);
-    assertBytes(0xe0 | 31, 154, 10);
-  }
-
-  @Test public void max31BitValue() throws IOException {
-    hpackWriter.writeInt(0x7fffffff, 31, 0);
-    assertBytes(31, 224, 255, 255, 255, 7);
-    assertEquals(0x7fffffff,
-        new Hpack.Reader(byteStream(224, 255, 255, 255, 7), true).readInt(31, 31));
-  }
-
-  @Test public void prefixMask() throws IOException {
-    hpackWriter.writeInt(31, 31, 0);
-    assertBytes(31, 0);
-    assertEquals(31, new Hpack.Reader(byteStream(0), true).readInt(31, 31));
-  }
-
-  @Test public void prefixMaskMinusOne() throws IOException {
-    hpackWriter.writeInt(30, 31, 0);
-    assertBytes(30);
-    assertEquals(31, new Hpack.Reader(byteStream(0), true).readInt(31, 31));
-  }
-
-  @Test public void zero() throws IOException {
-    hpackWriter.writeInt(0, 31, 0);
-    assertBytes(0);
-    assertEquals(0, new Hpack.Reader(byteStream(), true).readInt(0, 31));
-  }
-
-  @Test public void headerName() throws IOException {
-    hpackWriter.writeString("foo");
-    assertBytes(3, 'f', 'o', 'o');
-    assertEquals("foo", new Hpack.Reader(byteStream(3, 'f', 'o', 'o'), true).readString());
-  }
-
-  @Test public void emptyHeaderName() throws IOException {
-    hpackWriter.writeString("");
-    assertBytes(0);
-    assertEquals("", new Hpack.Reader(byteStream(0), true).readString());
-  }
-
-  @Test public void headersRoundTrip() throws IOException {
-    List<String> sentHeaders = Arrays.asList("name", "value");
-    hpackWriter.writeHeaders(sentHeaders);
-    ByteArrayInputStream bytesIn = new ByteArrayInputStream(bytesOut.toByteArray());
-    Hpack.Reader reader = new Hpack.Reader(new DataInputStream(bytesIn), true);
-    reader.readHeaders(bytesOut.size());
-    reader.emitReferenceSet();
-    List<String> receivedHeaders = reader.getAndReset();
-    assertEquals(sentHeaders, receivedHeaders);
-  }
-
-  private DataInputStream byteStream(int... bytes) {
-    byte[] data = intArrayToByteArray(bytes);
-    return new DataInputStream(new ByteArrayInputStream(data));
-  }
-
-  private void assertBytes(int... bytes) {
-    byte[] expected = intArrayToByteArray(bytes);
-    byte[] actual = bytesOut.toByteArray();
-    assertEquals(Arrays.toString(expected), Arrays.toString(actual));
-    bytesOut.reset(); // So the next test starts with a clean slate.
-  }
-
-  private byte[] intArrayToByteArray(int[] bytes) {
-    byte[] data = new byte[bytes.length];
-    for (int i = 0; i < bytes.length; i++) {
-      data[i] = (byte) bytes[i];
-    }
-    return data;
-  }
-}
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
new file mode 100644
index 0000000000..face99dad8
--- /dev/null
+++ b/okhttp-tests/pom.xml
@@ -0,0 +1,56 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.3.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-tests</artifactId>
+  <name>OkHttp Tests</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-urlconnection</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <!-- Do not deploy this as an artifact to Maven central. -->
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-deploy-plugin</artifactId>
+        <configuration>
+          <skip>true</skip>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/AddressTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/AddressTest.java
new file mode 100644
index 0000000000..44c39a810e
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/AddressTest.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
+import com.squareup.okhttp.internal.http.RecordingProxySelector;
+import java.util.List;
+import javax.net.SocketFactory;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+public final class AddressTest {
+  private SocketFactory socketFactory = SocketFactory.getDefault();
+  private Authenticator authenticator = AuthenticatorAdapter.INSTANCE;
+  private List<Protocol> protocols = Util.immutableList(Protocol.HTTP_1_1);
+  private List<ConnectionSpec> connectionSpecs = Util.immutableList(ConnectionSpec.MODERN_TLS);
+  private RecordingProxySelector proxySelector = new RecordingProxySelector();
+
+  @Test public void equalsAndHashcode() throws Exception {
+    Address a = new Address("square.com", 80, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, proxySelector);
+    Address b = new Address("square.com", 80, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, proxySelector);
+    assertEquals(a, b);
+    assertEquals(a.hashCode(), b.hashCode());
+  }
+
+  @Test public void differentProxySelectorsAreDifferent() throws Exception {
+    Address a = new Address("square.com", 80, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
+    Address b = new Address("square.com", 80, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
+    assertFalse(a.equals(b));
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheControlTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheControlTest.java
new file mode 100644
index 0000000000..7962ef3226
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheControlTest.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.util.concurrent.TimeUnit;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CacheControlTest {
+  @Test public void emptyBuilderIsEmpty() throws Exception {
+    CacheControl cacheControl = new CacheControl.Builder().build();
+    assertEquals("", cacheControl.toString());
+    assertFalse(cacheControl.noCache());
+    assertFalse(cacheControl.noStore());
+    assertEquals(-1, cacheControl.maxAgeSeconds());
+    assertEquals(-1, cacheControl.sMaxAgeSeconds());
+    assertFalse(cacheControl.isPublic());
+    assertFalse(cacheControl.mustRevalidate());
+    assertEquals(-1, cacheControl.maxStaleSeconds());
+    assertEquals(-1, cacheControl.minFreshSeconds());
+    assertFalse(cacheControl.onlyIfCached());
+    assertFalse(cacheControl.mustRevalidate());
+  }
+
+  @Test public void completeBuilder() throws Exception {
+    CacheControl cacheControl = new CacheControl.Builder()
+        .noCache()
+        .noStore()
+        .maxAge(1, TimeUnit.SECONDS)
+        .maxStale(2, TimeUnit.SECONDS)
+        .minFresh(3, TimeUnit.SECONDS)
+        .onlyIfCached()
+        .noTransform()
+        .build();
+    assertEquals("no-cache, no-store, max-age=1, max-stale=2, min-fresh=3, only-if-cached, "
+        + "no-transform", cacheControl.toString());
+    assertTrue(cacheControl.noCache());
+    assertTrue(cacheControl.noStore());
+    assertEquals(1, cacheControl.maxAgeSeconds());
+    assertEquals(2, cacheControl.maxStaleSeconds());
+    assertEquals(3, cacheControl.minFreshSeconds());
+    assertTrue(cacheControl.onlyIfCached());
+
+    // These members are accessible to response headers only.
+    assertEquals(-1, cacheControl.sMaxAgeSeconds());
+    assertFalse(cacheControl.isPublic());
+    assertFalse(cacheControl.mustRevalidate());
+  }
+
+  @Test public void parseEmpty() throws Exception {
+    CacheControl cacheControl = CacheControl.parse(
+        new Headers.Builder().set("Cache-Control", "").build());
+    assertEquals("", cacheControl.toString());
+    assertFalse(cacheControl.noCache());
+    assertFalse(cacheControl.noStore());
+    assertEquals(-1, cacheControl.maxAgeSeconds());
+    assertEquals(-1, cacheControl.sMaxAgeSeconds());
+    assertFalse(cacheControl.isPublic());
+    assertFalse(cacheControl.mustRevalidate());
+    assertEquals(-1, cacheControl.maxStaleSeconds());
+    assertEquals(-1, cacheControl.minFreshSeconds());
+    assertFalse(cacheControl.onlyIfCached());
+    assertFalse(cacheControl.mustRevalidate());
+  }
+
+  @Test public void parse() throws Exception {
+    String header = "no-cache, no-store, max-age=1, s-maxage=2, public, must-revalidate, "
+        + "max-stale=3, min-fresh=4, only-if-cached, no-transform";
+    CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
+        .set("Cache-Control", header)
+        .build());
+    assertTrue(cacheControl.noCache());
+    assertTrue(cacheControl.noStore());
+    assertEquals(1, cacheControl.maxAgeSeconds());
+    assertEquals(2, cacheControl.sMaxAgeSeconds());
+    assertTrue(cacheControl.isPublic());
+    assertTrue(cacheControl.mustRevalidate());
+    assertEquals(3, cacheControl.maxStaleSeconds());
+    assertEquals(4, cacheControl.minFreshSeconds());
+    assertTrue(cacheControl.onlyIfCached());
+    assertTrue(cacheControl.noTransform());
+    assertEquals(header, cacheControl.toString());
+  }
+
+  @Test public void timeDurationTruncatedToMaxValue() throws Exception {
+    CacheControl cacheControl = new CacheControl.Builder()
+        .maxAge(365 * 100, TimeUnit.DAYS) // Longer than Integer.MAX_VALUE seconds.
+        .build();
+    assertEquals(Integer.MAX_VALUE, cacheControl.maxAgeSeconds());
+  }
+
+  @Test public void secondsMustBeNonNegative() throws Exception {
+    CacheControl.Builder builder = new CacheControl.Builder();
+    try {
+      builder.maxAge(-1, TimeUnit.SECONDS);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void timePrecisionIsTruncatedToSeconds() throws Exception {
+    CacheControl cacheControl = new CacheControl.Builder()
+        .maxAge(4999, TimeUnit.MILLISECONDS)
+        .build();
+    assertEquals(4, cacheControl.maxAgeSeconds());
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
new file mode 100644
index 0000000000..8f117f0ec5
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
@@ -0,0 +1,2263 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.File;
+import java.io.IOException;
+import java.net.CookieHandler;
+import java.net.CookieManager;
+import java.net.HttpCookie;
+import java.net.HttpURLConnection;
+import java.net.ResponseCache;
+import java.net.URL;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.NoSuchElementException;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/** Test caching with {@link OkUrlFactory}. */
+public final class CacheTest {
+  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
+    @Override public boolean verify(String s, SSLSession sslSession) {
+      return true;
+    }
+  };
+
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+
+  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
+  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
+  @Rule public MockWebServerRule server2Rule = new MockWebServerRule();
+
+  private final OkHttpClient client = new OkHttpClient();
+  private MockWebServer server;
+  private MockWebServer server2;
+  private Cache cache;
+  private final CookieManager cookieManager = new CookieManager();
+
+  @Before public void setUp() throws Exception {
+    server = serverRule.get();
+    server.setProtocolNegotiationEnabled(false);
+    server2 = server2Rule.get();
+    cache = new Cache(cacheRule.getRoot(), Integer.MAX_VALUE);
+    client.setCache(cache);
+    CookieHandler.setDefault(cookieManager);
+  }
+
+  @After public void tearDown() throws Exception {
+    ResponseCache.setDefault(null);
+    CookieHandler.setDefault(null);
+  }
+
+  /**
+   * Test that response caching is consistent with the RI and the spec.
+   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
+   */
+  @Test public void responseCachingByResponseCode() throws Exception {
+    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
+    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
+
+    // We can't test 100 because it's not really a response.
+    // assertCached(false, 100);
+    assertCached(false, 101);
+    assertCached(false, 102);
+    assertCached(true, 200);
+    assertCached(false, 201);
+    assertCached(false, 202);
+    assertCached(true, 203);
+    assertCached(false, 204);
+    assertCached(false, 205);
+    assertCached(false, 206); // we don't cache partial responses
+    assertCached(false, 207);
+    assertCached(true, 300);
+    assertCached(true, 301);
+    assertCached(true, 302);
+    assertCached(false, 303);
+    assertCached(false, 304);
+    assertCached(false, 305);
+    assertCached(false, 306);
+    assertCached(true, 307);
+    assertCached(true, 308);
+    for (int i = 400; i <= 406; ++i) {
+      assertCached(false, i);
+    }
+    // (See test_responseCaching_407.)
+    assertCached(false, 408);
+    assertCached(false, 409);
+    // (See test_responseCaching_410.)
+    for (int i = 411; i <= 418; ++i) {
+      assertCached(false, i);
+    }
+    for (int i = 500; i <= 506; ++i) {
+      assertCached(false, i);
+    }
+  }
+
+  @Test public void responseCaching_410() throws Exception {
+    // the HTTP spec permits caching 410s, but the RI doesn't.
+    assertCached(true, 410);
+  }
+
+  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
+    server = new MockWebServer();
+    MockResponse mockResponse = new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(responseCode)
+        .setBody("ABCDE")
+        .addHeader("WWW-Authenticate: challenge");
+    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
+      mockResponse.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
+    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
+      mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
+    }
+    server.enqueue(mockResponse);
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals(responseCode, response.code());
+
+    // Exhaust the content stream.
+    response.body().string();
+
+    Response cached = cache.get(request);
+    if (shouldPut) {
+      assertNotNull(Integer.toString(responseCode), cached);
+      cached.body().close();
+    } else {
+      assertNull(Integer.toString(responseCode), cached);
+    }
+    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
+    testResponseCaching(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
+    testResponseCaching(TransferKind.CHUNKED);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
+    testResponseCaching(TransferKind.END_OF_STREAM);
+  }
+
+  /**
+   * Skipping bytes in the input stream caused ResponseCache corruption.
+   * http://code.google.com/p/android/issues/detail?id=8175
+   */
+  private void testResponseCaching(TransferKind transferKind) throws IOException {
+    MockResponse mockResponse = new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setStatus("HTTP/1.1 200 Fantastic");
+    transferKind.setBody(mockResponse, "I love puppies but hate spiders", 1);
+    server.enqueue(mockResponse);
+
+    // Make sure that calling skip() doesn't omit bytes from the cache.
+    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Response response1 = client.newCall(request).execute();
+
+    BufferedSource in1 = response1.body().source();
+    assertEquals("I love ", in1.readUtf8("I love ".length()));
+    in1.skip("puppies but hate ".length());
+    assertEquals("spiders", in1.readUtf8("spiders".length()));
+    assertTrue(in1.exhausted());
+    in1.close();
+    assertEquals(1, cache.getWriteSuccessCount());
+    assertEquals(0, cache.getWriteAbortCount());
+
+    Response response2 = client.newCall(request).execute();
+    BufferedSource in2 = response2.body().source();
+    assertEquals("I love puppies but hate spiders",
+        in2.readUtf8("I love puppies but hate spiders".length()));
+    assertEquals(200, response2.code());
+    assertEquals("Fantastic", response2.message());
+
+    assertTrue(in2.exhausted());
+    in2.close();
+    assertEquals(1, cache.getWriteSuccessCount());
+    assertEquals(0, cache.getWriteAbortCount());
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getHitCount());
+  }
+
+  @Test public void secureResponseCaching() throws IOException {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Response response1 = client.newCall(request).execute();
+    BufferedSource in = response1.body().source();
+    assertEquals("ABC", in.readUtf8());
+
+    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
+    String suite = response1.handshake().cipherSuite();
+    List<Certificate> localCerts = response1.handshake().localCertificates();
+    List<Certificate> serverCerts = response1.handshake().peerCertificates();
+    Principal peerPrincipal = response1.handshake().peerPrincipal();
+    Principal localPrincipal = response1.handshake().localPrincipal();
+
+    Response response2 = client.newCall(request).execute(); // Cached!
+    assertEquals("ABC", response2.body().source().readUtf8());
+
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(1, cache.getHitCount());
+
+    assertEquals(suite, response2.handshake().cipherSuite());
+    assertEquals(localCerts, response2.handshake().localCertificates());
+    assertEquals(serverCerts, response2.handshake().peerCertificates());
+    assertEquals(peerPrincipal, response2.handshake().peerPrincipal());
+    assertEquals(localPrincipal, response2.handshake().localPrincipal());
+  }
+
+  @Test public void responseCachingAndRedirects() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Response response1 = client.newCall(request).execute();
+    assertEquals("ABC", response1.body().string());
+
+    Response response2 = client.newCall(request).execute(); // Cached!
+    assertEquals("ABC", response2.body().string());
+
+    assertEquals(4, cache.getRequestCount()); // 2 requests + 2 redirects
+    assertEquals(2, cache.getNetworkCount());
+    assertEquals(2, cache.getHitCount());
+  }
+
+  @Test public void redirectToCachedResult() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    Request request1 = new Request.Builder().url(server.getUrl("/foo")).build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("ABC", response1.body().string());
+    RecordedRequest recordedRequest1 = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", recordedRequest1.getRequestLine());
+    assertEquals(0, recordedRequest1.getSequenceNumber());
+
+    Request request2 = new Request.Builder().url(server.getUrl("/bar")).build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("ABC", response2.body().string());
+    RecordedRequest recordedRequest2 = server.takeRequest();
+    assertEquals("GET /bar HTTP/1.1", recordedRequest2.getRequestLine());
+    assertEquals(1, recordedRequest2.getSequenceNumber());
+
+    // an unrelated request should reuse the pooled connection
+    Request request3 = new Request.Builder().url(server.getUrl("/baz")).build();
+    Response response3 = client.newCall(request3).execute();
+    assertEquals("DEF", response3.body().string());
+    RecordedRequest recordedRequest3 = server.takeRequest();
+    assertEquals("GET /baz HTTP/1.1", recordedRequest3.getRequestLine());
+    assertEquals(2, recordedRequest3.getSequenceNumber());
+  }
+
+  @Test public void secureResponseCachingAndRedirects() throws IOException {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    Response response1 = get(server.getUrl("/"));
+    assertEquals("ABC", response1.body().string());
+    assertNotNull(response1.handshake().cipherSuite());
+
+    // Cached!
+    Response response2 = get(server.getUrl("/"));
+    assertEquals("ABC", response2.body().string());
+    assertNotNull(response2.handshake().cipherSuite());
+
+    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.getHitCount());
+    assertEquals(response1.handshake().cipherSuite(), response2.handshake().cipherSuite());
+  }
+
+  /**
+   * We've had bugs where caching and cross-protocol redirects yield class
+   * cast exceptions internal to the cache because we incorrectly assumed that
+   * HttpsURLConnection was always HTTPS and HttpURLConnection was always HTTP;
+   * in practice redirects mean that each can do either.
+   *
+   * https://github.com/square/okhttp/issues/214
+   */
+  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
+    server2.useHttps(sslContext.getSocketFactory(), false);
+    server2.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server2.enqueue(new MockResponse()
+        .setBody("DEF"));
+
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: " + server2.getUrl("/")));
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    Response response1 = get(server.getUrl("/"));
+    assertEquals("ABC", response1.body().string());
+
+    // Cached!
+    Response response2 = get(server.getUrl("/"));
+    assertEquals("ABC", response2.body().string());
+
+    assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
+    assertEquals(2, cache.getHitCount());
+  }
+
+  @Test public void foundCachedWithExpiresHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(302, "Expires", formatDate(1, TimeUnit.HOURS));
+  }
+
+  @Test public void foundCachedWithCacheControlHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(302, "Cache-Control", "max-age=60");
+  }
+
+  @Test public void temporaryRedirectCachedWithExpiresHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(307, "Expires", formatDate(1, TimeUnit.HOURS));
+  }
+
+  @Test public void temporaryRedirectCachedWithCacheControlHeader() throws Exception {
+    temporaryRedirectCachedWithCachingHeader(307, "Cache-Control", "max-age=60");
+  }
+
+  @Test public void foundNotCachedWithoutCacheHeader() throws Exception {
+    temporaryRedirectNotCachedWithoutCachingHeader(302);
+  }
+
+  @Test public void temporaryRedirectNotCachedWithoutCacheHeader() throws Exception {
+    temporaryRedirectNotCachedWithoutCachingHeader(307);
+  }
+
+  private void temporaryRedirectCachedWithCachingHeader(
+      int responseCode, String headerName, String headerValue) throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(responseCode)
+        .addHeader(headerName, headerValue)
+        .addHeader("Location", "/a"));
+    server.enqueue(new MockResponse()
+        .addHeader(headerName, headerValue)
+        .setBody("a"));
+    server.enqueue(new MockResponse()
+        .setBody("b"));
+    server.enqueue(new MockResponse()
+        .setBody("c"));
+
+    URL url = server.getUrl("/");
+    assertEquals("a", get(url).body().string());
+    assertEquals("a", get(url).body().string());
+  }
+
+  private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(responseCode)
+        .addHeader("Location", "/a"));
+    server.enqueue(new MockResponse()
+        .setBody("a"));
+    server.enqueue(new MockResponse()
+        .setBody("b"));
+
+    URL url = server.getUrl("/");
+    assertEquals("a", get(url).body().string());
+    assertEquals("b", get(url).body().string());
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
+    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
+    testServerPrematureDisconnect(TransferKind.CHUNKED);
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
+    // Intentionally empty. This case doesn't make sense because there's no
+    // such thing as a premature disconnect when the disconnect itself
+    // indicates the end of the data stream.
+  }
+
+  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
+    MockResponse mockResponse = new MockResponse();
+    transferKind.setBody(mockResponse, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
+    server.enqueue(truncateViolently(mockResponse, 16));
+    server.enqueue(new MockResponse()
+        .setBody("Request #2"));
+
+    BufferedSource bodySource = get(server.getUrl("/")).body().source();
+    assertEquals("ABCDE", bodySource.readUtf8Line());
+    try {
+      bodySource.readUtf8Line();
+      fail("This implementation silently ignored a truncated HTTP body.");
+    } catch (IOException expected) {
+    } finally {
+      bodySource.close();
+    }
+
+    assertEquals(1, cache.getWriteAbortCount());
+    assertEquals(0, cache.getWriteSuccessCount());
+    Response response = get(server.getUrl("/"));
+    assertEquals("Request #2", response.body().string());
+    assertEquals(1, cache.getWriteAbortCount());
+    assertEquals(1, cache.getWriteSuccessCount());
+  }
+
+  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
+    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
+    testClientPrematureDisconnect(TransferKind.CHUNKED);
+  }
+
+  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
+    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
+  }
+
+  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
+    // Setting a low transfer speed ensures that stream discarding will time out.
+    MockResponse mockResponse = new MockResponse()
+        .throttleBody(6, 1, TimeUnit.SECONDS);
+    transferKind.setBody(mockResponse, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
+    server.enqueue(mockResponse);
+    server.enqueue(new MockResponse()
+        .setBody("Request #2"));
+
+    Response response1 = get(server.getUrl("/"));
+    BufferedSource in = response1.body().source();
+    assertEquals("ABCDE", in.readUtf8(5));
+    in.close();
+    try {
+      in.readByte();
+      fail("Expected an IllegalStateException because the source is closed.");
+    } catch (IllegalStateException expected) {
+    }
+
+    assertEquals(1, cache.getWriteAbortCount());
+    assertEquals(0, cache.getWriteSuccessCount());
+    Response response2 = get(server.getUrl("/"));
+    assertEquals("Request #2", response2.body().string());
+    assertEquals(1, cache.getWriteAbortCount());
+    assertEquals(1, cache.getWriteSuccessCount());
+  }
+
+  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
+    //      last modified: 105 seconds ago
+    //             served:   5 seconds ago
+    //   default lifetime: (105 - 5) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds from now
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+        .setBody("A"));
+
+    URL url = server.getUrl("/");
+    Response response1 = get(url);
+    assertEquals("A", response1.body().string());
+
+    Response response2 = get(url);
+    assertEquals("A", response2.body().string());
+    assertNull(response2.header("Warning"));
+  }
+
+  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
+    //      last modified: 115 seconds ago
+    //             served:  15 seconds ago
+    //   default lifetime: (115 - 15) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds ago
+    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
+    //      last modified: 105 days ago
+    //             served:   5 days ago
+    //   default lifetime: (105 - 5) / 10 = 10 days
+    //            expires:  10 days from served date = 5 days from now
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
+        .setBody("A"));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    Response response = get(server.getUrl("/"));
+    assertEquals("A", response.body().string());
+    assertEquals("113 HttpURLConnection \"Heuristic expiration\"", response.header("Warning"));
+  }
+
+  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/?foo=bar");
+    assertEquals("A", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+  }
+
+  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+  }
+
+  @Test public void expirationDateInTheFuture() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Cache-Control: max-age=60"));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
+    // Chrome interprets max-age relative to the local clock. Both our cache
+    // and Firefox both use the earlier of the local and server's clock.
+    assertNotCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: s-maxage=60")
+        .addHeader("Cache-Control: max-age=180"));
+  }
+
+  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: s-maxage=180")
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void requestMethodOptionsIsNotCached() throws Exception {
+    testRequestMethod("OPTIONS", false);
+  }
+
+  @Test public void requestMethodGetIsCached() throws Exception {
+    testRequestMethod("GET", true);
+  }
+
+  @Test public void requestMethodHeadIsNotCached() throws Exception {
+    // We could support this but choose not to for implementation simplicity
+    testRequestMethod("HEAD", false);
+  }
+
+  @Test public void requestMethodPostIsNotCached() throws Exception {
+    // We could support this but choose not to for implementation simplicity
+    testRequestMethod("POST", false);
+  }
+
+  @Test public void requestMethodPutIsNotCached() throws Exception {
+    testRequestMethod("PUT", false);
+  }
+
+  @Test public void requestMethodDeleteIsNotCached() throws Exception {
+    testRequestMethod("DELETE", false);
+  }
+
+  @Test public void requestMethodTraceIsNotCached() throws Exception {
+    testRequestMethod("TRACE", false);
+  }
+
+  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
+    // 1. seed the cache (potentially)
+    // 2. expect a cache hit or miss
+    server.enqueue(new MockResponse()
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("X-Response-ID: 1"));
+    server.enqueue(new MockResponse()
+        .addHeader("X-Response-ID: 2"));
+
+    URL url = server.getUrl("/");
+
+    Request request = new Request.Builder()
+        .url(url)
+        .method(requestMethod, requestBodyOrNull(requestMethod))
+        .build();
+    Response response1 = client.newCall(request).execute();
+    response1.body().close();
+    assertEquals("1", response1.header("X-Response-ID"));
+
+    Response response2 = get(url);
+    response2.body().close();
+    if (expectCached) {
+      assertEquals("1", response2.header("X-Response-ID"));
+    } else {
+      assertEquals("2", response2.header("X-Response-ID"));
+    }
+  }
+
+  private RequestBody requestBodyOrNull(String requestMethod) {
+    return (requestMethod.equals("POST") || requestMethod.equals("PUT"))
+          ? RequestBody.create(MediaType.parse("text/plain"), "foo")
+          : null;
+  }
+
+  @Test public void postInvalidatesCache() throws Exception {
+    testMethodInvalidates("POST");
+  }
+
+  @Test public void putInvalidatesCache() throws Exception {
+    testMethodInvalidates("PUT");
+  }
+
+  @Test public void deleteMethodInvalidatesCache() throws Exception {
+    testMethodInvalidates("DELETE");
+  }
+
+  private void testMethodInvalidates(String requestMethod) throws Exception {
+    // 1. seed the cache
+    // 2. invalidate it
+    // 3. expect a cache miss
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    URL url = server.getUrl("/");
+
+    assertEquals("A", get(url).body().string());
+
+    Request request = new Request.Builder()
+        .url(url)
+        .method(requestMethod, requestBodyOrNull(requestMethod))
+        .build();
+    Response invalidate = client.newCall(request).execute();
+    assertEquals("B", invalidate.body().string());
+
+    assertEquals("C", get(url).body().string());
+  }
+
+  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
+    // 1. seed the cache
+    // 2. invalidate it with uncacheable response
+    // 3. expect a cache miss
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B")
+        .setResponseCode(500));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    URL url = server.getUrl("/");
+
+    assertEquals("A", get(url).body().string());
+
+    Request request = new Request.Builder()
+        .url(url)
+        .method("POST", requestBodyOrNull("POST"))
+        .build();
+    Response invalidate = client.newCall(request).execute();
+    assertEquals("B", invalidate.body().string());
+
+    assertEquals("C", get(url).body().string());
+  }
+
+  @Test public void etag() throws Exception {
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("ETag: v1"));
+    assertTrue(conditionalRequest.getHeaders().contains("If-None-Match: v1"));
+  }
+
+  @Test public void etagAndExpirationDateInThePast() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-None-Match: v1"));
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
+    assertFullyCached(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  @Test public void cacheControlNoCache() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Cache-Control: no-cache"));
+  }
+
+  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: no-cache"));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void pragmaNoCache() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Pragma: no-cache"));
+  }
+
+  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Pragma: no-cache"));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void cacheControlNoStore() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Cache-Control: no-store"));
+  }
+
+  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
+    assertNotCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: no-store"));
+  }
+
+  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
+    // 1. request a range
+    // 2. request a full document, expecting a cache miss
+    server.enqueue(new MockResponse()
+        .setBody("AA")
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 1000-1001/2000"));
+    server.enqueue(new MockResponse()
+        .setBody("BB"));
+
+    URL url = server.getUrl("/");
+
+    Request request = new Request.Builder()
+        .url(url)
+        .header("Range", "bytes=1000-1001")
+        .build();
+    Response range = client.newCall(request).execute();
+    assertEquals("AA", range.body().string());
+
+    assertEquals("BB", get(url).body().string());
+  }
+
+  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B")
+        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
+
+    URL url = server.getUrl("/");
+
+    assertEquals("A", get(url).body().string());
+    assertEquals("A", get(url).body().string());
+  }
+
+  @Test public void clientSideNoStore() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("B"));
+
+    Request request1 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .cacheControl(new CacheControl.Builder().noStore().build())
+        .build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("A", response1.body().string());
+
+    Request request2 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("B", response2.body().string());
+  }
+
+  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
+    assertNonIdentityEncodingCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+  }
+
+  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
+    assertNonIdentityEncodingCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
+    server.enqueue(response
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // At least three request/response pairs are required because after the first request is cached
+    // a different execution path might be taken. Thus modifications to the cache applied during
+    // the second request might not be visible until another request is performed.
+    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
+    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
+    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
+  }
+
+  @Test public void notModifiedSpecifiesEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+        .setBody("DEFDEFDEF"));
+
+    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
+    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
+    assertEquals("DEFDEFDEF", get(server.getUrl("/")).body().string());
+  }
+
+  /** https://github.com/square/okhttp/issues/947 */
+  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Vary: Accept-Encoding")
+        .addHeader("Cache-Control: max-age=60"));
+    server.enqueue(new MockResponse()
+        .setBody("FAIL"));
+
+    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
+    assertEquals("ABCABCABC", get(server.getUrl("/")).body().string());
+  }
+
+  @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    ConnectionPool pool = ConnectionPool.getDefault();
+    pool.evictAll();
+    client.setConnectionPool(pool);
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals(1, client.getConnectionPool().getConnectionCount());
+  }
+
+  @Test public void expiresDateBeforeModifiedDate() throws Exception {
+    assertConditionallyCached(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
+  }
+
+  @Test public void requestMaxAge() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Cache-Control", "max-age=30")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("B", response.body().string());
+  }
+
+  @Test public void requestMinFresh() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Cache-Control", "min-fresh=120")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("B", response.body().string());
+  }
+
+  @Test public void requestMaxStale() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Cache-Control", "max-stale=180")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("A", response.body().string());
+    assertEquals("110 HttpURLConnection \"Response is stale\"", response.header("Warning"));
+  }
+
+  @Test public void requestMaxStaleDirectiveWithNoValue() throws IOException {
+    // Add a stale response to the cache.
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+
+    // With max-stale, we'll return that stale response.
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Cache-Control", "max-stale")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("A", response.body().string());
+    assertEquals("110 HttpURLConnection \"Response is stale\"", response.header("Warning"));
+  }
+
+  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=120, must-revalidate")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Cache-Control", "max-stale=180")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("B", response.body().string());
+  }
+
+  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
+    // (no responses enqueued)
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Cache-Control", "only-if-cached")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertTrue(response.body().source().exhausted());
+    assertEquals(504, response.code());
+    assertEquals(1, cache.getRequestCount());
+    assertEquals(0, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+  }
+
+  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Cache-Control", "only-if-cached")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("A", response.body().string());
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(1, cache.getHitCount());
+  }
+
+  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Cache-Control", "only-if-cached")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertTrue(response.body().source().exhausted());
+    assertEquals(504, response.code());
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+  }
+
+  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Cache-Control", "only-if-cached")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertTrue(response.body().source().exhausted());
+    assertEquals(504, response.code());
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+  }
+
+  @Test public void requestCacheControlNoCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", get(url).body().string());
+    Request request = new Request.Builder()
+        .url(url)
+        .header("Cache-Control", "no-cache")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("B", response.body().string());
+  }
+
+  @Test public void requestPragmaNoCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", get(url).body().string());
+    Request request = new Request.Builder()
+        .url(url)
+        .header("Pragma", "no-cache")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("B", response.body().string());
+  }
+
+  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
+    MockResponse response = new MockResponse()
+        .addHeader("ETag: v3")
+        .addHeader("Cache-Control: max-age=0");
+    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
+    RecordedRequest request =
+        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
+    List<String> headers = request.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + ifModifiedSinceDate));
+    assertFalse(headers.contains("If-None-Match: v3"));
+  }
+
+  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
+    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
+    MockResponse response = new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: max-age=0");
+    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
+    List<String> headers = request.getHeaders();
+    assertTrue(headers.contains("If-None-Match: v1"));
+    assertFalse(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
+      String conditionValue) throws Exception {
+    server.enqueue(seed.setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", get(url).body().string());
+
+    Request request = new Request.Builder()
+        .url(url)
+        .header(conditionName, conditionValue)
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, response.code());
+    assertEquals("", response.body().string());
+
+    server.takeRequest(); // seed
+    return server.takeRequest();
+  }
+
+  /**
+   * For Last-Modified and Date headers, we should echo the date back in the
+   * exact format we were served.
+   */
+  @Test public void retainServedDateFormat() throws Exception {
+    // Serve a response with a non-standard date format that OkHttp supports.
+    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
+    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
+    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
+    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    String lastModifiedString = dateFormat.format(lastModifiedDate);
+    String servedString = dateFormat.format(servedDate);
+
+    // This response should be conditionally cached.
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedString)
+        .addHeader("Expires: " + servedString)
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.getUrl("/")).body().string());
+
+    // The first request has no conditions.
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("If-Modified-Since"));
+
+    // The 2nd request uses the server's date format.
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
+  }
+
+  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("If-Modified-Since", formatDate(-24, TimeUnit.HOURS))
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, response.code());
+    assertEquals("", response.body().string());
+  }
+
+  @Test public void authorizationRequestFullyCached() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    Request request = new Request.Builder()
+        .url(url)
+        .header("Authorization", "password")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("A", response.body().string());
+    assertEquals("A", get(url).body().string());
+  }
+
+  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Content-Location: /bar")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.getUrl("/foo")).body().string());
+    assertEquals("B", get(server.getUrl("/bar")).body().string());
+  }
+
+  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.getUrl("/a")).body().string());
+    assertEquals("A", get(server.getUrl("/a")).body().string());
+    assertEquals("B", get(server.getUrl("/b")).body().string());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void statisticsConditionalCacheMiss() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals(1, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+    assertEquals("B", get(server.getUrl("/")).body().string());
+    assertEquals("C", get(server.getUrl("/")).body().string());
+    assertEquals(3, cache.getRequestCount());
+    assertEquals(3, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+  }
+
+  @Test public void statisticsConditionalCacheHit() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals(1, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals(3, cache.getRequestCount());
+    assertEquals(3, cache.getNetworkCount());
+    assertEquals(2, cache.getHitCount());
+  }
+
+  @Test public void statisticsFullCacheHit() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals(1, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals(3, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(2, cache.getHitCount());
+  }
+
+  @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    Request frRequest = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "fr-CA")
+        .build();
+    Response frResponse = client.newCall(frRequest).execute();
+    assertEquals("A", frResponse.body().string());
+
+    Request enRequest = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "en-US")
+        .build();
+    Response enResponse = client.newCall(enRequest).execute();
+    assertEquals("B", enResponse.body().string());
+  }
+
+  @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    Request request = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "fr-CA")
+        .build();
+    Response response1 = client.newCall(request).execute();
+    assertEquals("A", response1.body().string());
+    Request request1 = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "fr-CA")
+        .build();
+    Response response2 = client.newCall(request1).execute();
+    assertEquals("A", response2.body().string());
+  }
+
+  @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("A", get(server.getUrl("/")).body().string());
+  }
+
+  @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Foo", "bar")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("B", response.body().string());
+  }
+
+  @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Foo")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Foo", "bar")
+        .build();
+    Response fooresponse = client.newCall(request).execute();
+    assertEquals("A", fooresponse.body().string());
+    assertEquals("B", get(server.getUrl("/")).body().string());
+  }
+
+  @Test public void varyFieldsAreCaseInsensitive() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: ACCEPT-LANGUAGE")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    Request request = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "fr-CA")
+        .build();
+    Response response1 = client.newCall(request).execute();
+    assertEquals("A", response1.body().string());
+    Request request1 = new Request.Builder()
+        .url(url)
+        .header("accept-language", "fr-CA")
+        .build();
+    Response response2 = client.newCall(request1).execute();
+    assertEquals("A", response2.body().string());
+  }
+
+  @Test public void varyMultipleFieldsWithMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language, Accept-Charset")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    Request request = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "fr-CA")
+        .header("Accept-Charset", "UTF-8")
+        .header("Accept-Encoding", "identity")
+        .build();
+    Response response1 = client.newCall(request).execute();
+    assertEquals("A", response1.body().string());
+    Request request1 = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "fr-CA")
+        .header("Accept-Charset", "UTF-8")
+        .header("Accept-Encoding", "identity")
+        .build();
+    Response response2 = client.newCall(request1).execute();
+    assertEquals("A", response2.body().string());
+  }
+
+  @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language, Accept-Charset")
+        .addHeader("Vary: Accept-Encoding")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    Request frRequest = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "fr-CA")
+        .header("Accept-Charset", "UTF-8")
+        .header("Accept-Encoding", "identity")
+        .build();
+    Response frResponse = client.newCall(frRequest).execute();
+    assertEquals("A", frResponse.body().string());
+    Request enRequest = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "en-CA")
+        .header("Accept-Charset", "UTF-8")
+        .header("Accept-Encoding", "identity")
+        .build();
+    Response enResponse = client.newCall(enRequest).execute();
+    assertEquals("B", enResponse.body().string());
+  }
+
+  @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    Request request1 = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "fr-CA, fr-FR")
+        .addHeader("Accept-Language", "en-US")
+        .build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("A", response1.body().string());
+
+    Request request2 = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "fr-CA, fr-FR")
+        .addHeader("Accept-Language", "en-US")
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("A", response2.body().string());
+  }
+
+  @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    Request request1 = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "fr-CA, fr-FR")
+        .addHeader("Accept-Language", "en-US")
+        .build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("A", response1.body().string());
+
+    Request request2 = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "fr-CA")
+        .addHeader("Accept-Language", "en-US")
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("B", response2.body().string());
+  }
+
+  @Test public void varyAsterisk() throws Exception {
+    server.enqueue( new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: *")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    assertEquals("B", get(server.getUrl("/")).body().string());
+  }
+
+  @Test public void varyAndHttps() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Language")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    URL url = server.getUrl("/");
+    Request request1 = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "en-US")
+        .build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("A", response1.body().string());
+
+    Request request2 = new Request.Builder()
+        .url(url)
+        .header("Accept-Language", "en-US")
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("A", response2.body().string());
+  }
+
+  @Test public void cachePlusCookies() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie: a=FIRST; domain=" + server.getCookieDomain() + ";")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", get(url).body().string());
+    assertCookies(url, "a=FIRST");
+    assertEquals("A", get(url).body().string());
+    assertCookies(url, "a=SECOND");
+  }
+
+  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Allow: GET, HEAD")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Allow: GET, HEAD, PUT")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Response response1 = get(server.getUrl("/"));
+    assertEquals("A", response1.body().string());
+    assertEquals("GET, HEAD", response1.header("Allow"));
+
+    Response response2 = get(server.getUrl("/"));
+    assertEquals("A", response2.body().string());
+    assertEquals("GET, HEAD, PUT", response2.header("Allow"));
+  }
+
+  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Transfer-Encoding: identity")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Transfer-Encoding: none")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Response response1 = get(server.getUrl("/"));
+    assertEquals("A", response1.body().string());
+    assertEquals("identity", response1.header("Transfer-Encoding"));
+
+    Response response2 = get(server.getUrl("/"));
+    assertEquals("A", response2.body().string());
+    assertEquals("identity", response2.header("Transfer-Encoding"));
+  }
+
+  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Warning: 199 test danger")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Response response1 = get(server.getUrl("/"));
+    assertEquals("A", response1.body().string());
+    assertEquals("199 test danger", response1.header("Warning"));
+
+    Response response2 = get(server.getUrl("/"));
+    assertEquals("A", response2.body().string());
+    assertEquals(null, response2.header("Warning"));
+  }
+
+  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Warning: 299 test danger")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    Response response1 = get(server.getUrl("/"));
+    assertEquals("A", response1.body().string());
+    assertEquals("299 test danger", response1.header("Warning"));
+
+    Response response2 = get(server.getUrl("/"));
+    assertEquals("A", response2.body().string());
+    assertEquals("299 test danger", response2.header("Warning"));
+  }
+
+  public void assertCookies(URL url, String... expectedCookies) throws Exception {
+    List<String> actualCookies = new ArrayList<>();
+    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
+      actualCookies.add(cookie.toString());
+    }
+    assertEquals(Arrays.asList(expectedCookies), actualCookies);
+  }
+
+  @Test public void cachePlusRange() throws Exception {
+    assertNotCached(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 100-100/200")
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void conditionalHitUpdatesCache() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Allow: GET, HEAD")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    // cache miss; seed the cache
+    Response response1 = get(server.getUrl("/a"));
+    assertEquals("A", response1.body().string());
+    assertEquals(null, response1.header("Allow"));
+
+    // conditional cache hit; update the cache
+    Response response2 = get(server.getUrl("/a"));
+    assertEquals(HttpURLConnection.HTTP_OK, response2.code());
+    assertEquals("A", response2.body().string());
+    assertEquals("GET, HEAD", response2.header("Allow"));
+
+    // full cache hit
+    Response response3 = get(server.getUrl("/a"));
+    assertEquals("A", response3.body().string());
+    assertEquals("GET, HEAD", response3.header("Allow"));
+
+    assertEquals(2, server.getRequestCount());
+  }
+
+  @Test public void responseSourceHeaderCached() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Cache-Control", "only-if-cached")
+        .build();
+    Response response = client.newCall(request).execute();
+    assertEquals("A", response.body().string());
+  }
+
+  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setBody("B")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    Response response = get(server.getUrl("/"));
+    assertEquals("B", response.body().string());
+  }
+
+  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Cache-Control: max-age=0")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse()
+        .setResponseCode(304));
+
+    assertEquals("A", get(server.getUrl("/")).body().string());
+    Response response = get(server.getUrl("/"));
+    assertEquals("A", response.body().string());
+  }
+
+  @Test public void responseSourceHeaderFetched() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    Response response = get(server.getUrl("/"));
+    assertEquals("A", response.body().string());
+  }
+
+  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader(": A")
+        .setBody("body"));
+
+    Response response = get(server.getUrl("/"));
+    assertEquals("A", response.header(""));
+  }
+
+  /**
+   * Old implementations of OkHttp's response cache wrote header fields like
+   * ":status: 200 OK". This broke our cached response parser because it split
+   * on the first colon. This regression test exists to help us read these old
+   * bad cache entries.
+   *
+   * https://github.com/square/okhttp/issues/227
+   */
+  @Test public void testGoldenCacheResponse() throws Exception {
+    cache.close();
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URL url = server.getUrl("/");
+    String urlKey = Util.md5Hex(url.toString());
+    String entryMetadata = ""
+        + "" + url + "\n"
+        + "GET\n"
+        + "0\n"
+        + "HTTP/1.1 200 OK\n"
+        + "7\n"
+        + ":status: 200 OK\n"
+        + ":version: HTTP/1.1\n"
+        + "etag: foo\n"
+        + "content-length: 3\n"
+        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
+        + "X-Android-Response-Source: NETWORK 200\n"
+        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
+        + "\n"
+        + "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n"
+        + "1\n"
+        + "MIIBpDCCAQ2gAwIBAgIBATANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDEw1qd2lsc29uLmxvY2FsMB4XDTEzMDgy"
+        + "OTA1MDE1OVoXDTEzMDgzMDA1MDE1OVowGDEWMBQGA1UEAxMNandpbHNvbi5sb2NhbDCBnzANBgkqhkiG9w0BAQEF"
+        + "AAOBjQAwgYkCgYEAlFW+rGo/YikCcRghOyKkJanmVmJSce/p2/jH1QvNIFKizZdh8AKNwojt3ywRWaDULA/RlCUc"
+        + "ltF3HGNsCyjQI/+Lf40x7JpxXF8oim1E6EtDoYtGWAseelawus3IQ13nmo6nWzfyCA55KhAWf4VipelEy8DjcuFK"
+        + "v6L0xwXnI0ECAwEAATANBgkqhkiG9w0BAQsFAAOBgQAuluNyPo1HksU3+Mr/PyRQIQS4BI7pRXN8mcejXmqyscdP"
+        + "7S6J21FBFeRR8/XNjVOp4HT9uSc2hrRtTEHEZCmpyoxixbnM706ikTmC7SN/GgM+SmcoJ1ipJcNcl8N0X6zym4dm"
+        + "yFfXKHu2PkTo7QFdpOJFvP3lIigcSZXozfmEDg==\n"
+        + "-1\n";
+    String entryBody = "abc";
+    String journalBody = ""
+        + "libcore.io.DiskLruCache\n"
+        + "1\n"
+        + "201105\n"
+        + "2\n"
+        + "\n"
+        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
+    writeFile(cache.getDirectory(), urlKey + ".0", entryMetadata);
+    writeFile(cache.getDirectory(), urlKey + ".1", entryBody);
+    writeFile(cache.getDirectory(), "journal", journalBody);
+    cache = new Cache(cache.getDirectory(), Integer.MAX_VALUE);
+    client.setCache(cache);
+
+    Response response = get(url);
+    assertEquals(entryBody, response.body().string());
+    assertEquals("3", response.header("Content-Length"));
+    assertEquals("foo", response.header("etag"));
+  }
+
+  @Test public void evictAll() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", get(url).body().string());
+    client.getCache().evictAll();
+    assertEquals(0, client.getCache().getSize());
+    assertEquals("B", get(url).body().string());
+  }
+
+  @Test public void networkInterceptorInvokedForConditionalGet() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // Seed the cache.
+    URL url = server.getUrl("/");
+    assertEquals("A", get(url).body().string());
+
+    final AtomicReference<String> ifNoneMatch = new AtomicReference<>();
+    client.networkInterceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        ifNoneMatch.compareAndSet(null, chain.request().header("If-None-Match"));
+        return chain.proceed(chain.request());
+      }
+    });
+
+    // Confirm the value is cached and intercepted.
+    assertEquals("A", get(url).body().string());
+    assertEquals("v1", ifNoneMatch.get());
+  }
+
+  @Test public void networkInterceptorNotInvokedForFullyCached() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("A"));
+
+    // Seed the cache.
+    URL url = server.getUrl("/");
+    assertEquals("A", get(url).body().string());
+
+    // Confirm the interceptor isn't exercised.
+    client.networkInterceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        throw new AssertionError();
+      }
+    });
+    assertEquals("A", get(url).body().string());
+  }
+
+  @Test public void iterateCache() throws Exception {
+    // Put some responses in the cache.
+    server.enqueue(new MockResponse()
+        .setBody("a"));
+    URL urlA = server.getUrl("/a");
+    assertEquals("a", get(urlA).body().string());
+
+    server.enqueue(new MockResponse()
+        .setBody("b"));
+    URL urlB = server.getUrl("/b");
+    assertEquals("b", get(urlB).body().string());
+
+    server.enqueue(new MockResponse()
+        .setBody("c"));
+    URL urlC = server.getUrl("/c");
+    assertEquals("c", get(urlC).body().string());
+
+    // Confirm the iterator returns those responses...
+    Iterator<String> i = cache.urls();
+    assertTrue(i.hasNext());
+    assertEquals(urlA.toString(), i.next());
+    assertTrue(i.hasNext());
+    assertEquals(urlB.toString(), i.next());
+    assertTrue(i.hasNext());
+    assertEquals(urlC.toString(), i.next());
+
+    // ... and nothing else.
+    assertFalse(i.hasNext());
+    try {
+      i.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+  }
+
+  @Test public void iteratorRemoveFromCache() throws Exception {
+    // Put a response in the cache.
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=60")
+        .setBody("a"));
+    URL url = server.getUrl("/a");
+    assertEquals("a", get(url).body().string());
+
+    // Remove it with iteration.
+    Iterator<String> i = cache.urls();
+    assertEquals(url.toString(), i.next());
+    i.remove();
+
+    // Confirm that subsequent requests suffer a cache miss.
+    server.enqueue(new MockResponse()
+        .setBody("b"));
+    assertEquals("b", get(url).body().string());
+  }
+
+  @Test public void iteratorRemoveWithoutNextThrows() throws Exception {
+    // Put a response in the cache.
+    server.enqueue(new MockResponse()
+        .setBody("a"));
+    URL url = server.getUrl("/a");
+    assertEquals("a", get(url).body().string());
+
+    Iterator<String> i = cache.urls();
+    assertTrue(i.hasNext());
+    try {
+      i.remove();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void iteratorRemoveOncePerCallToNext() throws Exception {
+    // Put a response in the cache.
+    server.enqueue(new MockResponse()
+        .setBody("a"));
+    URL url = server.getUrl("/a");
+    assertEquals("a", get(url).body().string());
+
+    Iterator<String> i = cache.urls();
+    assertEquals(url.toString(), i.next());
+    i.remove();
+
+    // Too many calls to remove().
+    try {
+      i.remove();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void elementEvictedBetweenHasNextAndNext() throws Exception {
+    // Put a response in the cache.
+    server.enqueue(new MockResponse()
+        .setBody("a"));
+    URL url = server.getUrl("/a");
+    assertEquals("a", get(url).body().string());
+
+    // The URL will remain available if hasNext() returned true...
+    Iterator<String> i = cache.urls();
+    assertTrue(i.hasNext());
+
+    // ...so even when we evict the element, we still get something back.
+    cache.evictAll();
+    assertEquals(url.toString(), i.next());
+
+    // Remove does nothing. But most importantly, it doesn't throw!
+    i.remove();
+  }
+
+  @Test public void elementEvictedBeforeHasNextIsOmitted() throws Exception {
+    // Put a response in the cache.
+    server.enqueue(new MockResponse()
+        .setBody("a"));
+    URL url = server.getUrl("/a");
+    assertEquals("a", get(url).body().string());
+
+    Iterator<String> i = cache.urls();
+    cache.evictAll();
+
+    // The URL was evicted before hasNext() made any promises.
+    assertFalse(i.hasNext());
+    try {
+      i.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+  }
+
+  private Response get(URL url) throws IOException {
+    Request request = new Request.Builder()
+        .url(url)
+        .build();
+    return client.newCall(request).execute();
+  }
+
+  private void writeFile(File directory, String file, String content) throws IOException {
+    BufferedSink sink = Okio.buffer(Okio.sink(new File(directory, file)));
+    sink.writeUtf8(content);
+    sink.close();
+  }
+
+  /**
+   * @param delta the offset from the current date to use. Negative
+   * values yield dates in the past; positive values yield dates in the
+   * future.
+   */
+  private String formatDate(long delta, TimeUnit timeUnit) {
+    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
+  }
+
+  private String formatDate(Date date) {
+    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
+    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
+    return rfc1123.format(date);
+  }
+
+  private void assertNotCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+  }
+
+  /** @return the request with the conditional get headers. */
+  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
+    // scenario 1: condition succeeds
+    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // scenario 2: condition fails
+    server.enqueue(response.setBody("B")
+        .setStatus("HTTP/1.1 200 B-OK"));
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 200 C-OK")
+        .setBody("C"));
+
+    URL valid = server.getUrl("/valid");
+    Response response1 = get(valid);
+    assertEquals("A", response1.body().string());
+    assertEquals(HttpURLConnection.HTTP_OK, response1.code());
+    assertEquals("A-OK", response1.message());
+    Response response2 = get(valid);
+    assertEquals("A", response2.body().string());
+    assertEquals(HttpURLConnection.HTTP_OK, response2.code());
+    assertEquals("A-OK", response2.message());
+
+    URL invalid = server.getUrl("/invalid");
+    Response response3 = get(invalid);
+    assertEquals("B", response3.body().string());
+    assertEquals(HttpURLConnection.HTTP_OK, response3.code());
+    assertEquals("B-OK", response3.message());
+    Response response4 = get(invalid);
+    assertEquals("C", response4.body().string());
+    assertEquals(HttpURLConnection.HTTP_OK, response4.code());
+    assertEquals("C-OK", response4.message());
+
+    server.takeRequest(); // regular get
+    return server.takeRequest(); // conditional get
+  }
+
+  private void assertFullyCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
+    server.enqueue(response.setBody("B"));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", get(url).body().string());
+    assertEquals("A", get(url).body().string());
+  }
+
+  /**
+   * Shortens the body of {@code response} but not the corresponding headers.
+   * Only useful to test how clients respond to the premature conclusion of
+   * the HTTP body.
+   */
+  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
+    response.setSocketPolicy(DISCONNECT_AT_END);
+    List<String> headers = new ArrayList<>(response.getHeaders());
+    Buffer truncatedBody = new Buffer();
+    truncatedBody.write(response.getBody(), numBytesToKeep);
+    response.setBody(truncatedBody);
+    response.getHeaders().clear();
+    response.getHeaders().addAll(headers);
+    return response;
+  }
+
+  enum TransferKind {
+    CHUNKED() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
+          throws IOException {
+        response.setChunkedBody(content, chunkSize);
+      }
+    },
+    FIXED_LENGTH() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+      }
+    },
+    END_OF_STREAM() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+        response.setSocketPolicy(DISCONNECT_AT_END);
+        for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
+          if (h.next().startsWith("Content-Length:")) {
+            h.remove();
+            break;
+          }
+        }
+      }
+    };
+
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
+
+    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
+    }
+  }
+
+  /** Returns a gzipped copy of {@code bytes}. */
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
new file mode 100644
index 0000000000..7cd24fa705
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
@@ -0,0 +1,1692 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.DoubleInetAddressNetwork;
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.RecordingHostnameVerifier;
+import com.squareup.okhttp.internal.RecordingOkAuthenticator;
+import com.squareup.okhttp.internal.SingleInetAddressNetwork;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.Dispatcher;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.SocketPolicy;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.net.CookieManager;
+import java.net.HttpCookie;
+import java.net.HttpURLConnection;
+import java.net.SocketException;
+import java.net.URL;
+import java.security.cert.Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLProtocolException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.rules.Timeout;
+
+import static com.squareup.okhttp.internal.Internal.logger;
+import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CallTest {
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+
+  @Rule public TestRule timeout = new Timeout(30_000);
+
+  @Rule public MockWebServerRule server = new MockWebServerRule();
+  @Rule public MockWebServerRule server2 = new MockWebServerRule();
+  private OkHttpClient client = new OkHttpClient();
+  private RecordingCallback callback = new RecordingCallback();
+  private TestLogHandler logHandler = new TestLogHandler();
+  private Cache cache;
+
+  @Before public void setUp() throws Exception {
+    client = new OkHttpClient();
+    callback = new RecordingCallback();
+    logHandler = new TestLogHandler();
+
+    String tmp = System.getProperty("java.io.tmpdir");
+    File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
+    cache = new Cache(cacheDir, Integer.MAX_VALUE);
+    logger.addHandler(logHandler);
+  }
+
+  @After public void tearDown() throws Exception {
+    cache.delete();
+    logger.removeHandler(logHandler);
+  }
+
+  @Test public void get() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc").addHeader("Content-Type: text/plain"));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertSuccessful()
+        .assertHeader("Content-Type", "text/plain")
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("GET", recordedRequest.getMethod());
+    assertEquals("SyncApiTest", recordedRequest.getHeader("User-Agent"));
+    assertEquals(0, recordedRequest.getBody().length);
+    assertNull(recordedRequest.getHeader("Content-Length"));
+  }
+
+  @Test public void lazilyEvaluateRequestUrl() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request1 = new Request.Builder()
+        .url("foo://bar?baz")
+        .build();
+    Request request2 = request1.newBuilder()
+        .url(server.getUrl("/"))
+        .build();
+    executeSynchronously(request2)
+        .assertCode(200)
+        .assertSuccessful()
+        .assertBody("abc");
+  }
+
+  @Ignore // TODO(jwilson): fix.
+  @Test public void invalidScheme() throws Exception {
+    try {
+      Request request = new Request.Builder()
+          .url("ftp://hostname/path")
+          .build();
+      executeSynchronously(request);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void getReturns500() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(500));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(500)
+        .assertNotSuccessful();
+  }
+
+  @Test public void get_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    get();
+  }
+
+  @Test public void get_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    get();
+  }
+
+  @Test public void getWithRequestBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    try {
+      new Request.Builder().method("GET", RequestBody.create(MediaType.parse("text/plain"), "abc"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void head() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain"));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .head()
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertHeader("Content-Type", "text/plain");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("HEAD", recordedRequest.getMethod());
+    assertEquals("SyncApiTest", recordedRequest.getHeader("User-Agent"));
+    assertEquals(0, recordedRequest.getBody().length);
+    assertNull(recordedRequest.getHeader("Content-Length"));
+  }
+
+  @Test public void head_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    head();
+  }
+
+  @Test public void head_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    head();
+  }
+
+  @Test public void post() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("POST", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getUtf8Body());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void post_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    post();
+  }
+
+  @Test public void post_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    post();
+  }
+
+  @Test public void postZeroLength() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .method("POST", null)
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("POST", recordedRequest.getMethod());
+    assertEquals(0, recordedRequest.getBody().length);
+    assertEquals("0", recordedRequest.getHeader("Content-Length"));
+    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void postZeroLength_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    postZeroLength();
+  }
+
+  @Test public void postZerolength_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postZeroLength();
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(401));
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .method("POST", RequestBody.create(null, body))
+        .build();
+
+    String credential = Credentials.basic("jesse", "secret");
+    client.setAuthenticator(new RecordingOkAuthenticator(credential));
+
+    Response response = client.newCall(request).execute();
+    assertEquals(200, response.code());
+
+    RecordedRequest recordedRequest1 = server.takeRequest();
+    assertEquals("POST", recordedRequest1.getMethod());
+    assertEquals(body, recordedRequest1.getUtf8Body());
+    assertNull(recordedRequest1.getHeader("Authorization"));
+
+    RecordedRequest recordedRequest2 = server.takeRequest();
+    assertEquals("POST", recordedRequest2.getMethod());
+    assertEquals(body, recordedRequest2.getUtf8Body());
+    assertEquals(credential, recordedRequest2.getHeader("Authorization"));
+  }
+
+  @Test public void attemptAuthorization20Times() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse().setResponseCode(401));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+
+    String credential = Credentials.basic("jesse", "secret");
+    client.setAuthenticator(new RecordingOkAuthenticator(credential));
+
+    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("Success!");
+  }
+
+  @Test public void doesNotAttemptAuthorization21Times() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse().setResponseCode(401));
+    }
+
+    String credential = Credentials.basic("jesse", "secret");
+    client.setAuthenticator(new RecordingOkAuthenticator(credential));
+
+    try {
+      client.newCall(new Request.Builder().url(server.getUrl("/0")).build()).execute();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("Too many follow-up requests: 21", expected.getMessage());
+    }
+  }
+
+  @Test public void delete() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .delete()
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("DELETE", recordedRequest.getMethod());
+    assertEquals(0, recordedRequest.getBody().length);
+    assertEquals("0", recordedRequest.getHeader("Content-Length"));
+    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void delete_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    delete();
+  }
+
+  @Test public void delete_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    delete();
+  }
+
+  @Test public void put() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .put(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("PUT", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getUtf8Body());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void put_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    put();
+  }
+
+  @Test public void put_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    put();
+  }
+
+  @Test public void patch() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .patch(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("PATCH", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getUtf8Body());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void patch_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    patch();
+  }
+
+  @Test public void patch_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    patch();
+  }
+
+  @Test public void unspecifiedRequestBodyContentTypeDoesNotGetDefault() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .method("POST", RequestBody.create(null, "abc"))
+        .build();
+
+    executeSynchronously(request).assertCode(200);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("abc", recordedRequest.getUtf8Body());
+  }
+
+  @Test public void illegalToExecuteTwice() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    Call call = client.newCall(request);
+    call.execute();
+
+    try {
+      call.execute();
+      fail();
+    } catch (IllegalStateException e){
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    try {
+      call.enqueue(callback);
+      fail();
+    } catch (IllegalStateException e){
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: SyncApiTest"));
+  }
+
+  @Test public void illegalToExecuteTwice_Async() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    Call call = client.newCall(request);
+    call.enqueue(callback);
+
+    try {
+      call.execute();
+      fail();
+    } catch (IllegalStateException e){
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    try {
+      call.enqueue(callback);
+      fail();
+    } catch (IllegalStateException e){
+      assertEquals("Already Executed", e.getMessage());
+    }
+
+    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: SyncApiTest"));
+  }
+
+  @Test public void get_Async() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "AsyncApiTest")
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url())
+        .assertCode(200)
+        .assertHeader("Content-Type", "text/plain")
+        .assertBody("abc");
+
+    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: AsyncApiTest"));
+  }
+
+  @Test public void exceptionThrownByOnResponseIsRedactedAndLogged() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/secret"))
+        .build();
+
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        fail();
+      }
+
+      @Override public void onResponse(Response response) throws IOException {
+        throw new IOException("a");
+      }
+    });
+
+    assertEquals("INFO: Callback failure for call to " + server.getUrl("/") + "...",
+        logHandler.take());
+  }
+
+  @Test public void connectionPooling() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/a")).build())
+        .assertBody("abc");
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/b")).build())
+        .assertBody("def");
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/c")).build())
+        .assertBody("ghi");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionPooling_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+
+    client.newCall(new Request.Builder().url(server.getUrl("/a")).build()).enqueue(callback);
+    callback.await(server.getUrl("/a")).assertBody("abc");
+
+    client.newCall(new Request.Builder().url(server.getUrl("/b")).build()).enqueue(callback);
+    callback.await(server.getUrl("/b")).assertBody("def");
+
+    client.newCall(new Request.Builder().url(server.getUrl("/c")).build()).enqueue(callback);
+    callback.await(server.getUrl("/c")).assertBody("ghi");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void connectionReuseWhenResponseBodyConsumed_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        throw new AssertionError();
+      }
+
+      @Override public void onResponse(Response response) throws IOException {
+        InputStream bytes = response.body().byteStream();
+        assertEquals('a', bytes.read());
+        assertEquals('b', bytes.read());
+        assertEquals('c', bytes.read());
+
+        // This request will share a connection with 'A' cause it's all done.
+        client.newCall(new Request.Builder().url(server.getUrl("/b")).build()).enqueue(callback);
+      }
+    });
+
+    callback.await(server.getUrl("/b")).assertCode(200).assertBody("def");
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reuse!
+  }
+
+  @Test public void timeoutsUpdatedOnReusedConnections() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
+
+    // First request: time out after 1000ms.
+    client.setReadTimeout(1000, TimeUnit.MILLISECONDS);
+    executeSynchronously(new Request.Builder().url(server.getUrl("/a")).build()).assertBody("abc");
+
+    // Second request: time out after 250ms.
+    client.setReadTimeout(250, TimeUnit.MILLISECONDS);
+    Request request = new Request.Builder().url(server.getUrl("/b")).build();
+    Response response = client.newCall(request).execute();
+    BufferedSource bodySource = response.body().source();
+    assertEquals('d', bodySource.readByte());
+
+    // The second byte of this request will be delayed by 750ms so we should time out after 250ms.
+    long startNanos = System.nanoTime();
+    try {
+      bodySource.readByte();
+      fail();
+    } catch (IOException expected) {
+      // Timed out as expected.
+      long elapsedNanos = System.nanoTime() - startNanos;
+      long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(elapsedNanos);
+      assertTrue(String.format("Timed out: %sms", elapsedMillis), elapsedMillis < 500);
+    }
+  }
+
+  @Test public void timeoutsNotRetried() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
+    server.enqueue(new MockResponse()
+        .setBody("unreachable!"));
+
+    Internal.instance.setNetwork(client, new DoubleInetAddressNetwork());
+    client.setReadTimeout(100, TimeUnit.MILLISECONDS);
+
+    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    try {
+      // If this succeeds, too many requests were made.
+      client.newCall(request).execute();
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+  }
+
+  @Test public void tls() throws Exception {
+    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build())
+        .assertHandshake();
+  }
+
+  @Test public void tls_Async() throws Exception {
+    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url()).assertHandshake();
+  }
+
+  @Test public void recoverWhenRetryOnConnectionFailureIsTrue() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+    server.enqueue(new MockResponse().setBody("retry success"));
+
+    Internal.instance.setNetwork(client, new DoubleInetAddressNetwork());
+    assertTrue(client.getRetryOnConnectionFailure());
+
+    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Response response = client.newCall(request).execute();
+    assertEquals("retry success", response.body().string());
+  }
+
+  @Test public void noRecoverWhenRetryOnConnectionFailureIsFalse() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+    server.enqueue(new MockResponse().setBody("unreachable!"));
+
+    Internal.instance.setNetwork(client, new DoubleInetAddressNetwork());
+    client.setRetryOnConnectionFailure(false);
+
+    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    try {
+      // If this succeeds, too many requests were made.
+      client.newCall(request).execute();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void recoverFromTlsHandshakeFailure() throws Exception {
+    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    suppressTlsFallbackScsv(client);
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    Internal.instance.setNetwork(client, new SingleInetAddressNetwork());
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build())
+        .assertBody("abc");
+  }
+
+  @Test public void recoverFromTlsHandshakeFailure_tlsFallbackScsvEnabled() throws Exception {
+    final String tlsFallbackScsv = "TLS_FALLBACK_SCSV";
+    List<String> supportedCiphers =
+        Arrays.asList(sslContext.getSocketFactory().getSupportedCipherSuites());
+    if (!supportedCiphers.contains(tlsFallbackScsv)) {
+      // This only works if the client socket supports TLS_FALLBACK_SCSV.
+      return;
+    }
+
+    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+
+    RecordingSSLSocketFactory clientSocketFactory =
+        new RecordingSSLSocketFactory(sslContext.getSocketFactory());
+    client.setSslSocketFactory(clientSocketFactory);
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    Internal.instance.setNetwork(client, new SingleInetAddressNetwork());
+
+    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (SSLHandshakeException expected) {
+    }
+
+    List<SSLSocket> clientSockets = clientSocketFactory.getSocketsCreated();
+    SSLSocket firstSocket = clientSockets.get(0);
+    assertFalse(Arrays.asList(firstSocket.getEnabledCipherSuites()).contains(tlsFallbackScsv));
+    SSLSocket secondSocket = clientSockets.get(1);
+    assertTrue(Arrays.asList(secondSocket.getEnabledCipherSuites()).contains(tlsFallbackScsv));
+  }
+
+  @Test public void recoverFromTlsHandshakeFailure_Async() throws Exception {
+    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    suppressTlsFallbackScsv(client);
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url()).assertBody("abc");
+  }
+
+  @Test public void noRecoveryFromTlsHandshakeFailureWhenTlsFallbackIsDisabled() throws Exception {
+    client.setConnectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT));
+
+    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+
+    suppressTlsFallbackScsv(client);
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    Internal.instance.setNetwork(client, new SingleInetAddressNetwork());
+
+    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (SSLProtocolException expected) {
+      // RI response to the FAIL_HANDSHAKE
+    } catch (SSLHandshakeException expected) {
+      // Android's response to the FAIL_HANDSHAKE
+    }
+  }
+
+  @Test public void cleartextCallsFailWhenCleartextIsDisabled() throws Exception {
+    // Configure the client with only TLS configurations. No cleartext!
+    client.setConnectionSpecs(Arrays.asList(
+        ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS));
+
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (SocketException expected) {
+      assertTrue(expected.getMessage().contains("exhausted connection specs"));
+    }
+  }
+
+  @Test public void setFollowSslRedirectsFalse() throws Exception {
+    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: http://square.com"));
+
+    client.setFollowSslRedirects(false);
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Response response = client.newCall(request).execute();
+    assertEquals(301, response.code());
+  }
+
+  @Test public void matchingPinnedCertificate() throws Exception {
+    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    // Make a first request without certificate pinning. Use it to collect certificates to pin.
+    Request request1 = new Request.Builder().url(server.getUrl("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    CertificatePinner.Builder certificatePinnerBuilder = new CertificatePinner.Builder();
+    for (Certificate certificate : response1.handshake().peerCertificates()) {
+      certificatePinnerBuilder.add(server.get().getHostName(), CertificatePinner.pin(certificate));
+    }
+
+    // Make another request with certificate pinning. It should complete normally.
+    client.setCertificatePinner(certificatePinnerBuilder.build());
+    Request request2 = new Request.Builder().url(server.getUrl("/")).build();
+    Response response2 = client.newCall(request2).execute();
+    assertNotSame(response2.handshake(), response1.handshake());
+  }
+
+  @Test public void unmatchingPinnedCertificate() throws Exception {
+    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse());
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    // Pin publicobject.com's cert.
+    client.setCertificatePinner(new CertificatePinner.Builder()
+        .add(server.get().getHostName(), "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+        .build());
+
+    // When we pin the wrong certificate, connectivity fails.
+    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+      assertTrue(expected.getMessage().startsWith("Certificate pinning failure!"));
+    }
+  }
+
+  @Test public void post_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url())
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("def", recordedRequest.getUtf8Body());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    // Seed the connection pool so we have something that can fail.
+    Request request1 = new Request.Builder().url(server.getUrl("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("abc", response1.body().string());
+
+    Request request2 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "body!"))
+        .build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("def", response2.body().string());
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals(0, get.getSequenceNumber());
+
+    RecordedRequest post1 = server.takeRequest();
+    assertEquals("body!", post1.getUtf8Body());
+    assertEquals(1, post1.getSequenceNumber());
+
+    RecordedRequest post2 = server.takeRequest();
+    assertEquals("body!", post2.getUtf8Body());
+    assertEquals(0, post2.getSequenceNumber());
+  }
+
+  @Test public void cacheHit() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Charset")
+        .setBody("A"));
+
+    client.setCache(cache);
+
+    // Store a response in the cache.
+    URL url = server.getUrl("/");
+    Request cacheStoreRequest = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "fr-CA")
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    executeSynchronously(cacheStoreRequest)
+        .assertCode(200)
+        .assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    // Hit that stored response.
+    Request cacheHitRequest = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "en-US") // Different, but Vary says it doesn't matter.
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    RecordedResponse cacheHit = executeSynchronously(cacheHitRequest);
+
+    // Check the merged response. The request is the application's original request.
+    cacheHit.assertCode(200)
+        .assertBody("A")
+        .assertHeader("ETag", "v1")
+        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestHeader("Accept-Language", "en-US")
+        .assertRequestHeader("Accept-Charset", "UTF-8");
+
+    // Check the cached response. Its request contains only the saved Vary headers.
+    cacheHit.cacheResponse()
+        .assertCode(200)
+        .assertHeader("ETag", "v1")
+        .assertRequestMethod("GET")
+        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestHeader("Accept-Language")
+        .assertRequestHeader("Accept-Charset", "UTF-8");
+
+    cacheHit.assertNoNetworkResponse();
+  }
+
+  @Test public void conditionalCacheHit() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Vary: Accept-Charset")
+        .addHeader("Donut: a")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .addHeader("Donut: b")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    client.setCache(cache);
+
+    // Store a response in the cache.
+    URL url = server.getUrl("/");
+    Request cacheStoreRequest = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "fr-CA")
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    executeSynchronously(cacheStoreRequest)
+        .assertCode(200)
+        .assertHeader("Donut", "a")
+        .assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    // Hit that stored response.
+    Request cacheHitRequest = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "en-US") // Different, but Vary says it doesn't matter.
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    RecordedResponse cacheHit = executeSynchronously(cacheHitRequest);
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+
+    // Check the merged response. The request is the application's original request.
+    cacheHit.assertCode(200)
+        .assertBody("A")
+        .assertHeader("Donut", "b")
+        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestHeader("Accept-Language", "en-US")
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertRequestHeader("If-None-Match"); // No If-None-Match on the user's request.
+
+    // Check the cached response. Its request contains only the saved Vary headers.
+    cacheHit.cacheResponse()
+        .assertCode(200)
+        .assertHeader("Donut", "a")
+        .assertHeader("ETag", "v1")
+        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestHeader("Accept-Language") // No Vary on Accept-Language.
+        .assertRequestHeader("Accept-Charset", "UTF-8") // Because of Vary on Accept-Charset.
+        .assertRequestHeader("If-None-Match"); // This wasn't present in the original request.
+
+    // Check the network response. It has the caller's request, plus some caching headers.
+    cacheHit.networkResponse()
+        .assertCode(304)
+        .assertHeader("Donut", "b")
+        .assertRequestHeader("Accept-Language", "en-US")
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertRequestHeader("If-None-Match", "v1"); // If-None-Match in the validation request.
+  }
+
+  @Test public void conditionalCacheHit_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    client.setCache(cache);
+
+    Request request1 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request1).enqueue(callback);
+    callback.await(request1.url()).assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    Request request2 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request2).enqueue(callback);
+    callback.await(request2.url()).assertCode(200).assertBody("A");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void conditionalCacheMiss() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Vary: Accept-Charset")
+        .addHeader("Donut: a")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Donut: b")
+        .setBody("B"));
+
+    client.setCache(cache);
+
+    Request cacheStoreRequest = new Request.Builder()
+        .url(server.getUrl("/"))
+        .addHeader("Accept-Language", "fr-CA")
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    executeSynchronously(cacheStoreRequest)
+        .assertCode(200)
+        .assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    Request cacheMissRequest = new Request.Builder()
+        .url(server.getUrl("/"))
+        .addHeader("Accept-Language", "en-US") // Different, but Vary says it doesn't matter.
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    RecordedResponse cacheHit = executeSynchronously(cacheMissRequest);
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+
+    // Check the user response. It has the application's original request.
+    cacheHit.assertCode(200)
+        .assertBody("B")
+        .assertHeader("Donut", "b")
+        .assertRequestUrl(cacheStoreRequest.url());
+
+    // Check the cache response. Even though it's a miss, we used the cache.
+    cacheHit.cacheResponse()
+        .assertCode(200)
+        .assertHeader("Donut", "a")
+        .assertHeader("ETag", "v1")
+        .assertRequestUrl(cacheStoreRequest.url());
+
+    // Check the network response. It has the network request, plus caching headers.
+    cacheHit.networkResponse()
+        .assertCode(200)
+        .assertHeader("Donut", "b")
+        .assertRequestHeader("If-None-Match", "v1")  // If-None-Match in the validation request.
+        .assertRequestUrl(cacheStoreRequest.url());
+  }
+
+  @Test public void conditionalCacheMiss_Async() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    client.setCache(cache);
+
+    Request request1 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request1).enqueue(callback);
+    callback.await(request1.url()).assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    Request request2 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request2).enqueue(callback);
+    callback.await(request2.url()).assertCode(200).assertBody("B");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void onlyIfCachedReturns504WhenNotCached() throws Exception {
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Cache-Control", "only-if-cached")
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(504)
+        .assertBody("")
+        .assertNoNetworkResponse()
+        .assertNoCacheResponse();
+  }
+
+  @Test public void redirect() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .addHeader("Test", "Redirect from /a to /b")
+        .setBody("/a has moved!"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /c")
+        .addHeader("Test", "Redirect from /b to /c")
+        .setBody("/b has moved!"));
+    server.enqueue(new MockResponse().setBody("C"));
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/a")).build())
+        .assertCode(200)
+        .assertBody("C")
+        .priorResponse()
+        .assertCode(302)
+        .assertHeader("Test", "Redirect from /b to /c")
+        .priorResponse()
+        .assertCode(301)
+        .assertHeader("Test", "Redirect from /a to /b");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+  }
+
+  @Test public void postRedirectsToGet() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /page2")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("Page 2"));
+
+    Response response = client.newCall(new Request.Builder()
+        .url(server.getUrl("/page1"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
+        .build()).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest page1 = server.takeRequest();
+    assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
+    assertEquals("Request Body", page1.getUtf8Body());
+
+    RecordedRequest page2 = server.takeRequest();
+    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
+  }
+
+  @Test public void redirectsDoNotIncludeTooManyCookies() throws Exception {
+    server2.enqueue(new MockResponse().setBody("Page 2"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.getUrl("/")));
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    HttpCookie cookie = new HttpCookie("c", "cookie");
+    cookie.setDomain(server.get().getCookieDomain());
+    cookie.setPath("/");
+    String portList = Integer.toString(server.getPort());
+    cookie.setPortlist(portList);
+    cookieManager.getCookieStore().add(server.getUrl("/").toURI(), cookie);
+    client.setCookieHandler(cookieManager);
+
+    Response response = client.newCall(new Request.Builder()
+        .url(server.getUrl("/page1"))
+        .build()).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest request1 = server.takeRequest();
+    assertContains(request1.getHeaders(), "Cookie: $Version=\"1\"; "
+        + "c=\"cookie\";$Path=\"/\";$Domain=\"" + server.get().getCookieDomain()
+        + "\";$Port=\"" + portList + "\"");
+
+    RecordedRequest request2 = server2.takeRequest();
+    assertContainsNoneMatching(request2.getHeaders(), "Cookie.*");
+  }
+
+  @Test public void redirectsDoNotIncludeTooManyAuthHeaders() throws Exception {
+    server2.enqueue(new MockResponse().setBody("Page 2"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: " + server2.getUrl("/b")));
+
+    client.setAuthenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")));
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    Response response = client.newCall(request).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest redirectRequest = server2.takeRequest();
+    assertContainsNoneMatching(redirectRequest.getHeaders(), "Authorization.*");
+    assertEquals("/b", redirectRequest.getPath());
+  }
+
+  @Test public void redirect_Async() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .addHeader("Test", "Redirect from /a to /b")
+        .setBody("/a has moved!"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /c")
+        .addHeader("Test", "Redirect from /b to /c")
+        .setBody("/b has moved!"));
+    server.enqueue(new MockResponse().setBody("C"));
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(server.getUrl("/c"))
+        .assertCode(200)
+        .assertBody("C")
+        .priorResponse()
+        .assertCode(302)
+        .assertHeader("Test", "Redirect from /b to /c")
+        .priorResponse()
+        .assertCode(301)
+        .assertHeader("Test", "Redirect from /a to /b");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+  }
+
+  @Test public void follow20Redirects() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/0")).build())
+        .assertCode(200)
+        .assertBody("Success!");
+  }
+
+  @Test public void follow20Redirects_Async() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+
+    Request request = new Request.Builder().url(server.getUrl("/0")).build();
+    client.newCall(request).enqueue(callback);
+    callback.await(server.getUrl("/20"))
+        .assertCode(200)
+        .assertBody("Success!");
+  }
+
+  @Test public void doesNotFollow21Redirects() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+
+    try {
+      client.newCall(new Request.Builder().url(server.getUrl("/0")).build()).execute();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("Too many follow-up requests: 21", expected.getMessage());
+    }
+  }
+
+  @Test public void doesNotFollow21Redirects_Async() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+
+    Request request = new Request.Builder().url(server.getUrl("/0")).build();
+    client.newCall(request).enqueue(callback);
+    callback.await(server.getUrl("/20")).assertFailure("Too many follow-up requests: 21");
+  }
+
+  @Test public void canceledBeforeExecute() throws Exception {
+    Call call = client.newCall(new Request.Builder().url(server.getUrl("/a")).build());
+    call.cancel();
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+    assertEquals(0, server.getRequestCount());
+  }
+
+  @Test public void cancelTagImmediatelyAfterEnqueue() throws Exception {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.getUrl("/a"))
+        .tag("request")
+        .build());
+    call.enqueue(callback);
+    client.cancel("request");
+    assertEquals(0, server.getRequestCount());
+    callback.await(server.getUrl("/a")).assertFailure("Canceled");
+  }
+
+  @Test public void cancelBeforeBodyIsRead() throws Exception {
+    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
+
+    final Call call = client.newCall(new Request.Builder().url(server.getUrl("/a")).build());
+    ExecutorService executor = Executors.newSingleThreadExecutor();
+    Future<Response> result = executor.submit(new Callable<Response>() {
+      @Override public Response call() throws Exception {
+        return call.execute();
+      }
+    });
+
+    Thread.sleep(100); // wait for it to go in flight.
+
+    call.cancel();
+    try {
+      result.get().body().bytes();
+      fail();
+    } catch (IOException expected) {
+    }
+    assertEquals(1, server.getRequestCount());
+  }
+
+  @Test public void cancelInFlightBeforeResponseReadThrowsIOE() throws Exception {
+    server.get().setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        client.cancel("request");
+        return new MockResponse().setBody("A");
+      }
+    });
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).tag("request").build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    cancelInFlightBeforeResponseReadThrowsIOE();
+  }
+
+  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    cancelInFlightBeforeResponseReadThrowsIOE();
+  }
+
+  /**
+   * This test puts a request in front of one that is to be canceled, so that it is canceled before
+   * I/O takes place.
+   */
+  @Test public void canceledBeforeIOSignalsOnFailure() throws Exception {
+    client.getDispatcher().setMaxRequests(1); // Force requests to be executed serially.
+    server.get().setDispatcher(new Dispatcher() {
+      char nextResponse = 'A';
+
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        client.cancel("request B");
+        return new MockResponse().setBody(Character.toString(nextResponse++));
+      }
+    });
+
+    Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    client.newCall(requestA).enqueue(callback);
+    assertEquals("/a", server.takeRequest().getPath());
+
+    Request requestB = new Request.Builder().url(server.getUrl("/b")).tag("request B").build();
+    client.newCall(requestB).enqueue(callback);
+
+    callback.await(requestA.url()).assertBody("A");
+    // At this point we know the callback is ready, and that it will receive a cancel failure.
+    callback.await(requestB.url()).assertFailure("Canceled");
+  }
+
+  @Test public void canceledBeforeIOSignalsOnFailure_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    canceledBeforeIOSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeIOSignalsOnFailure_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    canceledBeforeIOSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
+    Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    final Call call = client.newCall(requestA);
+    server.get().setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        call.cancel();
+        return new MockResponse().setBody("A");
+      }
+    });
+
+    call.enqueue(callback);
+    assertEquals("/a", server.takeRequest().getPath());
+
+    callback.await(requestA.url()).assertFailure(
+        "Canceled", "stream was reset: CANCEL", "Socket closed");
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    canceledBeforeResponseReadSignalsOnFailure();
+  }
+
+  @Test public void canceledBeforeResponseReadSignalsOnFailure_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    canceledBeforeResponseReadSignalsOnFailure();
+  }
+
+  /**
+   * There's a race condition where the cancel may apply after the stream has already been
+   * processed.
+   */
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<String> bodyRef = new AtomicReference<>();
+    final AtomicBoolean failureRef = new AtomicBoolean();
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    final Call call = client.newCall(request);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        failureRef.set(true);
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Response response) throws IOException {
+        call.cancel();
+        try {
+          bodyRef.set(response.body().string());
+        } catch (IOException e) { // It is ok if this broke the stream.
+          bodyRef.set("A");
+          throw e; // We expect to not loop into onFailure in this case.
+        } finally {
+          latch.countDown();
+        }
+      }
+    });
+
+    latch.await();
+    assertEquals("A", bodyRef.get());
+    assertFalse(failureRef.get());
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTP_2()
+      throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_SPDY_3()
+      throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
+  }
+
+  @Test public void gzip() throws Exception {
+    Buffer gzippedBody = gzip("abcabcabc");
+    String bodySize = Long.toString(gzippedBody.size());
+
+    server.enqueue(new MockResponse()
+        .setBody(gzippedBody)
+        .addHeader("Content-Encoding: gzip"));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    // Confirm that the user request doesn't have Accept-Encoding, and the user
+    // response doesn't have a Content-Encoding or Content-Length.
+    RecordedResponse userResponse = executeSynchronously(request);
+    userResponse.assertCode(200)
+        .assertRequestHeader("Accept-Encoding")
+        .assertHeader("Content-Encoding")
+        .assertHeader("Content-Length")
+        .assertBody("abcabcabc");
+
+    // But the network request doesn't lie. OkHttp used gzip for this call.
+    userResponse.networkResponse()
+        .assertHeader("Content-Encoding", "gzip")
+        .assertHeader("Content-Length", bodySize)
+        .assertRequestHeader("Accept-Encoding", "gzip");
+  }
+
+  @Test public void asyncResponseCanBeConsumedLater() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    final BlockingQueue<Response> responseRef = new SynchronousQueue<>();
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        throw new AssertionError();
+      }
+
+      @Override public void onResponse(Response response) throws IOException {
+        try {
+          responseRef.put(response);
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+      }
+    });
+
+    Response response = responseRef.take();
+    assertEquals(200, response.code());
+    assertEquals("abc", response.body().string());
+
+    // Make another request just to confirm that that connection can be reused...
+    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build()).assertBody("def");
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+
+    // ... even before we close the response body!
+    response.body().close();
+  }
+
+  @Test public void userAgentIsIncludedByDefault() throws Exception {
+    server.enqueue(new MockResponse());
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build());
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertTrue(recordedRequest.getHeader("User-Agent")
+        .matches("okhttp/\\d\\.\\d\\.\\d(-SNAPSHOT|-RC\\d+)?"));
+  }
+
+  @Test public void setFollowRedirectsFalse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    client.setFollowRedirects(false);
+    RecordedResponse recordedResponse = executeSynchronously(
+        new Request.Builder().url(server.getUrl("/a")).build());
+
+    recordedResponse
+        .assertBody("A")
+        .assertCode(302);
+  }
+
+  private RecordedResponse executeSynchronously(Request request) throws IOException {
+    Response response = client.newCall(request).execute();
+    return new RecordedResponse(request, response, null, response.body().string(), null);
+  }
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
+   */
+  private void enableProtocol(Protocol protocol) {
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
+    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.get().setProtocols(client.getProtocols());
+  }
+
+  private Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
+  }
+
+  private void assertContains(Collection<String> collection, String element) {
+    for (String c : collection) {
+      if (c != null && c.equalsIgnoreCase(element)) return;
+    }
+    fail("No " + element + " in " + collection);
+  }
+
+  private void assertContainsNoneMatching(List<String> headers, String pattern) {
+    for (String header : headers) {
+      if (header.matches(pattern)) {
+        fail("Header " + header + " matches " + pattern);
+      }
+    }
+  }
+
+  private static class RecordingSSLSocketFactory extends DelegatingSSLSocketFactory {
+
+    private List<SSLSocket> socketsCreated = new ArrayList<SSLSocket>();
+
+    public RecordingSSLSocketFactory(SSLSocketFactory delegate) {
+      super(delegate);
+    }
+
+    @Override
+    protected void configureSocket(SSLSocket sslSocket) throws IOException {
+      socketsCreated.add(sslSocket);
+    }
+
+    public List<SSLSocket> getSocketsCreated() {
+      return socketsCreated;
+    }
+  }
+
+  /**
+   * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
+   * TLS_FALLBACK_SCSV cipher on fallback connections. See
+   * {@link com.squareup.okhttp.FallbackTestClientSocketFactory} for details.
+   */
+  private static void suppressTlsFallbackScsv(OkHttpClient client) {
+    FallbackTestClientSocketFactory clientSocketFactory =
+        new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
+    client.setSslSocketFactory(clientSocketFactory);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CertificatePinnerTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CertificatePinnerTest.java
new file mode 100644
index 0000000000..c5cea2803d
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CertificatePinnerTest.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.SslContextBuilder;
+import java.security.GeneralSecurityException;
+import java.security.KeyPair;
+import java.security.cert.X509Certificate;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import org.junit.Test;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CertificatePinnerTest {
+  static SslContextBuilder sslContextBuilder;
+
+  static KeyPair keyPairA;
+  static X509Certificate keypairACertificate1;
+  static String keypairACertificate1Pin;
+
+  static KeyPair keyPairB;
+  static X509Certificate keypairBCertificate1;
+  static String keypairBCertificate1Pin;
+
+  static {
+    try {
+      sslContextBuilder = new SslContextBuilder("example.com");
+
+      keyPairA = sslContextBuilder.generateKeyPair();
+      keypairACertificate1 = sslContextBuilder.selfSignedCertificate(keyPairA, "1");
+      keypairACertificate1Pin = CertificatePinner.pin(keypairACertificate1);
+
+      keyPairB = sslContextBuilder.generateKeyPair();
+      keypairBCertificate1 = sslContextBuilder.selfSignedCertificate(keyPairB, "1");
+      keypairBCertificate1Pin = CertificatePinner.pin(keypairBCertificate1);
+    } catch (GeneralSecurityException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  @Test public void malformedPin() throws Exception {
+    CertificatePinner.Builder builder = new CertificatePinner.Builder();
+    try {
+      builder.add("example.com", "md5/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void malformedBase64() throws Exception {
+    CertificatePinner.Builder builder = new CertificatePinner.Builder();
+    try {
+      builder.add("example.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw*");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  /** Multiple certificates generated from the same keypair have the same pin. */
+  @Test public void sameKeypairSamePin() throws Exception {
+    X509Certificate keypairACertificate2 = sslContextBuilder.selfSignedCertificate(keyPairA, "2");
+    String keypairACertificate2Pin = CertificatePinner.pin(keypairACertificate2);
+
+    X509Certificate keypairBCertificate2 = sslContextBuilder.selfSignedCertificate(keyPairB, "2");
+    String keypairBCertificate2Pin = CertificatePinner.pin(keypairBCertificate2);
+
+    assertTrue(keypairACertificate1Pin.equals(keypairACertificate2Pin));
+    assertTrue(keypairBCertificate1Pin.equals(keypairBCertificate2Pin));
+    assertFalse(keypairACertificate1Pin.equals(keypairBCertificate1Pin));
+  }
+
+  @Test public void successfulCheck() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", keypairACertificate1Pin)
+        .build();
+
+    certificatePinner.check("example.com", keypairACertificate1);
+  }
+
+  @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", keypairBCertificate1Pin)
+        .build();
+
+    certificatePinner.check("example.com", keypairACertificate1, keypairBCertificate1);
+  }
+
+  @Test public void unsuccessfulCheck() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", keypairACertificate1Pin)
+        .build();
+
+    try {
+      certificatePinner.check("example.com", keypairBCertificate1);
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void multipleCertificatesForOneHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", keypairACertificate1Pin, keypairBCertificate1Pin)
+        .build();
+
+    certificatePinner.check("example.com", keypairACertificate1);
+    certificatePinner.check("example.com", keypairBCertificate1);
+  }
+
+  @Test public void multipleHostnamesForOneCertificate() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", keypairACertificate1Pin)
+        .add("www.example.com", keypairACertificate1Pin)
+        .build();
+
+    certificatePinner.check("example.com", keypairACertificate1);
+    certificatePinner.check("www.example.com", keypairACertificate1);
+  }
+
+  @Test public void absentHostnameMatches() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder().build();
+    certificatePinner.check("example.com", keypairACertificate1);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
new file mode 100644
index 0000000000..0bdc9f58a4
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
@@ -0,0 +1,582 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.RecordingHostnameVerifier;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
+import com.squareup.okhttp.internal.http.RecordingProxySelector;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.Executor;
+import javax.net.SocketFactory;
+import javax.net.ssl.SSLContext;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class ConnectionPoolTest {
+  private static final int KEEP_ALIVE_DURATION_MS = 5000;
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+
+  private MockWebServer spdyServer;
+  private InetSocketAddress spdySocketAddress;
+  private Address spdyAddress;
+
+  private MockWebServer httpServer;
+  private Address httpAddress;
+  private InetSocketAddress httpSocketAddress;
+
+  private ConnectionPool pool;
+  private FakeExecutor cleanupExecutor;
+  private Connection httpA;
+  private Connection httpB;
+  private Connection httpC;
+  private Connection httpD;
+  private Connection httpE;
+  private Connection spdyA;
+
+  private Object owner;
+
+  @Before public void setUp() throws Exception {
+    setUp(2);
+  }
+
+  private void setUp(int poolSize) throws Exception {
+    SocketFactory socketFactory = SocketFactory.getDefault();
+    RecordingProxySelector proxySelector = new RecordingProxySelector();
+
+    spdyServer = new MockWebServer();
+    httpServer = new MockWebServer();
+    spdyServer.useHttps(sslContext.getSocketFactory(), false);
+
+    List<ConnectionSpec> connectionSpecs = Util.immutableList(
+        ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
+
+    httpServer.play();
+    httpAddress = new Address(httpServer.getHostName(), httpServer.getPort(), socketFactory, null,
+        null, null, AuthenticatorAdapter.INSTANCE, null,
+        Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1), connectionSpecs, proxySelector);
+    httpSocketAddress = new InetSocketAddress(InetAddress.getByName(httpServer.getHostName()),
+        httpServer.getPort());
+
+    spdyServer.play();
+    spdyAddress = new Address(spdyServer.getHostName(), spdyServer.getPort(), socketFactory,
+        sslContext.getSocketFactory(), new RecordingHostnameVerifier(), CertificatePinner.DEFAULT,
+        AuthenticatorAdapter.INSTANCE, null, Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1),
+        connectionSpecs, proxySelector);
+    spdySocketAddress = new InetSocketAddress(InetAddress.getByName(spdyServer.getHostName()),
+        spdyServer.getPort());
+
+    Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress,
+        ConnectionSpec.CLEARTEXT);
+    Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress,
+        ConnectionSpec.MODERN_TLS);
+    pool = new ConnectionPool(poolSize, KEEP_ALIVE_DURATION_MS);
+    // Disable the automatic execution of the cleanup.
+    cleanupExecutor = new FakeExecutor();
+    pool.replaceCleanupExecutorForTests(cleanupExecutor);
+    httpA = new Connection(pool, httpRoute);
+    httpA.connect(200, 200, 200, null);
+    httpB = new Connection(pool, httpRoute);
+    httpB.connect(200, 200, 200, null);
+    httpC = new Connection(pool, httpRoute);
+    httpC.connect(200, 200, 200, null);
+    httpD = new Connection(pool, httpRoute);
+    httpD.connect(200, 200, 200, null);
+    httpE = new Connection(pool, httpRoute);
+    httpE.connect(200, 200, 200, null);
+    spdyA = new Connection(pool, spdyRoute);
+    spdyA.connect(20000, 20000, 2000, null);
+
+    owner = new Object();
+    httpA.setOwner(owner);
+    httpB.setOwner(owner);
+    httpC.setOwner(owner);
+    httpD.setOwner(owner);
+    httpE.setOwner(owner);
+  }
+
+  @After public void tearDown() throws Exception {
+    httpServer.shutdown();
+    spdyServer.shutdown();
+
+    Util.closeQuietly(httpA.getSocket());
+    Util.closeQuietly(httpB.getSocket());
+    Util.closeQuietly(httpC.getSocket());
+    Util.closeQuietly(httpD.getSocket());
+    Util.closeQuietly(httpE.getSocket());
+    Util.closeQuietly(spdyA.getSocket());
+  }
+
+  private void resetWithPoolSize(int poolSize) throws Exception {
+    tearDown();
+    setUp(poolSize);
+  }
+
+  @Test public void poolSingleHttpConnection() throws Exception {
+    resetWithPoolSize(1);
+    Connection connection = pool.get(httpAddress);
+    assertNull(connection);
+
+    connection = new Connection(pool, new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress,
+        ConnectionSpec.CLEARTEXT));
+    connection.connect(200, 200, 200, null);
+    connection.setOwner(owner);
+    assertEquals(0, pool.getConnectionCount());
+
+    pool.recycle(connection);
+    assertNull(connection.getOwner());
+    assertEquals(1, pool.getConnectionCount());
+    assertEquals(1, pool.getHttpConnectionCount());
+    assertEquals(0, pool.getMultiplexedConnectionCount());
+
+    Connection recycledConnection = pool.get(httpAddress);
+    assertNull(connection.getOwner());
+    assertEquals(connection, recycledConnection);
+    assertTrue(recycledConnection.isAlive());
+
+    recycledConnection = pool.get(httpAddress);
+    assertNull(recycledConnection);
+  }
+
+  @Test public void getDoesNotScheduleCleanup() {
+    Connection connection = pool.get(httpAddress);
+    assertNull(connection);
+    cleanupExecutor.assertExecutionScheduled(false);
+  }
+
+  @Test public void recycleSchedulesCleanup() {
+    cleanupExecutor.assertExecutionScheduled(false);
+    pool.recycle(httpA);
+    cleanupExecutor.assertExecutionScheduled(true);
+  }
+
+  @Test public void shareSchedulesCleanup() {
+    cleanupExecutor.assertExecutionScheduled(false);
+    pool.share(spdyA);
+    cleanupExecutor.assertExecutionScheduled(true);
+  }
+
+  @Test public void poolPrefersMostRecentlyRecycled() throws Exception {
+    pool.recycle(httpA);
+    pool.recycle(httpB);
+    pool.recycle(httpC);
+    assertPooled(pool, httpC, httpB, httpA);
+
+    pool.performCleanup();
+    assertPooled(pool, httpC, httpB);
+  }
+
+  @Test public void getSpdyConnection() throws Exception {
+    pool.share(spdyA);
+    assertSame(spdyA, pool.get(spdyAddress));
+    assertPooled(pool, spdyA);
+  }
+
+  @Test public void getHttpConnection() throws Exception {
+    pool.recycle(httpA);
+    assertSame(httpA, pool.get(httpAddress));
+    assertPooled(pool);
+  }
+
+  @Test public void expiredConnectionNotReturned() throws Exception {
+    pool.recycle(httpA);
+
+    // Allow enough time to pass so that the connection is now expired.
+    Thread.sleep(KEEP_ALIVE_DURATION_MS * 2);
+
+    // The connection is held, but will not be returned.
+    assertNull(pool.get(httpAddress));
+    assertPooled(pool, httpA);
+
+    // The connection must be cleaned up.
+    pool.performCleanup();
+    assertPooled(pool);
+  }
+
+  @Test public void maxIdleConnectionLimitIsEnforced() throws Exception {
+    pool.recycle(httpA);
+    pool.recycle(httpB);
+    pool.recycle(httpC);
+    pool.recycle(httpD);
+    assertPooled(pool, httpD, httpC, httpB, httpA);
+
+    pool.performCleanup();
+    assertPooled(pool, httpD, httpC);
+  }
+
+  @Test public void expiredConnectionsAreEvicted() throws Exception {
+    pool.recycle(httpA);
+    pool.recycle(httpB);
+
+    // Allow enough time to pass so that the connections are now expired.
+    Thread.sleep(2 * KEEP_ALIVE_DURATION_MS);
+    assertPooled(pool, httpB, httpA);
+
+    // The connections must be cleaned up.
+    pool.performCleanup();
+    assertPooled(pool);
+  }
+
+  @Test public void nonAliveConnectionNotReturned() throws Exception {
+    pool.recycle(httpA);
+
+    // Close the connection. It is an ex-connection. It has ceased to be.
+    httpA.getSocket().close();
+    assertPooled(pool, httpA);
+    assertNull(pool.get(httpAddress));
+
+    // The connection must be cleaned up.
+    pool.performCleanup();
+    assertPooled(pool);
+  }
+
+  @Test public void differentAddressConnectionNotReturned() throws Exception {
+    pool.recycle(httpA);
+    assertNull(pool.get(spdyAddress));
+    assertPooled(pool, httpA);
+  }
+
+  @Test public void gettingSpdyConnectionPromotesItToFrontOfQueue() throws Exception {
+    pool.share(spdyA);
+    pool.recycle(httpA);
+    assertPooled(pool, httpA, spdyA);
+    assertSame(spdyA, pool.get(spdyAddress));
+    assertPooled(pool, spdyA, httpA);
+  }
+
+  @Test public void gettingConnectionReturnsOldestFirst() throws Exception {
+    pool.recycle(httpA);
+    pool.recycle(httpB);
+    assertSame(httpA, pool.get(httpAddress));
+  }
+
+  @Test public void recyclingNonAliveConnectionClosesThatConnection() throws Exception {
+    httpA.getSocket().shutdownInput();
+    pool.recycle(httpA); // Should close httpA.
+    assertTrue(httpA.getSocket().isClosed());
+
+    // The pool should remain empty, and there is no need to schedule a cleanup.
+    assertPooled(pool);
+    cleanupExecutor.assertExecutionScheduled(false);
+  }
+
+  @Test public void shareHttpConnectionFails() throws Exception {
+    try {
+      pool.share(httpA);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    // The pool should remain empty, and there is no need to schedule a cleanup.
+    assertPooled(pool);
+    cleanupExecutor.assertExecutionScheduled(false);
+  }
+
+  @Test public void recycleSpdyConnectionDoesNothing() throws Exception {
+    pool.recycle(spdyA);
+    // The pool should remain empty, and there is no need to schedule the cleanup.
+    assertPooled(pool);
+    cleanupExecutor.assertExecutionScheduled(false);
+  }
+
+  @Test public void validateIdleSpdyConnectionTimeout() throws Exception {
+    pool.share(spdyA);
+    assertPooled(pool, spdyA); // Connection should be in the pool.
+
+    Thread.sleep((long) (KEEP_ALIVE_DURATION_MS * 0.7));
+    pool.performCleanup();
+    assertPooled(pool, spdyA); // Connection should still be in the pool.
+
+    Thread.sleep((long) (KEEP_ALIVE_DURATION_MS * 0.4));
+    pool.performCleanup();
+    assertPooled(pool); // Connection should have been removed.
+  }
+
+  @Test public void validateIdleHttpConnectionTimeout() throws Exception {
+    pool.recycle(httpA);
+    assertPooled(pool, httpA); // Connection should be in the pool.
+    cleanupExecutor.assertExecutionScheduled(true);
+
+    Thread.sleep((long) (KEEP_ALIVE_DURATION_MS * 0.7));
+    pool.performCleanup();
+    assertPooled(pool, httpA); // Connection should still be in the pool.
+
+    Thread.sleep((long) (KEEP_ALIVE_DURATION_MS * 0.4));
+    pool.performCleanup();
+    assertPooled(pool); // Connection should have been removed.
+  }
+
+  @Test public void maxConnections() throws IOException, InterruptedException {
+    // Pool should be empty.
+    assertEquals(0, pool.getConnectionCount());
+
+    // http A should be added to the pool.
+    pool.recycle(httpA);
+    assertEquals(1, pool.getConnectionCount());
+    assertEquals(1, pool.getHttpConnectionCount());
+    assertEquals(0, pool.getMultiplexedConnectionCount());
+
+    // http B should be added to the pool.
+    pool.recycle(httpB);
+    assertEquals(2, pool.getConnectionCount());
+    assertEquals(2, pool.getHttpConnectionCount());
+    assertEquals(0, pool.getMultiplexedConnectionCount());
+
+    // http C should be added
+    pool.recycle(httpC);
+    assertEquals(3, pool.getConnectionCount());
+    assertEquals(3, pool.getHttpConnectionCount());
+    assertEquals(0, pool.getSpdyConnectionCount());
+
+    pool.performCleanup();
+
+    // http A should be removed by cleanup.
+    assertEquals(2, pool.getConnectionCount());
+    assertEquals(2, pool.getHttpConnectionCount());
+    assertEquals(0, pool.getMultiplexedConnectionCount());
+
+    // spdy A should be added
+    pool.share(spdyA);
+    assertEquals(3, pool.getConnectionCount());
+    assertEquals(2, pool.getHttpConnectionCount());
+    assertEquals(1, pool.getSpdyConnectionCount());
+
+    pool.performCleanup();
+
+    // http B should be removed by cleanup.
+    assertEquals(2, pool.getConnectionCount());
+    assertEquals(1, pool.getHttpConnectionCount());
+    assertEquals(1, pool.getMultiplexedConnectionCount());
+
+    // http C should be returned.
+    Connection recycledHttpConnection = pool.get(httpAddress);
+    recycledHttpConnection.setOwner(owner);
+    assertNotNull(recycledHttpConnection);
+    assertTrue(recycledHttpConnection.isAlive());
+    assertEquals(1, pool.getConnectionCount());
+    assertEquals(0, pool.getHttpConnectionCount());
+    assertEquals(1, pool.getMultiplexedConnectionCount());
+
+    // spdy A will be returned but also kept in the pool.
+    Connection sharedSpdyConnection = pool.get(spdyAddress);
+    assertNotNull(sharedSpdyConnection);
+    assertEquals(spdyA, sharedSpdyConnection);
+    assertEquals(1, pool.getConnectionCount());
+    assertEquals(0, pool.getHttpConnectionCount());
+    assertEquals(1, pool.getMultiplexedConnectionCount());
+
+    // http C should be added to the pool
+    pool.recycle(httpC);
+    assertEquals(2, pool.getConnectionCount());
+    assertEquals(1, pool.getHttpConnectionCount());
+    assertEquals(1, pool.getMultiplexedConnectionCount());
+
+    // An http connection should be removed from the pool.
+    recycledHttpConnection = pool.get(httpAddress);
+    assertNotNull(recycledHttpConnection);
+    assertTrue(recycledHttpConnection.isAlive());
+    assertEquals(1, pool.getConnectionCount());
+    assertEquals(0, pool.getHttpConnectionCount());
+    assertEquals(1, pool.getMultiplexedConnectionCount());
+
+    // spdy A will be returned but also kept in the pool.
+    sharedSpdyConnection = pool.get(spdyAddress);
+    assertEquals(spdyA, sharedSpdyConnection);
+    assertNotNull(sharedSpdyConnection);
+    assertEquals(1, pool.getConnectionCount());
+    assertEquals(0, pool.getHttpConnectionCount());
+    assertEquals(1, pool.getMultiplexedConnectionCount());
+
+    // http D should be added to the pool.
+    pool.recycle(httpD);
+    assertEquals(2, pool.getConnectionCount());
+    assertEquals(1, pool.getHttpConnectionCount());
+    assertEquals(1, pool.getMultiplexedConnectionCount());
+
+    // http E should be added to the pool.
+    pool.recycle(httpE);
+    assertEquals(3, pool.getConnectionCount());
+    assertEquals(2, pool.getHttpConnectionCount());
+    assertEquals(1, pool.getSpdyConnectionCount());
+
+    pool.performCleanup();
+
+    // spdy A should be removed from the pool by cleanup.
+    assertEquals(2, pool.getConnectionCount());
+    assertEquals(2, pool.getHttpConnectionCount());
+    assertEquals(0, pool.getMultiplexedConnectionCount());
+  }
+
+  @Test public void connectionCleanup() throws Exception {
+    ConnectionPool pool = new ConnectionPool(10, KEEP_ALIVE_DURATION_MS);
+
+    // Add 3 connections to the pool.
+    pool.recycle(httpA);
+    pool.recycle(httpB);
+    pool.share(spdyA);
+
+    // Give the cleanup callable time to run and settle down.
+    Thread.sleep(100);
+
+    // Kill http A.
+    Util.closeQuietly(httpA.getSocket());
+
+    assertEquals(3, pool.getConnectionCount());
+    assertEquals(2, pool.getHttpConnectionCount());
+    assertEquals(1, pool.getSpdyConnectionCount());
+
+    // Http A should be removed.
+    pool.performCleanup();
+    assertPooled(pool, spdyA, httpB);
+    assertEquals(2, pool.getConnectionCount());
+    assertEquals(1, pool.getHttpConnectionCount());
+    assertEquals(1, pool.getMultiplexedConnectionCount());
+
+    // Now let enough time pass for the connections to expire.
+    Thread.sleep(2 * KEEP_ALIVE_DURATION_MS);
+
+    // All remaining connections should be removed.
+    pool.performCleanup();
+    assertEquals(0, pool.getConnectionCount());
+  }
+
+  @Test public void maxIdleConnectionsLimitEnforced() throws Exception {
+    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
+
+    // Hit the max idle connections limit of 2.
+    pool.recycle(httpA);
+    pool.recycle(httpB);
+    Thread.sleep(100); // Give the cleanup callable time to run.
+    assertPooled(pool, httpB, httpA);
+
+    // Adding httpC bumps httpA.
+    pool.recycle(httpC);
+    Thread.sleep(100); // Give the cleanup callable time to run.
+    assertPooled(pool, httpC, httpB);
+
+    // Adding httpD bumps httpB.
+    pool.recycle(httpD);
+    Thread.sleep(100); // Give the cleanup callable time to run.
+    assertPooled(pool, httpD, httpC);
+
+    // Adding httpE bumps httpC.
+    pool.recycle(httpE);
+    Thread.sleep(100); // Give the cleanup callable time to run.
+    assertPooled(pool, httpE, httpD);
+  }
+
+  @Test public void evictAllConnections() throws Exception {
+    resetWithPoolSize(10);
+    pool.recycle(httpA);
+    Util.closeQuietly(httpA.getSocket()); // Include a closed connection in the pool.
+    pool.recycle(httpB);
+    pool.share(spdyA);
+    int connectionCount = pool.getConnectionCount();
+    assertTrue(connectionCount == 2 || connectionCount == 3);
+
+    pool.evictAll();
+    assertEquals(0, pool.getConnectionCount());
+  }
+
+  @Test public void closeIfOwnedBy() throws Exception {
+    httpA.closeIfOwnedBy(owner);
+    assertFalse(httpA.isAlive());
+    assertFalse(httpA.clearOwner());
+  }
+
+  @Test public void closeIfOwnedByDoesNothingIfNotOwner() throws Exception {
+    httpA.closeIfOwnedBy(new Object());
+    assertTrue(httpA.isAlive());
+    assertTrue(httpA.clearOwner());
+  }
+
+  @Test public void closeIfOwnedByFailsForSpdyConnections() throws Exception {
+    try {
+      spdyA.closeIfOwnedBy(owner);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void cleanupRunnableStopsEventually() throws Exception {
+    pool.recycle(httpA);
+    pool.share(spdyA);
+    assertPooled(pool, spdyA, httpA);
+
+    // The cleanup should terminate once the pool is empty again.
+    cleanupExecutor.fakeExecute();
+    assertPooled(pool);
+
+    cleanupExecutor.assertExecutionScheduled(false);
+
+    // Adding a new connection should cause the cleanup to start up again.
+    pool.recycle(httpB);
+
+    cleanupExecutor.assertExecutionScheduled(true);
+
+    // The cleanup should terminate once the pool is empty again.
+    cleanupExecutor.fakeExecute();
+    assertPooled(pool);
+  }
+
+  private void assertPooled(ConnectionPool pool, Connection... connections) throws Exception {
+    assertEquals(Arrays.asList(connections), pool.getConnections());
+  }
+
+  /**
+   * An executor that does not actually execute anything by default. See
+   * {@link #fakeExecute()}.
+   */
+  private static class FakeExecutor implements Executor {
+
+    private Runnable runnable;
+    
+    @Override
+    public void execute(Runnable runnable) {
+      // This is a bonus assertion for the invariant: At no time should two runnables be scheduled.
+      assertNull(this.runnable);
+      this.runnable = runnable;
+    }
+
+    public void assertExecutionScheduled(boolean expected) {
+      assertEquals(expected, runnable != null);
+    }
+
+    /**
+     * Executes the runnable.
+     */
+    public void fakeExecute() {
+      Runnable toRun = this.runnable;
+      this.runnable = null;
+      toRun.run();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocket.java b/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocket.java
new file mode 100644
index 0000000000..e13a50fcb9
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocket.java
@@ -0,0 +1,283 @@
+/*
+ * Copyright 2014 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.InetAddress;
+import java.net.SocketAddress;
+import java.net.SocketException;
+import java.nio.channels.SocketChannel;
+import javax.net.ssl.HandshakeCompletedListener;
+import javax.net.ssl.SSLParameters;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocket;
+
+/**
+ * An {@link javax.net.ssl.SSLSocket} that delegates all calls.
+ */
+public abstract class DelegatingSSLSocket extends SSLSocket {
+  protected final SSLSocket delegate;
+
+  public DelegatingSSLSocket(SSLSocket delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public void shutdownInput() throws IOException {
+    delegate.shutdownInput();
+  }
+
+  @Override public void shutdownOutput() throws IOException {
+    delegate.shutdownOutput();
+  }
+
+  @Override public String[] getSupportedCipherSuites() {
+    return delegate.getSupportedCipherSuites();
+  }
+
+  @Override public String[] getEnabledCipherSuites() {
+    return delegate.getEnabledCipherSuites();
+  }
+
+  @Override public void setEnabledCipherSuites(String[] suites) {
+    delegate.setEnabledCipherSuites(suites);
+  }
+
+  @Override public String[] getSupportedProtocols() {
+    return delegate.getSupportedProtocols();
+  }
+
+  @Override public String[] getEnabledProtocols() {
+    return delegate.getEnabledProtocols();
+  }
+
+  @Override public void setEnabledProtocols(String[] protocols) {
+    delegate.setEnabledProtocols(protocols);
+  }
+
+  @Override public SSLSession getSession() {
+    return delegate.getSession();
+  }
+
+  @Override public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {
+    delegate.addHandshakeCompletedListener(listener);
+  }
+
+  @Override public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {
+    delegate.removeHandshakeCompletedListener(listener);
+  }
+
+  @Override public void startHandshake() throws IOException {
+    delegate.startHandshake();
+  }
+
+  @Override public void setUseClientMode(boolean mode) {
+    delegate.setUseClientMode(mode);
+  }
+
+  @Override public boolean getUseClientMode() {
+    return delegate.getUseClientMode();
+  }
+
+  @Override public void setNeedClientAuth(boolean need) {
+    delegate.setNeedClientAuth(need);
+  }
+
+  @Override public void setWantClientAuth(boolean want) {
+    delegate.setWantClientAuth(want);
+  }
+
+  @Override public boolean getNeedClientAuth() {
+    return delegate.getNeedClientAuth();
+  }
+
+  @Override public boolean getWantClientAuth() {
+    return delegate.getWantClientAuth();
+  }
+
+  @Override public void setEnableSessionCreation(boolean flag) {
+    delegate.setEnableSessionCreation(flag);
+  }
+
+  @Override public boolean getEnableSessionCreation() {
+    return delegate.getEnableSessionCreation();
+  }
+
+  @Override public SSLParameters getSSLParameters() {
+    return delegate.getSSLParameters();
+  }
+
+  @Override public void setSSLParameters(SSLParameters p) {
+    delegate.setSSLParameters(p);
+  }
+
+  @Override public void close() throws IOException {
+    delegate.close();
+  }
+
+  @Override public InetAddress getInetAddress() {
+    return delegate.getInetAddress();
+  }
+
+  @Override public InputStream getInputStream() throws IOException {
+    return delegate.getInputStream();
+  }
+
+  @Override public boolean getKeepAlive() throws SocketException {
+    return delegate.getKeepAlive();
+  }
+
+  @Override public InetAddress getLocalAddress() {
+    return delegate.getLocalAddress();
+  }
+
+  @Override public int getLocalPort() {
+    return delegate.getLocalPort();
+  }
+
+  @Override public OutputStream getOutputStream() throws IOException {
+    return delegate.getOutputStream();
+  }
+
+  @Override public int getPort() {
+    return delegate.getPort();
+  }
+
+  @Override public int getSoLinger() throws SocketException {
+    return delegate.getSoLinger();
+  }
+
+  @Override public int getReceiveBufferSize() throws SocketException {
+    return delegate.getReceiveBufferSize();
+  }
+
+  @Override public int getSendBufferSize() throws SocketException {
+    return delegate.getSendBufferSize();
+  }
+
+  @Override public int getSoTimeout() throws SocketException {
+    return delegate.getSoTimeout();
+  }
+
+  @Override public boolean getTcpNoDelay() throws SocketException {
+    return delegate.getTcpNoDelay();
+  }
+
+  @Override public void setKeepAlive(boolean keepAlive) throws SocketException {
+    delegate.setKeepAlive(keepAlive);
+  }
+
+  @Override public void setSendBufferSize(int size) throws SocketException {
+    delegate.setSendBufferSize(size);
+  }
+
+  @Override public void setReceiveBufferSize(int size) throws SocketException {
+    delegate.setReceiveBufferSize(size);
+  }
+
+  @Override public void setSoLinger(boolean on, int timeout) throws SocketException {
+    delegate.setSoLinger(on, timeout);
+  }
+
+  @Override public void setSoTimeout(int timeout) throws SocketException {
+    delegate.setSoTimeout(timeout);
+  }
+
+  @Override public void setTcpNoDelay(boolean on) throws SocketException {
+    delegate.setTcpNoDelay(on);
+  }
+
+  @Override public String toString() {
+    return delegate.toString();
+  }
+
+  @Override public SocketAddress getLocalSocketAddress() {
+    return delegate.getLocalSocketAddress();
+  }
+
+  @Override public SocketAddress getRemoteSocketAddress() {
+    return delegate.getRemoteSocketAddress();
+  }
+
+  @Override public boolean isBound() {
+    return delegate.isBound();
+  }
+
+  @Override public boolean isConnected() {
+    return delegate.isConnected();
+  }
+
+  @Override public boolean isClosed() {
+    return delegate.isClosed();
+  }
+
+  @Override public void bind(SocketAddress localAddr) throws IOException {
+    delegate.bind(localAddr);
+  }
+
+  @Override public void connect(SocketAddress remoteAddr) throws IOException {
+    delegate.connect(remoteAddr);
+  }
+
+  @Override public void connect(SocketAddress remoteAddr, int timeout) throws IOException {
+    delegate.connect(remoteAddr, timeout);
+  }
+
+  @Override public boolean isInputShutdown() {
+    return delegate.isInputShutdown();
+  }
+
+  @Override public boolean isOutputShutdown() {
+    return delegate.isOutputShutdown();
+  }
+
+  @Override public void setReuseAddress(boolean reuse) throws SocketException {
+    delegate.setReuseAddress(reuse);
+  }
+
+  @Override public boolean getReuseAddress() throws SocketException {
+    return delegate.getReuseAddress();
+  }
+
+  @Override public void setOOBInline(boolean oobinline) throws SocketException {
+    delegate.setOOBInline(oobinline);
+  }
+
+  @Override public boolean getOOBInline() throws SocketException {
+    return delegate.getOOBInline();
+  }
+
+  @Override public void setTrafficClass(int value) throws SocketException {
+    delegate.setTrafficClass(value);
+  }
+
+  @Override public int getTrafficClass() throws SocketException {
+    return delegate.getTrafficClass();
+  }
+
+  @Override public void sendUrgentData(int value) throws IOException {
+    delegate.sendUrgentData(value);
+  }
+
+  @Override public SocketChannel getChannel() {
+    return delegate.getChannel();
+  }
+
+  @Override public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
+    delegate.setPerformancePreferences(connectionTime, latency, bandwidth);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocketFactory.java b/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocketFactory.java
new file mode 100644
index 0000000000..a14db22e67
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSSLSocketFactory.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import javax.net.SocketFactory;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * A {@link SSLSocketFactory} that delegates calls. Sockets can be configured after
+ * creation by overriding {@link #configureSocket(javax.net.ssl.SSLSocket)}.
+ */
+public class DelegatingSSLSocketFactory extends SSLSocketFactory {
+
+  private final SSLSocketFactory delegate;
+
+  public DelegatingSSLSocketFactory(SSLSocketFactory delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override
+  public SSLSocket createSocket() throws IOException {
+    SSLSocket sslSocket = (SSLSocket) delegate.createSocket();
+    configureSocket(sslSocket);
+    return sslSocket;
+  }
+
+  @Override
+  public SSLSocket createSocket(String host, int port) throws IOException, UnknownHostException {
+    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port);
+    configureSocket(sslSocket);
+    return sslSocket;
+  }
+
+  @Override
+  public SSLSocket createSocket(String host, int port, InetAddress localAddress, int localPort)
+      throws IOException, UnknownHostException {
+    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port, localAddress, localPort);
+    configureSocket(sslSocket);
+    return sslSocket;
+  }
+
+  @Override
+  public SSLSocket createSocket(InetAddress host, int port) throws IOException {
+    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port);
+    configureSocket(sslSocket);
+    return sslSocket;
+  }
+
+  @Override
+  public SSLSocket createSocket(InetAddress host, int port, InetAddress localAddress, int localPort)
+      throws IOException {
+    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port, localAddress, localPort);
+    configureSocket(sslSocket);
+    return sslSocket;
+  }
+
+  @Override
+  public String[] getDefaultCipherSuites() {
+    return delegate.getDefaultCipherSuites();
+  }
+
+  @Override
+  public String[] getSupportedCipherSuites() {
+    return delegate.getSupportedCipherSuites();
+  }
+
+  @Override
+  public SSLSocket createSocket(Socket socket, String host, int port, boolean autoClose)
+      throws IOException {
+    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(socket, host, port, autoClose);
+    configureSocket(sslSocket);
+    return sslSocket;
+  }
+
+  protected void configureSocket(SSLSocket sslSocket) throws IOException {
+    // No-op by default.
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingServerSocketFactory.java b/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingServerSocketFactory.java
new file mode 100644
index 0000000000..ef24aaaaeb
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingServerSocketFactory.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.ServerSocket;
+import javax.net.ServerSocketFactory;
+
+/**
+ * A {@link ServerSocketFactory} that delegates calls. Sockets can be configured after creation by
+ * overriding {@link #configureServerSocket(java.net.ServerSocket)}.
+ */
+public class DelegatingServerSocketFactory extends ServerSocketFactory {
+
+  private final ServerSocketFactory delegate;
+
+  public DelegatingServerSocketFactory(ServerSocketFactory delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override
+  public ServerSocket createServerSocket() throws IOException {
+    ServerSocket serverSocket = delegate.createServerSocket();
+    configureServerSocket(serverSocket);
+    return serverSocket;
+  }
+
+  @Override
+  public ServerSocket createServerSocket(int port) throws IOException {
+    ServerSocket serverSocket = delegate.createServerSocket(port);
+    configureServerSocket(serverSocket);
+    return serverSocket;
+  }
+
+  @Override
+  public ServerSocket createServerSocket(int port, int backlog) throws IOException {
+    ServerSocket serverSocket = delegate.createServerSocket(port, backlog);
+    configureServerSocket(serverSocket);
+    return serverSocket;
+  }
+
+  @Override
+  public ServerSocket createServerSocket(int port, int backlog, InetAddress ifAddress)
+      throws IOException {
+    ServerSocket serverSocket = delegate.createServerSocket(port, backlog, ifAddress);
+    configureServerSocket(serverSocket);
+    return serverSocket;
+  }
+
+  protected void configureServerSocket(ServerSocket serverSocket) throws IOException {
+    // No-op by default.
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSocketFactory.java b/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSocketFactory.java
new file mode 100644
index 0000000000..e8fdfe80fd
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/DelegatingSocketFactory.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import javax.net.SocketFactory;
+
+/**
+ * A {@link SocketFactory} that delegates calls. Sockets can be configured after creation by
+ * overriding {@link #configureSocket(java.net.Socket)}.
+ */
+public class DelegatingSocketFactory extends SocketFactory {
+
+  private final SocketFactory delegate;
+
+  public DelegatingSocketFactory(SocketFactory delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override
+  public Socket createSocket() throws IOException {
+    Socket socket = delegate.createSocket();
+    configureSocket(socket);
+    return socket;
+  }
+
+  @Override
+  public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
+    Socket socket = delegate.createSocket(host, port);
+    configureSocket(socket);
+    return socket;
+  }
+
+  @Override
+  public Socket createSocket(String host, int port, InetAddress localAddress, int localPort)
+      throws IOException, UnknownHostException {
+    Socket socket = delegate.createSocket(host, port, localAddress, localPort);
+    configureSocket(socket);
+    return socket;
+  }
+
+  @Override
+  public Socket createSocket(InetAddress host, int port) throws IOException {
+    Socket socket = delegate.createSocket(host, port);
+    configureSocket(socket);
+    return socket;
+  }
+
+  @Override
+  public Socket createSocket(InetAddress host, int port, InetAddress localAddress, int localPort)
+      throws IOException {
+    Socket socket = delegate.createSocket(host, port, localAddress, localPort);
+    configureSocket(socket);
+    return socket;
+  }
+
+  protected void configureSocket(Socket socket) throws IOException {
+    // No-op by default.
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
new file mode 100644
index 0000000000..3d7701f298
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
@@ -0,0 +1,181 @@
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.Call.AsyncCall;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.AbstractExecutorService;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class DispatcherTest {
+  RecordingExecutor executor = new RecordingExecutor();
+  RecordingCallback callback = new RecordingCallback();
+  Dispatcher dispatcher = new Dispatcher(executor);
+  OkHttpClient client = new OkHttpClient().setDispatcher(dispatcher);
+
+  @Before public void setUp() throws Exception {
+    dispatcher.setMaxRequests(20);
+    dispatcher.setMaxRequestsPerHost(10);
+  }
+
+  @Test public void maxRequestsZero() throws Exception {
+    try {
+      dispatcher.setMaxRequests(0);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void maxPerHostZero() throws Exception {
+    try {
+      dispatcher.setMaxRequestsPerHost(0);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void enqueuedJobsRunImmediately() throws Exception {
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    executor.assertJobs("http://a/1");
+  }
+
+  @Test public void maxRequestsEnforced() throws Exception {
+    dispatcher.setMaxRequests(3);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/2")).enqueue(callback);
+    executor.assertJobs("http://a/1", "http://a/2", "http://b/1");
+  }
+
+  @Test public void maxPerHostEnforced() throws Exception {
+    dispatcher.setMaxRequestsPerHost(2);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    client.newCall(newRequest("http://a/3")).enqueue(callback);
+    executor.assertJobs("http://a/1", "http://a/2");
+  }
+
+  @Test public void increasingMaxRequestsPromotesJobsImmediately() throws Exception {
+    dispatcher.setMaxRequests(2);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://c/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    client.newCall(newRequest("http://b/2")).enqueue(callback);
+    dispatcher.setMaxRequests(4);
+    executor.assertJobs("http://a/1", "http://b/1", "http://c/1", "http://a/2");
+  }
+
+  @Test public void increasingMaxPerHostPromotesJobsImmediately() throws Exception {
+    dispatcher.setMaxRequestsPerHost(2);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    client.newCall(newRequest("http://a/3")).enqueue(callback);
+    client.newCall(newRequest("http://a/4")).enqueue(callback);
+    client.newCall(newRequest("http://a/5")).enqueue(callback);
+    dispatcher.setMaxRequestsPerHost(4);
+    executor.assertJobs("http://a/1", "http://a/2", "http://a/3", "http://a/4");
+  }
+
+  @Test public void oldJobFinishesNewJobCanRunDifferentHost() throws Exception {
+    dispatcher.setMaxRequests(1);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    executor.finishJob("http://a/1");
+    executor.assertJobs("http://b/1");
+  }
+
+  @Test public void oldJobFinishesNewJobWithSameHostStarts() throws Exception {
+    dispatcher.setMaxRequests(2);
+    dispatcher.setMaxRequestsPerHost(1);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/2")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    executor.finishJob("http://a/1");
+    executor.assertJobs("http://b/1", "http://a/2");
+  }
+
+  @Test public void oldJobFinishesNewJobCantRunDueToHostLimit() throws Exception {
+    dispatcher.setMaxRequestsPerHost(1);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    executor.finishJob("http://b/1");
+    executor.assertJobs("http://a/1");
+  }
+
+  @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
+    dispatcher.setMaxRequests(1);
+    client.newCall(newRequest("http://a/1", "tag1")).enqueue(callback);
+    client.newCall(newRequest("http://a/2")).enqueue(callback);
+    dispatcher.cancel("tag1");
+    executor.assertJobs("http://a/1");
+    executor.finishJob("http://a/1");
+    executor.assertJobs("http://a/2");
+  }
+
+  class RecordingExecutor extends AbstractExecutorService {
+    private List<AsyncCall> calls = new ArrayList<>();
+
+    @Override public void execute(Runnable command) {
+      calls.add((AsyncCall) command);
+    }
+
+    public void assertJobs(String... expectedUrls) {
+      List<String> actualUrls = new ArrayList<>();
+      for (AsyncCall call : calls) {
+        actualUrls.add(call.request().urlString());
+      }
+      assertEquals(Arrays.asList(expectedUrls), actualUrls);
+    }
+
+    public void finishJob(String url) {
+      for (Iterator<AsyncCall> i = calls.iterator(); i.hasNext(); ) {
+        AsyncCall call = i.next();
+        if (call.request().urlString().equals(url)) {
+          i.remove();
+          dispatcher.finished(call);
+          return;
+        }
+      }
+      throw new AssertionError("No such job: " + url);
+    }
+
+    @Override public void shutdown() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public List<Runnable> shutdownNow() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean isShutdown() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean isTerminated() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean awaitTermination(long timeout, TimeUnit unit)
+        throws InterruptedException {
+      throw new UnsupportedOperationException();
+    }
+  }
+
+  private Request newRequest(String url) {
+    return new Request.Builder().url(url).build();
+  }
+
+  private Request newRequest(String url, String tag) {
+    return new Request.Builder().url(url).tag(tag).build();
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/FallbackTestClientSocketFactory.java b/okhttp-tests/src/test/java/com/squareup/okhttp/FallbackTestClientSocketFactory.java
new file mode 100644
index 0000000000..5f9e623c1c
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/FallbackTestClientSocketFactory.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2014 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.util.ArrayList;
+import java.util.List;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * An SSLSocketFactory that delegates calls. Sockets created by the delegate are wrapped with ones
+ * that will not accept the {@link #TLS_FALLBACK_SCSV} cipher, thus bypassing server-side fallback
+ * checks on platforms that support it. Unfortunately this wrapping will disable any
+ * reflection-based calls to SSLSocket from Platform.
+ */
+public class FallbackTestClientSocketFactory extends DelegatingSSLSocketFactory {
+  /**
+   * The cipher suite used during TLS connection fallback to indicate a fallback.
+   * See https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
+   */
+  public static final String TLS_FALLBACK_SCSV = "TLS_FALLBACK_SCSV";
+
+  public FallbackTestClientSocketFactory(SSLSocketFactory delegate) {
+    super(delegate);
+  }
+
+  @Override public SSLSocket createSocket(Socket s, String host, int port, boolean autoClose)
+      throws IOException {
+    SSLSocket socket = super.createSocket(s, host, port, autoClose);
+    return new TlsFallbackScsvDisabledSSLSocket(socket);
+  }
+
+  @Override public SSLSocket createSocket() throws IOException {
+    SSLSocket socket = super.createSocket();
+    return new TlsFallbackScsvDisabledSSLSocket(socket);
+  }
+
+  @Override public SSLSocket createSocket(String host,int port) throws IOException {
+    SSLSocket socket = super.createSocket(host, port);
+    return new TlsFallbackScsvDisabledSSLSocket(socket);
+  }
+
+  @Override public SSLSocket createSocket(String host,int port, InetAddress localHost,
+      int localPort) throws IOException {
+    SSLSocket socket = super.createSocket(host, port, localHost, localPort);
+    return new TlsFallbackScsvDisabledSSLSocket(socket);
+  }
+
+  @Override public SSLSocket createSocket(InetAddress host,int port) throws IOException {
+    SSLSocket socket = super.createSocket(host, port);
+    return new TlsFallbackScsvDisabledSSLSocket(socket);
+  }
+
+  @Override public SSLSocket createSocket(InetAddress address,int port,
+      InetAddress localAddress, int localPort) throws IOException {
+    SSLSocket socket = super.createSocket(address, port, localAddress, localPort);
+    return new TlsFallbackScsvDisabledSSLSocket(socket);
+  }
+
+  private static class TlsFallbackScsvDisabledSSLSocket extends DelegatingSSLSocket {
+
+    public TlsFallbackScsvDisabledSSLSocket(SSLSocket socket) {
+      super(socket);
+    }
+
+    @Override public void setEnabledCipherSuites(String[] suites) {
+      List<String> enabledCipherSuites = new ArrayList<String>(suites.length);
+      for (String suite : suites) {
+        if (!suite.equals(TLS_FALLBACK_SCSV)) {
+          enabledCipherSuites.add(suite);
+        }
+      }
+      delegate.setEnabledCipherSuites(
+          enabledCipherSuites.toArray(new String[enabledCipherSuites.size()]));
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java
new file mode 100644
index 0000000000..a9533bf783
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import okio.Buffer;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public final class FormEncodingBuilderTest {
+  @Test public void urlEncoding() throws Exception {
+    RequestBody formEncoding = new FormEncodingBuilder()
+        .add("a&b", "c=d")
+        .add("space, the", "final frontier")
+        .build();
+
+    assertEquals("application/x-www-form-urlencoded", formEncoding.contentType().toString());
+
+    String expected = "a%26b=c%3Dd&space%2C+the=final+frontier";
+    assertEquals(expected.length(), formEncoding.contentLength());
+
+    Buffer out = new Buffer();
+    formEncoding.writeTo(out);
+    assertEquals(expected, out.readUtf8());
+  }
+
+  @Test public void encodedPair() throws Exception {
+    RequestBody formEncoding = new FormEncodingBuilder()
+        .add("sim", "ple")
+        .build();
+
+    String expected = "sim=ple";
+    assertEquals(expected.length(), formEncoding.contentLength());
+
+    Buffer buffer = new Buffer();
+    formEncoding.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void encodeMultiplePairs() throws Exception {
+    RequestBody formEncoding = new FormEncodingBuilder()
+        .add("sim", "ple")
+        .add("hey", "there")
+        .add("help", "me")
+        .build();
+
+    String expected = "sim=ple&hey=there&help=me";
+    assertEquals(expected.length(), formEncoding.contentLength());
+
+    Buffer buffer = new Buffer();
+    formEncoding.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java
new file mode 100644
index 0000000000..46778d3a84
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/InterceptorTest.java
@@ -0,0 +1,424 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.IOException;
+import java.net.URL;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Locale;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ForwardingSink;
+import okio.ForwardingSource;
+import okio.GzipSink;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.fail;
+
+public final class InterceptorTest {
+  @Rule public MockWebServerRule server = new MockWebServerRule();
+
+  private OkHttpClient client = new OkHttpClient();
+  private RecordingCallback callback = new RecordingCallback();
+
+  @Test public void applicationInterceptorsCanShortCircuitResponses() throws Exception {
+    server.get().shutdown(); // Accept no connections.
+
+    Request request = new Request.Builder()
+        .url("https://localhost:1/")
+        .build();
+
+    final Response interceptorResponse = new Response.Builder()
+        .request(request)
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Intercepted!")
+        .body(ResponseBody.create(MediaType.parse("text/plain; charset=utf-8"), "abc"))
+        .build();
+
+    client.interceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return interceptorResponse;
+      }
+    });
+
+    Response response = client.newCall(request).execute();
+    assertSame(interceptorResponse, response);
+  }
+
+  @Test public void networkInterceptorsCannotShortCircuitResponses() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(500));
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return new Response.Builder()
+            .request(chain.request())
+            .protocol(Protocol.HTTP_1_1)
+            .code(200)
+            .message("Intercepted!")
+            .body(ResponseBody.create(MediaType.parse("text/plain; charset=utf-8"), "abc"))
+            .build();
+      }
+    };
+    client.networkInterceptors().add(interceptor);
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("network interceptor " + interceptor + " must call proceed() exactly once",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorsCannotCallProceedMultipleTimes() throws Exception {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        chain.proceed(chain.request());
+        return chain.proceed(chain.request());
+      }
+    };
+    client.networkInterceptors().add(interceptor);
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("network interceptor " + interceptor + " must call proceed() exactly once",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorsCannotChangeServerAddress() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(500));
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Address address = chain.connection().getRoute().getAddress();
+        String sameHost = address.getUriHost();
+        int differentPort = address.getUriPort() + 1;
+        return chain.proceed(chain.request().newBuilder()
+            .url(new URL("http://" + sameHost + ":" + differentPort + "/"))
+            .build());
+      }
+    };
+    client.networkInterceptors().add(interceptor);
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("network interceptor " + interceptor + " must retain the same host and port",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorsHaveConnectionAccess() throws Exception {
+    server.enqueue(new MockResponse());
+
+    client.networkInterceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Connection connection = chain.connection();
+        assertNotNull(connection);
+        return chain.proceed(chain.request());
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request).execute();
+  }
+
+  @Test public void networkInterceptorsObserveNetworkHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("abcabcabc"))
+        .addHeader("Content-Encoding: gzip"));
+
+    client.networkInterceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        // The network request has everything: User-Agent, Host, Accept-Encoding.
+        Request networkRequest = chain.request();
+        assertNotNull(networkRequest.header("User-Agent"));
+        assertEquals(server.get().getHostName() + ":" + server.get().getPort(),
+            networkRequest.header("Host"));
+        assertNotNull(networkRequest.header("Accept-Encoding"));
+
+        // The network response also has everything, including the raw gzipped content.
+        Response networkResponse = chain.proceed(networkRequest);
+        assertEquals("gzip", networkResponse.header("Content-Encoding"));
+        return networkResponse;
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    // No extra headers in the application's request.
+    assertNull(request.header("User-Agent"));
+    assertNull(request.header("Host"));
+    assertNull(request.header("Accept-Encoding"));
+
+    // No extra headers in the application's response.
+    Response response = client.newCall(request).execute();
+    assertNull(request.header("Content-Encoding"));
+    assertEquals("abcabcabc", response.body().string());
+  }
+
+  @Test public void applicationInterceptorsRewriteRequestToServer() throws Exception {
+    rewriteRequestToServer(client.interceptors());
+  }
+
+  @Test public void networkInterceptorsRewriteRequestToServer() throws Exception {
+    rewriteRequestToServer(client.networkInterceptors());
+  }
+
+  private void rewriteRequestToServer(List<Interceptor> interceptors) throws Exception {
+    server.enqueue(new MockResponse());
+
+    interceptors.add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Request originalRequest = chain.request();
+        return chain.proceed(originalRequest.newBuilder()
+            .method("POST", uppercase(originalRequest.body()))
+            .addHeader("OkHttp-Intercepted", "yep")
+            .build());
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .addHeader("Original-Header", "foo")
+        .method("PUT", RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    client.newCall(request).execute();
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("ABC", recordedRequest.getUtf8Body());
+    assertEquals("foo", recordedRequest.getHeader("Original-Header"));
+    assertEquals("yep", recordedRequest.getHeader("OkHttp-Intercepted"));
+    assertEquals("POST", recordedRequest.getMethod());
+  }
+
+  @Test public void applicationInterceptorsRewriteResponseFromServer() throws Exception {
+    rewriteResponseFromServer(client.interceptors());
+  }
+
+  @Test public void networkInterceptorsRewriteResponseFromServer() throws Exception {
+    rewriteResponseFromServer(client.networkInterceptors());
+  }
+
+  private void rewriteResponseFromServer(List<Interceptor> interceptors) throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Original-Header: foo")
+        .setBody("abc"));
+
+    interceptors.add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Response originalResponse = chain.proceed(chain.request());
+        return originalResponse.newBuilder()
+            .body(uppercase(originalResponse.body()))
+            .addHeader("OkHttp-Intercepted", "yep")
+            .build();
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    assertEquals("ABC", response.body().string());
+    assertEquals("yep", response.header("OkHttp-Intercepted"));
+    assertEquals("foo", response.header("Original-Header"));
+  }
+
+  @Test public void multipleApplicationInterceptors() throws Exception {
+    multipleInterceptors(client.interceptors());
+  }
+
+  @Test public void multipleNetworkInterceptors() throws Exception {
+    multipleInterceptors(client.networkInterceptors());
+  }
+
+  private void multipleInterceptors(List<Interceptor> interceptors) throws Exception {
+    server.enqueue(new MockResponse());
+
+    interceptors.add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Request originalRequest = chain.request();
+        Response originalResponse = chain.proceed(originalRequest.newBuilder()
+            .addHeader("Request-Interceptor", "Android") // 1. Added first.
+            .build());
+        return originalResponse.newBuilder()
+            .addHeader("Response-Interceptor", "Donut") // 4. Added last.
+            .build();
+      }
+    });
+    interceptors.add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Request originalRequest = chain.request();
+        Response originalResponse = chain.proceed(originalRequest.newBuilder()
+            .addHeader("Request-Interceptor", "Bob") // 2. Added second.
+            .build());
+        return originalResponse.newBuilder()
+            .addHeader("Response-Interceptor", "Cupcake") // 3. Added third.
+            .build();
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    assertEquals(Arrays.asList("Cupcake", "Donut"),
+        response.headers("Response-Interceptor"));
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(Arrays.asList("Android", "Bob"),
+        recordedRequest.getHeaders("Request-Interceptor"));
+  }
+
+  @Test public void asyncApplicationInterceptors() throws Exception {
+    asyncInterceptors(client.interceptors());
+  }
+
+  @Test public void asyncNetworkInterceptors() throws Exception {
+    asyncInterceptors(client.networkInterceptors());
+  }
+
+  private void asyncInterceptors(List<Interceptor> interceptors) throws Exception {
+    server.enqueue(new MockResponse());
+
+    interceptors.add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Response originalResponse = chain.proceed(chain.request());
+        return originalResponse.newBuilder()
+            .addHeader("OkHttp-Intercepted", "yep")
+            .build();
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.newCall(request).enqueue(callback);
+
+    callback.await(request.url())
+        .assertCode(200)
+        .assertHeader("OkHttp-Intercepted", "yep");
+  }
+
+  @Test public void applicationInterceptorsCanMakeMultipleRequestsToServer() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    client.interceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        chain.proceed(chain.request());
+        return chain.proceed(chain.request());
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    assertEquals(response.body().string(), "b");
+  }
+
+  private RequestBody uppercase(final RequestBody original) {
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return original.contentType();
+      }
+
+      @Override public long contentLength() throws IOException {
+        return original.contentLength();
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        Sink uppercase = uppercase(sink);
+        BufferedSink bufferedSink = Okio.buffer(uppercase);
+        original.writeTo(bufferedSink);
+        bufferedSink.emit();
+      }
+    };
+  }
+
+  private Sink uppercase(final BufferedSink original) {
+    return new ForwardingSink(original) {
+      @Override public void write(Buffer source, long byteCount) throws IOException {
+        original.writeUtf8(source.readUtf8(byteCount).toUpperCase(Locale.US));
+      }
+    };
+  }
+
+  static ResponseBody uppercase(ResponseBody original) {
+    return ResponseBody.create(original.contentType(), original.contentLength(),
+        Okio.buffer(uppercase(original.source())));
+  }
+
+  private static Source uppercase(final Source original) {
+    return new ForwardingSource(original) {
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        Buffer mixedCase = new Buffer();
+        long count = original.read(mixedCase, byteCount);
+        sink.writeUtf8(mixedCase.readUtf8().toUpperCase(Locale.US));
+        return count;
+      }
+    };
+  }
+
+  private Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/MediaTypeTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
similarity index 87%
rename from okhttp/src/test/java/com/squareup/okhttp/MediaTypeTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
index acbfdd5c16..25805957a5 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/MediaTypeTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
@@ -54,6 +54,13 @@
     assertMediaType("text/plain; a=1; a=2; b=3");
     assertMediaType("text/plain; charset=utf-16");
     assertMediaType("text/plain; \t \n \r a=b");
+    assertMediaType("text/plain;");
+    assertMediaType("text/plain; ");
+    assertMediaType("text/plain; a=1;");
+    assertMediaType("text/plain; a=1; ");
+    assertMediaType("text/plain; a=1;; b=2");
+    assertMediaType("text/plain;;");
+    assertMediaType("text/plain; ;");
   }
 
   @Test public void testInvalidParse() throws Exception {
@@ -64,14 +71,10 @@
     assertInvalid("text/");
     assertInvalid("te<t/plain");
     assertInvalid("text/pl@in");
-    assertInvalid("text/plain;");
-    assertInvalid("text/plain; ");
     assertInvalid("text/plain; a");
     assertInvalid("text/plain; a=");
     assertInvalid("text/plain; a=@");
     assertInvalid("text/plain; a=\"@");
-    assertInvalid("text/plain; a=1;");
-    assertInvalid("text/plain; a=1; ");
     assertInvalid("text/plain; a=1; b");
     assertInvalid("text/plain; a=1; b=");
     assertInvalid("text/plain; a=\u2025");
@@ -104,6 +107,11 @@
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
+  @Test public void testDuplicatedCharsets() {
+    MediaType mediaType = MediaType.parse("text/plain; charset=utf-8; charset=UTF-8");
+    assertEquals("UTF-8", mediaType.charset().name());
+  }
+
   @Test public void testMultipleCharsets() {
     try {
       MediaType.parse("text/plain; charset=utf-8; charset=utf-16");
@@ -140,6 +148,14 @@
     assertEquals("ISO-8859-1", charset.charset(Charset.forName("US-ASCII")).name());
   }
 
+  @Test public void testParseDanglingSemicolon() throws Exception {
+    MediaType mediaType = MediaType.parse("text/plain;");
+    assertEquals("text", mediaType.type());
+    assertEquals("plain", mediaType.subtype());
+    assertEquals(null, mediaType.charset());
+    assertEquals("text/plain;", mediaType.toString());
+  }
+
   private void assertMediaType(String string) {
     MediaType mediaType = MediaType.parse(string);
     assertEquals(string, mediaType.toString());
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java
new file mode 100644
index 0000000000..0e12470afb
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java
@@ -0,0 +1,241 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSink;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.Util.UTF_8;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class MultipartBuilderTest {
+  @Test(expected = IllegalStateException.class)
+  public void onePartRequired() throws Exception {
+    new MultipartBuilder().build();
+  }
+
+  @Test public void singlePart() throws Exception {
+    String expected = ""
+        + "--123\r\n"
+        + "Content-Length: 13\r\n"
+        + "\r\n"
+        + "Hello, World!\r\n"
+        + "--123--\r\n";
+
+    RequestBody requestBody = new MultipartBuilder("123")
+        .addPart(RequestBody.create(null, "Hello, World!"))
+        .build();
+
+    assertEquals("multipart/mixed; boundary=123", requestBody.contentType().toString());
+
+    Buffer buffer = new Buffer();
+    requestBody.writeTo(buffer);
+    assertEquals(-1L, requestBody.contentLength());
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void threeParts() throws Exception {
+    String expected = ""
+        + "--123\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Quick\r\n"
+        + "--123\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Brown\r\n"
+        + "--123\r\n"
+        + "Content-Length: 3\r\n"
+        + "\r\n"
+        + "Fox\r\n"
+        + "--123--\r\n";
+
+    RequestBody requestBody = new MultipartBuilder("123")
+        .addPart(RequestBody.create(null, "Quick"))
+        .addPart(RequestBody.create(null, "Brown"))
+        .addPart(RequestBody.create(null, "Fox"))
+        .build();
+
+    assertEquals("multipart/mixed; boundary=123", requestBody.contentType().toString());
+
+    Buffer buffer = new Buffer();
+    requestBody.writeTo(buffer);
+    assertEquals(-1L, requestBody.contentLength());
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void fieldAndTwoFiles() throws Exception {
+    String expected = ""
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"submit-name\"\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Larry\r\n"
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"files\"\r\n"
+        + "Content-Type: multipart/mixed; boundary=BbC04y\r\n"
+        + "\r\n"
+        + "--BbC04y\r\n"
+        + "Content-Disposition: file; filename=\"file1.txt\"\r\n"
+        + "Content-Type: text/plain; charset=utf-8\r\n"
+        + "Content-Length: 29\r\n"
+        + "\r\n"
+        + "... contents of file1.txt ...\r\n"
+        + "--BbC04y\r\n"
+        + "Content-Disposition: file; filename=\"file2.gif\"\r\n"
+        + "Content-Transfer-Encoding: binary\r\n"
+        + "Content-Type: image/gif\r\n"
+        + "Content-Length: 29\r\n"
+        + "\r\n"
+        + "... contents of file2.gif ...\r\n"
+        + "--BbC04y--\r\n"
+        + "\r\n"
+        + "--AaB03x--\r\n";
+
+    RequestBody requestBody = new MultipartBuilder("AaB03x")
+        .type(MultipartBuilder.FORM)
+        .addFormDataPart("submit-name", "Larry")
+        .addFormDataPart("files", null,
+            new MultipartBuilder("BbC04y")
+                .addPart(
+                    Headers.of("Content-Disposition", "file; filename=\"file1.txt\""),
+                    RequestBody.create(
+                        MediaType.parse("text/plain"), "... contents of file1.txt ..."))
+                .addPart(
+                    Headers.of(
+                        "Content-Disposition", "file; filename=\"file2.gif\"",
+                        "Content-Transfer-Encoding", "binary"),
+                    RequestBody.create(
+                        MediaType.parse("image/gif"),
+                        "... contents of file2.gif ...".getBytes(UTF_8)))
+                .build())
+        .build();
+
+    assertEquals("multipart/form-data; boundary=AaB03x", requestBody.contentType().toString());
+
+    Buffer buffer = new Buffer();
+    requestBody.writeTo(buffer);
+    assertEquals(-1L, requestBody.contentLength());
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void stringEscapingIsWeird() throws Exception {
+    String expected = ""
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"field with spaces\"; filename=\"filename with spaces.txt\"\r\n"
+        + "Content-Type: text/plain; charset=utf-8\r\n"
+        + "Content-Length: 4\r\n"
+        + "\r\n"
+        + "okay\r\n"
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"field with %22\"\r\n"
+        + "Content-Length: 1\r\n"
+        + "\r\n"
+        + "\"\r\n"
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"field with %22\"\r\n"
+        + "Content-Length: 3\r\n"
+        + "\r\n"
+        + "%22\r\n"
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"field with \u0391\"\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Alpha\r\n"
+        + "--AaB03x--\r\n";
+
+    RequestBody requestBody = new MultipartBuilder("AaB03x")
+        .type(MultipartBuilder.FORM)
+        .addFormDataPart("field with spaces", "filename with spaces.txt",
+            RequestBody.create(MediaType.parse("text/plain; charset=utf-8"), "okay"))
+        .addFormDataPart("field with \"", "\"")
+        .addFormDataPart("field with %22", "%22")
+        .addFormDataPart("field with \u0391", "Alpha")
+        .build();
+
+    Buffer buffer = new Buffer();
+    requestBody.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void streamingPartHasNoLength() throws Exception {
+    class StreamingBody extends RequestBody {
+      private final String body;
+
+      StreamingBody(String body) {
+        this.body = body;
+      }
+
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8(body);
+      }
+    }
+
+    String expected = ""
+        + "--123\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Quick\r\n"
+        + "--123\r\n"
+        + "\r\n"
+        + "Brown\r\n"
+        + "--123\r\n"
+        + "Content-Length: 3\r\n"
+        + "\r\n"
+        + "Fox\r\n"
+        + "--123--\r\n";
+
+    RequestBody requestBody = new MultipartBuilder("123")
+        .addPart(RequestBody.create(null, "Quick"))
+        .addPart(new StreamingBody("Brown"))
+        .addPart(RequestBody.create(null, "Fox"))
+        .build();
+
+    assertEquals("multipart/mixed; boundary=123", requestBody.contentType().toString());
+
+    Buffer buffer = new Buffer();
+    requestBody.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+    assertEquals(-1, requestBody.contentLength());
+  }
+
+  @Test public void contentTypeHeaderIsForbidden() throws Exception {
+    try {
+      new MultipartBuilder().addPart(
+          Headers.of("Content-Type", "text/plain"),
+          RequestBody.create(null, "Hello, World!"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void contentLengthHeaderIsForbidden() throws Exception {
+    try {
+      new MultipartBuilder().addPart(
+          Headers.of("Content-Length", "13"),
+          RequestBody.create(null, "Hello, World!"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
new file mode 100644
index 0000000000..0bb8d1a80d
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.RecordingAuthenticator;
+import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
+import com.squareup.okhttp.internal.http.RecordingProxySelector;
+import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
+import java.io.IOException;
+import java.net.Authenticator;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.CookieHandler;
+import java.net.CookieManager;
+import java.net.ProxySelector;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.net.URLConnection;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import javax.net.SocketFactory;
+import org.junit.After;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class OkHttpClientTest {
+  private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
+  private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
+  private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();
+  private static final Authenticator DEFAULT_AUTHENTICATOR = null; // No Authenticator.getDefault().
+
+  @After public void tearDown() throws Exception {
+    ProxySelector.setDefault(DEFAULT_PROXY_SELECTOR);
+    CookieManager.setDefault(DEFAULT_COOKIE_HANDLER);
+    ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
+    Authenticator.setDefault(DEFAULT_AUTHENTICATOR);
+  }
+
+  /** Confirm that {@code copyWithDefaults} gets expected constant values. */
+  @Test public void copyWithDefaultsWhenDefaultIsAConstant() throws Exception {
+    OkHttpClient client = new OkHttpClient().copyWithDefaults();
+    assertNull(client.internalCache());
+    assertEquals(0, client.getConnectTimeout());
+    assertEquals(0, client.getReadTimeout());
+    assertEquals(0, client.getWriteTimeout());
+    assertTrue(client.getFollowSslRedirects());
+    assertNull(client.getProxy());
+    assertEquals(Arrays.asList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1),
+        client.getProtocols());
+  }
+
+  /**
+   * Confirm that {@code copyWithDefaults} gets some default implementations
+   * from the core library.
+   */
+  @Test public void copyWithDefaultsWhenDefaultIsGlobal() throws Exception {
+    ProxySelector proxySelector = new RecordingProxySelector();
+    CookieManager cookieManager = new CookieManager();
+    Authenticator authenticator = new RecordingAuthenticator();
+    SocketFactory socketFactory = SocketFactory.getDefault(); // Global isn't configurable.
+    OkHostnameVerifier hostnameVerifier = OkHostnameVerifier.INSTANCE; // Global isn't configurable.
+    CertificatePinner certificatePinner = CertificatePinner.DEFAULT; // Global isn't configurable.
+
+    CookieManager.setDefault(cookieManager);
+    ProxySelector.setDefault(proxySelector);
+    Authenticator.setDefault(authenticator);
+
+    OkHttpClient client = new OkHttpClient().copyWithDefaults();
+
+    assertSame(proxySelector, client.getProxySelector());
+    assertSame(cookieManager, client.getCookieHandler());
+    assertSame(AuthenticatorAdapter.INSTANCE, client.getAuthenticator());
+    assertSame(socketFactory, client.getSocketFactory());
+    assertSame(hostnameVerifier, client.getHostnameVerifier());
+    assertSame(certificatePinner, client.getCertificatePinner());
+  }
+
+  /** There is no default cache. */
+  @Test public void copyWithDefaultsCacheIsNull() throws Exception {
+    OkHttpClient client = new OkHttpClient().copyWithDefaults();
+    assertNull(client.getCache());
+  }
+
+  @Test public void copyWithDefaultsDoesNotHonorGlobalResponseCache() {
+    ResponseCache.setDefault(new ResponseCache() {
+      @Override public CacheResponse get(URI uri, String requestMethod,
+          Map<String, List<String>> requestHeaders) throws IOException {
+        throw new AssertionError();
+      }
+
+      @Override public CacheRequest put(URI uri, URLConnection connection) {
+        throw new AssertionError();
+      }
+    });
+
+    OkHttpClient client = new OkHttpClient().copyWithDefaults();
+    assertNull(client.internalCache());
+  }
+
+  /**
+   * When copying the client, stateful things like the connection pool are
+   * shared across all clients.
+   */
+  @Test public void cloneSharesStatefulInstances() throws Exception {
+    OkHttpClient client = new OkHttpClient();
+
+    // Values should be non-null.
+    OkHttpClient a = client.clone().copyWithDefaults();
+    assertNotNull(a.routeDatabase());
+    assertNotNull(a.getDispatcher());
+    assertNotNull(a.getConnectionPool());
+    assertNotNull(a.getSslSocketFactory());
+
+    // Multiple clients share the instances.
+    OkHttpClient b = client.clone().copyWithDefaults();
+    assertSame(a.routeDatabase(), b.routeDatabase());
+    assertSame(a.getDispatcher(), b.getDispatcher());
+    assertSame(a.getConnectionPool(), b.getConnectionPool());
+    assertSame(a.getSslSocketFactory(), b.getSslSocketFactory());
+  }
+
+  /** We don't want to run user code inside of HttpEngine, etc. */
+  @Test public void copyWithDefaultsDoesNotReturnSubclass() throws Exception {
+    OkHttpClient subclass = new OkHttpClient() {};
+    OkHttpClient copy = subclass.copyWithDefaults();
+    assertEquals(OkHttpClient.class, copy.getClass());
+  }
+
+  @Test public void cloneReturnsSubclass() throws Exception {
+    OkHttpClient subclass = new OkHttpClient() {};
+    OkHttpClient clone = subclass.clone();
+    assertEquals(subclass.getClass(), clone.getClass());
+  }
+
+  /** Exercise a synchronous mocking case. */
+  @Test public void mock() throws Exception {
+    final Request request = new Request.Builder()
+        .url("http://example.com/")
+        .build();
+    final Response response = new Response.Builder()
+        .protocol(Protocol.HTTP_1_1)
+        .request(request)
+        .code(200)
+        .message("Alright")
+        .build();
+
+    OkHttpClient mockClient = new OkHttpClient() {
+      @Override public Call newCall(Request request) {
+        return new Call(this, request) {
+          @Override public Response execute() throws IOException {
+            return response;
+          }
+          @Override public void enqueue(Callback responseCallback) {
+          }
+          @Override public void cancel() {
+          }
+        };
+      }
+    };
+
+    Response actualResponse = mockClient.newCall(request).execute();
+    assertSame(response, actualResponse);
+  }
+
+  @Test public void setProtocolsRejectsHttp10() throws Exception {
+    OkHttpClient client = new OkHttpClient();
+    try {
+      client.setProtocols(Arrays.asList(Protocol.HTTP_1_0, Protocol.HTTP_1_1));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
new file mode 100644
index 0000000000..fdb1404df6
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.ws.WebSocket;
+import java.io.IOException;
+import java.net.URL;
+import java.util.Arrays;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * A received response or failure recorded by the response recorder.
+ */
+public final class RecordedResponse {
+  public final Request request;
+  public final Response response;
+  public final WebSocket webSocket;
+  public final String body;
+  public final IOException failure;
+
+  public RecordedResponse(Request request, Response response, WebSocket webSocket, String body,
+      IOException failure) {
+    this.request = request;
+    this.response = response;
+    this.webSocket = webSocket;
+    this.body = body;
+    this.failure = failure;
+  }
+
+  public RecordedResponse assertRequestUrl(URL url) {
+    assertEquals(url, request.url());
+    return this;
+  }
+
+  public RecordedResponse assertRequestMethod(String method) {
+    assertEquals(method, request.method());
+    return this;
+  }
+
+  public RecordedResponse assertRequestHeader(String name, String... values) {
+    assertEquals(Arrays.asList(values), request.headers(name));
+    return this;
+  }
+
+  public RecordedResponse assertCode(int expectedCode) {
+    assertEquals(expectedCode, response.code());
+    return this;
+  }
+
+  public RecordedResponse assertSuccessful() {
+    assertTrue(response.isSuccessful());
+    return this;
+  }
+
+  public RecordedResponse assertNotSuccessful() {
+    assertFalse(response.isSuccessful());
+    return this;
+  }
+
+  public RecordedResponse assertHeader(String name, String... values) {
+    assertEquals(Arrays.asList(values), response.headers(name));
+    return this;
+  }
+
+  public RecordedResponse assertBody(String expectedBody) {
+    assertEquals(expectedBody, body);
+    return this;
+  }
+
+  public RecordedResponse assertHandshake() {
+    Handshake handshake = response.handshake();
+    assertNotNull(handshake.cipherSuite());
+    assertNotNull(handshake.peerPrincipal());
+    assertEquals(1, handshake.peerCertificates().size());
+    assertNull(handshake.localPrincipal());
+    assertEquals(0, handshake.localCertificates().size());
+    return this;
+  }
+
+  /**
+   * Asserts that the current response was redirected and returns the prior
+   * response.
+   */
+  public RecordedResponse priorResponse() {
+    Response priorResponse = response.priorResponse();
+    assertNotNull(priorResponse);
+    assertNull(priorResponse.body());
+    return new RecordedResponse(priorResponse.request(), priorResponse, null, null, null);
+  }
+
+  /**
+   * Asserts that the current response used the network and returns the network
+   * response.
+   */
+  public RecordedResponse networkResponse() {
+    Response networkResponse = response.networkResponse();
+    assertNotNull(networkResponse);
+    assertNull(networkResponse.body());
+    return new RecordedResponse(networkResponse.request(), networkResponse, null, null, null);
+  }
+
+  /** Asserts that the current response didn't use the network. */
+  public RecordedResponse assertNoNetworkResponse() {
+    assertNull(response.networkResponse());
+    return this;
+  }
+
+  /** Asserts that the current response didn't use the cache. */
+  public RecordedResponse assertNoCacheResponse() {
+    assertNull(response.cacheResponse());
+    return this;
+  }
+
+  /**
+   * Asserts that the current response used the cache and returns the cache
+   * response.
+   */
+  public RecordedResponse cacheResponse() {
+    Response cacheResponse = response.cacheResponse();
+    assertNotNull(cacheResponse);
+    assertNull(cacheResponse.body());
+    return new RecordedResponse(cacheResponse.request(), cacheResponse, null, null, null);
+  }
+
+  public void assertFailure(String... messages) {
+    assertNotNull(failure);
+    assertTrue(failure.getMessage(), Arrays.asList(messages).contains(failure.getMessage()));
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java
similarity index 60%
rename from okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java
index ee0db124a9..73e38f0e95 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java
@@ -16,26 +16,32 @@
 package com.squareup.okhttp;
 
 import java.io.IOException;
+import java.net.URL;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import okio.Buffer;
 
 /**
  * Records received HTTP responses so they can be later retrieved by tests.
  */
-public class RecordingReceiver implements Response.Receiver {
+public class RecordingCallback implements Callback {
   public static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10);
 
-  private final List<RecordedResponse> responses = new ArrayList<RecordedResponse>();
+  private final List<RecordedResponse> responses = new ArrayList<>();
 
-  @Override public synchronized void onFailure(Failure failure) {
-    responses.add(new RecordedResponse(failure.request(), null, null, failure));
+  @Override public synchronized void onFailure(Request request, IOException e) {
+    responses.add(new RecordedResponse(request, null, null, null, e));
     notifyAll();
   }
 
   @Override public synchronized void onResponse(Response response) throws IOException {
-    responses.add(new RecordedResponse(
-        response.request(), response, response.body().string(), null));
+    Buffer buffer = new Buffer();
+    ResponseBody body = response.body();
+    body.source().readAll(buffer);
+
+    responses.add(new RecordedResponse(response.request(), response, null, buffer.readUtf8(), null));
     notifyAll();
   }
 
@@ -43,11 +49,13 @@
    * Returns the recorded response triggered by {@code request}. Throws if the
    * response isn't enqueued before the timeout.
    */
-  public synchronized RecordedResponse await(Request request) throws Exception {
+  public synchronized RecordedResponse await(URL url) throws Exception {
     long timeoutMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime()) + TIMEOUT_MILLIS;
     while (true) {
-      for (RecordedResponse recordedResponse : responses) {
-        if (recordedResponse.request == request) {
+      for (Iterator<RecordedResponse> i = responses.iterator(); i.hasNext(); ) {
+        RecordedResponse recordedResponse = i.next();
+        if (recordedResponse.request.url().equals(url)) {
+          i.remove();
           return recordedResponse;
         }
       }
@@ -57,6 +65,14 @@ public synchronized RecordedResponse await(Request request) throws Exception {
       wait(timeoutMillis - nowMillis);
     }
 
-    throw new AssertionError("Timed out waiting for response to " + request);
+    throw new AssertionError("Timed out waiting for response to " + url);
+  }
+
+  public synchronized void assertNoResponse(URL url) throws Exception {
+    for (RecordedResponse recordedResponse : responses) {
+      if (recordedResponse.request.url().equals(url)) {
+        throw new AssertionError("Expected no response for " + url);
+      }
+    }
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
new file mode 100644
index 0000000000..8a74d1b6e8
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.net.URI;
+import java.net.URL;
+import java.util.Arrays;
+import java.util.Collections;
+import okio.Buffer;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+public final class RequestTest {
+  @Test public void string() throws Exception {
+    MediaType contentType = MediaType.parse("text/plain; charset=utf-8");
+    RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
+    assertEquals(contentType, body.contentType());
+    assertEquals(3, body.contentLength());
+    assertEquals("616263", bodyToHex(body));
+    assertEquals("Retransmit body", "616263", bodyToHex(body));
+  }
+
+  @Test public void stringWithDefaultCharsetAdded() throws Exception {
+    MediaType contentType = MediaType.parse("text/plain");
+    RequestBody body = RequestBody.create(contentType, "\u0800");
+    assertEquals(MediaType.parse("text/plain; charset=utf-8"), body.contentType());
+    assertEquals(3, body.contentLength());
+    assertEquals("e0a080", bodyToHex(body));
+  }
+
+  @Test public void stringWithNonDefaultCharsetSpecified() throws Exception {
+    MediaType contentType = MediaType.parse("text/plain; charset=utf-16be");
+    RequestBody body = RequestBody.create(contentType, "\u0800");
+    assertEquals(contentType, body.contentType());
+    assertEquals(2, body.contentLength());
+    assertEquals("0800", bodyToHex(body));
+  }
+
+  @Test public void byteArray() throws Exception {
+    MediaType contentType = MediaType.parse("text/plain");
+    RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
+    assertEquals(contentType, body.contentType());
+    assertEquals(3, body.contentLength());
+    assertEquals("616263", bodyToHex(body));
+    assertEquals("Retransmit body", "616263", bodyToHex(body));
+  }
+
+  @Test public void file() throws Exception {
+    File file = File.createTempFile("RequestTest", "tmp");
+    FileWriter writer = new FileWriter(file);
+    writer.write("abc");
+    writer.close();
+
+    MediaType contentType = MediaType.parse("text/plain");
+    RequestBody body = RequestBody.create(contentType, file);
+    assertEquals(contentType, body.contentType());
+    assertEquals(3, body.contentLength());
+    assertEquals("616263", bodyToHex(body));
+    assertEquals("Retransmit body", "616263", bodyToHex(body));
+  }
+
+  /** Common verbs used for apis such as GitHub, AWS, and Google Cloud. */
+  @Test public void crudVerbs() throws IOException {
+    MediaType contentType = MediaType.parse("application/json");
+    RequestBody body = RequestBody.create(contentType, "{}");
+
+    Request get = new Request.Builder().url("http://localhost/api").get().build();
+    assertEquals("GET", get.method());
+    assertNull(get.body());
+
+    Request head = new Request.Builder().url("http://localhost/api").head().build();
+    assertEquals("HEAD", head.method());
+    assertNull(head.body());
+
+    Request delete = new Request.Builder().url("http://localhost/api").delete().build();
+    assertEquals("DELETE", delete.method());
+    assertEquals(0L, delete.body().contentLength());
+
+    Request post = new Request.Builder().url("http://localhost/api").post(body).build();
+    assertEquals("POST", post.method());
+    assertEquals(body, post.body());
+
+    Request put = new Request.Builder().url("http://localhost/api").put(body).build();
+    assertEquals("PUT", put.method());
+    assertEquals(body, put.body());
+
+    Request patch = new Request.Builder().url("http://localhost/api").patch(body).build();
+    assertEquals("PATCH", patch.method());
+    assertEquals(body, patch.body());
+  }
+
+  @Test public void uninitializedURI() throws Exception {
+    Request request = new Request.Builder().url("http://localhost/api").build();
+    assertEquals(new URI("http://localhost/api"), request.uri());
+    assertEquals(new URL("http://localhost/api"), request.url());
+  }
+
+  @Test public void cacheControl() throws Exception {
+    Request request = new Request.Builder()
+        .cacheControl(new CacheControl.Builder().noCache().build())
+        .url("https://square.com")
+        .build();
+    assertEquals(Arrays.asList("no-cache"), request.headers("Cache-Control"));
+  }
+
+  @Test public void emptyCacheControlClearsAllCacheControlHeaders() throws Exception {
+    Request request = new Request.Builder()
+        .header("Cache-Control", "foo")
+        .cacheControl(new CacheControl.Builder().build())
+        .url("https://square.com")
+        .build();
+    assertEquals(Collections.<String>emptyList(), request.headers("Cache-Control"));
+  }
+
+  private String bodyToHex(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return buffer.readByteString().hex();
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxy.java b/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxy.java
new file mode 100644
index 0000000000..e2a553203f
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxy.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.NamedRunnable;
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+
+/**
+ * A limited implementation of SOCKS Protocol Version 5, intended to be similar to MockWebServer.
+ * See <a href="https://www.ietf.org/rfc/rfc1928.txt">RFC 1928</a>.
+ */
+public final class SocksProxy {
+  private static final int VERSION_5 = 5;
+  private static final int METHOD_NONE = 0xff;
+  private static final int METHOD_NO_AUTHENTICATION_REQUIRED = 0;
+  private static final int ADDRESS_TYPE_IPV4 = 1;
+  private static final int ADDRESS_TYPE_DOMAIN_NAME = 3;
+  private static final int COMMAND_CONNECT = 1;
+  private static final int REPLY_SUCCEEDED = 0;
+
+  private static final Logger logger = Logger.getLogger(SocksProxy.class.getName());
+
+  private final ExecutorService executor = Executors.newCachedThreadPool(
+      Util.threadFactory("SocksProxy", false));
+
+  private ServerSocket serverSocket;
+  private AtomicInteger connectionCount = new AtomicInteger();
+
+  public void play() throws IOException {
+    serverSocket = new ServerSocket(0);
+    executor.execute(new NamedRunnable("SocksProxy %s", serverSocket.getLocalPort()) {
+      @Override protected void execute() {
+        try {
+          while (true) {
+            Socket socket = serverSocket.accept();
+            connectionCount.incrementAndGet();
+            service(socket);
+          }
+        } catch (SocketException e) {
+          logger.info(name + " done accepting connections: " + e.getMessage());
+        } catch (IOException e) {
+          logger.log(Level.WARNING, name + " failed unexpectedly", e);
+        }
+      }
+    });
+  }
+
+  public Proxy proxy() {
+    return new Proxy(Proxy.Type.SOCKS, InetSocketAddress.createUnresolved(
+        "localhost", serverSocket.getLocalPort()));
+  }
+
+  public int connectionCount() {
+    return connectionCount.get();
+  }
+
+  public void shutdown() throws Exception {
+    serverSocket.close();
+    executor.shutdown();
+    if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
+      throw new IOException("Gave up waiting for executor to shut down");
+    }
+  }
+
+  private void service(final Socket from) {
+    executor.execute(new NamedRunnable("SocksProxy %s", from.getRemoteSocketAddress()) {
+      @Override protected void execute() {
+        try {
+          BufferedSource fromSource = Okio.buffer(Okio.source(from));
+          BufferedSink fromSink = Okio.buffer(Okio.sink(from));
+          hello(fromSource, fromSink);
+          acceptCommand(from.getInetAddress(), fromSource, fromSink);
+        } catch (IOException e) {
+          logger.log(Level.WARNING, name + " failed", e);
+          Util.closeQuietly(from);
+        }
+      }
+    });
+  }
+
+  private void hello(BufferedSource fromSource, BufferedSink fromSink) throws IOException {
+    int version = fromSource.readByte() & 0xff;
+    int methodCount = fromSource.readByte() & 0xff;
+    int selectedMethod = METHOD_NONE;
+
+    if (version != VERSION_5) {
+      throw new ProtocolException("unsupported version: " + version);
+    }
+
+    for (int i = 0; i < methodCount; i++) {
+      int candidateMethod = fromSource.readByte() & 0xff;
+      if (candidateMethod == METHOD_NO_AUTHENTICATION_REQUIRED) {
+        selectedMethod = candidateMethod;
+      }
+    }
+
+    switch (selectedMethod) {
+      case METHOD_NO_AUTHENTICATION_REQUIRED:
+        fromSink.writeByte(VERSION_5);
+        fromSink.writeByte(selectedMethod);
+        fromSink.emit();
+        break;
+
+      default:
+        throw new ProtocolException("unsupported method: " + selectedMethod);
+    }
+  }
+
+  private void acceptCommand(InetAddress fromAddress, BufferedSource fromSource,
+      BufferedSink fromSink) throws IOException {
+    // Read the command.
+    int version = fromSource.readByte() & 0xff;
+    if (version != VERSION_5) throw new ProtocolException("unexpected version: " + version);
+    int command = fromSource.readByte() & 0xff;
+    int reserved = fromSource.readByte() & 0xff;
+    if (reserved != 0) throw new ProtocolException("unexpected reserved: " + reserved);
+
+    int addressType = fromSource.readByte() & 0xff;
+    InetAddress toAddress;
+    switch (addressType) {
+      case ADDRESS_TYPE_IPV4:
+        toAddress = InetAddress.getByAddress(fromSource.readByteArray(4L));
+        break;
+
+      case ADDRESS_TYPE_DOMAIN_NAME:
+        int domainNameLength = fromSource.readByte() & 0xff;
+        String domainName = fromSource.readUtf8(domainNameLength);
+        toAddress = InetAddress.getByName(domainName);
+        break;
+
+      default:
+        throw new ProtocolException("unsupported address type: " + addressType);
+    }
+
+    int port = fromSource.readShort() & 0xffff;
+
+    switch (command) {
+      case COMMAND_CONNECT:
+        Socket toSocket = new Socket(toAddress, port);
+        byte[] localAddress = toSocket.getLocalAddress().getAddress();
+        if (localAddress.length != 4) {
+          throw new ProtocolException("unexpected address: " + toSocket.getLocalAddress());
+        }
+
+        // Write the reply.
+        fromSink.writeByte(VERSION_5);
+        fromSink.writeByte(REPLY_SUCCEEDED);
+        fromSink.writeByte(0);
+        fromSink.writeByte(ADDRESS_TYPE_IPV4);
+        fromSink.write(localAddress);
+        fromSink.writeShort(toSocket.getLocalPort());
+        fromSink.emit();
+
+        logger.log(Level.INFO, "SocksProxy connected " + fromAddress + " to " + toAddress);
+
+        // Copy sources to sinks in both directions.
+        BufferedSource toSource = Okio.buffer(Okio.source(toSocket));
+        BufferedSink toSink = Okio.buffer(Okio.sink(toSocket));
+        transfer(fromAddress, toAddress, fromSource, toSink);
+        transfer(fromAddress, toAddress, toSource, fromSink);
+        break;
+
+      default:
+        throw new ProtocolException("unexpected command: " + command);
+    }
+  }
+
+  private void transfer(final InetAddress fromAddress, final InetAddress toAddress,
+      final BufferedSource source, final BufferedSink sink) {
+    executor.execute(new NamedRunnable("SocksProxy %s to %s", fromAddress, toAddress) {
+      @Override protected void execute() {
+        Buffer buffer = new Buffer();
+        try {
+          while (true) {
+            long byteCount = source.read(buffer, 2048L);
+            if (byteCount == -1L) break;
+            sink.write(buffer, byteCount);
+            sink.emit();
+          }
+        } catch (SocketException e) {
+          logger.info(name + " done: " + e.getMessage());
+        } catch (IOException e) {
+          logger.log(Level.WARNING, name + " failed", e);
+        }
+
+        try {
+          source.close();
+        } catch (IOException e) {
+          logger.log(Level.WARNING, name + " failed", e);
+        }
+
+        try {
+          sink.close();
+        } catch (IOException e) {
+          logger.log(Level.WARNING, name + " failed", e);
+        }
+      }
+    });
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java
new file mode 100644
index 0000000000..234e449d85
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/SocksProxyTest.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import java.io.IOException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.util.Collections;
+import java.util.List;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public final class SocksProxyTest {
+  private final SocksProxy socksProxy = new SocksProxy();
+  private final MockWebServer server = new MockWebServer();
+
+  @Before public void setUp() throws Exception {
+    server.play();
+    socksProxy.play();
+  }
+
+  @After public void tearDown() throws Exception {
+    server.shutdown();
+    socksProxy.shutdown();
+  }
+
+  @Test public void proxy() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    OkHttpClient client = new OkHttpClient()
+        .setProxy(socksProxy.proxy());
+
+    Request request1 = new Request.Builder().url(server.getUrl("/")).build();
+    Response response1 = client.newCall(request1).execute();
+    assertEquals("abc", response1.body().string());
+
+    Request request2 = new Request.Builder().url(server.getUrl("/")).build();
+    Response response2 = client.newCall(request2).execute();
+    assertEquals("def", response2.body().string());
+
+    // The HTTP calls should share a single connection.
+    assertEquals(1, socksProxy.connectionCount());
+  }
+
+  @Test public void proxySelector() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    ProxySelector proxySelector = new ProxySelector() {
+      @Override public List<Proxy> select(URI uri) {
+        return Collections.singletonList(socksProxy.proxy());
+      }
+
+      @Override public void connectFailed(URI uri, SocketAddress socketAddress, IOException e) {
+        throw new AssertionError();
+      }
+    };
+
+    OkHttpClient client = new OkHttpClient()
+        .setProxySelector(proxySelector);
+
+    Request request = new Request.Builder().url(server.getUrl("/")).build();
+    Response response = client.newCall(request).execute();
+    assertEquals("abc", response.body().string());
+
+    assertEquals(1, socksProxy.connectionCount());
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/TestLogHandler.java b/okhttp-tests/src/test/java/com/squareup/okhttp/TestLogHandler.java
new file mode 100644
index 0000000000..24cb377cab
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/TestLogHandler.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.logging.Handler;
+import java.util.logging.LogRecord;
+
+/**
+ * A log handler that records which log messages were published so that a calling test can make
+ * assertions about them.
+ */
+public final class TestLogHandler extends Handler {
+  private final List<String> logs = new ArrayList<>();
+
+  @Override public synchronized void publish(LogRecord logRecord) {
+    logs.add(logRecord.getLevel() + ": " + logRecord.getMessage());
+    notifyAll();
+  }
+
+  @Override public void flush() {
+  }
+
+  @Override public void close() throws SecurityException {
+  }
+
+  public synchronized String take() throws InterruptedException {
+    while (logs.isEmpty()) {
+      wait();
+    }
+    return logs.remove(0);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/TestUtil.java b/okhttp-tests/src/test/java/com/squareup/okhttp/TestUtil.java
new file mode 100644
index 0000000000..10f0d4df19
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/TestUtil.java
@@ -0,0 +1,18 @@
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.spdy.Header;
+import java.util.ArrayList;
+import java.util.List;
+
+public final class TestUtil {
+  private TestUtil() {
+  }
+
+  public static List<Header> headerEntries(String... elements) {
+    List<Header> result = new ArrayList<>(elements.length / 2);
+    for (int i = 0; i < elements.length; i += 2) {
+      result.add(new Header(elements[i], elements[i + 1]));
+    }
+    return result;
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
new file mode 100644
index 0000000000..5a6a76bcec
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DiskLruCacheTest.java
@@ -0,0 +1,1250 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.concurrent.Executor;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Source;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.junit.rules.Timeout;
+
+import static com.squareup.okhttp.internal.DiskLruCache.JOURNAL_FILE;
+import static com.squareup.okhttp.internal.DiskLruCache.JOURNAL_FILE_BACKUP;
+import static com.squareup.okhttp.internal.DiskLruCache.MAGIC;
+import static com.squareup.okhttp.internal.DiskLruCache.VERSION_1;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class DiskLruCacheTest {
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+  @Rule public final Timeout timeout = new Timeout(30 * 1000);
+
+  private final int appVersion = 100;
+  private File cacheDir;
+  private File journalFile;
+  private File journalBkpFile;
+  private final TestExecutor executor = new TestExecutor();
+
+  private DiskLruCache cache;
+  private final Deque<DiskLruCache> toClose = new ArrayDeque<>();
+
+  private void createNewCache() throws IOException {
+    createNewCacheWithSize(Integer.MAX_VALUE);
+  }
+
+  private void createNewCacheWithSize(int maxSize) throws IOException {
+    cache = new DiskLruCache(cacheDir, appVersion, 2, maxSize, executor);
+    cache.initialize();
+    toClose.add(cache);
+  }
+
+  @Before public void setUp() throws Exception {
+    cacheDir = tempDir.getRoot();
+    journalFile = new File(cacheDir, JOURNAL_FILE);
+    journalBkpFile = new File(cacheDir, JOURNAL_FILE_BACKUP);
+    createNewCache();
+  }
+
+  @After public void tearDown() throws Exception {
+    while (!toClose.isEmpty()) {
+      toClose.pop().close();
+    }
+  }
+
+  @Test public void emptyCache() throws Exception {
+    cache.close();
+    assertJournalEquals();
+  }
+
+  @Test public void validateKey() throws Exception {
+    String key = null;
+    try {
+      key = "has_space ";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+    try {
+      key = "has_CR\r";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+    try {
+      key = "has_LF\n";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+    try {
+      key = "has_invalid/";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+    try {
+      key = "has_invalid\u2603";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+    try {
+      key = "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long_"
+          + "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long";
+      cache.edit(key);
+      fail("Exepcting an IllegalArgumentException as the key was too long.");
+    } catch (IllegalArgumentException iae) {
+      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+    }
+
+    // Test valid cases.
+
+    // Exactly 120.
+    key = "0123456789012345678901234567890123456789012345678901234567890123456789"
+        + "01234567890123456789012345678901234567890123456789";
+    cache.edit(key).abort();
+    // Contains all valid characters.
+    key = "abcdefghijklmnopqrstuvwxyz_0123456789";
+    cache.edit(key).abort();
+    // Contains dash.
+    key = "-20384573948576";
+    cache.edit(key).abort();
+  }
+
+  @Test public void writeAndReadEntry() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "ABC");
+    creator.set(1, "DE");
+    assertNull(creator.getString(0));
+    assertNull(creator.newSource(0));
+    assertNull(creator.getString(1));
+    assertNull(creator.newSource(1));
+    creator.commit();
+
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertEquals("ABC", snapshot.getString(0));
+    assertEquals(3, snapshot.getLength(0));
+    assertEquals("DE", snapshot.getString(1));
+    assertEquals(2, snapshot.getLength(1));
+  }
+
+  @Test public void readAndWriteEntryAcrossCacheOpenAndClose() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "A");
+    creator.set(1, "B");
+    creator.commit();
+    cache.close();
+
+    createNewCache();
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertEquals("A", snapshot.getString(0));
+    assertEquals(1, snapshot.getLength(0));
+    assertEquals("B", snapshot.getString(1));
+    assertEquals(1, snapshot.getLength(1));
+    snapshot.close();
+  }
+
+  @Test public void readAndWriteEntryWithoutProperClose() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "A");
+    creator.set(1, "B");
+    creator.commit();
+
+    // Simulate a dirty close of 'cache' by opening the cache directory again.
+    createNewCache();
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertEquals("A", snapshot.getString(0));
+    assertEquals(1, snapshot.getLength(0));
+    assertEquals("B", snapshot.getString(1));
+    assertEquals(1, snapshot.getLength(1));
+    snapshot.close();
+  }
+
+  @Test public void journalWithEditAndPublish() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
+    creator.set(0, "AB");
+    creator.set(1, "C");
+    creator.commit();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1");
+  }
+
+  @Test public void revertedNewFileIsRemoveInJournal() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
+    creator.set(0, "AB");
+    creator.set(1, "C");
+    creator.abort();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "REMOVE k1");
+  }
+
+  @Test public void unterminatedEditIsRevertedOnClose() throws Exception {
+    cache.edit("k1");
+    cache.close();
+    assertJournalEquals("DIRTY k1", "REMOVE k1");
+  }
+
+  @Test public void journalDoesNotIncludeReadOfYetUnpublishedValue() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    assertNull(cache.get("k1"));
+    creator.set(0, "A");
+    creator.set(1, "BC");
+    creator.commit();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "CLEAN k1 1 2");
+  }
+
+  @Test public void journalWithEditAndPublishAndRead() throws Exception {
+    DiskLruCache.Editor k1Creator = cache.edit("k1");
+    k1Creator.set(0, "AB");
+    k1Creator.set(1, "C");
+    k1Creator.commit();
+    DiskLruCache.Editor k2Creator = cache.edit("k2");
+    k2Creator.set(0, "DEF");
+    k2Creator.set(1, "G");
+    k2Creator.commit();
+    DiskLruCache.Snapshot k1Snapshot = cache.get("k1");
+    k1Snapshot.close();
+    cache.close();
+    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1", "DIRTY k2", "CLEAN k2 3 1", "READ k1");
+  }
+
+  @Test public void cannotOperateOnEditAfterPublish() throws Exception {
+    DiskLruCache.Editor editor = cache.edit("k1");
+    editor.set(0, "A");
+    editor.set(1, "B");
+    editor.commit();
+    assertInoperable(editor);
+  }
+
+  @Test public void cannotOperateOnEditAfterRevert() throws Exception {
+    DiskLruCache.Editor editor = cache.edit("k1");
+    editor.set(0, "A");
+    editor.set(1, "B");
+    editor.abort();
+    assertInoperable(editor);
+  }
+
+  @Test public void explicitRemoveAppliedToDiskImmediately() throws Exception {
+    DiskLruCache.Editor editor = cache.edit("k1");
+    editor.set(0, "ABC");
+    editor.set(1, "B");
+    editor.commit();
+    File k1 = getCleanFile("k1", 0);
+    assertEquals("ABC", readFile(k1));
+    cache.remove("k1");
+    assertFalse(k1.exists());
+  }
+
+  @Test public void removePreventsActiveEditFromStoringAValue() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Editor a = cache.edit("a");
+    a.set(0, "a1");
+    assertTrue(cache.remove("a"));
+    a.set(1, "a2");
+    a.commit();
+    assertAbsent("a");
+  }
+
+  /**
+   * Each read sees a snapshot of the file at the time read was called.
+   * This means that two reads of the same key can see different data.
+   */
+  @Test public void readAndWriteOverlapsMaintainConsistency() throws Exception {
+    DiskLruCache.Editor v1Creator = cache.edit("k1");
+    v1Creator.set(0, "AAaa");
+    v1Creator.set(1, "BBbb");
+    v1Creator.commit();
+
+    DiskLruCache.Snapshot snapshot1 = cache.get("k1");
+    BufferedSource inV1 = Okio.buffer(snapshot1.getSource(0));
+    assertEquals('A', inV1.readByte());
+    assertEquals('A', inV1.readByte());
+
+    DiskLruCache.Editor v1Updater = cache.edit("k1");
+    v1Updater.set(0, "CCcc");
+    v1Updater.set(1, "DDdd");
+    v1Updater.commit();
+
+    DiskLruCache.Snapshot snapshot2 = cache.get("k1");
+    assertEquals("CCcc", snapshot2.getString(0));
+    assertEquals(4, snapshot2.getLength(0));
+    assertEquals("DDdd", snapshot2.getString(1));
+    assertEquals(4, snapshot2.getLength(1));
+    snapshot2.close();
+
+    assertEquals('a', inV1.readByte());
+    assertEquals('a', inV1.readByte());
+    assertEquals("BBbb", snapshot1.getString(1));
+    assertEquals(4, snapshot1.getLength(1));
+    snapshot1.close();
+  }
+
+  @Test public void openWithDirtyKeyDeletesAllFilesForThatKey() throws Exception {
+    cache.close();
+    File cleanFile0 = getCleanFile("k1", 0);
+    File cleanFile1 = getCleanFile("k1", 1);
+    File dirtyFile0 = getDirtyFile("k1", 0);
+    File dirtyFile1 = getDirtyFile("k1", 1);
+    writeFile(cleanFile0, "A");
+    writeFile(cleanFile1, "B");
+    writeFile(dirtyFile0, "C");
+    writeFile(dirtyFile1, "D");
+    createJournal("CLEAN k1 1 1", "DIRTY   k1");
+    createNewCache();
+    assertFalse(cleanFile0.exists());
+    assertFalse(cleanFile1.exists());
+    assertFalse(dirtyFile0.exists());
+    assertFalse(dirtyFile1.exists());
+    assertNull(cache.get("k1"));
+  }
+
+  @Test public void openWithInvalidVersionClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "0", "100", "2", "");
+    createNewCache();
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidAppVersionClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "1", "101", "2", "");
+    createNewCache();
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidValueCountClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "1", "100", "1", "");
+    createNewCache();
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidBlankLineClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournalWithHeader(MAGIC, "1", "100", "2", "x");
+    createNewCache();
+    assertGarbageFilesAllDeleted();
+  }
+
+  @Test public void openWithInvalidJournalLineClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournal("CLEAN k1 1 1", "BOGUS");
+    createNewCache();
+    assertGarbageFilesAllDeleted();
+    assertNull(cache.get("k1"));
+  }
+
+  @Test public void openWithInvalidFileSizeClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournal("CLEAN k1 0000x001 1");
+    createNewCache();
+    assertGarbageFilesAllDeleted();
+    assertNull(cache.get("k1"));
+  }
+
+  @Test public void openWithTruncatedLineDiscardsThatLine() throws Exception {
+    cache.close();
+    writeFile(getCleanFile("k1", 0), "A");
+    writeFile(getCleanFile("k1", 1), "B");
+    Writer writer = new FileWriter(journalFile);
+    writer.write(MAGIC + "\n" + VERSION_1 + "\n100\n2\n\nCLEAN k1 1 1"); // no trailing newline
+    writer.close();
+    createNewCache();
+    assertNull(cache.get("k1"));
+
+    // The journal is not corrupt when editing after a truncated line.
+    set("k1", "C", "D");
+
+    cache.close();
+    createNewCache();
+    assertValue("k1", "C", "D");
+  }
+
+  @Test public void openWithTooManyFileSizesClearsDirectory() throws Exception {
+    cache.close();
+    generateSomeGarbageFiles();
+    createJournal("CLEAN k1 1 1 1");
+    createNewCache();
+    assertGarbageFilesAllDeleted();
+    assertNull(cache.get("k1"));
+  }
+
+  @Test public void keyWithSpaceNotPermitted() throws Exception {
+    try {
+      cache.edit("my key");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void keyWithNewlineNotPermitted() throws Exception {
+    try {
+      cache.edit("my\nkey");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void keyWithCarriageReturnNotPermitted() throws Exception {
+    try {
+      cache.edit("my\rkey");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void nullKeyThrows() throws Exception {
+    try {
+      cache.edit(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test public void createNewEntryWithTooFewValuesFails() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(1, "A");
+    try {
+      creator.commit();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    assertFalse(getCleanFile("k1", 0).exists());
+    assertFalse(getCleanFile("k1", 1).exists());
+    assertFalse(getDirtyFile("k1", 0).exists());
+    assertFalse(getDirtyFile("k1", 1).exists());
+    assertNull(cache.get("k1"));
+
+    DiskLruCache.Editor creator2 = cache.edit("k1");
+    creator2.set(0, "B");
+    creator2.set(1, "C");
+    creator2.commit();
+  }
+
+  @Test public void revertWithTooFewValues() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(1, "A");
+    creator.abort();
+    assertFalse(getCleanFile("k1", 0).exists());
+    assertFalse(getCleanFile("k1", 1).exists());
+    assertFalse(getDirtyFile("k1", 0).exists());
+    assertFalse(getDirtyFile("k1", 1).exists());
+    assertNull(cache.get("k1"));
+  }
+
+  @Test public void updateExistingEntryWithTooFewValuesReusesPreviousValues() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "A");
+    creator.set(1, "B");
+    creator.commit();
+
+    DiskLruCache.Editor updater = cache.edit("k1");
+    updater.set(0, "C");
+    updater.commit();
+
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertEquals("C", snapshot.getString(0));
+    assertEquals(1, snapshot.getLength(0));
+    assertEquals("B", snapshot.getString(1));
+    assertEquals(1, snapshot.getLength(1));
+    snapshot.close();
+  }
+
+  @Test public void growMaxSize() throws Exception {
+    cache.close();
+    createNewCacheWithSize(10);
+    set("a", "a", "aaa"); // size 4
+    set("b", "bb", "bbbb"); // size 6
+    cache.setMaxSize(20);
+    set("c", "c", "c"); // size 12
+    assertEquals(12, cache.size());
+  }
+
+  @Test public void shrinkMaxSizeEvicts() throws Exception {
+    cache.close();
+    createNewCacheWithSize(20);
+    set("a", "a", "aaa"); // size 4
+    set("b", "bb", "bbbb"); // size 6
+    set("c", "c", "c"); // size 12
+    cache.setMaxSize(10);
+    assertEquals(1, executor.jobs.size());
+  }
+
+  @Test public void evictOnInsert() throws Exception {
+    cache.close();
+    createNewCacheWithSize(10);
+
+    set("a", "a", "aaa"); // size 4
+    set("b", "bb", "bbbb"); // size 6
+    assertEquals(10, cache.size());
+
+    // Cause the size to grow to 12 should evict 'A'.
+    set("c", "c", "c");
+    cache.flush();
+    assertEquals(8, cache.size());
+    assertAbsent("a");
+    assertValue("b", "bb", "bbbb");
+    assertValue("c", "c", "c");
+
+    // Causing the size to grow to 10 should evict nothing.
+    set("d", "d", "d");
+    cache.flush();
+    assertEquals(10, cache.size());
+    assertAbsent("a");
+    assertValue("b", "bb", "bbbb");
+    assertValue("c", "c", "c");
+    assertValue("d", "d", "d");
+
+    // Causing the size to grow to 18 should evict 'B' and 'C'.
+    set("e", "eeee", "eeee");
+    cache.flush();
+    assertEquals(10, cache.size());
+    assertAbsent("a");
+    assertAbsent("b");
+    assertAbsent("c");
+    assertValue("d", "d", "d");
+    assertValue("e", "eeee", "eeee");
+  }
+
+  @Test public void evictOnUpdate() throws Exception {
+    cache.close();
+    createNewCacheWithSize(10);
+
+    set("a", "a", "aa"); // size 3
+    set("b", "b", "bb"); // size 3
+    set("c", "c", "cc"); // size 3
+    assertEquals(9, cache.size());
+
+    // Causing the size to grow to 11 should evict 'A'.
+    set("b", "b", "bbbb");
+    cache.flush();
+    assertEquals(8, cache.size());
+    assertAbsent("a");
+    assertValue("b", "b", "bbbb");
+    assertValue("c", "c", "cc");
+  }
+
+  @Test public void evictionHonorsLruFromCurrentSession() throws Exception {
+    cache.close();
+    createNewCacheWithSize(10);
+    set("a", "a", "a");
+    set("b", "b", "b");
+    set("c", "c", "c");
+    set("d", "d", "d");
+    set("e", "e", "e");
+    cache.get("b").close(); // 'B' is now least recently used.
+
+    // Causing the size to grow to 12 should evict 'A'.
+    set("f", "f", "f");
+    // Causing the size to grow to 12 should evict 'C'.
+    set("g", "g", "g");
+    cache.flush();
+    assertEquals(10, cache.size());
+    assertAbsent("a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertValue("d", "d", "d");
+    assertValue("e", "e", "e");
+    assertValue("f", "f", "f");
+  }
+
+  @Test public void evictionHonorsLruFromPreviousSession() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    set("c", "c", "c");
+    set("d", "d", "d");
+    set("e", "e", "e");
+    set("f", "f", "f");
+    cache.get("b").close(); // 'B' is now least recently used.
+    assertEquals(12, cache.size());
+    cache.close();
+    createNewCacheWithSize(10);
+
+    set("g", "g", "g");
+    cache.flush();
+    assertEquals(10, cache.size());
+    assertAbsent("a");
+    assertValue("b", "b", "b");
+    assertAbsent("c");
+    assertValue("d", "d", "d");
+    assertValue("e", "e", "e");
+    assertValue("f", "f", "f");
+    assertValue("g", "g", "g");
+  }
+
+  @Test public void cacheSingleEntryOfSizeGreaterThanMaxSize() throws Exception {
+    cache.close();
+    createNewCacheWithSize(10);
+    set("a", "aaaaa", "aaaaaa"); // size=11
+    cache.flush();
+    assertAbsent("a");
+  }
+
+  @Test public void cacheSingleValueOfSizeGreaterThanMaxSize() throws Exception {
+    cache.close();
+    createNewCacheWithSize(10);
+    set("a", "aaaaaaaaaaa", "a"); // size=12
+    cache.flush();
+    assertAbsent("a");
+  }
+
+  @Test public void constructorDoesNotAllowZeroCacheSize() throws Exception {
+    try {
+      DiskLruCache.open(cacheDir, appVersion, 2, 0);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void constructorDoesNotAllowZeroValuesPerEntry() throws Exception {
+    try {
+      DiskLruCache.open(cacheDir, appVersion, 0, 10);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void removeAbsentElement() throws Exception {
+    cache.remove("a");
+  }
+
+  @Test public void readingTheSameStreamMultipleTimes() throws Exception {
+    set("a", "a", "b");
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    assertSame(snapshot.getSource(0), snapshot.getSource(0));
+    snapshot.close();
+  }
+
+  @Test public void rebuildJournalOnRepeatedReads() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    while (executor.jobs.isEmpty()) {
+      assertValue("a", "a", "a");
+      assertValue("b", "b", "b");
+    }
+  }
+
+  @Test public void rebuildJournalOnRepeatedEdits() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+    }
+    executor.jobs.removeFirst().run();
+
+    // Sanity check that a rebuilt journal behaves normally.
+    assertValue("a", "a", "a");
+    assertValue("b", "b", "b");
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
+  @Test public void rebuildJournalOnRepeatedReadsWithOpenAndClose() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    while (executor.jobs.isEmpty()) {
+      assertValue("a", "a", "a");
+      assertValue("b", "b", "b");
+      cache.close();
+      createNewCache();
+    }
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
+  @Test public void rebuildJournalOnRepeatedEditsWithOpenAndClose() throws Exception {
+    while (executor.jobs.isEmpty()) {
+      set("a", "a", "a");
+      set("b", "b", "b");
+      cache.close();
+      createNewCache();
+    }
+  }
+
+  @Test public void restoreBackupFile() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "ABC");
+    creator.set(1, "DE");
+    creator.commit();
+    cache.close();
+
+    assertTrue(journalFile.renameTo(journalBkpFile));
+    assertFalse(journalFile.exists());
+
+    createNewCache();
+
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertEquals("ABC", snapshot.getString(0));
+    assertEquals(3, snapshot.getLength(0));
+    assertEquals("DE", snapshot.getString(1));
+    assertEquals(2, snapshot.getLength(1));
+
+    assertFalse(journalBkpFile.exists());
+    assertTrue(journalFile.exists());
+  }
+
+  @Test public void journalFileIsPreferredOverBackupFile() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    creator.set(0, "ABC");
+    creator.set(1, "DE");
+    creator.commit();
+    cache.flush();
+
+    copyFile(journalFile, journalBkpFile);
+
+    creator = cache.edit("k2");
+    creator.set(0, "F");
+    creator.set(1, "GH");
+    creator.commit();
+    cache.close();
+
+    assertTrue(journalFile.exists());
+    assertTrue(journalBkpFile.exists());
+
+    createNewCache();
+
+    DiskLruCache.Snapshot snapshotA = cache.get("k1");
+    assertEquals("ABC", snapshotA.getString(0));
+    assertEquals(3, snapshotA.getLength(0));
+    assertEquals("DE", snapshotA.getString(1));
+    assertEquals(2, snapshotA.getLength(1));
+
+    DiskLruCache.Snapshot snapshotB = cache.get("k2");
+    assertEquals("F", snapshotB.getString(0));
+    assertEquals(1, snapshotB.getLength(0));
+    assertEquals("GH", snapshotB.getString(1));
+    assertEquals(2, snapshotB.getLength(1));
+
+    assertFalse(journalBkpFile.exists());
+    assertTrue(journalFile.exists());
+  }
+
+  @Test public void openCreatesDirectoryIfNecessary() throws Exception {
+    cache.close();
+    File dir = tempDir.newFolder("testOpenCreatesDirectoryIfNecessary");
+    cache = DiskLruCache.open(dir, appVersion, 2, Integer.MAX_VALUE);
+    set("a", "a", "a");
+    assertTrue(new File(dir, "a.0").exists());
+    assertTrue(new File(dir, "a.1").exists());
+    assertTrue(new File(dir, "journal").exists());
+  }
+
+  @Test public void fileDeletedExternally() throws Exception {
+    set("a", "a", "a");
+    getCleanFile("a", 1).delete();
+    assertNull(cache.get("a"));
+  }
+
+  @Test public void editSameVersion() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    DiskLruCache.Editor editor = snapshot.edit();
+    editor.set(1, "a2");
+    editor.commit();
+    assertValue("a", "a", "a2");
+  }
+
+  @Test public void editSnapshotAfterChangeAborted() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    DiskLruCache.Editor toAbort = snapshot.edit();
+    toAbort.set(0, "b");
+    toAbort.abort();
+    DiskLruCache.Editor editor = snapshot.edit();
+    editor.set(1, "a2");
+    editor.commit();
+    assertValue("a", "a", "a2");
+  }
+
+  @Test public void editSnapshotAfterChangeCommitted() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    DiskLruCache.Editor toAbort = snapshot.edit();
+    toAbort.set(0, "b");
+    toAbort.commit();
+    assertNull(snapshot.edit());
+  }
+
+  @Test public void editSinceEvicted() throws Exception {
+    cache.close();
+    createNewCacheWithSize(10);
+    set("a", "aa", "aaa"); // size 5
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    set("b", "bb", "bbb"); // size 5
+    set("c", "cc", "ccc"); // size 5; will evict 'A'
+    cache.flush();
+    assertNull(snapshot.edit());
+  }
+
+  @Test public void editSinceEvictedAndRecreated() throws Exception {
+    cache.close();
+    createNewCacheWithSize(10);
+    set("a", "aa", "aaa"); // size 5
+    DiskLruCache.Snapshot snapshot = cache.get("a");
+    set("b", "bb", "bbb"); // size 5
+    set("c", "cc", "ccc"); // size 5; will evict 'A'
+    set("a", "a", "aaaa"); // size 5; will evict 'B'
+    cache.flush();
+    assertNull(snapshot.edit());
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesWrite() throws Exception {
+    tempDir.delete();
+    set("a", "a", "a");
+    assertValue("a", "a", "a");
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesEdit() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Editor a = cache.get("a").edit();
+    tempDir.delete();
+    a.set(1, "a2");
+    a.commit();
+  }
+
+  @Test public void removeHandlesMissingFile() throws Exception {
+    set("a", "a", "a");
+    getCleanFile("a", 0).delete();
+    cache.remove("a");
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesPartialEdit() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    DiskLruCache.Editor a = cache.get("a").edit();
+    a.set(0, "a1");
+    tempDir.delete();
+    a.set(1, "a2");
+    a.commit();
+    assertNull(cache.get("a"));
+  }
+
+  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
+  @Test public void aggressiveClearingHandlesRead() throws Exception {
+    tempDir.delete();
+    assertNull(cache.get("a"));
+  }
+
+  /**
+   * We had a long-lived bug where {@link DiskLruCache#trimToSize} could
+   * infinite loop if entries being edited required deletion for the operation
+   * to complete.
+   */
+  @Test public void trimToSizeWithActiveEdit() throws Exception {
+    set("a", "a1234", "a1234");
+    DiskLruCache.Editor a = cache.edit("a");
+    a.set(0, "a123");
+
+    cache.setMaxSize(8); // Smaller than the sum of active edits!
+    cache.flush(); // Force trimToSize().
+    assertEquals(0, cache.size());
+    assertNull(cache.get("a"));
+
+    // After the edit is completed, its entry is still gone.
+    a.set(1, "a1");
+    a.commit();
+    assertAbsent("a");
+    assertEquals(0, cache.size());
+  }
+
+  @Test public void evictAll() throws Exception {
+    set("a", "a", "a");
+    set("b", "b", "b");
+    cache.evictAll();
+    assertEquals(0, cache.size());
+    assertAbsent("a");
+    assertAbsent("b");
+  }
+
+  @Test public void evictAllWithPartialCreate() throws Exception {
+    DiskLruCache.Editor a = cache.edit("a");
+    a.set(0, "a1");
+    a.set(1, "a2");
+    cache.evictAll();
+    assertEquals(0, cache.size());
+    a.commit();
+    assertAbsent("a");
+  }
+
+  @Test public void evictAllWithPartialEditDoesNotStoreAValue() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Editor a = cache.edit("a");
+    a.set(0, "a1");
+    a.set(1, "a2");
+    cache.evictAll();
+    assertEquals(0, cache.size());
+    a.commit();
+    assertAbsent("a");
+  }
+
+  @Test public void evictAllDoesntInterruptPartialRead() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Snapshot a = cache.get("a");
+    assertEquals("a", a.getString(0));
+    cache.evictAll();
+    assertEquals(0, cache.size());
+    assertAbsent("a");
+    assertEquals("a", a.getString(1));
+    a.close();
+  }
+
+  @Test public void editSnapshotAfterEvictAllReturnsNullDueToStaleValue() throws Exception {
+    set("a", "a", "a");
+    DiskLruCache.Snapshot a = cache.get("a");
+    cache.evictAll();
+    assertEquals(0, cache.size());
+    assertAbsent("a");
+    assertNull(a.edit());
+    a.close();
+  }
+
+  @Test public void iterator() throws Exception {
+    set("a", "a1", "a2");
+    set("b", "b1", "b2");
+    set("c", "c1", "c2");
+    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
+
+    assertTrue(iterator.hasNext());
+    DiskLruCache.Snapshot a = iterator.next();
+    assertEquals("a", a.key());
+    assertEquals("a1", a.getString(0));
+    assertEquals("a2", a.getString(1));
+    a.close();
+
+    assertTrue(iterator.hasNext());
+    DiskLruCache.Snapshot b = iterator.next();
+    assertEquals("b", b.key());
+    assertEquals("b1", b.getString(0));
+    assertEquals("b2", b.getString(1));
+    b.close();
+
+    assertTrue(iterator.hasNext());
+    DiskLruCache.Snapshot c = iterator.next();
+    assertEquals("c", c.key());
+    assertEquals("c1", c.getString(0));
+    assertEquals("c2", c.getString(1));
+    c.close();
+
+    assertFalse(iterator.hasNext());
+    try {
+      iterator.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+  }
+
+  @Test public void iteratorElementsAddedDuringIterationAreOmitted() throws Exception {
+    set("a", "a1", "a2");
+    set("b", "b1", "b2");
+    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
+
+    DiskLruCache.Snapshot a = iterator.next();
+    assertEquals("a", a.key());
+    a.close();
+
+    set("c", "c1", "c2");
+
+    DiskLruCache.Snapshot b = iterator.next();
+    assertEquals("b", b.key());
+    b.close();
+
+    assertFalse(iterator.hasNext());
+  }
+
+  @Test public void iteratorElementsUpdatedDuringIterationAreUpdated() throws Exception {
+    set("a", "a1", "a2");
+    set("b", "b1", "b2");
+    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
+
+    DiskLruCache.Snapshot a = iterator.next();
+    assertEquals("a", a.key());
+    a.close();
+
+    set("b", "b3", "b4");
+
+    DiskLruCache.Snapshot b = iterator.next();
+    assertEquals("b", b.key());
+    assertEquals("b3", b.getString(0));
+    assertEquals("b4", b.getString(1));
+    b.close();
+  }
+
+  @Test public void iteratorElementsRemovedDuringIterationAreOmitted() throws Exception {
+    set("a", "a1", "a2");
+    set("b", "b1", "b2");
+    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
+
+    cache.remove("b");
+
+    DiskLruCache.Snapshot a = iterator.next();
+    assertEquals("a", a.key());
+    a.close();
+
+    assertFalse(iterator.hasNext());
+  }
+
+  @Test public void iteratorRemove() throws Exception {
+    set("a", "a1", "a2");
+    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
+
+    DiskLruCache.Snapshot a = iterator.next();
+    a.close();
+    iterator.remove();
+
+    assertEquals(null, cache.get("a"));
+  }
+
+  @Test public void iteratorRemoveBeforeNext() throws Exception {
+    set("a", "a1", "a2");
+    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
+    try {
+      iterator.remove();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void iteratorRemoveOncePerCallToNext() throws Exception {
+    set("a", "a1", "a2");
+    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
+
+    DiskLruCache.Snapshot a = iterator.next();
+    iterator.remove();
+    a.close();
+
+    try {
+      iterator.remove();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void cacheClosedTruncatesIterator() throws Exception {
+    set("a", "a1", "a2");
+    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
+    cache.close();
+    assertFalse(iterator.hasNext());
+  }
+
+  private void assertJournalEquals(String... expectedBodyLines) throws Exception {
+    List<String> expectedLines = new ArrayList<>();
+    expectedLines.add(MAGIC);
+    expectedLines.add(VERSION_1);
+    expectedLines.add("100");
+    expectedLines.add("2");
+    expectedLines.add("");
+    expectedLines.addAll(Arrays.asList(expectedBodyLines));
+    assertEquals(expectedLines, readJournalLines());
+  }
+
+  private void createJournal(String... bodyLines) throws Exception {
+    createJournalWithHeader(MAGIC, VERSION_1, "100", "2", "", bodyLines);
+  }
+
+  private void createJournalWithHeader(String magic, String version, String appVersion,
+      String valueCount, String blank, String... bodyLines) throws Exception {
+    Writer writer = new FileWriter(journalFile);
+    writer.write(magic + "\n");
+    writer.write(version + "\n");
+    writer.write(appVersion + "\n");
+    writer.write(valueCount + "\n");
+    writer.write(blank + "\n");
+    for (String line : bodyLines) {
+      writer.write(line);
+      writer.write('\n');
+    }
+    writer.close();
+  }
+
+  private List<String> readJournalLines() throws Exception {
+    List<String> result = new ArrayList<>();
+    BufferedReader reader = new BufferedReader(new FileReader(journalFile));
+    String line;
+    while ((line = reader.readLine()) != null) {
+      result.add(line);
+    }
+    reader.close();
+    return result;
+  }
+
+  private File getCleanFile(String key, int index) {
+    return new File(cacheDir, key + "." + index);
+  }
+
+  private File getDirtyFile(String key, int index) {
+    return new File(cacheDir, key + "." + index + ".tmp");
+  }
+
+  private static String readFile(File file) throws Exception {
+    Reader reader = new FileReader(file);
+    StringWriter writer = new StringWriter();
+    char[] buffer = new char[1024];
+    int count;
+    while ((count = reader.read(buffer)) != -1) {
+      writer.write(buffer, 0, count);
+    }
+    reader.close();
+    return writer.toString();
+  }
+
+  public static void writeFile(File file, String content) throws Exception {
+    FileWriter writer = new FileWriter(file);
+    writer.write(content);
+    writer.close();
+  }
+
+  private static void assertInoperable(DiskLruCache.Editor editor) throws Exception {
+    try {
+      editor.getString(0);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.set(0, "A");
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.newSource(0);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.newSink(0);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.commit();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      editor.abort();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  private void generateSomeGarbageFiles() throws Exception {
+    File dir1 = new File(cacheDir, "dir1");
+    File dir2 = new File(dir1, "dir2");
+    writeFile(getCleanFile("g1", 0), "A");
+    writeFile(getCleanFile("g1", 1), "B");
+    writeFile(getCleanFile("g2", 0), "C");
+    writeFile(getCleanFile("g2", 1), "D");
+    writeFile(getCleanFile("g2", 1), "D");
+    writeFile(new File(cacheDir, "otherFile0"), "E");
+    dir1.mkdir();
+    dir2.mkdir();
+    writeFile(new File(dir2, "otherFile1"), "F");
+  }
+
+  private void assertGarbageFilesAllDeleted() throws Exception {
+    assertFalse(getCleanFile("g1", 0).exists());
+    assertFalse(getCleanFile("g1", 1).exists());
+    assertFalse(getCleanFile("g2", 0).exists());
+    assertFalse(getCleanFile("g2", 1).exists());
+    assertFalse(new File(cacheDir, "otherFile0").exists());
+    assertFalse(new File(cacheDir, "dir1").exists());
+  }
+
+  private void set(String key, String value0, String value1) throws Exception {
+    DiskLruCache.Editor editor = cache.edit(key);
+    editor.set(0, value0);
+    editor.set(1, value1);
+    editor.commit();
+  }
+
+  private void assertAbsent(String key) throws Exception {
+    DiskLruCache.Snapshot snapshot = cache.get(key);
+    if (snapshot != null) {
+      snapshot.close();
+      fail();
+    }
+    assertFalse(getCleanFile(key, 0).exists());
+    assertFalse(getCleanFile(key, 1).exists());
+    assertFalse(getDirtyFile(key, 0).exists());
+    assertFalse(getDirtyFile(key, 1).exists());
+  }
+
+  private void assertValue(String key, String value0, String value1) throws Exception {
+    DiskLruCache.Snapshot snapshot = cache.get(key);
+    assertEquals(value0, snapshot.getString(0));
+    assertEquals(value0.length(), snapshot.getLength(0));
+    assertEquals(value1, snapshot.getString(1));
+    assertEquals(value1.length(), snapshot.getLength(1));
+    assertTrue(getCleanFile(key, 0).exists());
+    assertTrue(getCleanFile(key, 1).exists());
+    snapshot.close();
+  }
+
+  private void copyFile(File from, File to) throws IOException {
+    Source source = Okio.source(from);
+    BufferedSink sink = Okio.buffer(Okio.sink(to));
+    sink.writeAll(source);
+    source.close();
+    sink.close();
+  }
+
+  private static class TestExecutor implements Executor {
+    final Deque<Runnable> jobs = new ArrayDeque<>();
+
+    @Override public void execute(Runnable command) {
+      jobs.addLast(command);
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DoubleInetAddressNetwork.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DoubleInetAddressNetwork.java
new file mode 100644
index 0000000000..4934b427c9
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/DoubleInetAddressNetwork.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+
+/**
+ * A network that always resolves two IP addresses per host. Use this when testing route selection
+ * fallbacks to guarantee that a fallback address is available.
+ */
+public class DoubleInetAddressNetwork implements Network {
+  @Override public InetAddress[] resolveInetAddresses(String host) throws UnknownHostException {
+    InetAddress[] allInetAddresses = Network.DEFAULT.resolveInetAddresses(host);
+    return new InetAddress[] { allInetAddresses[0], allInetAddresses[0] };
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/OptionalMethodTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/OptionalMethodTest.java
new file mode 100644
index 0000000000..3e129a2353
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/OptionalMethodTest.java
@@ -0,0 +1,336 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.squareup.okhttp.internal;
+
+import org.junit.Test;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests for {@link OptionalMethod}.
+ */
+public class OptionalMethodTest {
+  @SuppressWarnings("unused")
+  private static class BaseClass {
+    public String stringMethod() {
+      return "string";
+    }
+
+    public void voidMethod() {}
+  }
+
+  @SuppressWarnings("unused")
+  private static class SubClass1 extends BaseClass {
+    public String subclassMethod() {
+      return "subclassMethod1";
+    }
+
+    public String methodWithArgs(String arg) {
+      return arg;
+    }
+  }
+
+  @SuppressWarnings("unused")
+  private static class SubClass2 extends BaseClass {
+    public int subclassMethod() {
+      return 1234;
+    }
+
+    public String methodWithArgs(String arg) {
+      return arg;
+    }
+
+    public void throwsException() throws IOException {
+      throw new IOException();
+    }
+
+    public void throwsRuntimeException() throws Exception {
+      throw new NumberFormatException();
+    }
+
+    protected void nonPublic() {}
+  }
+
+  private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_ANY =
+      new OptionalMethod<BaseClass>(null, "stringMethod");
+  private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_STRING =
+      new OptionalMethod<BaseClass>(String.class, "stringMethod");
+  private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_INT =
+      new OptionalMethod<BaseClass>(Integer.TYPE, "stringMethod");
+  private final static OptionalMethod<BaseClass> VOID_METHOD_RETURNS_ANY =
+      new OptionalMethod<BaseClass>(null, "voidMethod");
+  private final static OptionalMethod<BaseClass> VOID_METHOD_RETURNS_VOID =
+      new OptionalMethod<BaseClass>(Void.TYPE, "voidMethod");
+  private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_ANY =
+      new OptionalMethod<BaseClass>(null, "subclassMethod");
+  private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_STRING =
+      new OptionalMethod<BaseClass>(String.class, "subclassMethod");
+  private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_INT =
+      new OptionalMethod<BaseClass>(Integer.TYPE, "subclassMethod");
+  private final static OptionalMethod<BaseClass> METHOD_WITH_ARGS_WRONG_PARAMS =
+      new OptionalMethod<BaseClass>(null, "methodWithArgs", Integer.class);
+  private final static OptionalMethod<BaseClass> METHOD_WITH_ARGS_CORRECT_PARAMS =
+      new OptionalMethod<BaseClass>(null, "methodWithArgs", String.class);
+
+  private final static OptionalMethod<BaseClass> THROWS_EXCEPTION =
+      new OptionalMethod<BaseClass>(null, "throwsException");
+  private final static OptionalMethod<BaseClass> THROWS_RUNTIME_EXCEPTION =
+      new OptionalMethod<BaseClass>(null, "throwsRuntimeException");
+  private final static OptionalMethod<BaseClass> NON_PUBLIC =
+      new OptionalMethod<BaseClass>(null, "nonPublic");
+
+  @Test
+  public void isSupported() throws Exception {
+    {
+      BaseClass base = new BaseClass();
+      assertTrue(STRING_METHOD_RETURNS_ANY.isSupported(base));
+      assertTrue(STRING_METHOD_RETURNS_STRING.isSupported(base));
+      assertFalse(STRING_METHOD_RETURNS_INT.isSupported(base));
+      assertTrue(VOID_METHOD_RETURNS_ANY.isSupported(base));
+      assertTrue(VOID_METHOD_RETURNS_VOID.isSupported(base));
+      assertFalse(SUBCLASS_METHOD_RETURNS_ANY.isSupported(base));
+      assertFalse(SUBCLASS_METHOD_RETURNS_STRING.isSupported(base));
+      assertFalse(SUBCLASS_METHOD_RETURNS_INT.isSupported(base));
+      assertFalse(METHOD_WITH_ARGS_WRONG_PARAMS.isSupported(base));
+      assertFalse(METHOD_WITH_ARGS_CORRECT_PARAMS.isSupported(base));
+    }
+    {
+      SubClass1 subClass1 = new SubClass1();
+      assertTrue(STRING_METHOD_RETURNS_ANY.isSupported(subClass1));
+      assertTrue(STRING_METHOD_RETURNS_STRING.isSupported(subClass1));
+      assertFalse(STRING_METHOD_RETURNS_INT.isSupported(subClass1));
+      assertTrue(VOID_METHOD_RETURNS_ANY.isSupported(subClass1));
+      assertTrue(VOID_METHOD_RETURNS_VOID.isSupported(subClass1));
+      assertTrue(SUBCLASS_METHOD_RETURNS_ANY.isSupported(subClass1));
+      assertTrue(SUBCLASS_METHOD_RETURNS_STRING.isSupported(subClass1));
+      assertFalse(SUBCLASS_METHOD_RETURNS_INT.isSupported(subClass1));
+      assertFalse(METHOD_WITH_ARGS_WRONG_PARAMS.isSupported(subClass1));
+      assertTrue(METHOD_WITH_ARGS_CORRECT_PARAMS.isSupported(subClass1));
+    }
+    {
+      SubClass2 subClass2 = new SubClass2();
+      assertTrue(STRING_METHOD_RETURNS_ANY.isSupported(subClass2));
+      assertTrue(STRING_METHOD_RETURNS_STRING.isSupported(subClass2));
+      assertFalse(STRING_METHOD_RETURNS_INT.isSupported(subClass2));
+      assertTrue(VOID_METHOD_RETURNS_ANY.isSupported(subClass2));
+      assertTrue(VOID_METHOD_RETURNS_VOID.isSupported(subClass2));
+      assertTrue(SUBCLASS_METHOD_RETURNS_ANY.isSupported(subClass2));
+      assertFalse(SUBCLASS_METHOD_RETURNS_STRING.isSupported(subClass2));
+      assertTrue(SUBCLASS_METHOD_RETURNS_INT.isSupported(subClass2));
+      assertFalse(METHOD_WITH_ARGS_WRONG_PARAMS.isSupported(subClass2));
+      assertTrue(METHOD_WITH_ARGS_CORRECT_PARAMS.isSupported(subClass2));
+    }
+  }
+
+  @Test
+  public void invoke() throws Exception {
+    {
+      BaseClass base = new BaseClass();
+      assertEquals("string", STRING_METHOD_RETURNS_STRING.invoke(base));
+      assertEquals("string", STRING_METHOD_RETURNS_ANY.invoke(base));
+      assertErrorOnInvoke(STRING_METHOD_RETURNS_INT, base);
+      assertNull(VOID_METHOD_RETURNS_ANY.invoke(base));
+      assertNull(VOID_METHOD_RETURNS_VOID.invoke(base));
+      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_ANY, base);
+      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_STRING, base);
+      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_INT, base);
+      assertErrorOnInvoke(METHOD_WITH_ARGS_WRONG_PARAMS, base);
+      assertErrorOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, base);
+    }
+    {
+      SubClass1 subClass1 = new SubClass1();
+      assertEquals("string", STRING_METHOD_RETURNS_STRING.invoke(subClass1));
+      assertEquals("string", STRING_METHOD_RETURNS_ANY.invoke(subClass1));
+      assertErrorOnInvoke(STRING_METHOD_RETURNS_INT, subClass1);
+      assertNull(VOID_METHOD_RETURNS_ANY.invoke(subClass1));
+      assertNull(VOID_METHOD_RETURNS_VOID.invoke(subClass1));
+      assertEquals("subclassMethod1", SUBCLASS_METHOD_RETURNS_ANY.invoke(subClass1));
+      assertEquals("subclassMethod1", SUBCLASS_METHOD_RETURNS_STRING.invoke(subClass1));
+      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_INT, subClass1);
+      assertErrorOnInvoke(METHOD_WITH_ARGS_WRONG_PARAMS, subClass1);
+      assertEquals("arg", METHOD_WITH_ARGS_CORRECT_PARAMS.invoke(subClass1, "arg"));
+    }
+
+    {
+      SubClass2 subClass2 = new SubClass2();
+      assertEquals("string", STRING_METHOD_RETURNS_STRING.invoke(subClass2));
+      assertEquals("string", STRING_METHOD_RETURNS_ANY.invoke(subClass2));
+      assertErrorOnInvoke(STRING_METHOD_RETURNS_INT, subClass2);
+      assertNull(VOID_METHOD_RETURNS_ANY.invoke(subClass2));
+      assertNull(VOID_METHOD_RETURNS_VOID.invoke(subClass2));
+      assertEquals(1234, SUBCLASS_METHOD_RETURNS_ANY.invoke(subClass2));
+      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_STRING, subClass2);
+      assertEquals(1234, SUBCLASS_METHOD_RETURNS_INT.invoke(subClass2));
+      assertErrorOnInvoke(METHOD_WITH_ARGS_WRONG_PARAMS, subClass2);
+      assertEquals("arg", METHOD_WITH_ARGS_CORRECT_PARAMS.invoke(subClass2, "arg"));
+    }
+  }
+
+  @Test
+  public void invokeBadArgs() throws Exception {
+    SubClass1 subClass1 = new SubClass1();
+    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1); // no args
+    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, 123);
+    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, true);
+    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, new Object());
+    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, "one", "two");
+  }
+
+  @Test
+  public void invokeWithException() throws Exception {
+    SubClass2 subClass2 = new SubClass2();
+    try {
+      THROWS_EXCEPTION.invoke(subClass2);
+    } catch (InvocationTargetException expected) {
+      assertTrue(expected.getTargetException() instanceof IOException);
+    }
+
+    try {
+      THROWS_RUNTIME_EXCEPTION.invoke(subClass2);
+    } catch (InvocationTargetException expected) {
+      assertTrue(expected.getTargetException() instanceof NumberFormatException);
+    }
+  }
+
+  @Test
+  public void invokeNonPublic() throws Exception {
+    SubClass2 subClass2 = new SubClass2();
+    assertFalse(NON_PUBLIC.isSupported(subClass2));
+    assertErrorOnInvoke(NON_PUBLIC, subClass2);
+  }
+
+  @Test
+  public void invokeOptional() throws Exception {
+    {
+      BaseClass base = new BaseClass();
+      assertEquals("string", STRING_METHOD_RETURNS_STRING.invokeOptional(base));
+      assertEquals("string", STRING_METHOD_RETURNS_ANY.invokeOptional(base));
+      assertNull(STRING_METHOD_RETURNS_INT.invokeOptional(base));
+      assertNull(VOID_METHOD_RETURNS_ANY.invokeOptional(base));
+      assertNull(VOID_METHOD_RETURNS_VOID.invokeOptional(base));
+      assertNull(SUBCLASS_METHOD_RETURNS_ANY.invokeOptional(base));
+      assertNull(SUBCLASS_METHOD_RETURNS_STRING.invokeOptional(base));
+      assertNull(SUBCLASS_METHOD_RETURNS_INT.invokeOptional(base));
+      assertNull(METHOD_WITH_ARGS_WRONG_PARAMS.invokeOptional(base));
+      assertNull(METHOD_WITH_ARGS_CORRECT_PARAMS.invokeOptional(base));
+    }
+    {
+      SubClass1 subClass1 = new SubClass1();
+      assertEquals("string", STRING_METHOD_RETURNS_STRING.invokeOptional(subClass1));
+      assertEquals("string", STRING_METHOD_RETURNS_ANY.invokeOptional(subClass1));
+      assertNull(STRING_METHOD_RETURNS_INT.invokeOptional(subClass1));
+      assertNull(VOID_METHOD_RETURNS_ANY.invokeOptional(subClass1));
+      assertNull(VOID_METHOD_RETURNS_VOID.invokeOptional(subClass1));
+      assertEquals("subclassMethod1", SUBCLASS_METHOD_RETURNS_ANY.invokeOptional(subClass1));
+      assertEquals("subclassMethod1", SUBCLASS_METHOD_RETURNS_STRING.invokeOptional(subClass1));
+      assertNull(SUBCLASS_METHOD_RETURNS_INT.invokeOptional(subClass1));
+      assertNull(METHOD_WITH_ARGS_WRONG_PARAMS.invokeOptional(subClass1));
+      assertEquals("arg", METHOD_WITH_ARGS_CORRECT_PARAMS.invokeOptional(subClass1, "arg"));
+    }
+
+    {
+      SubClass2 subClass2 = new SubClass2();
+      assertEquals("string", STRING_METHOD_RETURNS_STRING.invokeOptional(subClass2));
+      assertEquals("string", STRING_METHOD_RETURNS_ANY.invokeOptional(subClass2));
+      assertNull(STRING_METHOD_RETURNS_INT.invokeOptional(subClass2));
+      assertNull(VOID_METHOD_RETURNS_ANY.invokeOptional(subClass2));
+      assertNull(VOID_METHOD_RETURNS_VOID.invokeOptional(subClass2));
+      assertEquals(1234, SUBCLASS_METHOD_RETURNS_ANY.invokeOptional(subClass2));
+      assertNull(SUBCLASS_METHOD_RETURNS_STRING.invokeOptional(subClass2));
+      assertEquals(1234, SUBCLASS_METHOD_RETURNS_INT.invokeOptional(subClass2));
+      assertNull(METHOD_WITH_ARGS_WRONG_PARAMS.invokeOptional(subClass2));
+      assertEquals("arg", METHOD_WITH_ARGS_CORRECT_PARAMS.invokeOptional(subClass2, "arg"));
+    }
+  }
+
+  @Test
+  public void invokeOptionalBadArgs() throws Exception {
+    SubClass1 subClass1 = new SubClass1();
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1); // no args
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, 123);
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, true);
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, new Object());
+    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, "one", "two");
+  }
+
+  @Test
+  public void invokeOptionalWithException() throws Exception {
+    SubClass2 subClass2 = new SubClass2();
+    try {
+      THROWS_EXCEPTION.invokeOptional(subClass2);
+    } catch (InvocationTargetException expected) {
+      assertTrue(expected.getTargetException() instanceof IOException);
+    }
+
+    try {
+      THROWS_RUNTIME_EXCEPTION.invokeOptional(subClass2);
+    } catch (InvocationTargetException expected) {
+      assertTrue(expected.getTargetException() instanceof NumberFormatException);
+    }
+  }
+
+  @Test
+  public void invokeOptionalNonPublic() throws Exception {
+    SubClass2 subClass2 = new SubClass2();
+    assertFalse(NON_PUBLIC.isSupported(subClass2));
+    assertErrorOnInvokeOptional(NON_PUBLIC, subClass2);
+  }
+
+  private static <T> void assertErrorOnInvoke(
+      OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
+    try {
+      optionalMethod.invoke(base, args);
+      fail();
+    } catch (Error expected) {
+    }
+  }
+
+  private static <T> void assertIllegalArgumentExceptionOnInvoke(
+      OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
+    try {
+      optionalMethod.invoke(base, args);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  private static <T> void assertErrorOnInvokeOptional(
+      OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
+    try {
+      optionalMethod.invokeOptional(base, args);
+      fail();
+    } catch (Error expected) {
+    }
+  }
+
+  private static <T> void assertIllegalArgumentExceptionOnInvokeOptional(
+      OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
+    try {
+      optionalMethod.invokeOptional(base, args);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
similarity index 71%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
index 9eff91919a..292875bff6 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
@@ -24,7 +24,7 @@
   /** base64("username:password") */
   public static final String BASE_64_CREDENTIALS = "dXNlcm5hbWU6cGFzc3dvcmQ=";
 
-  public final List<String> calls = new ArrayList<String>();
+  public final List<String> calls = new ArrayList<>();
   public final PasswordAuthentication authentication;
 
   public RecordingAuthenticator(PasswordAuthentication authentication) {
@@ -36,23 +36,14 @@ public RecordingAuthenticator() {
   }
 
   @Override protected PasswordAuthentication getPasswordAuthentication() {
-    this.calls
-        .add("host="
-            + getRequestingHost()
-            + " port="
-            + getRequestingPort()
-            + " site="
-            + getRequestingSite()
-            + " url="
-            + getRequestingURL()
-            + " type="
-            + getRequestorType()
-            + " prompt="
-            + getRequestingPrompt()
-            + " protocol="
-            + getRequestingProtocol()
-            + " scheme="
-            + getRequestingScheme());
+    this.calls.add("host=" + getRequestingHost()
+        + " port=" + getRequestingPort()
+        + " site=" + getRequestingSite().getHostName()
+        + " url=" + getRequestingURL()
+        + " type=" + getRequestorType()
+        + " prompt=" + getRequestingPrompt()
+        + " protocol=" + getRequestingProtocol()
+        + " scheme=" + getRequestingScheme());
     return authentication;
   }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
similarity index 94%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
index b3e2369b79..c9d914f5f2 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
@@ -21,7 +21,7 @@
 import javax.net.ssl.SSLSession;
 
 public final class RecordingHostnameVerifier implements HostnameVerifier {
-  public final List<String> calls = new ArrayList<String>();
+  public final List<String> calls = new ArrayList<>();
 
   public boolean verify(String hostname, SSLSession session) {
     calls.add("verify " + hostname);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
new file mode 100644
index 0000000000..f5b3617d9d
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import com.squareup.okhttp.Authenticator;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.net.Proxy;
+import java.util.ArrayList;
+import java.util.List;
+
+public final class RecordingOkAuthenticator implements Authenticator {
+  public final List<Response> responses = new ArrayList<>();
+  public final List<Proxy> proxies = new ArrayList<>();
+  public final String credential;
+
+  public RecordingOkAuthenticator(String credential) {
+    this.credential = credential;
+  }
+
+  public Response onlyResponse() {
+    if (responses.size() != 1) throw new IllegalStateException();
+    return responses.get(0);
+  }
+
+  public Proxy onlyProxy() {
+    if (proxies.size() != 1) throw new IllegalStateException();
+    return proxies.get(0);
+  }
+
+  @Override public Request authenticate(Proxy proxy, Response response) {
+    responses.add(response);
+    proxies.add(proxy);
+    return response.request().newBuilder()
+        .addHeader("Authorization", credential)
+        .build();
+  }
+
+  @Override public Request authenticateProxy(Proxy proxy, Response response) {
+    responses.add(response);
+    proxies.add(proxy);
+    return response.request().newBuilder()
+        .addHeader("Proxy-Authorization", credential)
+        .build();
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/SingleInetAddressNetwork.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/SingleInetAddressNetwork.java
new file mode 100644
index 0000000000..beb48cb2e1
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/SingleInetAddressNetwork.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+
+/**
+ * A network that resolves only one IP address per host. Use this when testing
+ * route selection fallbacks to prevent the host machine's various IP addresses
+ * from interfering.
+ */
+public class SingleInetAddressNetwork implements Network {
+  @Override public InetAddress[] resolveInetAddresses(String host) throws UnknownHostException {
+    InetAddress[] allInetAddresses = Network.DEFAULT.resolveInetAddresses(host);
+    return new InetAddress[] { allInetAddresses[0] };
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
new file mode 100644
index 0000000000..a738cde082
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
@@ -0,0 +1,350 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.IOException;
+import java.net.CookieHandler;
+import java.net.CookieManager;
+import java.net.HttpCookie;
+import java.net.HttpURLConnection;
+import java.net.URI;
+import java.net.URLConnection;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/** Android's CookiesTest. */
+public class CookiesTest {
+
+  private OkHttpClient client;
+
+  @Before
+  public void setUp() throws Exception {
+    client = new OkHttpClient();
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    CookieHandler.setDefault(null);
+  }
+
+  @Test
+  public void testNetscapeResponse() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    CookieHandler.setDefault(cookieManager);
+    MockWebServer server = new MockWebServer();
+    server.play();
+
+    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
+        + "expires=Fri, 31-Dec-9999 23:59:59 GMT; "
+        + "path=/path; "
+        + "domain=" + server.getCookieDomain() + "; "
+        + "secure"));
+    get(server, "/path/foo");
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals(null, cookie.getComment());
+    assertEquals(null, cookie.getCommentURL());
+    assertEquals(false, cookie.getDiscard());
+    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
+    assertTrue(cookie.getMaxAge() > 100000000000L);
+    assertEquals("/path", cookie.getPath());
+    assertEquals(true, cookie.getSecure());
+    assertEquals(0, cookie.getVersion());
+  }
+
+  @Test public void testRfc2109Response() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    CookieHandler.setDefault(cookieManager);
+    MockWebServer server = new MockWebServer();
+    server.play();
+
+    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
+        + "Comment=this cookie is delicious; "
+        + "Domain=" + server.getCookieDomain() + "; "
+        + "Max-Age=60; "
+        + "Path=/path; "
+        + "Secure; "
+        + "Version=1"));
+    get(server, "/path/foo");
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals("this cookie is delicious", cookie.getComment());
+    assertEquals(null, cookie.getCommentURL());
+    assertEquals(false, cookie.getDiscard());
+    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
+    assertEquals(60, cookie.getMaxAge());
+    assertEquals("/path", cookie.getPath());
+    assertEquals(true, cookie.getSecure());
+    assertEquals(1, cookie.getVersion());
+  }
+
+  @Test public void testRfc2965Response() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    CookieHandler.setDefault(cookieManager);
+    MockWebServer server = new MockWebServer();
+    server.play();
+
+    server.enqueue(new MockResponse().addHeader("Set-Cookie2: a=android; "
+        + "Comment=this cookie is delicious; "
+        + "CommentURL=http://google.com/; "
+        + "Discard; "
+        + "Domain=" + server.getCookieDomain() + "; "
+        + "Max-Age=60; "
+        + "Path=/path; "
+        + "Port=\"80,443," + server.getPort() + "\"; "
+        + "Secure; "
+        + "Version=1"));
+    get(server, "/path/foo");
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals("this cookie is delicious", cookie.getComment());
+    assertEquals("http://google.com/", cookie.getCommentURL());
+    assertEquals(true, cookie.getDiscard());
+    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
+    assertEquals(60, cookie.getMaxAge());
+    assertEquals("/path", cookie.getPath());
+    assertEquals("80,443," + server.getPort(), cookie.getPortlist());
+    assertEquals(true, cookie.getSecure());
+    assertEquals(1, cookie.getVersion());
+  }
+
+  @Test public void testQuotedAttributeValues() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    CookieHandler.setDefault(cookieManager);
+    MockWebServer server = new MockWebServer();
+    server.play();
+
+    server.enqueue(new MockResponse().addHeader("Set-Cookie2: a=\"android\"; "
+        + "Comment=\"this cookie is delicious\"; "
+        + "CommentURL=\"http://google.com/\"; "
+        + "Discard; "
+        + "Domain=\"" + server.getCookieDomain() + "\"; "
+        + "Max-Age=\"60\"; "
+        + "Path=\"/path\"; "
+        + "Port=\"80,443," + server.getPort() + "\"; "
+        + "Secure; "
+        + "Version=\"1\""));
+    get(server, "/path/foo");
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals("this cookie is delicious", cookie.getComment());
+    assertEquals("http://google.com/", cookie.getCommentURL());
+    assertEquals(true, cookie.getDiscard());
+    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
+    assertEquals(60, cookie.getMaxAge());
+    assertEquals("/path", cookie.getPath());
+    assertEquals("80,443," + server.getPort(), cookie.getPortlist());
+    assertEquals(true, cookie.getSecure());
+    assertEquals(1, cookie.getVersion());
+  }
+
+  @Test public void testSendingCookiesFromStore() throws Exception {
+    MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse());
+    server.play();
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    HttpCookie cookieA = new HttpCookie("a", "android");
+    cookieA.setDomain(server.getCookieDomain());
+    cookieA.setPath("/");
+    cookieManager.getCookieStore().add(server.getUrl("/").toURI(), cookieA);
+    HttpCookie cookieB = new HttpCookie("b", "banana");
+    cookieB.setDomain(server.getCookieDomain());
+    cookieB.setPath("/");
+    cookieManager.getCookieStore().add(server.getUrl("/").toURI(), cookieB);
+    CookieHandler.setDefault(cookieManager);
+
+    get(server, "/");
+    RecordedRequest request = server.takeRequest();
+
+    List<String> receivedHeaders = request.getHeaders();
+    assertContains(receivedHeaders, "Cookie: $Version=\"1\"; "
+        + "a=\"android\";$Path=\"/\";$Domain=\"" + server.getCookieDomain() + "\"; "
+        + "b=\"banana\";$Path=\"/\";$Domain=\"" + server.getCookieDomain() + "\"");
+  }
+
+  @Test public void testRedirectsDoNotIncludeTooManyCookies() throws Exception {
+    MockWebServer redirectTarget = new MockWebServer();
+    redirectTarget.enqueue(new MockResponse().setBody("A"));
+    redirectTarget.play();
+
+    MockWebServer redirectSource = new MockWebServer();
+    redirectSource.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + redirectTarget.getUrl("/")));
+    redirectSource.play();
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    HttpCookie cookie = new HttpCookie("c", "cookie");
+    cookie.setDomain(redirectSource.getCookieDomain());
+    cookie.setPath("/");
+    String portList = Integer.toString(redirectSource.getPort());
+    cookie.setPortlist(portList);
+    cookieManager.getCookieStore().add(redirectSource.getUrl("/").toURI(), cookie);
+    CookieHandler.setDefault(cookieManager);
+
+    get(redirectSource, "/");
+    RecordedRequest request = redirectSource.takeRequest();
+
+    assertContains(request.getHeaders(), "Cookie: $Version=\"1\"; "
+        + "c=\"cookie\";$Path=\"/\";$Domain=\"" + redirectSource.getCookieDomain()
+        + "\";$Port=\"" + portList + "\"");
+
+    for (String header : redirectTarget.takeRequest().getHeaders()) {
+      if (header.startsWith("Cookie")) {
+        fail(header);
+      }
+    }
+  }
+
+  /**
+   * Test which headers show up where. The cookie manager should be notified
+   * of both user-specified and derived headers like {@code Host}. Headers
+   * named {@code Cookie} or {@code Cookie2} that are returned by the cookie
+   * manager should show up in the request and in {@code
+   * getRequestProperties}.
+   */
+  @Test public void testHeadersSentToCookieHandler() throws IOException, InterruptedException {
+    final Map<String, List<String>> cookieHandlerHeaders = new HashMap<>();
+    CookieHandler.setDefault(new CookieManager() {
+      @Override
+      public Map<String, List<String>> get(URI uri,
+          Map<String, List<String>> requestHeaders) throws IOException {
+        cookieHandlerHeaders.putAll(requestHeaders);
+        Map<String, List<String>> result = new HashMap<>();
+        result.put("Cookie", Collections.singletonList("Bar=bar"));
+        result.put("Cookie2", Collections.singletonList("Baz=baz"));
+        result.put("Quux", Collections.singletonList("quux"));
+        return result;
+      }
+    });
+    MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse());
+    server.play();
+
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    assertEquals(Collections.<String, List<String>>emptyMap(),
+        connection.getRequestProperties());
+
+    connection.setRequestProperty("Foo", "foo");
+    connection.setDoOutput(true);
+    connection.getOutputStream().write(5);
+    connection.getOutputStream().close();
+    connection.getInputStream().close();
+
+    RecordedRequest request = server.takeRequest();
+
+    assertContainsAll(cookieHandlerHeaders.keySet(), "Foo");
+    assertContainsAll(cookieHandlerHeaders.keySet(),
+        "Content-type", "User-Agent", "Connection", "Host");
+    assertFalse(cookieHandlerHeaders.containsKey("Cookie"));
+
+    /*
+     * The API specifies that calling getRequestProperties() on a connected instance should fail
+     * with an IllegalStateException, but the RI violates the spec and returns a valid map.
+     * http://www.mail-archive.com/net-dev@openjdk.java.net/msg01768.html
+     */
+    try {
+      assertContainsAll(connection.getRequestProperties().keySet(), "Foo");
+      assertContainsAll(connection.getRequestProperties().keySet(),
+          "Content-type", "Content-Length", "User-Agent", "Connection", "Host");
+      assertContainsAll(connection.getRequestProperties().keySet(), "Cookie", "Cookie2");
+      assertFalse(connection.getRequestProperties().containsKey("Quux"));
+    } catch (IllegalStateException expected) {
+    }
+
+    assertContainsAll(request.getHeaders(), "Foo: foo", "Cookie: Bar=bar", "Cookie2: Baz=baz");
+    assertFalse(request.getHeaders().contains("Quux: quux"));
+  }
+
+  @Test public void testCookiesSentIgnoresCase() throws Exception {
+    CookieHandler.setDefault(new CookieManager() {
+      @Override public Map<String, List<String>> get(URI uri,
+          Map<String, List<String>> requestHeaders) throws IOException {
+        Map<String, List<String>> result = new HashMap<>();
+        result.put("COOKIE", Collections.singletonList("Bar=bar"));
+        result.put("cooKIE2", Collections.singletonList("Baz=baz"));
+        return result;
+      }
+    });
+    MockWebServer server = new MockWebServer();
+    server. enqueue(new MockResponse());
+    server.play();
+
+    get(server, "/");
+
+    RecordedRequest request = server.takeRequest();
+    assertContainsAll(request.getHeaders(), "COOKIE: Bar=bar", "cooKIE2: Baz=baz");
+    assertFalse(request.getHeaders().contains("Quux: quux"));
+  }
+
+  private void assertContains(Collection<String> collection, String element) {
+    for (String c : collection) {
+      if (c != null && c.equalsIgnoreCase(element)) {
+        return;
+      }
+    }
+    fail("No " + element + " in " + collection);
+  }
+
+  private void assertContainsAll(Collection<String> collection, String... toFind) {
+    for (String s : toFind) {
+      assertContains(collection, s);
+    }
+  }
+
+  private Map<String,List<String>> get(MockWebServer server, String path) throws Exception {
+    URLConnection connection = new OkUrlFactory(client).open(server.getUrl(path));
+    Map<String, List<String>> headers = connection.getHeaderFields();
+    connection.getInputStream().close();
+    return headers;
+  }
+
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
new file mode 100644
index 0000000000..eee41bbd94
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.DelegatingServerSocketFactory;
+import com.squareup.okhttp.DelegatingSocketFactory;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+
+import static org.junit.Assert.fail;
+
+public final class DisconnectTest {
+
+  // The size of the socket buffers in bytes.
+  private static final int SOCKET_BUFFER_SIZE = 256 * 1024;
+
+  private MockWebServer server;
+  private OkHttpClient client;
+
+  @Before public void setUp() throws Exception {
+    server = new MockWebServer();
+    client = new OkHttpClient();
+
+    // Sockets on some platforms can have large buffers that mean writes do not block when
+    // required. These socket factories explicitly set the buffer sizes on sockets created.
+    server.setServerSocketFactory(
+        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
+          @Override
+          protected void configureServerSocket(ServerSocket serverSocket) throws IOException {
+            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+          }
+        });
+    client.setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+      @Override
+      protected void configureSocket(Socket socket) throws IOException {
+        socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+        socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+      }
+    });
+  }
+
+  @Test public void interruptWritingRequestBody() throws Exception {
+    int requestBodySize = 2 * 1024 * 1024; // 2 MiB
+
+    server.enqueue(new MockResponse()
+        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
+    server.play();
+
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    disconnectLater(connection, 500);
+
+    connection.setDoOutput(true);
+    connection.setFixedLengthStreamingMode(requestBodySize);
+    OutputStream requestBody = connection.getOutputStream();
+    byte[] buffer = new byte[1024];
+    try {
+      for (int i = 0; i < requestBodySize; i += buffer.length) {
+        requestBody.write(buffer);
+        requestBody.flush();
+      }
+      fail("Expected connection to be closed");
+    } catch (IOException expected) {
+    }
+
+    connection.disconnect();
+  }
+
+  @Test public void interruptReadingResponseBody() throws Exception {
+    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
+
+    server.enqueue(new MockResponse()
+        .setBody(new byte[responseBodySize])
+        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
+    server.play();
+
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    disconnectLater(connection, 500);
+
+    InputStream responseBody = connection.getInputStream();
+    byte[] buffer = new byte[1024];
+    try {
+      while (responseBody.read(buffer) != -1) {
+      }
+      fail("Expected connection to be closed");
+    } catch (IOException expected) {
+    }
+
+    connection.disconnect();
+  }
+
+  private void disconnectLater(final HttpURLConnection connection, final int delayMillis) {
+    Thread interruptingCow = new Thread() {
+      @Override public void run() {
+        try {
+          sleep(delayMillis);
+          connection.disconnect();
+        } catch (InterruptedException e) {
+          throw new RuntimeException(e);
+        }
+      }
+    };
+    interruptingCow.start();
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
new file mode 100644
index 0000000000..020c7f0e36
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.Util;
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.net.URL;
+import java.util.List;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLSession;
+
+import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
+
+public final class ExternalHttp2Example {
+  public static void main(String[] args) throws Exception {
+    URL url = new URL("https://twitter.com");
+    OkHttpClient client = new OkHttpClient()
+        .setProtocols(Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    HttpsURLConnection connection = (HttpsURLConnection) new OkUrlFactory(client)
+        .open(url);
+
+    connection.setHostnameVerifier(new HostnameVerifier() {
+      @Override public boolean verify(String s, SSLSession sslSession) {
+        System.out.println("VERIFYING " + s);
+        return true;
+      }
+    });
+
+    int responseCode = connection.getResponseCode();
+    System.out.println(responseCode);
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    // If null, probably you didn't add jetty's alpn jar to your boot classpath!
+    if (protocolValues != null && !protocolValues.isEmpty()) {
+      System.out.println("PROTOCOL " + protocolValues.get(0));
+    }
+
+    BufferedReader reader =
+        new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
+    String line;
+    while ((line = reader.readLine()) != null) {
+      System.out.println(line);
+    }
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
similarity index 68%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
index 11d7239050..a8009626c0 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
@@ -17,17 +17,26 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.Util;
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.net.URL;
+import java.util.List;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLSession;
 
+import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
+
 public final class ExternalSpdyExample {
   public static void main(String[] args) throws Exception {
     URL url = new URL("https://www.google.ca/");
-    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient().open(url);
+    OkHttpClient client = new OkHttpClient()
+        .setProtocols(Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1));
+    HttpsURLConnection connection = (HttpsURLConnection) new OkUrlFactory(client)
+        .open(url);
 
     connection.setHostnameVerifier(new HostnameVerifier() {
       @Override public boolean verify(String s, SSLSession sslSession) {
@@ -38,6 +47,11 @@ public static void main(String[] args) throws Exception {
 
     int responseCode = connection.getResponseCode();
     System.out.println(responseCode);
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    // If null, probably you didn't add jetty's alpn jar to your boot classpath!
+    if (protocolValues != null && !protocolValues.isEmpty()) {
+      System.out.println("PROTOCOL " + protocolValues.get(0));
+    }
 
     BufferedReader reader =
         new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
new file mode 100644
index 0000000000..eef731b0a4
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.spdy.Header;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Test;
+
+import static com.squareup.okhttp.TestUtil.headerEntries;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+
+public final class HeadersTest {
+  @Test public void parseNameValueBlock() throws IOException {
+    List<Header> headerBlock = headerEntries(
+        "cache-control", "no-cache, no-store",
+        "set-cookie", "Cookie1\u0000Cookie2",
+        ":status", "200 OK",
+        ":version", "HTTP/1.1");
+    Request request = new Request.Builder().url("http://square.com/").build();
+    Response response =
+        SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
+    Headers headers = response.headers();
+    assertEquals(4, headers.size());
+    assertEquals(Protocol.SPDY_3, response.protocol());
+    assertEquals(200, response.code());
+    assertEquals("OK", response.message());
+    assertEquals("no-cache, no-store", headers.get("cache-control"));
+    assertEquals("Cookie2", headers.get("set-cookie"));
+    assertEquals(Protocol.SPDY_3.toString(), headers.get(OkHeaders.SELECTED_PROTOCOL));
+    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(0));
+    assertEquals(Protocol.SPDY_3.toString(), headers.value(0));
+    assertEquals("cache-control", headers.name(1));
+    assertEquals("no-cache, no-store", headers.value(1));
+    assertEquals("set-cookie", headers.name(2));
+    assertEquals("Cookie1", headers.value(2));
+    assertEquals("set-cookie", headers.name(3));
+    assertEquals("Cookie2", headers.value(3));
+    assertNull(headers.get(":status"));
+    assertNull(headers.get(":version"));
+  }
+
+  @Test public void readNameValueBlockDropsForbiddenHeadersSpdy3() throws IOException {
+    List<Header> headerBlock = headerEntries(
+        ":status", "200 OK",
+        ":version", "HTTP/1.1",
+        "connection", "close");
+    Request request = new Request.Builder().url("http://square.com/").build();
+    Response response =
+        SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
+    Headers headers = response.headers();
+    assertEquals(1, headers.size());
+    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(0));
+    assertEquals(Protocol.SPDY_3.toString(), headers.value(0));
+  }
+
+  @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
+    List<Header> headerBlock = headerEntries(
+        ":status", "200 OK",
+        ":version", "HTTP/1.1",
+        "connection", "close");
+    Request request = new Request.Builder().url("http://square.com/").build();
+    Response response = SpdyTransport.readNameValueBlock(headerBlock, Protocol.HTTP_2)
+        .request(request).build();
+    Headers headers = response.headers();
+    assertEquals(1, headers.size());
+    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(0));
+    assertEquals(Protocol.HTTP_2.toString(), headers.value(0));
+  }
+
+  @Test public void toNameValueBlock() {
+    Request request = new Request.Builder()
+        .url("http://square.com/")
+        .header("cache-control", "no-cache, no-store")
+        .addHeader("set-cookie", "Cookie1")
+        .addHeader("set-cookie", "Cookie2")
+        .header(":status", "200 OK")
+        .build();
+    List<Header> headerBlock =
+        SpdyTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1");
+    List<Header> expected = headerEntries(
+        ":method", "GET",
+        ":path", "/",
+        ":version", "HTTP/1.1",
+        ":host", "square.com",
+        ":scheme", "http",
+        "cache-control", "no-cache, no-store",
+        "set-cookie", "Cookie1\u0000Cookie2",
+        ":status", "200 OK");
+    assertEquals(expected, headerBlock);
+  }
+
+  @Test public void toNameValueBlockDropsForbiddenHeadersSpdy3() {
+    Request request = new Request.Builder()
+        .url("http://square.com/")
+        .header("Connection", "close")
+        .header("Transfer-Encoding", "chunked")
+        .build();
+    List<Header> expected = headerEntries(
+        ":method", "GET",
+        ":path", "/",
+        ":version", "HTTP/1.1",
+        ":host", "square.com",
+        ":scheme", "http");
+    assertEquals(expected, SpdyTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1"));
+  }
+
+  @Test public void toNameValueBlockDropsForbiddenHeadersHttp2() {
+    Request request = new Request.Builder()
+        .url("http://square.com/")
+        .header("Connection", "upgrade")
+        .header("Upgrade", "websocket")
+        .build();
+    List<Header> expected = headerEntries(
+        ":method", "GET",
+        ":path", "/",
+        ":authority", "square.com",
+        ":scheme", "http");
+    assertEquals(expected,
+        SpdyTransport.writeNameValueBlock(request, Protocol.HTTP_2, "HTTP/1.1"));
+  }
+
+  @Test public void ofTrims() {
+    Headers headers = Headers.of("\t User-Agent \n", " \r OkHttp ");
+    assertEquals("User-Agent", headers.name(0));
+    assertEquals("OkHttp", headers.value(0));
+  }
+
+  @Test public void addParsing() {
+    Headers headers = new Headers.Builder()
+        .add("foo: bar")
+        .add(" foo: baz") // Name leading whitespace is trimmed.
+        .add("foo : bak") // Name trailing whitespace is trimmed.
+        .add("ping:  pong  ") // Value whitespace is trimmed.
+        .add("kit:kat") // Space after colon is not required.
+        .build();
+    assertEquals(Arrays.asList("bar", "baz", "bak"), headers.values("foo"));
+    assertEquals(Arrays.asList("pong"), headers.values("ping"));
+    assertEquals(Arrays.asList("kat"), headers.values("kit"));
+  }
+
+  @Test public void addThrowsOnEmptyName() {
+    try {
+      new Headers.Builder().add(": bar");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Headers.Builder().add(" : bar");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void addThrowsOnNoColon() {
+    try {
+      new Headers.Builder().add("foo bar");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void addThrowsOnMultiColon() {
+    try {
+      new Headers.Builder().add(":status: 200 OK");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofThrowsOddNumberOfHeaders() {
+    try {
+      Headers.of("User-Agent", "OkHttp", "Content-Length");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofThrowsOnNull() {
+    try {
+      Headers.of("User-Agent", null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofThrowsOnEmptyName() {
+    try {
+      Headers.of("", "OkHttp");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofAcceptsEmptyValue() {
+    Headers headers = Headers.of("User-Agent", "");
+    assertEquals("", headers.value(0));
+  }
+
+  @Test public void ofMakesDefensiveCopy() {
+    String[] namesAndValues = {
+        "User-Agent",
+        "OkHttp"
+    };
+    Headers headers = Headers.of(namesAndValues);
+    namesAndValues[1] = "Chrome";
+    assertEquals("OkHttp", headers.value(0));
+  }
+
+  @Test public void ofRejectsNulChar() {
+    try {
+      Headers.of("User-Agent", "Square\u0000OkHttp");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpDateTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpDateTest.java
new file mode 100644
index 0000000000..2181774f43
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpDateTest.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Date;
+import java.util.TimeZone;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+public class HttpDateTest {
+
+  private TimeZone originalDefault;
+
+  @Before
+  public void setUp() throws Exception {
+    originalDefault = TimeZone.getDefault();
+    // The default timezone should affect none of these tests: HTTP specified GMT, so we set it to
+    // something else.
+    TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles"));
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    TimeZone.setDefault(originalDefault);
+  }
+
+  @Test public void parseStandardFormats() throws Exception {
+    // RFC 822, updated by RFC 1123 with GMT.
+    assertEquals(0L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT").getTime());
+    assertEquals(1402057830000L, HttpDate.parse("Fri, 06 Jun 2014 12:30:30 GMT").getTime());
+
+    // RFC 850, obsoleted by RFC 1036 with GMT.
+    assertEquals(0L, HttpDate.parse("Thursday, 01-Jan-70 00:00:00 GMT").getTime());
+    assertEquals(1402057830000L, HttpDate.parse("Friday, 06-Jun-14 12:30:30 GMT").getTime());
+
+    // ANSI C's asctime(): should use GMT, not platform default.
+    assertEquals(0L, HttpDate.parse("Thu Jan 1 00:00:00 1970").getTime());
+    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014").getTime());
+  }
+
+  @Test public void format() throws Exception {
+    assertEquals("Thu, 01 Jan 1970 00:00:00 GMT", HttpDate.format(new Date(0)));
+    assertEquals("Fri, 06 Jun 2014 12:30:30 GMT", HttpDate.format(new Date(1402057830000L)));
+  }
+
+  @Test public void parseNonStandardStrings() throws Exception {
+    // RFC 822, updated by RFC 1123 with any TZ
+    assertEquals(3600000L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT-01:00").getTime());
+    assertEquals(28800000L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 PST").getTime());
+    // Ignore trailing junk
+    assertEquals(0L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT JUNK").getTime());
+    // Missing timezones treated as bad.
+    assertNull(HttpDate.parse("Thu, 01 Jan 1970 00:00:00"));
+    // Missing seconds treated as bad.
+    assertNull(HttpDate.parse("Thu, 01 Jan 1970 00:00 GMT"));
+    // Extra spaces treated as bad.
+    assertNull(HttpDate.parse("Thu,  01 Jan 1970 00:00 GMT"));
+    // Missing leading zero treated as bad.
+    assertNull(HttpDate.parse("Thu, 1 Jan 1970 00:00 GMT"));
+
+    // RFC 850, obsoleted by RFC 1036 with any TZ.
+    assertEquals(3600000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 GMT-01:00").getTime());
+    assertEquals(28800000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST").getTime());
+    // Ignore trailing junk
+    assertEquals(28800000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST JUNK").getTime());
+
+    // ANSI C's asctime() format
+    // This format ignores the timezone entirely even if it is present and uses GMT.
+    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014 PST").getTime());
+    // Ignore trailing junk.
+    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014 JUNK").getTime());
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft16Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft16Test.java
new file mode 100644
index 0000000000..6ebe415f82
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft16Test.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.PushPromise;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.util.Arrays;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class HttpOverHttp20Draft16Test extends HttpOverSpdyTest {
+
+  public HttpOverHttp20Draft16Test() {
+    super(Protocol.HTTP_2);
+    this.hostHeader = ":authority";
+  }
+
+  @Test public void serverSendsPushPromise_GET() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet")
+        .withPush(new PushPromise("GET", "/foo/bar", Arrays.asList("foo: bar"),
+            new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet")));
+    server.enqueue(response);
+    server.play();
+
+    connection = client.open(server.getUrl("/foo"));
+    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Sweet", connection.getResponseMessage());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertContains(request.getHeaders(), ":scheme: https");
+    assertContains(request.getHeaders(), hostHeader + ": "
+        + server.getHostName() + ":" + server.getPort());
+
+    RecordedRequest pushedRequest = server.takeRequest();
+    assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
+    assertEquals(Arrays.asList("foo: bar"), pushedRequest.getHeaders());
+  }
+
+  @Test public void serverSendsPushPromise_HEAD() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet")
+        .withPush(new PushPromise("HEAD", "/foo/bar", Arrays.asList("foo: bar"),
+            new MockResponse().setStatus("HTTP/1.1 204 Sweet")));
+    server.enqueue(response);
+    server.play();
+
+    connection = client.open(server.getUrl("/foo"));
+    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Sweet", connection.getResponseMessage());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertContains(request.getHeaders(), ":scheme: https");
+    assertContains(request.getHeaders(), hostHeader + ": "
+        + server.getHostName() + ":" + server.getPort());
+
+    RecordedRequest pushedRequest = server.takeRequest();
+    assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
+    assertEquals(Arrays.asList("foo: bar"), pushedRequest.getHeaders());
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
new file mode 100644
index 0000000000..4020bf4c25
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Protocol;
+
+public class HttpOverSpdy3Test extends HttpOverSpdyTest {
+
+  public HttpOverSpdy3Test() {
+    super(Protocol.SPDY_3);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
new file mode 100644
index 0000000000..670361c603
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -0,0 +1,507 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Cache;
+import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.RecordingAuthenticator;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.SocketPolicy;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.Authenticator;
+import java.net.CookieManager;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/** Test how SPDY interacts with HTTP features. */
+public abstract class HttpOverSpdyTest {
+
+  /** Protocol to test, for example {@link com.squareup.okhttp.Protocol#SPDY_3} */
+  private final Protocol protocol;
+  protected String hostHeader = ":host";
+
+  protected HttpOverSpdyTest(Protocol protocol){
+    this.protocol = protocol;
+  }
+
+  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
+    public boolean verify(String hostname, SSLSession session) {
+      return true;
+    }
+  };
+
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+  protected final MockWebServer server = new MockWebServer();
+  protected final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
+  protected HttpURLConnection connection;
+  protected Cache cache;
+
+  @Before public void setUp() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    String systemTmpDir = System.getProperty("java.io.tmpdir");
+    File cacheDir = new File(systemTmpDir, "HttpCache-" + protocol + "-" + UUID.randomUUID());
+    cache = new Cache(cacheDir, Integer.MAX_VALUE);
+  }
+
+  @After public void tearDown() throws Exception {
+    Authenticator.setDefault(null);
+    server.shutdown();
+  }
+
+  @Test public void get() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet");
+    server.enqueue(response);
+    server.play();
+
+    connection = client.open(server.getUrl("/foo"));
+    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Sweet", connection.getResponseMessage());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertContains(request.getHeaders(), ":scheme: https");
+    assertContains(request.getHeaders(), hostHeader + ": "
+        + server.getHostName() + ":" + server.getPort());
+  }
+
+  @Test public void emptyResponse() throws IOException {
+    server.enqueue(new MockResponse());
+    server.play();
+
+    connection = client.open(server.getUrl("/foo"));
+    assertEquals(-1, connection.getInputStream().read());
+  }
+
+  byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+
+  @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDE");
+    server.enqueue(response);
+    server.play();
+
+    connection = client.open(server.getUrl("/foo"));
+    connection.setDoOutput(true);
+    connection.setChunkedStreamingMode(0);
+    connection.getOutputStream().write(postBytes);
+    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody());
+    assertNull(request.getHeader("Content-Length"));
+  }
+
+  @Test public void userSuppliedContentLengthHeader() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDE");
+    server.enqueue(response);
+    server.play();
+
+    connection = client.open(server.getUrl("/foo"));
+    connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
+    connection.setDoOutput(true);
+    connection.getOutputStream().write(postBytes);
+    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody());
+    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+  }
+
+  @Test public void closeAfterFlush() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDE");
+    server.enqueue(response);
+    server.play();
+
+    connection = client.open(server.getUrl("/foo"));
+    connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
+    connection.setDoOutput(true);
+    connection.getOutputStream().write(postBytes); // push bytes into SpdyDataOutputStream.buffer
+    connection.getOutputStream().flush(); // SpdyConnection.writeData subject to write window
+    connection.getOutputStream().close(); // SpdyConnection.writeData empty frame
+    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody());
+    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+  }
+
+  @Test public void setFixedLengthStreamingModeSetsContentLength() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDE");
+    server.enqueue(response);
+    server.play();
+
+    connection = client.open(server.getUrl("/foo"));
+    connection.setFixedLengthStreamingMode(postBytes.length);
+    connection.setDoOutput(true);
+    connection.getOutputStream().write(postBytes);
+    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody());
+    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+  }
+
+  @Test public void spdyConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABCDEF"));
+    server.enqueue(new MockResponse().setBody("GHIJKL"));
+    server.play();
+
+    HttpURLConnection connection1 = client.open(server.getUrl("/r1"));
+    HttpURLConnection connection2 = client.open(server.getUrl("/r2"));
+    assertEquals("ABC", readAscii(connection1.getInputStream(), 3));
+    assertEquals("GHI", readAscii(connection2.getInputStream(), 3));
+    assertEquals("DEF", readAscii(connection1.getInputStream(), 3));
+    assertEquals("JKL", readAscii(connection2.getInputStream(), 3));
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test @Ignore public void synchronousSpdyRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+
+    ExecutorService executor = Executors.newCachedThreadPool();
+    CountDownLatch countDownLatch = new CountDownLatch(2);
+    executor.execute(new SpdyRequest("/r1", countDownLatch));
+    executor.execute(new SpdyRequest("/r2", countDownLatch));
+    countDownLatch.await();
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void gzippedResponseBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("ABCABCABC")));
+    server.play();
+    assertContent("ABCABCABC", client.open(server.getUrl("/r1")), Integer.MAX_VALUE);
+  }
+
+  @Test public void authenticate() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
+        .addHeader("www-authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate."));
+    server.enqueue(new MockResponse().setBody("Successful auth!"));
+    server.play();
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    connection = client.open(server.getUrl("/"));
+    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    RecordedRequest denied = server.takeRequest();
+    assertContainsNoneMatching(denied.getHeaders(), "authorization: Basic .*");
+    RecordedRequest accepted = server.takeRequest();
+    assertEquals("GET / HTTP/1.1", accepted.getRequestLine());
+    assertContains(accepted.getHeaders(),
+        "authorization: Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS);
+  }
+
+  @Test public void redirect() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse().setBody("This is the new location!"));
+    server.play();
+
+    connection = client.open(server.getUrl("/"));
+    assertContent("This is the new location!", connection, Integer.MAX_VALUE);
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("/", request1.getPath());
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("/foo", request2.getPath());
+  }
+
+  @Test public void readAfterLastByte() throws Exception {
+    server.enqueue(new MockResponse().setBody("ABC"));
+    server.play();
+
+    connection = client.open(server.getUrl("/"));
+    InputStream in = connection.getInputStream();
+    assertEquals("ABC", readAscii(in, 3));
+    assertEquals(-1, in.read());
+    assertEquals(-1, in.read());
+  }
+
+  @Ignore // See https://github.com/square/okhttp/issues/578
+  @Test(timeout = 3000) public void readResponseHeaderTimeout() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+
+    connection = client.open(server.getUrl("/"));
+    connection.setReadTimeout(1000);
+    assertContent("A", connection, Integer.MAX_VALUE);
+  }
+
+  /**
+   * Test to ensure we don't  throw a read timeout on responses that are
+   * progressing.  For this case, we take a 4KiB body and throttle it to
+   * 1KiB/second.  We set the read timeout to two seconds.  If our
+   * implementation is acting correctly, it will not throw, as it is
+   * progressing.
+   */
+  @Test public void readTimeoutMoreGranularThanBodySize() throws Exception {
+    char[] body = new char[4096]; // 4KiB to read
+    Arrays.fill(body, 'y');
+    server.enqueue(new MockResponse()
+        .setBody(new String(body))
+        .throttleBody(1024, 1, SECONDS)); // slow connection 1KiB/second
+    server.play();
+
+    connection = client.open(server.getUrl("/"));
+    connection.setReadTimeout(2000); // 2 seconds to read something.
+    assertContent(new String(body), connection, Integer.MAX_VALUE);
+  }
+
+  /**
+   * Test to ensure we throw a read timeout on responses that are progressing
+   * too slowly.  For this case, we take a 2KiB body and throttle it to
+   * 1KiB/second.  We set the read timeout to half a second.  If our
+   * implementation is acting correctly, it will throw, as a byte doesn't
+   * arrive in time.
+   */
+  @Test public void readTimeoutOnSlowConnection() throws Exception {
+    char[] body = new char[2048]; // 2KiB to read
+    Arrays.fill(body, 'y');
+    server.enqueue(new MockResponse()
+        .setBody(new String(body))
+        .throttleBody(1024, 1, SECONDS)); // slow connection 1KiB/second
+    server.play();
+
+    connection = client.open(server.getUrl("/"));
+    connection.setReadTimeout(500); // half a second to read something
+    connection.connect();
+    try {
+      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
+      fail("Should have timed out!");
+    } catch (IOException e){
+      assertEquals("timeout", e.getMessage());
+    }
+  }
+
+  @Test public void spdyConnectionTimeout() throws Exception {
+    MockResponse response = new MockResponse().setBody("A");
+    response.setBodyDelayTimeMs(1000);
+    server.enqueue(response);
+    server.play();
+
+    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    connection1.setReadTimeout(2000);
+    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    connection2.setReadTimeout(200);
+    connection1.connect();
+    connection2.connect();
+    assertContent("A", connection1, Integer.MAX_VALUE);
+  }
+
+  @Test public void responsesAreCached() throws IOException {
+    client.client().setCache(cache);
+
+    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("A"));
+    server.play();
+
+    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
+    assertEquals(1, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
+    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
+    assertEquals(3, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(2, cache.getHitCount());
+  }
+
+  @Test public void conditionalCache() throws IOException {
+    client.client().setCache(cache);
+
+    server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
+    assertEquals(1, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
+    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(2, cache.getNetworkCount());
+    assertEquals(1, cache.getHitCount());
+  }
+
+  @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
+    client.client().setCache(cache);
+
+    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("ABCD"));
+    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("EFGH"));
+    server.play();
+
+    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    InputStream in1 = connection1.getInputStream();
+    assertEquals("AB", readAscii(in1, 2));
+    in1.close();
+
+    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    InputStream in2 = connection2.getInputStream();
+    assertEquals("ABCD", readAscii(in2, Integer.MAX_VALUE));
+    in2.close();
+  }
+
+  @Test public void acceptAndTransmitCookies() throws Exception {
+    CookieManager cookieManager = new CookieManager();
+    client.client().setCookieHandler(cookieManager);
+    server.play();
+    server.enqueue(new MockResponse()
+        .addHeader("set-cookie: c=oreo; domain=" + server.getCookieDomain())
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    URL url = server.getUrl("/");
+    assertContent("A", client.open(url), Integer.MAX_VALUE);
+    Map<String, List<String>> requestHeaders = Collections.emptyMap();
+    assertEquals(Collections.singletonMap("Cookie", Arrays.asList("c=oreo")),
+        cookieManager.get(url.toURI(), requestHeaders));
+
+    assertContent("B", client.open(url), Integer.MAX_VALUE);
+    RecordedRequest requestA = server.takeRequest();
+    assertContainsNoneMatching(requestA.getHeaders(), "Cookie.*");
+    RecordedRequest requestB = server.takeRequest();
+    assertContains(requestB.getHeaders(), "cookie: c=oreo");
+  }
+
+  /** https://github.com/square/okhttp/issues/1191 */
+  @Test public void disconnectWithStreamNotEstablished() throws Exception {
+    ConnectionPool connectionPool = new ConnectionPool(5, 5000);
+    client.client().setConnectionPool(connectionPool);
+
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    // Disconnect before the stream is created. A connection is still established!
+    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    connection1.connect();
+    connection1.disconnect();
+
+    // That connection is pooled, and it works.
+    assertEquals(1, connectionPool.getSpdyConnectionCount());
+    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    assertContent("abc", connection2, 3);
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  <T> void assertContains(Collection<T> collection, T value) {
+    assertTrue(collection.toString(), collection.contains(value));
+  }
+
+  void assertContent(String expected, HttpURLConnection connection, int limit)
+      throws IOException {
+    connection.connect();
+    assertEquals(expected, readAscii(connection.getInputStream(), limit));
+  }
+
+  private void assertContainsNoneMatching(List<String> headers, String pattern) {
+    for (String header : headers) {
+      if (header.matches(pattern)) {
+        fail("Header " + header + " matches " + pattern);
+      }
+    }
+  }
+
+  private String readAscii(InputStream in, int count) throws IOException {
+    StringBuilder result = new StringBuilder();
+    for (int i = 0; i < count; i++) {
+      int value = in.read();
+      if (value == -1) {
+        in.close();
+        break;
+      }
+      result.append((char) value);
+    }
+    return result.toString();
+  }
+
+  public Buffer gzip(String bytes) throws IOException {
+    Buffer bytesOut = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
+    sink.writeUtf8(bytes);
+    sink.close();
+    return bytesOut;
+  }
+
+  class SpdyRequest implements Runnable {
+    String path;
+    CountDownLatch countDownLatch;
+    public SpdyRequest(String path, CountDownLatch countDownLatch) {
+      this.path = path;
+      this.countDownLatch = countDownLatch;
+    }
+
+    @Override public void run() {
+      try {
+        HttpURLConnection conn = client.open(server.getUrl(path));
+        assertEquals("A", readAscii(conn.getInputStream(), 1));
+        countDownLatch.countDown();
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RecordingProxySelector.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RecordingProxySelector.java
new file mode 100644
index 0000000000..ed9cfa4ba9
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RecordingProxySelector.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+public final class RecordingProxySelector extends ProxySelector {
+  final List<URI> requestedUris = new ArrayList<>();
+  List<Proxy> proxies = new ArrayList<>();
+  final List<String> failures = new ArrayList<>();
+
+  @Override public List<Proxy> select(URI uri) {
+    requestedUris.add(uri);
+    return proxies;
+  }
+
+  public void assertRequests(URI... expectedUris) {
+    assertEquals(Arrays.asList(expectedUris), requestedUris);
+    requestedUris.clear();
+  }
+
+  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
+    InetSocketAddress socketAddress = (InetSocketAddress) sa;
+    failures.add(
+        String.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
+            ioe.getMessage()));
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
new file mode 100644
index 0000000000..f69b10db04
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
@@ -0,0 +1,465 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Address;
+import com.squareup.okhttp.Authenticator;
+import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.ConnectionSpec;
+import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.Network;
+import com.squareup.okhttp.internal.RouteDatabase;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.NoSuchElementException;
+import javax.net.SocketFactory;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLSocketFactory;
+import org.junit.Before;
+import org.junit.Test;
+
+import static java.net.Proxy.NO_PROXY;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class RouteSelectorTest {
+  public final List<ConnectionSpec> connectionSpecs = Util.immutableList(
+      ConnectionSpec.MODERN_TLS,
+      ConnectionSpec.COMPATIBLE_TLS,
+      ConnectionSpec.CLEARTEXT);
+
+  private static final int proxyAPort = 1001;
+  private static final String proxyAHost = "proxyA";
+  private static final Proxy proxyA =
+      new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyAHost, proxyAPort));
+  private static final int proxyBPort = 1002;
+  private static final String proxyBHost = "proxyB";
+  private static final Proxy proxyB =
+      new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyBHost, proxyBPort));
+  private String uriHost = "hostA";
+  private int uriPort = 1003;
+
+  private SocketFactory socketFactory;
+  private final SSLContext sslContext = SslContextBuilder.localhost();
+  private final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+  private HostnameVerifier hostnameVerifier;
+
+  private final Authenticator authenticator = AuthenticatorAdapter.INSTANCE;
+  private final List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
+  private final FakeDns dns = new FakeDns();
+  private final RecordingProxySelector proxySelector = new RecordingProxySelector();
+  private OkHttpClient client;
+  private RouteDatabase routeDatabase;
+  private Request httpRequest;
+  private Request httpsRequest;
+
+  @Before public void setUp() throws Exception {
+    socketFactory = SocketFactory.getDefault();
+    hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
+
+    client = new OkHttpClient()
+        .setAuthenticator(authenticator)
+        .setProxySelector(proxySelector)
+        .setSocketFactory(socketFactory)
+        .setSslSocketFactory(sslSocketFactory)
+        .setHostnameVerifier(hostnameVerifier)
+        .setProtocols(protocols)
+        .setConnectionSpecs(connectionSpecs)
+        .setConnectionPool(ConnectionPool.getDefault());
+    Internal.instance.setNetwork(client, dns);
+
+    routeDatabase = Internal.instance.routeDatabase(client);
+
+    httpRequest = new Request.Builder()
+        .url("http://" + uriHost + ":" + uriPort + "/path")
+        .build();
+    httpsRequest = new Request.Builder()
+        .url("https://" + uriHost + ":" + uriPort + "/path")
+        .build();
+  }
+
+  @Test public void singleRoute() throws Exception {
+    Address address = httpAddress();
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+
+    assertTrue(routeSelector.hasNext());
+    dns.inetAddresses = makeFakeAddresses(255, 1);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, ConnectionSpec.CLEARTEXT);
+    dns.assertRequests(uriHost);
+
+    assertFalse(routeSelector.hasNext());
+    try {
+      routeSelector.nextUnconnected();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+  }
+
+  @Test public void singleRouteReturnsFailedRoute() throws Exception {
+    Address address = httpAddress();
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+
+    assertTrue(routeSelector.hasNext());
+    dns.inetAddresses = makeFakeAddresses(255, 1);
+    Connection connection = routeSelector.nextUnconnected();
+    routeDatabase.failed(connection.getRoute());
+    routeSelector = RouteSelector.get(httpRequest, client);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, ConnectionSpec.CLEARTEXT);
+    assertFalse(routeSelector.hasNext());
+    try {
+      routeSelector.nextUnconnected();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+  }
+
+  @Test public void explicitProxyTriesThatProxysAddressesOnly() throws Exception {
+    Address address = new Address(uriHost, uriPort, socketFactory, null, null, null, authenticator,
+        proxyA, protocols, connectionSpecs, proxySelector);
+    client.setProxy(proxyA);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+
+    assertTrue(routeSelector.hasNext());
+    dns.inetAddresses = makeFakeAddresses(255, 2);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0],
+        proxyAPort, ConnectionSpec.CLEARTEXT);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[1],
+        proxyAPort, ConnectionSpec.CLEARTEXT);
+
+    assertFalse(routeSelector.hasNext());
+    dns.assertRequests(proxyAHost);
+    proxySelector.assertRequests(); // No proxy selector requests!
+  }
+
+  @Test public void explicitDirectProxy() throws Exception {
+    Address address = new Address(uriHost, uriPort, socketFactory, null, null, null, authenticator,
+        NO_PROXY, protocols, connectionSpecs, proxySelector);
+    client.setProxy(NO_PROXY);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+
+    assertTrue(routeSelector.hasNext());
+    dns.inetAddresses = makeFakeAddresses(255, 2);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, ConnectionSpec.CLEARTEXT);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[1],
+        uriPort, ConnectionSpec.CLEARTEXT);
+
+    assertFalse(routeSelector.hasNext());
+    dns.assertRequests(uriHost);
+    proxySelector.assertRequests(); // No proxy selector requests!
+  }
+
+  @Test public void proxySelectorReturnsNull() throws Exception {
+    Address address = httpAddress();
+
+    proxySelector.proxies = null;
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    proxySelector.assertRequests(httpRequest.uri());
+
+    assertTrue(routeSelector.hasNext());
+    dns.inetAddresses = makeFakeAddresses(255, 1);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, ConnectionSpec.CLEARTEXT);
+    dns.assertRequests(uriHost);
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void proxySelectorReturnsNoProxies() throws Exception {
+    Address address = httpAddress();
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+
+    assertTrue(routeSelector.hasNext());
+    dns.inetAddresses = makeFakeAddresses(255, 2);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, ConnectionSpec.CLEARTEXT);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[1],
+        uriPort, ConnectionSpec.CLEARTEXT);
+
+    assertFalse(routeSelector.hasNext());
+    dns.assertRequests(uriHost);
+    proxySelector.assertRequests(httpRequest.uri());
+  }
+
+  @Test public void proxySelectorReturnsMultipleProxies() throws Exception {
+    Address address = httpAddress();
+
+    proxySelector.proxies.add(proxyA);
+    proxySelector.proxies.add(proxyB);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    proxySelector.assertRequests(httpRequest.uri());
+
+    // First try the IP addresses of the first proxy, in sequence.
+    assertTrue(routeSelector.hasNext());
+    dns.inetAddresses = makeFakeAddresses(255, 2);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0], proxyAPort,
+        ConnectionSpec.CLEARTEXT);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[1], proxyAPort,
+        ConnectionSpec.CLEARTEXT);
+    dns.assertRequests(proxyAHost);
+
+    // Next try the IP address of the second proxy.
+    assertTrue(routeSelector.hasNext());
+    dns.inetAddresses = makeFakeAddresses(254, 1);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[0], proxyBPort,
+        ConnectionSpec.CLEARTEXT);
+    dns.assertRequests(proxyBHost);
+
+    // Finally try the only IP address of the origin server.
+    assertTrue(routeSelector.hasNext());
+    dns.inetAddresses = makeFakeAddresses(253, 1);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
+        ConnectionSpec.CLEARTEXT);
+    dns.assertRequests(uriHost);
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void proxySelectorDirectConnectionsAreSkipped() throws Exception {
+    Address address = httpAddress();
+
+    proxySelector.proxies.add(NO_PROXY);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    proxySelector.assertRequests(httpRequest.uri());
+
+    // Only the origin server will be attempted.
+    assertTrue(routeSelector.hasNext());
+    dns.inetAddresses = makeFakeAddresses(255, 1);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
+        ConnectionSpec.CLEARTEXT);
+    dns.assertRequests(uriHost);
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void proxyDnsFailureContinuesToNextProxy() throws Exception {
+    Address address = httpAddress();
+
+    proxySelector.proxies.add(proxyA);
+    proxySelector.proxies.add(proxyB);
+    proxySelector.proxies.add(proxyA);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    proxySelector.assertRequests(httpRequest.uri());
+
+    assertTrue(routeSelector.hasNext());
+    dns.inetAddresses = makeFakeAddresses(255, 1);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0],
+        proxyAPort, ConnectionSpec.CLEARTEXT);
+    dns.assertRequests(proxyAHost);
+
+    assertTrue(routeSelector.hasNext());
+    dns.inetAddresses = null;
+    try {
+      routeSelector.nextUnconnected();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+    dns.assertRequests(proxyBHost);
+
+    assertTrue(routeSelector.hasNext());
+    dns.inetAddresses = makeFakeAddresses(255, 1);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0],
+        proxyAPort, ConnectionSpec.CLEARTEXT);
+    dns.assertRequests(proxyAHost);
+
+    assertTrue(routeSelector.hasNext());
+    dns.inetAddresses = makeFakeAddresses(254, 1);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, ConnectionSpec.CLEARTEXT);
+    dns.assertRequests(uriHost);
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  // https://github.com/square/okhttp/issues/442
+  @Test public void nonSslErrorAddsAllTlsModesToFailedRoute() throws Exception {
+    client.setProxy(Proxy.NO_PROXY);
+    RouteSelector routeSelector = RouteSelector.get(httpsRequest, client);
+
+    dns.inetAddresses = makeFakeAddresses(255, 1);
+    Connection connection = routeSelector.nextUnconnected();
+    routeSelector.connectFailed(connection, new IOException("Non SSL exception"));
+    assertEquals(2, routeDatabase.failedRoutesCount());
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void sslErrorAddsOnlyFailedConfigurationToFailedRoute() throws Exception {
+    client.setProxy(Proxy.NO_PROXY);
+    RouteSelector routeSelector = RouteSelector.get(httpsRequest, client);
+
+    dns.inetAddresses = makeFakeAddresses(255, 1);
+    Connection connection = routeSelector.nextUnconnected();
+    routeSelector.connectFailed(connection, new SSLHandshakeException("SSL exception"));
+    assertTrue(routeDatabase.failedRoutesCount() == 1);
+    assertTrue(routeSelector.hasNext());
+  }
+
+  @Test public void multipleProxiesMultipleInetAddressesMultipleConfigurations() throws Exception {
+    Address address = new Address(uriHost, uriPort, socketFactory, sslSocketFactory,
+        hostnameVerifier, null, authenticator, null, protocols, connectionSpecs, proxySelector);
+    proxySelector.proxies.add(proxyA);
+    proxySelector.proxies.add(proxyB);
+    RouteSelector routeSelector = RouteSelector.get(httpsRequest, client);
+
+    // Proxy A
+    dns.inetAddresses = makeFakeAddresses(255, 2);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0],
+        proxyAPort, ConnectionSpec.MODERN_TLS);
+    dns.assertRequests(proxyAHost);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0],
+        proxyAPort, ConnectionSpec.COMPATIBLE_TLS);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[1],
+        proxyAPort, ConnectionSpec.MODERN_TLS);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[1],
+        proxyAPort, ConnectionSpec.COMPATIBLE_TLS);
+
+    // Proxy B
+    dns.inetAddresses = makeFakeAddresses(254, 2);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[0],
+        proxyBPort, ConnectionSpec.MODERN_TLS);
+    dns.assertRequests(proxyBHost);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[0],
+        proxyBPort, ConnectionSpec.COMPATIBLE_TLS);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[1],
+        proxyBPort, ConnectionSpec.MODERN_TLS);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[1],
+        proxyBPort, ConnectionSpec.COMPATIBLE_TLS);
+
+    // Origin
+    dns.inetAddresses = makeFakeAddresses(253, 2);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, ConnectionSpec.MODERN_TLS);
+    dns.assertRequests(uriHost);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, ConnectionSpec.COMPATIBLE_TLS);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[1],
+        uriPort, ConnectionSpec.MODERN_TLS);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[1],
+        uriPort, ConnectionSpec.COMPATIBLE_TLS);
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void failedRoutesAreLast() throws Exception {
+    client.setProxy(Proxy.NO_PROXY);
+    RouteSelector routeSelector = RouteSelector.get(httpsRequest, client);
+
+    dns.inetAddresses = makeFakeAddresses(255, 1);
+
+    // Extract the regular sequence of routes from selector.
+    List<Connection> regularRoutes = new ArrayList<>();
+    while (routeSelector.hasNext()) {
+      regularRoutes.add(routeSelector.nextUnconnected());
+    }
+
+    // Check that we do indeed have more than one route.
+    assertTrue(regularRoutes.size() > 1);
+    // Add first regular route as failed.
+    routeDatabase.failed(regularRoutes.get(0).getRoute());
+    // Reset selector
+    routeSelector = RouteSelector.get(httpsRequest, client);
+
+    List<Connection> routesWithFailedRoute = new ArrayList<>();
+    while (routeSelector.hasNext()) {
+      routesWithFailedRoute.add(routeSelector.nextUnconnected());
+    }
+
+    assertEquals(regularRoutes.get(0).getRoute(),
+        routesWithFailedRoute.get(routesWithFailedRoute.size() - 1).getRoute());
+    assertEquals(regularRoutes.size(), routesWithFailedRoute.size());
+  }
+
+  @Test public void getHostString() throws Exception {
+    // Name proxy specification.
+    InetSocketAddress socketAddress = InetSocketAddress.createUnresolved("host", 1234);
+    assertEquals("host", RouteSelector.getHostString(socketAddress));
+    socketAddress = InetSocketAddress.createUnresolved("127.0.0.1", 1234);
+    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+
+    // InetAddress proxy specification.
+    socketAddress = new InetSocketAddress(InetAddress.getByName("localhost"), 1234);
+    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+    socketAddress = new InetSocketAddress(
+        InetAddress.getByAddress(new byte[] { 127, 0, 0, 1 }), 1234);
+    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+    socketAddress = new InetSocketAddress(
+        InetAddress.getByAddress("foobar", new byte[] { 127, 0, 0, 1 }), 1234);
+    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+  }
+
+  private void assertConnection(Connection connection, Address address, Proxy proxy,
+      InetAddress socketAddress, int socketPort, ConnectionSpec connectionSpec) {
+    assertEquals(address, connection.getRoute().getAddress());
+    assertEquals(proxy, connection.getRoute().getProxy());
+    assertEquals(socketAddress, connection.getRoute().getSocketAddress().getAddress());
+    assertEquals(socketPort, connection.getRoute().getSocketAddress().getPort());
+    assertEquals(connectionSpec, connection.getRoute().getConnectionSpec());
+  }
+
+  /** Returns an address that's without an SSL socket factory or hostname verifier. */
+  private Address httpAddress() {
+    return new Address(uriHost, uriPort, socketFactory, null, null, null, authenticator, null,
+        protocols, connectionSpecs, proxySelector);
+  }
+
+  private static InetAddress[] makeFakeAddresses(int prefix, int count) {
+    try {
+      InetAddress[] result = new InetAddress[count];
+      for (int i = 0; i < count; i++) {
+        result[i] =
+            InetAddress.getByAddress(new byte[] { (byte) prefix, (byte) 0, (byte) 0, (byte) i });
+      }
+      return result;
+    } catch (UnknownHostException e) {
+      throw new AssertionError();
+    }
+  }
+
+  private static class FakeDns implements Network {
+    List<String> requestedHosts = new ArrayList<>();
+    InetAddress[] inetAddresses;
+
+    @Override public InetAddress[] resolveInetAddresses(String host) throws UnknownHostException {
+      requestedHosts.add(host);
+      if (inetAddresses == null) throw new UnknownHostException();
+      return inetAddresses;
+    }
+
+    public void assertRequests(String... expectedHosts) {
+      assertEquals(Arrays.asList(expectedHosts), requestedHosts);
+      requestedHosts.clear();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
new file mode 100644
index 0000000000..f339f9ebe6
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Protocol;
+import java.io.IOException;
+import java.net.ProtocolException;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class StatusLineTest {
+  @Test public void parse() throws IOException {
+    String message = "Temporary Redirect";
+    int version = 1;
+    int code = 200;
+    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code + " " + message);
+    assertEquals(message, statusLine.message);
+    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
+    assertEquals(code, statusLine.code);
+  }
+
+  @Test public void emptyMessage() throws IOException {
+    int version = 1;
+    int code = 503;
+    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code + " ");
+    assertEquals("", statusLine.message);
+    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
+    assertEquals(code, statusLine.code);
+  }
+
+  /**
+   * This is not defined in the protocol but some servers won't add the leading
+   * empty space when the message is empty.
+   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
+   */
+  @Test public void emptyMessageAndNoLeadingSpace() throws IOException {
+    int version = 1;
+    int code = 503;
+    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code);
+    assertEquals("", statusLine.message);
+    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
+    assertEquals(code, statusLine.code);
+  }
+
+  // https://github.com/square/okhttp/issues/386
+  @Test public void shoutcast() throws IOException {
+    StatusLine statusLine = StatusLine.parse("ICY 200 OK");
+    assertEquals("OK", statusLine.message);
+    assertEquals(Protocol.HTTP_1_0, statusLine.protocol);
+    assertEquals(200, statusLine.code);
+  }
+
+  @Test public void missingProtocol() throws IOException {
+    assertInvalid("");
+    assertInvalid(" ");
+    assertInvalid("200 OK");
+    assertInvalid(" 200 OK");
+  }
+
+  @Test public void protocolVersions() throws IOException {
+    assertInvalid("HTTP/2.0 200 OK");
+    assertInvalid("HTTP/2.1 200 OK");
+    assertInvalid("HTTP/-.1 200 OK");
+    assertInvalid("HTTP/1.- 200 OK");
+    assertInvalid("HTTP/0.1 200 OK");
+    assertInvalid("HTTP/101 200 OK");
+    assertInvalid("HTTP/1.1_200 OK");
+  }
+
+  @Test public void nonThreeDigitCode() throws IOException {
+    assertInvalid("HTTP/1.1  OK");
+    assertInvalid("HTTP/1.1 2 OK");
+    assertInvalid("HTTP/1.1 20 OK");
+    assertInvalid("HTTP/1.1 2000 OK");
+    assertInvalid("HTTP/1.1 two OK");
+    assertInvalid("HTTP/1.1 2");
+    assertInvalid("HTTP/1.1 2000");
+    assertInvalid("HTTP/1.1 two");
+  }
+
+  @Test public void truncated() throws IOException {
+    assertInvalid("");
+    assertInvalid("H");
+    assertInvalid("HTTP/1");
+    assertInvalid("HTTP/1.");
+    assertInvalid("HTTP/1.1");
+    assertInvalid("HTTP/1.1 ");
+    assertInvalid("HTTP/1.1 2");
+    assertInvalid("HTTP/1.1 20");
+  }
+
+  @Test public void wrongMessageDelimiter() throws IOException {
+    assertInvalid("HTTP/1.1 200_");
+  }
+
+  private void assertInvalid(String statusLine) throws IOException {
+    try {
+      StatusLine.parse(statusLine);
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
new file mode 100644
index 0000000000..c9e5a0b185
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.DelegatingServerSocketFactory;
+import com.squareup.okhttp.DelegatingSocketFactory;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.InetAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+
+import static org.junit.Assert.fail;
+
+public final class ThreadInterruptTest {
+
+  // The size of the socket buffers in bytes.
+  private static final int SOCKET_BUFFER_SIZE = 256 * 1024;
+
+  private MockWebServer server;
+  private OkHttpClient client;
+
+  @Before public void setUp() throws Exception {
+    server = new MockWebServer();
+    client = new OkHttpClient();
+
+    // Sockets on some platforms can have large buffers that mean writes do not block when
+    // required. These socket factories explicitly set the buffer sizes on sockets created.
+    server.setServerSocketFactory(
+        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
+          @Override
+          protected void configureServerSocket(ServerSocket serverSocket) throws IOException {
+            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+          }
+        });
+    client.setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+      @Override
+      protected void configureSocket(Socket socket) throws IOException {
+        socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+        socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+      }
+    });
+  }
+
+  @Test public void interruptWritingRequestBody() throws Exception {
+    int requestBodySize = 2 * 1024 * 1024; // 2 MiB
+
+    server.enqueue(new MockResponse()
+        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
+    server.play();
+
+    interruptLater(500);
+
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    connection.setDoOutput(true);
+    connection.setFixedLengthStreamingMode(requestBodySize);
+    OutputStream requestBody = connection.getOutputStream();
+    byte[] buffer = new byte[1024];
+    try {
+      for (int i = 0; i < requestBodySize; i += buffer.length) {
+        requestBody.write(buffer);
+        requestBody.flush();
+      }
+      fail("Expected thread to be interrupted");
+    } catch (InterruptedIOException expected) {
+    }
+
+    connection.disconnect();
+  }
+
+  @Test public void interruptReadingResponseBody() throws Exception {
+    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
+
+    server.enqueue(new MockResponse()
+        .setBody(new byte[responseBodySize])
+        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
+    server.play();
+
+    interruptLater(500);
+
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
+    InputStream responseBody = connection.getInputStream();
+    byte[] buffer = new byte[1024];
+    try {
+      while (responseBody.read(buffer) != -1) {
+      }
+      fail("Expected thread to be interrupted");
+    } catch (InterruptedIOException expected) {
+    }
+
+    connection.disconnect();
+  }
+
+  private void interruptLater(final int delayMillis) {
+    final Thread toInterrupt = Thread.currentThread();
+    Thread interruptingCow = new Thread() {
+      @Override public void run() {
+        try {
+          sleep(delayMillis);
+          toInterrupt.interrupt();
+        } catch (InterruptedException e) {
+          throw new RuntimeException(e);
+        }
+      }
+    };
+    interruptingCow.start();
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
similarity index 63%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 5af2812ccd..ddc64bc9f7 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -16,24 +16,37 @@
 
 package com.squareup.okhttp.internal.http;
 
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.SocketPolicy;
-import com.squareup.okhttp.HttpResponseCache;
+import com.squareup.okhttp.Cache;
+import com.squareup.okhttp.Challenge;
+import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.ConnectionSpec;
+import com.squareup.okhttp.Credentials;
+import com.squareup.okhttp.DelegatingServerSocketFactory;
+import com.squareup.okhttp.DelegatingSocketFactory;
+import com.squareup.okhttp.FallbackTestClientSocketFactory;
+import com.squareup.okhttp.Interceptor;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.TlsVersion;
+import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.RecordingAuthenticator;
 import com.squareup.okhttp.internal.RecordingHostnameVerifier;
 import com.squareup.okhttp.internal.RecordingOkAuthenticator;
+import com.squareup.okhttp.internal.SingleInetAddressNetwork;
 import com.squareup.okhttp.internal.SslContextBuilder;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.SocketPolicy;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.Authenticator;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
 import java.net.ConnectException;
 import java.net.HttpRetryException;
 import java.net.HttpURLConnection;
@@ -41,19 +54,19 @@
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.ProxySelector;
-import java.net.ResponseCache;
+import java.net.ServerSocket;
+import java.net.Socket;
 import java.net.SocketAddress;
-import java.net.SocketTimeoutException;
 import java.net.URI;
 import java.net.URL;
 import java.net.URLConnection;
 import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.EnumSet;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
@@ -61,9 +74,10 @@
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
-import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
-import java.util.zip.GZIPOutputStream;
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLException;
@@ -71,57 +85,58 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Ignore;
+import org.junit.Rule;
 import org.junit.Test;
 
+import static com.squareup.okhttp.internal.Util.UTF_8;
+import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
-import static com.squareup.okhttp.OkAuthenticator.Credential;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /** Android's URLConnectionTest. */
 public final class URLConnectionTest {
-  private MockWebServer server = new MockWebServer();
-  private MockWebServer server2 = new MockWebServer();
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
 
-  private final OkHttpClient client = new OkHttpClient();
-  private HttpResponseCache cache;
-  private String hostName;
+  @Rule public MockWebServerRule server = new MockWebServerRule();
+  @Rule public MockWebServerRule server2 = new MockWebServerRule();
 
-  private static final SSLContext sslContext;
-  static {
-    try {
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
+  private OkUrlFactory client;
+  private HttpURLConnection connection;
+  private Cache cache;
 
   @Before public void setUp() throws Exception {
-    hostName = server.getHostName();
-    server.setNpnEnabled(false);
+    server.get().setProtocolNegotiationEnabled(false);
+    client = new OkUrlFactory(new OkHttpClient());
   }
 
   @After public void tearDown() throws Exception {
     Authenticator.setDefault(null);
     System.clearProperty("proxyHost");
     System.clearProperty("proxyPort");
+    System.clearProperty("http.agent");
     System.clearProperty("http.proxyHost");
     System.clearProperty("http.proxyPort");
     System.clearProperty("https.proxyHost");
     System.clearProperty("https.proxyPort");
-    server.shutdown();
-    server2.shutdown();
     if (cache != null) {
       cache.delete();
     }
@@ -129,14 +144,13 @@
 
   @Test public void requestHeaders() throws IOException, InterruptedException {
     server.enqueue(new MockResponse());
-    server.play();
-
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.addRequestProperty("D", "e");
-    urlConnection.addRequestProperty("D", "f");
-    assertEquals("f", urlConnection.getRequestProperty("D"));
-    assertEquals("f", urlConnection.getRequestProperty("d"));
-    Map<String, List<String>> requestHeaders = urlConnection.getRequestProperties();
+
+    connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("D", "e");
+    connection.addRequestProperty("D", "f");
+    assertEquals("f", connection.getRequestProperty("D"));
+    assertEquals("f", connection.getRequestProperty("d"));
+    Map<String, List<String>> requestHeaders = connection.getRequestProperties();
     assertEquals(newSet("e", "f"), new HashSet<String>(requestHeaders.get("D")));
     assertEquals(newSet("e", "f"), new HashSet<String>(requestHeaders.get("d")));
     try {
@@ -150,21 +164,21 @@
     } catch (UnsupportedOperationException expected) {
     }
     try {
-      urlConnection.setRequestProperty(null, "j");
+      connection.setRequestProperty(null, "j");
       fail();
     } catch (NullPointerException expected) {
     }
     try {
-      urlConnection.addRequestProperty(null, "k");
+      connection.addRequestProperty(null, "k");
       fail();
     } catch (NullPointerException expected) {
     }
-    urlConnection.setRequestProperty("NullValue", null);
-    assertNull(urlConnection.getRequestProperty("NullValue"));
-    urlConnection.addRequestProperty("AnotherNullValue", null);
-    assertNull(urlConnection.getRequestProperty("AnotherNullValue"));
+    connection.setRequestProperty("NullValue", null);
+    assertNull(connection.getRequestProperty("NullValue"));
+    connection.addRequestProperty("AnotherNullValue", null);
+    assertNull(connection.getRequestProperty("AnotherNullValue"));
 
-    urlConnection.getResponseCode();
+    connection.getResponseCode();
     RecordedRequest request = server.takeRequest();
     assertContains(request.getHeaders(), "D: e");
     assertContains(request.getHeaders(), "D: f");
@@ -174,28 +188,27 @@
     assertContainsNoneMatching(request.getHeaders(), "null:.*");
 
     try {
-      urlConnection.addRequestProperty("N", "o");
+      connection.addRequestProperty("N", "o");
       fail("Set header after connect");
     } catch (IllegalStateException expected) {
     }
     try {
-      urlConnection.setRequestProperty("P", "q");
+      connection.setRequestProperty("P", "q");
       fail("Set header after connect");
     } catch (IllegalStateException expected) {
     }
     try {
-      urlConnection.getRequestProperties();
+      connection.getRequestProperties();
       fail();
     } catch (IllegalStateException expected) {
     }
   }
 
   @Test public void getRequestPropertyReturnsLastValue() throws Exception {
-    server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.addRequestProperty("A", "value1");
-    urlConnection.addRequestProperty("A", "value2");
-    assertEquals("value2", urlConnection.getRequestProperty("A"));
+    connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("A", "value1");
+    connection.addRequestProperty("A", "value2");
+    assertEquals("value2", connection.getRequestProperty("A"));
   }
 
   @Test public void responseHeaders() throws IOException, InterruptedException {
@@ -204,13 +217,12 @@
         .addHeader("B: d")
         .addHeader("A: e")
         .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
-    server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-    assertEquals("HTTP/1.0 200 Fantastic", urlConnection.getHeaderField(null));
-    Map<String, List<String>> responseHeaders = urlConnection.getHeaderFields();
+    connection = client.open(server.getUrl("/"));
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Fantastic", connection.getResponseMessage());
+    assertEquals("HTTP/1.0 200 Fantastic", connection.getHeaderField(null));
+    Map<String, List<String>> responseHeaders = connection.getHeaderFields();
     assertEquals(Arrays.asList("HTTP/1.0 200 Fantastic"), responseHeaders.get(null));
     assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("A")));
     assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("a")));
@@ -224,21 +236,20 @@
       fail("Modified an unmodifiable view.");
     } catch (UnsupportedOperationException expected) {
     }
-    assertEquals("A", urlConnection.getHeaderFieldKey(0));
-    assertEquals("c", urlConnection.getHeaderField(0));
-    assertEquals("B", urlConnection.getHeaderFieldKey(1));
-    assertEquals("d", urlConnection.getHeaderField(1));
-    assertEquals("A", urlConnection.getHeaderFieldKey(2));
-    assertEquals("e", urlConnection.getHeaderField(2));
+    assertEquals("A", connection.getHeaderFieldKey(0));
+    assertEquals("c", connection.getHeaderField(0));
+    assertEquals("B", connection.getHeaderFieldKey(1));
+    assertEquals("d", connection.getHeaderField(1));
+    assertEquals("A", connection.getHeaderFieldKey(2));
+    assertEquals("e", connection.getHeaderField(2));
   }
 
   @Test public void serverSendsInvalidResponseHeaders() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
-    server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.getResponseCode();
+      connection.getResponseCode();
       fail();
     } catch (IOException expected) {
     }
@@ -246,11 +257,10 @@
 
   @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
-    server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.getResponseCode();
+      connection.getResponseCode();
       fail();
     } catch (IOException expected) {
     }
@@ -258,11 +268,10 @@
 
   @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
-    server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.getResponseCode();
+      connection.getResponseCode();
       fail();
     } catch (IOException expected) {
     }
@@ -270,22 +279,20 @@
 
   @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
     server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
-    server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.getResponseCode();
+      connection.getResponseCode();
       fail();
     } catch (IOException expected) {
     }
   }
 
   @Test public void connectRetriesUntilConnectedOrFailed() throws Exception {
-    server.play();
     URL url = server.getUrl("/foo");
-    server.shutdown();
+    server.get().shutdown();
 
-    HttpURLConnection connection = client.open(url);
+    connection = client.open(url);
     try {
       connection.connect();
       fail();
@@ -307,16 +314,14 @@
 
   private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
-    server.play();
 
     // Use a misconfigured proxy to guarantee that the request is retried.
-    server2.play();
     FakeProxySelector proxySelector = new FakeProxySelector();
-    proxySelector.proxies.add(server2.toProxyAddress());
-    client.setProxySelector(proxySelector);
-    server2.shutdown();
+    proxySelector.proxies.add(server2.get().toProxyAddress());
+    client.client().setProxySelector(proxySelector);
+    server2.get().shutdown();
 
-    HttpURLConnection connection = client.open(server.getUrl("/def"));
+    connection = client.open(server.getUrl("/def"));
     connection.setDoOutput(true);
     transferKind.setForRequest(connection, 4);
     connection.getOutputStream().write("body".getBytes("UTF-8"));
@@ -327,15 +332,13 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
 
   @Test public void getErrorStreamOnSuccessfulRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertNull(connection.getErrorStream());
   }
 
   @Test public void getErrorStreamOnUnsuccessfulRequest() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(404).setBody("A"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection.getErrorStream(), Integer.MAX_VALUE));
   }
 
@@ -347,7 +350,6 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
 
     server.enqueue(response);
     server.enqueue(response);
-    server.play();
 
     assertContent("ABCDE", client.open(server.getUrl("/")), 5);
     assertContent("ABCDE", client.open(server.getUrl("/")), 5);
@@ -366,7 +368,6 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     server.enqueue(response);
     server.enqueue(response);
     server.enqueue(response);
-    server.play();
 
     assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/foo")));
     assertEquals(0, server.takeRequest().getSequenceNumber());
@@ -382,7 +383,6 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     server.enqueue(response);
     server.enqueue(response);
     server.enqueue(response);
-    server.play();
 
     assertContent("ABCDEFGHIJKLMNOPQR", client.open(server.getUrl("/foo")));
     assertEquals(0, server.takeRequest().getSequenceNumber());
@@ -404,13 +404,23 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     testServerClosesOutput(SHUTDOWN_OUTPUT_AT_END);
   }
 
+  @Test public void invalidHost() throws Exception {
+    // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
+    URL url = new URL("http://1234.1.1.1/index.html");
+    HttpURLConnection connection = client.open(url);
+    try {
+      connection.connect();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
   private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception {
     server.enqueue(new MockResponse().setBody("This connection won't pool properly")
         .setSocketPolicy(socketPolicy));
     MockResponse responseAfter = new MockResponse().setBody("This comes after a busted connection");
     server.enqueue(responseAfter);
     server.enqueue(responseAfter); // Enqueue 2x because the broken connection may be reused.
-    server.play();
 
     HttpURLConnection connection1 = client.open(server.getUrl("/a"));
     connection1.setReadTimeout(100);
@@ -457,9 +467,8 @@ private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception
 
   private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Exception {
     int n = 512 * 1024;
-    server.setBodyLimit(0);
+    server.get().setBodyLimit(0);
     server.enqueue(new MockResponse());
-    server.play();
 
     HttpURLConnection conn = client.open(server.getUrl("/"));
     conn.setDoOutput(true);
@@ -494,7 +503,6 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
 
   @Test public void getResponseCodeNoResponseBody() throws Exception {
     server.enqueue(new MockResponse().addHeader("abc: def"));
-    server.play();
 
     URL url = server.getUrl("/");
     HttpURLConnection conn = client.open(url);
@@ -509,13 +517,12 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void connectViaHttps() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.get().useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-    server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    connection = client.open(server.getUrl("/foo"));
 
     assertContent("this response comes via HTTPS", connection);
 
@@ -523,19 +530,47 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
   }
 
+  @Test public void inspectHandshakeThroughoutRequestLifecycle() throws Exception {
+    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse());
+
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+
+    HttpsURLConnection httpsConnection = (HttpsURLConnection) client.open(server.getUrl("/foo"));
+
+    // Prior to calling connect(), getting the cipher suite is forbidden.
+    try {
+      httpsConnection.getCipherSuite();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    // Calling connect establishes a handshake...
+    httpsConnection.connect();
+    assertNotNull(httpsConnection.getCipherSuite());
+
+    // ...which remains after we read the response body...
+    assertContent("", httpsConnection);
+    assertNotNull(httpsConnection.getCipherSuite());
+
+    // ...and after we disconnect.
+    httpsConnection.disconnect();
+    assertNotNull(httpsConnection.getCipherSuite());
+  }
+
   @Test public void connectViaHttpsReusingConnections() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.get().useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
-    server.play();
 
     // The pool will only reuse sockets if the SSL socket factories are the same.
     SSLSocketFactory clientSocketFactory = sslContext.getSocketFactory();
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    client.setSslSocketFactory(clientSocketFactory);
-    client.setHostnameVerifier(hostnameVerifier);
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    client.client().setSslSocketFactory(clientSocketFactory);
+    client.client().setHostnameVerifier(hostnameVerifier);
+    connection = client.open(server.getUrl("/"));
     assertContent("this response comes via HTTPS", connection);
 
     connection = client.open(server.getUrl("/"));
@@ -547,18 +582,17 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
 
   @Test public void connectViaHttpsReusingConnectionsDifferentFactories()
       throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.get().useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
-    server.play();
 
     // install a custom SSL socket factory so the server can be authorized
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     HttpURLConnection connection1 = client.open(server.getUrl("/"));
     assertContent("this response comes via HTTPS", connection1);
 
-    client.setSslSocketFactory(null);
+    client.client().setSslSocketFactory(null);
     HttpURLConnection connection2 = client.open(server.getUrl("/"));
     try {
       readAscii(connection2.getInputStream(), Integer.MAX_VALUE);
@@ -568,14 +602,13 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void connectViaHttpsWithSSLFallback() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.get().useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("this response comes via SSL"));
-    server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    suppressTlsFallbackScsv(client.client());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    connection = client.open(server.getUrl("/foo"));
 
     assertContent("this response comes via SSL", connection);
 
@@ -583,17 +616,45 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
   }
 
+  /**
+   * When a pooled connection fails, don't blame the route. Otherwise pooled
+   * connection failures can cause unnecessary SSL fallbacks.
+   *
+   * https://github.com/square/okhttp/issues/515
+   */
+  @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
+    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    suppressTlsFallbackScsv(client.client());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+
+    assertContent("abc", client.open(server.getUrl("/")));
+    assertContent("def", client.open(server.getUrl("/")));
+
+    Set<TlsVersion> tlsVersions =
+        EnumSet.of(TlsVersion.TLS_1_0, TlsVersion.TLS_1_2); // v1.2 on OpenJDK 8.
+
+    RecordedRequest request1 = server.takeRequest();
+    assertTrue(tlsVersions.contains(request1.getTlsVersion()));
+
+    RecordedRequest request2 = server.takeRequest();
+    assertTrue(tlsVersions.contains(request2.getTlsVersion()));
+  }
+
   /**
    * Verify that we don't retry connections on certificate verification errors.
    *
    * http://code.google.com/p/android/issues/detail?id=13178
    */
   @Test public void connectViaHttpsToUntrustedServer() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.get().useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse()); // unused
-    server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     try {
       connection.getInputStream();
       fail();
@@ -618,13 +679,13 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
     MockResponse mockResponse = new MockResponse().setBody("this response comes via a proxy");
     server.enqueue(mockResponse);
-    server.play();
 
     URL url = new URL("http://android.com/foo");
-    HttpURLConnection connection = proxyConfig.connect(server, client, url);
+    connection = proxyConfig.connect(server.get(), client, url);
     assertContent("this response comes via a proxy", connection);
+    assertTrue(connection.usingProxy());
 
-    RecordedRequest request = server.takeRequest();
+    RecordedRequest request = server.get().takeRequest();
     assertEquals("GET http://android.com/foo HTTP/1.1", request.getRequestLine());
     assertContains(request.getHeaders(), "Host: android.com");
   }
@@ -633,23 +694,61 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
     server.enqueue(new MockResponse().setBody("abc\r\nYOU SHOULD NOT SEE THIS")
         .clearHeaders()
         .addHeader("Content-Length: 3"));
-    server.play();
-
     assertContent("abc", client.open(server.getUrl("/")));
   }
 
+  public void testConnectViaSocketFactory(boolean useHttps) throws IOException {
+    SocketFactory uselessSocketFactory = new SocketFactory() {
+      public Socket createSocket() { throw new IllegalArgumentException("useless"); }
+      public Socket createSocket(InetAddress host, int port) { return null; }
+      public Socket createSocket(InetAddress address, int port, InetAddress localAddress,
+          int localPort) { return null; }
+      public Socket createSocket(String host, int port) { return null; }
+      public Socket createSocket(String host, int port, InetAddress localHost, int localPort) {
+        return null;
+      }
+    };
+
+    if (useHttps) {
+      server.get().useHttps(sslContext.getSocketFactory(), false);
+      client.client().setSslSocketFactory(sslContext.getSocketFactory());
+      client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    }
+
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
+
+    client.client().setSocketFactory(uselessSocketFactory);
+    connection = client.open(server.getUrl("/"));
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+
+    client.client().setSocketFactory(SocketFactory.getDefault());
+    connection = client.open(server.getUrl("/"));
+    assertEquals(200, connection.getResponseCode());
+  }
+
+  @Test public void connectHttpViaSocketFactory() throws Exception {
+    testConnectViaSocketFactory(false);
+  }
+
+  @Test public void connectHttpsViaSocketFactory() throws Exception {
+    testConnectViaSocketFactory(true);
+  }
+
   @Test public void contentDisagreesWithChunkedHeader() throws IOException {
     MockResponse mockResponse = new MockResponse();
     mockResponse.setChunkedBody("abc", 3);
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    bytesOut.write(mockResponse.getBody());
-    bytesOut.write("\r\nYOU SHOULD NOT SEE THIS".getBytes("UTF-8"));
-    mockResponse.setBody(bytesOut.toByteArray());
+    Buffer buffer = new Buffer();
+    buffer.writeAll(mockResponse.getBody());
+    buffer.write("\r\nYOU SHOULD NOT SEE THIS".getBytes("UTF-8"));
+    mockResponse.setBody(buffer);
     mockResponse.clearHeaders();
     mockResponse.addHeader("Transfer-encoding: chunked");
 
     server.enqueue(mockResponse);
-    server.play();
 
     assertContent("abc", client.open(server.getUrl("/")));
   }
@@ -664,14 +763,13 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
   }
 
   private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.get().useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-    server.play();
 
     URL url = server.getUrl("/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = proxyConfig.connect(server, client, url);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    connection = proxyConfig.connect(server.get(), client, url);
 
     assertContent("this response comes via HTTPS", connection);
 
@@ -702,16 +800,15 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
   private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.useHttps(sslContext.getSocketFactory(), true);
+    server.get().useHttps(sslContext.getSocketFactory(), true);
     server.enqueue(
         new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
-    server.play();
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
-    HttpURLConnection connection = proxyConfig.connect(server, client, url);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(hostnameVerifier);
+    connection = proxyConfig.connect(server.get(), client, url);
 
     assertContent("this response comes via a secure proxy", connection);
 
@@ -726,49 +823,40 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
   }
 
-  /** Tolerate bad https proxy response when using HttpResponseCache. http://b/6754912 */
+  /** Tolerate bad https proxy response when using HttpResponseCache. Android bug 6754912. */
   @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
     initResponseCache();
 
-    server.useHttps(sslContext.getSocketFactory(), true);
-    MockResponse response = new MockResponse() // Key to reproducing b/6754912
+    server.get().useHttps(sslContext.getSocketFactory(), true);
+    // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
+    MockResponse badProxyResponse = new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
         .setBody("bogus proxy connect response content");
+    server.enqueue(badProxyResponse);
+    server.enqueue(new MockResponse().setBody("response"));
 
-    // Enqueue a pair of responses for every IP address held by localhost, because the
-    // route selector will try each in sequence.
-    // TODO: use the fake Dns implementation instead of a loop
-    for (InetAddress inetAddress : InetAddress.getAllByName(server.getHostName())) {
-      server.enqueue(response); // For the first TLS tolerant connection
-      server.enqueue(response); // For the backwards-compatible SSLv3 retry
-    }
-    server.play();
-    client.setProxy(server.toProxyAddress());
+    // Configure a single IP address for the host and a single configuration, so we only need one
+    // failure to fail permanently.
+    Internal.instance.setNetwork(client.client(), new SingleInetAddressNetwork());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setConnectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS));
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setProxy(server.get().toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    HttpURLConnection connection = client.open(url);
-
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-      // Thrown when the connect causes SSLSocket.startHandshake() to throw
-      // when it sees the "bogus proxy connect response content"
-      // instead of a ServerHello handshake message.
-    }
+    connection = client.open(url);
+    assertContent("response", connection);
 
     RecordedRequest connect = server.takeRequest();
-    assertEquals("Connect line failure on proxy", "CONNECT android.com:443 HTTP/1.1",
-        connect.getRequestLine());
+    assertEquals("CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
     assertContains(connect.getHeaders(), "Host: android.com");
   }
 
   private void initResponseCache() throws IOException {
     String tmp = System.getProperty("java.io.tmpdir");
     File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
-    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
-    client.setResponseCache(cache);
+    cache = new Cache(cacheDir, Integer.MAX_VALUE);
+    client.client().setCache(cache);
   }
 
   /** Test which headers are sent unencrypted to the HTTP proxy. */
@@ -776,17 +864,17 @@ private void initResponseCache() throws IOException {
       throws IOException, InterruptedException {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.useHttps(sslContext.getSocketFactory(), true);
+    server.get().useHttps(sslContext.getSocketFactory(), true);
     server.enqueue(
         new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
-    server.play();
-    client.setProxy(server.toProxyAddress());
+
+    client.client().setProxy(server.get().toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
-    HttpURLConnection connection = client.open(url);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(hostnameVerifier);
+    connection = client.open(url);
     connection.addRequestProperty("Private", "Secret");
     connection.addRequestProperty("Proxy-Authorization", "bar");
     connection.addRequestProperty("User-Agent", "baz");
@@ -806,19 +894,19 @@ private void initResponseCache() throws IOException {
 
   @Test public void proxyAuthenticateOnConnect() throws Exception {
     Authenticator.setDefault(new RecordingAuthenticator());
-    server.useHttps(sslContext.getSocketFactory(), true);
+    server.get().useHttps(sslContext.getSocketFactory(), true);
     server.enqueue(new MockResponse().setResponseCode(407)
         .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
     server.enqueue(
         new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-    client.setProxy(server.toProxyAddress());
+
+    client.client().setProxy(server.get().toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(url);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    connection = client.open(url);
     assertContent("A", connection);
 
     RecordedRequest connect1 = server.takeRequest();
@@ -838,17 +926,17 @@ private void initResponseCache() throws IOException {
   // Don't disconnect after building a tunnel with CONNECT
   // http://code.google.com/p/android/issues/detail?id=37221
   @Test public void proxyWithConnectionClose() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), true);
+    server.get().useHttps(sslContext.getSocketFactory(), true);
     server.enqueue(
         new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
-    server.play();
-    client.setProxy(server.toProxyAddress());
+
+    client.client().setProxy(server.get().toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(url);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    connection = client.open(url);
     connection.setRequestProperty("Connection", "close");
 
     assertContent("this response comes via a proxy", connection);
@@ -858,30 +946,35 @@ private void initResponseCache() throws IOException {
     SSLSocketFactory socketFactory = sslContext.getSocketFactory();
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.useHttps(socketFactory, true);
+    server.get().useHttps(socketFactory, true);
     server.enqueue(
         new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("response 1"));
     server.enqueue(new MockResponse().setBody("response 2"));
-    server.play();
-    client.setProxy(server.toProxyAddress());
+
+    client.client().setProxy(server.get().toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(socketFactory);
-    client.setHostnameVerifier(hostnameVerifier);
+    client.client().setSslSocketFactory(socketFactory);
+    client.client().setHostnameVerifier(hostnameVerifier);
     assertContent("response 1", client.open(url));
     assertContent("response 2", client.open(url));
   }
 
   @Test public void disconnectedConnection() throws IOException {
-    server.enqueue(new MockResponse().setBody("ABCDEFGHIJKLMNOPQR"));
-    server.play();
+    server.enqueue(new MockResponse()
+        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
+        .setBody("ABCD"));
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals('A', (char) in.read());
     connection.disconnect();
     try {
+      // Reading 'B' may succeed if it's buffered.
+      in.read();
+
+      // But 'C' shouldn't be buffered (the response is throttled) and this should fail.
       in.read();
       fail("Expected a connection closed exception");
     } catch (IOException expected) {
@@ -890,11 +983,9 @@ private void initResponseCache() throws IOException {
 
   @Test public void disconnectBeforeConnect() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.disconnect();
-
     assertContent("A", connection);
     assertEquals(200, connection.getResponseCode());
   }
@@ -939,7 +1030,6 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     transferKind.setBody(response, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1024);
     server.enqueue(response);
     server.enqueue(response);
-    server.play();
 
     InputStream in = client.open(server.getUrl("/")).getInputStream();
     assertFalse("This implementation claims to support mark().", in.markSupported());
@@ -966,7 +1056,6 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     server.enqueue(response);
     server.enqueue(response);
     server.enqueue(response);
-    server.play();
 
     URL url = server.getUrl("/");
     HttpURLConnection conn = client.open(url);
@@ -981,7 +1070,6 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setBody("5\r\nABCDE\r\nG\r\nFGHIJKLMNOPQRSTU\r\n0\r\n\r\n")
         .clearHeaders()
         .addHeader("Transfer-encoding: chunked"));
-    server.play();
 
     URLConnection connection = client.open(server.getUrl("/"));
     try {
@@ -996,7 +1084,6 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
         .clearHeaders()
         .addHeader("Transfer-encoding: chunked")
         .setSocketPolicy(DISCONNECT_AT_END));
-    server.play();
 
     URLConnection connection = client.open(server.getUrl("/"));
     try {
@@ -1012,9 +1099,9 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
    * imply a bug in the implementation.
    */
   @Test public void gzipEncodingEnabledByDefault() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody(gzip("ABCABCABC".getBytes("UTF-8")))
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
         .addHeader("Content-Encoding: gzip"));
-    server.play();
 
     URLConnection connection = client.open(server.getUrl("/"));
     assertEquals("ABCABCABC", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
@@ -1026,17 +1113,16 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
   }
 
   @Test public void clientConfiguredGzipContentEncoding() throws Exception {
-    byte[] bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ".getBytes("UTF-8"));
+    Buffer bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
     server.enqueue(new MockResponse()
         .setBody(bodyBytes)
         .addHeader("Content-Encoding: gzip"));
-    server.play();
 
     URLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Accept-Encoding", "gzip");
     InputStream gunzippedIn = new GZIPInputStream(connection.getInputStream());
     assertEquals("ABCDEFGHIJKLMNOPQRSTUVWXYZ", readAscii(gunzippedIn, Integer.MAX_VALUE));
-    assertEquals(bodyBytes.length, connection.getContentLength());
+    assertEquals(bodyBytes.size(), connection.getContentLength());
 
     RecordedRequest request = server.takeRequest();
     assertContains(request.getHeaders(), "Accept-Encoding: gzip");
@@ -1060,7 +1146,6 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
 
   @Test public void clientConfiguredCustomContentEncoding() throws Exception {
     server.enqueue(new MockResponse().setBody("ABCDE").addHeader("Content-Encoding: custom"));
-    server.play();
 
     URLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Accept-Encoding", "custom");
@@ -1081,19 +1166,18 @@ private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferK
     if (tls) {
       SSLSocketFactory socketFactory = sslContext.getSocketFactory();
       RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-      server.useHttps(socketFactory, false);
-      client.setSslSocketFactory(socketFactory);
-      client.setHostnameVerifier(hostnameVerifier);
+      server.get().useHttps(socketFactory, false);
+      client.client().setSslSocketFactory(socketFactory);
+      client.client().setHostnameVerifier(hostnameVerifier);
     }
 
     MockResponse responseOne = new MockResponse();
     responseOne.addHeader("Content-Encoding: gzip");
-    transferKind.setBody(responseOne, gzip("one (gzipped)".getBytes("UTF-8")), 5);
+    transferKind.setBody(responseOne, gzip("one (gzipped)"), 5);
     server.enqueue(responseOne);
     MockResponse responseTwo = new MockResponse();
     transferKind.setBody(responseTwo, "two (identity)", 5);
     server.enqueue(responseTwo);
-    server.play();
 
     HttpURLConnection connection1 = client.open(server.getUrl("/"));
     connection1.addRequestProperty("Accept-Encoding", "gzip");
@@ -1106,6 +1190,39 @@ private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferK
     assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
+  @Test public void transparentGzipWorksAfterExceptionRecovery() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("a")
+        .setSocketPolicy(SHUTDOWN_INPUT_AT_END));
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("b")));
+
+    // Seed the pool with a bad connection.
+    assertContent("a", client.open(server.getUrl("/")));
+
+    // This connection will need to be recovered. When it is, transparent gzip should still work!
+    assertContent("b", client.open(server.getUrl("/")));
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
+  }
+
+  @Test public void endOfStreamResponseIsNotPooled() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("{}")
+        .clearHeaders()
+        .setSocketPolicy(DISCONNECT_AT_END));
+
+    ConnectionPool pool = ConnectionPool.getDefault();
+    pool.evictAll();
+    client.client().setConnectionPool(pool);
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertContent("{}", connection);
+    assertEquals(0, client.client().getConnectionPool().getConnectionCount());
+  }
+
   @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
     testEarlyDisconnectDoesntHarmPooling(TransferKind.CHUNKED);
   }
@@ -1123,42 +1240,62 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     transferKind.setBody(response2, "LMNOPQRSTUV", 1024);
     server.enqueue(response2);
 
-    server.play();
-
-    URLConnection connection1 = client.open(server.getUrl("/"));
+    HttpURLConnection connection1 = client.open(server.getUrl("/"));
     InputStream in1 = connection1.getInputStream();
     assertEquals("ABCDE", readAscii(in1, 5));
     in1.close();
+    connection1.disconnect();
 
     HttpURLConnection connection2 = client.open(server.getUrl("/"));
     InputStream in2 = connection2.getInputStream();
     assertEquals("LMNOP", readAscii(in2, 5));
     in2.close();
+    connection2.disconnect();
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection is pooled!
   }
 
-  /**
-   * Obnoxiously test that the chunk sizes transmitted exactly equal the
-   * requested data+chunk header size. Although setChunkedStreamingMode()
-   * isn't specific about whether the size applies to the data or the
-   * complete chunk, the RI interprets it as a complete chunk.
-   */
+  @Test public void streamDiscardingIsTimely() throws Exception {
+    // This response takes at least a full second to serve: 10,000 bytes served 100 bytes at a time.
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[10000]))
+        .throttleBody(100, 10, MILLISECONDS));
+    server.enqueue(new MockResponse().setBody("A"));
+
+    long startNanos = System.nanoTime();
+    URLConnection connection1 = client.open(server.getUrl("/"));
+    InputStream in = connection1.getInputStream();
+    in.close();
+    long elapsedNanos = System.nanoTime() - startNanos;
+    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
+
+    // If we're working correctly, this should be greater than 100ms, but less than double that.
+    // Previously we had a bug where we would download the entire response body as long as no
+    // individual read took longer than 100ms.
+    assertTrue(String.format("Time to close: %sms", elapsedMillis), elapsedMillis < 500);
+
+    // Do another request to confirm that the discarded connection was not pooled.
+    assertContent("A", client.open(server.getUrl("/")));
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
+  }
+
   @Test public void setChunkedStreamingMode() throws IOException, InterruptedException {
     server.enqueue(new MockResponse());
-    server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.setChunkedStreamingMode(8);
-    urlConnection.setDoOutput(true);
-    OutputStream outputStream = urlConnection.getOutputStream();
-    outputStream.write("ABCDEFGHIJKLMNOPQ".getBytes("US-ASCII"));
-    assertEquals(200, urlConnection.getResponseCode());
+    String body = "ABCDEFGHIJKLMNOPQ";
+    connection = client.open(server.getUrl("/"));
+    connection.setChunkedStreamingMode(0); // OkHttp does not honor specific chunk sizes.
+    connection.setDoOutput(true);
+    OutputStream outputStream = connection.getOutputStream();
+    outputStream.write(body.getBytes("US-ASCII"));
+    assertEquals(200, connection.getResponseCode());
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("ABCDEFGHIJKLMNOPQ", new String(request.getBody(), "US-ASCII"));
-    assertEquals(Arrays.asList(3, 3, 3, 3, 3, 2), request.getChunkSizes());
+    assertEquals(body, new String(request.getBody(), "US-ASCII"));
+    assertEquals(Arrays.asList(body.length()), request.getChunkSizes());
   }
 
   @Test public void authenticateWithFixedLengthStreaming() throws Exception {
@@ -1174,10 +1311,9 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
         .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
         .setBody("Please authenticate.");
     server.enqueue(pleaseAuthenticate);
-    server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     if (streamingMode == StreamingMode.FIXED_LENGTH) {
@@ -1200,6 +1336,60 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     assertEquals(Arrays.toString(requestBody), Arrays.toString(request.getBody()));
   }
 
+  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(401));
+    server.enqueue(new MockResponse());
+
+    String credential = Credentials.basic("jesse", "secret");
+    client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
+
+    connection = client.open(server.getUrl("/"));
+    connection.setDoOutput(true);
+    OutputStream outputStream = connection.getOutputStream();
+    outputStream.write(body.getBytes("UTF-8"));
+    outputStream.close();
+    assertEquals(200, connection.getResponseCode());
+
+    RecordedRequest recordedRequest1 = server.takeRequest();
+    assertEquals("POST", recordedRequest1.getMethod());
+    assertEquals(body, recordedRequest1.getUtf8Body());
+    assertNull(recordedRequest1.getHeader("Authorization"));
+
+    RecordedRequest recordedRequest2 = server.takeRequest();
+    assertEquals("POST", recordedRequest2.getMethod());
+    assertEquals(body, recordedRequest2.getUtf8Body());
+    assertEquals(credential, recordedRequest2.getHeader("Authorization"));
+  }
+
   @Test public void nonStandardAuthenticationScheme() throws Exception {
     List<String> calls = authCallsForHeader("WWW-Authenticate: Foo");
     assertEquals(Collections.<String>emptyList(), calls);
@@ -1227,7 +1417,7 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     String call = calls.get(0);
     assertTrue(call, call.contains("host=" + url.getHost()));
     assertTrue(call, call.contains("port=" + url.getPort()));
-    assertTrue(call, call.contains("site=" + InetAddress.getAllByName(url.getHost())[0]));
+    assertTrue(call, call.contains("site=" + url.getHost()));
     assertTrue(call, call.contains("url=" + url));
     assertTrue(call, call.contains("type=" + Authenticator.RequestorType.SERVER));
     assertTrue(call, call.contains("prompt=Bar"));
@@ -1242,7 +1432,7 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     String call = calls.get(0);
     assertTrue(call, call.contains("host=" + url.getHost()));
     assertTrue(call, call.contains("port=" + url.getPort()));
-    assertTrue(call, call.contains("site=" + InetAddress.getAllByName(url.getHost())[0]));
+    assertTrue(call, call.contains("site=" + url.getHost()));
     assertTrue(call, call.contains("url=http://android.com"));
     assertTrue(call, call.contains("type=" + Authenticator.RequestorType.PROXY));
     assertTrue(call, call.contains("prompt=Bar"));
@@ -1259,11 +1449,9 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
         .addHeader(authHeader)
         .setBody("Please authenticate.");
     server.enqueue(pleaseAuthenticate);
-    server.play();
 
-    HttpURLConnection connection;
     if (proxy) {
-      client.setProxy(server.toProxyAddress());
+      client.client().setProxy(server.get().toProxyAddress());
       connection = client.open(new URL("http://android.com"));
     } else {
       connection = client.open(server.getUrl("/"));
@@ -1273,7 +1461,6 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
   }
 
   @Test public void setValidRequestMethod() throws Exception {
-    server.play();
     assertValidRequestMethod("GET");
     assertValidRequestMethod("DELETE");
     assertValidRequestMethod("HEAD");
@@ -1281,26 +1468,25 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     assertValidRequestMethod("POST");
     assertValidRequestMethod("PUT");
     assertValidRequestMethod("TRACE");
+    assertValidRequestMethod("PATCH");
   }
 
   private void assertValidRequestMethod(String requestMethod) throws Exception {
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setRequestMethod(requestMethod);
     assertEquals(requestMethod, connection.getRequestMethod());
   }
 
   @Test public void setInvalidRequestMethodLowercase() throws Exception {
-    server.play();
     assertInvalidRequestMethod("get");
   }
 
   @Test public void setInvalidRequestMethodConnect() throws Exception {
-    server.play();
     assertInvalidRequestMethod("CONNECT");
   }
 
   private void assertInvalidRequestMethod(String requestMethod) throws Exception {
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.setRequestMethod(requestMethod);
       fail();
@@ -1308,9 +1494,33 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
     }
   }
 
+  @Test public void shoutcast() throws Exception {
+    server.enqueue(new MockResponse().setStatus("ICY 200 OK")
+        // .addHeader("HTTP/1.0 200 OK")
+        .addHeader("Accept-Ranges: none")
+        .addHeader("Content-Type: audio/mpeg")
+        .addHeader("icy-br:128")
+        .addHeader("ice-audio-info: bitrate=128;samplerate=44100;channels=2")
+        .addHeader("icy-br:128")
+        .addHeader("icy-description:Rock")
+        .addHeader("icy-genre:riders")
+        .addHeader("icy-name:A2RRock")
+        .addHeader("icy-pub:1")
+        .addHeader("icy-url:http://www.A2Rradio.com")
+        .addHeader("Server: Icecast 2.3.3-kh8")
+        .addHeader("Cache-Control: no-cache")
+        .addHeader("Pragma: no-cache")
+        .addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT")
+        .addHeader("icy-metaint:16000")
+        .setBody("mp3 data"));
+    connection = client.open(server.getUrl("/"));
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("OK", connection.getResponseMessage());
+    assertContent("mp3 data", connection);
+  }
+
   @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.setFixedLengthStreamingMode(-2);
       fail();
@@ -1319,15 +1529,13 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
   }
 
   @Test public void canSetNegativeChunkedStreamingMode() throws Exception {
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setChunkedStreamingMode(-2);
   }
 
   @Test public void cannotSetFixedLengthStreamingModeAfterConnect() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     try {
       connection.setFixedLengthStreamingMode(1);
@@ -1338,8 +1546,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
 
   @Test public void cannotSetChunkedStreamingModeAfterConnect() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     try {
       connection.setChunkedStreamingMode(1);
@@ -1349,8 +1556,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
   }
 
   @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() throws Exception {
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setChunkedStreamingMode(1);
     try {
       connection.setFixedLengthStreamingMode(1);
@@ -1360,8 +1566,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
   }
 
   @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() throws Exception {
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setFixedLengthStreamingMode(1);
     try {
       connection.setChunkedStreamingMode(1);
@@ -1383,13 +1588,12 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
    * http://code.google.com/p/android/issues/detail?id=12860
    */
   private void testSecureStreamingPost(StreamingMode streamingMode) throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.get().useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("Success!"));
-    server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     if (streamingMode == StreamingMode.FIXED_LENGTH) {
@@ -1426,10 +1630,9 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.enqueue(pleaseAuthenticate);
     // ...then succeed the fourth time
     server.enqueue(new MockResponse().setBody("Successful auth!"));
-    server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     OutputStream outputStream = connection.getOutputStream();
@@ -1461,10 +1664,41 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.enqueue(pleaseAuthenticate);
     // ...then succeed the fourth time
     server.enqueue(new MockResponse().setBody("Successful auth!"));
-    server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
+    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    // no authorization header for the first request...
+    RecordedRequest request = server.takeRequest();
+    assertContainsNoneMatching(request.getHeaders(), "Authorization: Basic .*");
+
+    // ...but the three requests that follow requests include an authorization header
+    for (int i = 0; i < 3; i++) {
+      request = server.takeRequest();
+      assertEquals("GET / HTTP/1.1", request.getRequestLine());
+      assertContains(request.getHeaders(),
+          "Authorization: Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS);
+    }
+  }
+
+  /** https://code.google.com/p/android/issues/detail?id=74026 */
+  @Test public void authenticateWithGetAndTransparentGzip() throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate.");
+    // fail auth three times...
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    // ...then succeed the fourth time
+    MockResponse successfulResponse = new MockResponse()
+        .addHeader("Content-Encoding", "gzip")
+        .setBody(gzip("Successful auth!"));
+    server.enqueue(successfulResponse);
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    connection = client.open(server.getUrl("/"));
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
     // no authorization header for the first request...
@@ -1480,6 +1714,18 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     }
   }
 
+  /** https://github.com/square/okhttp/issues/342 */
+  @Test public void authenticateRealmUppercase() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(401)
+        .addHeader("wWw-aUtHeNtIcAtE: bAsIc rEaLm=\"pRoTeCtEd aReA\"")
+        .setBody("Please authenticate."));
+    server.enqueue(new MockResponse().setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    connection = client.open(server.getUrl("/"));
+    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+  }
+
   @Test public void redirectedWithChunkedEncoding() throws Exception {
     testRedirected(TransferKind.CHUNKED, true);
   }
@@ -1498,7 +1744,6 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     transferKind.setBody(response, "This page has moved!", 10);
     server.enqueue(response);
     server.enqueue(new MockResponse().setBody("This is the new location!"));
-    server.play();
 
     URLConnection connection = client.open(server.getUrl("/"));
     assertEquals("This is the new location!",
@@ -1514,16 +1759,15 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   }
 
   @Test public void redirectedOnHttps() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.get().useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /foo")
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("This is the new location!"));
-    server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    connection = client.open(server.getUrl("/"));
     assertEquals("This is the new location!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1535,16 +1779,15 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   }
 
   @Test public void notRedirectedFromHttpsToHttp() throws IOException, InterruptedException {
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.get().useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: http://anyhost/foo")
         .setBody("This page has moved!"));
-    server.play();
 
-    client.setFollowProtocolRedirects(false);
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    client.client().setFollowSslRedirects(false);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    connection = client.open(server.getUrl("/"));
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1552,27 +1795,23 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: https://anyhost/foo")
         .setBody("This page has moved!"));
-    server.play();
 
-    client.setFollowProtocolRedirects(false);
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    client.client().setFollowSslRedirects(false);
+    connection = client.open(server.getUrl("/"));
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
   @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
-    server2 = new MockWebServer();
     server2.enqueue(new MockResponse().setBody("This is insecure HTTP!"));
-    server2.play();
 
-    server.useHttps(sslContext.getSocketFactory(), false);
+    server.get().useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: " + server2.getUrl("/"))
         .setBody("This page has moved!"));
-    server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    client.setFollowProtocolRedirects(true);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setFollowSslRedirects(true);
     HttpsURLConnection connection = (HttpsURLConnection) client.open(server.getUrl("/"));
     assertContent("This is insecure HTTP!", connection);
     assertNull(connection.getCipherSuite());
@@ -1583,20 +1822,17 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   }
 
   @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
-    server2 = new MockWebServer();
-    server2.useHttps(sslContext.getSocketFactory(), false);
+    server2.get().useHttps(sslContext.getSocketFactory(), false);
     server2.enqueue(new MockResponse().setBody("This is secure HTTPS!"));
-    server2.play();
 
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: " + server2.getUrl("/"))
         .setBody("This page has moved!"));
-    server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    client.setFollowProtocolRedirects(true);
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setFollowSslRedirects(true);
+    connection = client.open(server.getUrl("/"));
     assertContent("This is secure HTTPS!", connection);
     assertFalse(connection instanceof HttpsURLConnection);
   }
@@ -1610,26 +1846,23 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   }
 
   private void redirectToAnotherOriginServer(boolean https) throws Exception {
-    server2 = new MockWebServer();
     if (https) {
-      server.useHttps(sslContext.getSocketFactory(), false);
-      server2.useHttps(sslContext.getSocketFactory(), false);
-      server2.setNpnEnabled(false);
-      client.setSslSocketFactory(sslContext.getSocketFactory());
-      client.setHostnameVerifier(new RecordingHostnameVerifier());
+      server.get().useHttps(sslContext.getSocketFactory(), false);
+      server2.get().useHttps(sslContext.getSocketFactory(), false);
+      server2.get().setProtocolNegotiationEnabled(false);
+      client.client().setSslSocketFactory(sslContext.getSocketFactory());
+      client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     }
 
     server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
     server2.enqueue(new MockResponse().setBody("This is the 2nd server, again!"));
-    server2.play();
 
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: " + server2.getUrl("/").toString())
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("This is the first server again!"));
-    server.play();
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertContent("This is the 2nd server!", connection);
     assertEquals(server2.getUrl("/"), connection.getURL());
 
@@ -1637,8 +1870,8 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
     assertContent("This is the first server again!", client.open(server.getUrl("/")));
     assertContent("This is the 2nd server, again!", client.open(server2.getUrl("/")));
 
-    String server1Host = hostName + ":" + server.getPort();
-    String server2Host = hostName + ":" + server2.getPort();
+    String server1Host = server.get().getHostName() + ":" + server.getPort();
+    String server2Host = server2.get().getHostName() + ":" + server2.getPort();
     assertContains(server.takeRequest().getHeaders(), "Host: " + server1Host);
     assertContains(server2.takeRequest().getHeaders(), "Host: " + server2Host);
     assertEquals("Expected connection reuse", 1, server.takeRequest().getSequenceNumber());
@@ -1647,60 +1880,83 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
 
   @Test public void redirectWithProxySelector() throws Exception {
     final List<URI> proxySelectionRequests = new ArrayList<URI>();
-    client.setProxySelector(new ProxySelector() {
+    client.client().setProxySelector(new ProxySelector() {
       @Override public List<Proxy> select(URI uri) {
         proxySelectionRequests.add(uri);
-        MockWebServer proxyServer = (uri.getPort() == server.getPort()) ? server : server2;
+        MockWebServer proxyServer = (uri.getPort() == server.get().getPort())
+            ? server.get()
+            : server2.get();
         return Arrays.asList(proxyServer.toProxyAddress());
       }
+
       @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
         throw new AssertionError();
       }
     });
 
-    server2 = new MockWebServer();
     server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
-    server2.play();
 
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: " + server2.getUrl("/b").toString())
         .setBody("This page has moved!"));
-    server.play();
 
     assertContent("This is the 2nd server!", client.open(server.getUrl("/a")));
 
     assertEquals(Arrays.asList(server.getUrl("/a").toURI(), server2.getUrl("/b").toURI()),
         proxySelectionRequests);
+  }
+
+  @Test public void redirectWithAuthentication() throws Exception {
+    server2.enqueue(new MockResponse().setBody("Page 2"));
+
+    server.enqueue(new MockResponse().setResponseCode(401));
+    server.enqueue(new MockResponse().setResponseCode(302)
+        .addHeader("Location: " + server2.getUrl("/b")));
 
-    server2.shutdown();
+    client.client().setAuthenticator(
+        new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")));
+    assertContent("Page 2", client.open(server.getUrl("/a")));
+
+    RecordedRequest redirectRequest = server2.takeRequest();
+    assertContainsNoneMatching(redirectRequest.getHeaders(), "Authorization.*");
+    assertEquals("/b", redirectRequest.getPath());
   }
 
   @Test public void response300MultipleChoiceWithPost() throws Exception {
     // Chrome doesn't follow the redirect, but Firefox and the RI both do
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MULT_CHOICE);
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MULT_CHOICE, TransferKind.END_OF_STREAM);
   }
 
   @Test public void response301MovedPermanentlyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_PERM);
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_PERM, TransferKind.END_OF_STREAM);
   }
 
   @Test public void response302MovedTemporarilyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP);
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.END_OF_STREAM);
   }
 
   @Test public void response303SeeOtherWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_SEE_OTHER);
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_SEE_OTHER, TransferKind.END_OF_STREAM);
   }
 
-  private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(redirectCode)
-        .addHeader("Location: /page2")
-        .setBody("This page has moved!"));
+  @Test public void postRedirectToGetWithChunkedRequest() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.CHUNKED);
+  }
+
+  @Test public void postRedirectToGetWithStreamedRequest() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.FIXED_LENGTH);
+  }
+
+  private void testResponseRedirectedWithPost(int redirectCode, TransferKind transferKind)
+      throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(redirectCode)
+        .addHeader("Location: /page2")
+        .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("Page 2"));
-    server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/page1"));
+    connection = client.open(server.getUrl("/page1"));
     connection.setDoOutput(true);
+    transferKind.setForRequest(connection, 4);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     OutputStream outputStream = connection.getOutputStream();
     outputStream.write(requestBody);
@@ -1717,13 +1973,11 @@ private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
   }
 
   @Test public void redirectedPostStripsRequestBodyHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /page2"));
     server.enqueue(new MockResponse().setBody("Page 2"));
-    server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/page1"));
+    connection = client.open(server.getUrl("/page1"));
     connection.setDoOutput(true);
     connection.addRequestProperty("Content-Length", "4");
     connection.addRequestProperty("Content-Type", "text/plain; charset=utf-8");
@@ -1737,19 +1991,18 @@ private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
 
     RecordedRequest page2 = server.takeRequest();
     assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
-    assertContainsNoneMatching(page2.getHeaders(), "Content-Length");
-    assertContains(page2.getHeaders(), "Content-Type: text/plain; charset=utf-8");
-    assertContains(page2.getHeaders(), "Transfer-Encoding: identity");
+    assertContainsNoneMatching(page2.getHeaders(), "Content-Length.*");
+    assertContainsNoneMatching(page2.getHeaders(), "Content-Type.*");
+    assertContainsNoneMatching(page2.getHeaders(), "Transfer-Encoding.*");
   }
 
   @Test public void response305UseProxy() throws Exception {
-    server.play();
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_USE_PROXY)
         .addHeader("Location: " + server.getUrl("/"))
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("Proxy Response"));
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     // Fails on the RI, which gets "Proxy Response"
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1759,33 +2012,48 @@ private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
   }
 
   @Test public void response307WithGet() throws Exception {
-    test307Redirect("GET");
+    testRedirect(true, "GET");
   }
 
   @Test public void response307WithHead() throws Exception {
-    test307Redirect("HEAD");
+    testRedirect(true, "HEAD");
   }
 
   @Test public void response307WithOptions() throws Exception {
-    test307Redirect("OPTIONS");
+    testRedirect(true, "OPTIONS");
   }
 
   @Test public void response307WithPost() throws Exception {
-    test307Redirect("POST");
+    testRedirect(true, "POST");
+  }
+
+  @Test public void response308WithGet() throws Exception {
+    testRedirect(false, "GET");
+  }
+
+  @Test public void response308WithHead() throws Exception {
+    testRedirect(false, "HEAD");
+  }
+
+  @Test public void response308WithOptions() throws Exception {
+    testRedirect(false, "OPTIONS");
+  }
+
+  @Test public void response308WithPost() throws Exception {
+    testRedirect(false, "POST");
   }
 
-  private void test307Redirect(String method) throws Exception {
+  private void testRedirect(boolean temporary, String method) throws Exception {
     MockResponse response1 = new MockResponse()
-        .setResponseCode(HttpURLConnectionImpl.HTTP_TEMP_REDIRECT)
+        .setResponseCode(temporary ? HTTP_TEMP_REDIRECT : HTTP_PERM_REDIRECT)
         .addHeader("Location: /page2");
     if (!method.equals("HEAD")) {
       response1.setBody("This page has moved!");
     }
     server.enqueue(response1);
     server.enqueue(new MockResponse().setBody("Page 2"));
-    server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/page1"));
+    connection = client.open(server.getUrl("/page1"));
     connection.setRequestMethod(method);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     if (method.equals("POST")) {
@@ -1801,9 +2069,9 @@ private void test307Redirect(String method) throws Exception {
     assertEquals(method + " /page1 HTTP/1.1", page1.getRequestLine());
 
     if (method.equals("GET")) {
-        assertEquals("Page 2", response);
+      assertEquals("Page 2", response);
     } else if (method.equals("HEAD"))  {
-        assertEquals("", response);
+      assertEquals("", response);
     } else {
       // Methods other than GET/HEAD shouldn't follow the redirect
       if (method.equals("POST")) {
@@ -1829,9 +2097,8 @@ private void test307Redirect(String method) throws Exception {
           .setBody("Redirecting to /" + (i + 1)));
     }
     server.enqueue(new MockResponse().setBody("Success!"));
-    server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/0"));
+    connection = client.open(server.getUrl("/0"));
     assertContent("Success!", connection);
     assertEquals(server.getUrl("/20"), connection.getURL());
   }
@@ -1842,15 +2109,14 @@ private void test307Redirect(String method) throws Exception {
           .addHeader("Location: /" + (i + 1))
           .setBody("Redirecting to /" + (i + 1)));
     }
-    server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/0"));
+    connection = client.open(server.getUrl("/0"));
     try {
       connection.getInputStream();
       fail();
     } catch (ProtocolException expected) {
       assertEquals(HttpURLConnection.HTTP_MOVED_TEMP, connection.getResponseCode());
-      assertEquals("Too many redirects: 21", expected.getMessage());
+      assertEquals("Too many follow-up requests: 21", expected.getMessage());
       assertContent("Redirecting to /21", connection);
       assertEquals(server.getUrl("/20"), connection.getURL());
     }
@@ -1862,21 +2128,22 @@ private void test307Redirect(String method) throws Exception {
     SSLContext sc = SSLContext.getInstance("TLS");
     sc.init(null, new TrustManager[] { trustManager }, new java.security.SecureRandom());
 
-    client.setHostnameVerifier(hostnameVerifier);
-    client.setSslSocketFactory(sc.getSocketFactory());
-    server.useHttps(sslContext.getSocketFactory(), false);
+    client.client().setHostnameVerifier(hostnameVerifier);
+    client.client().setSslSocketFactory(sc.getSocketFactory());
+    server.get().useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
     server.enqueue(new MockResponse().setBody("GHI"));
-    server.play();
 
     URL url = server.getUrl("/");
     assertContent("ABC", client.open(url));
     assertContent("DEF", client.open(url));
     assertContent("GHI", client.open(url));
 
-    assertEquals(Arrays.asList("verify " + hostName), hostnameVerifier.calls);
-    assertEquals(Arrays.asList("checkServerTrusted [CN=" + hostName + " 1]"), trustManager.calls);
+    assertEquals(Arrays.asList("verify " + server.get().getHostName()),
+        hostnameVerifier.calls);
+    assertEquals(Arrays.asList("checkServerTrusted [CN=" + server.get().getHostName() + " 1]"),
+        trustManager.calls);
   }
 
   @Test public void readTimeouts() throws IOException {
@@ -1887,30 +2154,64 @@ private void test307Redirect(String method) throws Exception {
         new MockResponse().setBody("ABC").clearHeaders().addHeader("Content-Length: 4");
     server.enqueue(timeout);
     server.enqueue(new MockResponse().setBody("unused")); // to keep the server alive
-    server.play();
 
-    URLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.setReadTimeout(1000);
-    InputStream in = urlConnection.getInputStream();
+    URLConnection connection = client.open(server.getUrl("/"));
+    connection.setReadTimeout(1000);
+    InputStream in = connection.getInputStream();
     assertEquals('A', in.read());
     assertEquals('B', in.read());
     assertEquals('C', in.read());
     try {
       in.read(); // if Content-Length was accurate, this would return -1 immediately
       fail();
-    } catch (SocketTimeoutException expected) {
+    } catch (IOException expected) {
+    }
+  }
+
+  /** Confirm that an unacknowledged write times out. */
+  @Test public void writeTimeouts() throws IOException {
+    // Sockets on some platforms can have large buffers that mean writes do not block when
+    // required. These socket factories explicitly set the buffer sizes on sockets created.
+    final int SOCKET_BUFFER_SIZE = 256 * 1024;
+    server.get().setServerSocketFactory(
+        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
+          @Override
+          protected void configureServerSocket(ServerSocket serverSocket) throws IOException {
+            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+          }
+        });
+    client.client().setSocketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+      @Override
+      protected void configureSocket(Socket socket) throws IOException {
+        socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+        socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+      }
+    });
+
+    server.enqueue(new MockResponse()
+        .throttleBody(1, 1, TimeUnit.SECONDS)); // Prevent the server from reading!
+
+    client.client().setWriteTimeout(500, TimeUnit.MILLISECONDS);
+    connection = client.open(server.getUrl("/"));
+    connection.setDoOutput(true);
+    connection.setChunkedStreamingMode(0);
+    OutputStream out = connection.getOutputStream();
+    try {
+      byte[] data = new byte[16 * 1024 * 1024]; // 16 MiB.
+      out.write(data);
+      fail();
+    } catch (IOException expected) {
     }
   }
 
   @Test public void setChunkedEncodingAsRequestProperty() throws IOException, InterruptedException {
     server.enqueue(new MockResponse());
-    server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.setRequestProperty("Transfer-encoding", "chunked");
-    urlConnection.setDoOutput(true);
-    urlConnection.getOutputStream().write("ABC".getBytes("UTF-8"));
-    assertEquals(200, urlConnection.getResponseCode());
+    connection = client.open(server.getUrl("/"));
+    connection.setRequestProperty("Transfer-encoding", "chunked");
+    connection.setDoOutput(true);
+    connection.getOutputStream().write("ABC".getBytes("UTF-8"));
+    assertEquals(200, connection.getResponseCode());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("ABC", new String(request.getBody(), "UTF-8"));
@@ -1919,7 +2220,6 @@ private void test307Redirect(String method) throws Exception {
   @Test public void connectionCloseInRequest() throws IOException, InterruptedException {
     server.enqueue(new MockResponse()); // server doesn't honor the connection: close header!
     server.enqueue(new MockResponse());
-    server.play();
 
     HttpURLConnection a = client.open(server.getUrl("/"));
     a.setRequestProperty("Connection", "close");
@@ -1936,7 +2236,6 @@ private void test307Redirect(String method) throws Exception {
   @Test public void connectionCloseInResponse() throws IOException, InterruptedException {
     server.enqueue(new MockResponse().addHeader("Connection: close"));
     server.enqueue(new MockResponse());
-    server.play();
 
     HttpURLConnection a = client.open(server.getUrl("/"));
     assertEquals(200, a.getResponseCode());
@@ -1955,7 +2254,6 @@ private void test307Redirect(String method) throws Exception {
         .addHeader("Connection: close");
     server.enqueue(response);
     server.enqueue(new MockResponse().setBody("This is the new location!"));
-    server.play();
 
     URLConnection connection = client.open(server.getUrl("/"));
     assertEquals("This is the new location!",
@@ -1975,7 +2273,6 @@ private void test307Redirect(String method) throws Exception {
         .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
         .addHeader("Location: /foo"));
     server.enqueue(new MockResponse().setBody("This is the new page!"));
-    server.play();
 
     assertContent("This is the new page!", client.open(server.getUrl("/")));
 
@@ -1986,7 +2283,6 @@ private void test307Redirect(String method) throws Exception {
   @Test public void responseCodeDisagreesWithHeaders() throws IOException, InterruptedException {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
         .setBody("This body is not allowed!"));
-    server.play();
 
     URLConnection connection = client.open(server.getUrl("/"));
     assertEquals("This body is not allowed!",
@@ -1994,10 +2290,9 @@ private void test307Redirect(String method) throws Exception {
   }
 
   @Test public void singleByteReadIsSigned() throws IOException {
-    server.enqueue(new MockResponse().setBody(new byte[] { -2, -1 }));
-    server.play();
+    server.enqueue(new MockResponse().setBody(new Buffer().writeByte(-2).writeByte(-1)));
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals(254, in.read());
     assertEquals(255, in.read());
@@ -2023,9 +2318,8 @@ private void test307Redirect(String method) throws Exception {
    */
   private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setBody("abc"));
-    server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] upload = "def".getBytes("UTF-8");
 
@@ -2039,7 +2333,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     out.write(upload);
     assertEquals("abc", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
-    out.flush(); // dubious but permitted
+    out.flush(); // Dubious but permitted.
     try {
       out.write("ghi".getBytes("UTF-8"));
       fail();
@@ -2048,15 +2342,9 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void getHeadersThrows() throws IOException {
-    // Enqueue a response for every IP address held by localhost, because the route selector
-    // will try each in sequence.
-    // TODO: use the fake Dns implementation instead of a loop
-    for (InetAddress inetAddress : InetAddress.getAllByName(server.getHostName())) {
-      server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
-    }
-    server.play();
+    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.getInputStream();
       fail();
@@ -2071,7 +2359,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void dnsFailureThrowsIOException() throws IOException {
-    HttpURLConnection connection = client.open(new URL("http://host.unlikelytld"));
+    connection = client.open(new URL("http://host.unlikelytld"));
     try {
       connection.connect();
       fail();
@@ -2080,7 +2368,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
-    HttpURLConnection connection = client.open(new URL("http:///foo.html"));
+    connection = client.open(new URL("http:///foo.html"));
     try {
       connection.connect();
       fail();
@@ -2089,17 +2377,14 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void getKeepAlive() throws Exception {
-    MockWebServer server = new MockWebServer();
     server.enqueue(new MockResponse().setBody("ABC"));
-    server.play();
 
     // The request should work once and then fail
-    URLConnection connection1 = client.open(server.getUrl(""));
+    HttpURLConnection connection1 = client.open(server.getUrl(""));
     connection1.setReadTimeout(100);
     InputStream input = connection1.getInputStream();
     assertEquals("ABC", readAscii(input, Integer.MAX_VALUE));
-    input.close();
-    server.shutdown();
+    server.get().shutdown();
     try {
       HttpURLConnection connection2 = client.open(server.getUrl(""));
       connection2.setReadTimeout(100);
@@ -2109,47 +2394,14 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     }
   }
 
-  /** Don't explode if the cache returns a null body. http://b/3373699 */
-  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
-    final AtomicBoolean aborted = new AtomicBoolean();
-    client.setResponseCache(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        return null;
-      }
-
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        return new CacheRequest() {
-          @Override public void abort() {
-            aborted.set(true);
-          }
-
-          @Override public OutputStream getBody() throws IOException {
-            return null;
-          }
-        };
-      }
-    });
-
-    server.enqueue(new MockResponse().setBody("abcdef"));
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    InputStream in = connection.getInputStream();
-    assertEquals("abc", readAscii(in, 3));
-    in.close();
-    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
-  }
-
   /** http://code.google.com/p/android/issues/detail?id=14562 */
   @Test public void readAfterLastByte() throws Exception {
     server.enqueue(new MockResponse().setBody("ABC")
         .clearHeaders()
         .addHeader("Connection: close")
         .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-    server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals("ABC", readAscii(in, 3));
     assertEquals(-1, in.read());
@@ -2158,16 +2410,14 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
 
   @Test public void getContent() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = (InputStream) connection.getContent();
     assertEquals("A", readAscii(in, Integer.MAX_VALUE));
   }
 
   @Test public void getContentOfType() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.getContent(null);
       fail();
@@ -2178,14 +2428,12 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
       fail();
     } catch (NullPointerException expected) {
     }
-    assertNull(connection.getContent(new Class[] { getClass() }));
-    connection.disconnect();
+    assertNull(connection.getContent(new Class[]{getClass()}));
   }
 
   @Test public void getOutputStreamOnGetFails() throws Exception {
     server.enqueue(new MockResponse());
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.getOutputStream();
       fail();
@@ -2195,8 +2443,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
 
   @Test public void getOutputAfterGetInputStreamFails() throws Exception {
     server.enqueue(new MockResponse());
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     try {
       connection.getInputStream();
@@ -2208,8 +2455,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
 
   @Test public void setDoOutputOrDoInputAfterConnectFails() throws Exception {
     server.enqueue(new MockResponse());
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.connect();
     try {
       connection.setDoOutput(true);
@@ -2221,13 +2467,11 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
       fail();
     } catch (IllegalStateException expected) {
     }
-    connection.disconnect();
   }
 
   @Test public void clientSendsContentLength() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     OutputStream out = connection.getOutputStream();
     out.write(new byte[] { 'A', 'B', 'C' });
@@ -2239,38 +2483,43 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
 
   @Test public void getContentLengthConnects() throws Exception {
     server.enqueue(new MockResponse().setBody("ABC"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals(3, connection.getContentLength());
-    connection.disconnect();
   }
 
   @Test public void getContentTypeConnects() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("ABC"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("text/plain", connection.getContentType());
-    connection.disconnect();
   }
 
   @Test public void getContentEncodingConnects() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Encoding: identity").setBody("ABC"));
-    server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("identity", connection.getContentEncoding());
-    connection.disconnect();
   }
 
   // http://b/4361656
   @Test public void urlContainsQueryButNoPath() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-    URL url = new URL("http", server.getHostName(), server.getPort(), "?query");
+
+    URL url = new URL("http", server.get().getHostName(), server.getPort(), "?query");
     assertEquals("A", readAscii(client.open(url).getInputStream(), Integer.MAX_VALUE));
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /?query HTTP/1.1", request.getRequestLine());
   }
 
+  @Test public void doOutputForMethodThatDoesntSupportOutput() throws Exception {
+    connection = client.open(server.getUrl("/"));
+    connection.setRequestMethod("HEAD");
+    connection.setDoOutput(true);
+    try {
+      connection.connect();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
   // http://code.google.com/p/android/issues/detail?id=20442
   @Test public void inputStreamAvailableWithChunkedEncoding() throws Exception {
     testInputStreamAvailable(TransferKind.CHUNKED);
@@ -2289,8 +2538,7 @@ private void testInputStreamAvailable(TransferKind transferKind) throws IOExcept
     MockResponse response = new MockResponse();
     transferKind.setBody(response, body, 4);
     server.enqueue(response);
-    server.play();
-    URLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     for (int i = 0; i < body.length(); i++) {
       assertTrue(in.available() >= 0);
@@ -2327,9 +2575,9 @@ private void testInputStreamAvailable(TransferKind transferKind) throws IOExcept
 
   private void reusedConnectionFailsWithPost(TransferKind transferKind, int requestSize)
       throws Exception {
-    server.enqueue(new MockResponse().setBody("A").setSocketPolicy(SHUTDOWN_INPUT_AT_END));
+    server.enqueue(new MockResponse().setBody("A").setSocketPolicy(DISCONNECT_AT_END));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
+    server.enqueue(new MockResponse().setBody("C"));
 
     assertContent("A", client.open(server.getUrl("/a")));
 
@@ -2337,7 +2585,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     byte[] requestBody = new byte[requestSize];
     new Random(0).nextBytes(requestBody);
 
-    HttpURLConnection connection = client.open(server.getUrl("/b"));
+    connection = client.open(server.getUrl("/b"));
     connection.setRequestMethod("POST");
     transferKind.setForRequest(connection, requestBody.length);
     for (int i = 0; i < requestBody.length; i += 1024) {
@@ -2353,11 +2601,35 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertEquals(Arrays.toString(requestBody), Arrays.toString(requestB.getBody()));
   }
 
+  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse().setBody("def"));
+
+    // Seed the connection pool so we have something that can fail.
+    assertContent("abc", client.open(server.getUrl("/")));
+
+    HttpURLConnection post = client.open(server.getUrl("/"));
+    post.setDoOutput(true);
+    post.getOutputStream().write("body!".getBytes(Util.UTF_8));
+    assertContent("def", post);
+
+    RecordedRequest get = server.takeRequest();
+    assertEquals(0, get.getSequenceNumber());
+
+    RecordedRequest post1 = server.takeRequest();
+    assertEquals("body!", post1.getUtf8Body());
+    assertEquals(1, post1.getSequenceNumber());
+
+    RecordedRequest post2 = server.takeRequest();
+    assertEquals("body!", post2.getUtf8Body());
+    assertEquals(0, post2.getSequenceNumber());
+  }
+
   @Test public void fullyBufferedPostIsTooShort() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/b"));
+    connection = client.open(server.getUrl("/b"));
     connection.setRequestProperty("Content-Length", "4");
     connection.setRequestMethod("POST");
     OutputStream out = connection.getOutputStream();
@@ -2373,9 +2645,8 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
   @Test public void fullyBufferedPostIsTooLong() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/b"));
+    connection = client.open(server.getUrl("/b"));
     connection.setRequestProperty("Content-Length", "3");
     connection.setRequestMethod("POST");
     OutputStream out = connection.getOutputStream();
@@ -2384,6 +2655,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     out.write('c');
     try {
       out.write('d');
+      out.flush();
       fail();
     } catch (IOException expected) {
     }
@@ -2415,27 +2687,24 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
   @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
-    server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.addRequestProperty("B", "");
-    assertContent("body", urlConnection);
-    assertEquals("", urlConnection.getRequestProperty("B"));
+    connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("B", "");
+    assertContent("body", connection);
+    assertEquals("", connection.getRequestProperty("B"));
   }
 
   @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().addHeader("A:").setBody("body"));
-    server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    assertContent("body", urlConnection);
-    assertEquals("", urlConnection.getHeaderField("A"));
+    connection = client.open(server.getUrl("/"));
+    assertContent("body", connection);
+    assertEquals("", connection.getHeaderField("A"));
   }
 
   @Test public void emptyRequestHeaderNameIsStrict() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
-    server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.setRequestProperty("", "A");
+      connection.setRequestProperty("", "A");
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -2443,10 +2712,9 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
   @Test public void emptyResponseHeaderNameIsLenient() throws Exception {
     server.enqueue(new MockResponse().addHeader(":A").setBody("body"));
-    server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.getResponseCode();
-    assertEquals("A", urlConnection.getHeaderField(""));
+    connection = client.open(server.getUrl("/"));
+    connection.getResponseCode();
+    assertEquals("A", connection.getHeaderField(""));
   }
 
   @Test @Ignore public void deflateCompression() {
@@ -2461,59 +2729,217 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     fail("TODO");
   }
 
-  @Test public void customAuthenticator() throws Exception {
+  @Test public void customBasicAuthenticator() throws Exception {
     MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
         .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
         .setBody("Please authenticate.");
     server.enqueue(pleaseAuthenticate);
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
 
-    Credential credential = Credential.basic("jesse", "peanutbutter");
+    String credential = Credentials.basic("jesse", "peanutbutter");
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential);
-    client.setAuthenticator(authenticator);
+    client.client().setAuthenticator(authenticator);
     assertContent("A", client.open(server.getUrl("/private")));
 
     assertContainsNoneMatching(server.takeRequest().getHeaders(), "Authorization: .*");
     assertContains(server.takeRequest().getHeaders(),
-        "Authorization: " + credential.getHeaderValue());
+        "Authorization: " + credential);
 
-    assertEquals(1, authenticator.calls.size());
-    String call = authenticator.calls.get(0);
-    assertTrue(call, call.contains("proxy=DIRECT"));
-    assertTrue(call, call.contains("url=" + server.getUrl("/private")));
-    assertTrue(call, call.contains("challenges=[Basic realm=\"protected area\"]"));
+    assertEquals(Proxy.NO_PROXY, authenticator.onlyProxy());
+    Response response = authenticator.onlyResponse();
+    assertEquals("/private", response.request().url().getPath());
+    assertEquals(Arrays.asList(new Challenge("Basic", "protected area")), response.challenges());
   }
+  
+  @Test public void customTokenAuthenticator() throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
+            .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
+            .setBody("Please authenticate.");
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(new MockResponse().setBody("A"));
+
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator("oauthed abc123");
+    client.client().setAuthenticator(authenticator);
+    assertContent("A", client.open(server.getUrl("/private")));
+
+    assertContainsNoneMatching(server.takeRequest().getHeaders(), "Authorization: .*");
+    assertContains(server.takeRequest().getHeaders(), "Authorization: oauthed abc123");
+
+    Response response = authenticator.onlyResponse();
+    assertEquals("/private", response.request().url().getPath());
+    assertEquals(Arrays.asList(new Challenge("Bearer", "oauthed")), response.challenges());
+  }
+
+  @Test public void authenticateCallsTrackedAsRedirects() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\""));
+    server.enqueue(new MockResponse().setBody("c"));
+
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
+        Credentials.basic("jesse", "peanutbutter"));
+    client.client().setAuthenticator(authenticator);
+    assertContent("c", client.open(server.getUrl("/a")));
+
+    Response challengeResponse = authenticator.responses.get(0);
+    assertEquals("/b", challengeResponse.request().url().getPath());
+
+    Response redirectedBy = challengeResponse.priorResponse();
+    assertEquals("/a", redirectedBy.request().url().getPath());
+  }
+
+  @Test public void attemptAuthorization20Times() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse().setResponseCode(401));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
 
-  @Test public void setTransports() throws Exception {
+    String credential = Credentials.basic("jesse", "peanutbutter");
+    client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
+
+    connection = client.open(server.getUrl("/0"));
+    assertContent("Success!", connection);
+  }
+
+  @Test public void doesNotAttemptAuthorization21Times() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse().setResponseCode(401));
+    }
+
+    String credential = Credentials.basic("jesse", "peanutbutter");
+    client.client().setAuthenticator(new RecordingOkAuthenticator(credential));
+
+    connection = client.open(server.getUrl("/"));
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (ProtocolException expected) {
+      assertEquals(401, connection.getResponseCode());
+      assertEquals("Too many follow-up requests: 21", expected.getMessage());
+    }
+  }
+
+  @Test public void setsNegotiatedProtocolHeader_SPDY_3() throws Exception {
+    setsNegotiatedProtocolHeader(Protocol.SPDY_3);
+  }
+
+  @Test public void setsNegotiatedProtocolHeader_HTTP_2() throws Exception {
+    setsNegotiatedProtocolHeader(Protocol.HTTP_2);
+  }
+
+  private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException {
+    enableProtocol(protocol);
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
-    client.setTransports(Arrays.asList("http/1.1"));
+    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
+    connection = client.open(server.getUrl("/"));
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    assertEquals(Arrays.asList(protocol.toString()), protocolValues);
+    assertContent("A", connection);
+  }
+
+  @Test public void http10SelectedProtocol() throws Exception {
+    server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 OK"));
+    connection = client.open(server.getUrl("/"));
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    assertEquals(Arrays.asList("http/1.0"), protocolValues);
+  }
+
+  @Test public void http11SelectedProtocol() throws Exception {
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
+    connection = client.open(server.getUrl("/"));
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    assertEquals(Arrays.asList("http/1.1"), protocolValues);
+  }
+
+  /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
+  @Test public void zeroLengthPost() throws IOException, InterruptedException {
+    zeroLengthPayload("POST");
+  }
+
+  @Test public void zeroLengthPost_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    zeroLengthPost();
+  }
+
+  @Test public void zeroLengthPost_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    zeroLengthPost();
+  }
+
+  /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
+  @Test public void zeroLengthPut() throws IOException, InterruptedException {
+    zeroLengthPayload("PUT");
+  }
+
+  @Test public void zeroLengthPut_SPDY_3() throws Exception {
+    enableProtocol(Protocol.SPDY_3);
+    zeroLengthPut();
+  }
+
+  @Test public void zeroLengthPut_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    zeroLengthPut();
+  }
+
+  private void zeroLengthPayload(String method)
+      throws IOException, InterruptedException {
+    server.enqueue(new MockResponse());
+    connection = client.open(server.getUrl("/"));
+    connection.setRequestProperty("Content-Length", "0");
+    connection.setRequestMethod(method);
+    connection.setFixedLengthStreamingMode(0);
+    connection.setDoOutput(true);
+    assertContent("", connection);
+    RecordedRequest zeroLengthPayload = server.takeRequest();
+    assertEquals(method, zeroLengthPayload.getMethod());
+    assertEquals("0", zeroLengthPayload.getHeader("content-length"));
+    assertEquals(0L, zeroLengthPayload.getBodySize());
+  }
+
+  @Test public void unspecifiedRequestBodyContentTypeGetsDefault() throws Exception {
+    server.enqueue(new MockResponse());
+
+    connection = client.open(server.getUrl("/"));
+    connection.setDoOutput(true);
+    connection.getOutputStream().write("abc".getBytes(UTF_8));
+    assertEquals(200, connection.getResponseCode());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("application/x-www-form-urlencoded", request.getHeader("Content-Type"));
+    assertEquals("3", request.getHeader("Content-Length"));
+    assertEquals("abc", request.getUtf8Body());
+  }
+
+  @Test public void setProtocols() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    client.client().setProtocols(Arrays.asList(Protocol.HTTP_1_1));
     assertContent("A", client.open(server.getUrl("/")));
   }
 
-  @Test public void setTransportsWithoutHttp11() throws Exception {
+  @Test public void setProtocolsWithoutHttp11() throws Exception {
     try {
-      client.setTransports(Arrays.asList("spdy/3"));
+      client.client().setProtocols(Arrays.asList(Protocol.SPDY_3));
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
-  @Test public void setTransportsWithNull() throws Exception {
+  @Test public void setProtocolsWithNull() throws Exception {
     try {
-      client.setTransports(Arrays.asList("http/1.1", null));
+      client.client().setProtocols(Arrays.asList(Protocol.HTTP_1_1, null));
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
   @Test public void veryLargeFixedLengthRequest() throws Exception {
-    server.setBodyLimit(0);
+    server.get().setBodyLimit(0);
     server.enqueue(new MockResponse());
-    server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     long contentLength = Integer.MAX_VALUE + 1L;
     connection.setFixedLengthStreamingMode(contentLength);
@@ -2530,27 +2956,126 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertEquals(Long.toString(contentLength), request.getHeader("Content-Length"));
   }
 
+  /**
+   * We had a bug where we attempted to gunzip responses that didn't have a
+   * body. This only came up with 304s since that response code can include
+   * headers (like "Content-Encoding") without any content to go along with it.
+   * https://github.com/square/okhttp/issues/358
+   */
+  @Test public void noTransparentGzipFor304NotModified() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection1.getResponseCode());
+    assertContent("", connection1);
+
+    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+    assertContent("b", connection2);
+
+    RecordedRequest requestA = server.takeRequest();
+    assertEquals(0, requestA.getSequenceNumber());
+
+    RecordedRequest requestB = server.takeRequest();
+    assertEquals(1, requestB.getSequenceNumber());
+  }
+
+  /**
+   * We had a bug where we weren't closing Gzip streams on redirects.
+   * https://github.com/square/okhttp/issues/441
+   */
+  @Test public void gzipWithRedirectAndConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("Moved! Moved! Moved!")));
+    server.enqueue(new MockResponse().setBody("This is the new page!"));
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertContent("This is the new page!", connection);
+
+    RecordedRequest requestA = server.takeRequest();
+    assertEquals(0, requestA.getSequenceNumber());
+
+    RecordedRequest requestB = server.takeRequest();
+    assertEquals(1, requestB.getSequenceNumber());
+  }
+
+  /**
+   * The RFC is unclear in this regard as it only specifies that this should
+   * invalidate the cache entry (if any).
+   */
+  @Test public void bodyPermittedOnDelete() throws Exception {
+    server.enqueue(new MockResponse());
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection.setRequestMethod("DELETE");
+    connection.setDoOutput(true);
+    connection.getOutputStream().write("BODY".getBytes(UTF_8));
+    assertEquals(200, connection.getResponseCode());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("DELETE", request.getMethod());
+    assertEquals("BODY", new String(request.getBody(), UTF_8));
+  }
+
+  @Test public void userAgentPicksUpHttpAgentSystemProperty() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    System.setProperty("http.agent", "foo");
+    assertContent("abc", client.open(server.getUrl("/")));
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("foo", request.getHeader("User-Agent"));
+  }
+
+  @Test public void userAgentDefaultsToJavaVersion() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    assertContent("abc", client.open(server.getUrl("/")));
+
+    RecordedRequest request = server.takeRequest();
+    assertTrue(request.getHeader("User-Agent").startsWith("Java"));
+  }
+
+  @Test public void interceptorsNotInvoked() throws Exception {
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        throw new AssertionError();
+      }
+    };
+    client.client().interceptors().add(interceptor);
+    client.client().networkInterceptors().add(interceptor);
+
+    server.enqueue(new MockResponse().setBody("abc"));
+    assertContent("abc", client.open(server.getUrl("/")));
+  }
+
   /** Returns a gzipped copy of {@code bytes}. */
-  public byte[] gzip(byte[] bytes) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
-    gzippedOut.write(bytes);
-    gzippedOut.close();
-    return bytesOut.toByteArray();
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink gzipSink = Okio.buffer(new GzipSink(result));
+    gzipSink.writeUtf8(data);
+    gzipSink.close();
+    return result;
   }
 
   /**
    * Reads at most {@code limit} characters from {@code in} and asserts that
    * content equals {@code expected}.
    */
-  private void assertContent(String expected, URLConnection connection, int limit)
+  private void assertContent(String expected, HttpURLConnection connection, int limit)
       throws IOException {
     connection.connect();
     assertEquals(expected, readAscii(connection.getInputStream(), limit));
-    ((HttpURLConnection) connection).disconnect();
   }
 
-  private void assertContent(String expected, URLConnection connection) throws IOException {
+  private void assertContent(String expected, HttpURLConnection connection) throws IOException {
     assertContent(expected, connection, Integer.MAX_VALUE);
   }
 
@@ -2572,7 +3097,7 @@ private void assertContainsNoneMatching(List<String> headers, String pattern) {
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize)
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
           throws IOException {
         response.setChunkedBody(content, chunkSize);
       }
@@ -2581,7 +3106,7 @@ private void assertContainsNoneMatching(List<String> headers, String pattern) {
       }
     },
     FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
       }
       @Override void setForRequest(HttpURLConnection connection, int contentLength) {
@@ -2589,7 +3114,7 @@ private void assertContainsNoneMatching(List<String> headers, String pattern) {
       }
     },
     END_OF_STREAM() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
         response.setSocketPolicy(DISCONNECT_AT_END);
         for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
@@ -2603,60 +3128,66 @@ private void assertContainsNoneMatching(List<String> headers, String pattern) {
       }
     };
 
-    abstract void setBody(MockResponse response, byte[] content, int chunkSize) throws IOException;
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
 
     abstract void setForRequest(HttpURLConnection connection, int contentLength);
 
     void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, content.getBytes("UTF-8"), chunkSize);
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
     }
   }
 
   enum ProxyConfig {
     NO_PROXY() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        client.setProxy(Proxy.NO_PROXY);
-        return client.open(url);
+        streamHandlerFactory.client().setProxy(Proxy.NO_PROXY);
+        return streamHandlerFactory.open(url);
       }
     },
 
     CREATE_ARG() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        client.setProxy(server.toProxyAddress());
-        return client.open(url);
+        streamHandlerFactory.client().setProxy(server.toProxyAddress());
+        return streamHandlerFactory.open(url);
       }
     },
 
     PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        System.setProperty("proxyHost", "localhost");
+        System.setProperty("proxyHost", server.getHostName());
         System.setProperty("proxyPort", Integer.toString(server.getPort()));
-        return client.open(url);
+        return streamHandlerFactory.open(url);
       }
     },
 
     HTTP_PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        System.setProperty("http.proxyHost", "localhost");
+        System.setProperty("http.proxyHost", server.getHostName());
         System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
-        return client.open(url);
+        return streamHandlerFactory.open(url);
       }
     },
 
     HTTPS_PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        System.setProperty("https.proxyHost", "localhost");
+        System.setProperty("https.proxyHost", server.getHostName());
         System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
-        return client.open(url);
+        return streamHandlerFactory.open(url);
       }
     };
 
-    public abstract HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+    public abstract HttpURLConnection connect(
+        MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
         throws IOException;
   }
 
@@ -2687,7 +3218,7 @@ private String certificatesToString(X509Certificate[] certificates) {
   }
 
   private static class FakeProxySelector extends ProxySelector {
-    List<Proxy> proxies = new ArrayList<Proxy>();
+    List<Proxy> proxies = new ArrayList<>();
 
     @Override public List<Proxy> select(URI uri) {
       // Don't handle 'socket' schemes, which the RI's Socket class may request (for SOCKS).
@@ -2698,4 +3229,28 @@ private String certificatesToString(X509Certificate[] certificates) {
     @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
     }
   }
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
+   */
+  private void enableProtocol(Protocol protocol) {
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
+    server.get().useHttps(sslContext.getSocketFactory(), false);
+    server.get().setProtocolNegotiationEnabled(true);
+    server.get().setProtocols(client.client().getProtocols());
+  }
+
+  /**
+   * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
+   * TLS_FALLBACK_SCSV cipher on fallback connections. See
+   * {@link com.squareup.okhttp.FallbackTestClientSocketFactory} for details.
+   */
+  private static void suppressTlsFallbackScsv(OkHttpClient client) {
+    FallbackTestClientSocketFactory clientSocketFactory =
+        new FallbackTestClientSocketFactory(sslContext.getSocketFactory());
+    client.setSslSocketFactory(clientSocketFactory);
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
new file mode 100644
index 0000000000..d0b5e97ddb
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.IOException;
+import java.util.List;
+import okio.BufferedSource;
+import okio.ByteString;
+
+import static org.junit.Assert.fail;
+
+class BaseTestHandler implements FrameReader.Handler {
+  @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
+      throws IOException {
+    fail();
+  }
+
+  @Override
+  public void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
+      List<Header> headerBlock, HeadersMode headersMode) {
+    fail();
+  }
+
+  @Override public void rstStream(int streamId, ErrorCode errorCode) {
+    fail();
+  }
+
+  @Override public void settings(boolean clearPrevious, Settings settings) {
+    fail();
+  }
+
+  @Override public void ackSettings() {
+    fail();
+  }
+
+  @Override public void ping(boolean ack, int payload1, int payload2) {
+    fail();
+  }
+
+  @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+    fail();
+  }
+
+  @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
+    fail();
+  }
+
+  @Override public void priority(int streamId, int streamDependency, int weight,
+      boolean exclusive) {
+    fail();
+  }
+
+  @Override
+  public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
+    fail();
+  }
+
+  @Override public void alternateService(int streamId, String origin, ByteString protocol,
+      String host, int port, long maxAge) {
+    fail();
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft10Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft10Test.java
new file mode 100644
index 0000000000..b886a43fdd
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft10Test.java
@@ -0,0 +1,726 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.Before;
+import org.junit.Test;
+
+import static com.squareup.okhttp.TestUtil.headerEntries;
+import static okio.ByteString.decodeHex;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class HpackDraft10Test {
+
+  private final Buffer bytesIn = new Buffer();
+  private HpackDraft10.Reader hpackReader;
+  private Buffer bytesOut = new Buffer();
+  private HpackDraft10.Writer hpackWriter;
+
+  @Before public void reset() {
+    hpackReader = newReader(bytesIn);
+    hpackWriter = new HpackDraft10.Writer(bytesOut);
+  }
+
+  /**
+   * Variable-length quantity special cases strings which are longer than 127
+   * bytes.  Values such as cookies can be 4KiB, and should be possible to send.
+   *
+   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-5.2
+   */
+  @Test public void largeHeaderValue() throws IOException {
+    char[] value = new char[4096];
+    Arrays.fill(value, '!');
+    List<Header> headerBlock = headerEntries("cookie", new String(value));
+
+    hpackWriter.writeHeaders(headerBlock);
+    bytesIn.writeAll(bytesOut);
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  /**
+   * HPACK has a max header table size, which can be smaller than the max header message.
+   * Ensure the larger header content is not lost.
+   */
+  @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
+    bytesIn.writeByte(0x00); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackReader.headerTableSizeSetting(1);
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
+  }
+
+  /** Oldest entries are evicted to support newer ones. */
+  @Test public void testEviction() throws IOException {
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-foo");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-bar");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-baz");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    // Set to only support 110 bytes (enough for 2 headers).
+    hpackReader.headerTableSizeSetting(110);
+    hpackReader.readHeaders();
+
+    assertEquals(2, hpackReader.headerCount);
+
+    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    checkEntry(entry, "custom-bar", "custom-header", 55);
+
+    entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    checkEntry(entry, "custom-baz", "custom-header", 55);
+
+    // Once a header field is decoded and added to the reconstructed header
+    // list, it cannot be removed from it. Hence, foo is here.
+    assertEquals(
+        headerEntries(
+            "custom-foo", "custom-header",
+            "custom-bar", "custom-header",
+            "custom-baz", "custom-header"),
+        hpackReader.getAndResetHeaderList());
+
+    // Simulate receiving a small settings frame, that implies eviction.
+    hpackReader.headerTableSizeSetting(55);
+    assertEquals(1, hpackReader.headerCount);
+  }
+
+  /** Header table backing array is initially 8 long, let's ensure it grows. */
+  @Test public void dynamicallyGrowsBeyond64Entries() throws IOException {
+    for (int i = 0; i < 256; i++) {
+      bytesIn.writeByte(0x40); // Literal indexed
+      bytesIn.writeByte(0x0a); // Literal name (len = 10)
+      bytesIn.writeUtf8("custom-foo");
+
+      bytesIn.writeByte(0x0d); // Literal value (len = 13)
+      bytesIn.writeUtf8("custom-header");
+    }
+
+    hpackReader.headerTableSizeSetting(16384); // Lots of headers need more room!
+    hpackReader.readHeaders();
+
+    assertEquals(256, hpackReader.headerCount);
+  }
+
+  @Test public void huffmanDecodingSupported() throws IOException {
+    bytesIn.writeByte(0x44); // == Literal indexed ==
+                             // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x8c); // Literal value Huffman encoded 12 bytes
+                             // decodes to www.example.com which is length 15
+    bytesIn.write(decodeHex("f1e3c2e5f23a6ba0ab90f4ff"));
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(52, hpackReader.dynamicTableByteCount);
+
+    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    checkEntry(entry, ":path", "www.example.com", 52);
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-C.2.1
+   */
+  @Test public void readLiteralHeaderFieldWithIndexing() throws IOException {
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackReader.readHeaders();
+
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(55, hpackReader.dynamicTableByteCount);
+
+    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    checkEntry(entry, "custom-key", "custom-header", 55);
+
+    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-C.2.2
+   */
+  @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {
+    List<Header> headerBlock = headerEntries(":path", "/sample/path");
+
+    bytesIn.writeByte(0x04); // == Literal not indexed ==
+                             // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("/sample/path");
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(bytesIn, bytesOut);
+
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldWithoutIndexingNewName() throws IOException {
+    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
+
+    bytesIn.writeByte(0x00); // Not indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(bytesIn, bytesOut);
+
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldNeverIndexedIndexedName() throws IOException {
+    bytesIn.writeByte(0x14); // == Literal never indexed ==
+                             // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("/sample/path");
+
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerEntries(":path", "/sample/path"), hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void literalHeaderFieldNeverIndexedNewName() throws IOException {
+    bytesIn.writeByte(0x10); // Never indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
+
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void staticHeaderIsNotCopiedIntoTheIndexedTable() throws IOException {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.headerCount);
+    assertEquals(0, hpackReader.dynamicTableByteCount);
+
+    assertEquals(null, hpackReader.dynamicTable[headerTableLength() - 1]);
+
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndResetHeaderList());
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testUnusedIndex
+  @Test public void readIndexedHeaderFieldIndex0() throws IOException {
+    bytesIn.writeByte(0x80); // == Indexed - Add idx = 0
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("index == 0", e.getMessage());
+    }
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testIllegalIndex
+  @Test public void readIndexedHeaderFieldTooLargeIndex() throws IOException {
+    bytesIn.writeShort(0xff00); // == Indexed - Add idx = 127
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Header index too large 127", e.getMessage());
+    }
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testInsidiousIndex
+  @Test public void readIndexedHeaderFieldInsidiousIndex() throws IOException {
+    bytesIn.writeByte(0xff); // == Indexed - Add ==
+    bytesIn.write(decodeHex("8080808008")); // idx = -2147483521
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Header index too large -2147483521", e.getMessage());
+    }
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testHeaderTableSizeUpdate
+  @Test public void minMaxHeaderTableSize() throws IOException {
+    bytesIn.writeByte(0x20);
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.maxDynamicTableByteCount());
+
+    bytesIn.writeByte(0x3f); // encode size 4096
+    bytesIn.writeByte(0xe1);
+    bytesIn.writeByte(0x1f);
+    hpackReader.readHeaders();
+
+    assertEquals(4096, hpackReader.maxDynamicTableByteCount());
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testIllegalHeaderTableSizeUpdate
+  @Test public void cannotSetTableSizeLargerThanSettingsValue() throws IOException {
+    bytesIn.writeByte(0x3f); // encode size 4097
+    bytesIn.writeByte(0xe2);
+    bytesIn.writeByte(0x1f);
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Invalid dynamic table size update 4097", e.getMessage());
+    }
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testInsidiousMaxHeaderSize
+  @Test public void readHeaderTableStateChangeInsidiousMaxHeaderByteCount() throws IOException {
+    bytesIn.writeByte(0x3f);
+    bytesIn.write(decodeHex("e1ffffff07")); // count = -2147483648
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Invalid dynamic table size update -2147483648", e.getMessage());
+    }
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-C.2.4
+   */
+  @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+
+    hpackReader.headerTableSizeSetting(0); // SETTINGS_HEADER_TABLE_SIZE == 0
+    hpackReader.readHeaders();
+
+    // Not buffered in header table.
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndResetHeaderList());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-C.2
+   */
+  @Test public void readRequestExamplesWithoutHuffman() throws IOException {
+    firstRequestWithoutHuffman();
+    hpackReader.readHeaders();
+    checkReadFirstRequestWithoutHuffman();
+
+    secondRequestWithoutHuffman();
+    hpackReader.readHeaders();
+    checkReadSecondRequestWithoutHuffman();
+
+    thirdRequestWithoutHuffman();
+    hpackReader.readHeaders();
+    checkReadThirdRequestWithoutHuffman();
+  }
+
+  private void firstRequestWithoutHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+                             // idx = 7 -> :scheme: http
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+                             // idx = 6 -> :path: /
+    bytesIn.writeByte(0x41); // == Literal indexed ==
+                             // Indexed name (idx = 4) -> :authority
+    bytesIn.writeByte(0x0f); // Literal value (len = 15)
+    bytesIn.writeUtf8("www.example.com");
+  }
+
+  private void checkReadFirstRequestWithoutHuffman() {
+    assertEquals(1, hpackReader.headerCount);
+
+    // [  1] (s =  57) :authority: www.example.com
+    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 57
+    assertEquals(57, hpackReader.dynamicTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com"), hpackReader.getAndResetHeaderList());
+  }
+
+  private void secondRequestWithoutHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+                             // idx = 7 -> :scheme: http
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+                             // idx = 6 -> :path: /
+    bytesIn.writeByte(0xbe); // == Indexed - Add ==
+                             // Indexed name (idx = 62) -> :authority: www.example.com
+    bytesIn.writeByte(0x58); // == Literal indexed ==
+                             // Indexed name (idx = 24) -> cache-control
+    bytesIn.writeByte(0x08); // Literal value (len = 8)
+    bytesIn.writeUtf8("no-cache");
+  }
+
+  private void checkReadSecondRequestWithoutHuffman() {
+    assertEquals(2, hpackReader.headerCount);
+
+    // [  1] (s =  53) cache-control: no-cache
+    Header entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+
+    // [  2] (s =  57) :authority: www.example.com
+    entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 110
+    assertEquals(110, hpackReader.dynamicTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com",
+        "cache-control", "no-cache"), hpackReader.getAndResetHeaderList());
+  }
+
+  private void thirdRequestWithoutHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x87); // == Indexed - Add ==
+                             // idx = 7 -> :scheme: http
+    bytesIn.writeByte(0x85); // == Indexed - Add ==
+                             // idx = 5 -> :path: /index.html
+    bytesIn.writeByte(0xbf); // == Indexed - Add ==
+                             // Indexed name (idx = 63) -> :authority: www.example.com
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("custom-value");
+  }
+
+  private void checkReadThirdRequestWithoutHuffman() {
+    assertEquals(3, hpackReader.headerCount);
+
+    // [  1] (s =  54) custom-key: custom-value
+    Header entry = hpackReader.dynamicTable[headerTableLength() - 3];
+    checkEntry(entry, "custom-key", "custom-value", 54);
+
+    // [  2] (s =  53) cache-control: no-cache
+    entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+
+    // [  3] (s =  57) :authority: www.example.com
+    entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 164
+    assertEquals(164, hpackReader.dynamicTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "https",
+        ":path", "/index.html",
+        ":authority", "www.example.com",
+        "custom-key", "custom-value"), hpackReader.getAndResetHeaderList());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-C.4
+   */
+  @Test public void readRequestExamplesWithHuffman() throws IOException {
+    firstRequestWithHuffman();
+    hpackReader.readHeaders();
+    checkReadFirstRequestWithHuffman();
+
+    secondRequestWithHuffman();
+    hpackReader.readHeaders();
+    checkReadSecondRequestWithHuffman();
+
+    thirdRequestWithHuffman();
+    hpackReader.readHeaders();
+    checkReadThirdRequestWithHuffman();
+  }
+
+  private void firstRequestWithHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+                             // idx = 6 -> :scheme: http
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+                             // idx = 4 -> :path: /
+    bytesIn.writeByte(0x41); // == Literal indexed ==
+                             // Indexed name (idx = 1) -> :authority
+    bytesIn.writeByte(0x8c); // Literal value Huffman encoded 12 bytes
+                             // decodes to www.example.com which is length 15
+    bytesIn.write(decodeHex("f1e3c2e5f23a6ba0ab90f4ff"));
+  }
+
+  private void checkReadFirstRequestWithHuffman() {
+    assertEquals(1, hpackReader.headerCount);
+
+    // [  1] (s =  57) :authority: www.example.com
+    Header entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 57
+    assertEquals(57, hpackReader.dynamicTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com"), hpackReader.getAndResetHeaderList());
+  }
+
+  private void secondRequestWithHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+                             // idx = 6 -> :scheme: http
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+                             // idx = 4 -> :path: /
+    bytesIn.writeByte(0xbe); // == Indexed - Add ==
+                             // idx = 62 -> :authority: www.example.com
+    bytesIn.writeByte(0x58); // == Literal indexed ==
+                             // Indexed name (idx = 24) -> cache-control
+    bytesIn.writeByte(0x86); // Literal value Huffman encoded 6 bytes
+                             // decodes to no-cache which is length 8
+    bytesIn.write(decodeHex("a8eb10649cbf"));
+  }
+
+  private void checkReadSecondRequestWithHuffman() {
+    assertEquals(2, hpackReader.headerCount);
+
+    // [  1] (s =  53) cache-control: no-cache
+    Header entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+
+    // [  2] (s =  57) :authority: www.example.com
+    entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 110
+    assertEquals(110, hpackReader.dynamicTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com",
+        "cache-control", "no-cache"), hpackReader.getAndResetHeaderList());
+  }
+
+  private void thirdRequestWithHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x87); // == Indexed - Add ==
+                             // idx = 7 -> :scheme: https
+    bytesIn.writeByte(0x85); // == Indexed - Add ==
+                             // idx = 5 -> :path: /index.html
+    bytesIn.writeByte(0xbf); // == Indexed - Add ==
+                             // idx = 63 -> :authority: www.example.com
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x88); // Literal name Huffman encoded 8 bytes
+                             // decodes to custom-key which is length 10
+    bytesIn.write(decodeHex("25a849e95ba97d7f"));
+    bytesIn.writeByte(0x89); // Literal value Huffman encoded 9 bytes
+                             // decodes to custom-value which is length 12
+    bytesIn.write(decodeHex("25a849e95bb8e8b4bf"));
+  }
+
+  private void checkReadThirdRequestWithHuffman() {
+    assertEquals(3, hpackReader.headerCount);
+
+    // [  1] (s =  54) custom-key: custom-value
+    Header entry = hpackReader.dynamicTable[headerTableLength() - 3];
+    checkEntry(entry, "custom-key", "custom-value", 54);
+
+    // [  2] (s =  53) cache-control: no-cache
+    entry = hpackReader.dynamicTable[headerTableLength() - 2];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+
+    // [  3] (s =  57) :authority: www.example.com
+    entry = hpackReader.dynamicTable[headerTableLength() - 1];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+
+    // Table size: 164
+    assertEquals(164, hpackReader.dynamicTableByteCount);
+
+    // Decoded header list:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "https",
+        ":path", "/index.html",
+        ":authority", "www.example.com",
+        "custom-key", "custom-value"), hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void readSingleByteInt() throws IOException {
+    assertEquals(10, newReader(byteStream()).readInt(10, 31));
+    assertEquals(10, newReader(byteStream()).readInt(0xe0 | 10, 31));
+  }
+
+  @Test public void readMultibyteInt() throws IOException {
+    assertEquals(1337, newReader(byteStream(154, 10)).readInt(31, 31));
+  }
+
+  @Test public void writeSingleByteInt() throws IOException {
+    hpackWriter.writeInt(10, 31, 0);
+    assertBytes(10);
+    hpackWriter.writeInt(10, 31, 0xe0);
+    assertBytes(0xe0 | 10);
+  }
+
+  @Test public void writeMultibyteInt() throws IOException {
+    hpackWriter.writeInt(1337, 31, 0);
+    assertBytes(31, 154, 10);
+    hpackWriter.writeInt(1337, 31, 0xe0);
+    assertBytes(0xe0 | 31, 154, 10);
+  }
+
+  @Test public void max31BitValue() throws IOException {
+    hpackWriter.writeInt(0x7fffffff, 31, 0);
+    assertBytes(31, 224, 255, 255, 255, 7);
+    assertEquals(0x7fffffff,
+        newReader(byteStream(224, 255, 255, 255, 7)).readInt(31, 31));
+  }
+
+  @Test public void prefixMask() throws IOException {
+    hpackWriter.writeInt(31, 31, 0);
+    assertBytes(31, 0);
+    assertEquals(31, newReader(byteStream(0)).readInt(31, 31));
+  }
+
+  @Test public void prefixMaskMinusOne() throws IOException {
+    hpackWriter.writeInt(30, 31, 0);
+    assertBytes(30);
+    assertEquals(31, newReader(byteStream(0)).readInt(31, 31));
+  }
+
+  @Test public void zero() throws IOException {
+    hpackWriter.writeInt(0, 31, 0);
+    assertBytes(0);
+    assertEquals(0, newReader(byteStream()).readInt(0, 31));
+  }
+
+  @Test public void lowercaseHeaderNameBeforeEmit() throws IOException {
+    hpackWriter.writeHeaders(Arrays.asList(new Header("FoO", "BaR")));
+    assertBytes(0, 3, 'f', 'o', 'o', 3, 'B', 'a', 'R');
+  }
+
+  @Test public void mixedCaseHeaderNameIsMalformed() throws IOException {
+    try {
+      newReader(byteStream(0, 3, 'F', 'o', 'o', 3, 'B', 'a', 'R')).readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR response malformed: mixed case name: Foo", e.getMessage());
+    }
+  }
+
+  @Test public void emptyHeaderName() throws IOException {
+    hpackWriter.writeByteString(ByteString.encodeUtf8(""));
+    assertBytes(0);
+    assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString());
+  }
+
+  private HpackDraft10.Reader newReader(Buffer source) {
+    return new HpackDraft10.Reader(4096, source);
+  }
+
+  private Buffer byteStream(int... bytes) {
+    return new Buffer().write(intArrayToByteArray(bytes));
+  }
+
+  private void checkEntry(Header entry, String name, String value, int size) {
+    assertEquals(name, entry.name.utf8());
+    assertEquals(value, entry.value.utf8());
+    assertEquals(size, entry.hpackSize);
+  }
+
+  private void assertBytes(int... bytes) throws IOException {
+    ByteString expected = intArrayToByteArray(bytes);
+    ByteString actual = bytesOut.readByteString();
+    assertEquals(expected, actual);
+  }
+
+  private ByteString intArrayToByteArray(int[] bytes) {
+    byte[] data = new byte[bytes.length];
+    for (int i = 0; i < bytes.length; i++) {
+      data[i] = (byte) bytes[i];
+    }
+    return ByteString.of(data);
+  }
+
+  private int headerTableLength() {
+    return hpackReader.dynamicTable.length;
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16FrameLoggerTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16FrameLoggerTest.java
new file mode 100644
index 0000000000..992611f5eb
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16FrameLoggerTest.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_ACK;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_END_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_END_STREAM;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_NONE;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.FrameLogger.formatFlags;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.FrameLogger.formatHeader;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_CONTINUATION;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_DATA;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_GOAWAY;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_PING;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_PUSH_PROMISE;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.TYPE_SETTINGS;
+import static org.junit.Assert.assertEquals;
+
+public class Http20Draft16FrameLoggerTest {
+
+  /** Real stream traffic applied to the log format. */
+  @Test public void exampleStream() {
+    assertEquals(">> 0x00000000     5 SETTINGS      ",
+        formatHeader(false, 0, 5, TYPE_SETTINGS, FLAG_NONE));
+    assertEquals(">> 0x00000003   100 HEADERS       END_HEADERS",
+        formatHeader(false, 3, 100, TYPE_HEADERS, FLAG_END_HEADERS));
+    assertEquals(">> 0x00000003     0 DATA          END_STREAM",
+        formatHeader(false, 3, 0, TYPE_DATA, FLAG_END_STREAM));
+    assertEquals("<< 0x00000000    15 SETTINGS      ",
+        formatHeader(true, 0, 15, TYPE_SETTINGS, FLAG_NONE));
+    assertEquals(">> 0x00000000     0 SETTINGS      ACK",
+        formatHeader(false, 0, 0, TYPE_SETTINGS, FLAG_ACK));
+    assertEquals("<< 0x00000000     0 SETTINGS      ACK",
+        formatHeader(true, 0, 0, TYPE_SETTINGS, FLAG_ACK));
+    assertEquals("<< 0x00000003    22 HEADERS       END_HEADERS",
+        formatHeader(true, 3, 22, TYPE_HEADERS, FLAG_END_HEADERS));
+    assertEquals("<< 0x00000003   226 DATA          END_STREAM",
+        formatHeader(true, 3, 226, TYPE_DATA, FLAG_END_STREAM));
+    assertEquals(">> 0x00000000     8 GOAWAY        ",
+        formatHeader(false, 0, 8, TYPE_GOAWAY, FLAG_NONE));
+  }
+
+  @Test public void flagOverlapOn0x1() {
+    assertEquals("<< 0x00000000     0 SETTINGS      ACK",
+        formatHeader(true, 0, 0, TYPE_SETTINGS, (byte) 0x1));
+    assertEquals("<< 0x00000000     8 PING          ACK",
+        formatHeader(true, 0, 8, TYPE_PING, (byte) 0x1));
+    assertEquals("<< 0x00000003     0 HEADERS       END_STREAM",
+        formatHeader(true, 3, 0, TYPE_HEADERS, (byte) 0x1));
+    assertEquals("<< 0x00000003     0 DATA          END_STREAM",
+        formatHeader(true, 3, 0, TYPE_DATA, (byte) 0x1));
+  }
+
+  @Test public void flagOverlapOn0x4() {
+    assertEquals("<< 0x00000003 10000 HEADERS       END_HEADERS",
+        formatHeader(true, 3, 10000, TYPE_HEADERS, (byte) 0x4));
+    assertEquals("<< 0x00000003 10000 CONTINUATION  END_HEADERS",
+        formatHeader(true, 3, 10000, TYPE_CONTINUATION, (byte) 0x4));
+    assertEquals("<< 0x00000004 10000 PUSH_PROMISE  END_PUSH_PROMISE",
+        formatHeader(true, 4, 10000, TYPE_PUSH_PROMISE, (byte) 0x4));
+  }
+
+  @Test public void flagOverlapOn0x20() {
+    assertEquals("<< 0x00000003 10000 HEADERS       PRIORITY",
+        formatHeader(true, 3, 10000, TYPE_HEADERS, (byte) 0x20));
+    assertEquals("<< 0x00000003 10000 DATA          COMPRESSED",
+        formatHeader(true, 3, 10000, TYPE_DATA, (byte) 0x20));
+  }
+
+  /**
+   * Ensures that valid flag combinations appear visually correct, and invalid show in hex.  This
+   * also demonstrates how sparse the lookup table is.
+   */
+  @Test public void allFormattedFlagsWithValidBits() {
+    List<String> formattedFlags = new ArrayList<>(0x40); // Highest valid flag is 0x20.
+    for (byte i = 0; i < 0x40; i++) formattedFlags.add(formatFlags(TYPE_HEADERS, i));
+
+    assertEquals(Arrays.asList(
+        "",
+        "END_STREAM",
+        "00000010",
+        "00000011",
+        "END_HEADERS",
+        "END_STREAM|END_HEADERS",
+        "00000110",
+        "00000111",
+        "PADDED",
+        "END_STREAM|PADDED",
+        "00001010",
+        "00001011",
+        "00001100",
+        "END_STREAM|END_HEADERS|PADDED",
+        "00001110",
+        "00001111",
+        "00010000",
+        "00010001",
+        "00010010",
+        "00010011",
+        "00010100",
+        "00010101",
+        "00010110",
+        "00010111",
+        "00011000",
+        "00011001",
+        "00011010",
+        "00011011",
+        "00011100",
+        "00011101",
+        "00011110",
+        "00011111",
+        "PRIORITY",
+        "END_STREAM|PRIORITY",
+        "00100010",
+        "00100011",
+        "END_HEADERS|PRIORITY",
+        "END_STREAM|END_HEADERS|PRIORITY",
+        "00100110",
+        "00100111",
+        "00101000",
+        "END_STREAM|PRIORITY|PADDED",
+        "00101010",
+        "00101011",
+        "00101100",
+        "END_STREAM|END_HEADERS|PRIORITY|PADDED",
+        "00101110",
+        "00101111",
+        "00110000",
+        "00110001",
+        "00110010",
+        "00110011",
+        "00110100",
+        "00110101",
+        "00110110",
+        "00110111",
+        "00111000",
+        "00111001",
+        "00111010",
+        "00111011",
+        "00111100",
+        "00111101",
+        "00111110",
+        "00111111"
+    ), formattedFlags);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16Test.java
new file mode 100644
index 0000000000..acf3f1c2f0
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft16Test.java
@@ -0,0 +1,744 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.Test;
+
+import static com.squareup.okhttp.TestUtil.headerEntries;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_COMPRESSED;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_END_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_END_STREAM;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_NONE;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_PADDED;
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.FLAG_PRIORITY;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class Http20Draft16Test {
+  final Buffer frame = new Buffer();
+  final FrameReader fr = new Http20Draft16.Reader(frame, 4096, false);
+  final int expectedStreamId = 15;
+
+  @Test public void unknownFrameTypeSkipped() throws IOException {
+    writeMedium(frame, 4); // has a 4-byte field
+    frame.writeByte(99); // type 99
+    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeInt(expectedStreamId);
+    frame.writeInt(111111111); // custom data
+
+    fr.nextFrame(new BaseTestHandler()); // Should not callback.
+  }
+
+  @Test public void onlyOneLiteralHeadersFrame() throws IOException {
+    final List<Header> sentHeaders = headerEntries("name", "value");
+
+    Buffer headerBytes = literalHeaders(sentHeaders);
+    writeMedium(frame, (int) headerBytes.size());
+    frame.writeByte(Http20Draft16.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_END_STREAM);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBytes);
+
+    assertEquals(frame, sendHeaderFrames(true, sentHeaders)); // Check writer sends the same bytes.
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertTrue(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(sentHeaders, headerBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  @Test public void headersWithPriority() throws IOException {
+    final List<Header> sentHeaders = headerEntries("name", "value");
+
+    Buffer headerBytes = literalHeaders(sentHeaders);
+    writeMedium(frame, (int) (headerBytes.size() + 5));
+    frame.writeByte(Http20Draft16.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_PRIORITY);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(0); // Independent stream.
+    frame.writeByte(255); // Heaviest weight, zero-indexed.
+    frame.writeAll(headerBytes);
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void priority(int streamId, int streamDependency, int weight,
+          boolean exclusive) {
+        assertEquals(0, streamDependency);
+        assertEquals(256, weight);
+        assertFalse(exclusive);
+      }
+
+      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> nameValueBlock,
+          HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(sentHeaders, nameValueBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void headersFrameThenContinuation() throws IOException {
+    final List<Header> sentHeaders = largeHeaders();
+
+    Buffer headerBlock = literalHeaders(sentHeaders);
+
+    // Write the first headers frame.
+    writeMedium(frame, Http20Draft16.INITIAL_MAX_FRAME_SIZE);
+    frame.writeByte(Http20Draft16.TYPE_HEADERS);
+    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.write(headerBlock, Http20Draft16.INITIAL_MAX_FRAME_SIZE);
+
+    // Write the continuation frame, specifying no more frames are expected.
+    writeMedium(frame, (int) headerBlock.size());
+    frame.writeByte(Http20Draft16.TYPE_CONTINUATION);
+    frame.writeByte(FLAG_END_HEADERS);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBlock);
+
+    assertEquals(frame, sendHeaderFrames(false, sentHeaders)); // Check writer sends the same bytes.
+
+    // Reading the above frames should result in a concatenated headerBlock.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(sentHeaders, headerBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  @Test public void pushPromise() throws IOException {
+    final int expectedPromisedStreamId = 11;
+
+    final List<Header> pushPromise = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/")
+    );
+
+    // Write the push promise frame, specifying the associated stream ID.
+    Buffer headerBytes = literalHeaders(pushPromise);
+    writeMedium(frame, (int) (headerBytes.size() + 4));
+    frame.writeByte(Http20Draft16.TYPE_PUSH_PROMISE);
+    frame.writeByte(Http20Draft16.FLAG_END_PUSH_PROMISE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
+    frame.writeAll(headerBytes);
+
+    assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedPromisedStreamId, promisedStreamId);
+        assertEquals(pushPromise, headerBlock);
+      }
+    });
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void pushPromiseThenContinuation() throws IOException {
+    final int expectedPromisedStreamId = 11;
+    final List<Header> pushPromise = largeHeaders();
+
+    // Decoding the first header will cross frame boundaries.
+    Buffer headerBlock = literalHeaders(pushPromise);
+
+    // Write the first headers frame.
+    writeMedium(frame, Http20Draft16.INITIAL_MAX_FRAME_SIZE);
+    frame.writeByte(Http20Draft16.TYPE_PUSH_PROMISE);
+    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
+    frame.write(headerBlock, Http20Draft16.INITIAL_MAX_FRAME_SIZE - 4);
+
+    // Write the continuation frame, specifying no more frames are expected.
+    writeMedium(frame, (int) headerBlock.size());
+    frame.writeByte(Http20Draft16.TYPE_CONTINUATION);
+    frame.writeByte(FLAG_END_HEADERS);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBlock);
+
+    assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
+
+    // Reading the above frames should result in a concatenated headerBlock.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedPromisedStreamId, promisedStreamId);
+        assertEquals(pushPromise, headerBlock);
+      }
+    });
+  }
+
+  @Test public void readRstStreamFrame() throws IOException {
+    writeMedium(frame, 4);
+    frame.writeByte(Http20Draft16.TYPE_RST_STREAM);
+    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void rstStream(int streamId, ErrorCode errorCode) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(ErrorCode.COMPRESSION_ERROR, errorCode);
+      }
+    });
+  }
+
+  @Test public void readSettingsFrame() throws IOException {
+    final int reducedTableSizeBytes = 16;
+
+    writeMedium(frame, 12); // 2 settings * 6 bytes (2 for the code and 4 for the value).
+    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
+    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(1); // SETTINGS_HEADER_TABLE_SIZE
+    frame.writeInt(reducedTableSizeBytes);
+    frame.writeShort(2); // SETTINGS_ENABLE_PUSH
+    frame.writeInt(0);
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void settings(boolean clearPrevious, Settings settings) {
+        assertFalse(clearPrevious); // No clearPrevious in HTTP/2.
+        assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
+        assertEquals(false, settings.getEnablePush(true));
+      }
+    });
+  }
+
+  @Test public void readSettingsFrameInvalidPushValue() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
+    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(2);
+    frame.writeInt(2);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameInvalidSettingId() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
+    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(7); // old number for SETTINGS_INITIAL_WINDOW_SIZE
+    frame.writeInt(1);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR invalid settings id: 7", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameNegativeWindowSize() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
+    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(4); // SETTINGS_INITIAL_WINDOW_SIZE
+    frame.writeInt(Integer.MIN_VALUE);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameNegativeFrameLength() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
+    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
+    frame.writeInt(Integer.MIN_VALUE);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: -2147483648", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameTooShortFrameLength() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
+    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
+    frame.writeInt((int) Math.pow(2, 14) - 1);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16383", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameTooLongFrameLength() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft16.TYPE_SETTINGS);
+    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
+    frame.writeInt((int) Math.pow(2, 24));
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16777216", e.getMessage());
+    }
+  }
+
+  @Test public void pingRoundTrip() throws IOException {
+    final int expectedPayload1 = 7;
+    final int expectedPayload2 = 8;
+
+    writeMedium(frame, 8); // length
+    frame.writeByte(Http20Draft16.TYPE_PING);
+    frame.writeByte(Http20Draft16.FLAG_ACK);
+    frame.writeInt(0); // connection-level
+    frame.writeInt(expectedPayload1);
+    frame.writeInt(expectedPayload2);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendPingFrame(true, expectedPayload1, expectedPayload2));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void ping(boolean ack, int payload1, int payload2) {
+        assertTrue(ack);
+        assertEquals(expectedPayload1, payload1);
+        assertEquals(expectedPayload2, payload2);
+      }
+    });
+  }
+
+  @Test public void maxLengthDataFrame() throws IOException {
+    final byte[] expectedData = new byte[Http20Draft16.INITIAL_MAX_FRAME_SIZE];
+    Arrays.fill(expectedData, (byte) 2);
+
+    writeMedium(frame, expectedData.length);
+    frame.writeByte(Http20Draft16.TYPE_DATA);
+    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.write(expectedData);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendDataFrame(new Buffer().write(expectedData)));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void data(boolean inFinished, int streamId, BufferedSource source,
+          int length) throws IOException {
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(Http20Draft16.INITIAL_MAX_FRAME_SIZE, length);
+        ByteString data = source.readByteString(length);
+        for (byte b : data.toByteArray()) {
+          assertEquals(2, b);
+        }
+      }
+    });
+  }
+
+  /** We do not send SETTINGS_COMPRESS_DATA = 1, nor want to. Let's make sure we error. */
+  @Test public void compressedDataFrameWhenSettingDisabled() throws IOException {
+    byte[] expectedData = new byte[Http20Draft16.INITIAL_MAX_FRAME_SIZE];
+    Arrays.fill(expectedData, (byte) 2);
+    Buffer zipped = gzip(expectedData);
+    int zippedSize = (int) zipped.size();
+
+    writeMedium(frame, zippedSize);
+    frame.writeByte(Http20Draft16.TYPE_DATA);
+    frame.writeByte(FLAG_COMPRESSED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    zipped.readAll(frame);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA",
+          e.getMessage());
+    }
+  }
+
+  @Test public void readPaddedDataFrame() throws IOException {
+    int dataLength = 1123;
+    byte[] expectedData = new byte[dataLength];
+    Arrays.fill(expectedData, (byte) 2);
+
+    int paddingLength = 254;
+    byte[] padding = new byte[paddingLength];
+    Arrays.fill(padding, (byte) 0);
+
+    writeMedium(frame, dataLength + paddingLength + 1);
+    frame.writeByte(Http20Draft16.TYPE_DATA);
+    frame.writeByte(FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(paddingLength);
+    frame.write(expectedData);
+    frame.write(padding);
+
+    fr.nextFrame(assertData());
+    assertTrue(frame.exhausted()); // Padding was skipped.
+  }
+
+  @Test public void readPaddedDataFrameZeroPadding() throws IOException {
+    int dataLength = 1123;
+    byte[] expectedData = new byte[dataLength];
+    Arrays.fill(expectedData, (byte) 2);
+
+    writeMedium(frame, dataLength + 1);
+    frame.writeByte(Http20Draft16.TYPE_DATA);
+    frame.writeByte(FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(0);
+    frame.write(expectedData);
+
+    fr.nextFrame(assertData());
+  }
+
+  @Test public void readPaddedHeadersFrame() throws IOException {
+    int paddingLength = 254;
+    byte[] padding = new byte[paddingLength];
+    Arrays.fill(padding, (byte) 0);
+
+    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+    writeMedium(frame, (int) headerBlock.size() + paddingLength + 1);
+    frame.writeByte(Http20Draft16.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(paddingLength);
+    frame.writeAll(headerBlock);
+    frame.write(padding);
+
+    fr.nextFrame(assertHeaderBlock());
+    assertTrue(frame.exhausted()); // Padding was skipped.
+  }
+
+  @Test public void readPaddedHeadersFrameZeroPadding() throws IOException {
+    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+    writeMedium(frame, (int) headerBlock.size() + 1);
+    frame.writeByte(Http20Draft16.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(0);
+    frame.writeAll(headerBlock);
+
+    fr.nextFrame(assertHeaderBlock());
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void readPaddedHeadersFrameThenContinuation() throws IOException {
+    int paddingLength = 254;
+    byte[] padding = new byte[paddingLength];
+    Arrays.fill(padding, (byte) 0);
+
+    // Decoding the first header will cross frame boundaries.
+    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+
+    // Write the first headers frame.
+    writeMedium(frame, (int) (headerBlock.size() / 2) + paddingLength + 1);
+    frame.writeByte(Http20Draft16.TYPE_HEADERS);
+    frame.writeByte(FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(paddingLength);
+    frame.write(headerBlock, headerBlock.size() / 2);
+    frame.write(padding);
+
+    // Write the continuation frame, specifying no more frames are expected.
+    writeMedium(frame, (int) headerBlock.size());
+    frame.writeByte(Http20Draft16.TYPE_CONTINUATION);
+    frame.writeByte(FLAG_END_HEADERS);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBlock);
+
+    fr.nextFrame(assertHeaderBlock());
+    assertTrue(frame.exhausted());
+  }
+
+  @Test public void tooLargeDataFrame() throws IOException {
+    try {
+      sendDataFrame(new Buffer().write(new byte[0x1000000]));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("FRAME_SIZE_ERROR length > 16384: 16777216", e.getMessage());
+    }
+  }
+
+  @Test public void windowUpdateRoundTrip() throws IOException {
+    final long expectedWindowSizeIncrement = 0x7fffffff;
+
+    writeMedium(frame, 4); // length
+    frame.writeByte(Http20Draft16.TYPE_WINDOW_UPDATE);
+    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeInt(expectedStreamId);
+    frame.writeInt((int) expectedWindowSizeIncrement);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, windowUpdate(expectedWindowSizeIncrement));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
+      }
+    });
+  }
+
+  @Test public void badWindowSizeIncrement() throws IOException {
+    try {
+      windowUpdate(0);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 0",
+          e.getMessage());
+    }
+    try {
+      windowUpdate(0x80000000L);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 2147483648",
+          e.getMessage());
+    }
+  }
+
+  @Test public void goAwayWithoutDebugDataRoundTrip() throws IOException {
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+
+    writeMedium(frame, 8); // Without debug data there's only 2 32-bit fields.
+    frame.writeByte(Http20Draft16.TYPE_GOAWAY);
+    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeInt(0); // connection-scope
+    frame.writeInt(expectedStreamId); // last good stream.
+    frame.writeInt(expectedError.httpCode);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+        assertEquals(expectedStreamId, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertEquals(0, debugData.size());
+      }
+    });
+  }
+
+  @Test public void goAwayWithDebugDataRoundTrip() throws IOException {
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+    final ByteString expectedData = ByteString.encodeUtf8("abcdefgh");
+
+    // Compose the expected GOAWAY frame without debug data.
+    writeMedium(frame, 8 + expectedData.size());
+    frame.writeByte(Http20Draft16.TYPE_GOAWAY);
+    frame.writeByte(Http20Draft16.FLAG_NONE);
+    frame.writeInt(0); // connection-scope
+    frame.writeInt(0); // never read any stream!
+    frame.writeInt(expectedError.httpCode);
+    frame.write(expectedData.toByteArray());
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendGoAway(0, expectedError, expectedData.toByteArray()));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+        assertEquals(0, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertEquals(expectedData, debugData);
+      }
+    });
+  }
+
+  @Test public void frameSizeError() throws IOException {
+    Http20Draft16.Writer writer = new Http20Draft16.Writer(new Buffer(), true);
+
+    try {
+      writer.frameHeader(0, 16777216, Http20Draft16.TYPE_DATA, FLAG_NONE);
+      fail();
+    } catch (IllegalArgumentException e) {
+      // TODO: real max is based on settings between 16384 and 16777215
+      assertEquals("FRAME_SIZE_ERROR length > 16384: 16777216", e.getMessage());
+    }
+  }
+
+  @Test public void ackSettingsAppliesMaxFrameSize() throws IOException {
+    int newMaxFrameSize = 16777215;
+
+    Http20Draft16.Writer writer = new Http20Draft16.Writer(new Buffer(), true);
+
+    writer.ackSettings(new Settings().set(Settings.MAX_FRAME_SIZE, 0, newMaxFrameSize));
+
+    assertEquals(newMaxFrameSize, writer.maxDataLength());
+    writer.frameHeader(0, newMaxFrameSize, Http20Draft16.TYPE_DATA, FLAG_NONE);
+  }
+
+  @Test public void streamIdHasReservedBit() throws IOException {
+    Http20Draft16.Writer writer = new Http20Draft16.Writer(new Buffer(), true);
+
+    try {
+      int streamId = 3;
+      streamId |= 1L << 31; // set reserved bit
+      writer.frameHeader(streamId, Http20Draft16.INITIAL_MAX_FRAME_SIZE, Http20Draft16.TYPE_DATA, FLAG_NONE);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("reserved bit set: -2147483645", e.getMessage());
+    }
+  }
+
+  private Buffer literalHeaders(List<Header> sentHeaders) throws IOException {
+    Buffer out = new Buffer();
+    new HpackDraft10.Writer(out).writeHeaders(sentHeaders);
+    return out;
+  }
+
+  private Buffer sendHeaderFrames(boolean outFinished, List<Header> headers) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft16.Writer(out, true).headers(outFinished, expectedStreamId, headers);
+    return out;
+  }
+
+  private Buffer sendPushPromiseFrames(int streamId, List<Header> headers) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft16.Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
+    return out;
+  }
+
+  private Buffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft16.Writer(out, true).ping(ack, payload1, payload2);
+    return out;
+  }
+
+  private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+      throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft16.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
+    return out;
+  }
+
+  private Buffer sendDataFrame(Buffer data) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft16.Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
+        (int) data.size());
+    return out;
+  }
+
+  private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft16.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
+    return out;
+  }
+
+  private FrameReader.Handler assertHeaderBlock() {
+    return new BaseTestHandler() {
+      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    };
+  }
+
+  private FrameReader.Handler assertData() {
+    return new BaseTestHandler() {
+      @Override public void data(boolean inFinished, int streamId, BufferedSource source,
+          int length) throws IOException {
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(1123, length);
+        ByteString data = source.readByteString(length);
+        for (byte b : data.toByteArray()) {
+          assertEquals(2, b);
+        }
+      }
+    };
+  }
+
+  private static Buffer gzip(byte[] data) throws IOException {
+    Buffer buffer = new Buffer();
+    Okio.buffer(new GzipSink(buffer)).write(data).close();
+    return buffer;
+  }
+
+  /** Create a sufficiently large header set to overflow Http20Draft12.INITIAL_MAX_FRAME_SIZE bytes. */
+  private static List<Header> largeHeaders() {
+    String[] nameValues = new String[32];
+    char[] chars = new char[512];
+    for (int i = 0; i < nameValues.length;) {
+      Arrays.fill(chars, (char) i);
+      nameValues[i++] = nameValues[i++] = String.valueOf(chars);
+    }
+    return headerEntries(nameValues);
+  }
+
+  private static void writeMedium(BufferedSink sink, int i) throws IOException {
+    sink.writeByte((i >>> 16) & 0xff);
+    sink.writeByte((i >>>  8) & 0xff);
+    sink.writeByte( i         & 0xff);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java
new file mode 100644
index 0000000000..13c91d1620
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java
@@ -0,0 +1,521 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Source;
+import org.junit.After;
+import org.junit.Test;
+
+import static com.squareup.okhttp.TestUtil.headerEntries;
+import static com.squareup.okhttp.internal.spdy.ErrorCode.CANCEL;
+import static com.squareup.okhttp.internal.spdy.ErrorCode.PROTOCOL_ERROR;
+import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static com.squareup.okhttp.internal.spdy.Settings.PERSIST_VALUE;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_DATA;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_PING;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_RST_STREAM;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_SETTINGS;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_WINDOW_UPDATE;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class Http2ConnectionTest {
+  private static final Variant HTTP_2 = new Http20Draft16();
+  private final MockSpdyPeer peer = new MockSpdyPeer();
+
+  @After public void tearDown() throws Exception {
+    peer.close();
+  }
+
+  @Test public void serverPingsClientHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.sendFrame().ping(false, 2, 3);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connection(peer, HTTP_2);
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame ping = peer.takeFrame();
+    assertEquals(TYPE_PING, ping.type);
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(3, ping.payload2);
+    assertTrue(ping.ack);
+  }
+
+  @Test public void clientPingsServerHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 5);
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, HTTP_2);
+    Ping ping = connection.ping();
+    assertTrue(ping.roundTripTime() > 0);
+    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
+    assertEquals(0, pingFrame.streamId);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
+    assertFalse(pingFrame.ack);
+  }
+
+  @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    Settings initial = new Settings();
+    initial.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 1684);
+    Settings shouldntImpactConnection = new Settings();
+    shouldntImpactConnection.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 3368);
+
+    peer.sendFrame().settings(initial);
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().settings(shouldntImpactConnection);
+    peer.acceptFrame(); // ACK 2
+    peer.acceptFrame(); // HEADERS
+    peer.play();
+
+    SpdyConnection connection = connection(peer, HTTP_2);
+
+    // Default is 64KiB - 1.
+    assertEquals(65535, connection.peerSettings.getInitialWindowSize(-1));
+
+    // Verify the peer received the ACK.
+    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+    ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+
+    // This stream was created *after* the connection settings were adjusted.
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
+
+    assertEquals(3368, connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
+    assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
+    // New Stream is has the most recent initial window size.
+    assertEquals(3368, stream.bytesLeftInWriteWindow);
+  }
+
+  @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
+    boolean client = false; // Peer is server, so we are client.
+    Settings settings = new Settings();
+    settings.set(Settings.HEADER_TABLE_SIZE, PERSIST_VALUE, 0);
+
+    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+
+    // verify the peer's settings were read and applied.
+    assertEquals(0, connection.peerSettings.getHeaderTableSize());
+    Http20Draft16.Reader frameReader = (Http20Draft16.Reader) connection.readerRunnable.frameReader;
+    assertEquals(0, frameReader.hpackReader.maxDynamicTableByteCount());
+    // TODO: when supported, check the frameWriter's compression table is unaffected.
+  }
+
+  @Test public void peerHttp2ClientDisablesPush() throws Exception {
+    boolean client = false; // Peer is client, so we are server.
+    Settings settings = new Settings();
+    settings.set(Settings.ENABLE_PUSH, 0, 0); // The peer client disables push.
+
+    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+
+    // verify the peer's settings were read and applied.
+    assertFalse(connection.peerSettings.getEnablePush(true));
+  }
+
+  @Test public void peerIncreasesMaxFrameSize() throws Exception {
+    int newMaxFrameSize = 0x4001;
+    Settings settings = new Settings();
+    settings.set(Settings.MAX_FRAME_SIZE, 0, newMaxFrameSize);
+
+    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(true, settings);
+
+    // verify the peer's settings were read and applied.
+    assertEquals(newMaxFrameSize, connection.peerSettings.getMaxFrameSize(-1));
+    assertEquals(newMaxFrameSize, connection.frameWriter.maxDataLength());
+  }
+
+  @Test public void receiveGoAwayHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM 3
+    peer.acceptFrame(); // SYN_STREAM 5
+    peer.sendFrame().goAway(3, PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // DATA STREAM 3
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, HTTP_2);
+    SpdyStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
+    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
+    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    BufferedSink sink1 = Okio.buffer(stream1.getSink());
+    BufferedSink sink2 = Okio.buffer(stream2.getSink());
+    sink1.writeUtf8("abc");
+    try {
+      sink2.writeUtf8("abc");
+      sink2.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+    }
+    sink1.writeUtf8("def");
+    sink1.close();
+    try {
+      connection.newStream(headerEntries("c", "cola"), true, true);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("shutdown", expected.getMessage());
+    }
+    assertTrue(stream1.isOpen());
+    assertFalse(stream2.isOpen());
+    assertEquals(1, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame synStream1 = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream1.type);
+    MockSpdyPeer.InFrame synStream2 = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream2.type);
+    MockSpdyPeer.InFrame ping = peer.takeFrame();
+    assertEquals(TYPE_PING, ping.type);
+    MockSpdyPeer.InFrame data1 = peer.takeFrame();
+    assertEquals(TYPE_DATA, data1.type);
+    assertEquals(3, data1.streamId);
+    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
+  }
+
+  @Test public void readSendsWindowUpdateHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    int windowSize = 100;
+    int windowUpdateThreshold = 50;
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    for (int i = 0; i < 3; i++) {
+      // Send frames of summing to size 50, which is windowUpdateThreshold.
+      peer.sendFrame().data(false, 3, data(24), 24);
+      peer.sendFrame().data(false, 3, data(25), 25);
+      peer.sendFrame().data(false, 3, data(1), 1);
+      peer.acceptFrame(); // connection WINDOW UPDATE
+      peer.acceptFrame(); // stream WINDOW UPDATE
+    }
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, HTTP_2);
+    connection.okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, windowSize);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(0, stream.unacknowledgedBytesRead);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    Source in = stream.getSource();
+    Buffer buffer = new Buffer();
+    buffer.writeAll(in);
+    assertEquals(-1, in.read(buffer, 1));
+    assertEquals(150, buffer.size());
+
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    for (int i = 0; i < 3; i++) {
+      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
+      for (int j = 0; j < 2; j++) {
+        MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
+        assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
+        windowUpdateStreamIds.add(windowUpdate.streamId);
+        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+      }
+      assertTrue(windowUpdateStreamIds.contains(0)); // connection
+      assertTrue(windowUpdateStreamIds.contains(3)); // stream
+    }
+  }
+
+  private Buffer data(int byteCount) {
+    return new Buffer().write(new byte[byteCount]);
+  }
+
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, HTTP_2);
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // Verify the peer received what was expected.
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    assertEquals(3, peer.frameCount());
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, HTTP_2);
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), true, true);
+    BufferedSink out = Okio.buffer(client.getSink());
+    out.write(Util.EMPTY_BYTE_ARRAY);
+    out.flush();
+    out.close();
+
+    // Verify the peer received what was expected.
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_DATA, peer.takeFrame().type);
+    assertEquals(3, peer.frameCount());
+  }
+
+  @Test public void maxFrameSizeHonored() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    byte[] buff = new byte[peer.maxOutboundDataLength() + 1];
+    Arrays.fill(buff, (byte) '*');
+
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // DATA
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, HTTP_2);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.write(buff);
+    out.flush();
+    out.close();
+
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    MockSpdyPeer.InFrame data = peer.takeFrame();
+    assertEquals(peer.maxOutboundDataLength(), data.data.length);
+    data = peer.takeFrame();
+    assertEquals(1, data.data.length);
+  }
+
+  @Test public void pushPromiseStream() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    final List<Header> expectedRequestHeaders = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    );
+    peer.sendFrame().pushPromise(3, 2, expectedRequestHeaders);
+    final List<Header> expectedResponseHeaders = Arrays.asList(
+        new Header(Header.RESPONSE_STATUS, "200")
+    );
+    peer.sendFrame().synReply(true, 2, expectedResponseHeaders);
+    peer.sendFrame().data(true, 3, data(0), 0);
+    peer.play();
+
+    RecordingPushObserver observer = new RecordingPushObserver();
+
+    // play it back
+    SpdyConnection connection = connectionBuilder(peer, HTTP_2)
+        .pushObserver(observer).build();
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+
+    assertEquals(expectedRequestHeaders, observer.takeEvent());
+    assertEquals(expectedResponseHeaders, observer.takeEvent());
+  }
+
+  @Test public void doublePushPromise() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.sendFrame().pushPromise(3, 2, headerEntries("a", "android"));
+    peer.acceptFrame(); // SYN_REPLY
+    peer.sendFrame().pushPromise(3, 2, headerEntries("b", "banana"));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connectionBuilder(peer, HTTP_2).build();
+    connection.newStream(headerEntries("b", "banana"), false, true);
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(PROTOCOL_ERROR, peer.takeFrame().errorCode);
+  }
+
+  @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.sendFrame().pushPromise(3, 2, Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    ));
+    peer.sendFrame().synReply(true, 2, Arrays.asList(
+        new Header(Header.RESPONSE_STATUS, "200")
+    ));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    connectionBuilder(peer, HTTP_2)
+        .pushObserver(PushObserver.CANCEL).build();
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
+    assertEquals(TYPE_RST_STREAM, rstStream.type);
+    assertEquals(2, rstStream.streamId);
+    assertEquals(CANCEL, rstStream.errorCode);
+  }
+
+  private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
+      throws IOException, InterruptedException {
+    peer.setVariantAndClient(HTTP_2, client);
+    peer.sendFrame().settings(settings);
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, HTTP_2);
+
+    // verify the peer received the ACK
+    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+
+    connection.ping().roundTripTime(); // Ensure that settings have been applied before returning.
+    return connection;
+  }
+
+  private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
+    return connectionBuilder(peer, variant).build();
+  }
+
+  private SpdyConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
+      throws IOException {
+    return new SpdyConnection.Builder(true, peer.openSocket())
+        .pushObserver(IGNORE)
+        .protocol(variant.getProtocol());
+  }
+
+  static final PushObserver IGNORE = new PushObserver() {
+
+    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
+      return false;
+    }
+
+    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
+      return false;
+    }
+
+    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
+        boolean last) throws IOException {
+      source.skip(byteCount);
+      return false;
+    }
+
+    @Override public void onReset(int streamId, ErrorCode errorCode) {
+    }
+  };
+
+  private static class RecordingPushObserver implements PushObserver {
+    final List<Object> events = new ArrayList<>();
+
+    public synchronized Object takeEvent() throws InterruptedException {
+      while (events.isEmpty()) {
+        wait();
+      }
+      return events.remove(0);
+    }
+
+    @Override public synchronized boolean onRequest(int streamId, List<Header> requestHeaders) {
+      assertEquals(2, streamId);
+      events.add(requestHeaders);
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized boolean onHeaders(
+        int streamId, List<Header> responseHeaders, boolean last) {
+      assertEquals(2, streamId);
+      assertTrue(last);
+      events.add(responseHeaders);
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized boolean onData(
+        int streamId, BufferedSource source, int byteCount, boolean last) {
+      events.add(new AssertionError("onData"));
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized void onReset(int streamId, ErrorCode errorCode) {
+      events.add(new AssertionError("onReset"));
+      notifyAll();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
new file mode 100644
index 0000000000..222d23e150
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2013 Twitter, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Original version of this class was lifted from {@code com.twitter.hpack.HuffmanTest}.
+ */
+public class HuffmanTest {
+
+  @Test public void roundTripForRequestAndResponse() throws IOException {
+    String s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
+    for (int i = 0; i < s.length(); i++) {
+      assertRoundTrip(s.substring(0, i).getBytes());
+    }
+
+    Random random = new Random(123456789L);
+    byte[] buf = new byte[4096];
+    random.nextBytes(buf);
+    assertRoundTrip(buf);
+  }
+
+  private void assertRoundTrip(byte[] buf) throws IOException {
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    DataOutputStream dos = new DataOutputStream(baos);
+
+    Huffman.get().encode(buf, dos);
+    assertEquals(baos.size(), Huffman.get().encodedLength(buf));
+
+    byte[] decodedBytes = Huffman.get().decode(baos.toByteArray());
+    assertTrue(Arrays.equals(buf, decodedBytes));
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
similarity index 55%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index dfdd1d09ae..fd6da2b0c9 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -17,7 +17,6 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
@@ -28,51 +27,84 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
-
-import static java.util.concurrent.Executors.defaultThreadFactory;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
 
 /** Replays prerecorded outgoing frames and records incoming frames. */
 public final class MockSpdyPeer implements Closeable {
   private int frameCount = 0;
-  private final boolean client;
-  private final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-  private final FrameWriter frameWriter;
-  private final List<OutFrame> outFrames = new ArrayList<OutFrame>();
-  private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<InFrame>();
+  private boolean client = false;
+  private Variant variant = new Spdy3();
+  private final Buffer bytesOut = new Buffer();
+  private FrameWriter frameWriter = variant.newWriter(bytesOut, client);
+  private final List<OutFrame> outFrames = new ArrayList<>();
+  private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<>();
   private int port;
-  private final Executor executor = Executors.newCachedThreadPool(defaultThreadFactory());
+  private final ExecutorService executor = Executors.newSingleThreadExecutor(
+      Util.threadFactory("MockSpdyPeer", false));
   private ServerSocket serverSocket;
   private Socket socket;
 
-  public MockSpdyPeer(boolean client) {
+  public void setVariantAndClient(Variant variant, boolean client) {
+    if (this.variant.getProtocol() == variant.getProtocol() && this.client == client) {
+      return;
+    }
     this.client = client;
-    this.frameWriter = Variant.SPDY3.newWriter(bytesOut, client);
+    this.variant = variant;
+    this.frameWriter = variant.newWriter(bytesOut, client);
   }
 
   public void acceptFrame() {
     frameCount++;
   }
 
+  /** Maximum length of an outbound data frame. */
+  public int maxOutboundDataLength() {
+    return frameWriter.maxDataLength();
+  }
+
+  /** Count of frames sent or received. */
+  public int frameCount() {
+    return frameCount;
+  }
+
   public FrameWriter sendFrame() {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), Integer.MAX_VALUE));
+    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
     return frameWriter;
   }
 
   /**
-   * Sends a frame, truncated to {@code truncateToLength} bytes. This is only
-   * useful for testing error handling as the truncated frame will be
-   * malformed.
+   * Sends a manually-constructed frame. This is useful to test frames that
+   * won't be generated naturally.
    */
-  public FrameWriter sendTruncatedFrame(int truncateToLength) {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), truncateToLength));
-    return frameWriter;
+  public void sendFrame(byte[] frame) throws IOException {
+    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
+    bytesOut.write(frame);
   }
 
-  public int getPort() {
-    return port;
+  /**
+   * Shortens the last frame from its original length to {@code length}. This
+   * will cause the peer to close the socket as soon as this frame has been
+   * written; otherwise the peer stays open until explicitly closed.
+   */
+  public FrameWriter truncateLastFrame(int length) {
+    OutFrame lastFrame = outFrames.remove(outFrames.size() - 1);
+    if (length >= bytesOut.size() - lastFrame.start) throw new IllegalArgumentException();
+
+    // Move everything from bytesOut into a new buffer.
+    Buffer fullBuffer = new Buffer();
+    bytesOut.read(fullBuffer, bytesOut.size());
+
+    // Copy back all but what we're truncating.
+    fullBuffer.read(bytesOut, lastFrame.start + length);
+
+    outFrames.add(new OutFrame(lastFrame.sequence, lastFrame.start, true));
+    return frameWriter;
   }
 
   public InFrame takeFrame() throws InterruptedException {
@@ -83,13 +115,14 @@ public void play() throws IOException {
     if (serverSocket != null) throw new IllegalStateException();
     serverSocket = new ServerSocket(0);
     serverSocket.setReuseAddress(true);
-    this.port = serverSocket.getLocalPort();
+    port = serverSocket.getLocalPort();
     executor.execute(new Runnable() {
       @Override public void run() {
         try {
           readAndWriteFrames();
         } catch (IOException e) {
-          throw new RuntimeException(e);
+          Util.closeQuietly(MockSpdyPeer.this);
+          e.printStackTrace();
         }
       }
     });
@@ -100,10 +133,10 @@ private void readAndWriteFrames() throws IOException {
     socket = serverSocket.accept();
     OutputStream out = socket.getOutputStream();
     InputStream in = socket.getInputStream();
-    FrameReader reader = Variant.SPDY3.newReader(in, client);
+    FrameReader reader = variant.newReader(Okio.buffer(Okio.source(in)), client);
 
     Iterator<OutFrame> outFramesIterator = outFrames.iterator();
-    byte[] outBytes = bytesOut.toByteArray();
+    byte[] outBytes = bytesOut.readByteArray();
     OutFrame nextOutFrame = null;
 
     for (int i = 0; i < frameCount; i++) {
@@ -112,19 +145,26 @@ private void readAndWriteFrames() throws IOException {
       }
 
       if (nextOutFrame != null && nextOutFrame.sequence == i) {
-        int start = nextOutFrame.start;
-        int truncateToLength = nextOutFrame.truncateToLength;
-        int end;
+        long start = nextOutFrame.start;
+        boolean truncated;
+        long end;
         if (outFramesIterator.hasNext()) {
           nextOutFrame = outFramesIterator.next();
           end = nextOutFrame.start;
+          truncated = false;
         } else {
           end = outBytes.length;
+          truncated = nextOutFrame.truncated;
         }
 
-        // write a frame
-        int length = Math.min(end - start, truncateToLength);
-        out.write(outBytes, start, length);
+        // Write a frame.
+        int length = (int) (end - start);
+        out.write(outBytes, (int) start, length);
+
+        // If the last frame was truncated, immediately close the connection.
+        if (truncated) {
+          socket.close();
+        }
       } else {
         // read a frame
         InFrame inFrame = new InFrame(i, reader);
@@ -132,35 +172,35 @@ private void readAndWriteFrames() throws IOException {
         inFrames.add(inFrame);
       }
     }
-    Util.closeQuietly(socket);
   }
 
   public Socket openSocket() throws IOException {
     return new Socket("localhost", port);
   }
 
-  @Override public void close() throws IOException {
+  @Override public synchronized void close() throws IOException {
+    executor.shutdown();
     Socket socket = this.socket;
     if (socket != null) {
-      socket.close();
+      Util.closeQuietly(socket);
       this.socket = null;
     }
     ServerSocket serverSocket = this.serverSocket;
     if (serverSocket != null) {
-      serverSocket.close();
+      Util.closeQuietly(serverSocket);
       this.serverSocket = null;
     }
   }
 
   private static class OutFrame {
     private final int sequence;
-    private final int start;
-    private final int truncateToLength;
+    private final long start;
+    private final boolean truncated;
 
-    private OutFrame(int sequence, int start, int truncateToLength) {
+    private OutFrame(int sequence, long start, boolean truncated) {
       this.sequence = sequence;
       this.start = start;
-      this.truncateToLength = truncateToLength;
+      this.truncated = truncated;
     }
   }
 
@@ -173,13 +213,15 @@ private OutFrame(int sequence, int start, int truncateToLength) {
     public boolean inFinished;
     public int streamId;
     public int associatedStreamId;
-    public int priority;
     public ErrorCode errorCode;
-    public int deltaWindowSize;
-    public List<String> nameValueBlock;
+    public long windowSizeIncrement;
+    public List<Header> headerBlock;
     public byte[] data;
     public Settings settings;
     public HeadersMode headersMode;
+    public boolean ack;
+    public int payload1;
+    public int payload2;
 
     public InFrame(int sequence, FrameReader reader) {
       this.sequence = sequence;
@@ -193,28 +235,31 @@ public InFrame(int sequence, FrameReader reader) {
       this.settings = settings;
     }
 
+    @Override public void ackSettings() {
+      if (this.type != -1) throw new IllegalStateException();
+      this.type = Spdy3.TYPE_SETTINGS;
+      this.ack = true;
+    }
+
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<String> nameValueBlock,
-        HeadersMode headersMode) {
+        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_HEADERS;
       this.outFinished = outFinished;
       this.inFinished = inFinished;
       this.streamId = streamId;
       this.associatedStreamId = associatedStreamId;
-      this.priority = priority;
-      this.nameValueBlock = nameValueBlock;
+      this.headerBlock = headerBlock;
       this.headersMode = headersMode;
     }
 
-    @Override public void data(boolean inFinished, int streamId, InputStream in, int length)
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_DATA;
       this.inFinished = inFinished;
       this.streamId = streamId;
-      this.data = new byte[length];
-      Util.readFully(in, this.data);
+      this.data = source.readByteString(length).toByteArray();
     }
 
     @Override public void rstStream(int streamId, ErrorCode errorCode) {
@@ -224,33 +269,45 @@ public InFrame(int sequence, FrameReader reader) {
       this.errorCode = errorCode;
     }
 
-    @Override public void ping(boolean reply, int payload1, int payload2) {
+    @Override public void ping(boolean ack, int payload1, int payload2) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_PING;
-      this.streamId = payload1;
-    }
-
-    @Override public void noop() {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_NOOP;
+      this.ack = ack;
+      this.payload1 = payload1;
+      this.payload2 = payload2;
     }
 
-    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode) {
+    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_GOAWAY;
       this.streamId = lastGoodStreamId;
       this.errorCode = errorCode;
+      this.data = debugData.toByteArray();
     }
 
-    @Override public void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl) {
+    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_WINDOW_UPDATE;
       this.streamId = streamId;
-      this.deltaWindowSize = deltaWindowSize;
+      this.windowSizeIncrement = windowSizeIncrement;
+    }
+
+    @Override public void priority(int streamId, int streamDependency, int weight,
+        boolean exclusive) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
+      this.type = Http20Draft16.TYPE_PUSH_PROMISE;
+      this.streamId = streamId;
+      this.associatedStreamId = associatedStreamId;
+      this.headerBlock = headerBlock;
     }
 
-    @Override public void priority(int streamId, int priority) {
+    @Override public void alternateService(int streamId, String origin, ByteString protocol,
+        String host, int port, long maxAge) {
       throw new UnsupportedOperationException();
     }
   }
-}
\ No newline at end of file
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
similarity index 79%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
index a906fc7cb9..f9f9efa32d 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static com.squareup.okhttp.internal.spdy.Settings.DOWNLOAD_BANDWIDTH;
 import static com.squareup.okhttp.internal.spdy.Settings.DOWNLOAD_RETRANS_RATE;
 import static com.squareup.okhttp.internal.spdy.Settings.MAX_CONCURRENT_STREAMS;
@@ -36,12 +37,21 @@
   @Test public void setFields() {
     Settings settings = new Settings();
 
+    // WARNING: clash on flags between spdy/3 and HTTP/2!
     assertEquals(-3, settings.getUploadBandwidth(-3));
-    settings.set(Settings.UPLOAD_BANDWIDTH, 0, 42);
+    assertEquals(-1, settings.getHeaderTableSize());
+    settings.set(UPLOAD_BANDWIDTH, 0, 42);
     assertEquals(42, settings.getUploadBandwidth(-3));
-
+    settings.set(Settings.HEADER_TABLE_SIZE, 0, 8096);
+    assertEquals(8096, settings.getHeaderTableSize());
+
+    // WARNING: clash on flags between spdy/3 and HTTP/2!
+    assertEquals(true, settings.getEnablePush(true));
+    settings.set(Settings.ENABLE_PUSH, 0, 1);
+    assertEquals(true, settings.getEnablePush(false));
+    settings.clear();
     assertEquals(-3, settings.getDownloadBandwidth(-3));
-    settings.set(Settings.DOWNLOAD_BANDWIDTH, 0, 53);
+    settings.set(DOWNLOAD_BANDWIDTH, 0, 53);
     assertEquals(53, settings.getDownloadBandwidth(-3));
 
     assertEquals(-3, settings.getRoundTripTime(-3));
@@ -49,20 +59,31 @@
     assertEquals(64, settings.getRoundTripTime(-3));
 
     assertEquals(-3, settings.getMaxConcurrentStreams(-3));
-    settings.set(Settings.MAX_CONCURRENT_STREAMS, 0, 75);
+    settings.set(MAX_CONCURRENT_STREAMS, 0, 75);
     assertEquals(75, settings.getMaxConcurrentStreams(-3));
 
+    // WARNING: clash on flags between spdy/3 and HTTP/2!
     assertEquals(-3, settings.getCurrentCwnd(-3));
     settings.set(Settings.CURRENT_CWND, 0, 86);
     assertEquals(86, settings.getCurrentCwnd(-3));
+    settings.clear();
+    assertEquals(16384, settings.getMaxFrameSize(16384));
+    settings.set(Settings.MAX_FRAME_SIZE, 0, 16777215);
+    assertEquals(16777215, settings.getMaxFrameSize(16384));
 
+    // WARNING: clash on flags between spdy/3 and HTTP/2!
     assertEquals(-3, settings.getDownloadRetransRate(-3));
-    settings.set(Settings.DOWNLOAD_RETRANS_RATE, 0, 97);
+    settings.set(DOWNLOAD_RETRANS_RATE, 0, 97);
     assertEquals(97, settings.getDownloadRetransRate(-3));
+    settings.clear();
+    assertEquals(-1, settings.getMaxHeaderListSize(-1));
+    settings.set(Settings.MAX_HEADER_LIST_SIZE, 0, 16777215);
+    assertEquals(16777215, settings.getMaxHeaderListSize(-1));
 
-    assertEquals(-3, settings.getInitialWindowSize(-3));
+    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE,
+        settings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
     settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 108);
-    assertEquals(108, settings.getInitialWindowSize(-3));
+    assertEquals(108, settings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
 
     assertEquals(-3, settings.getClientCertificateVectorSize(-3));
     settings.set(Settings.CLIENT_CERTIFICATE_VECTOR_SIZE, 0, 117);
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
similarity index 52%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
index ebc67603d3..110412ec2e 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
@@ -13,50 +13,48 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.InterruptedIOException;
-import java.io.OutputStream;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
 import org.junit.After;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.Util.UTF_8;
+import static com.squareup.okhttp.TestUtil.headerEntries;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.CANCEL;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.FLOW_CONTROL_ERROR;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.INTERNAL_ERROR;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.INVALID_STREAM;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.PROTOCOL_ERROR;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.REFUSED_STREAM;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.STREAM_IN_USE;
+import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static com.squareup.okhttp.internal.spdy.Settings.PERSIST_VALUE;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_DATA;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_GOAWAY;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_NOOP;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_PING;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_RST_STREAM;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_WINDOW_UPDATE;
-import static com.squareup.okhttp.internal.spdy.SpdyStream.WINDOW_UPDATE_THRESHOLD;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-public final class SpdyConnectionTest {
-  private static final IncomingStreamHandler REJECT_INCOMING_STREAMS = new IncomingStreamHandler() {
-    @Override public void receive(SpdyStream stream) throws IOException {
-      throw new AssertionError();
-    }
-  };
-  private final MockSpdyPeer peer = new MockSpdyPeer(false);
+public final class Spdy3ConnectionTest {
+  private static final Variant SPDY3 = new Spdy3();
+  private final MockSpdyPeer peer = new MockSpdyPeer();
 
   @After public void tearDown() throws Exception {
     peer.close();
@@ -65,17 +63,20 @@
   @Test public void clientCreatesStreamAndServerReplies() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
-    peer.sendFrame().data(true, 1, "robot".getBytes("UTF-8"));
+    peer.sendFrame()
+        .synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"), 5);
     peer.acceptFrame(); // DATA
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
-    assertEquals(Arrays.asList("a", "android"), stream.getResponseHeaders());
-    assertStreamData("robot", stream.getInputStream());
-    writeAndClose(stream, "c3po");
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertStreamData("robot", stream.getSource());
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.writeUtf8("c3po");
+    out.close();
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -86,20 +87,23 @@
     assertFalse(synStream.outFinished);
     assertEquals(1, synStream.streamId);
     assertEquals(0, synStream.associatedStreamId);
-    assertEquals(Arrays.asList("b", "banana"), synStream.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
     MockSpdyPeer.InFrame requestData = peer.takeFrame();
     assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
   }
 
   @Test public void headersOnlyStreamIsClosedAfterReplyHeaders() throws Exception {
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), false, false);
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, false);
     assertEquals(1, connection.openStreamCount());
-    assertEquals(Arrays.asList("b", "banana"), stream.getResponseHeaders());
+    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
+    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
     assertEquals(0, connection.openStreamCount());
   }
 
@@ -107,13 +111,13 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(true, 1, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(true, 1, headerEntries("a", "android"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    connection.newStream(Arrays.asList("b", "banana"), false, true);
+    SpdyConnection connection = connection(peer, SPDY3);
+    connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(1, connection.openStreamCount());
     connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
     assertEquals(0, connection.openStreamCount());
@@ -127,8 +131,16 @@
   }
 
   @Test public void serverCreatesStreamAndClientReplies() throws Exception {
+    final List<Header> pushHeaders = headerEntries(
+        ":scheme", "https",
+        ":host", "localhost:8888",
+        ":method", "GET",
+        ":path", "/index.html",
+        ":status", "200",
+        ":version", "HTTP/1.1",
+        "content-type", "text/html");
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 5, 129, Arrays.asList("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, pushHeaders);
     peer.acceptFrame(); // SYN_REPLY
     peer.play();
 
@@ -137,10 +149,9 @@
     IncomingStreamHandler handler = new IncomingStreamHandler() {
       @Override public void receive(SpdyStream stream) throws IOException {
         receiveCount.incrementAndGet();
-        assertEquals(Arrays.asList("a", "android"), stream.getRequestHeaders());
+        assertEquals(pushHeaders, stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
-        assertEquals(5, stream.getPriority());
-        stream.reply(Arrays.asList("b", "banana"), true);
+        stream.reply(headerEntries("b", "banana"), true);
       }
     };
     new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
@@ -151,13 +162,13 @@
     assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
     assertFalse(reply.inFinished);
     assertEquals(2, reply.streamId);
-    assertEquals(Arrays.asList("b", "banana"), reply.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), reply.headerBlock);
     assertEquals(1, receiveCount.get());
   }
 
   @Test public void replyWithNoData() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, Arrays.asList("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
     peer.play();
 
@@ -165,35 +176,20 @@
     final AtomicInteger receiveCount = new AtomicInteger();
     IncomingStreamHandler handler = new IncomingStreamHandler() {
       @Override public void receive(SpdyStream stream) throws IOException {
-        stream.reply(Arrays.asList("b", "banana"), false);
+        stream.reply(headerEntries("b", "banana"), false);
         receiveCount.incrementAndGet();
       }
     };
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
+
+    connectionBuilder(peer, SPDY3).handler(handler).build();
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame reply = peer.takeFrame();
     assertEquals(TYPE_HEADERS, reply.type);
-    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
     assertTrue(reply.inFinished);
-    assertEquals(Arrays.asList("b", "banana"), reply.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), reply.headerBlock);
     assertEquals(1, receiveCount.get());
-  }
-
-  @Test public void noop() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // NOOP
-    peer.play();
-
-    // play it back
-    SpdyConnection connection =
-        new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS)
-            .build();
-    connection.noop();
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_NOOP, ping.type);
+    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
   }
 
   @Test public void serverPingsClient() throws Exception {
@@ -203,24 +199,24 @@
     peer.play();
 
     // play it back
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
+    connection(peer, SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.streamId);
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(0, ping.payload2); // ignored in spdy!
+    assertTrue(ping.ack);
   }
 
   @Test public void clientPingsServer() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
+    peer.sendFrame().ping(true, 1, 5); // payload2 ignored in spdy!
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, SPDY3);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
@@ -228,7 +224,9 @@
     // verify the peer received what was expected
     MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
     assertEquals(TYPE_PING, pingFrame.type);
-    assertEquals(1, pingFrame.streamId);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(0, pingFrame.payload2);
+    assertFalse(pingFrame.ack);
   }
 
   @Test public void unexpectedPingIsNotReturned() throws Exception {
@@ -241,13 +239,13 @@
     peer.play();
 
     // play it back
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
+    connection(peer, SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping2 = peer.takeFrame();
-    assertEquals(2, ping2.streamId);
+    assertEquals(2, ping2.payload1);
     MockSpdyPeer.InFrame ping4 = peer.takeFrame();
-    assertEquals(4, ping4.streamId);
+    assertEquals(4, ping4.payload1);
   }
 
   @Test public void serverSendsSettingsToClient() throws Exception {
@@ -260,13 +258,11 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, SPDY3);
 
-    peer.takeFrame(); // Guarantees that the Settings frame has been processed.
+    peer.takeFrame(); // Guarantees that the peer Settings frame has been processed.
     synchronized (connection) {
-      assertEquals(10, connection.settings.getMaxConcurrentStreams(-1));
+      assertEquals(10, connection.peerSettings.getMaxConcurrentStreams(-1));
     }
   }
 
@@ -287,67 +283,94 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, SPDY3);
 
     peer.takeFrame(); // Guarantees that the Settings frame has been processed.
     synchronized (connection) {
-      assertEquals(100, connection.settings.getUploadBandwidth(-1));
-      assertEquals(PERSIST_VALUE, connection.settings.flags(Settings.UPLOAD_BANDWIDTH));
-      assertEquals(400, connection.settings.getDownloadBandwidth(-1));
-      assertEquals(0, connection.settings.flags(Settings.DOWNLOAD_BANDWIDTH));
-      assertEquals(500, connection.settings.getDownloadRetransRate(-1));
-      assertEquals(PERSIST_VALUE, connection.settings.flags(Settings.DOWNLOAD_RETRANS_RATE));
-      assertEquals(600, connection.settings.getMaxConcurrentStreams(-1));
-      assertEquals(PERSIST_VALUE, connection.settings.flags(Settings.MAX_CONCURRENT_STREAMS));
+      assertEquals(100, connection.peerSettings.getUploadBandwidth(-1));
+      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(Settings.UPLOAD_BANDWIDTH));
+      assertEquals(400, connection.peerSettings.getDownloadBandwidth(-1));
+      assertEquals(0, connection.peerSettings.flags(Settings.DOWNLOAD_BANDWIDTH));
+      assertEquals(500, connection.peerSettings.getDownloadRetransRate(-1));
+      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(Settings.DOWNLOAD_RETRANS_RATE));
+      assertEquals(600, connection.peerSettings.getMaxConcurrentStreams(-1));
+      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(Settings.MAX_CONCURRENT_STREAMS));
+    }
+  }
+
+  @Test public void clearSettingsBeforeMerge() throws Exception {
+    // write the mocking script
+    Settings settings1 = new Settings();
+    settings1.set(Settings.UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
+    settings1.set(Settings.DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
+    settings1.set(Settings.DOWNLOAD_RETRANS_RATE, 0, 300);
+    peer.sendFrame().settings(settings1);
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame();
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, SPDY3);
+
+    peer.takeFrame(); // Guarantees that the Settings frame has been processed.
+
+    // fake a settings frame with clear flag set.
+    Settings settings2 = new Settings();
+    settings2.set(Settings.MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
+    connection.readerRunnable.settings(true, settings2);
+
+    synchronized (connection) {
+      assertEquals(-1, connection.peerSettings.getUploadBandwidth(-1));
+      assertEquals(-1, connection.peerSettings.getDownloadBandwidth(-1));
+      assertEquals(-1, connection.peerSettings.getDownloadRetransRate(-1));
+      assertEquals(600, connection.peerSettings.getMaxConcurrentStreams(-1));
     }
   }
 
   @Test public void bogusDataFrameDoesNotDisruptConnection() throws Exception {
     // write the mocking script
-    peer.sendFrame().data(true, 42, "bogus".getBytes("UTF-8"));
+    peer.sendFrame().data(true, 41, new Buffer().writeUtf8("bogus"), 5);
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
+    connection(peer, SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
     assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(42, rstStream.streamId);
+    assertEquals(41, rstStream.streamId);
     assertEquals(INVALID_STREAM, rstStream.errorCode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void bogusReplyFrameDoesNotDisruptConnection() throws Exception {
     // write the mocking script
-    peer.sendFrame().synReply(false, 42, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(false, 41, headerEntries("a", "android"));
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
+    connection(peer, SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
     assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(42, rstStream.streamId);
+    assertEquals(41, rstStream.streamId);
     assertEquals(INVALID_STREAM, rstStream.errorCode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void clientClosesClientOutputStream() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.acceptFrame(); // TYPE_DATA
     peer.acceptFrame(); // TYPE_DATA with FLAG_FIN
     peer.acceptFrame(); // PING
@@ -355,20 +378,18 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, false);
-    OutputStream out = stream.getOutputStream();
-    out.write("square".getBytes(UTF_8));
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, false);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.writeUtf8("square");
     out.flush();
     assertEquals(1, connection.openStreamCount());
     out.close();
     try {
-      out.write("round".getBytes(UTF_8));
+      out.writeUtf8("round");
       fail();
     } catch (Exception expected) {
-      assertEquals("stream closed", expected.getMessage());
+      assertEquals("closed", expected.getMessage());
     }
     connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
     assertEquals(0, connection.openStreamCount());
@@ -388,7 +409,7 @@
     assertTrue(fin.inFinished);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(1, ping.streamId);
+    assertEquals(1, ping.payload1);
   }
 
   @Test public void serverClosesClientOutputStream() throws Exception {
@@ -397,23 +418,26 @@
     peer.sendFrame().rstStream(1, CANCEL);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // DATA
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, true);
-    OutputStream out = stream.getOutputStream();
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    BufferedSink out = Okio.buffer(stream.getSink());
     connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
     try {
-      out.write("square".getBytes(UTF_8));
+      out.writeUtf8("square");
+      out.flush();
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: CANCEL", expected.getMessage());
     }
-    out.close();
+    try {
+      out.close();
+      fail();
+    } catch (IOException expected) {
+      // Close throws because buffered data wasn't flushed.
+    }
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -424,12 +448,7 @@
     assertFalse(synStream.outFinished);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(1, ping.streamId);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(TYPE_DATA, data.type);
-    assertEquals(1, data.streamId);
-    assertTrue(data.inFinished);
-    assertFalse(data.outFinished);
+    assertEquals(1, ping.payload1);
   }
 
   /**
@@ -443,21 +462,20 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), false, true);
-    InputStream in = stream.getInputStream();
-    OutputStream out = stream.getOutputStream();
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
+    Source in = stream.getSource();
+    BufferedSink out = Okio.buffer(stream.getSink());
     in.close();
     try {
-      in.read();
+      in.read(new Buffer(), 1);
       fail();
     } catch (IOException expected) {
       assertEquals("stream closed", expected.getMessage());
     }
     try {
-      out.write('a');
+      out.writeUtf8("a");
+      out.flush();
       fail();
     } catch (IOException expected) {
       assertEquals("stream finished", expected.getMessage());
@@ -488,20 +506,18 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, true);
-    InputStream in = stream.getInputStream();
-    OutputStream out = stream.getOutputStream();
-    in.close();
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    Source source = stream.getSource();
+    BufferedSink out = Okio.buffer(stream.getSink());
+    source.close();
     try {
-      in.read();
+      source.read(new Buffer(), 1);
       fail();
     } catch (IOException expected) {
       assertEquals("stream closed", expected.getMessage());
     }
-    out.write("square".getBytes(UTF_8));
+    out.writeUtf8("square");
     out.flush();
     out.close();
     assertEquals(0, connection.openStreamCount());
@@ -527,17 +543,18 @@
   @Test public void serverClosesClientInputStream() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("b", "banana"));
-    peer.sendFrame().data(true, 1, "square".getBytes(UTF_8));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
+    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("square"), 6);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), false, true);
-    InputStream in = stream.getInputStream();
-    assertStreamData("square", in);
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
+    Source source = stream.getSource();
+    assertStreamData("square", source);
+    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -551,20 +568,20 @@
   @Test public void remoteDoubleSynReply() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 1, Arrays.asList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("c", "cola"), true, true);
-    assertEquals(Arrays.asList("a", "android"), stream.getResponseHeaders());
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("c", "cola"), true, true);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
     try {
-      stream.getInputStream().read();
+      stream.getSource().read(new Buffer(), 1);
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: STREAM_IN_USE", expected.getMessage());
@@ -584,9 +601,9 @@
 
   @Test public void remoteDoubleSynStream() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, Arrays.asList("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, Arrays.asList("b", "banana"));
+    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("b", "banana"));
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
@@ -595,9 +612,9 @@
     IncomingStreamHandler handler = new IncomingStreamHandler() {
       @Override public void receive(SpdyStream stream) throws IOException {
         receiveCount.incrementAndGet();
-        assertEquals(Arrays.asList("a", "android"), stream.getRequestHeaders());
+        assertEquals(headerEntries("a", "android"), stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
-        stream.reply(Arrays.asList("c", "cola"), true);
+        stream.reply(headerEntries("c", "cola"), true);
       }
     };
     new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
@@ -616,18 +633,18 @@
   @Test public void remoteSendsDataAfterInFinished() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
-    peer.sendFrame().data(true, 1, "robot".getBytes("UTF-8"));
-    peer.sendFrame().data(true, 1, "c3po".getBytes("UTF-8")); // Ignored.
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"), 5);
+    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("c3po"), 4); // Ignored.
     peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
-    assertEquals(Arrays.asList("a", "android"), stream.getResponseHeaders());
-    assertStreamData("robot", stream.getInputStream());
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertStreamData("robot", stream.getSource());
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
@@ -635,35 +652,31 @@
     assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
-  @Test public void remoteSendsTooMuchData() throws Exception {
+  @Test public void clientDoesNotLimitFlowControl() throws Exception {
+    int dataLength = 64 * 1024 + 1;
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("b", "banana"));
-    peer.sendFrame().data(false, 1, new byte[64 * 1024 + 1]);
-    peer.acceptFrame(); // RST_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
+    peer.sendFrame().data(false, 1, new Buffer().write(new byte[dataLength]), dataLength);
     peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, true);
-    assertEquals(Arrays.asList("b", "banana"), stream.getResponseHeaders());
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream.type);
     assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(1, rstStream.streamId);
-    assertEquals(FLOW_CONTROL_ERROR, rstStream.errorCode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
@@ -675,8 +688,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, true);
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     try {
       stream.getResponseHeaders();
       fail();
@@ -691,39 +704,47 @@
     assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
+
   @Test public void receiveGoAway() throws Exception {
+    peer.setVariantAndClient(SPDY3, false);
+
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // SYN_STREAM 3
-    peer.sendFrame().goAway(1, PROTOCOL_ERROR);
+    peer.sendFrame().goAway(1, PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // DATA STREAM 1
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream1 = connection.newStream(Arrays.asList("a", "android"), true, true);
-    SpdyStream stream2 = connection.newStream(Arrays.asList("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Ensure that the GO_AWAY has been received.
-    stream1.getOutputStream().write("abc".getBytes(UTF_8));
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
+    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
+    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    BufferedSink sink1 = Okio.buffer(stream1.getSink());
+    BufferedSink sink2 = Okio.buffer(stream2.getSink());
+    sink1.writeUtf8("abc");
     try {
-      stream2.getOutputStream().write("abc".getBytes(UTF_8));
+      sink2.writeUtf8("abc");
+      sink2.flush();
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
     }
-    stream1.getOutputStream().write("def".getBytes(UTF_8));
-    stream1.getOutputStream().close();
+    sink1.writeUtf8("def");
+    sink1.close();
     try {
-      connection.newStream(Arrays.asList("c", "cola"), true, true);
+      connection.newStream(headerEntries("c", "cola"), true, true);
       fail();
     } catch (IOException expected) {
       assertEquals("shutdown", expected.getMessage());
     }
+    assertTrue(stream1.isOpen());
+    assertFalse(stream2.isOpen());
     assertEquals(1, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -744,13 +765,13 @@
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // GOAWAY
     peer.acceptFrame(); // PING
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, Arrays.asList("b", "b")); // Should be ignored!
+    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("b", "b")); // Should be ignored!
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    connection.newStream(Arrays.asList("a", "android"), true, true);
+    SpdyConnection connection = connection(peer, SPDY3);
+    connection.newStream(headerEntries("a", "android"), true, true);
     Ping ping = connection.ping();
     connection.shutdown(PROTOCOL_ERROR);
     assertEquals(1, connection.openStreamCount());
@@ -773,7 +794,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     connection.shutdown(INTERNAL_ERROR);
     try {
       connection.ping();
@@ -796,25 +817,27 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, true);
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     assertEquals(1, connection.openStreamCount());
     connection.close();
     assertEquals(0, connection.openStreamCount());
     try {
-      connection.newStream(Arrays.asList("b", "banana"), true, true);
+      connection.newStream(headerEntries("b", "banana"), true, true);
       fail();
     } catch (IOException expected) {
       assertEquals("shutdown", expected.getMessage());
     }
+    BufferedSink sink = Okio.buffer(stream.getSink());
     try {
-      stream.getOutputStream().write(0);
+      sink.writeByte(0);
+      sink.flush();
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: CANCEL", expected.getMessage());
     }
     try {
-      stream.getInputStream().read();
+      stream.getSource().read(new Buffer(), 1);
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: CANCEL", expected.getMessage());
@@ -838,55 +861,116 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     Ping ping = connection.ping();
     connection.close();
     assertEquals(-1, ping.roundTripTime());
   }
 
-  @Test public void readTimeoutExpires() throws Exception {
+  @Test public void getResponseHeadersTimesOut() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    long startNanos = System.nanoTime();
+    try {
+      stream.getResponseHeaders();
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void readTimesOut() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    Source source = stream.getSource();
+    long startNanos = System.nanoTime();
+    try {
+      source.read(new Buffer(), 1);
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
+    // Set the peer's receive window to 5 bytes!
+    Settings peerSettings = new Settings().set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
+
+    // write the mocking script
+    peer.sendFrame().settings(peerSettings);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
-    stream.setReadTimeout(1000);
-    InputStream in = stream.getInputStream();
+    SpdyConnection connection = connection(peer, SPDY3);
+    connection.ping().roundTripTime(); // Make sure settings have been received.
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    Sink sink = stream.getSink();
+    sink.write(new Buffer().writeUtf8("abcde"), 5);
+    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
     long startNanos = System.nanoTime();
     try {
-      in.read();
+      sink.write(new Buffer().writeUtf8("f"), 1); // This will time out waiting on the write window.
       fail();
-    } catch (IOException expected) {
+    } catch (InterruptedIOException expected) {
     }
     long elapsedNanos = System.nanoTime() - startNanos;
-    assertEquals(1000d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(1, connection.openStreamCount());
-    connection.ping().roundTripTime(); // Prevent the peer from exiting prematurely.
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
+    assertEquals(TYPE_PING, peer.takeFrame().type);
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_DATA, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
   }
 
   @Test public void headers() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
-    peer.sendFrame().headers(1, Arrays.asList("c", "c3po"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().headers(1, headerEntries("c", "c3po"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
-    assertEquals(Arrays.asList("a", "android", "c", "c3po"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android", "c", "c3po"), stream.getResponseHeaders());
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
@@ -900,14 +984,14 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().headers(1, Arrays.asList("c", "c3po"));
+    peer.sendFrame().headers(1, headerEntries("c", "c3po"));
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
     try {
       stream.getResponseHeaders();
@@ -928,105 +1012,254 @@
   }
 
   @Test public void readSendsWindowUpdate() throws Exception {
+    peer.setVariantAndClient(SPDY3, false);
+
+    int windowSize = 100;
+    int windowUpdateThreshold = 50;
+
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     for (int i = 0; i < 3; i++) {
-      peer.sendFrame().data(false, 1, new byte[WINDOW_UPDATE_THRESHOLD]);
-      peer.acceptFrame(); // WINDOW UPDATE
+      // Send frames of summing to size 50, which is windowUpdateThreshold.
+      peer.sendFrame().data(false, 1, data(24), 24);
+      peer.sendFrame().data(false, 1, data(25), 25);
+      peer.sendFrame().data(false, 1, data(1), 1);
+      peer.acceptFrame(); // connection WINDOW UPDATE
+      peer.acceptFrame(); // stream WINDOW UPDATE
     }
-    peer.sendFrame().data(true, 1, new byte[0]);
+    peer.sendFrame().data(true, 1, data(0), 0);
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
-    assertEquals(Arrays.asList("a", "android"), stream.getResponseHeaders());
-    InputStream in = stream.getInputStream();
-    int total = 0;
-    byte[] buffer = new byte[1024];
-    int count;
-    while ((count = in.read(buffer)) != -1) {
-      total += count;
-      if (total == 3 * WINDOW_UPDATE_THRESHOLD) break;
-    }
-    assertEquals(-1, in.read());
+    SpdyConnection connection = connection(peer, SPDY3);
+    connection.okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, windowSize);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(0, stream.unacknowledgedBytesRead);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    Source in = stream.getSource();
+    Buffer buffer = new Buffer();
+    buffer.writeAll(in);
+    assertEquals(-1, in.read(buffer, 1));
+    assertEquals(150, buffer.size());
 
-    // Verify the peer received what was expected.
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream.type);
     for (int i = 0; i < 3; i++) {
-      MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
-      assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
-      assertEquals(1, windowUpdate.streamId);
-      assertEquals(WINDOW_UPDATE_THRESHOLD, windowUpdate.deltaWindowSize);
+      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
+      for (int j = 0; j < 2; j++) {
+        MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
+        assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
+        windowUpdateStreamIds.add(windowUpdate.streamId);
+        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+      }
+      assertTrue(windowUpdateStreamIds.contains(0)); // connection
+      assertTrue(windowUpdateStreamIds.contains(1)); // stream
     }
   }
 
-  @Test public void writeAwaitsWindowUpdate() throws Exception {
-    // Write the mocking script. This accepts more data frames than necessary!
+  private Buffer data(int byteCount) {
+    return new Buffer().write(new byte[byteCount]);
+  }
+
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
+    peer.setVariantAndClient(SPDY3, false);
+
+    // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
-    for (int i = 0; i < Settings.DEFAULT_INITIAL_WINDOW_SIZE / 1024; i++) {
-      peer.acceptFrame(); // DATA
-    }
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 1, data(0), 0);
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
-    OutputStream out = stream.getOutputStream();
-    out.write(new byte[Settings.DEFAULT_INITIAL_WINDOW_SIZE]);
-    interruptAfterDelay(500);
-    try {
-      out.write('a');
-      out.flush();
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
     // Verify the peer received what was expected.
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream.type);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(TYPE_DATA, data.type);
+    assertEquals(3, peer.frameCount());
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
+    peer.setVariantAndClient(SPDY3, false);
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), true, true);
+    BufferedSink out = Okio.buffer(client.getSink());
+    out.write(Util.EMPTY_BYTE_ARRAY);
+    out.flush();
+    out.close();
+
+    // Verify the peer received what was expected.
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_DATA, peer.takeFrame().type);
+    assertEquals(3, peer.frameCount());
   }
 
   @Test public void testTruncatedDataFrame() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
-    peer.sendTruncatedFrame(8 + 100).data(false, 1, new byte[1024]);
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().data(false, 1, data(1024), 1024);
+    peer.truncateLastFrame(8 + 100);
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
-    assertEquals(Arrays.asList("a", "android"), stream.getResponseHeaders());
-    InputStream in = stream.getInputStream();
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    Source in = stream.getSource();
     try {
-      Util.readFully(in, new byte[101]);
+      Okio.buffer(in).readByteString(101);
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
     }
   }
 
-  private void writeAndClose(SpdyStream stream, String data) throws IOException {
-    OutputStream out = stream.getOutputStream();
-    out.write(data.getBytes("UTF-8"));
-    out.close();
-  }
+  @Test public void blockedStreamDoesntStarveNewStream() throws Exception {
+    int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, peer.maxOutboundDataLength());
 
-  private void assertStreamData(String expected, InputStream inputStream) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    byte[] buffer = new byte[1024];
-    for (int count; (count = inputStream.read(buffer)) != -1; ) {
-      bytesOut.write(buffer, 0, count);
+    // Write the mocking script. This accepts more data frames than necessary!
+    peer.acceptFrame(); // SYN_STREAM on stream 1
+    for (int i = 0; i < framesThatFillWindow; i++) {
+      peer.acceptFrame(); // DATA on stream 1
     }
-    String actual = bytesOut.toString("UTF-8");
+    peer.acceptFrame(); // SYN_STREAM on stream 2
+    peer.acceptFrame(); // DATA on stream 2
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream1 = connection.newStream(headerEntries("a", "apple"), true, true);
+    BufferedSink out1 = Okio.buffer(stream1.getSink());
+    out1.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
+    out1.flush();
+
+    // Check that we've filled the window for both the stream and also the connection.
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+
+    // receiving a window update on the the connection will unblock new streams.
+    connection.readerRunnable.windowUpdate(0, 3);
+
+    assertEquals(3, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+
+    // Another stream should be able to send data even though 1 is blocked.
+    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
+    BufferedSink out2 = Okio.buffer(stream2.getSink());
+    out2.writeUtf8("foo");
+    out2.flush();
+
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE - 3, connection.getStream(3).bytesLeftInWriteWindow);
+  }
+
+  /** https://github.com/square/okhttp/issues/333 */
+  @Test public void headerBlockHasTrailingCompressedBytes512() throws Exception {
+    // This specially-formatted frame has trailing deflated bytes after the name value block.
+    String frame = "gAMAAgAAAgkAAAABeLvjxqfCYgAAAAD//2IAAAAA//9iAAAAAP//YgQAAAD//2IAAAAA//9iAAAAAP/"
+        + "/YgAAAAD//2IEAAAA//9KBAAAAP//YgAAAAD//2IAAAAA//9iAAAAAP//sgEAAAD//2IAAAAA\n//9iBAAAAP//Y"
+        + "gIAAAD//2IGAAAA//9iAQAAAP//YgUAAAD//2IDAAAA//9iBwAAAP//4gAAAAD//+IEAAAA///iAgAAAP//4gYAA"
+        + "AD//+IBAAAA///iBQAAAP//4gMAAAD//+IHAAAA//8SAAAAAP//EgQAAAD//xICAAAA//8SBgAAAP//EgEAAAD//"
+        + "xIFAAAA//8SAwAAAP//EgcAAAD//5IAAAAA//+SBAAAAP//kgIAAAD//5IGAAAA//+SAQAAAP//kgUAAAD//5IDA"
+        + "AAA//+SBwAAAP//UgAAAAD//1IEAAAA//9SAgAAAP//UgYAAAD//1IBAAAA//9SBQAAAP//UgMAAAD//1IHAAAA/"
+        + "//SAAAAAP//0gQAAAD//9ICAAAA///SBgAAAP//0gEAAAD//9IFAAAA///SAwAAAP//0gcAAAD//zIAAAAA//8yB"
+        + "AAAAP//MgIAAAD//zIGAAAA//8yAQAAAP//MgUAAAD//zIDAAAA//8yBwAAAP//sgAAAAD//7IEAAAA//+yAgAAA"
+        + "P//sgYAAAD//w==";
+    headerBlockHasTrailingCompressedBytes(frame, 60);
+  }
+
+  @Test public void headerBlockHasTrailingCompressedBytes2048() throws Exception {
+    // This specially-formatted frame has trailing deflated bytes after the name value block.
+    String frame = "gAMAAgAAB/sAAAABeLvjxqfCAqYjRhAGJmxGxUQAAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
+        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
+        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
+        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
+        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
+        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
+        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
+        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
+        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
+        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
+        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
+        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
+        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
+        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
+        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
+        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
+        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
+        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
+        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
+        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
+        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
+        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
+        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
+        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
+        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
+        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
+        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
+        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
+        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
+        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
+        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
+        + "AAAD//0oEAAAA//8=";
+    headerBlockHasTrailingCompressedBytes(frame, 289);
+  }
+
+  private void headerBlockHasTrailingCompressedBytes(String frame, int length) throws IOException {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    byte[] trailingCompressedBytes = ByteString.decodeBase64(frame).toByteArray();
+    trailingCompressedBytes[11] = 1; // Set SPDY/3 stream ID to 3.
+    peer.sendFrame(trailingCompressedBytes);
+    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"), 5);
+    peer.acceptFrame(); // DATA
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals("a", stream.getResponseHeaders().get(0).name.utf8());
+    assertEquals(length, stream.getResponseHeaders().get(0).value.size());
+    assertStreamData("robot", stream.getSource());
+  }
+
+  private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
+    return connectionBuilder(peer, variant).build();
+  }
+
+  private SpdyConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
+      throws IOException {
+    return new SpdyConnection.Builder(true, peer.openSocket())
+        .protocol(variant.getProtocol());
+  }
+
+  private void assertStreamData(String expected, Source source) throws IOException {
+    String actual = Okio.buffer(source).readUtf8();
     assertEquals(expected, actual);
   }
 
+  private void assertFlushBlocks(BufferedSink out) throws IOException {
+    interruptAfterDelay(500);
+    try {
+      out.flush();
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+  }
+
   /** Interrupts the current thread after {@code delayMillis}. */
   private void interruptAfterDelay(final long delayMillis) {
     final Thread toInterrupt = Thread.currentThread();
@@ -1041,4 +1274,8 @@ private void interruptAfterDelay(final long delayMillis) {
       }
     }.start();
   }
+
+  static int roundUp(int num, int divisor) {
+    return (num + divisor - 1) / divisor;
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
new file mode 100644
index 0000000000..c902773c9f
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class Spdy3Test {
+  static final int expectedStreamId = 15;
+
+  @Test public void tooLargeDataFrame() throws IOException {
+    try {
+      sendDataFrame(new Buffer().write(new byte[0x1000000]));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("FRAME_TOO_LARGE max size is 16Mib: " + 0x1000000L, e.getMessage());
+    }
+  }
+
+  @Test public void badWindowSizeIncrement() throws IOException {
+    try {
+      windowUpdate(0);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 0", e.getMessage());
+    }
+    try {
+      windowUpdate(0x80000000L);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 2147483648",
+          e.getMessage());
+    }
+  }
+
+  @Test public void goAwayRoundTrip() throws IOException {
+    Buffer frame = new Buffer();
+
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+
+    // Compose the expected GOAWAY frame without debug data
+    // |C| Version(15bits) | Type(16bits) |
+    frame.writeInt(0x80000000 | (Spdy3.VERSION & 0x7fff) << 16 | Spdy3.TYPE_GOAWAY & 0xffff);
+    // | Flags (8)  |  Length (24 bits)   |
+    frame.writeInt(8); // no flags and length is 8.
+    frame.writeInt(expectedStreamId); // last good stream.
+    frame.writeInt(expectedError.spdyGoAwayCode);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
+
+    // SPDY/3 does not send debug data, so bytes should be same!
+    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, new byte[8]));
+
+    FrameReader fr = new Spdy3.Reader(frame, false);
+
+    fr.nextFrame(new BaseTestHandler() { // Consume the goAway frame.
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+        assertEquals(expectedStreamId, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertEquals(0, debugData.size());
+      }
+    });
+  }
+
+  private void sendDataFrame(Buffer source) throws IOException {
+    Spdy3.Writer writer = new Spdy3.Writer(new Buffer(), true);
+    writer.sendDataFrame(expectedStreamId, 0, source, (int) source.size());
+  }
+
+  private void windowUpdate(long increment) throws IOException {
+    new Spdy3.Writer(new Buffer(), true).windowUpdate(expectedStreamId, increment);
+  }
+
+  private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+      throws IOException {
+    Buffer out = new Buffer();
+    new Spdy3.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
+    return out;
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
similarity index 99%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
index f1decc8df0..d7f1c78cb8 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
@@ -289,7 +289,7 @@
         + "G9Z6tyMbmfRY+dLSh3a9JwoEcBUso6EWYBakLbq4nG/nvYdYvG9ehrnLVwZFL82e\n"
         + "l3Q/RK95bnA6cuRClGusLad0e6bjkBzx/VQ3VarDEpAkTLUGVAa0CLXtnyc=\n"
         + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("foo.com", session));
+    assertFalse(verifier.verify("foo.com", session));
     assertTrue(verifier.verify("www.foo.com", session));
     assertTrue(verifier.verify("\u82b1\u5b50.foo.com", session));
     assertFalse(verifier.verify("a.b.foo.com", session));
@@ -510,7 +510,7 @@
     assertFalse(verifier.verify("foo.com", session));
     assertTrue(verifier.verify("bar.com", session));
     assertTrue(verifier.verify("a.baz.com", session));
-    assertTrue(verifier.verify("baz.com", session));
+    assertFalse(verifier.verify("baz.com", session));
     assertFalse(verifier.verify("a.foo.com", session));
     assertFalse(verifier.verify("a.bar.com", session));
     assertFalse(verifier.verify("quux.com", session));
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
new file mode 100644
index 0000000000..7e7f05a2c8
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/RealWebSocketTest.java
@@ -0,0 +1,280 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.ws;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.BINARY;
+import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.TEXT;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class RealWebSocketTest {
+  // NOTE: Types are named 'client' and 'server' for cognitive simplicity. This differentiation has
+  // zero effect on the behavior of the WebSocket API which is why tests are only written once
+  // from the perspective of a single peer.
+
+  private RealWebSocket client;
+  private boolean clientConnectionClosed;
+  private final Buffer client2Server = new Buffer();
+  private final WebSocketRecorder clientListener = new WebSocketRecorder();
+
+  private RealWebSocket server;
+  private final Buffer server2client = new Buffer();
+  private final WebSocketRecorder serverListener = new WebSocketRecorder();
+
+  @Before public void setUp() {
+    Random random = new Random(0);
+
+    client = new RealWebSocket(true, server2client, client2Server, random, clientListener,
+        "http://example.com/websocket") {
+      @Override protected void closeConnection() throws IOException {
+        clientConnectionClosed = true;
+      }
+    };
+    server = new RealWebSocket(false, client2Server, server2client, random, serverListener,
+        "http://example.com/websocket") {
+      @Override protected void closeConnection() throws IOException {
+      }
+    };
+  }
+
+  @After public void tearDown() {
+    clientListener.assertExhausted();
+    serverListener.assertExhausted();
+  }
+
+  @Test public void textMessage() throws IOException {
+    client.sendMessage(TEXT, new Buffer().writeUtf8("Hello!"));
+    server.readMessage();
+    serverListener.assertTextMessage("Hello!");
+  }
+
+  @Test public void binaryMessage() throws IOException {
+    client.sendMessage(BINARY, new Buffer().writeUtf8("Hello!"));
+    server.readMessage();
+    serverListener.assertBinaryMessage(new byte[] { 'H', 'e', 'l', 'l', 'o', '!' });
+  }
+
+  @Test public void streamingMessage() throws IOException {
+    BufferedSink sink = client.newMessageSink(TEXT);
+    sink.writeUtf8("Hel").flush();
+    sink.writeUtf8("lo!").flush();
+    sink.close();
+    server.readMessage();
+    serverListener.assertTextMessage("Hello!");
+  }
+
+  @Test public void streamingMessageCanInterleavePing() throws IOException, InterruptedException {
+    BufferedSink sink = client.newMessageSink(TEXT);
+    sink.writeUtf8("Hel").flush();
+    client.sendPing(new Buffer().writeUtf8("Pong?"));
+    sink.writeUtf8("lo!").flush();
+    sink.close();
+    server.readMessage();
+    serverListener.assertTextMessage("Hello!");
+    Thread.sleep(1000); // Wait for pong to be written.
+    client.readMessage();
+    clientListener.assertPong(new Buffer().writeUtf8("Pong?"));
+  }
+
+  @Test public void pingWritesPong() throws IOException, InterruptedException {
+    client.sendPing(new Buffer().writeUtf8("Hello!"));
+    server.readMessage(); // Read the ping, enqueue the pong.
+    Thread.sleep(1000); // Wait for pong to be written.
+    client.readMessage();
+    clientListener.assertPong(new Buffer().writeUtf8("Hello!"));
+  }
+
+  @Test public void unsolicitedPong() throws IOException {
+    client.sendPong(new Buffer().writeUtf8("Hello!"));
+    server.readMessage();
+    serverListener.assertPong(new Buffer().writeUtf8("Hello!"));
+  }
+
+  @Test public void close() throws IOException {
+    client.close(1000, "Hello!");
+    server.readMessage(); // This will trigger a close response.
+    serverListener.assertClose(1000, "Hello!");
+    client.readMessage();
+    clientListener.assertClose(1000, "Hello!");
+  }
+
+  @Test public void clientCloseThenMethodsThrow() throws IOException {
+    client.close(1000, "Hello!");
+
+    try {
+      client.sendPing(new Buffer().writeUtf8("Pong?"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Closed", e.getMessage());
+    }
+    try {
+      client.close(1000, "Hello!");
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Closed", e.getMessage());
+    }
+    try {
+      client.sendMessage(TEXT, new Buffer().writeUtf8("Hello!"));
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Closed", e.getMessage());
+    }
+    try {
+      client.newMessageSink(TEXT);
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Closed", e.getMessage());
+    }
+  }
+
+  @Test public void serverCloseThenWritingThrows() throws IOException {
+    server.close(1000, "Hello!");
+    client.readMessage();
+    clientListener.assertClose(1000, "Hello!");
+
+    try {
+      client.sendPing(new Buffer().writeUtf8("Pong?"));
+      fail();
+    } catch (IOException e) {
+      assertEquals("Closed", e.getMessage());
+    }
+    try {
+      client.sendMessage(TEXT, new Buffer().writeUtf8("Hi!"));
+      fail();
+    } catch (IOException e) {
+      assertEquals("Closed", e.getMessage());
+    }
+    try {
+      client.close(1000, "Bye!");
+      fail();
+    } catch (IOException e) {
+      assertEquals("Closed", e.getMessage());
+    }
+  }
+
+  @Test public void serverCloseWhileWritingThrows() throws IOException {
+    // Start writing data.
+    BufferedSink sink = client.newMessageSink(TEXT);
+    sink.writeUtf8("Hel").flush();
+
+    server.close(1000, "Hello!");
+    client.readMessage();
+    clientListener.assertClose(1000, "Hello!");
+
+    try {
+      sink.writeUtf8("lo!").emit(); // No writing to the underlying sink.
+      fail();
+    } catch (IOException e) {
+      assertEquals("Closed", e.getMessage());
+      sink.buffer().clear();
+    }
+    try {
+      sink.flush(); // No flushing.
+      fail();
+    } catch (IOException e) {
+      assertEquals("Closed", e.getMessage());
+    }
+    try {
+      sink.close(); // No closing because this requires writing a frame.
+      fail();
+    } catch (IOException e) {
+      assertEquals("Closed", e.getMessage());
+    }
+  }
+
+  @Test public void clientCloseClosesConnection() throws IOException {
+    client.close(1000, "Hello!");
+    assertFalse(clientConnectionClosed);
+    server.readMessage(); // Read client close, send server close.
+    serverListener.assertClose(1000, "Hello!");
+
+    client.readMessage();
+    assertTrue(clientConnectionClosed);
+    clientListener.assertClose(1000, "Hello!");
+  }
+
+  @Test public void serverCloseClosesConnection() throws IOException {
+    server.close(1000, "Hello!");
+
+    client.readMessage(); // Read server close, send client close, close connection.
+    clientListener.assertClose(1000, "Hello!");
+    assertTrue(clientConnectionClosed);
+
+    server.readMessage();
+    serverListener.assertClose(1000, "Hello!");
+  }
+
+  @Test public void clientAndServerCloseClosesConnection() throws IOException {
+    // Send close from both sides at the same time.
+    server.close(1000, "Hello!");
+    client.close(1000, "Hi!");
+    assertFalse(clientConnectionClosed);
+
+    client.readMessage(); // Read close, should NOT send close.
+    assertTrue(clientConnectionClosed);
+    clientListener.assertClose(1000, "Hello!");
+
+    server.readMessage();
+    serverListener.assertClose(1000, "Hi!");
+
+    serverListener.assertExhausted(); // Client should not have sent second close.
+    clientListener.assertExhausted(); // Server should not have sent second close.
+  }
+
+  @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
+    server.sendMessage(TEXT, new Buffer().writeUtf8("Hello!"));
+    server.close(1000, "Bye!");
+    assertTrue(client.readMessage());
+    clientListener.assertTextMessage("Hello!");
+    assertFalse(client.readMessage());
+    clientListener.assertClose(1000, "Bye!");
+  }
+
+  @Test public void protocolErrorBeforeCloseSendsClose() {
+    server2client.write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
+
+    client.readMessage(); // Detects error, send close.
+    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
+    assertTrue(clientConnectionClosed);
+
+    server.readMessage();
+    serverListener.assertClose(1002, "");
+  }
+
+  @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
+    client.close(1000, "Hello!");
+    server2client.write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
+
+    client.readMessage();
+    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
+    assertTrue(clientConnectionClosed);
+
+    server.readMessage();
+    serverListener.assertClose(1000, "Hello!");
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketCallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketCallTest.java
new file mode 100644
index 0000000000..c0a5d4654d
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketCallTest.java
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.ws;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.RecordedResponse;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import okio.Buffer;
+import okio.BufferedSource;
+import org.junit.After;
+import org.junit.Rule;
+import org.junit.Test;
+
+public final class WebSocketCallTest {
+  @Rule public final MockWebServerRule server = new MockWebServerRule();
+
+  private final WebSocketRecorder listener = new WebSocketRecorder();
+  private final OkHttpClient client = new OkHttpClient();
+  private final Random random = new Random(0);
+
+  @After public void tearDown() {
+    listener.assertExhausted();
+  }
+
+  @Test public void okButNotOk() {
+    server.enqueue(new MockResponse());
+    awaitCall();
+    listener.assertFailure(ProtocolException.class, "Expected HTTP 101 response but was '200 OK'");
+  }
+
+  @Test public void notFound() {
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
+    awaitCall();
+    listener.assertFailure(ProtocolException.class,
+        "Expected HTTP 101 response but was '404 Not Found'");
+  }
+
+  @Test public void missingConnectionHeader() {
+    server.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    awaitCall();
+    listener.assertFailure(ProtocolException.class,
+        "Expected 'Connection' header value 'Upgrade' but was 'null'");
+  }
+
+  @Test public void wrongConnectionHeader() {
+    server.enqueue(new MockResponse().setResponseCode(101)
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Connection", "Downgrade")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    awaitCall();
+    listener.assertFailure(ProtocolException.class,
+        "Expected 'Connection' header value 'Upgrade' but was 'Downgrade'");
+  }
+
+  @Test public void missingUpgradeHeader() {
+    server.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    awaitCall();
+    listener.assertFailure(ProtocolException.class,
+        "Expected 'Upgrade' header value 'websocket' but was 'null'");
+  }
+
+  @Test public void wrongUpgradeHeader() {
+    server.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "Pepsi")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    awaitCall();
+    listener.assertFailure(ProtocolException.class,
+        "Expected 'Upgrade' header value 'websocket' but was 'Pepsi'");
+  }
+
+  @Test public void missingMagicHeader() {
+    server.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "websocket"));
+    awaitCall();
+    listener.assertFailure(ProtocolException.class,
+        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'null'");
+  }
+
+  @Test public void wrongMagicHeader() {
+    server.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Sec-WebSocket-Accept", "magic"));
+    awaitCall();
+    listener.assertFailure(ProtocolException.class,
+        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
+  }
+
+  private RecordedResponse awaitCall() {
+    Request request = new Request.Builder().get().url(server.getUrl("/")).build();
+    WebSocketCall call = new WebSocketCall(client, request, random);
+
+    final AtomicReference<Response> responseRef = new AtomicReference<>();
+    final AtomicReference<WebSocket> webSocketRef = new AtomicReference<>();
+    final AtomicReference<IOException> failureRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new WebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Request request, Response response)
+          throws IOException {
+        webSocketRef.set(webSocket);
+        responseRef.set(response);
+        latch.countDown();
+      }
+
+      @Override public void onMessage(BufferedSource payload, WebSocket.PayloadType type)
+          throws IOException {
+        listener.onMessage(payload, type);
+      }
+
+      @Override public void onPong(Buffer payload) {
+        listener.onPong(payload);
+      }
+
+      @Override public void onClose(int code, String reason) {
+        listener.onClose(code, reason);
+      }
+
+      @Override public void onFailure(IOException e) {
+        listener.onFailure(e);
+        failureRef.set(e);
+        latch.countDown();
+      }
+    });
+
+    try {
+      latch.await(10, TimeUnit.SECONDS);
+    } catch (InterruptedException e) {
+      throw new AssertionError(e);
+    }
+    if (latch.getCount() > 0) {
+      throw new AssertionError("Timed out.");
+    }
+
+    return new RecordedResponse(request, responseRef.get(), webSocketRef.get(), null,
+        failureRef.get());
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
new file mode 100644
index 0000000000..2f9dda8bee
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketReaderTest.java
@@ -0,0 +1,335 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.ws;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.concurrent.atomic.AtomicReference;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import org.junit.After;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
+import static com.squareup.okhttp.internal.ws.WebSocketRecorder.MessageDelegate;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.fail;
+
+public class WebSocketReaderTest {
+  private final Buffer data = new Buffer();
+  private final WebSocketRecorder callback = new WebSocketRecorder();
+  private final Random random = new Random(0);
+
+  // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
+  private final WebSocketReader serverReader = new WebSocketReader(false, data, callback);
+  private final WebSocketReader clientReader = new WebSocketReader(true, data, callback);
+
+  @After public void tearDown() {
+    callback.assertExhausted();
+  }
+
+  @Test public void controlFramesMustBeFinal() throws IOException {
+    data.write(ByteString.decodeHex("0a00")); // Empty ping.
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Control frames must be final.", e.getMessage());
+    }
+  }
+
+  @Test public void reservedFlagsAreUnsupported() throws IOException {
+    data.write(ByteString.decodeHex("9a00")); // Empty ping, flag 1 set.
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Reserved flags are unsupported.", e.getMessage());
+    }
+    data.clear();
+    data.write(ByteString.decodeHex("aa00")); // Empty ping, flag 2 set.
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Reserved flags are unsupported.", e.getMessage());
+    }
+    data.clear();
+    data.write(ByteString.decodeHex("ca00")); // Empty ping, flag 3 set.
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Reserved flags are unsupported.", e.getMessage());
+    }
+  }
+
+  @Test public void clientSentFramesMustBeMasked() throws IOException {
+    data.write(ByteString.decodeHex("8100"));
+    try {
+      serverReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Client-sent frames must be masked. Server sent must not.", e.getMessage());
+    }
+  }
+
+  @Test public void serverSentFramesMustNotBeMasked() throws IOException {
+    data.write(ByteString.decodeHex("8180"));
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Client-sent frames must be masked. Server sent must not.", e.getMessage());
+    }
+  }
+
+  @Test public void controlFramePayloadMax() throws IOException {
+    data.write(ByteString.decodeHex("8a7e007e"));
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Control frame must be less than 125B.", e.getMessage());
+    }
+  }
+
+  @Test public void clientSimpleHello() throws IOException {
+    data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
+    clientReader.processNextFrame();
+    callback.assertTextMessage("Hello");
+  }
+
+  @Test public void serverSimpleHello() throws IOException {
+    data.write(ByteString.decodeHex("818537fa213d7f9f4d5158")); // Hello
+    serverReader.processNextFrame();
+    callback.assertTextMessage("Hello");
+  }
+
+  @Test public void serverHelloTwoChunks() throws IOException {
+    data.write(ByteString.decodeHex("818537fa213d7f9f4d")); // Hel
+
+    final Buffer sink = new Buffer();
+    callback.setNextMessageDelegate(new MessageDelegate() {
+      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
+        payload.readFully(sink, 3); // Read "Hel"
+        data.write(ByteString.decodeHex("5158")); // lo
+        payload.readFully(sink, 2); // Read "lo"
+        payload.close();
+      }
+    });
+    serverReader.processNextFrame();
+
+    assertEquals("Hello", sink.readUtf8());
+  }
+
+  @Test public void clientTwoFrameHello() throws IOException {
+    data.write(ByteString.decodeHex("010348656c")); // Hel
+    data.write(ByteString.decodeHex("80026c6f")); // lo
+    clientReader.processNextFrame();
+    callback.assertTextMessage("Hello");
+  }
+
+  @Test public void clientTwoFrameHelloWithPongs() throws IOException {
+    data.write(ByteString.decodeHex("010348656c")); // Hel
+    data.write(ByteString.decodeHex("8a00")); // Pong
+    data.write(ByteString.decodeHex("8a00")); // Pong
+    data.write(ByteString.decodeHex("8a00")); // Pong
+    data.write(ByteString.decodeHex("8a00")); // Pong
+    data.write(ByteString.decodeHex("80026c6f")); // lo
+    clientReader.processNextFrame();
+    callback.assertPong(null);
+    callback.assertPong(null);
+    callback.assertPong(null);
+    callback.assertPong(null);
+    callback.assertTextMessage("Hello");
+  }
+
+  @Test public void clientIncompleteMessageBodyThrows() throws IOException {
+    data.write(ByteString.decodeHex("810548656c")); // Length = 5, "Hel"
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (EOFException ignored) {
+    }
+  }
+
+  @Test public void clientIncompleteControlFrameBodyThrows() throws IOException {
+    data.write(ByteString.decodeHex("8a0548656c")); // Length = 5, "Hel"
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (EOFException ignored) {
+    }
+  }
+
+  @Test public void serverIncompleteMessageBodyThrows() throws IOException {
+    data.write(ByteString.decodeHex("818537fa213d7f9f4d")); // Length = 5, "Hel"
+    try {
+      serverReader.processNextFrame();
+      fail();
+    } catch (EOFException ignored) {
+    }
+  }
+
+  @Test public void serverIncompleteControlFrameBodyThrows() throws IOException {
+    data.write(ByteString.decodeHex("8a8537fa213d7f9f4d")); // Length = 5, "Hel"
+    try {
+      serverReader.processNextFrame();
+      fail();
+    } catch (EOFException ignored) {
+    }
+  }
+
+  @Test public void clientSimpleBinary() throws IOException {
+    byte[] bytes = binaryData(256);
+    data.write(ByteString.decodeHex("827E0100")).write(bytes);
+    clientReader.processNextFrame();
+    callback.assertBinaryMessage(bytes);
+  }
+
+  @Test public void clientTwoFrameBinary() throws IOException {
+    byte[] bytes = binaryData(200);
+    data.write(ByteString.decodeHex("0264")).write(bytes, 0, 100);
+    data.write(ByteString.decodeHex("8064")).write(bytes, 100, 100);
+    clientReader.processNextFrame();
+    callback.assertBinaryMessage(bytes);
+  }
+
+  @Test public void twoFrameNotContinuation() throws IOException {
+    byte[] bytes = binaryData(200);
+    data.write(ByteString.decodeHex("0264")).write(bytes, 0, 100);
+    data.write(ByteString.decodeHex("8264")).write(bytes, 100, 100);
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (ProtocolException e) {
+      assertEquals("Expected continuation opcode. Got: 2", e.getMessage());
+    }
+  }
+
+  @Test public void noCloseErrors() throws IOException {
+    data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
+    callback.setNextMessageDelegate(new MessageDelegate() {
+      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
+        payload.readAll(new Buffer());
+      }
+    });
+    try {
+      clientReader.processNextFrame();
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Listener failed to call close on message payload.", e.getMessage());
+    }
+  }
+
+  @Test public void closeExhaustsMessage() throws IOException {
+    data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
+    data.write(ByteString.decodeHex("810448657921")); // Hey!
+
+    final Buffer sink = new Buffer();
+    callback.setNextMessageDelegate(new MessageDelegate() {
+      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
+        payload.read(sink, 3);
+        payload.close();
+      }
+    });
+
+    clientReader.processNextFrame();
+    assertEquals("Hel", sink.readUtf8());
+
+    clientReader.processNextFrame();
+    callback.assertTextMessage("Hey!");
+  }
+
+  @Test public void closeExhaustsMessageOverControlFrames() throws IOException {
+    data.write(ByteString.decodeHex("010348656c")); // Hel
+    data.write(ByteString.decodeHex("8a00")); // Pong
+    data.write(ByteString.decodeHex("8a00")); // Pong
+    data.write(ByteString.decodeHex("80026c6f")); // lo
+    data.write(ByteString.decodeHex("810448657921")); // Hey!
+
+    final Buffer sink = new Buffer();
+    callback.setNextMessageDelegate(new MessageDelegate() {
+      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
+        payload.read(sink, 2);
+        payload.close();
+      }
+    });
+
+    clientReader.processNextFrame();
+    assertEquals("He", sink.readUtf8());
+    callback.assertPong(null);
+    callback.assertPong(null);
+
+    clientReader.processNextFrame();
+    callback.assertTextMessage("Hey!");
+  }
+
+  @Test public void closedMessageSourceThrows() throws IOException {
+    data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
+
+    final AtomicReference<Exception> exception = new AtomicReference<>();
+    callback.setNextMessageDelegate(new MessageDelegate() {
+      @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
+        payload.close();
+        try {
+          payload.readAll(new Buffer());
+          fail();
+        } catch (IllegalStateException e) {
+          exception.set(e);
+        }
+      }
+    });
+    clientReader.processNextFrame();
+
+    assertNotNull(exception.get());
+  }
+
+  @Test public void emptyPingCallsCallback() throws IOException {
+    data.write(ByteString.decodeHex("8900")); // Empty ping
+    clientReader.processNextFrame();
+    callback.assertPing(null);
+  }
+
+  @Test public void pingCallsCallback() throws IOException {
+    data.write(ByteString.decodeHex("890548656c6c6f")); // Ping with "Hello"
+    clientReader.processNextFrame();
+    callback.assertPing(new Buffer().writeUtf8("Hello"));
+  }
+
+  @Test public void emptyCloseCallsCallback() throws IOException {
+    data.write(ByteString.decodeHex("8800")); // Empty close
+    clientReader.processNextFrame();
+    callback.assertClose(0, "");
+  }
+
+  @Test public void closeCallsCallback() throws IOException {
+    data.write(ByteString.decodeHex("880703e848656c6c6f")); // Close with code and reason
+    clientReader.processNextFrame();
+    callback.assertClose(1000, "Hello");
+  }
+
+  private byte[] binaryData(int length) {
+    byte[] junk = new byte[length];
+    random.nextBytes(junk);
+    return junk;
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketRecorder.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketRecorder.java
new file mode 100644
index 0000000000..c2000d4880
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketRecorder.java
@@ -0,0 +1,213 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.ws;
+
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import okio.Buffer;
+import okio.BufferedSource;
+
+import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.BINARY;
+import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.TEXT;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+final class WebSocketRecorder implements WebSocketReader.FrameCallback, WebSocketListener {
+  public interface MessageDelegate {
+    void onMessage(BufferedSource payload, WebSocket.PayloadType type) throws IOException;
+  }
+
+  private final Deque<Object> events = new ArrayDeque<>();
+  private MessageDelegate delegate;
+
+  /** Sets a delegate for the next call to {@link #onMessage}. Cleared after invoked. */
+  public void setNextMessageDelegate(MessageDelegate delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public void onOpen(WebSocket webSocket, Request request, Response response) {
+    throw new AssertionError();
+  }
+
+  @Override public void onMessage(BufferedSource source, WebSocket.PayloadType type)
+      throws IOException {
+    if (delegate != null) {
+      delegate.onMessage(source, type);
+      delegate = null;
+    } else {
+      Message message = new Message(type);
+      source.readAll(message.buffer);
+      source.close();
+      events.add(message);
+    }
+  }
+
+  @Override public void onPing(Buffer buffer) {
+    events.add(new Ping(buffer));
+  }
+
+  @Override public void onPong(Buffer buffer) {
+    events.add(new Pong(buffer));
+  }
+
+  @Override public void onClose(int code, String reason) {
+    events.add(new Close(code, reason));
+  }
+
+  @Override public void onFailure(IOException e) {
+    events.add(e);
+  }
+
+  public void assertTextMessage(String payload) {
+    Message message = new Message(TEXT);
+    message.buffer.writeUtf8(payload);
+    assertEquals(message, events.pollFirst());
+  }
+
+  public void assertBinaryMessage(byte[] payload) {
+    Message message = new Message(BINARY);
+    message.buffer.write(payload);
+    assertEquals(message, events.pollFirst());
+  }
+
+  public void assertPing(Buffer payload) {
+    assertEquals(new Ping(payload), events.pollFirst());
+  }
+
+  public void assertPong(Buffer payload) {
+    assertEquals(new Pong(payload), events.pollFirst());
+  }
+
+  public void assertClose(int code, String reason) {
+    assertEquals(new Close(code, reason), events.pollFirst());
+  }
+
+  public void assertFailure(Class<? extends IOException> cls, String message) {
+    Object event = events.pollFirst();
+    String errorMessage =
+        "Expected [" + cls.getName() + ": " + message + "] but was [" + event + "].";
+    assertNotNull(errorMessage, event);
+    assertEquals(errorMessage, cls, event.getClass());
+    assertEquals(errorMessage, cls.cast(event).getMessage(), message);
+  }
+
+  public void assertExhausted() {
+    assertTrue("Remaining events: " + events, events.isEmpty());
+  }
+
+  private static class Message {
+    public final WebSocket.PayloadType type;
+    public final Buffer buffer = new Buffer();
+
+    private Message(WebSocket.PayloadType type) {
+      this.type = type;
+    }
+
+    @Override public String toString() {
+      return "Message[" + type + " " + buffer + "]";
+    }
+
+    @Override public int hashCode() {
+      return type.hashCode() * 37 + buffer.hashCode();
+    }
+
+    @Override public boolean equals(Object obj) {
+      if (obj instanceof Message) {
+        Message other = (Message) obj;
+        return type == other.type && buffer.equals(other.buffer);
+      }
+      return false;
+    }
+  }
+
+  private static class Ping {
+    public final Buffer buffer;
+
+    private Ping(Buffer buffer) {
+      this.buffer = buffer;
+    }
+
+    @Override public String toString() {
+      return "Ping[" + buffer + "]";
+    }
+
+    @Override public int hashCode() {
+      return buffer.hashCode();
+    }
+
+    @Override public boolean equals(Object obj) {
+      if (obj instanceof Ping) {
+        Ping other = (Ping) obj;
+        return buffer == null ? other.buffer == null : buffer.equals(other.buffer);
+      }
+      return false;
+    }
+  }
+
+  private static class Pong {
+    public final Buffer buffer;
+
+    private Pong(Buffer buffer) {
+      this.buffer = buffer;
+    }
+
+    @Override public String toString() {
+      return "Pong[" + buffer + "]";
+    }
+
+    @Override public int hashCode() {
+      return buffer.hashCode();
+    }
+
+    @Override public boolean equals(Object obj) {
+      if (obj instanceof Pong) {
+        Pong other = (Pong) obj;
+        return buffer == null ? other.buffer == null : buffer.equals(other.buffer);
+      }
+      return false;
+    }
+  }
+
+  private static class Close {
+    public final int code;
+    public final String reason;
+
+    private Close(int code, String reason) {
+      this.code = code;
+      this.reason = reason;
+    }
+
+    @Override public String toString() {
+      return "Close[" + code + " " + reason + "]";
+    }
+
+    @Override public int hashCode() {
+      return code * 37 + reason.hashCode();
+    }
+
+    @Override public boolean equals(Object obj) {
+      if (obj instanceof Close) {
+        Close other = (Close) obj;
+        return code == other.code && reason.equals(other.reason);
+      }
+      return false;
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
new file mode 100644
index 0000000000..1134e45151
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/ws/WebSocketWriterTest.java
@@ -0,0 +1,335 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.ws;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+import org.junit.After;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.ws.Protocol.toggleMask;
+import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.BINARY;
+import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.TEXT;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class WebSocketWriterTest {
+  private final Buffer data = new Buffer();
+  private final Random random = new Random(0);
+
+  // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
+  private final WebSocketWriter serverWriter = new WebSocketWriter(false, data, random);
+  private final WebSocketWriter clientWriter = new WebSocketWriter(true, data, random);
+
+  @After public void tearDown() throws IOException {
+    assertEquals("Data not empty", "", data.readByteString().hex());
+  }
+
+  @Test public void serverSendSimpleHello() throws IOException {
+    Buffer payload = new Buffer().writeUtf8("Hello");
+    serverWriter.sendMessage(TEXT, payload);
+    assertData("810548656c6c6f");
+  }
+
+  @Test public void clientSendSimpleHello() throws IOException {
+    Buffer payload = new Buffer().writeUtf8("Hello");
+    clientWriter.sendMessage(TEXT, payload);
+    assertData("818560b420bb28d14cd70f");
+  }
+
+  @Test public void serverStreamSimpleHello() throws IOException {
+    BufferedSink sink = serverWriter.newMessageSink(TEXT);
+
+    sink.writeUtf8("Hel").flush();
+    assertData("010348656c");
+
+    sink.writeUtf8("lo").flush();
+    assertData("00026c6f");
+
+    sink.close();
+    assertData("8000");
+  }
+
+  @Test public void serverStreamCloseFlushes() throws IOException {
+    BufferedSink sink = serverWriter.newMessageSink(TEXT);
+
+    sink.writeUtf8("Hel").flush();
+    assertData("010348656c");
+
+    sink.writeUtf8("lo").close();
+    assertData("00026c6f");
+    assertData("8000");
+  }
+
+  @Test public void clientStreamSimpleHello() throws IOException {
+    BufferedSink sink = clientWriter.newMessageSink(TEXT);
+
+    sink.writeUtf8("Hel").flush();
+    assertData("018360b420bb28d14c");
+
+    sink.writeUtf8("lo").flush();
+    assertData("00823851d9d4543e");
+
+    sink.close();
+    assertData("80807acb933d");
+  }
+
+  @Test public void serverSendBinary() throws IOException {
+    byte[] payload = binaryData(100);
+    serverWriter.sendMessage(BINARY, new Buffer().write(payload));
+    assertData("8264");
+    assertData(payload);
+  }
+
+  @Test public void serverSendBinaryShort() throws IOException {
+    byte[] payload = binaryData(1000);
+    serverWriter.sendMessage(BINARY, new Buffer().write(payload));
+    assertData("827e03e8");
+    assertData(payload);
+  }
+
+  @Test public void serverSendBinaryLong() throws IOException {
+    byte[] payload = binaryData(65537);
+    serverWriter.sendMessage(BINARY, new Buffer().write(payload));
+    assertData("827f0000000000010001");
+    assertData(payload);
+  }
+
+  @Test public void clientSendBinary() throws IOException {
+    byte[] payload = binaryData(100);
+    clientWriter.sendMessage(BINARY, new Buffer().write(payload));
+    assertData("82e4");
+
+    byte[] maskKey = new byte[4];
+    random.setSeed(0); // Reset the seed so we can mask the payload.
+    random.nextBytes(maskKey);
+    toggleMask(payload, payload.length, maskKey, 0);
+
+    assertData(maskKey);
+    assertData(payload);
+  }
+
+  @Test public void serverStreamBinary() throws IOException {
+    byte[] payload = binaryData(100);
+    BufferedSink sink = serverWriter.newMessageSink(BINARY);
+
+    sink.write(payload, 0, 50).flush();
+    assertData("0232");
+    assertData(Arrays.copyOfRange(payload, 0, 50));
+
+    sink.write(payload, 50, 50).flush();
+    assertData("0032");
+    assertData(Arrays.copyOfRange(payload, 50, 100));
+
+    sink.close();
+    assertData("8000");
+  }
+
+  @Test public void clientStreamBinary() throws IOException {
+    byte[] maskKey1 = new byte[4];
+    random.nextBytes(maskKey1);
+    byte[] maskKey2 = new byte[4];
+    random.nextBytes(maskKey2);
+    byte[] maskKey3 = new byte[4];
+    random.nextBytes(maskKey3);
+
+    random.setSeed(0); // Reset the seed so real data matches.
+
+    byte[] payload = binaryData(100);
+    BufferedSink sink = clientWriter.newMessageSink(BINARY);
+
+    sink.write(payload, 0, 50).flush();
+    byte[] part1 = Arrays.copyOfRange(payload, 0, 50);
+    toggleMask(part1, 50, maskKey1, 0);
+    assertData("02b2");
+    assertData(maskKey1);
+    assertData(part1);
+
+    sink.write(payload, 50, 50).flush();
+    byte[] part2 = Arrays.copyOfRange(payload, 50, 100);
+    toggleMask(part2, 50, maskKey2, 0);
+    assertData("00b2");
+    assertData(maskKey2);
+    assertData(part2);
+
+    sink.close();
+    assertData("8080");
+    assertData(maskKey3);
+  }
+
+  @Test public void serverEmptyClose() throws IOException {
+    serverWriter.writeClose(0, null);
+    assertData("8800");
+  }
+
+  @Test public void serverCloseWithCode() throws IOException {
+    serverWriter.writeClose(1005, null);
+    assertData("880203ed");
+  }
+
+  @Test public void serverCloseWithCodeAndReason() throws IOException {
+    serverWriter.writeClose(1005, "Hello");
+    assertData("880703ed48656c6c6f");
+  }
+
+  @Test public void clientEmptyClose() throws IOException {
+    clientWriter.writeClose(0, null);
+    assertData("888060b420bb");
+  }
+
+  @Test public void clientCloseWithCode() throws IOException {
+    clientWriter.writeClose(1005, null);
+    assertData("888260b420bb6359");
+  }
+
+  @Test public void clientCloseWithCodeAndReason() throws IOException {
+    clientWriter.writeClose(1005, "Hello");
+    assertData("888760b420bb635968de0cd84f");
+  }
+
+  @Test public void closeWithOnlyReasonThrows() throws IOException {
+    try {
+      clientWriter.writeClose(0, "Hello");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Code required to include reason.", e.getMessage());
+    }
+  }
+
+  @Test public void closeCodeOutOfRangeThrows() throws IOException {
+    try {
+      clientWriter.writeClose(98724976, "Hello");
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Code must be in range [1000,5000).", e.getMessage());
+    }
+  }
+
+  @Test public void serverEmptyPing() throws IOException {
+    serverWriter.writePing(null);
+    assertData("8900");
+  }
+
+  @Test public void clientEmptyPing() throws IOException {
+    clientWriter.writePing(null);
+    assertData("898060b420bb");
+  }
+
+  @Test public void serverPingWithPayload() throws IOException {
+    serverWriter.writePing(new Buffer().writeUtf8("Hello"));
+    assertData("890548656c6c6f");
+  }
+
+  @Test public void clientPingWithPayload() throws IOException {
+    clientWriter.writePing(new Buffer().writeUtf8("Hello"));
+    assertData("898560b420bb28d14cd70f");
+  }
+
+  @Test public void serverEmptyPong() throws IOException {
+    serverWriter.writePong(null);
+    assertData("8a00");
+  }
+
+  @Test public void clientEmptyPong() throws IOException {
+    clientWriter.writePong(null);
+    assertData("8a8060b420bb");
+  }
+
+  @Test public void serverPongWithPayload() throws IOException {
+    serverWriter.writePong(new Buffer().writeUtf8("Hello"));
+    assertData("8a0548656c6c6f");
+  }
+
+  @Test public void clientPongWithPayload() throws IOException {
+    clientWriter.writePong(new Buffer().writeUtf8("Hello"));
+    assertData("8a8560b420bb28d14cd70f");
+  }
+
+  @Test public void pingTooLongThrows() throws IOException {
+    try {
+      serverWriter.writePing(new Buffer().write(binaryData(1000)));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+    }
+  }
+
+  @Test public void pongTooLongThrows() throws IOException {
+    try {
+      serverWriter.writePong(new Buffer().write(binaryData(1000)));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+    }
+  }
+
+  @Test public void closeTooLongThrows() throws IOException {
+    try {
+      String longString = ByteString.of(binaryData(75)).hex();
+      serverWriter.writeClose(1000, longString);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+    }
+  }
+
+  @Test public void twoWritersThrows() {
+    clientWriter.newMessageSink(TEXT);
+    try {
+      clientWriter.newMessageSink(TEXT);
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("Another message writer is active. Did you call close()?", e.getMessage());
+    }
+  }
+
+  @Test public void writeWhileWriterThrows() throws IOException {
+    clientWriter.newMessageSink(TEXT);
+    try {
+      clientWriter.sendMessage(TEXT, new Buffer());
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals("A message writer is active. Did you call close()?", e.getMessage());
+    }
+  }
+
+  private void assertData(String hex) throws EOFException {
+    ByteString expected = ByteString.decodeHex(hex);
+    ByteString actual = data.readByteString(expected.size());
+    assertEquals(expected, actual);
+  }
+
+  private void assertData(byte[] data) throws IOException {
+    int byteCount = 16;
+    for (int i = 0; i < data.length; i += byteCount) {
+      int count = Math.min(byteCount, data.length - i);
+      Buffer expectedChunk = new Buffer();
+      expectedChunk.write(data, i, count);
+      assertEquals("At " + i, expectedChunk.readByteString(), this.data.readByteString(count));
+    }
+  }
+
+  private static byte[] binaryData(int length) {
+    byte[] junk = new byte[length];
+    new Random(0).nextBytes(junk);
+    return junk;
+  }
+}
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
new file mode 100644
index 0000000000..790f596bb7
--- /dev/null
+++ b/okhttp-urlconnection/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.3.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-urlconnection</artifactId>
+  <name>OkHttp URLConnection</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <excludePackageNames>com.squareup.okhttp.internal.*</excludePackageNames>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+          </links>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java
new file mode 100644
index 0000000000..2c5f95ff79
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.InternalCache;
+import com.squareup.okhttp.internal.huc.CacheAdapter;
+import com.squareup.okhttp.internal.huc.HttpURLConnectionImpl;
+import com.squareup.okhttp.internal.huc.HttpsURLConnectionImpl;
+import java.net.HttpURLConnection;
+import java.net.Proxy;
+import java.net.ResponseCache;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.URLStreamHandler;
+import java.net.URLStreamHandlerFactory;
+
+public final class OkUrlFactory implements URLStreamHandlerFactory, Cloneable {
+  private final OkHttpClient client;
+
+  public OkUrlFactory(OkHttpClient client) {
+    this.client = client;
+  }
+
+  public OkHttpClient client() {
+    return client;
+  }
+
+  /** Sets the response cache to be used to read and write cached responses. */
+  OkUrlFactory setResponseCache(ResponseCache responseCache) {
+    client.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
+    return this;
+  }
+
+  ResponseCache getResponseCache() {
+    InternalCache cache = client.internalCache();
+    return cache instanceof CacheAdapter ? ((CacheAdapter) cache).getDelegate() : null;
+  }
+
+  /**
+   * Returns a copy of this stream handler factory that includes a shallow copy
+   * of the internal {@linkplain OkHttpClient HTTP client}.
+   */
+  @Override public OkUrlFactory clone() {
+    return new OkUrlFactory(client.clone());
+  }
+
+  public HttpURLConnection open(URL url) {
+    return open(url, client.getProxy());
+  }
+
+  HttpURLConnection open(URL url, Proxy proxy) {
+    String protocol = url.getProtocol();
+    OkHttpClient copy = client.copyWithDefaults();
+    copy.setProxy(proxy);
+
+    if (protocol.equals("http")) return new HttpURLConnectionImpl(url, copy);
+    if (protocol.equals("https")) return new HttpsURLConnectionImpl(url, copy);
+    throw new IllegalArgumentException("Unexpected protocol: " + protocol);
+  }
+
+  /**
+   * Creates a URLStreamHandler as a {@link java.net.URL#setURLStreamHandlerFactory}.
+   *
+   * <p>This code configures OkHttp to handle all HTTP and HTTPS connections
+   * created with {@link java.net.URL#openConnection()}: <pre>   {@code
+   *
+   *   OkHttpClient okHttpClient = new OkHttpClient();
+   *   URL.setURLStreamHandlerFactory(new OkUrlFactory(okHttpClient));
+   * }</pre>
+   */
+  @Override public URLStreamHandler createURLStreamHandler(final String protocol) {
+    if (!protocol.equals("http") && !protocol.equals("https")) return null;
+
+    return new URLStreamHandler() {
+      @Override protected URLConnection openConnection(URL url) {
+        return open(url);
+      }
+
+      @Override protected URLConnection openConnection(URL url, Proxy proxy) {
+        return open(url, proxy);
+      }
+
+      @Override protected int getDefaultPort() {
+        if (protocol.equals("http")) return 80;
+        if (protocol.equals("https")) return 443;
+        throw new AssertionError();
+      }
+    };
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
new file mode 100644
index 0000000000..13a34c032b
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.huc;
+
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.InternalCache;
+import com.squareup.okhttp.internal.http.CacheRequest;
+import com.squareup.okhttp.internal.http.CacheStrategy;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.CacheResponse;
+import java.net.HttpURLConnection;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.util.List;
+import java.util.Map;
+import okio.Okio;
+import okio.Sink;
+
+/** Adapts {@link ResponseCache} to {@link InternalCache}. */
+public final class CacheAdapter implements InternalCache {
+  private final ResponseCache delegate;
+
+  public CacheAdapter(ResponseCache delegate) {
+    this.delegate = delegate;
+  }
+
+  public ResponseCache getDelegate() {
+    return delegate;
+  }
+
+  @Override public Response get(Request request) throws IOException {
+    CacheResponse javaResponse = getJavaCachedResponse(request);
+    if (javaResponse == null) {
+      return null;
+    }
+    return JavaApiConverter.createOkResponse(request, javaResponse);
+  }
+
+  @Override public CacheRequest put(Response response) throws IOException {
+    URI uri = response.request().uri();
+    HttpURLConnection connection = JavaApiConverter.createJavaUrlConnection(response);
+    final java.net.CacheRequest request = delegate.put(uri, connection);
+    if (request == null) {
+      return null;
+    }
+    return new CacheRequest() {
+      @Override public Sink body() throws IOException {
+        OutputStream body = request.getBody();
+        return body != null ? Okio.sink(body) : null;
+      }
+
+      @Override public void abort() {
+        request.abort();
+      }
+    };
+  }
+
+  @Override public void remove(Request request) throws IOException {
+    // This method is treated as optional and there is no obvious way of implementing it with
+    // ResponseCache. Removing items from the cache due to modifications made from this client is
+    // not essential given that modifications could be made from any other client. We have to assume
+    // that it's ok to keep using the cached data. Otherwise the server shouldn't declare it as
+    // cacheable or the client should be careful about caching it.
+  }
+
+  @Override public void update(Response cached, Response network) throws IOException {
+    // This method is treated as optional and there is no obvious way of implementing it with
+    // ResponseCache. Updating headers is useful if the server changes the metadata for a resource
+    // (e.g. max age) to extend or truncate the life of that resource in the cache. If the metadata
+    // is not updated the caching behavior may not be optimal, but will obey the metadata sent
+    // with the original cached response.
+  }
+
+  @Override public void trackConditionalCacheHit() {
+    // This method is optional.
+  }
+
+  @Override public void trackResponse(CacheStrategy cacheStrategy) {
+    // This method is optional.
+  }
+
+  /**
+   * Returns the {@link CacheResponse} from the delegate by converting the
+   * OkHttp {@link Request} into the arguments required by the {@link ResponseCache}.
+   */
+  private CacheResponse getJavaCachedResponse(Request request) throws IOException {
+    Map<String, List<String>> headers = JavaApiConverter.extractJavaHeaders(request);
+    return delegate.get(request.uri(), request.method(), headers);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java
similarity index 65%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
rename to okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java
index e8c656a2a3..631a2ae03d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java
@@ -14,15 +14,14 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package com.squareup.okhttp.internal.huc;
 
-import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Handshake;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.HttpURLConnection;
 import java.net.ProtocolException;
-import java.net.SecureCacheResponse;
 import java.net.URL;
 import java.security.Permission;
 import java.security.Principal;
@@ -32,92 +31,62 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 
-public final class HttpsURLConnectionImpl extends HttpsURLConnection {
-
-  /** HttpUrlConnectionDelegate allows reuse of HttpURLConnectionImpl. */
-  private final HttpUrlConnectionDelegate delegate;
+/**
+ * Implement an HTTPS connection by delegating to an HTTP connection for
+ * everything but the HTTPS-specific stuff.
+ */
+abstract class DelegatingHttpsURLConnection extends HttpsURLConnection {
+  private final HttpURLConnection delegate;
 
-  public HttpsURLConnectionImpl(URL url, OkHttpClient client) {
-    super(url);
-    delegate = new HttpUrlConnectionDelegate(url, client);
+  public DelegatingHttpsURLConnection(HttpURLConnection delegate) {
+    super(delegate.getURL());
+    this.delegate = delegate;
   }
 
+  protected abstract Handshake handshake();
+
+  @Override public abstract void setHostnameVerifier(HostnameVerifier hostnameVerifier);
+
+  @Override public abstract HostnameVerifier getHostnameVerifier();
+
+  @Override public abstract void setSSLSocketFactory(SSLSocketFactory sslSocketFactory);
+
+  @Override public abstract SSLSocketFactory getSSLSocketFactory();
+
   @Override public String getCipherSuite() {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      return cacheResponse.getCipherSuite();
-    }
-    SSLSocket sslSocket = getSslSocket();
-    if (sslSocket != null) {
-      return sslSocket.getSession().getCipherSuite();
-    }
-    return null;
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.cipherSuite() : null;
   }
 
   @Override public Certificate[] getLocalCertificates() {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      List<Certificate> result = cacheResponse.getLocalCertificateChain();
-      return result != null ? result.toArray(new Certificate[result.size()]) : null;
-    }
-    SSLSocket sslSocket = getSslSocket();
-    if (sslSocket != null) {
-      return sslSocket.getSession().getLocalCertificates();
-    }
-    return null;
+    Handshake handshake = handshake();
+    if (handshake == null) return null;
+    List<Certificate> result = handshake.localCertificates();
+    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
   }
 
   @Override public Certificate[] getServerCertificates() throws SSLPeerUnverifiedException {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      List<Certificate> result = cacheResponse.getServerCertificateChain();
-      return result != null ? result.toArray(new Certificate[result.size()]) : null;
-    }
-    SSLSocket sslSocket = getSslSocket();
-    if (sslSocket != null) {
-      return sslSocket.getSession().getPeerCertificates();
-    }
-    return null;
+    Handshake handshake = handshake();
+    if (handshake == null) return null;
+    List<Certificate> result = handshake.peerCertificates();
+    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
   }
 
   @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      return cacheResponse.getPeerPrincipal();
-    }
-    SSLSocket sslSocket = getSslSocket();
-    if (sslSocket != null) {
-      return sslSocket.getSession().getPeerPrincipal();
-    }
-    return null;
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.peerPrincipal() : null;
   }
 
   @Override public Principal getLocalPrincipal() {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      return cacheResponse.getLocalPrincipal();
-    }
-    SSLSocket sslSocket = getSslSocket();
-    if (sslSocket != null) {
-      return sslSocket.getSession().getLocalPrincipal();
-    }
-    return null;
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.localPrincipal() : null;
   }
 
-  public HttpEngine getHttpEngine() {
-    return delegate.getHttpEngine();
-  }
-
-  private SSLSocket getSslSocket() {
-    if (delegate.httpEngine == null || !delegate.httpEngine.connected) {
-      throw new IllegalStateException("Connection has not yet been established");
-    }
-    return delegate.httpEngine instanceof HttpsEngine
-        ? ((HttpsEngine) delegate.httpEngine).getSslSocket()
-        : null; // Not HTTPS! Probably an https:// to http:// redirect.
+  @Override public void connect() throws IOException {
+    connected = true;
+    delegate.connect();
   }
 
   @Override public void disconnect() {
@@ -156,11 +125,6 @@ private SSLSocket getSslSocket() {
     delegate.setInstanceFollowRedirects(followRedirects);
   }
 
-  @Override public void connect() throws IOException {
-    connected = true;
-    delegate.connect();
-  }
-
   @Override public boolean getAllowUserInteraction() {
     return delegate.getAllowUserInteraction();
   }
@@ -325,36 +289,4 @@ private SSLSocket getSslSocket() {
   @Override public void setChunkedStreamingMode(int chunkLength) {
     delegate.setChunkedStreamingMode(chunkLength);
   }
-
-  @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
-    delegate.client.setHostnameVerifier(hostnameVerifier);
-  }
-
-  @Override public HostnameVerifier getHostnameVerifier() {
-    return delegate.client.getHostnameVerifier();
-  }
-
-  @Override public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
-    delegate.client.setSslSocketFactory(sslSocketFactory);
-  }
-
-  @Override public SSLSocketFactory getSSLSocketFactory() {
-    return delegate.client.getSslSocketFactory();
-  }
-
-  private final class HttpUrlConnectionDelegate extends HttpURLConnectionImpl {
-    private HttpUrlConnectionDelegate(URL url, OkHttpClient client) {
-      super(url, client);
-    }
-
-    @Override public HttpURLConnection getHttpConnectionToCache() {
-      return HttpsURLConnectionImpl.this;
-    }
-
-    public SecureCacheResponse getSecureCacheResponse() {
-      return httpEngine instanceof HttpsEngine
-          ? (SecureCacheResponse) httpEngine.getCacheResponse()
-          : null;
-    }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
similarity index 50%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
rename to okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
index f273039b15..04ac55206c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
@@ -15,12 +15,25 @@
  *  limitations under the License.
  */
 
-package com.squareup.okhttp.internal.http;
+package com.squareup.okhttp.internal.huc;
 
 import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.Handshake;
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.Route;
+import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.HttpDate;
+import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.HttpMethod;
+import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.RetryableSink;
+import com.squareup.okhttp.internal.http.StatusLine;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -33,14 +46,17 @@
 import java.net.SocketPermission;
 import java.net.URL;
 import java.security.Permission;
-import java.security.cert.CertificateException;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Date;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLHandshakeException;
-
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
+import okio.BufferedSink;
+import okio.Sink;
 
 /**
  * This implementation uses HttpEngine to send requests and receive responses.
@@ -52,30 +68,35 @@
  * is <strong>not</strong> used to indicate not whether this URLConnection is
  * currently connected. Instead, it indicates whether a connection has ever been
  * attempted. Once a connection has been attempted, certain properties (request
- * header fields, request method, etc.) are immutable. Test the {@code
- * connection} field on this class for null/non-null to determine of an instance
- * is currently connected to a server.
+ * header fields, request method, etc.) are immutable.
  */
-public class HttpURLConnectionImpl extends HttpURLConnection implements Policy {
-
-  /** Numeric status code, 307: Temporary Redirect. */
-  static final int HTTP_TEMP_REDIRECT = 307;
-
-  /**
-   * How many redirects should we follow? Chrome follows 21; Firefox, curl,
-   * and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
-   */
-  private static final int MAX_REDIRECTS = 20;
+public class HttpURLConnectionImpl extends HttpURLConnection {
+  private static final Set<String> METHODS = new LinkedHashSet<>(
+      Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
 
   final OkHttpClient client;
 
-  private final RawHeaders rawRequestHeaders = new RawHeaders();
+  private Headers.Builder requestHeaders = new Headers.Builder();
+
   /** Like the superclass field of the same name, but a long and available on all platforms. */
   private long fixedContentLength = -1;
-  private int redirectionCount;
+  private int followUpCount;
   protected IOException httpEngineFailure;
   protected HttpEngine httpEngine;
-  private Proxy selectedProxy;
+  /** Lazily created (with synthetic headers) on first call to getHeaders(). */
+  private Headers responseHeaders;
+
+  /**
+   * The most recently attempted route. This will be null if we haven't sent a
+   * request yet, or if the response comes from a cache.
+   */
+  private Route route;
+
+  /**
+   * The most recently received TLS handshake. This will be null if we haven't
+   * connected yet, or if the most recent connection was HTTP (and not HTTPS).
+   */
+  Handshake handshake;
 
   public HttpURLConnectionImpl(URL url, OkHttpClient client) {
     super(url);
@@ -92,17 +113,15 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
 
   @Override public final void disconnect() {
     // Calling disconnect() before a connection exists should have no effect.
-    if (httpEngine != null) {
-      // We close the response body here instead of in
-      // HttpEngine.release because that is called when input
-      // has been completely read from the underlying socket.
-      // However the response body can be a GZIPInputStream that
-      // still has unread data.
-      if (httpEngine.hasResponse()) {
-        Util.closeQuietly(httpEngine.getResponseBody());
-      }
-      httpEngine.release(true);
-    }
+    if (httpEngine == null) return;
+
+    httpEngine.disconnect();
+
+    // This doesn't close the stream because doing so would require all stream
+    // access to be synchronized. It's expected that the thread using the
+    // connection will close its streams directly. If it doesn't, the worst
+    // case is that the GzipSource's Inflater won't be released until it's
+    // finalized. (This logs a warning on Android.)
   }
 
   /**
@@ -112,8 +131,9 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
   @Override public final InputStream getErrorStream() {
     try {
       HttpEngine response = getResponse();
-      if (response.hasResponseBody() && response.getResponseCode() >= HTTP_BAD_REQUEST) {
-        return response.getResponseBody();
+      if (HttpEngine.hasBody(response.getResponse())
+          && response.getResponse().code() >= HTTP_BAD_REQUEST) {
+        return response.getResponse().body().byteStream();
       }
       return null;
     } catch (IOException e) {
@@ -121,13 +141,38 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
     }
   }
 
+  private Headers getHeaders() throws IOException {
+    if (responseHeaders == null) {
+      Response response = getResponse().getResponse();
+      Headers headers = response.headers();
+
+      responseHeaders = headers.newBuilder()
+          .add(Platform.get().getPrefix() + "-Response-Source", responseSourceHeader(response))
+          .build();
+    }
+    return responseHeaders;
+  }
+
+  private static String responseSourceHeader(Response response) {
+    if (response.networkResponse() == null) {
+      if (response.cacheResponse() == null) {
+        return "NONE";
+      }
+      return "CACHE " + response.code();
+    }
+    if (response.cacheResponse() == null) {
+      return "NETWORK " + response.code();
+    }
+    return "CONDITIONAL_CACHE " + response.networkResponse().code();
+  }
+
   /**
    * Returns the value of the field at {@code position}. Returns null if there
    * are fewer than {@code position} headers.
    */
   @Override public final String getHeaderField(int position) {
     try {
-      return getResponse().getResponseHeaders().getHeaders().getValue(position);
+      return getHeaders().value(position);
     } catch (IOException e) {
       return null;
     }
@@ -140,8 +185,9 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
    */
   @Override public final String getHeaderField(String fieldName) {
     try {
-      RawHeaders rawHeaders = getResponse().getResponseHeaders().getHeaders();
-      return fieldName == null ? rawHeaders.getStatusLine() : rawHeaders.get(fieldName);
+      return fieldName == null
+          ? StatusLine.get(getResponse().getResponse()).toString()
+          : getHeaders().get(fieldName);
     } catch (IOException e) {
       return null;
     }
@@ -149,7 +195,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
 
   @Override public final String getHeaderFieldKey(int position) {
     try {
-      return getResponse().getResponseHeaders().getHeaders().getFieldName(position);
+      return getHeaders().name(position);
     } catch (IOException e) {
       return null;
     }
@@ -157,9 +203,10 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
 
   @Override public final Map<String, List<String>> getHeaderFields() {
     try {
-      return getResponse().getResponseHeaders().getHeaders().toMultimap(true);
+      return OkHeaders.toMultimap(getHeaders(),
+          StatusLine.get(getResponse().getResponse()).toString());
     } catch (IOException e) {
-      return null;
+      return Collections.emptyMap();
     }
   }
 
@@ -168,7 +215,8 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
       throw new IllegalStateException(
           "Cannot access request header fields after connection is set");
     }
-    return rawRequestHeaders.toMultimap(false);
+
+    return OkHeaders.toMultimap(requestHeaders.build(), null);
   }
 
   @Override public final InputStream getInputStream() throws IOException {
@@ -186,24 +234,20 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
       throw new FileNotFoundException(url.toString());
     }
 
-    InputStream result = response.getResponseBody();
-    if (result == null) {
-      throw new ProtocolException("No response body exists; responseCode=" + getResponseCode());
-    }
-    return result;
+    return response.getResponse().body().byteStream();
   }
 
   @Override public final OutputStream getOutputStream() throws IOException {
     connect();
 
-    OutputStream out = httpEngine.getRequestBody();
-    if (out == null) {
+    BufferedSink sink = httpEngine.getBufferedRequestBody();
+    if (sink == null) {
       throw new ProtocolException("method does not support a request body: " + method);
     } else if (httpEngine.hasResponse()) {
       throw new ProtocolException("cannot write request body after response has been read");
     }
 
-    return out;
+    return sink.outputStream();
   }
 
   @Override public final Permission getPermission() throws IOException {
@@ -218,16 +262,19 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
   }
 
   @Override public final String getRequestProperty(String field) {
-    if (field == null) {
-      return null;
-    }
-    return rawRequestHeaders.get(field);
+    if (field == null) return null;
+    return requestHeaders.get(field);
   }
 
   @Override public void setConnectTimeout(int timeoutMillis) {
     client.setConnectTimeout(timeoutMillis, TimeUnit.MILLISECONDS);
   }
 
+  @Override
+  public void setInstanceFollowRedirects(boolean followRedirects) {
+    client.setFollowRedirects(followRedirects);
+  }
+
   @Override public int getConnectTimeout() {
     return client.getConnectTimeout();
   }
@@ -253,31 +300,64 @@ private void initHttpEngine() throws IOException {
         if (method.equals("GET")) {
           // they are requesting a stream to write to. This implies a POST method
           method = "POST";
-        } else if (!method.equals("POST") && !method.equals("PUT")) {
-          // If the request method is neither POST nor PUT, then you're not writing
+        } else if (!HttpMethod.permitsRequestBody(method)) {
           throw new ProtocolException(method + " does not support writing");
         }
       }
-      httpEngine = newHttpEngine(method, rawRequestHeaders, null, null);
+      // If the user set content length to zero, we know there will not be a request body.
+      httpEngine = newHttpEngine(method, null, null, null);
     } catch (IOException e) {
       httpEngineFailure = e;
       throw e;
     }
   }
 
-  @Override public HttpURLConnection getHttpConnectionToCache() {
-    return this;
-  }
+  private HttpEngine newHttpEngine(String method, Connection connection,
+      RetryableSink requestBody, Response priorResponse) {
+    Request.Builder builder = new Request.Builder()
+        .url(getURL())
+        .method(method, null /* No body; that's passed separately. */);
+    Headers headers = requestHeaders.build();
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      builder.addHeader(headers.name(i), headers.value(i));
+    }
 
-  private HttpEngine newHttpEngine(String method, RawHeaders requestHeaders,
-      Connection connection, RetryableOutputStream requestBody) throws IOException {
-    if (url.getProtocol().equals("http")) {
-      return new HttpEngine(client, this, method, requestHeaders, connection, requestBody);
-    } else if (url.getProtocol().equals("https")) {
-      return new HttpsEngine(client, this, method, requestHeaders, connection, requestBody);
-    } else {
-      throw new AssertionError();
+    boolean bufferRequestBody = false;
+    if (HttpMethod.permitsRequestBody(method)) {
+      // Specify how the request body is terminated.
+      if (fixedContentLength != -1) {
+        builder.header("Content-Length", Long.toString(fixedContentLength));
+      } else if (chunkLength > 0) {
+        builder.header("Transfer-Encoding", "chunked");
+      } else {
+        bufferRequestBody = true;
+      }
+
+      // Add a content type for the request body, if one isn't already present.
+      if (headers.get("Content-Type") == null) {
+        builder.header("Content-Type", "application/x-www-form-urlencoded");
+      }
+    }
+
+    if (headers.get("User-Agent") == null) {
+      builder.header("User-Agent", defaultUserAgent());
+    }
+
+    Request request = builder.build();
+
+    // If we're currently not using caches, make sure the engine's client doesn't have one.
+    OkHttpClient engineClient = client;
+    if (Internal.instance.internalCache(engineClient) != null && !getUseCaches()) {
+      engineClient = client.clone().setCache(null);
     }
+
+    return new HttpEngine(engineClient, request, bufferRequestBody, true, false, connection, null,
+        requestBody, priorResponse);
+  }
+
+  private String defaultUserAgent() {
+    String agent = System.getProperty("http.agent");
+    return agent != null ? agent : ("Java" + System.getProperty("java.version"));
   }
 
   /**
@@ -297,46 +377,41 @@ private HttpEngine getResponse() throws IOException {
         continue;
       }
 
-      Retry retry = processResponseHeaders();
-      if (retry == Retry.NONE) {
-        httpEngine.automaticallyReleaseConnectionToPool();
+      Response response = httpEngine.getResponse();
+      Request followUp = httpEngine.followUpRequest();
+
+      if (followUp == null) {
+        httpEngine.releaseConnection();
         return httpEngine;
       }
 
+      if (++followUpCount > HttpEngine.MAX_FOLLOW_UPS) {
+        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
+      }
+
       // The first request was insufficient. Prepare for another...
-      String retryMethod = method;
-      OutputStream requestBody = httpEngine.getRequestBody();
-
-      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM
-      // redirect should keep the same method, Chrome, Firefox and the
-      // RI all issue GETs when following any redirect.
-      int responseCode = getResponseCode();
-      if (responseCode == HTTP_MULT_CHOICE
-          || responseCode == HTTP_MOVED_PERM
-          || responseCode == HTTP_MOVED_TEMP
-          || responseCode == HTTP_SEE_OTHER) {
-        retryMethod = "GET";
+      url = followUp.url();
+      requestHeaders = followUp.headers().newBuilder();
+
+      // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM redirect
+      // should keep the same method, Chrome, Firefox and the RI all issue GETs
+      // when following any redirect.
+      Sink requestBody = httpEngine.getRequestBody();
+      if (!followUp.method().equals(method)) {
         requestBody = null;
       }
 
-      if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {
-        throw new HttpRetryException("Cannot retry streamed HTTP body",
-            httpEngine.getResponseCode());
+      if (requestBody != null && !(requestBody instanceof RetryableSink)) {
+        throw new HttpRetryException("Cannot retry streamed HTTP body", responseCode);
       }
 
-      if (retry == Retry.DIFFERENT_CONNECTION) {
-        httpEngine.automaticallyReleaseConnectionToPool();
+      if (!httpEngine.sameConnection(followUp.url())) {
+        httpEngine.releaseConnection();
       }
 
-      httpEngine.release(false);
-
-      httpEngine = newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),
-          (RetryableOutputStream) requestBody);
-
-      if (requestBody == null) {
-        // Drop the Content-Length header when redirected from POST to GET.
-        httpEngine.getRequestHeaders().removeContentLength();
-      }
+      Connection connection = httpEngine.close();
+      httpEngine = newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,
+          response);
     }
   }
 
@@ -348,164 +423,52 @@ private HttpEngine getResponse() throws IOException {
   private boolean execute(boolean readResponse) throws IOException {
     try {
       httpEngine.sendRequest();
+      route = httpEngine.getRoute();
+      handshake = httpEngine.getConnection() != null
+          ? httpEngine.getConnection().getHandshake()
+          : null;
       if (readResponse) {
         httpEngine.readResponse();
       }
 
       return true;
     } catch (IOException e) {
-      if (handleFailure(e)) {
+      HttpEngine retryEngine = httpEngine.recover(e);
+      if (retryEngine != null) {
+        httpEngine = retryEngine;
         return false;
-      } else {
-        throw e;
       }
-    }
-  }
 
-  /**
-   * Report and attempt to recover from {@code e}. Returns true if the HTTP
-   * engine was replaced and the request should be retried. Otherwise the
-   * failure is permanent.
-   */
-  private boolean handleFailure(IOException e) throws IOException {
-    RouteSelector routeSelector = httpEngine.routeSelector;
-    if (routeSelector != null && httpEngine.connection != null) {
-      routeSelector.connectFailed(httpEngine.connection, e);
-    }
-
-    OutputStream requestBody = httpEngine.getRequestBody();
-    boolean canRetryRequestBody = requestBody == null
-        || requestBody instanceof RetryableOutputStream;
-    if (routeSelector == null && httpEngine.connection == null // No connection.
-        || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
-        || !isRecoverable(e)
-        || !canRetryRequestBody) {
+      // Give up; recovery is not possible.
       httpEngineFailure = e;
-      return false;
+      throw e;
     }
-
-    httpEngine.release(true);
-    RetryableOutputStream retryableOutputStream = (RetryableOutputStream) requestBody;
-    httpEngine = newHttpEngine(method, rawRequestHeaders, null, retryableOutputStream);
-    httpEngine.routeSelector = routeSelector; // Keep the same routeSelector.
-    return true;
-  }
-
-  private boolean isRecoverable(IOException e) {
-    // If the problem was a CertificateException from the X509TrustManager,
-    // do not retry, we didn't have an abrupt server initiated exception.
-    boolean sslFailure =
-        e instanceof SSLHandshakeException && e.getCause() instanceof CertificateException;
-    boolean protocolFailure = e instanceof ProtocolException;
-    return !sslFailure && !protocolFailure;
-  }
-
-  public HttpEngine getHttpEngine() {
-    return httpEngine;
-  }
-
-  enum Retry {
-    NONE,
-    SAME_CONNECTION,
-    DIFFERENT_CONNECTION
   }
 
   /**
-   * Returns the retry action to take for the current response headers. The
-   * headers, proxy and target URL or this connection may be adjusted to
-   * prepare for a follow up request.
+   * Returns true if either:
+   * <ul>
+   *   <li>A specific proxy was explicitly configured for this connection.
+   *   <li>The response has already been retrieved, and a proxy was {@link
+   *       java.net.ProxySelector selected} in order to get it.
+   * </ul>
+   *
+   * <p><strong>Warning:</strong> This method may return false before attempting
+   * to connect and true afterwards.
    */
-  private Retry processResponseHeaders() throws IOException {
-    Proxy selectedProxy = httpEngine.connection != null
-        ? httpEngine.connection.getRoute().getProxy()
-        : client.getProxy();
-    final int responseCode = getResponseCode();
-    switch (responseCode) {
-      case HTTP_PROXY_AUTH:
-        if (selectedProxy.type() != Proxy.Type.HTTP) {
-          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
-        }
-        // fall-through
-      case HTTP_UNAUTHORIZED:
-        boolean credentialsFound = HttpAuthenticator.processAuthHeader(client.getAuthenticator(),
-            getResponseCode(), httpEngine.getResponseHeaders().getHeaders(), rawRequestHeaders,
-            selectedProxy, url);
-        return credentialsFound ? Retry.SAME_CONNECTION : Retry.NONE;
-
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-      case HTTP_TEMP_REDIRECT:
-        if (!getInstanceFollowRedirects()) {
-          return Retry.NONE;
-        }
-        if (++redirectionCount > MAX_REDIRECTS) {
-          throw new ProtocolException("Too many redirects: " + redirectionCount);
-        }
-        if (responseCode == HTTP_TEMP_REDIRECT && !method.equals("GET") && !method.equals("HEAD")) {
-          // "If the 307 status code is received in response to a request other than GET or HEAD,
-          // the user agent MUST NOT automatically redirect the request"
-          return Retry.NONE;
-        }
-        String location = getHeaderField("Location");
-        if (location == null) {
-          return Retry.NONE;
-        }
-        URL previousUrl = url;
-        url = new URL(previousUrl, location);
-        if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) {
-          return Retry.NONE; // Don't follow redirects to unsupported protocols.
-        }
-        boolean sameProtocol = previousUrl.getProtocol().equals(url.getProtocol());
-        if (!sameProtocol && !client.getFollowProtocolRedirects()) {
-          return Retry.NONE; // This client doesn't follow redirects across protocols.
-        }
-        boolean sameHost = previousUrl.getHost().equals(url.getHost());
-        boolean samePort = getEffectivePort(previousUrl) == getEffectivePort(url);
-        if (sameHost && samePort && sameProtocol) {
-          return Retry.SAME_CONNECTION;
-        } else {
-          return Retry.DIFFERENT_CONNECTION;
-        }
-
-      default:
-        return Retry.NONE;
-    }
-  }
-
-  /** @see java.net.HttpURLConnection#setFixedLengthStreamingMode(int) */
-  @Override public final long getFixedContentLength() {
-    return fixedContentLength;
-  }
-
-  @Override public final int getChunkLength() {
-    return chunkLength;
-  }
-
   @Override public final boolean usingProxy() {
-    if (selectedProxy != null) {
-      return isValidNonDirectProxy(selectedProxy);
-    }
-
-    // This behavior is a bit odd (but is probably justified by the
-    // oddness of the APIs involved). Before a connection is established,
-    // this method will return true only if this connection was explicitly
-    // opened with a Proxy. We don't attempt to query the ProxySelector
-    // at all.
-    return isValidNonDirectProxy(client.getProxy());
-  }
-
-  private static boolean isValidNonDirectProxy(Proxy proxy) {
+    Proxy proxy = route != null
+        ? route.getProxy()
+        : client.getProxy();
     return proxy != null && proxy.type() != Proxy.Type.DIRECT;
   }
 
   @Override public String getResponseMessage() throws IOException {
-    return getResponse().getResponseHeaders().getHeaders().getResponseMessage();
+    return getResponse().getResponse().message();
   }
 
   @Override public final int getResponseCode() throws IOException {
-    return getResponse().getResponseCode();
+    return getResponse().getResponse().code();
   }
 
   @Override public final void setRequestProperty(String field, String newValue) {
@@ -525,10 +488,20 @@ private static boolean isValidNonDirectProxy(Proxy proxy) {
       return;
     }
 
-    if ("X-Android-Transports".equals(field)) {
-      setTransports(newValue, false /* append */);
+    // TODO: Deprecate use of X-Android-Transports header?
+    if ("X-Android-Transports".equals(field) || "X-Android-Protocols".equals(field)) {
+      setProtocols(newValue, false /* append */);
+    } else {
+      requestHeaders.set(field, newValue);
+    }
+  }
+
+  @Override public void setIfModifiedSince(long newValue) {
+    super.setIfModifiedSince(newValue);
+    if (ifModifiedSince != 0) {
+      requestHeaders.set("If-Modified-Since", HttpDate.format(new Date(ifModifiedSince)));
     } else {
-      rawRequestHeaders.set(field, newValue);
+      requestHeaders.removeAll("If-Modified-Since");
     }
   }
 
@@ -549,42 +522,51 @@ private static boolean isValidNonDirectProxy(Proxy proxy) {
       return;
     }
 
-    if ("X-Android-Transports".equals(field)) {
-      setTransports(value, true /* append */);
+    // TODO: Deprecate use of X-Android-Transports header?
+    if ("X-Android-Transports".equals(field) || "X-Android-Protocols".equals(field)) {
+      setProtocols(value, true /* append */);
     } else {
-      rawRequestHeaders.add(field, value);
+      requestHeaders.add(field, value);
     }
   }
 
   /*
-   * Splits and validates a comma-separated string of transports.
+   * Splits and validates a comma-separated string of protocols.
    * When append == false, we require that the transport list contains "http/1.1".
+   * Throws {@link IllegalStateException} when one of the protocols isn't
+   * defined in {@link Protocol OkHttp's protocol enumeration}.
    */
-  private void setTransports(String transportsString, boolean append) {
-    List<String> transportsList = new ArrayList<String>();
+  private void setProtocols(String protocolsString, boolean append) {
+    List<Protocol> protocolsList = new ArrayList<>();
     if (append) {
-      transportsList.addAll(client.getTransports());
+      protocolsList.addAll(client.getProtocols());
     }
-    for (String transport : transportsString.split(",", -1)) {
-      transportsList.add(transport);
+    for (String protocol : protocolsString.split(",", -1)) {
+      try {
+        protocolsList.add(Protocol.get(protocol));
+      } catch (IOException e) {
+        throw new IllegalStateException(e);
+      }
+    }
+    client.setProtocols(protocolsList);
+  }
+
+  @Override public void setRequestMethod(String method) throws ProtocolException {
+    if (!METHODS.contains(method)) {
+      throw new ProtocolException("Expected one of " + METHODS + " but was " + method);
     }
-    client.setTransports(transportsList);
+    this.method = method;
   }
 
   @Override public void setFixedLengthStreamingMode(int contentLength) {
     setFixedLengthStreamingMode((long) contentLength);
   }
 
-  // @Override Don't override: this overload method doesn't exist prior to Java 1.7.
-  public void setFixedLengthStreamingMode(long contentLength) {
+  @Override public void setFixedLengthStreamingMode(long contentLength) {
     if (super.connected) throw new IllegalStateException("Already connected");
     if (chunkLength > 0) throw new IllegalStateException("Already in chunked mode");
     if (contentLength < 0) throw new IllegalArgumentException("contentLength < 0");
     this.fixedContentLength = contentLength;
     super.fixedContentLength = (int) Math.min(contentLength, Integer.MAX_VALUE);
   }
-
-  @Override public final void setSelectedProxy(Proxy proxy) {
-    this.selectedProxy = proxy;
-  }
 }
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java
new file mode 100644
index 0000000000..2aba0872a8
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java
@@ -0,0 +1,77 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.squareup.okhttp.internal.huc;
+
+import com.squareup.okhttp.Handshake;
+import com.squareup.okhttp.OkHttpClient;
+import java.net.URL;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSocketFactory;
+
+public final class HttpsURLConnectionImpl extends DelegatingHttpsURLConnection {
+  private final HttpURLConnectionImpl delegate;
+
+  public HttpsURLConnectionImpl(URL url, OkHttpClient client) {
+    this(new HttpURLConnectionImpl(url, client));
+  }
+
+  public HttpsURLConnectionImpl(HttpURLConnectionImpl delegate) {
+    super(delegate);
+    this.delegate = delegate;
+  }
+
+  @Override protected Handshake handshake() {
+    if (delegate.httpEngine == null) {
+      throw new IllegalStateException("Connection has not yet been established");
+    }
+
+    // If there's a response, get the handshake from there so that caching
+    // works. Otherwise get the handshake from the connection because we might
+    // have not connected yet.
+    return delegate.httpEngine.hasResponse()
+        ? delegate.httpEngine.getResponse().handshake()
+        : delegate.handshake;
+  }
+
+  @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
+    delegate.client.setHostnameVerifier(hostnameVerifier);
+  }
+
+  @Override public HostnameVerifier getHostnameVerifier() {
+    return delegate.client.getHostnameVerifier();
+  }
+
+  @Override public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
+    delegate.client.setSslSocketFactory(sslSocketFactory);
+  }
+
+  @Override public SSLSocketFactory getSSLSocketFactory() {
+    return delegate.client.getSslSocketFactory();
+  }
+
+  @Override public long getContentLengthLong() {
+    return delegate.getContentLengthLong();
+  }
+
+  @Override public void setFixedLengthStreamingMode(long contentLength) {
+    delegate.setFixedLengthStreamingMode(contentLength);
+  }
+
+  @Override public long getHeaderFieldLong(String field, long defaultValue) {
+    return delegate.getHeaderFieldLong(field, defaultValue);
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
new file mode 100644
index 0000000000..1d2492246a
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
@@ -0,0 +1,686 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.huc;
+
+import com.squareup.okhttp.Handshake;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.StatusLine;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.CacheResponse;
+import java.net.HttpURLConnection;
+import java.net.ProtocolException;
+import java.net.SecureCacheResponse;
+import java.net.URI;
+import java.net.URLConnection;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocketFactory;
+import okio.BufferedSource;
+import okio.Okio;
+
+/**
+ * Helper methods that convert between Java and OkHttp representations.
+ */
+public final class JavaApiConverter {
+
+  private JavaApiConverter() {
+  }
+
+  /**
+   * Creates an OkHttp {@link Response} using the supplied {@link URI} and {@link URLConnection}
+   * to supply the data. The URLConnection is assumed to already be connected.
+   */
+  public static Response createOkResponse(URI uri, URLConnection urlConnection) throws IOException {
+    HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
+
+    Response.Builder okResponseBuilder = new Response.Builder();
+
+    // Request: Create one from the URL connection.
+    // A connected HttpURLConnection does not permit access to request headers.
+    Map<String, List<String>> requestHeaders = null;
+    Request okRequest = createOkRequest(uri, httpUrlConnection.getRequestMethod(), requestHeaders);
+    okResponseBuilder.request(okRequest);
+
+    // Status line
+    StatusLine statusLine = StatusLine.parse(extractStatusLine(httpUrlConnection));
+    okResponseBuilder.protocol(statusLine.protocol);
+    okResponseBuilder.code(statusLine.code);
+    okResponseBuilder.message(statusLine.message);
+
+    // Response headers
+    Headers okHeaders = extractOkResponseHeaders(httpUrlConnection);
+    okResponseBuilder.headers(okHeaders);
+
+    // Response body
+    ResponseBody okBody = createOkBody(okHeaders, urlConnection.getInputStream());
+    okResponseBuilder.body(okBody);
+
+    // Handle SSL handshake information as needed.
+    if (httpUrlConnection instanceof HttpsURLConnection) {
+      HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) httpUrlConnection;
+
+      Certificate[] peerCertificates;
+      try {
+        peerCertificates = httpsUrlConnection.getServerCertificates();
+      } catch (SSLPeerUnverifiedException e) {
+        peerCertificates = null;
+      }
+
+      Certificate[] localCertificates = httpsUrlConnection.getLocalCertificates();
+
+      Handshake handshake = Handshake.get(
+          httpsUrlConnection.getCipherSuite(), nullSafeImmutableList(peerCertificates),
+          nullSafeImmutableList(localCertificates));
+      okResponseBuilder.handshake(handshake);
+    }
+
+    return okResponseBuilder.build();
+  }
+
+  /**
+   * Creates an OkHttp {@link Response} using the supplied {@link Request} and {@link CacheResponse}
+   * to supply the data.
+   */
+  static Response createOkResponse(Request request, CacheResponse javaResponse)
+      throws IOException {
+    Response.Builder okResponseBuilder = new Response.Builder();
+
+    // Request: Use the one provided.
+    okResponseBuilder.request(request);
+
+    // Status line: Java has this as one of the headers.
+    StatusLine statusLine = StatusLine.parse(extractStatusLine(javaResponse));
+    okResponseBuilder.protocol(statusLine.protocol);
+    okResponseBuilder.code(statusLine.code);
+    okResponseBuilder.message(statusLine.message);
+
+    // Response headers
+    Headers okHeaders = extractOkHeaders(javaResponse);
+    okResponseBuilder.headers(okHeaders);
+
+    // Response body
+    ResponseBody okBody = createOkBody(okHeaders, javaResponse.getBody());
+    okResponseBuilder.body(okBody);
+
+    // Handle SSL handshake information as needed.
+    if (javaResponse instanceof SecureCacheResponse) {
+      SecureCacheResponse javaSecureCacheResponse = (SecureCacheResponse) javaResponse;
+
+      // Handshake doesn't support null lists.
+      List<Certificate> peerCertificates;
+      try {
+        peerCertificates = javaSecureCacheResponse.getServerCertificateChain();
+      } catch (SSLPeerUnverifiedException e) {
+        peerCertificates = Collections.emptyList();
+      }
+      List<Certificate> localCertificates = javaSecureCacheResponse.getLocalCertificateChain();
+      if (localCertificates == null) {
+        localCertificates = Collections.emptyList();
+      }
+      Handshake handshake = Handshake.get(
+          javaSecureCacheResponse.getCipherSuite(), peerCertificates, localCertificates);
+      okResponseBuilder.handshake(handshake);
+    }
+
+    return okResponseBuilder.build();
+  }
+
+  /**
+   * Creates an OkHttp {@link Request} from the supplied information.
+   *
+   * <p>This method allows a {@code null} value for {@code requestHeaders} for situations
+   * where a connection is already connected and access to the headers has been lost.
+   * See {@link java.net.HttpURLConnection#getRequestProperties()} for details.
+   */
+  public static Request createOkRequest(
+      URI uri, String requestMethod, Map<String, List<String>> requestHeaders) {
+
+    Request.Builder builder = new Request.Builder()
+        .url(uri.toString())
+        .method(requestMethod, null);
+
+    if (requestHeaders != null) {
+      Headers headers = extractOkHeaders(requestHeaders);
+      builder.headers(headers);
+    }
+    return builder.build();
+  }
+
+  /**
+   * Creates a {@link java.net.CacheResponse} of the correct (sub)type using information
+   * gathered from the supplied {@link Response}.
+   */
+  public static CacheResponse createJavaCacheResponse(final Response response) {
+    final Headers headers = response.headers();
+    final ResponseBody body = response.body();
+    if (response.request().isHttps()) {
+      final Handshake handshake = response.handshake();
+      return new SecureCacheResponse() {
+        @Override
+        public String getCipherSuite() {
+          return handshake != null ? handshake.cipherSuite() : null;
+        }
+
+        @Override
+        public List<Certificate> getLocalCertificateChain() {
+          if (handshake == null) return null;
+          // Java requires null, not an empty list here.
+          List<Certificate> certificates = handshake.localCertificates();
+          return certificates.size() > 0 ? certificates : null;
+        }
+
+        @Override
+        public List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException {
+          if (handshake == null) return null;
+          // Java requires null, not an empty list here.
+          List<Certificate> certificates = handshake.peerCertificates();
+          return certificates.size() > 0 ? certificates : null;
+        }
+
+        @Override
+        public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+          if (handshake == null) return null;
+          return handshake.peerPrincipal();
+        }
+
+        @Override
+        public Principal getLocalPrincipal() {
+          if (handshake == null) return null;
+          return handshake.localPrincipal();
+        }
+
+        @Override
+        public Map<String, List<String>> getHeaders() throws IOException {
+          // Java requires that the entry with a null key be the status line.
+          return OkHeaders.toMultimap(headers, StatusLine.get(response).toString());
+        }
+
+        @Override
+        public InputStream getBody() throws IOException {
+          if (body == null) return null;
+          return body.byteStream();
+        }
+      };
+    } else {
+      return new CacheResponse() {
+        @Override
+        public Map<String, List<String>> getHeaders() throws IOException {
+          // Java requires that the entry with a null key be the status line.
+          return OkHeaders.toMultimap(headers, StatusLine.get(response).toString());
+        }
+
+        @Override
+        public InputStream getBody() throws IOException {
+          if (body == null) return null;
+          return body.byteStream();
+        }
+      };
+    }
+  }
+
+  /**
+   * Creates an {@link java.net.HttpURLConnection} of the correct subclass from the supplied OkHttp
+   * {@link Response}.
+   */
+  static HttpURLConnection createJavaUrlConnection(Response okResponse) {
+    Request request = okResponse.request();
+    // Create an object of the correct class in case the ResponseCache uses instanceof.
+    if (request.isHttps()) {
+      return new CacheHttpsURLConnection(new CacheHttpURLConnection(okResponse));
+    } else {
+      return new CacheHttpURLConnection(okResponse);
+    }
+  }
+
+  /**
+   * Extracts an immutable request header map from the supplied {@link com.squareup.okhttp.Headers}.
+   */
+  static Map<String, List<String>> extractJavaHeaders(Request request) {
+    return OkHeaders.toMultimap(request.headers(), null);
+  }
+
+  /**
+   * Extracts OkHttp headers from the supplied {@link java.net.CacheResponse}. Only real headers are
+   * extracted. See {@link #extractStatusLine(java.net.CacheResponse)}.
+   */
+  private static Headers extractOkHeaders(CacheResponse javaResponse) throws IOException {
+    Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
+    return extractOkHeaders(javaResponseHeaders);
+  }
+
+  /**
+   * Extracts OkHttp headers from the supplied {@link java.net.HttpURLConnection}. Only real headers
+   * are extracted. See {@link #extractStatusLine(java.net.HttpURLConnection)}.
+   */
+  private static Headers extractOkResponseHeaders(HttpURLConnection httpUrlConnection) {
+    Map<String, List<String>> javaResponseHeaders = httpUrlConnection.getHeaderFields();
+    return extractOkHeaders(javaResponseHeaders);
+  }
+
+  /**
+   * Extracts OkHttp headers from the supplied {@link Map}. Only real headers are
+   * extracted. Any entry (one with a {@code null} key) is discarded.
+   */
+  // @VisibleForTesting
+  static Headers extractOkHeaders(Map<String, List<String>> javaHeaders) {
+    Headers.Builder okHeadersBuilder = new Headers.Builder();
+    for (Map.Entry<String, List<String>> javaHeader : javaHeaders.entrySet()) {
+      String name = javaHeader.getKey();
+      if (name == null) {
+        // The Java API uses the null key to store the status line in responses.
+        // Earlier versions of OkHttp would use the null key to store the "request line" in
+        // requests. e.g. "GET / HTTP 1.1". Although this is no longer the case it must be
+        // explicitly ignored because Headers.Builder does not support null keys.
+        continue;
+      }
+      for (String value : javaHeader.getValue()) {
+        okHeadersBuilder.add(name, value);
+      }
+    }
+    return okHeadersBuilder.build();
+  }
+
+  /**
+   * Extracts the status line from the supplied Java API {@link java.net.HttpURLConnection}.
+   * As per the spec, the status line is held as the header with the null key. Returns {@code null}
+   * if there is no status line.
+   */
+  private static String extractStatusLine(HttpURLConnection httpUrlConnection) {
+    // Java specifies that this will be be response header with a null key.
+    return httpUrlConnection.getHeaderField(null);
+  }
+
+  /**
+   * Extracts the status line from the supplied Java API {@link java.net.CacheResponse}.
+   * As per the spec, the status line is held as the header with the null key. Returns {@code null}
+   * if there is no status line.
+   */
+  private static String extractStatusLine(CacheResponse javaResponse) throws IOException {
+    Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
+    return extractStatusLine(javaResponseHeaders);
+  }
+
+  // VisibleForTesting
+  static String extractStatusLine(Map<String, List<String>> javaResponseHeaders) {
+    List<String> values = javaResponseHeaders.get(null);
+    if (values == null || values.size() == 0) {
+      return null;
+    }
+    return values.get(0);
+  }
+
+  /**
+   * Creates an OkHttp Response.Body containing the supplied information.
+   */
+  private static ResponseBody createOkBody(final Headers okHeaders, InputStream body) {
+    final BufferedSource source = Okio.buffer(Okio.source(body));
+    return new ResponseBody() {
+      @Override public MediaType contentType() {
+        String contentTypeHeader = okHeaders.get("Content-Type");
+        return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);
+      }
+      @Override public long contentLength() {
+        return OkHeaders.contentLength(okHeaders);
+      }
+      @Override public BufferedSource source() {
+        return source;
+      }
+    };
+  }
+
+  /**
+   * An {@link java.net.HttpURLConnection} that represents an HTTP request at the point where
+   * the request has been made, and the response headers have been received, but the body content,
+   * if present, has not been read yet. This intended to provide enough information for
+   * {@link java.net.ResponseCache} subclasses and no more.
+   *
+   * <p>Much of the method implementations are overrides to delegate to the OkHttp request and
+   * response, or to deny access to information as a real HttpURLConnection would after connection.
+   */
+  private static final class CacheHttpURLConnection extends HttpURLConnection {
+
+    private final Request request;
+    private final Response response;
+
+    public CacheHttpURLConnection(Response response) {
+      super(response.request().url());
+      this.request = response.request();
+      this.response = response;
+
+      // Configure URLConnection inherited fields.
+      this.connected = true;
+      this.doOutput = response.body() == null;
+
+      // Configure HttpUrlConnection inherited fields.
+      this.method = request.method();
+    }
+
+    // HTTP connection lifecycle methods
+
+    @Override
+    public void connect() throws IOException {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void disconnect() {
+      throw throwRequestModificationException();
+    }
+
+    // HTTP Request methods
+
+    @Override
+    public void setRequestProperty(String key, String value) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void addRequestProperty(String key, String value) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public String getRequestProperty(String key) {
+      return request.header(key);
+    }
+
+    @Override
+    public Map<String, List<String>> getRequestProperties() {
+      // This is to preserve RI and compatibility with OkHttp's HttpURLConnectionImpl. There seems
+      // no good reason why this should fail while getRequestProperty() is ok.
+      throw throwRequestHeaderAccessException();
+    }
+
+    @Override
+    public void setFixedLengthStreamingMode(int contentLength) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void setFixedLengthStreamingMode(long contentLength) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void setChunkedStreamingMode(int chunklen) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void setInstanceFollowRedirects(boolean followRedirects) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public boolean getInstanceFollowRedirects() {
+      // Return the platform default.
+      return super.getInstanceFollowRedirects();
+    }
+
+    @Override
+    public void setRequestMethod(String method) throws ProtocolException {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public String getRequestMethod() {
+      return request.method();
+    }
+
+    // HTTP Response methods
+
+    @Override
+    public String getHeaderFieldKey(int position) {
+      // Deal with index 0 meaning "status line"
+      if (position < 0) {
+        throw new IllegalArgumentException("Invalid header index: " + position);
+      }
+      if (position == 0) {
+        return null;
+      }
+      return response.headers().name(position - 1);
+    }
+
+    @Override
+    public String getHeaderField(int position) {
+      // Deal with index 0 meaning "status line"
+      if (position < 0) {
+        throw new IllegalArgumentException("Invalid header index: " + position);
+      }
+      if (position == 0) {
+        return StatusLine.get(response).toString();
+      }
+      return response.headers().value(position - 1);
+    }
+
+    @Override
+    public String getHeaderField(String fieldName) {
+      return fieldName == null
+          ? StatusLine.get(response).toString()
+          : response.headers().get(fieldName);
+    }
+
+    @Override
+    public Map<String, List<String>> getHeaderFields() {
+      return OkHeaders.toMultimap(response.headers(), StatusLine.get(response).toString());
+    }
+
+    @Override
+    public int getResponseCode() throws IOException {
+      return response.code();
+    }
+
+    @Override
+    public String getResponseMessage() throws IOException {
+      return response.message();
+    }
+
+    @Override
+    public InputStream getErrorStream() {
+      return null;
+    }
+
+    // HTTP miscellaneous methods
+
+    @Override
+    public boolean usingProxy() {
+      // It's safe to return false here, even if a proxy is in use. The problem is we don't
+      // necessarily know if we're going to use a proxy by the time we ask the cache for a response.
+      return false;
+    }
+
+    // URLConnection methods
+
+    @Override
+    public void setConnectTimeout(int timeout) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public int getConnectTimeout() {
+      // Impossible to say.
+      return 0;
+    }
+
+    @Override
+    public void setReadTimeout(int timeout) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public int getReadTimeout() {
+      // Impossible to say.
+      return 0;
+    }
+
+    @Override
+    public Object getContent() throws IOException {
+      throw throwResponseBodyAccessException();
+    }
+
+    @Override
+    public Object getContent(Class[] classes) throws IOException {
+      throw throwResponseBodyAccessException();
+    }
+
+    @Override
+    public InputStream getInputStream() throws IOException {
+      throw throwResponseBodyAccessException();
+    }
+
+    @Override
+    public OutputStream getOutputStream() throws IOException {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void setDoInput(boolean doInput) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public boolean getDoInput() {
+      return true;
+    }
+
+    @Override
+    public void setDoOutput(boolean doOutput) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public boolean getDoOutput() {
+      return request.body() != null;
+    }
+
+    @Override
+    public void setAllowUserInteraction(boolean allowUserInteraction) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public boolean getAllowUserInteraction() {
+      return false;
+    }
+
+    @Override
+    public void setUseCaches(boolean useCaches) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public boolean getUseCaches() {
+      return super.getUseCaches();
+    }
+
+    @Override
+    public void setIfModifiedSince(long ifModifiedSince) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public long getIfModifiedSince() {
+      return 0;
+    }
+
+    @Override
+    public boolean getDefaultUseCaches() {
+      return super.getDefaultUseCaches();
+    }
+
+    @Override
+    public void setDefaultUseCaches(boolean defaultUseCaches) {
+      super.setDefaultUseCaches(defaultUseCaches);
+    }
+  }
+
+  /** An HttpsURLConnection to offer to the cache. */
+  private static final class CacheHttpsURLConnection extends DelegatingHttpsURLConnection {
+    private final CacheHttpURLConnection delegate;
+
+    public CacheHttpsURLConnection(CacheHttpURLConnection delegate) {
+      super(delegate);
+      this.delegate = delegate;
+    }
+
+    @Override protected Handshake handshake() {
+      return delegate.response.handshake();
+    }
+
+    @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
+      throw throwRequestModificationException();
+    }
+
+    @Override public HostnameVerifier getHostnameVerifier() {
+      throw throwRequestSslAccessException();
+    }
+
+    @Override public void setSSLSocketFactory(SSLSocketFactory socketFactory) {
+      throw throwRequestModificationException();
+    }
+
+    @Override public SSLSocketFactory getSSLSocketFactory() {
+      throw throwRequestSslAccessException();
+    }
+
+    @Override public long getContentLengthLong() {
+      return delegate.getContentLengthLong();
+    }
+
+    @Override public void setFixedLengthStreamingMode(long contentLength) {
+      delegate.setFixedLengthStreamingMode(contentLength);
+    }
+
+    @Override public long getHeaderFieldLong(String field, long defaultValue) {
+      return delegate.getHeaderFieldLong(field, defaultValue);
+    }
+  }
+
+  private static RuntimeException throwRequestModificationException() {
+    throw new UnsupportedOperationException("ResponseCache cannot modify the request.");
+  }
+
+  private static RuntimeException throwRequestHeaderAccessException() {
+    throw new UnsupportedOperationException("ResponseCache cannot access request headers");
+  }
+
+  private static RuntimeException throwRequestSslAccessException() {
+    throw new UnsupportedOperationException("ResponseCache cannot access SSL internals");
+  }
+
+  private static RuntimeException throwResponseBodyAccessException() {
+    throw new UnsupportedOperationException("ResponseCache cannot access the response body.");
+  }
+
+  private static <T> List<T> nullSafeImmutableList(T[] elements) {
+    return elements == null ? Collections.<T>emptyList() : Util.immutableList(elements);
+  }
+
+}
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/AbstractResponseCache.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/AbstractResponseCache.java
new file mode 100644
index 0000000000..2a59d22a02
--- /dev/null
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/AbstractResponseCache.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.List;
+import java.util.Map;
+
+public class AbstractResponseCache extends ResponseCache {
+  @Override public CacheResponse get(URI uri, String requestMethod,
+      Map<String, List<String>> requestHeaders) throws IOException {
+    return null;
+  }
+
+  @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+    return null;
+  }
+
+  public static URI toUri(URL serverUrl) {
+    try {
+      return serverUrl.toURI();
+    } catch (URISyntaxException e) {
+      throw new AssertionError(e);
+    }
+  }
+}
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java
new file mode 100644
index 0000000000..a7dc44b0d0
--- /dev/null
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java
@@ -0,0 +1,167 @@
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static okio.Okio.buffer;
+import static okio.Okio.source;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class OkUrlFactoryTest {
+  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
+  @Rule public TemporaryFolder cacheFolder = new TemporaryFolder();
+
+  private MockWebServer server;
+  private OkUrlFactory factory;
+
+  @Before public void setUp() throws IOException {
+    server = serverRule.get();
+
+    OkHttpClient client = new OkHttpClient();
+    client.setCache(new Cache(cacheFolder.getRoot(), 10 * 1024 * 1024));
+    factory = new OkUrlFactory(client);
+  }
+
+  /**
+   * Response code 407 should only come from proxy servers. Android's client
+   * throws if it is sent by an origin server.
+   */
+  @Test public void originServerSends407() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(407));
+
+    HttpURLConnection conn = factory.open(server.getUrl("/"));
+    try {
+      conn.getResponseCode();
+      fail();
+    } catch (IOException ignored) {
+    }
+  }
+
+  @Test public void networkResponseSourceHeader() throws Exception {
+    server.enqueue(new MockResponse().setBody("Isla Sorna"));
+
+    HttpURLConnection connection = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection, "NETWORK 200");
+    assertResponseBody(connection, "Isla Sorna");
+  }
+
+  @Test public void networkFailureResponseSourceHeader() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    HttpURLConnection connection = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection, "NETWORK 404");
+  }
+
+  @Test public void conditionalCacheHitResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("Isla Nublar"));
+    server.enqueue(new MockResponse().setResponseCode(304));
+
+    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection2, "CONDITIONAL_CACHE 304");
+    assertResponseBody(connection2, "Isla Nublar");
+  }
+
+  @Test public void conditionalCacheMissResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("Isla Nublar"));
+    server.enqueue(new MockResponse().setBody("Isla Sorna"));
+
+    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection2, "CONDITIONAL_CACHE 200");
+    assertResponseBody(connection2, "Isla Sorna");
+  }
+
+  @Test public void cacheResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Expires: " + formatDate(2, TimeUnit.HOURS))
+        .setBody("Isla Nublar"));
+
+    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection2, "CACHE 200");
+    assertResponseBody(connection2, "Isla Nublar");
+  }
+
+  @Test public void noneResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse().setBody("Isla Nublar"));
+
+    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    connection2.setRequestProperty("Cache-Control", "only-if-cached");
+    assertResponseHeader(connection2, "NONE");
+  }
+
+  @Test
+  public void setInstanceFollowRedirectsFalse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpURLConnection connection = factory.open(server.getUrl("/a"));
+    connection.setInstanceFollowRedirects(false);
+    assertResponseBody(connection, "A");
+    assertResponseCode(connection, 302);
+  }
+
+  private void assertResponseBody(HttpURLConnection connection, String expected) throws Exception {
+    String actual = buffer(source(connection.getInputStream())).readString(US_ASCII);
+    assertEquals(expected, actual);
+  }
+
+  private void assertResponseHeader(HttpURLConnection connection, String expected) {
+    final String headerFieldPrefix = Platform.get().getPrefix();
+    assertEquals(expected, connection.getHeaderField(headerFieldPrefix + "-Response-Source"));
+  }
+
+  private void assertResponseCode(HttpURLConnection connection, int expected) throws IOException {
+    assertEquals(expected, connection.getResponseCode());
+  }
+
+  private static String formatDate(long delta, TimeUnit timeUnit) {
+    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
+  }
+
+  private static String formatDate(Date date) {
+    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
+    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
+    return rfc1123.format(date);
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
similarity index 73%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
rename to okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
index aa3948b192..79d73f4eef 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/UrlConnectionCacheTest.java
@@ -14,117 +14,100 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.http;
+package com.squareup.okhttp;
 
-import com.squareup.okhttp.HttpResponseCache;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.ResponseSource;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
 import java.io.BufferedReader;
-import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
-import java.net.InetAddress;
 import java.net.ResponseCache;
-import java.net.SecureCacheResponse;
-import java.net.URI;
-import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.URLConnection;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
-import java.util.Map;
 import java.util.TimeZone;
-import java.util.UUID;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-/** Android's HttpResponseCacheTest. */
-public final class HttpResponseCacheTest {
+/** Test caching with {@link OkUrlFactory}. */
+public final class UrlConnectionCacheTest {
   private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
     @Override public boolean verify(String s, SSLSession sslSession) {
       return true;
     }
   };
-  private final OkHttpClient client = new OkHttpClient();
-  private MockWebServer server = new MockWebServer();
-  private MockWebServer server2 = new MockWebServer();
-  private HttpResponseCache cache;
-  private final CookieManager cookieManager = new CookieManager();
 
-  private static final SSLContext sslContext;
-  static {
-    try {
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+
+  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
+  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
+  @Rule public MockWebServerRule server2Rule = new MockWebServerRule();
+
+  private final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
+  private MockWebServer server;
+  private MockWebServer server2;
+  private Cache cache;
+  private final CookieManager cookieManager = new CookieManager();
 
   @Before public void setUp() throws Exception {
-    String tmp = System.getProperty("java.io.tmpdir");
-    File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
-    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
-    ResponseCache.setDefault(cache);
+    server = serverRule.get();
+    server.setProtocolNegotiationEnabled(false);
+    server2 = server2Rule.get();
+    cache = new Cache(cacheRule.getRoot(), Integer.MAX_VALUE);
+    client.client().setCache(cache);
     CookieHandler.setDefault(cookieManager);
-    server.setNpnEnabled(false);
   }
 
   @After public void tearDown() throws Exception {
-    server.shutdown();
-    server2.shutdown();
     ResponseCache.setDefault(null);
-    cache.delete();
     CookieHandler.setDefault(null);
   }
 
-  private HttpURLConnection openConnection(URL url) {
-    return client.open(url);
+  @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
+    assertSame(cache, client.client().getCache());
+    assertNull(client.getResponseCache());
   }
 
   /**
@@ -149,9 +132,13 @@ private HttpURLConnection openConnection(URL url) {
     assertCached(false, 207);
     assertCached(true, 300);
     assertCached(true, 301);
-    for (int i = 302; i <= 308; ++i) {
-      assertCached(false, i);
-    }
+    assertCached(true, 302);
+    assertCached(false, 303);
+    assertCached(false, 304);
+    assertCached(false, 305);
+    assertCached(false, 306);
+    assertCached(true, 307);
+    assertCached(true, 308);
     for (int i = 400; i <= 406; ++i) {
       assertCached(false, i);
     }
@@ -167,23 +154,6 @@ private HttpURLConnection openConnection(URL url) {
     }
   }
 
-  /**
-   * Response code 407 should only come from proxy servers. Android's client
-   * throws if it is sent by an origin server.
-   */
-  @Test public void originServerSends407() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(407));
-    server.play();
-
-    URL url = server.getUrl("/");
-    HttpURLConnection conn = openConnection(url);
-    try {
-      conn.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
   @Test public void responseCaching_410() throws Exception {
     // the HTTP spec permits caching 410s, but the RI doesn't.
     assertCached(true, 410);
@@ -191,12 +161,12 @@ private HttpURLConnection openConnection(URL url) {
 
   private void assertCached(boolean shouldPut, int responseCode) throws Exception {
     server = new MockWebServer();
-    MockResponse response =
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .setResponseCode(responseCode)
-            .setBody("ABCDE")
-            .addHeader("WWW-Authenticate: challenge");
+    MockResponse response = new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(responseCode)
+        .setBody("ABCDE")
+        .addHeader("WWW-Authenticate: challenge");
     if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
       response.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
     } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
@@ -206,76 +176,22 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
     server.play();
 
     URL url = server.getUrl("/");
-    HttpURLConnection conn = openConnection(url);
+    HttpURLConnection conn = client.open(url);
     assertEquals(responseCode, conn.getResponseCode());
 
     // exhaust the content stream
     readAscii(conn);
 
-    CacheResponse cached =
-        cache.get(url.toURI(), "GET", Collections.<String, List<String>>emptyMap());
+    Response cached = cache.get(new Request.Builder().url(url).build());
     if (shouldPut) {
       assertNotNull(Integer.toString(responseCode), cached);
-      cached.getBody().close();
+      cached.body().close();
     } else {
       assertNull(Integer.toString(responseCode), cached);
     }
     server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
   }
 
-  /**
-   * Test that we can interrogate the response when the cache is being
-   * populated. http://code.google.com/p/android/issues/detail?id=7787
-   */
-  @Test public void responseCacheCallbackApis() throws Exception {
-    final String body = "ABCDE";
-    final AtomicInteger cacheCount = new AtomicInteger();
-
-    server.enqueue(
-        new MockResponse().setStatus("HTTP/1.1 200 Fantastic").addHeader("fgh: ijk").setBody(body));
-    server.play();
-
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        return null;
-      }
-
-      @Override public CacheRequest put(URI uri, URLConnection conn) throws IOException {
-        HttpURLConnection httpConnection = (HttpURLConnection) conn;
-        try {
-          httpConnection.getRequestProperties();
-          fail();
-        } catch (IllegalStateException expected) {
-        }
-        try {
-          httpConnection.addRequestProperty("K", "V");
-          fail();
-        } catch (IllegalStateException expected) {
-        }
-        assertEquals("HTTP/1.1 200 Fantastic", httpConnection.getHeaderField(null));
-        assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"),
-            httpConnection.getHeaderFields().get(null));
-        assertEquals(200, httpConnection.getResponseCode());
-        assertEquals("Fantastic", httpConnection.getResponseMessage());
-        assertEquals(body.length(), httpConnection.getContentLength());
-        assertEquals("ijk", httpConnection.getHeaderField("fgh"));
-        try {
-          httpConnection.getInputStream(); // the RI doesn't forbid this, but it should
-          fail();
-        } catch (IOException expected) {
-        }
-        cacheCount.incrementAndGet();
-        return null;
-      }
-    });
-
-    URL url = server.getUrl("/");
-    HttpURLConnection connection = openConnection(url);
-    assertEquals(body, readAscii(connection));
-    assertEquals(1, cacheCount.get());
-  }
-
   @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
     testResponseCaching(TransferKind.FIXED_LENGTH);
   }
@@ -299,10 +215,9 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
             .setStatus("HTTP/1.1 200 Fantastic");
     transferKind.setBody(response, "I love puppies but hate spiders", 1);
     server.enqueue(response);
-    server.play();
 
     // Make sure that calling skip() doesn't omit bytes from the cache.
-    HttpURLConnection urlConnection = openConnection(server.getUrl("/"));
+    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
     InputStream in = urlConnection.getInputStream();
     assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
     reliableSkip(in, "puppies but hate ".length());
@@ -312,7 +227,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals(1, cache.getWriteSuccessCount());
     assertEquals(0, cache.getWriteAbortCount());
 
-    urlConnection = openConnection(server.getUrl("/")); // cached!
+    urlConnection = client.open(server.getUrl("/")); // cached!
     in = urlConnection.getInputStream();
     assertEquals("I love puppies but hate spiders",
         readAscii(urlConnection, "I love puppies but hate spiders".length()));
@@ -332,54 +247,33 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
-    server.play();
 
-    HttpsURLConnection connection = (HttpsURLConnection) client.open(server.getUrl("/"));
-    connection.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(connection));
+    HttpsURLConnection c1 = (HttpsURLConnection) client.open(server.getUrl("/"));
+    c1.setSSLSocketFactory(sslContext.getSocketFactory());
+    c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("ABC", readAscii(c1));
 
     // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    String suite = connection.getCipherSuite();
-    List<Certificate> localCerts = toListOrNull(connection.getLocalCertificates());
-    List<Certificate> serverCerts = toListOrNull(connection.getServerCertificates());
-    Principal peerPrincipal = connection.getPeerPrincipal();
-    Principal localPrincipal = connection.getLocalPrincipal();
-
-    connection = (HttpsURLConnection) client.open(server.getUrl("/")); // cached!
-    connection.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(connection));
+    String suite = c1.getCipherSuite();
+    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
+    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
+    Principal peerPrincipal = c1.getPeerPrincipal();
+    Principal localPrincipal = c1.getLocalPrincipal();
+
+    HttpsURLConnection c2 = (HttpsURLConnection) client.open(server.getUrl("/")); // cached!
+    c2.setSSLSocketFactory(sslContext.getSocketFactory());
+    c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("ABC", readAscii(c2));
 
     assertEquals(2, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(1, cache.getHitCount());
 
-    assertEquals(suite, connection.getCipherSuite());
-    assertEquals(localCerts, toListOrNull(connection.getLocalCertificates()));
-    assertEquals(serverCerts, toListOrNull(connection.getServerCertificates()));
-    assertEquals(peerPrincipal, connection.getPeerPrincipal());
-    assertEquals(localPrincipal, connection.getLocalPrincipal());
-  }
-
-  @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
-
-    ResponseCache.setDefault(new InsecureResponseCache());
-
-    HttpsURLConnection connection1 = (HttpsURLConnection) client.open(server.getUrl("/"));
-    connection1.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(connection1));
-
-    // Not cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) client.open(server.getUrl("/"));
-    connection2.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("DEF", readAscii(connection2));
+    assertEquals(suite, c2.getCipherSuite());
+    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
+    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
+    assertEquals(peerPrincipal, c2.getPeerPrincipal());
+    assertEquals(localPrincipal, c2.getLocalPrincipal());
   }
 
   @Test public void responseCachingAndRedirects() throws Exception {
@@ -391,12 +285,11 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
 
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection));
 
-    connection = openConnection(server.getUrl("/")); // cached!
+    connection = client.open(server.getUrl("/")); // cached!
     assertEquals("ABC", readAscii(connection));
 
     assertEquals(4, cache.getRequestCount()); // 2 requests + 2 redirects
@@ -409,20 +302,19 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: /foo"));
     server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
 
-    assertEquals("ABC", readAscii(openConnection(server.getUrl("/foo"))));
+    assertEquals("ABC", readAscii(client.open(server.getUrl("/foo"))));
     RecordedRequest request1 = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
     assertEquals(0, request1.getSequenceNumber());
 
-    assertEquals("ABC", readAscii(openConnection(server.getUrl("/bar"))));
+    assertEquals("ABC", readAscii(client.open(server.getUrl("/bar"))));
     RecordedRequest request2 = server.takeRequest();
     assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
     assertEquals(1, request2.getSequenceNumber());
 
     // an unrelated request should reuse the pooled connection
-    assertEquals("DEF", readAscii(openConnection(server.getUrl("/baz"))));
+    assertEquals("DEF", readAscii(client.open(server.getUrl("/baz"))));
     RecordedRequest request3 = server.takeRequest();
     assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
     assertEquals(2, request3.getSequenceNumber());
@@ -438,20 +330,22 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
 
     HttpsURLConnection connection1 = (HttpsURLConnection) client.open(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection1));
+    assertNotNull(connection1.getCipherSuite());
 
     // Cached!
     HttpsURLConnection connection2 = (HttpsURLConnection) client.open(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection2));
+    assertNotNull(connection2.getCipherSuite());
 
     assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
     assertEquals(2, cache.getHitCount());
+    assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
   }
 
   /**
@@ -468,16 +362,14 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
     server2.enqueue(new MockResponse().setBody("DEF"));
-    server2.play();
 
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: " + server2.getUrl("/")));
-    server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
 
     HttpURLConnection connection1 = client.open(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection1));
@@ -490,30 +382,6 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals(2, cache.getHitCount());
   }
 
-  @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.play();
-
-    final AtomicReference<Map<String, List<String>>> requestHeadersRef =
-        new AtomicReference<Map<String, List<String>>>();
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        requestHeadersRef.set(requestHeaders);
-        return null;
-      }
-      @Override public CacheRequest put(URI uri, URLConnection conn) throws IOException {
-        return null;
-      }
-    });
-
-    URL url = server.getUrl("/");
-    URLConnection urlConnection = openConnection(url);
-    urlConnection.addRequestProperty("A", "android");
-    readAscii(urlConnection);
-    assertEquals(Arrays.asList("android"), requestHeadersRef.get().get("A"));
-  }
-
   @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
     testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
   }
@@ -533,10 +401,9 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
     transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
     server.enqueue(truncateViolently(response, 16));
     server.enqueue(new MockResponse().setBody("Request #2"));
-    server.play();
 
     BufferedReader reader = new BufferedReader(
-        new InputStreamReader(openConnection(server.getUrl("/")).getInputStream()));
+        new InputStreamReader(client.open(server.getUrl("/")).getInputStream()));
     assertEquals("ABCDE", reader.readLine());
     try {
       reader.readLine();
@@ -548,7 +415,7 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
 
     assertEquals(1, cache.getWriteAbortCount());
     assertEquals(0, cache.getWriteSuccessCount());
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = client.open(server.getUrl("/"));
     assertEquals("Request #2", readAscii(connection));
     assertEquals(1, cache.getWriteAbortCount());
     assertEquals(1, cache.getWriteSuccessCount());
@@ -568,13 +435,12 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
 
   private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
     // Setting a low transfer speed ensures that stream discarding will time out.
-    MockResponse response = new MockResponse().setBytesPerSecond(6);
+    MockResponse response = new MockResponse().throttleBody(6, 1, TimeUnit.SECONDS);
     transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
     server.enqueue(response);
     server.enqueue(new MockResponse().setBody("Request #2"));
-    server.play();
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals("ABCDE", readAscii(connection, 5));
     in.close();
@@ -586,7 +452,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
 
     assertEquals(1, cache.getWriteAbortCount());
     assertEquals(0, cache.getWriteSuccessCount());
-    connection = openConnection(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("Request #2", readAscii(connection));
     assertEquals(1, cache.getWriteAbortCount());
     assertEquals(1, cache.getWriteSuccessCount());
@@ -601,11 +467,10 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
             .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
             .setBody("A"));
-    server.play();
 
     URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
+    assertEquals("A", readAscii(client.open(url)));
+    URLConnection connection = client.open(url);
     assertEquals("A", readAscii(connection));
     assertNull(connection.getHeaderField("Warning"));
   }
@@ -631,10 +496,9 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
         .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
         .setBody("A"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    URLConnection connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
     assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
         connection.getHeaderField("Warning"));
@@ -646,11 +510,10 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
             .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/?foo=bar");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("B", readAscii(client.open(url)));
   }
 
   @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
@@ -763,18 +626,19 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
     server.enqueue(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("X-Response-ID: 1"));
     server.enqueue(new MockResponse().addHeader("X-Response-ID: 2"));
-    server.play();
 
     URL url = server.getUrl("/");
 
-    HttpURLConnection request1 = openConnection(url);
+    HttpURLConnection request1 = client.open(url);
     request1.setRequestMethod(requestMethod);
     addRequestBodyIfNecessary(requestMethod, request1);
+    request1.getInputStream().close();
     assertEquals("1", request1.getHeaderField("X-Response-ID"));
 
-    URLConnection request2 = openConnection(url);
+    URLConnection request2 = client.open(url);
+    request2.getInputStream().close();
     if (expectCached) {
-      assertEquals("1", request1.getHeaderField("X-Response-ID"));
+      assertEquals("1", request2.getHeaderField("X-Response-ID"));
     } else {
       assertEquals("2", request2.getHeaderField("X-Response-ID"));
     }
@@ -800,18 +664,17 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
     server.enqueue(new MockResponse().setBody("B"));
     server.enqueue(new MockResponse().setBody("C"));
-    server.play();
 
     URL url = server.getUrl("/");
 
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
 
-    HttpURLConnection invalidate = openConnection(url);
+    HttpURLConnection invalidate = client.open(url);
     invalidate.setRequestMethod(requestMethod);
     addRequestBodyIfNecessary(requestMethod, invalidate);
     assertEquals("B", readAscii(invalidate));
 
-    assertEquals("C", readAscii(openConnection(url)));
+    assertEquals("C", readAscii(client.open(url)));
   }
 
   @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
@@ -822,18 +685,17 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
     server.enqueue(new MockResponse().setBody("B").setResponseCode(500));
     server.enqueue(new MockResponse().setBody("C"));
-    server.play();
 
     URL url = server.getUrl("/");
 
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
 
-    HttpURLConnection invalidate = openConnection(url);
+    HttpURLConnection invalidate = client.open(url);
     invalidate.setRequestMethod("POST");
     addRequestBodyIfNecessary("POST", invalidate);
     assertEquals("B", readAscii(invalidate));
 
-    assertEquals("C", readAscii(openConnection(url)));
+    assertEquals("C", readAscii(client.open(url)));
   }
 
   @Test public void etag() throws Exception {
@@ -905,15 +767,14 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("Content-Range: bytes 1000-1001/2000"));
     server.enqueue(new MockResponse().setBody("BB"));
-    server.play();
 
     URL url = server.getUrl("/");
 
-    URLConnection range = openConnection(url);
+    URLConnection range = client.open(url);
     range.addRequestProperty("Range", "bytes=1000-1001");
     assertEquals("AA", readAscii(range));
 
-    assertEquals("BB", readAscii(openConnection(url)));
+    assertEquals("BB", readAscii(client.open(url)));
   }
 
   @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
@@ -922,12 +783,11 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
     server.enqueue(new MockResponse().setBody("B")
         .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
-    server.play();
 
     URL url = server.getUrl("/");
 
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(client.open(url)));
   }
 
   @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
@@ -944,17 +804,21 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
   private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
     server.enqueue(
-        response.setBody(gzip("ABCABCABC".getBytes("UTF-8"))).addHeader("Content-Encoding: gzip"));
+        response.setBody(gzip("ABCABCABC")).addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    server.play();
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
+    // At least three request/response pairs are required because after the first request is cached
+    // a different execution path might be taken. Thus modifications to the cache applied during
+    // the second request might not be visible until another request is performed.
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
   }
 
   @Test public void notModifiedSpecifiesEncoding() throws Exception {
     server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC".getBytes("UTF-8")))
+        .setBody(gzip("ABCABCABC"))
         .addHeader("Content-Encoding: gzip")
         .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
@@ -964,10 +828,37 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("DEFDEFDEF"));
 
-    server.play();
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("DEFDEFDEF", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("DEFDEFDEF", readAscii(client.open(server.getUrl("/"))));
+  }
+
+  /** https://github.com/square/okhttp/issues/947 */
+  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Vary: Accept-Encoding")
+        .addHeader("Cache-Control: max-age=60"));
+    server.enqueue(new MockResponse().setBody("FAIL"));
+
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+  }
+
+  @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
+    server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    ConnectionPool pool = ConnectionPool.getDefault();
+    pool.evictAll();
+    client.client().setConnectionPool(pool);
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals(1, client.client().getConnectionPool().getConnectionCount());
   }
 
   @Test public void expiresDateBeforeModifiedDate() throws Exception {
@@ -983,10 +874,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    server.play();
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "max-age=30");
     assertEquals("B", readAscii(connection));
   }
@@ -997,10 +887,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    server.play();
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "min-fresh=120");
     assertEquals("B", readAscii(connection));
   }
@@ -1011,10 +900,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    server.play();
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "max-stale=180");
     assertEquals("A", readAscii(connection));
     assertEquals("110 HttpURLConnection \"Response is stale\"",
@@ -1027,55 +915,62 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setBody("B"));
 
-    server.play();
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "max-stale=180");
     assertEquals("B", readAscii(connection));
   }
 
   @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
     // (no responses enqueued)
-    server.play();
 
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
+    assertEquals(1, cache.getRequestCount());
+    assertEquals(0, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
   }
 
   @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
     server.enqueue(new MockResponse().setBody("A")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    URLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(1, cache.getHitCount());
   }
 
   @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
     server.enqueue(new MockResponse().setBody("A")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
   }
 
   @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
   }
 
   @Test public void requestCacheControlNoCache() throws Exception {
@@ -1085,11 +980,10 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
             .addHeader("Cache-Control: max-age=60")
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
+    assertEquals("A", readAscii(client.open(url)));
+    URLConnection connection = client.open(url);
     connection.setRequestProperty("Cache-Control", "no-cache");
     assertEquals("B", readAscii(connection));
   }
@@ -1101,11 +995,10 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
             .addHeader("Cache-Control: max-age=60")
             .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
+    assertEquals("A", readAscii(client.open(url)));
+    URLConnection connection = client.open(url);
     connection.setRequestProperty("Pragma", "no-cache");
     assertEquals("B", readAscii(connection));
   }
@@ -1136,12 +1029,11 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
       String conditionValue) throws Exception {
     server.enqueue(seed.setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
     URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
 
-    HttpURLConnection connection = openConnection(url);
+    HttpURLConnection connection = client.open(url);
     connection.addRequestProperty(conditionName, conditionValue);
     assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
     assertEquals("", readAscii(connection));
@@ -1150,69 +1042,76 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     return server.takeRequest();
   }
 
+  /**
+   * Confirm that {@link URLConnection#setIfModifiedSince} causes an
+   * If-Modified-Since header with a GMT timestamp.
+   *
+   * https://code.google.com/p/android/issues/detail?id=66135
+   */
   @Test public void setIfModifiedSince() throws Exception {
-    Date since = new Date();
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection connection = openConnection(url);
-    connection.setIfModifiedSince(since.getTime());
+    URLConnection connection = client.open(url);
+    connection.setIfModifiedSince(1393666200000L);
     assertEquals("A", readAscii(connection));
     RecordedRequest request = server.takeRequest();
-    assertTrue(request.getHeaders().contains("If-Modified-Since: " + formatDate(since)));
+    String ifModifiedSinceHeader = request.getHeader("If-Modified-Since");
+    assertEquals("Sat, 01 Mar 2014 09:30:00 GMT", ifModifiedSinceHeader);
+  }
+
+  /**
+   * For Last-Modified and Date headers, we should echo the date back in the
+   * exact format we were served.
+   */
+  @Test public void retainServedDateFormat() throws Exception {
+    // Serve a response with a non-standard date format that OkHttp supports.
+    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
+    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
+    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
+    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    String lastModifiedString = dateFormat.format(lastModifiedDate);
+    String servedString = dateFormat.format(servedDate);
+
+    // This response should be conditionally cached.
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedString)
+        .addHeader("Expires: " + servedString)
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+
+    // The first request has no conditions.
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("If-Modified-Since"));
+
+    // The 2nd request uses the server's date format.
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
   }
 
   @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
     String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
     connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
     assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
     assertEquals("", readAscii(connection));
   }
 
-  @Test public void authorizationRequestHeaderPreventsCaching() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.MINUTES))
-            .addHeader("Cache-Control: max-age=60")
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    URLConnection connection = openConnection(url);
-    connection.addRequestProperty("Authorization", "password");
-    assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(openConnection(url)));
-  }
-
-  @Test public void authorizationResponseCachedWithSMaxAge() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader("Cache-Control: s-maxage=60"));
-  }
-
-  @Test public void authorizationResponseCachedWithPublic() throws Exception {
-    assertAuthorizationRequestFullyCached(new MockResponse().addHeader("Cache-Control: public"));
-  }
-
-  @Test public void authorizationResponseCachedWithMustRevalidate() throws Exception {
-    assertAuthorizationRequestFullyCached(
-        new MockResponse().addHeader("Cache-Control: must-revalidate"));
-  }
-
-  public void assertAuthorizationRequestFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.addHeader("Cache-Control: max-age=60").setBody("A"));
+  @Test public void authorizationRequestFullyCached() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection connection = openConnection(url);
+    URLConnection connection = client.open(url);
     connection.addRequestProperty("Authorization", "password");
     assertEquals("A", readAscii(connection));
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
   }
 
   @Test public void contentLocationDoesNotPopulateCache() throws Exception {
@@ -1220,46 +1119,43 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Content-Location: /bar")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/foo"))));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/bar"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/foo"))));
+    assertEquals("B", readAscii(client.open(server.getUrl("/bar"))));
   }
 
   @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
     server.enqueue(
         new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = client.open(server.getUrl("/"));
     connection.setUseCaches(false);
     assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
   }
 
   @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
     server.enqueue(
         new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    URLConnection connection = client.open(server.getUrl("/"));
     connection.setUseCaches(false);
     assertEquals("B", readAscii(connection));
   }
 
   @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
     URL url = new URL("http://localhost/");
-    URLConnection c1 = openConnection(url);
-    URLConnection c2 = openConnection(url);
+    URLConnection c1 = client.open(url);
+    URLConnection c2 = client.open(url);
     assertTrue(c1.getDefaultUseCaches());
     c1.setDefaultUseCaches(false);
     try {
       assertTrue(c1.getUseCaches());
       assertTrue(c2.getUseCaches());
-      URLConnection c3 = openConnection(url);
+      URLConnection c3 = client.open(url);
       assertFalse(c3.getUseCaches());
     } finally {
       c1.setDefaultUseCaches(true);
@@ -1272,11 +1168,10 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/b"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/a"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/a"))));
+    assertEquals("B", readAscii(client.open(server.getUrl("/b"))));
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
@@ -1289,14 +1184,13 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
     server.enqueue(new MockResponse().setBody("C"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
     assertEquals(1, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(0, cache.getHitCount());
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("C", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("C", readAscii(client.open(server.getUrl("/"))));
     assertEquals(3, cache.getRequestCount());
     assertEquals(3, cache.getNetworkCount());
     assertEquals(0, cache.getHitCount());
@@ -1308,14 +1202,13 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
     assertEquals(1, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(0, cache.getHitCount());
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
     assertEquals(3, cache.getRequestCount());
     assertEquals(3, cache.getNetworkCount());
     assertEquals(2, cache.getHitCount());
@@ -1323,14 +1216,13 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
 
   @Test public void statisticsFullCacheHit() throws Exception {
     server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
     assertEquals(1, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(0, cache.getHitCount());
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
     assertEquals(3, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(2, cache.getHitCount());
@@ -1341,14 +1233,13 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    HttpURLConnection frConnection = openConnection(url);
+    HttpURLConnection frConnection = client.open(url);
     frConnection.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(frConnection));
 
-    HttpURLConnection enConnection = openConnection(url);
+    HttpURLConnection enConnection = client.open(url);
     enConnection.addRequestProperty("Accept-Language", "en-US");
     assertEquals("B", readAscii(enConnection));
   }
@@ -1358,13 +1249,12 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
+    URLConnection connection1 = client.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = openConnection(url);
+    URLConnection connection2 = client.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(connection2));
   }
@@ -1374,10 +1264,9 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Foo")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
   }
 
   @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
@@ -1385,10 +1274,9 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Foo")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection fooConnection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    URLConnection fooConnection = client.open(server.getUrl("/"));
     fooConnection.addRequestProperty("Foo", "bar");
     assertEquals("B", readAscii(fooConnection));
   }
@@ -1398,12 +1286,11 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Foo")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
-    URLConnection fooConnection = openConnection(server.getUrl("/"));
+    URLConnection fooConnection = client.open(server.getUrl("/"));
     fooConnection.addRequestProperty("Foo", "bar");
     assertEquals("A", readAscii(fooConnection));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
   }
 
   @Test public void varyFieldsAreCaseInsensitive() throws Exception {
@@ -1411,13 +1298,12 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: ACCEPT-LANGUAGE")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
+    URLConnection connection1 = client.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA");
     assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = openConnection(url);
+    URLConnection connection2 = client.open(url);
     connection2.addRequestProperty("accept-language", "fr-CA");
     assertEquals("A", readAscii(connection2));
   }
@@ -1428,15 +1314,14 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Accept-Encoding")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
+    URLConnection connection1 = client.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA");
     connection1.addRequestProperty("Accept-Charset", "UTF-8");
     connection1.addRequestProperty("Accept-Encoding", "identity");
     assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = openConnection(url);
+    URLConnection connection2 = client.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA");
     connection2.addRequestProperty("Accept-Charset", "UTF-8");
     connection2.addRequestProperty("Accept-Encoding", "identity");
@@ -1449,15 +1334,14 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Accept-Encoding")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection frConnection = openConnection(url);
+    URLConnection frConnection = client.open(url);
     frConnection.addRequestProperty("Accept-Language", "fr-CA");
     frConnection.addRequestProperty("Accept-Charset", "UTF-8");
     frConnection.addRequestProperty("Accept-Encoding", "identity");
     assertEquals("A", readAscii(frConnection));
-    URLConnection enConnection = openConnection(url);
+    URLConnection enConnection = client.open(url);
     enConnection.addRequestProperty("Accept-Language", "en-CA");
     enConnection.addRequestProperty("Accept-Charset", "UTF-8");
     enConnection.addRequestProperty("Accept-Encoding", "identity");
@@ -1469,15 +1353,14 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
+    URLConnection connection1 = client.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
-    URLConnection connection2 = openConnection(url);
+    URLConnection connection2 = client.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
     connection2.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection2));
@@ -1488,15 +1371,14 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    URLConnection connection1 = openConnection(url);
+    URLConnection connection1 = client.open(url);
     connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
-    URLConnection connection2 = openConnection(url);
+    URLConnection connection2 = client.open(url);
     connection2.addRequestProperty("Accept-Language", "fr-CA");
     connection2.addRequestProperty("Accept-Language", "en-US");
     assertEquals("B", readAscii(connection2));
@@ -1507,10 +1389,9 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: *")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("B", readAscii(client.open(server.getUrl("/"))));
   }
 
   @Test public void varyAndHttps() throws Exception {
@@ -1519,7 +1400,6 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
     HttpsURLConnection connection1 = (HttpsURLConnection) client.open(url);
@@ -1544,12 +1424,11 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
     server.enqueue(new MockResponse().addHeader(
         "Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
     URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
     assertCookies(url, "a=FIRST");
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
     assertCookies(url, "a=SECOND");
   }
 
@@ -1560,13 +1439,12 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .setBody("A"));
     server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD, PUT")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
-    URLConnection connection1 = openConnection(server.getUrl("/"));
+    URLConnection connection1 = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection1));
     assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
 
-    URLConnection connection2 = openConnection(server.getUrl("/"));
+    URLConnection connection2 = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection2));
     assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
   }
@@ -1578,13 +1456,12 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .setBody("A"));
     server.enqueue(new MockResponse().addHeader("Transfer-Encoding: none")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
-    URLConnection connection1 = openConnection(server.getUrl("/"));
+    URLConnection connection1 = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection1));
     assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
 
-    URLConnection connection2 = openConnection(server.getUrl("/"));
+    URLConnection connection2 = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection2));
     assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
   }
@@ -1595,13 +1472,12 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
-    URLConnection connection1 = openConnection(server.getUrl("/"));
+    URLConnection connection1 = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection1));
     assertEquals("199 test danger", connection1.getHeaderField("Warning"));
 
-    URLConnection connection2 = openConnection(server.getUrl("/"));
+    URLConnection connection2 = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection2));
     assertEquals(null, connection2.getHeaderField("Warning"));
   }
@@ -1612,19 +1488,18 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
         .addHeader("Cache-Control: max-age=0")
         .setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
-    URLConnection connection1 = openConnection(server.getUrl("/"));
+    URLConnection connection1 = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection1));
     assertEquals("299 test danger", connection1.getHeaderField("Warning"));
 
-    URLConnection connection2 = openConnection(server.getUrl("/"));
+    URLConnection connection2 = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection2));
     assertEquals("299 test danger", connection2.getHeaderField("Warning"));
   }
 
   public void assertCookies(URL url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<String>();
+    List<String> actualCookies = new ArrayList<>();
     for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
       actualCookies.add(cookie.toString());
     }
@@ -1646,21 +1521,20 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Allow: GET, HEAD")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     // cache miss; seed the cache
-    HttpURLConnection connection1 = openConnection(server.getUrl("/a"));
+    HttpURLConnection connection1 = client.open(server.getUrl("/a"));
     assertEquals("A", readAscii(connection1));
     assertEquals(null, connection1.getHeaderField("Allow"));
 
     // conditional cache hit; update the cache
-    HttpURLConnection connection2 = openConnection(server.getUrl("/a"));
+    HttpURLConnection connection2 = client.open(server.getUrl("/a"));
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertEquals("A", readAscii(connection2));
     assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
 
     // full cache hit
-    HttpURLConnection connection3 = openConnection(server.getUrl("/a"));
+    HttpURLConnection connection3 = client.open(server.getUrl("/a"));
     assertEquals("A", readAscii(connection3));
     assertEquals("GET, HEAD", connection3.getHeaderField("Allow"));
 
@@ -1671,15 +1545,11 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse().setBody("A")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    URLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(ResponseHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CACHE.toString() + " 200", source);
   }
 
   @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
@@ -1689,14 +1559,10 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse().setBody("B")
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
     assertEquals("B", readAscii(connection));
-
-    String source = connection.getHeaderField(ResponseHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CONDITIONAL_CACHE.toString() + " 200", source);
   }
 
   @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
@@ -1704,25 +1570,17 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Cache-Control: max-age=0")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
     server.enqueue(new MockResponse().setResponseCode(304));
-    server.play();
 
-    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
-    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(client.open(server.getUrl("/"))));
+    HttpURLConnection connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(ResponseHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CONDITIONAL_CACHE.toString() + " 304", source);
   }
 
   @Test public void responseSourceHeaderFetched() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
-    server.play();
 
-    URLConnection connection = openConnection(server.getUrl("/"));
+    URLConnection connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(ResponseHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.NETWORK.toString() + " 200", source);
   }
 
   @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
@@ -1730,7 +1588,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
         .addHeader("Cache-Control: max-age=120")
         .addHeader(": A")
         .setBody("body"));
-    server.play();
+
     HttpURLConnection connection = client.open(server.getUrl("/"));
     assertEquals("A", connection.getHeaderField(""));
   }
@@ -1748,10 +1606,9 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     server.enqueue(new MockResponse()
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
 
     URL url = server.getUrl("/");
-    String urlKey = Util.hash(url.toString());
+    String urlKey = Util.md5Hex(url.toString());
     String entryMetadata = ""
         + "" + url + "\n"
         + "GET\n"
@@ -1787,8 +1644,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     writeFile(cache.getDirectory(), urlKey + ".0", entryMetadata);
     writeFile(cache.getDirectory(), urlKey + ".1", entryBody);
     writeFile(cache.getDirectory(), "journal", journalBody);
-    cache = new HttpResponseCache(cache.getDirectory(), Integer.MAX_VALUE);
-    client.setResponseCache(cache);
+    cache = new Cache(cache.getDirectory(), Integer.MAX_VALUE);
+    client.client().setCache(cache);
 
     HttpURLConnection connection = client.open(url);
     assertEquals(entryBody, readAscii(connection));
@@ -1797,9 +1654,9 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
   }
 
   private void writeFile(File directory, String file, String content) throws IOException {
-    OutputStream out = new FileOutputStream(new File(directory, file));
-    out.write(content.getBytes(Util.UTF_8));
-    out.close();
+    BufferedSink sink = Okio.buffer(Okio.sink(new File(directory, file)));
+    sink.writeUtf8(content);
+    sink.close();
   }
 
   /**
@@ -1813,7 +1670,7 @@ private String formatDate(long delta, TimeUnit timeUnit) {
 
   private String formatDate(Date date) {
     DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone("UTC"));
+    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
     return rfc1123.format(date);
   }
 
@@ -1830,11 +1687,10 @@ private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection i
   private void assertNotCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(new MockResponse().setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("B", readAscii(client.open(url)));
   }
 
   /** @return the request with the conditional get headers. */
@@ -1847,24 +1703,22 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
 
-    server.play();
-
     URL valid = server.getUrl("/valid");
-    HttpURLConnection connection1 = openConnection(valid);
+    HttpURLConnection connection1 = client.open(valid);
     assertEquals("A", readAscii(connection1));
     assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
     assertEquals("A-OK", connection1.getResponseMessage());
-    HttpURLConnection connection2 = openConnection(valid);
+    HttpURLConnection connection2 = client.open(valid);
     assertEquals("A", readAscii(connection2));
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertEquals("A-OK", connection2.getResponseMessage());
 
     URL invalid = server.getUrl("/invalid");
-    HttpURLConnection connection3 = openConnection(invalid);
+    HttpURLConnection connection3 = client.open(invalid);
     assertEquals("B", readAscii(connection3));
     assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
     assertEquals("B-OK", connection3.getResponseMessage());
-    HttpURLConnection connection4 = openConnection(invalid);
+    HttpURLConnection connection4 = client.open(invalid);
     assertEquals("C", readAscii(connection4));
     assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
     assertEquals("C-OK", connection4.getResponseMessage());
@@ -1876,11 +1730,10 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
   private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(response.setBody("B"));
-    server.play();
 
     URL url = server.getUrl("/");
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(client.open(url)));
+    assertEquals("A", readAscii(client.open(url)));
   }
 
   /**
@@ -1890,8 +1743,10 @@ private void assertFullyCached(MockResponse response) throws Exception {
    */
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
     response.setSocketPolicy(DISCONNECT_AT_END);
-    List<String> headers = new ArrayList<String>(response.getHeaders());
-    response.setBody(Arrays.copyOfRange(response.getBody(), 0, numBytesToKeep));
+    List<String> headers = new ArrayList<>(response.getHeaders());
+    Buffer truncatedBody = new Buffer();
+    truncatedBody.write(response.getBody(), numBytesToKeep);
+    response.setBody(truncatedBody);
     response.getHeaders().clear();
     response.getHeaders().addAll(headers);
     return response;
@@ -1905,7 +1760,8 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
   private String readAscii(URLConnection connection, int count) throws IOException {
     HttpURLConnection httpConnection = (HttpURLConnection) connection;
     InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
-        ? connection.getInputStream() : httpConnection.getErrorStream();
+        ? connection.getInputStream()
+        : httpConnection.getErrorStream();
     StringBuilder result = new StringBuilder();
     for (int i = 0; i < count; i++) {
       int value = in.read();
@@ -1940,18 +1796,18 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize)
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
           throws IOException {
         response.setChunkedBody(content, chunkSize);
       }
     },
     FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
       }
     },
     END_OF_STREAM() {
-      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
         response.setSocketPolicy(DISCONNECT_AT_END);
         for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
@@ -1963,10 +1819,10 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
       }
     };
 
-    abstract void setBody(MockResponse response, byte[] content, int chunkSize) throws IOException;
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
 
     void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, content.getBytes("UTF-8"), chunkSize);
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
     }
   }
 
@@ -1975,33 +1831,11 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
   }
 
   /** Returns a gzipped copy of {@code bytes}. */
-  public byte[] gzip(byte[] bytes) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
-    gzippedOut.write(bytes);
-    gzippedOut.close();
-    return bytesOut.toByteArray();
-  }
-
-  private class InsecureResponseCache extends ResponseCache {
-    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-      return cache.put(uri, connection);
-    }
-
-    @Override public CacheResponse get(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) throws IOException {
-      final CacheResponse response = cache.get(uri, requestMethod, requestHeaders);
-      if (response instanceof SecureCacheResponse) {
-        return new CacheResponse() {
-          @Override public InputStream getBody() throws IOException {
-            return response.getBody();
-          }
-          @Override public Map<String, List<String>> getHeaders() throws IOException {
-            return response.getHeaders();
-          }
-        };
-      }
-      return response;
-    }
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
   }
 }
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
new file mode 100644
index 0000000000..270fb837ee
--- /dev/null
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
@@ -0,0 +1,267 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.huc;
+
+import com.squareup.okhttp.AbstractResponseCache;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import java.io.IOException;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.HttpURLConnection;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * A white-box test for {@link CacheAdapter}. See also:
+ * <ul>
+ *   <li>{@link ResponseCacheTest} for black-box tests that check that {@link ResponseCache}
+ *   classes are called correctly by OkHttp.</li>
+ *   <li>{@link JavaApiConverterTest} for tests that check Java API classes / OkHttp conversion
+ *   logic. </li>
+ * </ul>
+ */
+public class CacheAdapterTest {
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
+    public boolean verify(String hostname, SSLSession session) {
+      return true;
+    }
+  };
+
+  private MockWebServer server;
+
+  private OkHttpClient client;
+
+  private HttpURLConnection connection;
+
+  @Before public void setUp() throws Exception {
+    server = new MockWebServer();
+    client = new OkHttpClient();
+  }
+
+  @After public void tearDown() throws Exception {
+    if (connection != null) {
+      connection.disconnect();
+    }
+    server.shutdown();
+  }
+
+  @Test public void get_httpGet() throws Exception {
+    final URL serverUrl = configureServer(new MockResponse());
+    assertEquals("http", serverUrl.getProtocol());
+
+    ResponseCache responseCache = new AbstractResponseCache() {
+      @Override
+      public CacheResponse get(URI uri, String method, Map<String, List<String>> headers) throws IOException {
+        assertEquals(toUri(serverUrl), uri);
+        assertEquals("GET", method);
+        assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
+        assertEquals(Collections.singletonList("value1"), headers.get("key1"));
+        return null;
+      }
+    };
+    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+
+    connection = new OkUrlFactory(client).open(serverUrl);
+    connection.setRequestProperty("key1", "value1");
+
+    executeGet(connection);
+  }
+
+  @Test public void get_httpsGet() throws Exception {
+    final URL serverUrl = configureHttpsServer(new MockResponse());
+    assertEquals("https", serverUrl.getProtocol());
+
+    ResponseCache responseCache = new AbstractResponseCache() {
+      @Override public CacheResponse get(URI uri, String method, Map<String, List<String>> headers)
+          throws IOException {
+        assertEquals("https", uri.getScheme());
+        assertEquals(toUri(serverUrl), uri);
+        assertEquals("GET", method);
+        assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
+        assertEquals(Collections.singletonList("value1"), headers.get("key1"));
+        return null;
+      }
+    };
+    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    connection = new OkUrlFactory(client).open(serverUrl);
+    connection.setRequestProperty("key1", "value1");
+
+    executeGet(connection);
+  }
+
+  @Test public void put_httpGet() throws Exception {
+    final String statusLine = "HTTP/1.1 200 Fantastic";
+    final URL serverUrl = configureServer(
+        new MockResponse()
+            .setStatus(statusLine)
+            .addHeader("A", "c"));
+
+    ResponseCache responseCache = new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+        assertTrue(connection instanceof HttpURLConnection);
+        assertFalse(connection instanceof HttpsURLConnection);
+
+        assertEquals(0, connection.getContentLength());
+
+        HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
+        assertEquals("GET", httpUrlConnection.getRequestMethod());
+        assertTrue(httpUrlConnection.getDoInput());
+        assertFalse(httpUrlConnection.getDoOutput());
+
+        assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
+        assertEquals(toUri(serverUrl), uri);
+        assertEquals(serverUrl, connection.getURL());
+        assertEquals("value", connection.getRequestProperty("key"));
+
+        // Check retrieval by string key.
+        assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
+        assertEquals("c", httpUrlConnection.getHeaderField("A"));
+        // The RI and OkHttp supports case-insensitive matching for this method.
+        assertEquals("c", httpUrlConnection.getHeaderField("a"));
+        return null;
+      }
+    };
+    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+
+    connection = new OkUrlFactory(client).open(serverUrl);
+    connection.setRequestProperty("key", "value");
+    executeGet(connection);
+  }
+
+  @Test public void put_httpPost() throws Exception {
+    final String statusLine = "HTTP/1.1 200 Fantastic";
+    final URL serverUrl = configureServer(
+        new MockResponse()
+            .setStatus(statusLine)
+            .addHeader("A", "c"));
+
+    ResponseCache responseCache = new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+        assertTrue(connection instanceof HttpURLConnection);
+        assertFalse(connection instanceof HttpsURLConnection);
+
+        assertEquals(0, connection.getContentLength());
+
+        HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
+        assertEquals("POST", httpUrlConnection.getRequestMethod());
+        assertTrue(httpUrlConnection.getDoInput());
+        assertTrue(httpUrlConnection.getDoOutput());
+
+        assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
+        assertEquals(toUri(serverUrl), uri);
+        assertEquals(serverUrl, connection.getURL());
+        assertEquals("value", connection.getRequestProperty("key"));
+
+        // Check retrieval by string key.
+        assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
+        assertEquals("c", httpUrlConnection.getHeaderField("A"));
+        // The RI and OkHttp supports case-insensitive matching for this method.
+        assertEquals("c", httpUrlConnection.getHeaderField("a"));
+        return null;
+      }
+    };
+    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+
+    connection = new OkUrlFactory(client).open(serverUrl);
+
+    executePost(connection);
+  }
+
+  @Test public void put_httpsGet() throws Exception {
+    final URL serverUrl = configureHttpsServer(new MockResponse());
+    assertEquals("https", serverUrl.getProtocol());
+
+    ResponseCache responseCache = new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+        assertTrue(connection instanceof HttpsURLConnection);
+        assertEquals(toUri(serverUrl), uri);
+        assertEquals(serverUrl, connection.getURL());
+
+        HttpsURLConnection cacheHttpsUrlConnection = (HttpsURLConnection) connection;
+        HttpsURLConnection realHttpsUrlConnection = (HttpsURLConnection) CacheAdapterTest.this.connection;
+        assertEquals(realHttpsUrlConnection.getCipherSuite(),
+            cacheHttpsUrlConnection.getCipherSuite());
+        assertEquals(realHttpsUrlConnection.getPeerPrincipal(),
+            cacheHttpsUrlConnection.getPeerPrincipal());
+        assertArrayEquals(realHttpsUrlConnection.getLocalCertificates(),
+            cacheHttpsUrlConnection.getLocalCertificates());
+        assertArrayEquals(realHttpsUrlConnection.getServerCertificates(),
+            cacheHttpsUrlConnection.getServerCertificates());
+        assertEquals(realHttpsUrlConnection.getLocalPrincipal(),
+            cacheHttpsUrlConnection.getLocalPrincipal());
+        return null;
+      }
+    };
+    Internal.instance.setCache(client, new CacheAdapter(responseCache));
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    connection = new OkUrlFactory(client).open(serverUrl);
+    executeGet(connection);
+  }
+
+  private void executeGet(HttpURLConnection connection) throws IOException {
+    connection.connect();
+    connection.getHeaderFields();
+    connection.disconnect();
+  }
+
+  private void executePost(HttpURLConnection connection) throws IOException {
+    connection.setDoOutput(true);
+    connection.connect();
+    connection.getOutputStream().write("Hello World".getBytes());
+    connection.disconnect();
+  }
+
+  private URL configureServer(MockResponse mockResponse) throws Exception {
+    server.enqueue(mockResponse);
+    server.play();
+    return server.getUrl("/");
+  }
+
+  private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false /* tunnelProxy */);
+    server.enqueue(mockResponse);
+    server.play();
+    return server.getUrl("/");
+  }
+}
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
new file mode 100644
index 0000000000..92fb7afd61
--- /dev/null
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
@@ -0,0 +1,786 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.huc;
+
+import com.squareup.okhttp.Handshake;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.CacheResponse;
+import java.net.HttpURLConnection;
+import java.net.SecureCacheResponse;
+import java.net.URI;
+import java.net.URL;
+import java.nio.charset.StandardCharsets;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import okio.Buffer;
+import okio.BufferedSource;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class JavaApiConverterTest {
+
+  // $ openssl req -x509 -nodes -days 36500 -subj '/CN=localhost' -config ./cert.cnf \
+  //     -newkey rsa:512 -out cert.pem
+  private static final X509Certificate LOCAL_CERT = certificate(""
+      + "-----BEGIN CERTIFICATE-----\n"
+      + "MIIBWDCCAQKgAwIBAgIJANS1EtICX2AZMA0GCSqGSIb3DQEBBQUAMBQxEjAQBgNV\n"
+      + "BAMTCWxvY2FsaG9zdDAgFw0xMjAxMDIxOTA4NThaGA8yMTExMTIwOTE5MDg1OFow\n"
+      + "FDESMBAGA1UEAxMJbG9jYWxob3N0MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAPpt\n"
+      + "atK8r4/hf4hSIs0os/BSlQLbRBaK9AfBReM4QdAklcQqe6CHsStKfI8pp0zs7Ptg\n"
+      + "PmMdpbttL0O7mUboBC8CAwEAAaM1MDMwMQYDVR0RBCowKIIVbG9jYWxob3N0Lmxv\n"
+      + "Y2FsZG9tYWlugglsb2NhbGhvc3SHBH8AAAEwDQYJKoZIhvcNAQEFBQADQQD0ntfL\n"
+      + "DCzOCv9Ma6Lv5o5jcYWVxvBSTsnt22hsJpWD1K7iY9lbkLwl0ivn73pG2evsAn9G\n"
+      + "X8YKH52fnHsCrhSD\n"
+      + "-----END CERTIFICATE-----");
+
+  // openssl req -x509 -nodes -days 36500 -subj '/CN=*.0.0.1' -newkey rsa:512 -out cert.pem
+  private static final X509Certificate SERVER_CERT = certificate(""
+      + "-----BEGIN CERTIFICATE-----\n"
+      + "MIIBkjCCATygAwIBAgIJAMdemqOwd/BEMA0GCSqGSIb3DQEBBQUAMBIxEDAOBgNV\n"
+      + "BAMUByouMC4wLjEwIBcNMTAxMjIwMTY0NDI1WhgPMjExMDExMjYxNjQ0MjVaMBIx\n"
+      + "EDAOBgNVBAMUByouMC4wLjEwXDANBgkqhkiG9w0BAQEFAANLADBIAkEAqY8c9Qrt\n"
+      + "YPWCvb7lclI+aDHM6fgbJcHsS9Zg8nUOh5dWrS7AgeA25wyaokFl4plBbbHQe2j+\n"
+      + "cCjsRiJIcQo9HwIDAQABo3MwcTAdBgNVHQ4EFgQUJ436TZPJvwCBKklZZqIvt1Yt\n"
+      + "JjEwQgYDVR0jBDswOYAUJ436TZPJvwCBKklZZqIvt1YtJjGhFqQUMBIxEDAOBgNV\n"
+      + "BAMUByouMC4wLjGCCQDHXpqjsHfwRDAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEB\n"
+      + "BQUAA0EAk9i88xdjWoewqvE+iMC9tD2obMchgFDaHH0ogxxiRaIKeEly3g0uGxIt\n"
+      + "fl2WRY8hb4x+zRrwsFaLEpdEvqcjOQ==\n"
+      + "-----END CERTIFICATE-----");
+
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
+    public boolean verify(String hostname, SSLSession session) {
+      return true;
+    }
+  };
+
+  @Rule public MockWebServerRule server = new MockWebServerRule();
+
+  private OkHttpClient client;
+
+  private HttpURLConnection connection;
+
+  @Before public void setUp() throws Exception {
+    client = new OkHttpClient();
+  }
+
+  @After public void tearDown() throws Exception {
+    if (connection != null) {
+      connection.disconnect();
+    }
+  }
+
+  @Test public void createOkResponse_fromOkHttpUrlConnection() throws Exception {
+    testCreateOkResponseInternal(new OkHttpURLConnectionFactory(client), false /* isSecure */);
+  }
+
+  @Test public void createOkResponse_fromJavaHttpUrlConnection() throws Exception {
+    testCreateOkResponseInternal(new JavaHttpURLConnectionFactory(), false /* isSecure */);
+  }
+
+  @Test public void createOkResponse_fromOkHttpsUrlConnection() throws Exception {
+    testCreateOkResponseInternal(new OkHttpURLConnectionFactory(client), true /* isSecure */);
+  }
+
+  @Test public void createOkResponse_fromJavaHttpsUrlConnection() throws Exception {
+    testCreateOkResponseInternal(new JavaHttpURLConnectionFactory(), true /* isSecure */);
+  }
+
+  private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnectionFactory,
+      boolean isSecure) throws Exception {
+    String statusLine = "HTTP/1.1 200 Fantastic";
+    String body = "Nothing happens";
+    final URL serverUrl;
+    MockResponse mockResponse = new MockResponse()
+        .setStatus(statusLine)
+        .addHeader("xyzzy", "baz")
+        .setBody(body);
+    if (isSecure) {
+      serverUrl = configureHttpsServer(
+          mockResponse);
+
+      assertEquals("https", serverUrl.getProtocol());
+    } else {
+      serverUrl = configureServer(
+          mockResponse);
+      assertEquals("http", serverUrl.getProtocol());
+    }
+
+    connection = httpUrlConnectionFactory.open(serverUrl);
+    if (isSecure) {
+      HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) connection;
+      httpsUrlConnection.setSSLSocketFactory(sslContext.getSocketFactory());
+      httpsUrlConnection.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    }
+    connection.setRequestProperty("snake", "bird");
+    connection.connect();
+    Response response = JavaApiConverter.createOkResponse(serverUrl.toURI(), connection);
+
+    // Check the response.request()
+    Request request = response.request();
+    assertEquals(isSecure, request.isHttps());
+    assertEquals(serverUrl.toURI(), request.uri());
+    assertNull(request.body());
+    Headers okRequestHeaders = request.headers();
+    // In Java the request headers are unavailable for a connected HttpURLConnection.
+    assertEquals(0, okRequestHeaders.size());
+    assertEquals("GET", request.method());
+
+    // Check the response
+    assertEquals(Protocol.HTTP_1_1, response.protocol());
+    assertEquals(200, response.code());
+    assertEquals("Fantastic", response.message());
+    Headers okResponseHeaders = response.headers();
+    assertEquals("baz", okResponseHeaders.get("xyzzy"));
+    if (isSecure) {
+      Handshake handshake = response.handshake();
+      assertNotNull(handshake);
+      HttpsURLConnection httpsURLConnection = (HttpsURLConnection) connection;
+      assertNotNullAndEquals(httpsURLConnection.getCipherSuite(), handshake.cipherSuite());
+      assertEquals(httpsURLConnection.getLocalPrincipal(), handshake.localPrincipal());
+      assertNotNullAndEquals(httpsURLConnection.getPeerPrincipal(), handshake.peerPrincipal());
+      assertNotNull(httpsURLConnection.getServerCertificates());
+      assertEquals(Arrays.asList(httpsURLConnection.getServerCertificates()),
+          handshake.peerCertificates());
+      assertNull(httpsURLConnection.getLocalCertificates());
+    } else {
+      assertNull(response.handshake());
+    }
+    assertEquals(body, response.body().string());
+  }
+
+  @Test public void createOkResponse_fromCacheResponse() throws Exception {
+    final String statusLine = "HTTP/1.1 200 Fantastic";
+    URI uri = new URI("http://foo/bar");
+    Request request = new Request.Builder().url(uri.toURL()).build();
+    CacheResponse cacheResponse = new CacheResponse() {
+      @Override public Map<String, List<String>> getHeaders() throws IOException {
+        Map<String, List<String>> headers = new HashMap<>();
+        headers.put(null, Collections.singletonList(statusLine));
+        headers.put("xyzzy", Arrays.asList("bar", "baz"));
+        return headers;
+      }
+
+      @Override public InputStream getBody() throws IOException {
+        return new ByteArrayInputStream("HelloWorld".getBytes(StandardCharsets.UTF_8));
+      }
+    };
+
+    Response response = JavaApiConverter.createOkResponse(request, cacheResponse);
+    assertSame(request, response.request());
+
+    assertEquals(Protocol.HTTP_1_1, response.protocol());
+    assertEquals(200, response.code());
+    assertEquals("Fantastic", response.message());
+    Headers okResponseHeaders = response.headers();
+    assertEquals("baz", okResponseHeaders.get("xyzzy"));
+    assertEquals("HelloWorld", response.body().string());
+    assertNull(response.handshake());
+  }
+
+  @Test public void createOkResponse_fromSecureCacheResponse() throws Exception {
+    final String statusLine = "HTTP/1.1 200 Fantastic";
+    final Principal localPrincipal = LOCAL_CERT.getSubjectX500Principal();
+    final List<Certificate> localCertificates = Arrays.<Certificate>asList(LOCAL_CERT);
+    final Principal serverPrincipal = SERVER_CERT.getSubjectX500Principal();
+    final List<Certificate> serverCertificates = Arrays.<Certificate>asList(SERVER_CERT);
+    URI uri = new URI("https://foo/bar");
+    Request request = new Request.Builder().url(uri.toURL()).build();
+    SecureCacheResponse cacheResponse = new SecureCacheResponse() {
+      @Override public Map<String, List<String>> getHeaders() throws IOException {
+        Map<String, List<String>> headers = new HashMap<>();
+        headers.put(null, Collections.singletonList(statusLine));
+        headers.put("xyzzy", Arrays.asList("bar", "baz"));
+        return headers;
+      }
+
+      @Override public InputStream getBody() throws IOException {
+        return new ByteArrayInputStream("HelloWorld".getBytes(StandardCharsets.UTF_8));
+      }
+
+      @Override public String getCipherSuite() {
+        return "SuperSecure";
+      }
+
+      @Override public List<Certificate> getLocalCertificateChain() {
+        return localCertificates;
+      }
+
+      @Override public List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException {
+        return serverCertificates;
+      }
+
+      @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+        return serverPrincipal;
+      }
+
+      @Override public Principal getLocalPrincipal() {
+        return localPrincipal;
+      }
+    };
+
+    Response response = JavaApiConverter.createOkResponse(request, cacheResponse);
+    assertSame(request, response.request());
+
+    assertEquals(Protocol.HTTP_1_1, response.protocol());
+    assertEquals(200, response.code());
+    assertEquals("Fantastic", response.message());
+    Headers okResponseHeaders = response.headers();
+    assertEquals("baz", okResponseHeaders.get("xyzzy"));
+    assertEquals("HelloWorld", response.body().string());
+
+    Handshake handshake = response.handshake();
+    assertNotNull(handshake);
+    assertNotNullAndEquals("SuperSecure", handshake.cipherSuite());
+    assertEquals(localPrincipal, handshake.localPrincipal());
+    assertEquals(serverPrincipal, handshake.peerPrincipal());
+    assertEquals(serverCertificates, handshake.peerCertificates());
+    assertEquals(localCertificates, handshake.localCertificates());
+  }
+
+  @Test public void createOkRequest_nullRequestHeaders() throws Exception {
+    URI uri = new URI("http://foo/bar");
+
+    Map<String,List<String>> javaRequestHeaders = null;
+    Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
+    assertFalse(request.isHttps());
+    assertEquals(uri, request.uri());
+    Headers okRequestHeaders = request.headers();
+    assertEquals(0, okRequestHeaders.size());
+    assertEquals("POST", request.method());
+  }
+
+  @Test public void createOkRequest_nonNullRequestHeaders() throws Exception {
+    URI uri = new URI("https://foo/bar");
+
+    Map<String,List<String>> javaRequestHeaders = new HashMap<>();
+    javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
+    Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
+    assertTrue(request.isHttps());
+    assertEquals(uri, request.uri());
+    Headers okRequestHeaders = request.headers();
+    assertEquals(1, okRequestHeaders.size());
+    assertEquals("Bar", okRequestHeaders.get("Foo"));
+    assertEquals("POST", request.method());
+  }
+
+  // Older versions of OkHttp would store the "request line" as a header with a
+  // null key. To support the Android usecase where an old version of OkHttp uses
+  // a newer, Android-bundled, version of HttpResponseCache the null key must be
+  // explicitly ignored.
+  @Test public void createOkRequest_nullRequestHeaderKey() throws Exception {
+    URI uri = new URI("https://foo/bar");
+
+    Map<String,List<String>> javaRequestHeaders = new HashMap<>();
+    javaRequestHeaders.put(null, Arrays.asList("GET / HTTP 1.1"));
+    javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
+    Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
+    assertTrue(request.isHttps());
+    assertEquals(uri, request.uri());
+    Headers okRequestHeaders = request.headers();
+    assertEquals(1, okRequestHeaders.size());
+    assertEquals("Bar", okRequestHeaders.get("Foo"));
+    assertEquals("POST", request.method());
+  }
+
+  @Test public void createJavaUrlConnection_requestChangesForbidden() throws Exception {
+    Response okResponse = createArbitraryOkResponse();
+    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    // Check an arbitrary (not complete) set of methods that can be used to modify the
+    // request.
+    try {
+      httpUrlConnection.setRequestProperty("key", "value");
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.setFixedLengthStreamingMode(1234);
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.setRequestMethod("PUT");
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.getHeaderFields().put("key", Collections.singletonList("value"));
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.getOutputStream();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  @Test public void createJavaUrlConnection_connectionChangesForbidden() throws Exception {
+    Response okResponse = createArbitraryOkResponse();
+    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    try {
+      httpUrlConnection.connect();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.disconnect();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  @Test public void createJavaUrlConnection_responseChangesForbidden() throws Exception {
+    Response okResponse = createArbitraryOkResponse();
+    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    // Check an arbitrary (not complete) set of methods that can be used to access the response
+    // body.
+    try {
+      httpUrlConnection.getInputStream();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.getContent();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.setFixedLengthStreamingMode(1234);
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.setRequestMethod("PUT");
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpUrlConnection.getHeaderFields().put("key", Collections.singletonList("value"));
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  @Test public void createJavaUrlConnection_responseHeadersOk() throws Exception {
+    ResponseBody responseBody = createResponseBody("BodyText");
+    Response okResponse = new Response.Builder()
+        .request(createArbitraryOkRequest())
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Fantastic")
+        .addHeader("A", "c")
+        .addHeader("B", "d")
+        .addHeader("A", "e")
+        .addHeader("Content-Length", Long.toString(responseBody.contentLength()))
+        .body(responseBody)
+        .build();
+
+    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+    assertEquals(200, httpUrlConnection.getResponseCode());
+    assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
+    assertEquals(responseBody.contentLength(), httpUrlConnection.getContentLength());
+
+    // Check retrieval by string key.
+    assertEquals("HTTP/1.1 200 Fantastic", httpUrlConnection.getHeaderField(null));
+    assertEquals("e", httpUrlConnection.getHeaderField("A"));
+    // The RI and OkHttp supports case-insensitive matching for this method.
+    assertEquals("e", httpUrlConnection.getHeaderField("a"));
+
+    // Check retrieval using a Map.
+    Map<String, List<String>> responseHeaders = httpUrlConnection.getHeaderFields();
+    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), responseHeaders.get(null));
+    assertEquals(newSet("c", "e"), newSet(responseHeaders.get("A")));
+    // OkHttp supports case-insensitive matching here. The RI does not.
+    assertEquals(newSet("c", "e"), newSet(responseHeaders.get("a")));
+
+    // Check the Map iterator contains the expected mappings.
+    assertHeadersContainsMapping(responseHeaders, null, "HTTP/1.1 200 Fantastic");
+    assertHeadersContainsMapping(responseHeaders, "A", "c", "e");
+    assertHeadersContainsMapping(responseHeaders, "B", "d");
+
+    // Check immutability of the headers Map.
+    try {
+      responseHeaders.put("N", Arrays.asList("o"));
+      fail("Modified an unmodifiable view.");
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      responseHeaders.get("A").add("f");
+      fail("Modified an unmodifiable view.");
+    } catch (UnsupportedOperationException expected) {
+    }
+
+    // Check retrieval of headers by index.
+    assertEquals(null, httpUrlConnection.getHeaderFieldKey(0));
+    assertEquals("HTTP/1.1 200 Fantastic", httpUrlConnection.getHeaderField(0));
+    // After header zero there may be additional entries provided at the beginning or end by the
+    // implementation. It's probably important that the relative ordering of the headers is
+    // preserved, particularly if there are multiple value for the same key.
+    int i = 1;
+    while (!httpUrlConnection.getHeaderFieldKey(i).equals("A")) {
+      i++;
+    }
+    // Check the ordering of the headers set by app code.
+    assertResponseHeaderAtIndex(httpUrlConnection, i++, "A", "c");
+    assertResponseHeaderAtIndex(httpUrlConnection, i++, "B", "d");
+    assertResponseHeaderAtIndex(httpUrlConnection, i++, "A", "e");
+    // There may be some additional headers provided by the implementation.
+    while (httpUrlConnection.getHeaderField(i) != null) {
+      assertNotNull(httpUrlConnection.getHeaderFieldKey(i));
+      i++;
+    }
+    // Confirm the correct behavior when the index is out-of-range.
+    assertNull(httpUrlConnection.getHeaderFieldKey(i));
+  }
+
+  private static void assertResponseHeaderAtIndex(HttpURLConnection httpUrlConnection,
+      int headerIndex, String expectedKey, String expectedValue) {
+    assertEquals(expectedKey, httpUrlConnection.getHeaderFieldKey(headerIndex));
+    assertEquals(expectedValue, httpUrlConnection.getHeaderField(headerIndex));
+  }
+
+  private void assertHeadersContainsMapping(Map<String, List<String>> headers, String expectedKey,
+      String... expectedValues) {
+    assertTrue(headers.containsKey(expectedKey));
+    assertEquals(newSet(expectedValues), newSet(headers.get(expectedKey)));
+  }
+
+  @Test public void createJavaUrlConnection_accessibleRequestInfo_GET() throws Exception {
+    Request okRequest = createArbitraryOkRequest().newBuilder()
+        .get()
+        .build();
+    Response okResponse = createArbitraryOkResponse(okRequest);
+    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+
+    assertEquals("GET", httpUrlConnection.getRequestMethod());
+    assertTrue(httpUrlConnection.getDoInput());
+    assertFalse(httpUrlConnection.getDoOutput());
+  }
+
+  @Test public void createJavaUrlConnection_accessibleRequestInfo_POST() throws Exception {
+    Request okRequest = createArbitraryOkRequest().newBuilder()
+        .post(createRequestBody("PostBody"))
+        .build();
+    Response okResponse = createArbitraryOkResponse(okRequest);
+    HttpURLConnection httpUrlConnection = JavaApiConverter.createJavaUrlConnection(okResponse);
+
+    assertEquals("POST", httpUrlConnection.getRequestMethod());
+    assertTrue(httpUrlConnection.getDoInput());
+    assertTrue(httpUrlConnection.getDoOutput());
+  }
+
+  @Test public void createJavaUrlConnection_https_extraHttpsMethods() throws Exception {
+    Request okRequest = createArbitraryOkRequest().newBuilder()
+        .get()
+        .url("https://secure/request")
+        .build();
+    Handshake handshake = Handshake.get("SecureCipher", Arrays.<Certificate>asList(SERVER_CERT),
+        Arrays.<Certificate>asList(LOCAL_CERT));
+    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
+        .handshake(handshake)
+        .build();
+    HttpsURLConnection httpsUrlConnection =
+        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnection(okResponse);
+
+    assertEquals("SecureCipher", httpsUrlConnection.getCipherSuite());
+    assertEquals(SERVER_CERT.getSubjectX500Principal(), httpsUrlConnection.getPeerPrincipal());
+    assertArrayEquals(new Certificate[] { LOCAL_CERT }, httpsUrlConnection.getLocalCertificates());
+    assertArrayEquals(new Certificate[] { SERVER_CERT },
+        httpsUrlConnection.getServerCertificates());
+    assertEquals(LOCAL_CERT.getSubjectX500Principal(), httpsUrlConnection.getLocalPrincipal());
+  }
+
+  @Test public void createJavaUrlConnection_https_forbiddenFields() throws Exception {
+    Request okRequest = createArbitraryOkRequest().newBuilder()
+        .url("https://secure/request")
+        .build();
+    Response okResponse = createArbitraryOkResponse(okRequest);
+    HttpsURLConnection httpsUrlConnection =
+        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnection(okResponse);
+
+    try {
+      httpsUrlConnection.getHostnameVerifier();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+    try {
+      httpsUrlConnection.getSSLSocketFactory();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  @Test public void createJavaCacheResponse_httpGet() throws Exception {
+    Request okRequest =
+        createArbitraryOkRequest().newBuilder()
+            .url("http://insecure/request")
+            .get()
+            .build();
+    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Fantastic")
+        .addHeader("key1", "value1_1")
+        .addHeader("key2", "value2")
+        .addHeader("key1", "value1_2")
+        .body(null)
+        .build();
+    CacheResponse javaCacheResponse = JavaApiConverter.createJavaCacheResponse(okResponse);
+    assertFalse(javaCacheResponse instanceof SecureCacheResponse);
+    Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
+    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
+    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
+    assertNull(javaCacheResponse.getBody());
+  }
+
+  @Test public void createJavaCacheResponse_httpPost() throws Exception {
+    Request okRequest =
+        createArbitraryOkRequest().newBuilder()
+            .url("http://insecure/request")
+            .post(createRequestBody("RequestBody"))
+            .build();
+    ResponseBody responseBody = createResponseBody("ResponseBody");
+    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Fantastic")
+        .addHeader("key1", "value1_1")
+        .addHeader("key2", "value2")
+        .addHeader("key1", "value1_2")
+        .body(responseBody)
+        .build();
+    CacheResponse javaCacheResponse = JavaApiConverter.createJavaCacheResponse(okResponse);
+    assertFalse(javaCacheResponse instanceof SecureCacheResponse);
+    Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
+    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
+    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
+    assertEquals("ResponseBody", readAll(javaCacheResponse.getBody()));
+  }
+
+  @Test public void createJavaCacheResponse_httpsPost() throws Exception {
+    Request okRequest =
+        createArbitraryOkRequest().newBuilder()
+            .url("https://secure/request")
+            .post(createRequestBody("RequestBody") )
+            .build();
+    ResponseBody responseBody = createResponseBody("ResponseBody");
+    Handshake handshake = Handshake.get("SecureCipher", Arrays.<Certificate>asList(SERVER_CERT),
+        Arrays.<Certificate>asList(LOCAL_CERT));
+    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Fantastic")
+        .addHeader("key1", "value1_1")
+        .addHeader("key2", "value2")
+        .addHeader("key1", "value1_2")
+        .body(responseBody)
+        .handshake(handshake)
+        .build();
+    SecureCacheResponse javaCacheResponse =
+        (SecureCacheResponse) JavaApiConverter.createJavaCacheResponse(okResponse);
+    Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
+    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
+    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
+    assertEquals("ResponseBody", readAll(javaCacheResponse.getBody()));
+    assertEquals(handshake.cipherSuite(), javaCacheResponse.getCipherSuite());
+    assertEquals(handshake.localCertificates(), javaCacheResponse.getLocalCertificateChain());
+    assertEquals(handshake.peerCertificates(), javaCacheResponse.getServerCertificateChain());
+    assertEquals(handshake.localPrincipal(), javaCacheResponse.getLocalPrincipal());
+    assertEquals(handshake.peerPrincipal(), javaCacheResponse.getPeerPrincipal());
+  }
+
+  @Test public void extractJavaHeaders() throws Exception {
+    Request okRequest = createArbitraryOkRequest().newBuilder()
+        .addHeader("key1", "value1_1")
+        .addHeader("key2", "value2")
+        .addHeader("key1", "value1_2")
+        .build();
+    Map<String, List<String>> javaHeaders = JavaApiConverter.extractJavaHeaders(okRequest);
+
+    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
+    assertEquals(Arrays.asList("value2"), javaHeaders.get("key2"));
+  }
+
+  @Test public void extractOkHeaders() {
+    Map<String, List<String>> javaResponseHeaders = new HashMap<>();
+    javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
+    javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
+    javaResponseHeaders.put("key2", Arrays.asList("value2"));
+
+    Headers okHeaders = JavaApiConverter.extractOkHeaders(javaResponseHeaders);
+    assertEquals(3, okHeaders.size()); // null entry should be stripped out
+    assertEquals(Arrays.asList("value1_1", "value1_2"), okHeaders.values("key1"));
+    assertEquals(Arrays.asList("value2"), okHeaders.values("key2"));
+  }
+
+  @Test public void extractStatusLine() {
+    Map<String, List<String>> javaResponseHeaders = new HashMap<>();
+    javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
+    javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
+    javaResponseHeaders.put("key2", Arrays.asList("value2"));
+    assertEquals("StatusLine", JavaApiConverter.extractStatusLine(javaResponseHeaders));
+
+    assertNull(JavaApiConverter.extractStatusLine(Collections.<String, List<String>>emptyMap()));
+  }
+
+  private URL configureServer(MockResponse mockResponse) throws Exception {
+    server.enqueue(mockResponse);
+    return server.getUrl("/");
+  }
+
+  private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
+    server.get().useHttps(sslContext.getSocketFactory(), false /* tunnelProxy */);
+    server.enqueue(mockResponse);
+    return server.getUrl("/");
+  }
+
+  private static <T> void assertNotNullAndEquals(T expected, T actual) {
+    assertNotNull(actual);
+    assertEquals(expected, actual);
+  }
+
+  private interface HttpURLConnectionFactory {
+    public HttpURLConnection open(URL serverUrl) throws IOException;
+  }
+
+  private static class OkHttpURLConnectionFactory implements HttpURLConnectionFactory {
+    protected final OkHttpClient client;
+
+    private OkHttpURLConnectionFactory(OkHttpClient client) {
+      this.client = client;
+    }
+
+    @Override public HttpURLConnection open(URL serverUrl) {
+      return new OkUrlFactory(client).open(serverUrl);
+    }
+  }
+
+  private static class JavaHttpURLConnectionFactory implements HttpURLConnectionFactory {
+    @Override public HttpURLConnection open(URL serverUrl) throws IOException {
+      return (HttpURLConnection) serverUrl.openConnection();
+    }
+  }
+
+  private static X509Certificate certificate(String certificate) {
+    try {
+      return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(
+          new ByteArrayInputStream(certificate.getBytes(Util.UTF_8)));
+    } catch (CertificateException e) {
+      fail();
+      return null;
+    }
+  }
+
+  private static <T> Set<T> newSet(T... elements) {
+    return newSet(Arrays.asList(elements));
+  }
+
+  private static <T> Set<T> newSet(List<T> elements) {
+    return new LinkedHashSet<>(elements);
+  }
+
+  private static Request createArbitraryOkRequest() {
+    return new Request.Builder().url("http://arbitrary/url").build();
+  }
+
+  private static Response createArbitraryOkResponse(Request request) {
+    return new Response.Builder()
+        .request(request)
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Arbitrary")
+        .build();
+  }
+
+  private static Response createArbitraryOkResponse() {
+    return createArbitraryOkResponse(createArbitraryOkRequest());
+  }
+
+  private static RequestBody createRequestBody(String bodyText) {
+    return RequestBody.create(MediaType.parse("text/plain"), bodyText);
+  }
+
+  private static ResponseBody createResponseBody(String bodyText) {
+    final Buffer source = new Buffer().writeUtf8(bodyText);
+    final long contentLength = source.size();
+    return new ResponseBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain; charset=utf-8");
+      }
+
+      @Override public long contentLength() {
+        return contentLength;
+      }
+
+      @Override public BufferedSource source() {
+        return source;
+      }
+    };
+  }
+
+  private String readAll(InputStream in) throws IOException {
+    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+    int value;
+    while ((value = in.read()) != -1) {
+      buffer.write(value);
+    }
+    in.close();
+    return buffer.toString("UTF-8");
+  }
+}
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
new file mode 100644
index 0000000000..e3b2c79793
--- /dev/null
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
@@ -0,0 +1,1690 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.huc;
+
+import com.squareup.okhttp.AbstractResponseCache;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.http.HttpDate;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.CookieManager;
+import java.net.HttpCookie;
+import java.net.HttpURLConnection;
+import java.net.ResponseCache;
+import java.net.SecureCacheResponse;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/** Tests the interaction between OkHttp and {@link ResponseCache}. */
+public final class ResponseCacheTest {
+  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
+    @Override public boolean verify(String s, SSLSession sslSession) {
+      return true;
+    }
+  };
+
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+
+  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
+  @Rule public MockWebServerRule server2Rule = new MockWebServerRule();
+
+  private OkHttpClient client;
+  private MockWebServer server;
+  private MockWebServer server2;
+  private ResponseCache cache;
+
+  @Before public void setUp() throws Exception {
+    server = serverRule.get();
+    server.setProtocolNegotiationEnabled(false);
+    server2 = server2Rule.get();
+
+    client = new OkHttpClient();
+    cache = new InMemoryResponseCache();
+    Internal.instance.setCache(client, new CacheAdapter(cache));
+  }
+
+  @After public void tearDown() throws Exception {
+    CookieManager.setDefault(null);
+  }
+
+  private HttpURLConnection openConnection(URL url) {
+    return new OkUrlFactory(client).open(url);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
+    testResponseCaching(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
+    testResponseCaching(TransferKind.CHUNKED);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
+    testResponseCaching(TransferKind.END_OF_STREAM);
+  }
+
+  /**
+   * HttpURLConnection.getInputStream().skip(long) causes ResponseCache corruption
+   * http://code.google.com/p/android/issues/detail?id=8175
+   */
+  private void testResponseCaching(TransferKind transferKind) throws IOException {
+    MockResponse response =
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+            .setStatus("HTTP/1.1 200 Fantastic");
+    transferKind.setBody(response, "I love puppies but hate spiders", 1);
+    server.enqueue(response);
+
+    // Make sure that calling skip() doesn't omit bytes from the cache.
+    HttpURLConnection urlConnection = openConnection(server.getUrl("/"));
+    InputStream in = urlConnection.getInputStream();
+    assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
+    reliableSkip(in, "puppies but hate ".length());
+    assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
+    assertEquals(-1, in.read());
+    in.close();
+
+    urlConnection = openConnection(server.getUrl("/")); // cached!
+    in = urlConnection.getInputStream();
+    assertEquals("I love puppies but hate spiders",
+        readAscii(urlConnection, "I love puppies but hate spiders".length()));
+    assertEquals(200, urlConnection.getResponseCode());
+    assertEquals("Fantastic", urlConnection.getResponseMessage());
+
+    assertEquals(-1, in.read());
+    in.close();
+  }
+
+  @Test public void secureResponseCaching() throws IOException {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+
+    HttpsURLConnection c1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    c1.setSSLSocketFactory(sslContext.getSocketFactory());
+    c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("ABC", readAscii(c1));
+
+    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
+    String suite = c1.getCipherSuite();
+    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
+    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
+    Principal peerPrincipal = c1.getPeerPrincipal();
+    Principal localPrincipal = c1.getLocalPrincipal();
+
+    HttpsURLConnection c2 = (HttpsURLConnection) openConnection(server.getUrl("/")); // cached!
+    c2.setSSLSocketFactory(sslContext.getSocketFactory());
+    c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("ABC", readAscii(c2));
+
+    assertEquals(suite, c2.getCipherSuite());
+    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
+    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
+    assertEquals(peerPrincipal, c2.getPeerPrincipal());
+    assertEquals(localPrincipal, c2.getLocalPrincipal());
+  }
+
+  @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().setBody("ABC"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+
+    Internal.instance.setCache(client,
+        new CacheAdapter(new InsecureResponseCache(new InMemoryResponseCache())));
+
+    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    connection1.setSSLSocketFactory(sslContext.getSocketFactory());
+    connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("ABC", readAscii(connection1));
+
+    // Not cached!
+    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    connection2.setSSLSocketFactory(sslContext.getSocketFactory());
+    connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("DEF", readAscii(connection2));
+  }
+
+  @Test public void responseCachingAndRedirects() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("ABC", readAscii(connection));
+
+    connection = openConnection(server.getUrl("/")); // cached!
+    assertEquals("ABC", readAscii(connection));
+  }
+
+  @Test public void redirectToCachedResult() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("ABC"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+
+    assertEquals("ABC", readAscii(openConnection(server.getUrl("/foo"))));
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
+    assertEquals(0, request1.getSequenceNumber());
+
+    assertEquals("ABC", readAscii(openConnection(server.getUrl("/bar"))));
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
+    assertEquals(1, request2.getSequenceNumber());
+
+    // an unrelated request should reuse the pooled connection
+    assertEquals("DEF", readAscii(openConnection(server.getUrl("/baz"))));
+    RecordedRequest request3 = server.takeRequest();
+    assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
+    assertEquals(2, request3.getSequenceNumber());
+  }
+
+  @Test public void secureResponseCachingAndRedirects() throws IOException {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    assertEquals("ABC", readAscii(connection1));
+    assertNotNull(connection1.getCipherSuite());
+
+    // Cached!
+    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    assertEquals("ABC", readAscii(connection2));
+    assertNotNull(connection2.getCipherSuite());
+
+    assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
+  }
+
+  /**
+   * We've had bugs where caching and cross-protocol redirects yield class
+   * cast exceptions internal to the cache because we incorrectly assumed that
+   * HttpsURLConnection was always HTTPS and HttpURLConnection was always HTTP;
+   * in practice redirects mean that each can do either.
+   *
+   * https://github.com/square/okhttp/issues/214
+   */
+  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
+    server2.useHttps(sslContext.getSocketFactory(), false);
+    server2.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server2.enqueue(new MockResponse().setBody("DEF"));
+
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: " + server2.getUrl("/")));
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    HttpURLConnection connection1 = openConnection(server.getUrl("/"));
+    assertEquals("ABC", readAscii(connection1));
+
+    // Cached!
+    HttpURLConnection connection2 = openConnection(server.getUrl("/"));
+    assertEquals("ABC", readAscii(connection2));
+  }
+
+  @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
+    server.enqueue(new MockResponse().setBody("ABC"));
+
+    final AtomicReference<Map<String, List<String>>> requestHeadersRef =
+        new AtomicReference<Map<String, List<String>>>();
+    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+      @Override public CacheResponse get(URI uri, String requestMethod,
+          Map<String, List<String>> requestHeaders) throws IOException {
+        requestHeadersRef.set(requestHeaders);
+        return null;
+      }
+    }));
+
+    URL url = server.getUrl("/");
+    URLConnection urlConnection = openConnection(url);
+    urlConnection.addRequestProperty("A", "android");
+    readAscii(urlConnection);
+    assertEquals(Arrays.asList("android"), requestHeadersRef.get().get("A"));
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
+    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
+    testServerPrematureDisconnect(TransferKind.CHUNKED);
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
+    // Intentionally empty. This case doesn't make sense because there's no
+    // such thing as a premature disconnect when the disconnect itself
+    // indicates the end of the data stream.
+  }
+
+  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
+    MockResponse response = new MockResponse();
+    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
+    server.enqueue(truncateViolently(response, 16));
+    server.enqueue(new MockResponse().setBody("Request #2"));
+
+    BufferedReader reader = new BufferedReader(
+        new InputStreamReader(openConnection(server.getUrl("/")).getInputStream()));
+    assertEquals("ABCDE", reader.readLine());
+    try {
+      reader.readLine();
+      fail("This implementation silently ignored a truncated HTTP body.");
+    } catch (IOException expected) {
+    } finally {
+      reader.close();
+    }
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("Request #2", readAscii(connection));
+  }
+
+  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
+    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
+    testClientPrematureDisconnect(TransferKind.CHUNKED);
+  }
+
+  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
+    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
+  }
+
+  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
+    // Setting a low transfer speed ensures that stream discarding will time out.
+    MockResponse response = new MockResponse().throttleBody(6, 1, TimeUnit.SECONDS);
+    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
+    server.enqueue(response);
+    server.enqueue(new MockResponse().setBody("Request #2"));
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    InputStream in = connection.getInputStream();
+    assertEquals("ABCDE", readAscii(connection, 5));
+    in.close();
+    try {
+      in.read();
+      fail("Expected an IOException because the stream is closed.");
+    } catch (IOException expected) {
+    }
+
+    connection = openConnection(server.getUrl("/"));
+    assertEquals("Request #2", readAscii(connection));
+  }
+
+  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
+    //      last modified: 105 seconds ago
+    //             served:   5 seconds ago
+    //   default lifetime: (105 - 5) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds from now
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+            .setBody("A"));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(openConnection(url)));
+    URLConnection connection = openConnection(url);
+    assertEquals("A", readAscii(connection));
+    assertNull(connection.getHeaderField("Warning"));
+  }
+
+  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
+    //      last modified: 115 seconds ago
+    //             served:  15 seconds ago
+    //   default lifetime: (115 - 15) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds ago
+    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
+    //      last modified: 105 days ago
+    //             served:   5 days ago
+    //   default lifetime: (105 - 5) / 10 = 10 days
+    //            expires:  10 days from served date = 5 days from now
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
+        .setBody("A"));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection));
+    assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
+        connection.getHeaderField("Warning"));
+  }
+
+  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+            .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/?foo=bar");
+    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("B", readAscii(openConnection(url)));
+  }
+
+  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+  }
+
+  @Test public void expirationDateInTheFuture() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Cache-Control: max-age=60"));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
+    // Chrome interprets max-age relative to the local clock. Both our cache
+    // and Firefox both use the earlier of the local and server's clock.
+    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
+    assertFullyCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
+    assertFullyCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+            .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: s-maxage=60")
+        .addHeader("Cache-Control: max-age=180"));
+  }
+
+  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: s-maxage=180")
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  /**
+   * Tests that the ResponseCache can cache something. The InMemoryResponseCache only caches GET
+   * requests.
+   */
+  @Test public void responseCacheCanCache() throws Exception {
+    testRequestMethod("GET", true);
+  }
+
+  /**
+   * Confirm the ResponseCache can elect to not cache something. The InMemoryResponseCache only
+   * caches GET requests.
+   */
+  @Test public void responseCacheCanIgnore() throws Exception {
+    testRequestMethod("HEAD", false);
+  }
+
+  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
+    // 1. seed the cache (potentially)
+    // 2. expect a cache hit or miss
+    server.enqueue(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("X-Response-ID: 1"));
+    server.enqueue(new MockResponse().addHeader("X-Response-ID: 2"));
+
+    URL url = server.getUrl("/");
+
+    HttpURLConnection request1 = openConnection(url);
+    request1.setRequestMethod(requestMethod);
+    addRequestBodyIfNecessary(requestMethod, request1);
+    request1.getInputStream().close();
+    assertEquals("1", request1.getHeaderField("X-Response-ID"));
+
+    URLConnection request2 = openConnection(url);
+    request2.getInputStream().close();
+    if (expectCached) {
+      assertEquals("1", request2.getHeaderField("X-Response-ID"));
+    } else {
+      assertEquals("2", request2.getHeaderField("X-Response-ID"));
+    }
+  }
+
+  /**
+   * Equivalent to {@code CacheTest.postInvalidatesCacheWithUncacheableResponse()} but demonstrating
+   * that {@link ResponseCache} provides no mechanism for cache invalidation as the result of
+   * locally-made requests. In reality invalidation could take place from other clients at any time.
+   */
+  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
+    // 1. seed the cache
+    // 2. invalidate it with uncacheable response
+    // 3. the cache to return the original value
+    server.enqueue(
+        new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse().setBody("B").setResponseCode(500));
+
+    URL url = server.getUrl("/");
+
+    assertEquals("A", readAscii(openConnection(url)));
+
+    HttpURLConnection invalidate = openConnection(url);
+    invalidate.setRequestMethod("POST");
+    addRequestBodyIfNecessary("POST", invalidate);
+    assertEquals("B", readAscii(invalidate));
+
+    assertEquals("A", readAscii(openConnection(url)));
+  }
+
+  @Test public void etag() throws Exception {
+    RecordedRequest conditionalRequest =
+        assertConditionallyCached(new MockResponse().addHeader("ETag: v1"));
+    assertTrue(conditionalRequest.getHeaders().contains("If-None-Match: v1"));
+  }
+
+  @Test public void etagAndExpirationDateInThePast() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("ETag: v1")
+            .addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-None-Match: v1"));
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("ETag: v1")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  @Test public void cacheControlNoCache() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Cache-Control: no-cache"));
+  }
+
+  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+            .addHeader("Cache-Control: no-cache"));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void pragmaNoCache() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Pragma: no-cache"));
+  }
+
+  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+            .addHeader("Pragma: no-cache"));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void cacheControlNoStore() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Cache-Control: no-store"));
+  }
+
+  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: no-store"));
+  }
+
+  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
+    // 1. request a range
+    // 2. request a full document, expecting a cache miss
+    server.enqueue(new MockResponse().setBody("AA")
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 1000-1001/2000"));
+    server.enqueue(new MockResponse().setBody("BB"));
+
+    URL url = server.getUrl("/");
+
+    URLConnection range = openConnection(url);
+    range.addRequestProperty("Range", "bytes=1000-1001");
+    assertEquals("AA", readAscii(range));
+
+    assertEquals("BB", readAscii(openConnection(url)));
+  }
+
+  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse().setBody("B")
+        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
+
+    URL url = server.getUrl("/");
+
+    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(openConnection(url)));
+  }
+
+  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
+    assertNonIdentityEncodingCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+  }
+
+  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
+    assertNonIdentityEncodingCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
+    server.enqueue(
+        response.setBody(gzip("ABCABCABC")).addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // At least three request/response pairs are required because after the first request is cached
+    // a different execution path might be taken. Thus modifications to the cache applied during
+    // the second request might not be visible until another request is performed.
+    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
+  }
+
+  @Test public void notModifiedSpecifiesEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+        .setBody("DEFDEFDEF"));
+
+    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("DEFDEFDEF", readAscii(openConnection(server.getUrl("/"))));
+  }
+
+  @Test public void expiresDateBeforeModifiedDate() throws Exception {
+    assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
+  }
+
+  @Test public void requestMaxAge() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "max-age=30");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestMinFresh() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "min-fresh=120");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestMaxStale() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "max-stale=180");
+    assertEquals("A", readAscii(connection));
+    assertEquals("110 HttpURLConnection \"Response is stale\"",
+        connection.getHeaderField("Warning"));
+  }
+
+  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=120, must-revalidate")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "max-stale=180");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
+    // (no responses enqueued)
+
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+  }
+
+  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+  }
+
+  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+  }
+
+  @Test public void requestCacheControlNoCache() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+            .addHeader("Cache-Control: max-age=60")
+            .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(openConnection(url)));
+    URLConnection connection = openConnection(url);
+    connection.setRequestProperty("Cache-Control", "no-cache");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestPragmaNoCache() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+            .addHeader("Cache-Control: max-age=60")
+            .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(openConnection(url)));
+    URLConnection connection = openConnection(url);
+    connection.setRequestProperty("Pragma", "no-cache");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
+    MockResponse response =
+        new MockResponse().addHeader("ETag: v3").addHeader("Cache-Control: max-age=0");
+    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
+    RecordedRequest request =
+        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
+    List<String> headers = request.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + ifModifiedSinceDate));
+    assertFalse(headers.contains("If-None-Match: v3"));
+  }
+
+  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
+    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
+    MockResponse response = new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: max-age=0");
+    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
+    List<String> headers = request.getHeaders();
+    assertTrue(headers.contains("If-None-Match: v1"));
+    assertFalse(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
+      String conditionValue) throws Exception {
+    server.enqueue(seed.setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(openConnection(url)));
+
+    HttpURLConnection connection = openConnection(url);
+    connection.addRequestProperty(conditionName, conditionValue);
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
+    assertEquals("", readAscii(connection));
+
+    server.takeRequest(); // seed
+    return server.takeRequest();
+  }
+
+  @Test public void setIfModifiedSince() throws Exception {
+    Date since = new Date();
+    server.enqueue(new MockResponse().setBody("A"));
+
+    URL url = server.getUrl("/");
+    URLConnection connection = openConnection(url);
+    connection.setIfModifiedSince(since.getTime());
+    assertEquals("A", readAscii(connection));
+    RecordedRequest request = server.takeRequest();
+    assertTrue(request.getHeaders().contains("If-Modified-Since: " + HttpDate.format(since)));
+  }
+
+  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
+    connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
+    assertEquals("", readAscii(connection));
+  }
+
+  @Test public void authorizationRequestFullyCached() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/");
+    URLConnection connection = openConnection(url);
+    connection.addRequestProperty("Authorization", "password");
+    assertEquals("A", readAscii(connection));
+    assertEquals("A", readAscii(openConnection(url)));
+  }
+
+  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Content-Location: /bar")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/foo"))));
+    assertEquals("B", readAscii(openConnection(server.getUrl("/bar"))));
+  }
+
+  @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.setUseCaches(false);
+    assertEquals("A", readAscii(connection));
+    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
+  }
+
+  @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.setUseCaches(false);
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
+    URL url = new URL("http://localhost/");
+    URLConnection c1 = openConnection(url);
+    URLConnection c2 = openConnection(url);
+    assertTrue(c1.getDefaultUseCaches());
+    c1.setDefaultUseCaches(false);
+    try {
+      assertTrue(c1.getUseCaches());
+      assertTrue(c2.getUseCaches());
+      URLConnection c3 = openConnection(url);
+      assertFalse(c3.getUseCaches());
+    } finally {
+      c1.setDefaultUseCaches(true);
+    }
+  }
+
+  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
+    assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
+    assertEquals("B", readAscii(openConnection(server.getUrl("/b"))));
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  /**
+   * Confirms the cache implementation may determine the criteria for caching. In real caches
+   * this would be the "Vary" headers.
+   */
+  @Test public void cacheCanUseCriteriaBesidesVariantObeyed() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Cache-Control: max-age=60")
+            .addHeader(InMemoryResponseCache.CACHE_VARIANT_HEADER, "A").setBody("A"));
+    server.enqueue(
+        new MockResponse().addHeader("Cache-Control: max-age=60")
+            .addHeader(InMemoryResponseCache.CACHE_VARIANT_HEADER, "B").setBody("B"));
+
+    URL url = server.getUrl("/");
+    URLConnection connection1 = openConnection(url);
+    connection1.addRequestProperty(InMemoryResponseCache.CACHE_VARIANT_HEADER, "A");
+    assertEquals("A", readAscii(connection1));
+    URLConnection connection2 = openConnection(url);
+    connection2.addRequestProperty(InMemoryResponseCache.CACHE_VARIANT_HEADER, "A");
+    assertEquals("A", readAscii(connection2));
+    assertEquals(1, server.getRequestCount());
+
+    URLConnection connection3 = openConnection(url);
+    connection3.addRequestProperty(InMemoryResponseCache.CACHE_VARIANT_HEADER, "B");
+    assertEquals("B", readAscii(connection3));
+    assertEquals(2, server.getRequestCount());
+
+    URLConnection connection4 = openConnection(url);
+    connection4.addRequestProperty(InMemoryResponseCache.CACHE_VARIANT_HEADER, "A");
+    assertEquals("A", readAscii(connection4));
+    assertEquals(2, server.getRequestCount());
+  }
+
+  @Test public void cachePlusCookies() throws Exception {
+    server.enqueue(new MockResponse().addHeader(
+        "Set-Cookie: a=FIRST; domain=" + server.getCookieDomain() + ";")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().addHeader(
+        "Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    CookieManager cookieManager = new CookieManager();
+    CookieManager.setDefault(cookieManager);
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(openConnection(url)));
+    assertCookies(cookieManager, url, "a=FIRST");
+    assertEquals("A", readAscii(openConnection(url)));
+    assertCookies(cookieManager, url, "a=SECOND");
+  }
+
+  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD, PUT")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection1));
+    assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
+
+    URLConnection connection2 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection2));
+    assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
+  }
+
+  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: identity")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: none")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection1));
+    assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
+
+    URLConnection connection2 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection2));
+    assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
+  }
+
+  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Warning: 199 test danger")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection1));
+    assertEquals("199 test danger", connection1.getHeaderField("Warning"));
+
+    URLConnection connection2 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection2));
+    assertEquals(null, connection2.getHeaderField("Warning"));
+  }
+
+  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Warning: 299 test danger")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    URLConnection connection1 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection1));
+    assertEquals("299 test danger", connection1.getHeaderField("Warning"));
+
+    URLConnection connection2 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection2));
+    assertEquals("299 test danger", connection2.getHeaderField("Warning"));
+  }
+
+  public void assertCookies(CookieManager cookieManager, URL url, String... expectedCookies)
+      throws Exception {
+    List<String> actualCookies = new ArrayList<String>();
+    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
+      actualCookies.add(cookie.toString());
+    }
+    assertEquals(Arrays.asList(expectedCookies), actualCookies);
+  }
+
+  @Test public void cachePlusRange() throws Exception {
+    assertNotCached(new MockResponse().setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 100-100/200")
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  /**
+   * Equivalent to {@code CacheTest.conditionalHitUpdatesCache()}, except a Java standard cache has
+   * no means to update the headers for an existing entry so the behavior is different.
+   */
+  @Test public void conditionalHitDoesNotUpdateCache() throws Exception {
+    // A response that is cacheable, but with a short life.
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    // A response that refers to the previous response, but is cacheable with a long life.
+    // Contains a header we can recognize as having come from the server.
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=30")
+        .addHeader("Allow: GET, HEAD")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    // A response that is cacheable with a long life.
+    server.enqueue(new MockResponse().setBody("B").addHeader("Cache-Control: max-age=30"));
+    // A response that should never be requested.
+    server.enqueue(new MockResponse().setBody("C"));
+
+    // cache miss; seed the cache with an entry that will require a network hit to be sure it is
+    // still valid
+    HttpURLConnection connection1 = openConnection(server.getUrl("/a"));
+    assertEquals("A", readAscii(connection1));
+    assertEquals(null, connection1.getHeaderField("Allow"));
+
+    // conditional cache hit; The cached data should be returned, but the cache is not updated.
+    HttpURLConnection connection2 = openConnection(server.getUrl("/a"));
+    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+    assertEquals("A", readAscii(connection2));
+    assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
+
+    // conditional cache hit; The server responds with new data. The cache is updated.
+    HttpURLConnection connection3 = openConnection(server.getUrl("/a"));
+    assertEquals("B", readAscii(connection3));
+
+    // full cache hit; The data from connection3 has now replaced that from connection 1.
+    HttpURLConnection connection4 = openConnection(server.getUrl("/a"));
+    assertEquals("B", readAscii(connection4));
+
+    assertEquals(3, server.getRequestCount());
+  }
+
+  @Test public void responseSourceHeaderCached() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setBody("B")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=0")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setResponseCode(304));
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void responseSourceHeaderFetched() throws IOException {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader(": A")
+        .setBody("body"));
+
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", connection.getHeaderField(""));
+  }
+
+  /**
+   * Test that we can interrogate the response when the cache is being
+   * populated. http://code.google.com/p/android/issues/detail?id=7787
+   */
+  @Test public void responseCacheCallbackApis() throws Exception {
+    final String body = "ABCDE";
+    final AtomicInteger cacheCount = new AtomicInteger();
+
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 200 Fantastic")
+        .addHeader("Content-Type: text/plain")
+        .addHeader("fgh: ijk")
+        .setBody(body));
+
+    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+        HttpURLConnection httpURLConnection = (HttpURLConnection) connection;
+        assertEquals(server.getUrl("/"), uri.toURL());
+        assertEquals(200, httpURLConnection.getResponseCode());
+        try {
+          httpURLConnection.getInputStream();
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        assertEquals("5", connection.getHeaderField("Content-Length"));
+        assertEquals("text/plain", connection.getHeaderField("Content-Type"));
+        assertEquals("ijk", connection.getHeaderField("fgh"));
+        cacheCount.incrementAndGet();
+        return null;
+      }
+    }));
+
+    URL url = server.getUrl("/");
+    HttpURLConnection connection = openConnection(url);
+    assertEquals(body, readAscii(connection));
+    assertEquals(1, cacheCount.get());
+  }
+
+  /** Don't explode if the cache returns a null body. http://b/3373699 */
+  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
+    final AtomicBoolean aborted = new AtomicBoolean();
+    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
+      @Override public CacheRequest put(URI uri, URLConnection connection) {
+        return new CacheRequest() {
+          @Override public void abort() {
+            aborted.set(true);
+          }
+
+          @Override public OutputStream getBody() throws IOException {
+            return null;
+          }
+        };
+      }
+    }));
+
+    server.enqueue(new MockResponse().setBody("abcdef"));
+
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("abc", readAscii(connection, 3));
+    connection.getInputStream().close();
+    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
+  }
+
+  /**
+   * @param delta the offset from the current date to use. Negative
+   * values yield dates in the past; positive values yield dates in the
+   * future.
+   */
+  private String formatDate(long delta, TimeUnit timeUnit) {
+    return HttpDate.format(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
+  }
+
+  private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection invalidate)
+      throws IOException {
+    if (requestMethod.equals("POST") || requestMethod.equals("PUT")) {
+      invalidate.setDoOutput(true);
+      OutputStream requestBody = invalidate.getOutputStream();
+      requestBody.write('x');
+      requestBody.close();
+    }
+  }
+
+  private void assertNotCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("B", readAscii(openConnection(url)));
+  }
+
+  /** @return the request with the conditional get headers. */
+  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
+    // scenario 1: condition succeeds
+    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // scenario 2: condition fails
+    server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
+
+    URL valid = server.getUrl("/valid");
+    HttpURLConnection connection1 = openConnection(valid);
+    assertEquals("A", readAscii(connection1));
+    assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
+    assertEquals("A-OK", connection1.getResponseMessage());
+    HttpURLConnection connection2 = openConnection(valid);
+    assertEquals("A", readAscii(connection2));
+    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+    assertEquals("A-OK", connection2.getResponseMessage());
+
+    URL invalid = server.getUrl("/invalid");
+    HttpURLConnection connection3 = openConnection(invalid);
+    assertEquals("B", readAscii(connection3));
+    assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
+    assertEquals("B-OK", connection3.getResponseMessage());
+    HttpURLConnection connection4 = openConnection(invalid);
+    assertEquals("C", readAscii(connection4));
+    assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
+    assertEquals("C-OK", connection4.getResponseMessage());
+
+    server.takeRequest(); // regular get
+    return server.takeRequest(); // conditional get
+  }
+
+  private void assertFullyCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
+    server.enqueue(response.setBody("B"));
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(openConnection(url)));
+  }
+
+  /**
+   * Shortens the body of {@code response} but not the corresponding headers.
+   * Only useful to test how clients respond to the premature conclusion of
+   * the HTTP body.
+   */
+  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
+    response.setSocketPolicy(DISCONNECT_AT_END);
+    List<String> headers = new ArrayList<>(response.getHeaders());
+    Buffer truncatedBody = new Buffer();
+    truncatedBody.write(response.getBody(), numBytesToKeep);
+    response.setBody(truncatedBody);
+    response.getHeaders().clear();
+    response.getHeaders().addAll(headers);
+    return response;
+  }
+
+  /**
+   * Reads {@code count} characters from the stream. If the stream is
+   * exhausted before {@code count} characters can be read, the remaining
+   * characters are returned and the stream is closed.
+   */
+  private String readAscii(URLConnection connection, int count) throws IOException {
+    HttpURLConnection httpConnection = (HttpURLConnection) connection;
+    InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
+        ? connection.getInputStream() : httpConnection.getErrorStream();
+    StringBuilder result = new StringBuilder();
+    for (int i = 0; i < count; i++) {
+      int value = in.read();
+      if (value == -1) {
+        in.close();
+        break;
+      }
+      result.append((char) value);
+    }
+    return result.toString();
+  }
+
+  private String readAscii(URLConnection connection) throws IOException {
+    return readAscii(connection, Integer.MAX_VALUE);
+  }
+
+  private void reliableSkip(InputStream in, int length) throws IOException {
+    while (length > 0) {
+      length -= in.skip(length);
+    }
+  }
+
+  private void assertGatewayTimeout(HttpURLConnection connection) throws IOException {
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (FileNotFoundException expected) {
+    }
+    assertEquals(504, connection.getResponseCode());
+    assertEquals(-1, connection.getErrorStream().read());
+  }
+
+  enum TransferKind {
+    CHUNKED() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
+          throws IOException {
+        response.setChunkedBody(content, chunkSize);
+      }
+    },
+    FIXED_LENGTH() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+      }
+    },
+    END_OF_STREAM() {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+        response.setSocketPolicy(DISCONNECT_AT_END);
+        for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
+          if (h.next().startsWith("Content-Length:")) {
+            h.remove();
+            break;
+          }
+        }
+      }
+    };
+
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
+
+    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
+    }
+  }
+
+  private <T> List<T> toListOrNull(T[] arrayOrNull) {
+    return arrayOrNull != null ? Arrays.asList(arrayOrNull) : null;
+  }
+
+  /** Returns a gzipped copy of {@code bytes}. */
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
+  }
+
+  private static class InsecureResponseCache extends ResponseCache {
+
+    private final ResponseCache delegate;
+
+    private InsecureResponseCache(ResponseCache delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+      return delegate.put(uri, connection);
+    }
+
+    @Override public CacheResponse get(URI uri, String requestMethod,
+        Map<String, List<String>> requestHeaders) throws IOException {
+      final CacheResponse response = delegate.get(uri, requestMethod, requestHeaders);
+      if (response instanceof SecureCacheResponse) {
+        return new CacheResponse() {
+          @Override public InputStream getBody() throws IOException {
+            return response.getBody();
+          }
+          @Override public Map<String, List<String>> getHeaders() throws IOException {
+            return response.getHeaders();
+          }
+        };
+      }
+      return response;
+    }
+  }
+
+  /**
+   * A trivial and non-thread-safe implementation of ResponseCache that uses an in-memory map to
+   * cache GETs.
+   */
+  private static class InMemoryResponseCache extends ResponseCache {
+
+    /** A request / response header that acts a bit like Vary but without the complexity. */
+    public static final String CACHE_VARIANT_HEADER = "CacheVariant";
+
+    private static class Key {
+      private final URI uri;
+      private final String cacheVariant;
+
+      private Key(URI uri, String cacheVariant) {
+        this.uri = uri;
+        this.cacheVariant = cacheVariant;
+      }
+
+      @Override
+      public boolean equals(Object o) {
+        if (this == o) {
+          return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+          return false;
+        }
+
+        Key key = (Key) o;
+
+        if (cacheVariant != null ? !cacheVariant.equals(key.cacheVariant)
+            : key.cacheVariant != null) {
+          return false;
+        }
+        if (!uri.equals(key.uri)) {
+          return false;
+        }
+
+        return true;
+      }
+
+      @Override
+      public int hashCode() {
+        int result = uri.hashCode();
+        result = 31 * result + (cacheVariant != null ? cacheVariant.hashCode() : 0);
+        return result;
+      }
+    }
+
+    private class Entry {
+
+      private final URI uri;
+      private final String cacheVariant;
+      private final String method;
+      private final Map<String, List<String>> responseHeaders;
+      private final String cipherSuite;
+      private final Certificate[] serverCertificates;
+      private final Certificate[] localCertificates;
+      private byte[] body;
+
+      public Entry(URI uri, URLConnection urlConnection) {
+        this.uri = uri;
+        HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
+        method = httpUrlConnection.getRequestMethod();
+        cacheVariant = urlConnection.getHeaderField(CACHE_VARIANT_HEADER);
+        responseHeaders = urlConnection.getHeaderFields();
+        if (urlConnection instanceof HttpsURLConnection) {
+          HttpsURLConnection httpsURLConnection = (HttpsURLConnection) urlConnection;
+          cipherSuite = httpsURLConnection.getCipherSuite();
+          Certificate[] serverCertificates;
+          try {
+            serverCertificates = httpsURLConnection.getServerCertificates();
+          } catch (SSLPeerUnverifiedException e) {
+            serverCertificates = null;
+          }
+          this.serverCertificates = serverCertificates;
+          localCertificates = httpsURLConnection.getLocalCertificates();
+        } else {
+          cipherSuite = null;
+          serverCertificates = null;
+          localCertificates = null;
+        }
+      }
+
+      public CacheResponse asCacheResponse() {
+        if (!method.equals(this.method)) {
+          return null;
+        }
+
+        // Handle SSL
+        if (cipherSuite != null) {
+          return new SecureCacheResponse() {
+            @Override
+            public Map<String, List<String>> getHeaders() throws IOException {
+              return responseHeaders;
+            }
+
+            @Override
+            public InputStream getBody() throws IOException {
+              return new ByteArrayInputStream(body);
+            }
+
+            @Override
+            public String getCipherSuite() {
+              return cipherSuite;
+            }
+
+            @Override
+            public List<Certificate> getLocalCertificateChain() {
+              return localCertificates == null ? null : Arrays.asList(localCertificates);
+            }
+
+            @Override
+            public List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException {
+              if (serverCertificates == null) {
+                throw new SSLPeerUnverifiedException("Test implementation");
+              }
+              return Arrays.asList(serverCertificates);
+            }
+
+            @Override
+            public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+              throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public Principal getLocalPrincipal() {
+              throw new UnsupportedOperationException();
+            }
+          };
+        } else {
+          return new CacheResponse() {
+            @Override
+            public Map<String, List<String>> getHeaders() throws IOException {
+              return responseHeaders;
+            }
+
+            @Override
+            public InputStream getBody() throws IOException {
+              return new ByteArrayInputStream(body);
+            }
+          };
+        }
+      }
+
+      public CacheRequest asCacheRequest() {
+        return new CacheRequest() {
+          @Override
+          public OutputStream getBody() throws IOException {
+            return new ByteArrayOutputStream() {
+              @Override
+              public void close() throws IOException {
+                super.close();
+                body = toByteArray();
+                cache.put(Entry.this.key(), Entry.this);
+              }
+            };
+          }
+
+          @Override
+          public void abort() {
+            // No-op: close() puts the item in the cache, abort need not do anything.
+          }
+        };
+      }
+
+      private Key key() {
+        return new Key(uri, cacheVariant);
+      }
+    }
+
+    private Map<Key, Entry> cache = new HashMap<Key, Entry>();
+
+    @Override
+    public CacheResponse get(URI uri, String method, Map<String, List<String>> requestHeaders)
+        throws IOException {
+
+      if (!"GET".equals(method)) {
+        return null;
+      }
+
+      String cacheVariant =
+          requestHeaders.containsKey(CACHE_VARIANT_HEADER)
+              ? requestHeaders.get(CACHE_VARIANT_HEADER).get(0) : null;
+      Key key = new Key(uri, cacheVariant);
+      Entry entry = cache.get(key);
+      if (entry == null) {
+        return null;
+      }
+      return entry.asCacheResponse();
+    }
+
+    @Override
+    public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+      if (!"GET".equals(((HttpURLConnection) urlConnection).getRequestMethod())) {
+        return null;
+      }
+
+      Entry entry = new Entry(uri, urlConnection);
+      return entry.asCacheRequest();
+    }
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/URLEncodingTest.java
similarity index 93%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java
rename to okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/URLEncodingTest.java
index 6ca375691b..4c5f28c8bf 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/internal/huc/URLEncodingTest.java
@@ -14,18 +14,18 @@
  * limitations under the License.
  */
 
-package com.squareup.okhttp.internal.http;
+package com.squareup.okhttp.internal.huc;
 
+import com.squareup.okhttp.AbstractResponseCache;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
+import com.squareup.okhttp.internal.Internal;
 import java.io.IOException;
-import java.net.CacheRequest;
 import java.net.CacheResponse;
 import java.net.HttpURLConnection;
-import java.net.ResponseCache;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
-import java.net.URLConnection;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
@@ -121,23 +121,19 @@ private void testUrlToUriMapping(String string, String asAuthority, String asFil
   }
 
   private URI backdoorUrlToUri(URL url) throws Exception {
-    final AtomicReference<URI> uriReference = new AtomicReference<URI>();
+    final AtomicReference<URI> uriReference = new AtomicReference<>();
 
     OkHttpClient client = new OkHttpClient();
-    client.setResponseCache(new ResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        return null;
-      }
-
+    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
       @Override public CacheResponse get(URI uri, String requestMethod,
           Map<String, List<String>> requestHeaders) throws IOException {
         uriReference.set(uri);
         throw new UnsupportedOperationException();
       }
-    });
+    }));
 
     try {
-      HttpURLConnection connection = client.open(url);
+      HttpURLConnection connection = new OkUrlFactory(client).open(url);
       connection.getResponseCode();
     } catch (Exception expected) {
       if (expected.getCause() instanceof URISyntaxException) {
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 9bad03d309..b7232214f7 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
@@ -14,56 +14,35 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>okhttp-protocols</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.mortbay.jetty.npn</groupId>
-      <artifactId>npn-boot</artifactId>
-      <scope>provided</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
     </dependency>
   </dependencies>
 
   <build>
     <plugins>
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <configuration>
-          <excludePackageNames>com.squareup.okhttp.internal:com.squareup.okhttp.internal.*</excludePackageNames>
-        </configuration>
-      </plugin>
-
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <configuration>
-          <descriptorRefs>
-            <descriptorRef>jar-with-dependencies</descriptorRef>
-          </descriptorRefs>
-        </configuration>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>templating-maven-plugin</artifactId>
+        <version>1.0-alpha-3</version>
         <executions>
           <execution>
-            <phase>package</phase>
             <goals>
-              <goal>single</goal>
+              <goal>filter-sources</goal>
             </goals>
           </execution>
         </executions>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <excludePackageNames>com.squareup.okhttp.internal:com.squareup.okhttp.internal.*</excludePackageNames>
+          <links>
+            <link>http://square.github.io/okio/</link>
+          </links>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/okhttp/src/main/java-templates/com/squareup/okhttp/internal/Version.java b/okhttp/src/main/java-templates/com/squareup/okhttp/internal/Version.java
new file mode 100644
index 0000000000..59fece92bf
--- /dev/null
+++ b/okhttp/src/main/java-templates/com/squareup/okhttp/internal/Version.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+public final class Version {
+  public static String userAgent() {
+    return "okhttp/${project.version}";
+  }
+
+  private Version() {
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Address.java b/okhttp/src/main/java/com/squareup/okhttp/Address.java
index b34bd9128c..38768a4004 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Address.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Address.java
@@ -17,8 +17,9 @@
 
 import com.squareup.okhttp.internal.Util;
 import java.net.Proxy;
-import java.net.UnknownHostException;
+import java.net.ProxySelector;
 import java.util.List;
+import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
 
@@ -27,7 +28,7 @@
 /**
  * A specification for a connection to an origin server. For simple connections,
  * this is the server's hostname and port. If an explicit proxy is requested (or
- * {@link Proxy#NO_PROXY no proxy} is explicitly requested), this also includes
+ * {@linkplain Proxy#NO_PROXY no proxy} is explicitly requested), this also includes
  * that proxy information. For secure connections the address also includes the
  * SSL socket factory and hostname verifier.
  *
@@ -38,25 +39,35 @@
   final Proxy proxy;
   final String uriHost;
   final int uriPort;
+  final SocketFactory socketFactory;
   final SSLSocketFactory sslSocketFactory;
   final HostnameVerifier hostnameVerifier;
-  final OkAuthenticator authenticator;
-  final List<String> transports;
+  final CertificatePinner certificatePinner;
+  final Authenticator authenticator;
+  final List<Protocol> protocols;
+  final List<ConnectionSpec> connectionSpecs;
+  final ProxySelector proxySelector;
 
-  public Address(String uriHost, int uriPort, SSLSocketFactory sslSocketFactory,
-      HostnameVerifier hostnameVerifier, OkAuthenticator authenticator, Proxy proxy,
-      List<String> transports) throws UnknownHostException {
+  public Address(String uriHost, int uriPort, SocketFactory socketFactory,
+      SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier,
+      CertificatePinner certificatePinner, Authenticator authenticator, Proxy proxy,
+      List<Protocol> protocols, List<ConnectionSpec> connectionSpecs, ProxySelector proxySelector) {
     if (uriHost == null) throw new NullPointerException("uriHost == null");
     if (uriPort <= 0) throw new IllegalArgumentException("uriPort <= 0: " + uriPort);
     if (authenticator == null) throw new IllegalArgumentException("authenticator == null");
-    if (transports == null) throw new IllegalArgumentException("transports == null");
+    if (protocols == null) throw new IllegalArgumentException("protocols == null");
+    if (proxySelector == null) throw new IllegalArgumentException("proxySelector == null");
     this.proxy = proxy;
     this.uriHost = uriHost;
     this.uriPort = uriPort;
+    this.socketFactory = socketFactory;
     this.sslSocketFactory = sslSocketFactory;
     this.hostnameVerifier = hostnameVerifier;
+    this.certificatePinner = certificatePinner;
     this.authenticator = authenticator;
-    this.transports = Util.immutableList(transports);
+    this.protocols = Util.immutableList(protocols);
+    this.connectionSpecs = Util.immutableList(connectionSpecs);
+    this.proxySelector = proxySelector;
   }
 
   /** Returns the hostname of the origin server. */
@@ -72,6 +83,11 @@ public int getUriPort() {
     return uriPort;
   }
 
+  /** Returns the socket factory for new connections. */
+  public SocketFactory getSocketFactory() {
+    return socketFactory;
+  }
+
   /**
    * Returns the SSL socket factory, or null if this is not an HTTPS
    * address.
@@ -88,30 +104,41 @@ public HostnameVerifier getHostnameVerifier() {
     return hostnameVerifier;
   }
 
-
   /**
    * Returns the client's authenticator. This method never returns null.
    */
-  public OkAuthenticator getAuthenticator() {
+  public Authenticator getAuthenticator() {
     return authenticator;
   }
 
   /**
-   * Returns the client's transports. This method always returns a non-null list
-   * that contains "http/1.1", possibly among other transports.
+   * Returns the protocols the client supports. This method always returns a
+   * non-null list that contains minimally {@link Protocol#HTTP_1_1}.
    */
-  public List<String> getTransports() {
-    return transports;
+  public List<Protocol> getProtocols() {
+    return protocols;
+  }
+
+  public List<ConnectionSpec> getConnectionSpecs() {
+    return connectionSpecs;
   }
 
   /**
    * Returns this address's explicitly-specified HTTP proxy, or null to
-   * delegate to the HTTP client's proxy selector.
+   * delegate to the {@linkplain #getProxySelector proxy selector}.
    */
   public Proxy getProxy() {
     return proxy;
   }
 
+  /**
+   * Returns this address's proxy selector. Only used if the proxy is null. If none of this
+   * selector's proxies are reachable, a direct connection will be attempted.
+   */
+  public ProxySelector getProxySelector() {
+    return proxySelector;
+  }
+
   @Override public boolean equals(Object other) {
     if (other instanceof Address) {
       Address that = (Address) other;
@@ -120,21 +147,27 @@ public Proxy getProxy() {
           && this.uriPort == that.uriPort
           && equal(this.sslSocketFactory, that.sslSocketFactory)
           && equal(this.hostnameVerifier, that.hostnameVerifier)
+          && equal(this.certificatePinner, that.certificatePinner)
           && equal(this.authenticator, that.authenticator)
-          && equal(this.transports, that.transports);
+          && equal(this.protocols, that.protocols)
+          && equal(this.connectionSpecs, that.connectionSpecs)
+          && equal(this.proxySelector, that.proxySelector);
     }
     return false;
   }
 
   @Override public int hashCode() {
     int result = 17;
+    result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
     result = 31 * result + uriHost.hashCode();
     result = 31 * result + uriPort;
     result = 31 * result + (sslSocketFactory != null ? sslSocketFactory.hashCode() : 0);
     result = 31 * result + (hostnameVerifier != null ? hostnameVerifier.hashCode() : 0);
-    result = 31 * result + (authenticator != null ? authenticator.hashCode() : 0);
-    result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
-    result = 31 * result + transports.hashCode();
+    result = 31 * result + (certificatePinner != null ? certificatePinner.hashCode() : 0);
+    result = 31 * result + authenticator.hashCode();
+    result = 31 * result + protocols.hashCode();
+    result = 31 * result + connectionSpecs.hashCode();
+    result = 31 * result + proxySelector.hashCode();
     return result;
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java b/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java
new file mode 100644
index 0000000000..cb66dc6249
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+import java.net.Proxy;
+
+/**
+ * Responds to authentication challenges from the remote web or proxy server.
+ */
+public interface Authenticator {
+  /**
+   * Returns a request that includes a credential to satisfy an authentication
+   * challenge in {@code response}. Returns null if the challenge cannot be
+   * satisfied. This method is called in response to an HTTP 401 unauthorized
+   * status code sent by the origin server.
+   *
+   * <p>Typical implementations will look up a credential and create a request
+   * derived from the initial request by setting the "Authorization" header.
+   * <pre>   {@code
+   *
+   *    String credential = Credentials.basic(...)
+   *    return response.request().newBuilder()
+   *        .header("Authorization", credential)
+   *        .build();
+   * }</pre>
+   */
+  Request authenticate(Proxy proxy, Response response) throws IOException;
+
+  /**
+   * Returns a request that includes a credential to satisfy an authentication
+   * challenge made by {@code response}. Returns null if the challenge cannot be
+   * satisfied. This method is called in response to an HTTP 407 unauthorized
+   * status code sent by the proxy server.
+   *
+   * <p>Typical implementations will look up a credential and create a request
+   * derived from the initial request by setting the "Proxy-Authorization"
+   * header. <pre>   {@code
+   *
+   *    String credential = Credentials.basic(...)
+   *    return response.request().newBuilder()
+   *        .header("Proxy-Authorization", credential)
+   *        .build();
+   * }</pre>
+   */
+  Request authenticateProxy(Proxy proxy, Response response) throws IOException;
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Cache.java b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
new file mode 100644
index 0000000000..231a664362
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
@@ -0,0 +1,677 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.DiskLruCache;
+import com.squareup.okhttp.internal.InternalCache;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.CacheRequest;
+import com.squareup.okhttp.internal.http.CacheStrategy;
+import com.squareup.okhttp.internal.http.HttpMethod;
+import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.StatusLine;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateEncodingException;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.NoSuchElementException;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.ForwardingSink;
+import okio.ForwardingSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+/**
+ * Caches HTTP and HTTPS responses to the filesystem so they may be reused,
+ * saving time and bandwidth.
+ *
+ * <h3>Cache Optimization</h3>
+ * To measure cache effectiveness, this class tracks three statistics:
+ * <ul>
+ *     <li><strong>{@linkplain #getRequestCount() Request Count:}</strong> the
+ *         number of HTTP requests issued since this cache was created.
+ *     <li><strong>{@linkplain #getNetworkCount() Network Count:}</strong> the
+ *         number of those requests that required network use.
+ *     <li><strong>{@linkplain #getHitCount() Hit Count:}</strong> the number of
+ *         those requests whose responses were served by the cache.
+ * </ul>
+ * Sometimes a request will result in a conditional cache hit. If the cache
+ * contains a stale copy of the response, the client will issue a conditional
+ * {@code GET}. The server will then send either the updated response if it has
+ * changed, or a short 'not modified' response if the client's copy is still
+ * valid. Such responses increment both the network count and hit count.
+ *
+ * <p>The best way to improve the cache hit rate is by configuring the web
+ * server to return cacheable responses. Although this client honors all <a
+ * href="http://www.ietf.org/rfc/rfc2616.txt">HTTP/1.1 (RFC 2068)</a> cache
+ * headers, it doesn't cache partial responses.
+ *
+ * <h3>Force a Network Response</h3>
+ * In some situations, such as after a user clicks a 'refresh' button, it may be
+ * necessary to skip the cache, and fetch data directly from the server. To force
+ * a full refresh, add the {@code no-cache} directive: <pre>   {@code
+ *         connection.addRequestProperty("Cache-Control", "no-cache");
+ * }</pre>
+ * If it is only necessary to force a cached response to be validated by the
+ * server, use the more efficient {@code max-age=0} instead: <pre>   {@code
+ *         connection.addRequestProperty("Cache-Control", "max-age=0");
+ * }</pre>
+ *
+ * <h3>Force a Cache Response</h3>
+ * Sometimes you'll want to show resources if they are available immediately,
+ * but not otherwise. This can be used so your application can show
+ * <i>something</i> while waiting for the latest data to be downloaded. To
+ * restrict a request to locally-cached resources, add the {@code
+ * only-if-cached} directive: <pre>   {@code
+ *     try {
+ *         connection.addRequestProperty("Cache-Control", "only-if-cached");
+ *         InputStream cached = connection.getInputStream();
+ *         // the resource was cached! show it
+ *     } catch (FileNotFoundException e) {
+ *         // the resource was not cached
+ *     }
+ * }</pre>
+ * This technique works even better in situations where a stale response is
+ * better than no response. To permit stale cached responses, use the {@code
+ * max-stale} directive with the maximum staleness in seconds: <pre>   {@code
+ *         int maxStale = 60 * 60 * 24 * 28; // tolerate 4-weeks stale
+ *         connection.addRequestProperty("Cache-Control", "max-stale=" + maxStale);
+ * }</pre>
+ */
+public final class Cache {
+  private static final int VERSION = 201105;
+  private static final int ENTRY_METADATA = 0;
+  private static final int ENTRY_BODY = 1;
+  private static final int ENTRY_COUNT = 2;
+
+  final InternalCache internalCache = new InternalCache() {
+    @Override public Response get(Request request) throws IOException {
+      return Cache.this.get(request);
+    }
+    @Override public CacheRequest put(Response response) throws IOException {
+      return Cache.this.put(response);
+    }
+    @Override public void remove(Request request) throws IOException {
+      Cache.this.remove(request);
+    }
+    @Override public void update(Response cached, Response network) throws IOException {
+      Cache.this.update(cached, network);
+    }
+    @Override public void trackConditionalCacheHit() {
+      Cache.this.trackConditionalCacheHit();
+    }
+    @Override public void trackResponse(CacheStrategy cacheStrategy) {
+      Cache.this.trackResponse(cacheStrategy);
+    }
+  };
+
+  private final DiskLruCache cache;
+
+  /* read and write statistics, all guarded by 'this' */
+  private int writeSuccessCount;
+  private int writeAbortCount;
+  private int networkCount;
+  private int hitCount;
+  private int requestCount;
+
+  public Cache(File directory, long maxSize) throws IOException {
+    cache = DiskLruCache.open(directory, VERSION, ENTRY_COUNT, maxSize);
+  }
+
+  private static String urlToKey(Request request) {
+    return Util.md5Hex(request.urlString());
+  }
+
+  Response get(Request request) {
+    String key = urlToKey(request);
+    DiskLruCache.Snapshot snapshot;
+    Entry entry;
+    try {
+      snapshot = cache.get(key);
+      if (snapshot == null) {
+        return null;
+      }
+    } catch (IOException e) {
+      // Give up because the cache cannot be read.
+      return null;
+    }
+
+    try {
+      entry = new Entry(snapshot.getSource(ENTRY_METADATA));
+    } catch (IOException e) {
+      Util.closeQuietly(snapshot);
+      return null;
+    }
+
+    Response response = entry.response(request, snapshot);
+
+    if (!entry.matches(request, response)) {
+      Util.closeQuietly(response.body());
+      return null;
+    }
+
+    return response;
+  }
+
+  private CacheRequest put(Response response) throws IOException {
+    String requestMethod = response.request().method();
+
+    if (HttpMethod.invalidatesCache(response.request().method())) {
+      try {
+        remove(response.request());
+      } catch (IOException ignored) {
+        // The cache cannot be written.
+      }
+      return null;
+    }
+    if (!requestMethod.equals("GET")) {
+      // Don't cache non-GET responses. We're technically allowed to cache
+      // HEAD requests and some POST requests, but the complexity of doing
+      // so is high and the benefit is low.
+      return null;
+    }
+
+    if (OkHeaders.hasVaryAll(response)) {
+      return null;
+    }
+
+    Entry entry = new Entry(response);
+    DiskLruCache.Editor editor = null;
+    try {
+      editor = cache.edit(urlToKey(response.request()));
+      if (editor == null) {
+        return null;
+      }
+      entry.writeTo(editor);
+      return new CacheRequestImpl(editor);
+    } catch (IOException e) {
+      abortQuietly(editor);
+      return null;
+    }
+  }
+
+  private void remove(Request request) throws IOException {
+    cache.remove(urlToKey(request));
+  }
+
+  private void update(Response cached, Response network) {
+    Entry entry = new Entry(network);
+    DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
+    DiskLruCache.Editor editor = null;
+    try {
+      editor = snapshot.edit(); // Returns null if snapshot is not current.
+      if (editor != null) {
+        entry.writeTo(editor);
+        editor.commit();
+      }
+    } catch (IOException e) {
+      abortQuietly(editor);
+    }
+  }
+
+  private void abortQuietly(DiskLruCache.Editor editor) {
+    // Give up because the cache cannot be written.
+    try {
+      if (editor != null) {
+        editor.abort();
+      }
+    } catch (IOException ignored) {
+    }
+  }
+
+  /**
+   * Closes the cache and deletes all of its stored values. This will delete
+   * all files in the cache directory including files that weren't created by
+   * the cache.
+   */
+  public void delete() throws IOException {
+    cache.delete();
+  }
+
+  /**
+   * Deletes all values stored in the cache. In-flight writes to the cache will
+   * complete normally, but the corresponding responses will not be stored.
+   */
+  public void evictAll() throws IOException {
+    cache.evictAll();
+  }
+
+  /**
+   * Returns an iterator over the URLs in this cache. This iterator doesn't throw {@code
+   * ConcurrentModificationException}, but if new responses are added while iterating, their URLs
+   * will not be returned. If existing responses are evicted during iteration, they will be absent
+   * (unless they were already returned).
+   *
+   * <p>The iterator supports {@linkplain Iterator#remove}. Removing a URL from the iterator evicts
+   * the corresponding response from the cache. Use this to evict selected responses.
+   */
+  public Iterator<String> urls() {
+    return new Iterator<String>() {
+      final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
+
+      String nextUrl;
+      boolean canRemove;
+
+      @Override public boolean hasNext() {
+        if (nextUrl != null) return true;
+
+        canRemove = false; // Prevent delegate.remove() on the wrong item!
+        while (delegate.hasNext()) {
+          DiskLruCache.Snapshot snapshot = delegate.next();
+          try {
+            BufferedSource metadata = Okio.buffer(snapshot.getSource(ENTRY_METADATA));
+            nextUrl = metadata.readUtf8LineStrict();
+            return true;
+          } catch (IOException ignored) {
+            // We couldn't read the metadata for this snapshot; possibly because the host filesystem
+            // has disappeared! Skip it.
+          } finally {
+            snapshot.close();
+          }
+        }
+
+        return false;
+      }
+
+      @Override public String next() {
+        if (!hasNext()) throw new NoSuchElementException();
+        String result = nextUrl;
+        nextUrl = null;
+        canRemove = true;
+        return result;
+      }
+
+      @Override public void remove() {
+        if (!canRemove) throw new IllegalStateException("remove() before next()");
+        delegate.remove();
+      }
+    };
+  }
+
+  public synchronized int getWriteAbortCount() {
+    return writeAbortCount;
+  }
+
+  public synchronized int getWriteSuccessCount() {
+    return writeSuccessCount;
+  }
+
+  public long getSize() {
+    return cache.size();
+  }
+
+  public long getMaxSize() {
+    return cache.getMaxSize();
+  }
+
+  public void flush() throws IOException {
+    cache.flush();
+  }
+
+  public void close() throws IOException {
+    cache.close();
+  }
+
+  public File getDirectory() {
+    return cache.getDirectory();
+  }
+
+  public boolean isClosed() {
+    return cache.isClosed();
+  }
+
+  private synchronized void trackResponse(CacheStrategy cacheStrategy) {
+    requestCount++;
+
+    if (cacheStrategy.networkRequest != null) {
+      // If this is a conditional request, we'll increment hitCount if/when it hits.
+      networkCount++;
+
+    } else if (cacheStrategy.cacheResponse != null) {
+      // This response uses the cache and not the network. That's a cache hit.
+      hitCount++;
+    }
+  }
+
+  private synchronized void trackConditionalCacheHit() {
+    hitCount++;
+  }
+
+  public synchronized int getNetworkCount() {
+    return networkCount;
+  }
+
+  public synchronized int getHitCount() {
+    return hitCount;
+  }
+
+  public synchronized int getRequestCount() {
+    return requestCount;
+  }
+
+  private final class CacheRequestImpl implements CacheRequest {
+    private final DiskLruCache.Editor editor;
+    private Sink cacheOut;
+    private boolean done;
+    private Sink body;
+
+    public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
+      this.editor = editor;
+      this.cacheOut = editor.newSink(ENTRY_BODY);
+      this.body = new ForwardingSink(cacheOut) {
+        @Override public void close() throws IOException {
+          synchronized (Cache.this) {
+            if (done) {
+              return;
+            }
+            done = true;
+            writeSuccessCount++;
+          }
+          super.close();
+          editor.commit();
+        }
+      };
+    }
+
+    @Override public void abort() {
+      synchronized (Cache.this) {
+        if (done) {
+          return;
+        }
+        done = true;
+        writeAbortCount++;
+      }
+      Util.closeQuietly(cacheOut);
+      try {
+        editor.abort();
+      } catch (IOException ignored) {
+      }
+    }
+
+    @Override public Sink body() {
+      return body;
+    }
+  }
+
+  private static final class Entry {
+    private final String url;
+    private final Headers varyHeaders;
+    private final String requestMethod;
+    private final Protocol protocol;
+    private final int code;
+    private final String message;
+    private final Headers responseHeaders;
+    private final Handshake handshake;
+
+    /**
+     * Reads an entry from an input stream. A typical entry looks like this:
+     * <pre>{@code
+     *   http://google.com/foo
+     *   GET
+     *   2
+     *   Accept-Language: fr-CA
+     *   Accept-Charset: UTF-8
+     *   HTTP/1.1 200 OK
+     *   3
+     *   Content-Type: image/png
+     *   Content-Length: 100
+     *   Cache-Control: max-age=600
+     * }</pre>
+     *
+     * <p>A typical HTTPS file looks like this:
+     * <pre>{@code
+     *   https://google.com/foo
+     *   GET
+     *   2
+     *   Accept-Language: fr-CA
+     *   Accept-Charset: UTF-8
+     *   HTTP/1.1 200 OK
+     *   3
+     *   Content-Type: image/png
+     *   Content-Length: 100
+     *   Cache-Control: max-age=600
+     *
+     *   AES_256_WITH_MD5
+     *   2
+     *   base64-encoded peerCertificate[0]
+     *   base64-encoded peerCertificate[1]
+     *   -1
+     * }</pre>
+     * The file is newline separated. The first two lines are the URL and
+     * the request method. Next is the number of HTTP Vary request header
+     * lines, followed by those lines.
+     *
+     * <p>Next is the response status line, followed by the number of HTTP
+     * response header lines, followed by those lines.
+     *
+     * <p>HTTPS responses also contain SSL session information. This begins
+     * with a blank line, and then a line containing the cipher suite. Next
+     * is the length of the peer certificate chain. These certificates are
+     * base64-encoded and appear each on their own line. The next line
+     * contains the length of the local certificate chain. These
+     * certificates are also base64-encoded and appear each on their own
+     * line. A length of -1 is used to encode a null array.
+     */
+    public Entry(Source in) throws IOException {
+      try {
+        BufferedSource source = Okio.buffer(in);
+        url = source.readUtf8LineStrict();
+        requestMethod = source.readUtf8LineStrict();
+        Headers.Builder varyHeadersBuilder = new Headers.Builder();
+        int varyRequestHeaderLineCount = readInt(source);
+        for (int i = 0; i < varyRequestHeaderLineCount; i++) {
+          varyHeadersBuilder.addLenient(source.readUtf8LineStrict());
+        }
+        varyHeaders = varyHeadersBuilder.build();
+
+        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+        protocol = statusLine.protocol;
+        code = statusLine.code;
+        message = statusLine.message;
+        Headers.Builder responseHeadersBuilder = new Headers.Builder();
+        int responseHeaderLineCount = readInt(source);
+        for (int i = 0; i < responseHeaderLineCount; i++) {
+          responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
+        }
+        responseHeaders = responseHeadersBuilder.build();
+
+        if (isHttps()) {
+          String blank = source.readUtf8LineStrict();
+          if (blank.length() > 0) {
+            throw new IOException("expected \"\" but was \"" + blank + "\"");
+          }
+          String cipherSuite = source.readUtf8LineStrict();
+          List<Certificate> peerCertificates = readCertificateList(source);
+          List<Certificate> localCertificates = readCertificateList(source);
+          handshake = Handshake.get(cipherSuite, peerCertificates, localCertificates);
+        } else {
+          handshake = null;
+        }
+      } finally {
+        in.close();
+      }
+    }
+
+    public Entry(Response response) {
+      this.url = response.request().urlString();
+      this.varyHeaders = OkHeaders.varyHeaders(response);
+      this.requestMethod = response.request().method();
+      this.protocol = response.protocol();
+      this.code = response.code();
+      this.message = response.message();
+      this.responseHeaders = response.headers();
+      this.handshake = response.handshake();
+    }
+
+    public void writeTo(DiskLruCache.Editor editor) throws IOException {
+      BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
+
+      sink.writeUtf8(url);
+      sink.writeByte('\n');
+      sink.writeUtf8(requestMethod);
+      sink.writeByte('\n');
+      sink.writeUtf8(Integer.toString(varyHeaders.size()));
+      sink.writeByte('\n');
+      for (int i = 0, size = varyHeaders.size(); i < size; i++) {
+        sink.writeUtf8(varyHeaders.name(i));
+        sink.writeUtf8(": ");
+        sink.writeUtf8(varyHeaders.value(i));
+        sink.writeByte('\n');
+      }
+
+      sink.writeUtf8(new StatusLine(protocol, code, message).toString());
+      sink.writeByte('\n');
+      sink.writeUtf8(Integer.toString(responseHeaders.size()));
+      sink.writeByte('\n');
+      for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+        sink.writeUtf8(responseHeaders.name(i));
+        sink.writeUtf8(": ");
+        sink.writeUtf8(responseHeaders.value(i));
+        sink.writeByte('\n');
+      }
+
+      if (isHttps()) {
+        sink.writeByte('\n');
+        sink.writeUtf8(handshake.cipherSuite());
+        sink.writeByte('\n');
+        writeCertArray(sink, handshake.peerCertificates());
+        writeCertArray(sink, handshake.localCertificates());
+      }
+      sink.close();
+    }
+
+    private boolean isHttps() {
+      return url.startsWith("https://");
+    }
+
+    private List<Certificate> readCertificateList(BufferedSource source) throws IOException {
+      int length = readInt(source);
+      if (length == -1) return Collections.emptyList(); // OkHttp v1.2 used -1 to indicate null.
+
+      try {
+        CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
+        List<Certificate> result = new ArrayList<>(length);
+        for (int i = 0; i < length; i++) {
+          String line = source.readUtf8LineStrict();
+          byte[] bytes = ByteString.decodeBase64(line).toByteArray();
+          result.add(certificateFactory.generateCertificate(new ByteArrayInputStream(bytes)));
+        }
+        return result;
+      } catch (CertificateException e) {
+        throw new IOException(e.getMessage());
+      }
+    }
+
+    private void writeCertArray(BufferedSink sink, List<Certificate> certificates)
+        throws IOException {
+      try {
+        sink.writeUtf8(Integer.toString(certificates.size()));
+        sink.writeByte('\n');
+        for (int i = 0, size = certificates.size(); i < size; i++) {
+          byte[] bytes = certificates.get(i).getEncoded();
+          String line = ByteString.of(bytes).base64();
+          sink.writeUtf8(line);
+          sink.writeByte('\n');
+        }
+      } catch (CertificateEncodingException e) {
+        throw new IOException(e.getMessage());
+      }
+    }
+
+    public boolean matches(Request request, Response response) {
+      return url.equals(request.urlString())
+          && requestMethod.equals(request.method())
+          && OkHeaders.varyMatches(response, varyHeaders, request);
+    }
+
+    public Response response(Request request, DiskLruCache.Snapshot snapshot) {
+      String contentType = responseHeaders.get("Content-Type");
+      String contentLength = responseHeaders.get("Content-Length");
+      Request cacheRequest = new Request.Builder()
+          .url(url)
+          .method(requestMethod, null)
+          .headers(varyHeaders)
+          .build();
+      return new Response.Builder()
+          .request(cacheRequest)
+          .protocol(protocol)
+          .code(code)
+          .message(message)
+          .headers(responseHeaders)
+          .body(new CacheResponseBody(snapshot, contentType, contentLength))
+          .handshake(handshake)
+          .build();
+    }
+  }
+
+  private static int readInt(BufferedSource source) throws IOException {
+    String line = source.readUtf8LineStrict();
+    try {
+      return Integer.parseInt(line);
+    } catch (NumberFormatException e) {
+      throw new IOException("Expected an integer but was \"" + line + "\"");
+    }
+  }
+
+  private static class CacheResponseBody extends ResponseBody {
+    private final DiskLruCache.Snapshot snapshot;
+    private final BufferedSource bodySource;
+    private final String contentType;
+    private final String contentLength;
+
+    public CacheResponseBody(final DiskLruCache.Snapshot snapshot,
+        String contentType, String contentLength) {
+      this.snapshot = snapshot;
+      this.contentType = contentType;
+      this.contentLength = contentLength;
+
+      Source source = snapshot.getSource(ENTRY_BODY);
+      bodySource = Okio.buffer(new ForwardingSource(source) {
+        @Override public void close() throws IOException {
+          snapshot.close();
+          super.close();
+        }
+      });
+    }
+
+    @Override public MediaType contentType() {
+      return contentType != null ? MediaType.parse(contentType) : null;
+    }
+
+    @Override public long contentLength() {
+      try {
+        return contentLength != null ? Long.parseLong(contentLength) : -1;
+      } catch (NumberFormatException e) {
+        return -1;
+      }
+    }
+
+    @Override public BufferedSource source() {
+      return bodySource;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java b/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
new file mode 100644
index 0000000000..36d2ff6f04
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
@@ -0,0 +1,330 @@
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.http.HeaderParser;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A Cache-Control header with cache directives from a server or client. These
+ * directives set policy on what responses can be stored, and which requests can
+ * be satisfied by those stored responses.
+ *
+ * <p>See <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">RFC
+ * 2616, 14.9</a>.
+ */
+public final class CacheControl {
+  /**
+   * Cache control request directives that require network validation of
+   * responses. Note that such requests may be assisted by the cache via
+   * conditional GET requests.
+   */
+  public static final CacheControl FORCE_NETWORK = new Builder().noCache().build();
+
+  /**
+   * Cache control request directives that uses the cache only, even if the
+   * cached response is stale. If the response isn't available in the cache or
+   * requires server validation, the call will fail with a {@code 504
+   * Unsatisfiable Request}.
+   */
+  public static final CacheControl FORCE_CACHE = new Builder()
+      .onlyIfCached()
+      .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)
+      .build();
+
+  private final boolean noCache;
+  private final boolean noStore;
+  private final int maxAgeSeconds;
+  private final int sMaxAgeSeconds;
+  private final boolean isPublic;
+  private final boolean mustRevalidate;
+  private final int maxStaleSeconds;
+  private final int minFreshSeconds;
+  private final boolean onlyIfCached;
+  private final boolean noTransform;
+
+  private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
+      boolean isPublic, boolean mustRevalidate, int maxStaleSeconds, int minFreshSeconds,
+      boolean onlyIfCached, boolean noTransform) {
+    this.noCache = noCache;
+    this.noStore = noStore;
+    this.maxAgeSeconds = maxAgeSeconds;
+    this.sMaxAgeSeconds = sMaxAgeSeconds;
+    this.isPublic = isPublic;
+    this.mustRevalidate = mustRevalidate;
+    this.maxStaleSeconds = maxStaleSeconds;
+    this.minFreshSeconds = minFreshSeconds;
+    this.onlyIfCached = onlyIfCached;
+    this.noTransform = noTransform;
+  }
+
+  private CacheControl(Builder builder) {
+    this.noCache = builder.noCache;
+    this.noStore = builder.noStore;
+    this.maxAgeSeconds = builder.maxAgeSeconds;
+    this.sMaxAgeSeconds = -1;
+    this.isPublic = false;
+    this.mustRevalidate = false;
+    this.maxStaleSeconds = builder.maxStaleSeconds;
+    this.minFreshSeconds = builder.minFreshSeconds;
+    this.onlyIfCached = builder.onlyIfCached;
+    this.noTransform = builder.noTransform;
+  }
+
+  /**
+   * In a response, this field's name "no-cache" is misleading. It doesn't
+   * prevent us from caching the response; it only means we have to validate the
+   * response with the origin server before returning it. We can do this with a
+   * conditional GET.
+   *
+   * <p>In a request, it means do not use a cache to satisfy the request.
+   */
+  public boolean noCache() {
+    return noCache;
+  }
+
+  /** If true, this response should not be cached. */
+  public boolean noStore() {
+    return noStore;
+  }
+
+  /**
+   * The duration past the response's served date that it can be served without
+   * validation.
+   */
+  public int maxAgeSeconds() {
+    return maxAgeSeconds;
+  }
+
+  /**
+   * The "s-maxage" directive is the max age for shared caches. Not to be
+   * confused with "max-age" for non-shared caches, As in Firefox and Chrome,
+   * this directive is not honored by this cache.
+   */
+  public int sMaxAgeSeconds() {
+    return sMaxAgeSeconds;
+  }
+
+  public boolean isPublic() {
+    return isPublic;
+  }
+
+  public boolean mustRevalidate() {
+    return mustRevalidate;
+  }
+
+  public int maxStaleSeconds() {
+    return maxStaleSeconds;
+  }
+
+  public int minFreshSeconds() {
+    return minFreshSeconds;
+  }
+
+  /**
+   * This field's name "only-if-cached" is misleading. It actually means "do
+   * not use the network". It is set by a client who only wants to make a
+   * request if it can be fully satisfied by the cache. Cached responses that
+   * would require validation (ie. conditional gets) are not permitted if this
+   * header is set.
+   */
+  public boolean onlyIfCached() {
+    return onlyIfCached;
+  }
+
+  public boolean noTransform() {
+    return noTransform;
+  }
+
+  /**
+   * Returns the cache directives of {@code headers}. This honors both
+   * Cache-Control and Pragma headers if they are present.
+   */
+  public static CacheControl parse(Headers headers) {
+    boolean noCache = false;
+    boolean noStore = false;
+    int maxAgeSeconds = -1;
+    int sMaxAgeSeconds = -1;
+    boolean isPublic = false;
+    boolean mustRevalidate = false;
+    int maxStaleSeconds = -1;
+    int minFreshSeconds = -1;
+    boolean onlyIfCached = false;
+    boolean noTransform = false;
+
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      if (!headers.name(i).equalsIgnoreCase("Cache-Control")
+          && !headers.name(i).equalsIgnoreCase("Pragma")) {
+        continue;
+      }
+
+      String string = headers.value(i);
+      int pos = 0;
+      while (pos < string.length()) {
+        int tokenStart = pos;
+        pos = HeaderParser.skipUntil(string, pos, "=,;");
+        String directive = string.substring(tokenStart, pos).trim();
+        String parameter;
+
+        if (pos == string.length() || string.charAt(pos) == ',' || string.charAt(pos) == ';') {
+          pos++; // consume ',' or ';' (if necessary)
+          parameter = null;
+        } else {
+          pos++; // consume '='
+          pos = HeaderParser.skipWhitespace(string, pos);
+
+          // quoted string
+          if (pos < string.length() && string.charAt(pos) == '\"') {
+            pos++; // consume '"' open quote
+            int parameterStart = pos;
+            pos = HeaderParser.skipUntil(string, pos, "\"");
+            parameter = string.substring(parameterStart, pos);
+            pos++; // consume '"' close quote (if necessary)
+
+            // unquoted string
+          } else {
+            int parameterStart = pos;
+            pos = HeaderParser.skipUntil(string, pos, ",;");
+            parameter = string.substring(parameterStart, pos).trim();
+          }
+        }
+
+        if ("no-cache".equalsIgnoreCase(directive)) {
+          noCache = true;
+        } else if ("no-store".equalsIgnoreCase(directive)) {
+          noStore = true;
+        } else if ("max-age".equalsIgnoreCase(directive)) {
+          maxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
+        } else if ("s-maxage".equalsIgnoreCase(directive)) {
+          sMaxAgeSeconds = HeaderParser.parseSeconds(parameter, -1);
+        } else if ("public".equalsIgnoreCase(directive)) {
+          isPublic = true;
+        } else if ("must-revalidate".equalsIgnoreCase(directive)) {
+          mustRevalidate = true;
+        } else if ("max-stale".equalsIgnoreCase(directive)) {
+          maxStaleSeconds = HeaderParser.parseSeconds(parameter, Integer.MAX_VALUE);
+        } else if ("min-fresh".equalsIgnoreCase(directive)) {
+          minFreshSeconds = HeaderParser.parseSeconds(parameter, -1);
+        } else if ("only-if-cached".equalsIgnoreCase(directive)) {
+          onlyIfCached = true;
+        } else if ("no-transform".equalsIgnoreCase(directive)) {
+          noTransform = true;
+        }
+      }
+    }
+
+    return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPublic,
+        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform);
+  }
+
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder();
+    if (noCache) result.append("no-cache, ");
+    if (noStore) result.append("no-store, ");
+    if (maxAgeSeconds != -1) result.append("max-age=").append(maxAgeSeconds).append(", ");
+    if (sMaxAgeSeconds != -1) result.append("s-maxage=").append(sMaxAgeSeconds).append(", ");
+    if (isPublic) result.append("public, ");
+    if (mustRevalidate) result.append("must-revalidate, ");
+    if (maxStaleSeconds != -1) result.append("max-stale=").append(maxStaleSeconds).append(", ");
+    if (minFreshSeconds != -1) result.append("min-fresh=").append(minFreshSeconds).append(", ");
+    if (onlyIfCached) result.append("only-if-cached, ");
+    if (noTransform) result.append("no-transform, ");
+    if (result.length() == 0) return "";
+    result.delete(result.length() - 2, result.length());
+    return result.toString();
+  }
+
+  /** Builds a {@code Cache-Control} request header. */
+  public static final class Builder {
+    boolean noCache;
+    boolean noStore;
+    int maxAgeSeconds = -1;
+    int maxStaleSeconds = -1;
+    int minFreshSeconds = -1;
+    boolean onlyIfCached;
+    boolean noTransform;
+
+    /** Don't accept an unvalidated cached response. */
+    public Builder noCache() {
+      this.noCache = true;
+      return this;
+    }
+
+    /** Don't store the server's response in any cache. */
+    public Builder noStore() {
+      this.noStore = true;
+      return this;
+    }
+
+    /**
+     * Sets the maximum age of a cached response. If the cache response's age
+     * exceeds {@code maxAge}, it will not be used and a network request will
+     * be made.
+     *
+     * @param maxAge a non-negative integer. This is stored and transmitted with
+     *     {@link TimeUnit#SECONDS} precision; finer precision will be lost.
+     */
+    public Builder maxAge(int maxAge, TimeUnit timeUnit) {
+      if (maxAge < 0) throw new IllegalArgumentException("maxAge < 0: " + maxAge);
+      long maxAgeSecondsLong = timeUnit.toSeconds(maxAge);
+      this.maxAgeSeconds = maxAgeSecondsLong > Integer.MAX_VALUE
+          ? Integer.MAX_VALUE
+          : (int) maxAgeSecondsLong;
+      return this;
+    }
+
+    /**
+     * Accept cached responses that have exceeded their freshness lifetime by
+     * up to {@code maxStale}. If unspecified, stale cache responses will not be
+     * used.
+     *
+     * @param maxStale a non-negative integer. This is stored and transmitted
+     *     with {@link TimeUnit#SECONDS} precision; finer precision will be
+     *     lost.
+     */
+    public Builder maxStale(int maxStale, TimeUnit timeUnit) {
+      if (maxStale < 0) throw new IllegalArgumentException("maxStale < 0: " + maxStale);
+      long maxStaleSecondsLong = timeUnit.toSeconds(maxStale);
+      this.maxStaleSeconds = maxStaleSecondsLong > Integer.MAX_VALUE
+          ? Integer.MAX_VALUE
+          : (int) maxStaleSecondsLong;
+      return this;
+    }
+
+    /**
+     * Sets the minimum number of seconds that a response will continue to be
+     * fresh for. If the response will be stale when {@code minFresh} have
+     * elapsed, the cached response will not be used and a network request will
+     * be made.
+     *
+     * @param minFresh a non-negative integer. This is stored and transmitted
+     *     with {@link TimeUnit#SECONDS} precision; finer precision will be
+     *     lost.
+     */
+    public Builder minFresh(int minFresh, TimeUnit timeUnit) {
+      if (minFresh < 0) throw new IllegalArgumentException("minFresh < 0: " + minFresh);
+      long minFreshSecondsLong = timeUnit.toSeconds(minFresh);
+      this.minFreshSeconds = minFreshSecondsLong > Integer.MAX_VALUE
+          ? Integer.MAX_VALUE
+          : (int) minFreshSecondsLong;
+      return this;
+    }
+
+    /**
+     * Only accept the response if it is in the cache. If the response isn't
+     * cached, a {@code 504 Unsatisfiable Request} response will be returned.
+     */
+    public Builder onlyIfCached() {
+      this.onlyIfCached = true;
+      return this;
+    }
+
+    /** Don't accept a transformed response. */
+    public Builder noTransform() {
+      this.noTransform = true;
+      return this;
+    }
+
+    public CacheControl build() {
+      return new CacheControl(this);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
new file mode 100644
index 0000000000..c4742c2799
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -0,0 +1,308 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.NamedRunnable;
+import com.squareup.okhttp.internal.http.HttpEngine;
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.ProtocolException;
+import java.net.URL;
+import java.util.logging.Level;
+
+import static com.squareup.okhttp.internal.Internal.logger;
+import static com.squareup.okhttp.internal.http.HttpEngine.MAX_FOLLOW_UPS;
+
+/**
+ * A call is a request that has been prepared for execution. A call can be
+ * canceled. As this object represents a single request/response pair (stream),
+ * it cannot be executed twice.
+ */
+public class Call {
+  private final OkHttpClient client;
+
+  // Guarded by this.
+  private boolean executed;
+  volatile boolean canceled;
+
+  /** The application's original request unadulterated by redirects or auth headers. */
+  Request originalRequest;
+  HttpEngine engine;
+
+  protected Call(OkHttpClient client, Request originalRequest) {
+    // Copy the client. Otherwise changes (socket factory, redirect policy,
+    // etc.) may incorrectly be reflected in the request when it is executed.
+    this.client = client.copyWithDefaults();
+    this.originalRequest = originalRequest;
+  }
+
+  /**
+   * Invokes the request immediately, and blocks until the response can be
+   * processed or is in error.
+   *
+   * <p>The caller may read the response body with the response's
+   * {@link Response#body} method.  To facilitate connection recycling, callers
+   * should always {@link ResponseBody#close() close the response body}.
+   *
+   * <p>Note that transport-layer success (receiving a HTTP response code,
+   * headers and body) does not necessarily indicate application-layer success:
+   * {@code response} may still indicate an unhappy HTTP response code like 404
+   * or 500.
+   *
+   * @throws IOException if the request could not be executed due to
+   *     cancellation, a connectivity problem or timeout. Because networks can
+   *     fail during an exchange, it is possible that the remote server
+   *     accepted the request before the failure.
+   *
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  public Response execute() throws IOException {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already Executed");
+      executed = true;
+    }
+    try {
+      client.getDispatcher().executed(this);
+      Response result = getResponseWithInterceptorChain(false);
+      if (result == null) throw new IOException("Canceled");
+      return result;
+    } finally {
+      client.getDispatcher().finished(this);
+    }
+  }
+
+  Object tag() {
+    return originalRequest.tag();
+  }
+
+  /**
+   * Schedules the request to be executed at some point in the future.
+   *
+   * <p>The {@link OkHttpClient#getDispatcher dispatcher} defines when the
+   * request will run: usually immediately unless there are several other
+   * requests currently being executed.
+   *
+   * <p>This client will later call back {@code responseCallback} with either
+   * an HTTP response or a failure exception. If you {@link #cancel} a request
+   * before it completes the callback will not be invoked.
+   *
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  public void enqueue(Callback responseCallback) {
+    enqueue(responseCallback, false);
+  }
+
+  void enqueue(Callback responseCallback, boolean forWebSocket) {
+    synchronized (this) {
+      if (executed) throw new IllegalStateException("Already Executed");
+      executed = true;
+    }
+    client.getDispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));
+  }
+
+  /**
+   * Cancels the request, if possible. Requests that are already complete
+   * cannot be canceled.
+   */
+  public void cancel() {
+    canceled = true;
+    if (engine != null) engine.disconnect();
+  }
+
+  public boolean isCanceled() {
+    return canceled;
+  }
+
+  final class AsyncCall extends NamedRunnable {
+    private final Callback responseCallback;
+    private final boolean forWebSocket;
+
+    private AsyncCall(Callback responseCallback, boolean forWebSocket) {
+      super("OkHttp %s", originalRequest.urlString());
+      this.responseCallback = responseCallback;
+      this.forWebSocket = forWebSocket;
+    }
+
+    String host() {
+      return originalRequest.url().getHost();
+    }
+
+    Request request() {
+      return originalRequest;
+    }
+
+    Object tag() {
+      return originalRequest.tag();
+    }
+
+    void cancel() {
+      Call.this.cancel();
+    }
+
+    Call get() {
+      return Call.this;
+    }
+
+    @Override protected void execute() {
+      boolean signalledCallback = false;
+      try {
+        Response response = getResponseWithInterceptorChain(forWebSocket);
+        if (canceled) {
+          signalledCallback = true;
+          responseCallback.onFailure(originalRequest, new IOException("Canceled"));
+        } else {
+          signalledCallback = true;
+          responseCallback.onResponse(response);
+        }
+      } catch (IOException e) {
+        if (signalledCallback) {
+          // Do not signal the callback twice!
+          logger.log(Level.INFO, "Callback failure for " + toLoggableString(), e);
+        } else {
+          responseCallback.onFailure(engine.getRequest(), e);
+        }
+      } finally {
+        client.getDispatcher().finished(this);
+      }
+    }
+  }
+
+  /**
+   * Returns a string that describes this call. Doesn't include a full URL as that might contain
+   * sensitive information.
+   */
+  private String toLoggableString() {
+    String string = canceled ? "canceled call" : "call";
+    try {
+      String redactedUrl = new URL(originalRequest.url(), "/...").toString();
+      return string + " to " + redactedUrl;
+    } catch (MalformedURLException e) {
+      return string;
+    }
+  }
+
+  private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException {
+    Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);
+    return chain.proceed(originalRequest);
+  }
+
+  class ApplicationInterceptorChain implements Interceptor.Chain {
+    private final int index;
+    private final Request request;
+    private final boolean forWebSocket;
+
+    ApplicationInterceptorChain(int index, Request request, boolean forWebSocket) {
+      this.index = index;
+      this.request = request;
+      this.forWebSocket = forWebSocket;
+    }
+
+    @Override public Connection connection() {
+      return null;
+    }
+
+    @Override public Request request() {
+      return request;
+    }
+
+    @Override public Response proceed(Request request) throws IOException {
+      if (index < client.interceptors().size()) {
+        // There's another interceptor in the chain. Call that.
+        Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);
+        return client.interceptors().get(index).intercept(chain);
+      } else {
+        // No more interceptors. Do HTTP.
+        return getResponse(request, forWebSocket);
+      }
+    }
+  }
+
+  /**
+   * Performs the request and returns the response. May return null if this
+   * call was canceled.
+   */
+  Response getResponse(Request request, boolean forWebSocket) throws IOException {
+    // Copy body metadata to the appropriate request headers.
+    RequestBody body = request.body();
+    if (body != null) {
+      Request.Builder requestBuilder = request.newBuilder();
+
+      MediaType contentType = body.contentType();
+      if (contentType != null) {
+        requestBuilder.header("Content-Type", contentType.toString());
+      }
+
+      long contentLength = body.contentLength();
+      if (contentLength != -1) {
+        requestBuilder.header("Content-Length", Long.toString(contentLength));
+        requestBuilder.removeHeader("Transfer-Encoding");
+      } else {
+        requestBuilder.header("Transfer-Encoding", "chunked");
+        requestBuilder.removeHeader("Content-Length");
+      }
+
+      request = requestBuilder.build();
+    }
+
+    // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
+    engine = new HttpEngine(client, request, false, false, forWebSocket, null, null, null, null);
+
+    int followUpCount = 0;
+    while (true) {
+      if (canceled) {
+        engine.releaseConnection();
+        return null;
+      }
+
+      try {
+        engine.sendRequest();
+        engine.readResponse();
+      } catch (IOException e) {
+        HttpEngine retryEngine = engine.recover(e, null);
+        if (retryEngine != null) {
+          engine = retryEngine;
+          continue;
+        }
+
+        // Give up; recovery is not possible.
+        throw e;
+      }
+
+      Response response = engine.getResponse();
+      Request followUp = engine.followUpRequest();
+
+      if (followUp == null) {
+        if (!forWebSocket) {
+          engine.releaseConnection();
+        }
+        return response;
+      }
+
+      if (++followUpCount > MAX_FOLLOW_UPS) {
+        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
+      }
+
+      if (!engine.sameConnection(followUp.url())) {
+        engine.releaseConnection();
+      }
+
+      Connection connection = engine.close();
+      request = followUp;
+      engine = new HttpEngine(client, request, false, false, forWebSocket, connection, null, null,
+          response);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Callback.java b/okhttp/src/main/java/com/squareup/okhttp/Callback.java
new file mode 100644
index 0000000000..d86960fe05
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Callback.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+
+public interface Callback {
+  /**
+   * Called when the request could not be executed due to cancellation, a
+   * connectivity problem or timeout. Because networks can fail during an
+   * exchange, it is possible that the remote server accepted the request
+   * before the failure.
+   */
+  void onFailure(Request request, IOException e);
+
+  /**
+   * Called when the HTTP response was successfully returned by the remote
+   * server. The callback may proceed to read the response body with {@link
+   * Response#body}. The response is still live until its response body is
+   * closed with {@code response.body().close()}. The recipient of the callback
+   * may even consume the response body on another thread.
+   *
+   * <p>Note that transport-layer success (receiving a HTTP response code,
+   * headers and body) does not necessarily indicate application-layer
+   * success: {@code response} may still indicate an unhappy HTTP response
+   * code like 404 or 500.
+   */
+  void onResponse(Response response) throws IOException;
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java b/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java
new file mode 100644
index 0000000000..2c5a2af095
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okio.ByteString;
+
+import static java.util.Collections.unmodifiableList;
+
+/**
+ * Constrains which certificates are trusted. Pinning certificates defends
+ * against attacks on certificate authorities. It also prevents connections
+ * through man-in-the-middle certificate authorities either known or unknown to
+ * the application's user.
+ *
+ * <p>This class currently pins a certificate's Subject Public Key Info as
+ * described on <a href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins
+ * are base-64 SHA-1 hashes, consistent with the format Chromium uses for <a
+ * href="http://goo.gl/XDh6je">static certificates</a>. See Chromium's <a
+ * href="http://goo.gl/4CCnGs">pinsets</a> for hostnames that are pinned in that
+ * browser.
+ *
+ * <h3>Setting up Certificate Pinning</h3>
+ * The easiest way to pin a host is turn on pinning with a broken configuration
+ * and read the expected configuration when the connection fails. Be sure to
+ * do this on a trusted network, and without man-in-the-middle tools like <a
+ * href="http://charlesproxy.com">Charles</a> or <a
+ * href="http://fiddlertool.com">Fiddler</a>.
+ *
+ * <p>For example, to pin {@code https://publicobject.com}, start with a broken
+ * configuration: <pre>   {@code
+ *
+ *     String hostname = "publicobject.com";
+ *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
+ *         .add(hostname, "sha1/BOGUSPIN")
+ *         .build();
+ *     OkHttpClient client = new OkHttpClient();
+ *     client.setCertificatePinner(certificatePinner);
+ *
+ *     Request request = new Request.Builder()
+ *         .url("https://" + hostname)
+ *         .build();
+ *     client.newCall(request).execute();
+ * }</pre>
+ *
+ * As expected, this fails with a certificate pinning exception: <pre>   {@code
+ *
+ * javax.net.ssl.SSLPeerUnverifiedException: Certificate pinning failure!
+ *   Peer certificate chain:
+ *     sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=: CN=publicobject.com, OU=PositiveSSL
+ *     sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=: CN=COMODO RSA Domain Validation Secure Server CA
+ *     sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=: CN=COMODO RSA Certification Authority
+ *     sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=: CN=AddTrust External CA Root
+ *   Pinned certificates for publicobject.com:
+ *     sha1/BOGUSPIN
+ *   at com.squareup.okhttp.CertificatePinner.check(CertificatePinner.java)
+ *   at com.squareup.okhttp.Connection.upgradeToTls(Connection.java)
+ *   at com.squareup.okhttp.Connection.connect(Connection.java)
+ *   at com.squareup.okhttp.Connection.connectAndSetOwner(Connection.java)
+ * }</pre>
+ *
+ * Follow up by pasting the public key hashes from the exception into the
+ * certificate pinner's configuration: <pre>   {@code
+ *
+ *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
+ *       .add("publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+ *       .add("publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
+ *       .add("publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
+ *       .add("publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+ *       .build();
+ * }</pre>
+ *
+ * Pinning is per-hostname. To pin both {@code publicobject.com} and {@code
+ * www.publicobject.com}, you must configure both hostnames.
+ *
+ * <h3>Warning: Certificate Pinning is Dangerous!</h3>
+ * Pinning certificates limits your server team's abilities to update their TLS
+ * certificates. By pinning certificates, you take on additional operational
+ * complexity and limit your ability to migrate between certificate authorities.
+ * Do not use certificate pinning without the blessing of your server's TLS
+ * administrator!
+ */
+public final class CertificatePinner {
+  public static final CertificatePinner DEFAULT = new Builder().build();
+
+  private final Map<String, List<ByteString>> hostnameToPins;
+
+  private CertificatePinner(Builder builder) {
+    hostnameToPins = Util.immutableMap(builder.hostnameToPins);
+  }
+
+  /**
+   * Confirms that at least one of the certificates pinned for {@code hostname}
+   * is in {@code peerCertificates}. Does nothing if there are no certificates
+   * pinned for {@code hostname}. OkHttp calls this after a successful TLS
+   * handshake, but before the connection is used.
+   *
+   * @throws SSLPeerUnverifiedException if {@code peerCertificates} don't match
+   *     the certificates pinned for {@code hostname}.
+   */
+  public void check(String hostname, List<Certificate> peerCertificates)
+      throws SSLPeerUnverifiedException {
+    List<ByteString> pins = hostnameToPins.get(hostname);
+    if (pins == null) return;
+
+    for (int i = 0, size = peerCertificates.size(); i < size; i++) {
+      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
+      if (pins.contains(sha1(x509Certificate))) return; // Success!
+    }
+
+    // If we couldn't find a matching pin, format a nice exception.
+    StringBuilder message = new StringBuilder()
+        .append("Certificate pinning failure!")
+        .append("\n  Peer certificate chain:");
+    for (int i = 0, size = peerCertificates.size(); i < size; i++) {
+      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);
+      message.append("\n    ").append(pin(x509Certificate))
+          .append(": ").append(x509Certificate.getSubjectDN().getName());
+    }
+    message.append("\n  Pinned certificates for ").append(hostname).append(":");
+    for (int i = 0, size = pins.size(); i < size; i++) {
+      ByteString pin = pins.get(i);
+      message.append("\n    sha1/").append(pin.base64());
+    }
+    throw new SSLPeerUnverifiedException(message.toString());
+  }
+
+  /** @deprecated replaced with {@link #check(String, List)}. */
+  public void check(String hostname, Certificate... peerCertificates)
+      throws SSLPeerUnverifiedException {
+    check(hostname, Arrays.asList(peerCertificates));
+  }
+
+  /**
+   * Returns the SHA-1 of {@code certificate}'s public key. This uses the
+   * mechanism Moxie Marlinspike describes in <a
+   * href="https://github.com/moxie0/AndroidPinning">Android Pinning</a>.
+   */
+  public static String pin(Certificate certificate) {
+    if (!(certificate instanceof X509Certificate)) {
+      throw new IllegalArgumentException("Certificate pinning requires X509 certificates");
+    }
+    return "sha1/" + sha1((X509Certificate) certificate).base64();
+  }
+
+  private static ByteString sha1(X509Certificate x509Certificate) {
+    return Util.sha1(ByteString.of(x509Certificate.getPublicKey().getEncoded()));
+  }
+
+  /** Builds a configured certificate pinner. */
+  public static final class Builder {
+    private final Map<String, List<ByteString>> hostnameToPins = new LinkedHashMap<>();
+
+    /**
+     * Pins certificates for {@code hostname}. Each pin is a SHA-1 hash of a
+     * certificate's Subject Public Key Info, base64-encoded and prefixed with
+     * "sha1/".
+     */
+    public Builder add(String hostname, String... pins) {
+      if (hostname == null) throw new IllegalArgumentException("hostname == null");
+
+      List<ByteString> hostPins = new ArrayList<>();
+      List<ByteString> previousPins = hostnameToPins.put(hostname, unmodifiableList(hostPins));
+      if (previousPins != null) {
+        hostPins.addAll(previousPins);
+      }
+
+      for (String pin : pins) {
+        if (!pin.startsWith("sha1/")) {
+          throw new IllegalArgumentException("pins must start with 'sha1/': " + pin);
+        }
+        ByteString decodedPin = ByteString.decodeBase64(pin.substring("sha1/".length()));
+        if (decodedPin == null) {
+          throw new IllegalArgumentException("pins must be base64: " + pin);
+        }
+        hostPins.add(decodedPin);
+      }
+
+      return this;
+    }
+
+    public CertificatePinner build() {
+      return new CertificatePinner(this);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Challenge.java b/okhttp/src/main/java/com/squareup/okhttp/Challenge.java
new file mode 100644
index 0000000000..a1ef7145a0
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Challenge.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import static com.squareup.okhttp.internal.Util.equal;
+
+/** An RFC 2617 challenge. */
+public final class Challenge {
+  private final String scheme;
+  private final String realm;
+
+  public Challenge(String scheme, String realm) {
+    this.scheme = scheme;
+    this.realm = realm;
+  }
+
+  /** Returns the authentication scheme, like {@code Basic}. */
+  public String getScheme() {
+    return scheme;
+  }
+
+  /** Returns the protection space. */
+  public String getRealm() {
+    return realm;
+  }
+
+  @Override public boolean equals(Object o) {
+    return o instanceof Challenge
+        && equal(scheme, ((Challenge) o).scheme)
+        && equal(realm, ((Challenge) o).realm);
+  }
+
+  @Override public int hashCode() {
+    int result = 29;
+    result = 31 * result + (realm != null ? realm.hashCode() : 0);
+    result = 31 * result + (scheme != null ? scheme.hashCode() : 0);
+    return result;
+  }
+
+  @Override public String toString() {
+    return scheme + " realm=\"" + realm + "\"";
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java b/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java
new file mode 100644
index 0000000000..c531e213b7
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/CipherSuite.java
@@ -0,0 +1,375 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import static java.lang.Integer.MAX_VALUE;
+
+/**
+ * <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml">TLS cipher
+ * suites</a>.
+ *
+ * <p><strong>Not all cipher suites are supported on all platforms.</strong> As newer cipher suites
+ * are created (for stronger privacy, better performance, etc.) they will be adopted by the platform
+ * and then exposed here. Cipher suites that are not available on either Android (through API level
+ * 20) or Java (through JDK 8) are omitted for brevity.
+ *
+ * <p>See also <a href="https://android.googlesource.com/platform/external/conscrypt/+/master/src/main/java/org/conscrypt/NativeCrypto.java">NativeCrypto.java</a>
+ * from conscrypt, which lists the cipher suites supported by Android.
+ */
+public enum CipherSuite {
+  // Last updated 2014-11-11 using cipher suites from Android 21 and Java 8.
+
+  // TLS_NULL_WITH_NULL_NULL("TLS_NULL_WITH_NULL_NULL", 0x0000, 5246, MAX_VALUE, MAX_VALUE),
+  TLS_RSA_WITH_NULL_MD5("SSL_RSA_WITH_NULL_MD5", 0x0001, 5246, 6, 10),
+  TLS_RSA_WITH_NULL_SHA("SSL_RSA_WITH_NULL_SHA", 0x0002, 5246, 6, 10),
+  TLS_RSA_EXPORT_WITH_RC4_40_MD5("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003, 4346, 6, 10),
+  TLS_RSA_WITH_RC4_128_MD5("SSL_RSA_WITH_RC4_128_MD5", 0x0004, 5246, 6, 10),
+  TLS_RSA_WITH_RC4_128_SHA("SSL_RSA_WITH_RC4_128_SHA", 0x0005, 5246, 6, 10),
+  // TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006, 4346, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_WITH_IDEA_CBC_SHA("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007, 5469, MAX_VALUE, MAX_VALUE),
+  TLS_RSA_EXPORT_WITH_DES40_CBC_SHA("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008, 4346, 6, 10),
+  TLS_RSA_WITH_DES_CBC_SHA("SSL_RSA_WITH_DES_CBC_SHA", 0x0009, 5469, 6, 10),
+  TLS_RSA_WITH_3DES_EDE_CBC_SHA("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a, 5246, 6, 10),
+  // TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b, 4346, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_DSS_WITH_DES_CBC_SHA("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c, 5469, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d, 5246, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e, 4346, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_DES_CBC_SHA("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f, 5469, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010, 5246, MAX_VALUE, MAX_VALUE),
+  TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011, 4346, 6, 10),
+  TLS_DHE_DSS_WITH_DES_CBC_SHA("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012, 5469, 6, 10),
+  TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013, 5246, 6, 10),
+  TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014, 4346, 6, 10),
+  TLS_DHE_RSA_WITH_DES_CBC_SHA("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015, 5469, 6, 10),
+  TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016, 5246, 6, 10),
+  TLS_DH_anon_EXPORT_WITH_RC4_40_MD5("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017, 4346, 6, 10),
+  TLS_DH_anon_WITH_RC4_128_MD5("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018, 5246, 6, 10),
+  TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019, 4346, 6, 10),
+  TLS_DH_anon_WITH_DES_CBC_SHA("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a, 5469, 6, 10),
+  TLS_DH_anon_WITH_3DES_EDE_CBC_SHA("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b, 5246, 6, 10),
+  TLS_KRB5_WITH_DES_CBC_SHA("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e, 2712, 6, MAX_VALUE),
+  TLS_KRB5_WITH_3DES_EDE_CBC_SHA("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f, 2712, 6, MAX_VALUE),
+  TLS_KRB5_WITH_RC4_128_SHA("TLS_KRB5_WITH_RC4_128_SHA", 0x0020, 2712, 6, MAX_VALUE),
+  // TLS_KRB5_WITH_IDEA_CBC_SHA("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021, 2712, MAX_VALUE, MAX_VALUE),
+  TLS_KRB5_WITH_DES_CBC_MD5("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022, 2712, 6, MAX_VALUE),
+  TLS_KRB5_WITH_3DES_EDE_CBC_MD5("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023, 2712, 6, MAX_VALUE),
+  TLS_KRB5_WITH_RC4_128_MD5("TLS_KRB5_WITH_RC4_128_MD5", 0x0024, 2712, 6, MAX_VALUE),
+  // TLS_KRB5_WITH_IDEA_CBC_MD5("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025, 2712, MAX_VALUE, MAX_VALUE),
+  TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026, 2712, 6, MAX_VALUE),
+  // TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027, 2712, MAX_VALUE, MAX_VALUE),
+  TLS_KRB5_EXPORT_WITH_RC4_40_SHA("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028, 2712, 6, MAX_VALUE),
+  TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029, 2712, 6, MAX_VALUE),
+  // TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a, 2712, MAX_VALUE, MAX_VALUE),
+  TLS_KRB5_EXPORT_WITH_RC4_40_MD5("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b, 2712, 6, MAX_VALUE),
+  // TLS_PSK_WITH_NULL_SHA("TLS_PSK_WITH_NULL_SHA", 0x002c, 4785, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_NULL_SHA("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d, 4785, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_NULL_SHA("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e, 4785, MAX_VALUE, MAX_VALUE),
+  TLS_RSA_WITH_AES_128_CBC_SHA("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f, 5246, 6, 10),
+  // TLS_DH_DSS_WITH_AES_128_CBC_SHA("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030, 5246, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_AES_128_CBC_SHA("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031, 5246, MAX_VALUE, MAX_VALUE),
+  TLS_DHE_DSS_WITH_AES_128_CBC_SHA("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032, 5246, 6, 10),
+  TLS_DHE_RSA_WITH_AES_128_CBC_SHA("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033, 5246, 6, 10),
+  TLS_DH_anon_WITH_AES_128_CBC_SHA("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034, 5246, 6, 10),
+  TLS_RSA_WITH_AES_256_CBC_SHA("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035, 5246, 6, 10),
+  // TLS_DH_DSS_WITH_AES_256_CBC_SHA("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036, 5246, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_AES_256_CBC_SHA("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037, 5246, MAX_VALUE, MAX_VALUE),
+  TLS_DHE_DSS_WITH_AES_256_CBC_SHA("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038, 5246, 6, 10),
+  TLS_DHE_RSA_WITH_AES_256_CBC_SHA("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039, 5246, 6, 10),
+  TLS_DH_anon_WITH_AES_256_CBC_SHA("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a, 5246, 6, 10),
+  TLS_RSA_WITH_NULL_SHA256("TLS_RSA_WITH_NULL_SHA256", 0x003b, 5246, 7, 21),
+  TLS_RSA_WITH_AES_128_CBC_SHA256("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c, 5246, 7, 21),
+  TLS_RSA_WITH_AES_256_CBC_SHA256("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d, 5246, 7, 21),
+  // TLS_DH_DSS_WITH_AES_128_CBC_SHA256("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e, 5246, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_AES_128_CBC_SHA256("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f, 5246, MAX_VALUE, MAX_VALUE),
+  TLS_DHE_DSS_WITH_AES_128_CBC_SHA256("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040, 5246, 7, 21),
+  // TLS_RSA_WITH_CAMELLIA_128_CBC_SHA("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046, 5932, MAX_VALUE, MAX_VALUE),
+  TLS_DHE_RSA_WITH_AES_128_CBC_SHA256("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067, 5246, 7, 21),
+  // TLS_DH_DSS_WITH_AES_256_CBC_SHA256("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068, 5246, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_AES_256_CBC_SHA256("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069, 5246, MAX_VALUE, MAX_VALUE),
+  TLS_DHE_DSS_WITH_AES_256_CBC_SHA256("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a, 5246, 7, 21),
+  TLS_DHE_RSA_WITH_AES_256_CBC_SHA256("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b, 5246, 7, 21),
+  TLS_DH_anon_WITH_AES_128_CBC_SHA256("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c, 5246, 7, 21),
+  TLS_DH_anon_WITH_AES_256_CBC_SHA256("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d, 5246, 7, 21),
+  // TLS_RSA_WITH_CAMELLIA_256_CBC_SHA("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_RC4_128_SHA("TLS_PSK_WITH_RC4_128_SHA", 0x008a, 4279, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_3DES_EDE_CBC_SHA("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b, 4279, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_AES_128_CBC_SHA("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c, 4279, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_AES_256_CBC_SHA("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d, 4279, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_RC4_128_SHA("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e, 4279, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f, 4279, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_AES_128_CBC_SHA("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090, 4279, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_AES_256_CBC_SHA("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091, 4279, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_RC4_128_SHA("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092, 4279, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093, 4279, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_AES_128_CBC_SHA("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094, 4279, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_AES_256_CBC_SHA("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095, 4279, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_WITH_SEED_CBC_SHA("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096, 4162, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_DSS_WITH_SEED_CBC_SHA("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097, 4162, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_SEED_CBC_SHA("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098, 4162, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_DSS_WITH_SEED_CBC_SHA("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099, 4162, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_RSA_WITH_SEED_CBC_SHA("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a, 4162, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_anon_WITH_SEED_CBC_SHA("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b, 4162, MAX_VALUE, MAX_VALUE),
+  TLS_RSA_WITH_AES_128_GCM_SHA256("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c, 5288, 8, 21),
+  TLS_RSA_WITH_AES_256_GCM_SHA384("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d, 5288, 8, 21),
+  TLS_DHE_RSA_WITH_AES_128_GCM_SHA256("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e, 5288, 8, 21),
+  TLS_DHE_RSA_WITH_AES_256_GCM_SHA384("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f, 5288, 8, 21),
+  // TLS_DH_RSA_WITH_AES_128_GCM_SHA256("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0, 5288, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_AES_256_GCM_SHA384("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1, 5288, MAX_VALUE, MAX_VALUE),
+  TLS_DHE_DSS_WITH_AES_128_GCM_SHA256("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2, 5288, 8, 21),
+  TLS_DHE_DSS_WITH_AES_256_GCM_SHA384("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3, 5288, 8, 21),
+  // TLS_DH_DSS_WITH_AES_128_GCM_SHA256("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4, 5288, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_DSS_WITH_AES_256_GCM_SHA384("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5, 5288, MAX_VALUE, MAX_VALUE),
+  TLS_DH_anon_WITH_AES_128_GCM_SHA256("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6, 5288, 8, 21),
+  TLS_DH_anon_WITH_AES_256_GCM_SHA384("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7, 5288, 8, 21),
+  // TLS_PSK_WITH_AES_128_GCM_SHA256("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_AES_256_GCM_SHA384("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_AES_128_GCM_SHA256("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_AES_256_GCM_SHA384("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_AES_128_GCM_SHA256("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_AES_256_GCM_SHA384("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_AES_128_CBC_SHA256("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_AES_256_CBC_SHA384("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_NULL_SHA256("TLS_PSK_WITH_NULL_SHA256", 0x00b0, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_NULL_SHA384("TLS_PSK_WITH_NULL_SHA384", 0x00b1, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_AES_128_CBC_SHA256("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_AES_256_CBC_SHA384("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_NULL_SHA256("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_NULL_SHA384("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_AES_128_CBC_SHA256("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_AES_256_CBC_SHA384("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_NULL_SHA256("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_NULL_SHA384("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9, 5487, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4, 5932, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5, 5932, MAX_VALUE, MAX_VALUE),
+  TLS_EMPTY_RENEGOTIATION_INFO_SCSV("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff, 5746, 6, 14),
+  TLS_ECDH_ECDSA_WITH_NULL_SHA("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001, 4492, 7, 14),
+  TLS_ECDH_ECDSA_WITH_RC4_128_SHA("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002, 4492, 7, 14),
+  TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003, 4492, 7, 14),
+  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004, 4492, 7, 14),
+  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005, 4492, 7, 14),
+  TLS_ECDHE_ECDSA_WITH_NULL_SHA("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006, 4492, 7, 14),
+  TLS_ECDHE_ECDSA_WITH_RC4_128_SHA("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007, 4492, 7, 14),
+  TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008, 4492, 7, 14),
+  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009, 4492, 7, 14),
+  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a, 4492, 7, 14),
+  TLS_ECDH_RSA_WITH_NULL_SHA("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b, 4492, 7, 14),
+  TLS_ECDH_RSA_WITH_RC4_128_SHA("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c, 4492, 7, 14),
+  TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d, 4492, 7, 14),
+  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e, 4492, 7, 14),
+  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f, 4492, 7, 14),
+  TLS_ECDHE_RSA_WITH_NULL_SHA("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010, 4492, 7, 14),
+  TLS_ECDHE_RSA_WITH_RC4_128_SHA("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011, 4492, 7, 14),
+  TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012, 4492, 7, 14),
+  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013, 4492, 7, 14),
+  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014, 4492, 7, 14),
+  TLS_ECDH_anon_WITH_NULL_SHA("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015, 4492, 7, 14),
+  TLS_ECDH_anon_WITH_RC4_128_SHA("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016, 4492, 7, 14),
+  TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017, 4492, 7, 14),
+  TLS_ECDH_anon_WITH_AES_128_CBC_SHA("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018, 4492, 7, 14),
+  TLS_ECDH_anon_WITH_AES_256_CBC_SHA("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019, 4492, 7, 14),
+  // TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a, 5054, MAX_VALUE, MAX_VALUE),
+  // TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b, 5054, MAX_VALUE, MAX_VALUE),
+  // TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c, 5054, MAX_VALUE, MAX_VALUE),
+  // TLS_SRP_SHA_WITH_AES_128_CBC_SHA("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d, 5054, MAX_VALUE, MAX_VALUE),
+  // TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e, 5054, MAX_VALUE, MAX_VALUE),
+  // TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f, 5054, MAX_VALUE, MAX_VALUE),
+  // TLS_SRP_SHA_WITH_AES_256_CBC_SHA("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020, 5054, MAX_VALUE, MAX_VALUE),
+  // TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021, 5054, MAX_VALUE, MAX_VALUE),
+  // TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022, 5054, MAX_VALUE, MAX_VALUE),
+  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023, 5289, 7, 21),
+  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024, 5289, 7, 21),
+  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025, 5289, 7, 21),
+  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026, 5289, 7, 21),
+  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027, 5289, 7, 21),
+  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028, 5289, 7, 21),
+  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029, 5289, 7, 21),
+  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a, 5289, 7, 21),
+  TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b, 5289, 8, 21),
+  TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c, 5289, 8, 21),
+  TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d, 5289, 8, 21),
+  TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e, 5289, 8, 21),
+  TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f, 5289, 8, 21),
+  TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030, 5289, 8, 21),
+  TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031, 5289, 8, 21),
+  TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032, 5289, 8, 21),
+  // TLS_ECDHE_PSK_WITH_RC4_128_SHA("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033, 5489, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034, 5489, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035, 5489, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036, 5489, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037, 5489, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038, 5489, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_PSK_WITH_NULL_SHA("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039, 5489, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_PSK_WITH_NULL_SHA256("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a, 5489, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_PSK_WITH_NULL_SHA384("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b, 5489, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_WITH_ARIA_128_CBC_SHA256("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_WITH_ARIA_256_CBC_SHA384("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_anon_WITH_ARIA_128_CBC_SHA256("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_anon_WITH_ARIA_256_CBC_SHA384("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_WITH_ARIA_128_GCM_SHA256("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_WITH_ARIA_256_GCM_SHA384("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_anon_WITH_ARIA_128_GCM_SHA256("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_anon_WITH_ARIA_256_GCM_SHA384("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_ARIA_128_CBC_SHA256("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_ARIA_256_CBC_SHA384("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_ARIA_128_GCM_SHA256("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_ARIA_256_GCM_SHA384("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071, 6209, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b, 6367, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_WITH_AES_128_CCM("TLS_RSA_WITH_AES_128_CCM", 0xc09c, 6655, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_WITH_AES_256_CCM("TLS_RSA_WITH_AES_256_CCM", 0xc09d, 6655, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_RSA_WITH_AES_128_CCM("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e, 6655, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_RSA_WITH_AES_256_CCM("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f, 6655, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_WITH_AES_128_CCM_8("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0, 6655, MAX_VALUE, MAX_VALUE),
+  // TLS_RSA_WITH_AES_256_CCM_8("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1, 6655, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_RSA_WITH_AES_128_CCM_8("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2, 6655, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_RSA_WITH_AES_256_CCM_8("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3, 6655, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_AES_128_CCM("TLS_PSK_WITH_AES_128_CCM", 0xc0a4, 6655, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_AES_256_CCM("TLS_PSK_WITH_AES_256_CCM", 0xc0a5, 6655, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_AES_128_CCM("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6, 6655, MAX_VALUE, MAX_VALUE),
+  // TLS_DHE_PSK_WITH_AES_256_CCM("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7, 6655, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_AES_128_CCM_8("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8, 6655, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_WITH_AES_256_CCM_8("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9, 6655, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_DHE_WITH_AES_128_CCM_8("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa, 6655, MAX_VALUE, MAX_VALUE),
+  // TLS_PSK_DHE_WITH_AES_256_CCM_8("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab, 6655, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_ECDSA_WITH_AES_128_CCM("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac, 7251, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_ECDSA_WITH_AES_256_CCM("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad, 7251, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae, 7251, MAX_VALUE, MAX_VALUE),
+  // TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af, 7251, MAX_VALUE, MAX_VALUE),
+  ;
+
+  final String javaName;
+
+  /**
+   * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
+   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
+   * @param value the integer identifier for this cipher suite. (Documentation only.)
+   * @param rfc the RFC describing this cipher suite. (Documentation only.)
+   * @param sinceJavaVersion the first major Java release supporting this cipher suite.
+   * @param sinceAndroidVersion the first Android SDK version supporting this cipher suite.
+   */
+  private CipherSuite(
+      String javaName, int value, int rfc, int sinceJavaVersion, int sinceAndroidVersion) {
+    this.javaName = javaName;
+  }
+
+  static CipherSuite forJavaName(String javaName) {
+    return javaName.startsWith("SSL_")
+        ? valueOf("TLS_" + javaName.substring(4))
+        : valueOf(javaName);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index 6be5656705..8d8586ea07 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -17,36 +17,37 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.http.HttpAuthenticator;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.HttpConnection;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpTransport;
-import com.squareup.okhttp.internal.http.RawHeaders;
+import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.SpdyTransport;
+import com.squareup.okhttp.internal.http.Transport;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.Closeable;
+import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.net.Proxy;
 import java.net.Socket;
-import java.net.SocketTimeoutException;
 import java.net.URL;
-import java.util.Arrays;
+import java.security.cert.X509Certificate;
+import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLSocket;
+import okio.Source;
 
+import static com.squareup.okhttp.internal.Util.getDefaultPort;
+import static com.squareup.okhttp.internal.Util.getEffectivePort;
 import static java.net.HttpURLConnection.HTTP_OK;
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 
 /**
- * Holds the sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection,
- * which may be used for multiple HTTP request/response exchanges. Connections
- * may be direct to the origin server or via a proxy.
+ * The sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection. May be
+ * used for multiple HTTP request/response exchanges. Connections may be direct
+ * to the origin server or via a proxy.
  *
  * <p>Typically instances of this class are created, connected and exercised
  * automatically by the HTTP client. Applications may use this class to monitor
- * HTTP connections as members of a {@link ConnectionPool connection pool}.
+ * HTTP connections as members of a {@linkplain ConnectionPool connection pool}.
  *
  * <p>Do not confuse this class with the misnamed {@code HttpURLConnection},
  * which isn't so much a connection as a single request/response exchange.
@@ -55,127 +56,228 @@
  * There are tradeoffs when selecting which options to include when negotiating
  * a secure connection to a remote host. Newer TLS options are quite useful:
  * <ul>
- * <li>Server Name Indication (SNI) enables one IP address to negotiate secure
- * connections for multiple domain names.
- * <li>Next Protocol Negotiation (NPN) enables the HTTPS port (443) to be used
- * for both HTTP and SPDY transports.
+ *   <li>Server Name Indication (SNI) enables one IP address to negotiate secure
+ *       connections for multiple domain names.
+ *   <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port
+ *       (443) to be used for different HTTP and SPDY protocols.
  * </ul>
  * Unfortunately, older HTTPS servers refuse to connect when such options are
  * presented. Rather than avoiding these options entirely, this class allows a
  * connection to be attempted with modern options and then retried without them
  * should the attempt fail.
  */
-public final class Connection implements Closeable {
-  private static final byte[] NPN_PROTOCOLS = new byte[] {
-      6, 's', 'p', 'd', 'y', '/', '3',
-      8, 'h', 't', 't', 'p', '/', '1', '.', '1'
-  };
-  private static final byte[] SPDY3 = new byte[] {
-      's', 'p', 'd', 'y', '/', '3'
-  };
-  private static final byte[] HTTP_11 = new byte[] {
-      'h', 't', 't', 'p', '/', '1', '.', '1'
-  };
-
+public final class Connection {
+  private final ConnectionPool pool;
   private final Route route;
 
   private Socket socket;
-  private InputStream in;
-  private OutputStream out;
   private boolean connected = false;
+  private HttpConnection httpConnection;
   private SpdyConnection spdyConnection;
-  private int httpMinorVersion = 1; // Assume HTTP/1.1
+  private Protocol protocol = Protocol.HTTP_1_1;
   private long idleStartTimeNs;
+  private Handshake handshake;
+  private int recycleCount;
+
+  /**
+   * The object that owns this connection. Null if it is shared (for SPDY),
+   * belongs to a pool, or has been discarded. Guarded by {@code pool}, which
+   * clears the owner when an incoming connection is recycled.
+   */
+  private Object owner;
 
-  public Connection(Route route) {
+  public Connection(ConnectionPool pool, Route route) {
+    this.pool = pool;
     this.route = route;
   }
 
-  public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)
+  Object getOwner() {
+    synchronized (pool) {
+      return owner;
+    }
+  }
+
+  void setOwner(Object owner) {
+    if (isSpdy()) return; // SPDY connections are shared.
+    synchronized (pool) {
+      if (this.owner != null) throw new IllegalStateException("Connection already has an owner!");
+      this.owner = owner;
+    }
+  }
+
+  /**
+   * Attempts to clears the owner of this connection. Returns true if the owner
+   * was cleared and the connection can be pooled or reused. This will return
+   * false if the connection cannot be pooled or reused, such as if it was
+   * closed with {@link #closeIfOwnedBy}.
+   */
+  boolean clearOwner() {
+    synchronized (pool) {
+      if (owner == null) {
+        // No owner? Don't reuse this connection.
+        return false;
+      }
+
+      owner = null;
+      return true;
+    }
+  }
+
+  /**
+   * Closes this connection if it is currently owned by {@code owner}. This also
+   * strips the ownership of the connection so it cannot be pooled or reused.
+   */
+  void closeIfOwnedBy(Object owner) throws IOException {
+    if (isSpdy()) throw new IllegalStateException();
+    synchronized (pool) {
+      if (this.owner != owner) {
+        return; // Wrong owner. Perhaps a late disconnect?
+      }
+
+      this.owner = null; // Drop the owner so the connection won't be reused.
+    }
+
+    // Don't close() inside the synchronized block.
+    socket.close();
+  }
+
+  void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest)
       throws IOException {
-    if (connected) {
-      throw new IllegalStateException("already connected");
+    if (connected) throw new IllegalStateException("already connected");
+
+    if (route.proxy.type() == Proxy.Type.DIRECT || route.proxy.type() == Proxy.Type.HTTP) {
+      socket = route.address.socketFactory.createSocket();
+    } else {
+      socket = new Socket(route.proxy);
     }
-    connected = true;
-    socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();
-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);
+
     socket.setSoTimeout(readTimeout);
-    in = socket.getInputStream();
-    out = socket.getOutputStream();
+    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);
 
     if (route.address.sslSocketFactory != null) {
-      upgradeToTls(tunnelRequest);
+      upgradeToTls(tunnelRequest, readTimeout, writeTimeout);
+    } else {
+      httpConnection = new HttpConnection(pool, this, socket);
+    }
+    connected = true;
+  }
+
+  /**
+   * Connects this connection if it isn't already. This creates tunnels, shares
+   * the connection with the connection pool, and configures timeouts.
+   */
+  void connectAndSetOwner(OkHttpClient client, Object owner, Request request) throws IOException {
+    setOwner(owner);
+
+    if (!isConnected()) {
+      Request tunnelRequest = tunnelRequest(request);
+      connect(client.getConnectTimeout(), client.getReadTimeout(),
+          client.getWriteTimeout(), tunnelRequest);
+      if (isSpdy()) {
+        client.getConnectionPool().share(this);
+      }
+      client.routeDatabase().connected(getRoute());
     }
 
-    // Use MTU-sized buffers to send fewer packets.
-    int mtu = Platform.get().getMtu(socket);
-    if (mtu < 1024) mtu = 1024;
-    if (mtu > 8192) mtu = 8192;
-    in = new BufferedInputStream(in, mtu);
-    out = new BufferedOutputStream(out, mtu);
+    setTimeouts(client.getReadTimeout(), client.getWriteTimeout());
+  }
+
+  /**
+   * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if
+   * no tunnel is necessary. Everything in the tunnel request is sent
+   * unencrypted to the proxy server, so tunnels include only the minimum set of
+   * headers. This avoids sending potentially sensitive data like HTTP cookies
+   * to the proxy unencrypted.
+   */
+  private Request tunnelRequest(Request request) throws IOException {
+    if (!route.requiresTunnel()) return null;
+
+    String host = request.url().getHost();
+    int port = getEffectivePort(request.url());
+    String authority = (port == getDefaultPort("https")) ? host : (host + ":" + port);
+    Request.Builder result = new Request.Builder()
+        .url(new URL("https", host, port, "/"))
+        .header("Host", authority)
+        .header("Proxy-Connection", "Keep-Alive"); // For HTTP/1.0 proxies like Squid.
+
+    // Copy over the User-Agent header if it exists.
+    String userAgent = request.header("User-Agent");
+    if (userAgent != null) {
+      result.header("User-Agent", userAgent);
+    }
+
+    // Copy over the Proxy-Authorization header if it exists.
+    String proxyAuthorization = request.header("Proxy-Authorization");
+    if (proxyAuthorization != null) {
+      result.header("Proxy-Authorization", proxyAuthorization);
+    }
+
+    return result.build();
   }
 
   /**
    * Create an {@code SSLSocket} and perform the TLS handshake and certificate
    * validation.
    */
-  private void upgradeToTls(TunnelRequest tunnelRequest) throws IOException {
+  private void upgradeToTls(Request tunnelRequest, int readTimeout, int writeTimeout)
+      throws IOException {
     Platform platform = Platform.get();
 
     // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
-    if (requiresTunnel()) {
-      makeTunnel(tunnelRequest);
+    if (tunnelRequest != null) {
+      makeTunnel(tunnelRequest, readTimeout, writeTimeout);
     }
 
     // Create the wrapper over connected socket.
     socket = route.address.sslSocketFactory
         .createSocket(socket, route.address.uriHost, route.address.uriPort, true /* autoClose */);
     SSLSocket sslSocket = (SSLSocket) socket;
-    if (route.modernTls) {
-      platform.enableTlsExtensions(sslSocket, route.address.uriHost);
-    } else {
-      platform.supportTlsIntolerantServer(sslSocket);
-    }
 
-    boolean useNpn = route.modernTls && route.address.transports.contains("spdy/3");
-    if (useNpn) {
-      platform.setNpnProtocols(sslSocket, NPN_PROTOCOLS);
+    // Configure the socket's ciphers, TLS versions, and extensions.
+    route.connectionSpec.apply(sslSocket, route);
+
+    try {
+      // Force handshake. This can throw!
+      sslSocket.startHandshake();
+
+      String maybeProtocol;
+      if (route.connectionSpec.supportsTlsExtensions()
+          && (maybeProtocol = platform.getSelectedProtocol(sslSocket)) != null) {
+        protocol = Protocol.get(maybeProtocol); // Throws IOE on unknown.
+      }
+    } finally {
+      platform.afterHandshake(sslSocket);
     }
 
-    // Force handshake. This can throw!
-    sslSocket.startHandshake();
+    handshake = Handshake.get(sslSocket.getSession());
 
     // Verify that the socket's certificates are acceptable for the target host.
     if (!route.address.hostnameVerifier.verify(route.address.uriHost, sslSocket.getSession())) {
-      throw new IOException("Hostname '" + route.address.uriHost + "' was not verified");
+      X509Certificate cert = (X509Certificate) sslSocket.getSession().getPeerCertificates()[0];
+      throw new IOException("Hostname " + route.address.uriHost + " not verified:"
+          + "\n    certificate: " + CertificatePinner.pin(cert)
+          + "\n    DN: " + cert.getSubjectDN().getName()
+          + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
     }
 
-    out = sslSocket.getOutputStream();
-    in = sslSocket.getInputStream();
-
-    byte[] selectedProtocol;
-    if (useNpn && (selectedProtocol = platform.getNpnSelectedProtocol(sslSocket)) != null) {
-      if (Arrays.equals(selectedProtocol, SPDY3)) {
-        sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
-        spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, in, out)
-            .build();
-        spdyConnection.sendConnectionHeader();
-      } else if (!Arrays.equals(selectedProtocol, HTTP_11)) {
-        throw new IOException(
-            "Unexpected NPN transport " + new String(selectedProtocol, "ISO-8859-1"));
-      }
+    // Check that the certificate pinner is satisfied by the certificates presented.
+    route.address.certificatePinner.check(route.address.uriHost, handshake.peerCertificates());
+
+    if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) {
+      sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
+      spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, socket)
+          .protocol(protocol).build();
+      spdyConnection.sendConnectionPreface();
+    } else {
+      httpConnection = new HttpConnection(pool, this, socket);
     }
   }
 
   /** Returns true if {@link #connect} has been attempted on this connection. */
-  public boolean isConnected() {
+  boolean isConnected() {
     return connected;
   }
 
-  @Override public void close() throws IOException {
-    socket.close();
-  }
-
   /** Returns the route used by this connection. */
   public Route getRoute() {
     return route;
@@ -190,7 +292,7 @@ public Socket getSocket() {
   }
 
   /** Returns true if this connection is alive. */
-  public boolean isAlive() {
+  boolean isAlive() {
     return !socket.isClosed() && !socket.isInputShutdown() && !socket.isOutputShutdown();
   }
 
@@ -199,106 +301,85 @@ public boolean isAlive() {
    * connection. This is more expensive and more accurate than {@link
    * #isAlive()}; callers should check {@link #isAlive()} first.
    */
-  public boolean isReadable() {
-    if (!(in instanceof BufferedInputStream)) {
-      return true; // Optimistic.
-    }
-    if (isSpdy()) {
-      return true; // Optimistic. We can't test SPDY because its streams are in use.
-    }
-    BufferedInputStream bufferedInputStream = (BufferedInputStream) in;
-    try {
-      int readTimeout = socket.getSoTimeout();
-      try {
-        socket.setSoTimeout(1);
-        bufferedInputStream.mark(1);
-        if (bufferedInputStream.read() == -1) {
-          return false; // Stream is exhausted; socket is closed.
-        }
-        bufferedInputStream.reset();
-        return true;
-      } finally {
-        socket.setSoTimeout(readTimeout);
-      }
-    } catch (SocketTimeoutException ignored) {
-      return true; // Read timed out; socket is good.
-    } catch (IOException e) {
-      return false; // Couldn't read; socket is closed.
-    }
+  boolean isReadable() {
+    if (httpConnection != null) return httpConnection.isReadable();
+    return true; // SPDY connections, and connections before connect() are both optimistic.
   }
 
-  public void resetIdleStartTime() {
-    if (spdyConnection != null) {
-      throw new IllegalStateException("spdyConnection != null");
-    }
+  void resetIdleStartTime() {
+    if (spdyConnection != null) throw new IllegalStateException("spdyConnection != null");
     this.idleStartTimeNs = System.nanoTime();
   }
 
   /** Returns true if this connection is idle. */
-  public boolean isIdle() {
+  boolean isIdle() {
     return spdyConnection == null || spdyConnection.isIdle();
   }
 
-  /**
-   * Returns true if this connection has been idle for longer than
-   * {@code keepAliveDurationNs}.
-   */
-  public boolean isExpired(long keepAliveDurationNs) {
-    return isIdle() && System.nanoTime() - getIdleStartTimeNs() > keepAliveDurationNs;
-  }
-
   /**
    * Returns the time in ns when this connection became idle. Undefined if
    * this connection is not idle.
    */
-  public long getIdleStartTimeNs() {
+  long getIdleStartTimeNs() {
     return spdyConnection == null ? idleStartTimeNs : spdyConnection.getIdleStartTimeNs();
   }
 
+  public Handshake getHandshake() {
+    return handshake;
+  }
+
   /** Returns the transport appropriate for this connection. */
-  public Object newTransport(HttpEngine httpEngine) throws IOException {
+  Transport newTransport(HttpEngine httpEngine) throws IOException {
     return (spdyConnection != null)
         ? new SpdyTransport(httpEngine, spdyConnection)
-        : new HttpTransport(httpEngine, out, in);
+        : new HttpTransport(httpEngine, httpConnection);
   }
 
   /**
    * Returns true if this is a SPDY connection. Such connections can be used
    * in multiple HTTP requests simultaneously.
    */
-  public boolean isSpdy() {
+  boolean isSpdy() {
     return spdyConnection != null;
   }
 
-  public SpdyConnection getSpdyConnection() {
-    return spdyConnection;
+  /**
+   * Returns the protocol negotiated by this connection, or {@link
+   * Protocol#HTTP_1_1} if no protocol has been negotiated.
+   */
+  public Protocol getProtocol() {
+    return protocol;
   }
 
   /**
-   * Returns the minor HTTP version that should be used for future requests on
-   * this connection. Either 0 for HTTP/1.0, or 1 for HTTP/1.1. The default
-   * value is 1 for new connections.
+   * Sets the protocol negotiated by this connection. Typically this is used
+   * when an HTTP/1.1 request is sent and an HTTP/1.0 response is received.
    */
-  public int getHttpMinorVersion() {
-    return httpMinorVersion;
+  void setProtocol(Protocol protocol) {
+    if (protocol == null) throw new IllegalArgumentException("protocol == null");
+    this.protocol = protocol;
   }
 
-  public void setHttpMinorVersion(int httpMinorVersion) {
-    this.httpMinorVersion = httpMinorVersion;
+  void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) throws IOException {
+    if (!connected) throw new IllegalStateException("setTimeouts - not connected");
+
+    // Don't set timeouts on shared SPDY connections.
+    if (httpConnection != null) {
+      socket.setSoTimeout(readTimeoutMillis);
+      httpConnection.setTimeouts(readTimeoutMillis, writeTimeoutMillis);
+    }
   }
 
-  /**
-   * Returns true if the HTTP connection needs to tunnel one protocol over
-   * another, such as when using HTTPS through an HTTP proxy. When doing so,
-   * we must avoid buffering bytes intended for the higher-level protocol.
-   */
-  public boolean requiresTunnel() {
-    return route.address.sslSocketFactory != null && route.proxy.type() == Proxy.Type.HTTP;
+  void incrementRecycleCount() {
+    recycleCount++;
   }
 
-  public void updateReadTimeout(int newTimeout) throws IOException {
-    if (!connected) throw new IllegalStateException("updateReadTimeout - not connected");
-    socket.setSoTimeout(newTimeout);
+  /**
+   * Returns the number of times this connection has been returned to the
+   * connection pool.
+   */
+  int recycleCount() {
+    return recycleCount;
   }
 
   /**
@@ -306,30 +387,61 @@ public void updateReadTimeout(int newTimeout) throws IOException {
    * CONNECT request to create the proxy connection. This may need to be
    * retried if the proxy requires authorization.
    */
-  private void makeTunnel(TunnelRequest tunnelRequest) throws IOException {
-    RawHeaders requestHeaders = tunnelRequest.getRequestHeaders();
+  private void makeTunnel(Request request, int readTimeout, int writeTimeout)
+      throws IOException {
+    HttpConnection tunnelConnection = new HttpConnection(pool, this, socket);
+    tunnelConnection.setTimeouts(readTimeout, writeTimeout);
+    URL url = request.url();
+    String requestLine = "CONNECT " + url.getHost() + ":" + url.getPort() + " HTTP/1.1";
     while (true) {
-      out.write(requestHeaders.toBytes());
-      RawHeaders responseHeaders = RawHeaders.fromBytes(in);
+      tunnelConnection.writeRequest(request.headers(), requestLine);
+      tunnelConnection.flush();
+      Response response = tunnelConnection.readResponse().request(request).build();
+      // The response body from a CONNECT should be empty, but if it is not then we should consume
+      // it before proceeding.
+      long contentLength = OkHeaders.contentLength(response);
+      if (contentLength == -1L) {
+        contentLength = 0L;
+      }
+      Source body = tunnelConnection.newFixedLengthSource(contentLength);
+      Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
+      body.close();
 
-      switch (responseHeaders.getResponseCode()) {
+      switch (response.code()) {
         case HTTP_OK:
+          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If that
+          // happens, then we will have buffered bytes that are needed by the SSLSocket!
+          // This check is imperfect: it doesn't tell us whether a handshake will succeed, just that
+          // it will almost certainly fail because the proxy has sent unexpected data.
+          if (tunnelConnection.bufferSize() > 0) {
+            throw new IOException("TLS tunnel buffered too many bytes!");
+          }
           return;
+
         case HTTP_PROXY_AUTH:
-          requestHeaders = new RawHeaders(requestHeaders);
-          URL url = new URL("https", tunnelRequest.host, tunnelRequest.port, "/");
-          boolean credentialsFound = HttpAuthenticator.processAuthHeader(
-              route.address.authenticator, HTTP_PROXY_AUTH, responseHeaders, requestHeaders,
-              route.proxy, url);
-          if (credentialsFound) {
-            continue;
-          } else {
-            throw new IOException("Failed to authenticate with proxy");
-          }
+          request = OkHeaders.processAuthHeader(
+              route.address.authenticator, response, route.proxy);
+          if (request != null) continue;
+          throw new IOException("Failed to authenticate with proxy");
+
         default:
           throw new IOException(
-              "Unexpected response code for CONNECT: " + responseHeaders.getResponseCode());
+              "Unexpected response code for CONNECT: " + response.code());
       }
     }
   }
+
+  @Override public String toString() {
+    return "Connection{"
+        + route.address.uriHost + ":" + route.address.uriPort
+        + ", proxy="
+        + route.proxy
+        + " hostAddress="
+        + route.inetSocketAddress.getAddress().getHostAddress()
+        + " cipherSuite="
+        + (handshake != null ? handshake.cipherSuite() : "none")
+        + " protocol="
+        + protocol
+        + '}';
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index 42b70b9806..16a6adbd13 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -23,8 +23,7 @@
 import java.util.LinkedList;
 import java.util.List;
 import java.util.ListIterator;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executor;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -52,8 +51,7 @@
  * parameters do so before making HTTP connections, and that this class is
  * initialized lazily.
  */
-public class ConnectionPool {
-  private static final int MAX_CONNECTIONS_TO_CLEANUP = 2;
+public final class ConnectionPool {
   private static final long DEFAULT_KEEP_ALIVE_DURATION_MS = 5 * 60 * 1000; // 5 min
 
   private static final ConnectionPool systemDefault;
@@ -77,43 +75,26 @@
   private final int maxIdleConnections;
   private final long keepAliveDurationNs;
 
-  private final LinkedList<Connection> connections = new LinkedList<Connection>();
+  private final LinkedList<Connection> connections = new LinkedList<>();
 
-  /** We use a single background thread to cleanup expired connections. */
-  private final ExecutorService executorService = new ThreadPoolExecutor(0, 1,
-      60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),
-      Util.daemonThreadFactory("OkHttp ConnectionPool"));
-  private final Callable<Void> connectionsCleanupCallable = new Callable<Void>() {
-    @Override public Void call() throws Exception {
-      List<Connection> expiredConnections = new ArrayList<Connection>(MAX_CONNECTIONS_TO_CLEANUP);
-      int idleConnectionCount = 0;
-      synchronized (ConnectionPool.this) {
-        for (ListIterator<Connection> i = connections.listIterator(connections.size());
-            i.hasPrevious(); ) {
-          Connection connection = i.previous();
-          if (!connection.isAlive() || connection.isExpired(keepAliveDurationNs)) {
-            i.remove();
-            expiredConnections.add(connection);
-            if (expiredConnections.size() == MAX_CONNECTIONS_TO_CLEANUP) break;
-          } else if (connection.isIdle()) {
-            idleConnectionCount++;
-          }
-        }
+  /**
+   * A background thread is used to cleanup expired connections. There will be, at most, a single
+   * thread running per connection pool.
+   *
+   * <p>A {@link ThreadPoolExecutor} is used and not a
+   * {@link java.util.concurrent.ScheduledThreadPoolExecutor}; ScheduledThreadPoolExecutors do not
+   * shrink. This executor shrinks the thread pool after a period of inactivity, and starts threads
+   * as needed. Delays are instead handled by the {@link #connectionsCleanupRunnable}. It is
+   * important that the {@link #connectionsCleanupRunnable} stops eventually, otherwise it will pin
+   * the thread, and thus the connection pool, in memory.
+   */
+  private Executor executor = new ThreadPoolExecutor(
+      0 /* corePoolSize */, 1 /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
+      new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
 
-        for (ListIterator<Connection> i = connections.listIterator(connections.size());
-            i.hasPrevious() && idleConnectionCount > maxIdleConnections; ) {
-          Connection connection = i.previous();
-          if (connection.isIdle()) {
-            expiredConnections.add(connection);
-            i.remove();
-            --idleConnectionCount;
-          }
-        }
-      }
-      for (Connection expiredConnection : expiredConnections) {
-        Util.closeQuietly(expiredConnection);
-      }
-      return null;
+  private final Runnable connectionsCleanupRunnable = new Runnable() {
+    @Override public void run() {
+      runCleanupUntilPoolIsEmpty();
     }
   };
 
@@ -122,32 +103,6 @@ public ConnectionPool(int maxIdleConnections, long keepAliveDurationMs) {
     this.keepAliveDurationNs = keepAliveDurationMs * 1000 * 1000;
   }
 
-  /**
-   * Returns a snapshot of the connections in this pool, ordered from newest to
-   * oldest. Waits for the cleanup callable to run if it is currently scheduled.
-   */
-  List<Connection> getConnections() {
-    waitForCleanupCallableToRun();
-    synchronized (this) {
-      return new ArrayList<Connection>(connections);
-    }
-  }
-
-  /**
-   * Blocks until the executor service has processed all currently enqueued
-   * jobs.
-   */
-  private void waitForCleanupCallableToRun() {
-    try {
-      executorService.submit(new Runnable() {
-        @Override public void run() {
-        }
-      }).get();
-    } catch (Exception e) {
-      throw new AssertionError();
-    }
-  }
-
   public static ConnectionPool getDefault() {
     return systemDefault;
   }
@@ -157,8 +112,14 @@ public synchronized int getConnectionCount() {
     return connections.size();
   }
 
-  /** Returns total number of spdy connections in the pool. */
+  /** @deprecated Use {@link #getMultiplexedConnectionCount()}. */
+  @Deprecated
   public synchronized int getSpdyConnectionCount() {
+    return getMultiplexedConnectionCount();
+  }
+
+  /** Returns total number of multiplexed connections in the pool. */
+  public synchronized int getMultiplexedConnectionCount() {
     int total = 0;
     for (Connection connection : connections) {
       if (connection.isSpdy()) total++;
@@ -168,11 +129,7 @@ public synchronized int getSpdyConnectionCount() {
 
   /** Returns total number of http connections in the pool. */
   public synchronized int getHttpConnectionCount() {
-    int total = 0;
-    for (Connection connection : connections) {
-      if (!connection.isSpdy()) total++;
-    }
-    return total;
+    return connections.size() - getMultiplexedConnectionCount();
   }
 
   /** Returns a recycled connection to {@code address}, or null if no such connection exists. */
@@ -191,7 +148,7 @@ public synchronized Connection get(Address address) {
         try {
           Platform.get().tagSocket(connection.getSocket());
         } catch (SocketException e) {
-          Util.closeQuietly(connection);
+          Util.closeQuietly(connection.getSocket());
           // When unable to tag, skip recycling and close
           Platform.get().logW("Unable to tagSocket(): " + e);
           continue;
@@ -205,7 +162,6 @@ public synchronized Connection get(Address address) {
       connections.addFirst(foundConnection); // Add it back after iteration.
     }
 
-    executorService.submit(connectionsCleanupCallable);
     return foundConnection;
   }
 
@@ -215,13 +171,17 @@ public synchronized Connection get(Address address) {
    *
    * <p>It is an error to use {@code connection} after calling this method.
    */
-  public void recycle(Connection connection) {
+  void recycle(Connection connection) {
     if (connection.isSpdy()) {
       return;
     }
 
+    if (!connection.clearOwner()) {
+      return; // This connection isn't eligible for reuse.
+    }
+
     if (!connection.isAlive()) {
-      Util.closeQuietly(connection);
+      Util.closeQuietly(connection.getSocket());
       return;
     }
 
@@ -230,45 +190,147 @@ public void recycle(Connection connection) {
     } catch (SocketException e) {
       // When unable to remove tagging, skip recycling and close.
       Platform.get().logW("Unable to untagSocket(): " + e);
-      Util.closeQuietly(connection);
+      Util.closeQuietly(connection.getSocket());
       return;
     }
 
     synchronized (this) {
-      connections.addFirst(connection);
+      addConnection(connection);
+      connection.incrementRecycleCount();
       connection.resetIdleStartTime();
     }
+  }
 
-    executorService.submit(connectionsCleanupCallable);
+  private void addConnection(Connection connection) {
+    boolean empty = connections.isEmpty();
+    connections.addFirst(connection);
+    if (empty) {
+      executor.execute(connectionsCleanupRunnable);
+    } else {
+      notifyAll();
+    }
   }
 
   /**
    * Shares the SPDY connection with the pool. Callers to this method may
    * continue to use {@code connection}.
    */
-  public void maybeShare(Connection connection) {
-    executorService.submit(connectionsCleanupCallable);
-    if (!connection.isSpdy()) {
-      // Only SPDY connections are sharable.
-      return;
-    }
-    if (connection.isAlive()) {
-      synchronized (this) {
-        connections.addFirst(connection);
-      }
+  void share(Connection connection) {
+    if (!connection.isSpdy()) throw new IllegalArgumentException();
+    if (!connection.isAlive()) return;
+    synchronized (this) {
+      addConnection(connection);
     }
   }
 
   /** Close and remove all connections in the pool. */
   public void evictAll() {
-    List<Connection> connections;
+    List<Connection> toEvict;
     synchronized (this) {
-      connections = new ArrayList<Connection>(this.connections);
-      this.connections.clear();
+      toEvict = new ArrayList<>(connections);
+      connections.clear();
     }
 
-    for (Connection connection : connections) {
-      Util.closeQuietly(connection);
+    for (int i = 0, size = toEvict.size(); i < size; i++) {
+      Util.closeQuietly(toEvict.get(i).getSocket());
     }
   }
+
+  private void runCleanupUntilPoolIsEmpty() {
+    while (true) {
+      if (!performCleanup()) return; // Halt cleanup.
+    }
+  }
+
+  /**
+   * Attempts to make forward progress on connection eviction. There are three possible outcomes:
+   *
+   * <h3>The pool is empty.</h3>
+   * In this case, this method returns false and the eviction job should exit because there are no
+   * further cleanup tasks coming. (If additional connections are added to the pool, another cleanup
+   * job must be enqueued.)
+   *
+   * <h3>Connections were evicted.</h3>
+   * At least one connections was eligible for immediate eviction and was evicted. The method
+   * returns true and cleanup should continue.
+   *
+   * <h3>We waited to evict.</h3>
+   * None of the pooled connections were eligible for immediate eviction. Instead, we waited until
+   * either a connection became eligible for eviction, or the connections list changed. In either
+   * case, the method returns true and cleanup should continue.
+   */
+  // VisibleForTesting
+  boolean performCleanup() {
+    List<Connection> evictableConnections;
+
+    synchronized (this) {
+      if (connections.isEmpty()) return false; // Halt cleanup.
+
+      evictableConnections = new ArrayList<>();
+      int idleConnectionCount = 0;
+      long now = System.nanoTime();
+      long nanosUntilNextEviction = keepAliveDurationNs;
+
+      // Collect connections eligible for immediate eviction.
+      for (ListIterator<Connection> i = connections.listIterator(connections.size());
+          i.hasPrevious(); ) {
+        Connection connection = i.previous();
+        long nanosUntilEviction = connection.getIdleStartTimeNs() + keepAliveDurationNs - now;
+        if (nanosUntilEviction <= 0 || !connection.isAlive()) {
+          i.remove();
+          evictableConnections.add(connection);
+        } else if (connection.isIdle()) {
+          idleConnectionCount++;
+          nanosUntilNextEviction = Math.min(nanosUntilNextEviction, nanosUntilEviction);
+        }
+      }
+
+      // If the pool has too many idle connections, gather more! Oldest to newest.
+      for (ListIterator<Connection> i = connections.listIterator(connections.size());
+          i.hasPrevious() && idleConnectionCount > maxIdleConnections; ) {
+        Connection connection = i.previous();
+        if (connection.isIdle()) {
+          evictableConnections.add(connection);
+          i.remove();
+          --idleConnectionCount;
+        }
+      }
+
+      // If there's nothing to evict, wait. (This will be interrupted if connections are added.)
+      if (evictableConnections.isEmpty()) {
+        try {
+          long millisUntilNextEviction = nanosUntilNextEviction / (1000 * 1000);
+          long remainderNanos = nanosUntilNextEviction - millisUntilNextEviction * (1000 * 1000);
+          this.wait(millisUntilNextEviction, (int) remainderNanos);
+          return true; // Cleanup continues.
+        } catch (InterruptedException ignored) {
+        }
+      }
+    }
+
+    // Actually do the eviction. Note that we avoid synchronized() when closing sockets.
+    for (int i = 0, size = evictableConnections.size(); i < size; i++) {
+      Connection expiredConnection = evictableConnections.get(i);
+      Util.closeQuietly(expiredConnection.getSocket());
+    }
+
+    return true; // Cleanup continues.
+  }
+
+  /**
+   * Replace the default {@link Executor} with a different one. Only use in tests.
+   */
+  // VisibleForTesting
+  void replaceCleanupExecutorForTests(Executor cleanupExecutor) {
+    this.executor = cleanupExecutor;
+  }
+
+  /**
+   * Returns a snapshot of the connections in this pool, ordered from newest to
+   * oldest. Only use in tests.
+   */
+  // VisibleForTesting
+  synchronized List<Connection> getConnections() {
+    return new ArrayList<>(connections);
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
new file mode 100644
index 0000000000..862be0f44f
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionSpec.java
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.Util;
+import java.util.Arrays;
+import java.util.List;
+import javax.net.ssl.SSLSocket;
+
+/**
+ * Specifies configuration for the socket connection that HTTP traffic travels through. For {@code
+ * https:} URLs, this includes the TLS version and ciphers to use when negotiating a secure
+ * connection.
+ */
+public final class ConnectionSpec {
+
+  /** A modern TLS connection with extensions like SNI and ALPN available. */
+  public static final ConnectionSpec MODERN_TLS = new Builder(true)
+      .cipherSuites(
+          // This is a subset of the cipher suites supported in Chrome 37, current as of 2014-10-5.
+          // All of these suites are available on Android L; earlier releases support a subset of
+          // these suites. https://github.com/square/okhttp/issues/330
+          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
+          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
+          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
+          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+          CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+          CipherSuite.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,
+          CipherSuite.TLS_ECDHE_RSA_WITH_RC4_128_SHA,
+          CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
+          CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA,
+          CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
+          CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
+          CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
+          CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
+          CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
+          CipherSuite.TLS_RSA_WITH_RC4_128_SHA,
+          CipherSuite.TLS_RSA_WITH_RC4_128_MD5
+      )
+      .tlsVersions(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
+      .supportsTlsExtensions(true)
+      .build();
+
+  /** A backwards-compatible fallback connection for interop with obsolete servers. */
+  public static final ConnectionSpec COMPATIBLE_TLS = new Builder(MODERN_TLS)
+      .tlsVersions(TlsVersion.TLS_1_0)
+      .build();
+
+  /** Unencrypted, unauthenticated connections for {@code http:} URLs. */
+  public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
+
+  final boolean tls;
+  private final String[] cipherSuites;
+  private final String[] tlsVersions;
+  final boolean supportsTlsExtensions;
+
+  /**
+   * Caches the subset of this spec that's supported by the host platform. It's possible that the
+   * platform hosts multiple implementations of {@link SSLSocket}, in which case this cache will be
+   * incorrect.
+   */
+  private ConnectionSpec supportedSpec;
+
+  private ConnectionSpec(Builder builder) {
+    this.tls = builder.tls;
+    this.cipherSuites = builder.cipherSuites;
+    this.tlsVersions = builder.tlsVersions;
+    this.supportsTlsExtensions = builder.supportsTlsExtensions;
+  }
+
+  public boolean isTls() {
+    return tls;
+  }
+
+  public List<CipherSuite> cipherSuites() {
+    CipherSuite[] result = new CipherSuite[cipherSuites.length];
+    for (int i = 0; i < cipherSuites.length; i++) {
+      result[i] = CipherSuite.forJavaName(cipherSuites[i]);
+    }
+    return Util.immutableList(result);
+  }
+
+  public List<TlsVersion> tlsVersions() {
+    TlsVersion[] result = new TlsVersion[tlsVersions.length];
+    for (int i = 0; i < tlsVersions.length; i++) {
+      result[i] = TlsVersion.forJavaName(tlsVersions[i]);
+    }
+    return Util.immutableList(result);
+  }
+
+  public boolean supportsTlsExtensions() {
+    return supportsTlsExtensions;
+  }
+
+  /** Applies this spec to {@code sslSocket} for {@code route}. */
+  void apply(SSLSocket sslSocket, Route route) {
+    ConnectionSpec specToApply = supportedSpec;
+    if (specToApply == null) {
+      specToApply = supportedSpec(sslSocket);
+      supportedSpec = specToApply;
+    }
+
+    sslSocket.setEnabledProtocols(specToApply.tlsVersions);
+
+    String[] cipherSuitesToEnable = specToApply.cipherSuites;
+    if (route.shouldSendTlsFallbackIndicator) {
+      // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
+      // the SCSV cipher is added to signal that a protocol fallback has taken place.
+      final String fallbackScsv = "TLS_FALLBACK_SCSV";
+      boolean socketSupportsFallbackScsv =
+          Arrays.asList(sslSocket.getSupportedCipherSuites()).contains(fallbackScsv);
+
+      if (socketSupportsFallbackScsv) {
+        // Add the SCSV cipher to the set of enabled ciphers iff it is supported.
+        String[] oldEnabledCipherSuites = cipherSuitesToEnable;
+        String[] newEnabledCipherSuites = new String[oldEnabledCipherSuites.length + 1];
+        System.arraycopy(oldEnabledCipherSuites, 0,
+            newEnabledCipherSuites, 0, oldEnabledCipherSuites.length);
+        newEnabledCipherSuites[newEnabledCipherSuites.length - 1] = fallbackScsv;
+        cipherSuitesToEnable = newEnabledCipherSuites;
+      }
+    }
+    sslSocket.setEnabledCipherSuites(cipherSuitesToEnable);
+
+    Platform platform = Platform.get();
+    if (specToApply.supportsTlsExtensions) {
+      platform.configureTlsExtensions(sslSocket, route.address.uriHost, route.address.protocols);
+    }
+  }
+
+  /**
+   * Returns a copy of this that omits cipher suites and TLS versions not
+   * supported by {@code sslSocket}.
+   */
+  private ConnectionSpec supportedSpec(SSLSocket sslSocket) {
+    List<String> supportedCipherSuites =
+        Util.intersect(cipherSuites, sslSocket.getSupportedCipherSuites());
+    List<String> supportedTlsVersions =
+        Util.intersect(tlsVersions, sslSocket.getSupportedProtocols());
+    return new Builder(this)
+        .cipherSuites(supportedCipherSuites.toArray(new String[supportedCipherSuites.size()]))
+        .tlsVersions(supportedTlsVersions.toArray(new String[supportedTlsVersions.size()]))
+        .build();
+  }
+
+  @Override public boolean equals(Object other) {
+    if (!(other instanceof ConnectionSpec)) return false;
+
+    ConnectionSpec that = (ConnectionSpec) other;
+    if (this.tls != that.tls) return false;
+
+    if (tls) {
+      if (!Arrays.equals(this.cipherSuites, that.cipherSuites)) return false;
+      if (!Arrays.equals(this.tlsVersions, that.tlsVersions)) return false;
+      if (this.supportsTlsExtensions != that.supportsTlsExtensions) return false;
+    }
+
+    return true;
+  }
+
+  @Override public int hashCode() {
+    int result = 17;
+    if (tls) {
+      result = 31 * result + Arrays.hashCode(cipherSuites);
+      result = 31 * result + Arrays.hashCode(tlsVersions);
+      result = 31 * result + (supportsTlsExtensions ? 0 : 1);
+    }
+    return result;
+  }
+
+  @Override public String toString() {
+    if (tls) {
+      return "ConnectionSpec(cipherSuites=" + cipherSuites()
+          + ", tlsVersions=" + tlsVersions()
+          + ", supportsTlsExtensions=" + supportsTlsExtensions
+          + ")";
+    } else {
+      return "ConnectionSpec()";
+    }
+  }
+
+  public static final class Builder {
+    private boolean tls;
+    private String[] cipherSuites;
+    private String[] tlsVersions;
+    private boolean supportsTlsExtensions;
+
+    private Builder(boolean tls) {
+      this.tls = tls;
+    }
+
+    public Builder(ConnectionSpec connectionSpec) {
+      this.tls = connectionSpec.tls;
+      this.cipherSuites = connectionSpec.cipherSuites;
+      this.tlsVersions = connectionSpec.tlsVersions;
+      this.supportsTlsExtensions = connectionSpec.supportsTlsExtensions;
+    }
+
+    public Builder cipherSuites(CipherSuite... cipherSuites) {
+      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
+
+      // Convert enums to the string names Java wants. This makes a defensive copy!
+      String[] strings = new String[cipherSuites.length];
+      for (int i = 0; i < cipherSuites.length; i++) {
+        strings[i] = cipherSuites[i].javaName;
+      }
+
+      return cipherSuites(strings);
+    }
+
+    Builder cipherSuites(String[] cipherSuites) {
+      this.cipherSuites = cipherSuites; // No defensive copy.
+      return this;
+    }
+
+    public Builder tlsVersions(TlsVersion... tlsVersions) {
+      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
+
+      // Convert enums to the string names Java wants. This makes a defensive copy!
+      String[] strings = new String[tlsVersions.length];
+      for (int i = 0; i < tlsVersions.length; i++) {
+        strings[i] = tlsVersions[i].javaName;
+      }
+
+      return tlsVersions(strings);
+    }
+
+    Builder tlsVersions(String... tlsVersions) {
+      this.tlsVersions = tlsVersions; // No defensive copy.
+      return this;
+    }
+
+    public Builder supportsTlsExtensions(boolean supportsTlsExtensions) {
+      if (!tls) throw new IllegalStateException("no TLS extensions for cleartext connections");
+      this.supportsTlsExtensions = supportsTlsExtensions;
+      return this;
+    }
+
+    public ConnectionSpec build() {
+      return new ConnectionSpec(this);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Credentials.java b/okhttp/src/main/java/com/squareup/okhttp/Credentials.java
new file mode 100644
index 0000000000..92c128f568
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Credentials.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.UnsupportedEncodingException;
+import okio.ByteString;
+
+/** Factory for HTTP authorization credentials. */
+public final class Credentials {
+  private Credentials() {
+  }
+
+  /** Returns an auth credential for the Basic scheme. */
+  public static String basic(String userName, String password) {
+    try {
+      String usernameAndPassword = userName + ":" + password;
+      byte[] bytes = usernameAndPassword.getBytes("ISO-8859-1");
+      String encoded = ByteString.of(bytes).base64();
+      return "Basic " + encoded;
+    } catch (UnsupportedEncodingException e) {
+      throw new AssertionError();
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index 6a6c273ad6..95eb7b0ad3 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -15,67 +15,166 @@
  */
 package com.squareup.okhttp;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
+import com.squareup.okhttp.Call.AsyncCall;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.HttpEngine;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
-final class Dispatcher {
-  // TODO: thread pool size should be configurable; possibly configurable per host.
-  private final ThreadPoolExecutor executorService = new ThreadPoolExecutor(
-      8, 8, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
-  private final Map<Object, List<Job>> enqueuedJobs = new LinkedHashMap<Object, List<Job>>();
-
-  public synchronized void enqueue(
-      HttpURLConnection connection, Request request, Response.Receiver responseReceiver) {
-    Job job = new Job(this, connection, request, responseReceiver);
-    List<Job> jobsForTag = enqueuedJobs.get(request.tag());
-    if (jobsForTag == null) {
-      jobsForTag = new ArrayList<Job>(2);
-      enqueuedJobs.put(request.tag(), jobsForTag);
+/**
+ * Policy on when async requests are executed.
+ *
+ * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you
+ * supply your own executor, it should be able to run {@linkplain #getMaxRequests the
+ * configured maximum} number of calls concurrently.
+ */
+public final class Dispatcher {
+  private int maxRequests = 64;
+  private int maxRequestsPerHost = 5;
+
+  /** Executes calls. Created lazily. */
+  private ExecutorService executorService;
+
+  /** Ready calls in the order they'll be run. */
+  private final Deque<AsyncCall> readyCalls = new ArrayDeque<>();
+
+  /** Running calls. Includes canceled calls that haven't finished yet. */
+  private final Deque<AsyncCall> runningCalls = new ArrayDeque<>();
+
+  /** In-flight synchronous calls. Includes canceled calls that haven't finished yet. */
+  private final Deque<Call> executedCalls = new ArrayDeque<>();
+
+  public Dispatcher(ExecutorService executorService) {
+    this.executorService = executorService;
+  }
+
+  public Dispatcher() {
+  }
+
+  public synchronized ExecutorService getExecutorService() {
+    if (executorService == null) {
+      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
+          new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
     }
-    jobsForTag.add(job);
-    executorService.execute(job);
+    return executorService;
   }
 
-  public synchronized void cancel(Object tag) {
-    List<Job> jobs = enqueuedJobs.remove(tag);
-    if (jobs == null) return;
-    for (Job job : jobs) {
-      executorService.remove(job);
+  /**
+   * Set the maximum number of requests to execute concurrently. Above this
+   * requests queue in memory, waiting for the running calls to complete.
+   *
+   * <p>If more than {@code maxRequests} requests are in flight when this is
+   * invoked, those requests will remain in flight.
+   */
+  public synchronized void setMaxRequests(int maxRequests) {
+    if (maxRequests < 1) {
+      throw new IllegalArgumentException("max < 1: " + maxRequests);
     }
+    this.maxRequests = maxRequests;
+    promoteCalls();
+  }
+
+  public synchronized int getMaxRequests() {
+    return maxRequests;
   }
 
-  synchronized void finished(Job job) {
-    List<Job> jobs = enqueuedJobs.get(job.request.tag());
-    if (jobs != null) jobs.remove(job);
+  /**
+   * Set the maximum number of requests for each host to execute concurrently.
+   * This limits requests by the URL's host name. Note that concurrent requests
+   * to a single IP address may still exceed this limit: multiple hostnames may
+   * share an IP address or be routed through the same HTTP proxy.
+   *
+   * <p>If more than {@code maxRequestsPerHost} requests are in flight when this
+   * is invoked, those requests will remain in flight.
+   */
+  public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
+    if (maxRequestsPerHost < 1) {
+      throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
+    }
+    this.maxRequestsPerHost = maxRequestsPerHost;
+    promoteCalls();
   }
 
-  static class RealResponseBody extends Response.Body {
-    private final HttpURLConnection connection;
-    private final InputStream in;
+  public synchronized int getMaxRequestsPerHost() {
+    return maxRequestsPerHost;
+  }
 
-    RealResponseBody(HttpURLConnection connection, InputStream in) {
-      this.connection = connection;
-      this.in = in;
+  synchronized void enqueue(AsyncCall call) {
+    if (runningCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
+      runningCalls.add(call);
+      getExecutorService().execute(call);
+    } else {
+      readyCalls.add(call);
     }
+  }
 
-    @Override public String contentType() {
-      return connection.getHeaderField("Content-Type");
+  /** Cancel all calls with the tag {@code tag}. */
+  public synchronized void cancel(Object tag) {
+    for (AsyncCall call : readyCalls) {
+      if (Util.equal(tag, call.tag())) {
+        call.cancel();
+      }
+    }
+
+    for (AsyncCall call : runningCalls) {
+      if (Util.equal(tag, call.tag())) {
+        call.get().canceled = true;
+        HttpEngine engine = call.get().engine;
+        if (engine != null) engine.disconnect();
+      }
+    }
+
+    for (Call call : executedCalls) {
+      if (Util.equal(tag, call.tag())) {
+        call.cancel();
+      }
     }
+  }
+
+  /** Used by {@code AsyncCall#run} to signal completion. */
+  synchronized void finished(AsyncCall call) {
+    if (!runningCalls.remove(call)) throw new AssertionError("AsyncCall wasn't running!");
+    promoteCalls();
+  }
 
-    @Override public long contentLength() {
-      return connection.getContentLength(); // TODO: getContentLengthLong
+  private void promoteCalls() {
+    if (runningCalls.size() >= maxRequests) return; // Already running max capacity.
+    if (readyCalls.isEmpty()) return; // No ready calls to promote.
+
+    for (Iterator<AsyncCall> i = readyCalls.iterator(); i.hasNext(); ) {
+      AsyncCall call = i.next();
+
+      if (runningCallsForHost(call) < maxRequestsPerHost) {
+        i.remove();
+        runningCalls.add(call);
+        getExecutorService().execute(call);
+      }
+
+      if (runningCalls.size() >= maxRequests) return; // Reached max capacity.
     }
+  }
 
-    @Override public InputStream byteStream() throws IOException {
-      return in;
+  /** Returns the number of running calls that share a host with {@code call}. */
+  private int runningCallsForHost(AsyncCall call) {
+    int result = 0;
+    for (AsyncCall c : runningCalls) {
+      if (c.host().equals(call.host())) result++;
     }
+    return result;
+  }
+
+  /** Used by {@code Call#execute} to signal it is in-flight. */
+  synchronized void executed(Call call) {
+    executedCalls.add(call);
+  }
+
+  /** Used by {@code Call#execute} to signal completion. */
+  synchronized void finished(Call call) {
+    if (!executedCalls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Failure.java b/okhttp/src/main/java/com/squareup/okhttp/Failure.java
deleted file mode 100644
index a3547003a5..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/Failure.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-/**
- * A failure attempting to retrieve an HTTP response.
- *
- * <h3>Warning: Experimental OkHttp 2.0 API</h3>
- * This class is in beta. APIs are subject to change!
- */
-/* OkHttp 2.0: public */ class Failure {
-  private final Request request;
-  private final Throwable exception;
-
-  private Failure(Builder builder) {
-    this.request = builder.request;
-    this.exception = builder.exception;
-  }
-
-  public Request request() {
-    return request;
-  }
-
-  public Throwable exception() {
-    return exception;
-  }
-
-  public static class Builder {
-    private Request request;
-    private Throwable exception;
-
-    public Builder request(Request request) {
-      this.request = request;
-      return this;
-    }
-
-    public Builder exception(Throwable exception) {
-      this.exception = exception;
-      return this;
-    }
-
-    public Failure build() {
-      return new Failure(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
new file mode 100644
index 0000000000..891fbff005
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+
+/**
+ * Fluent API to build <a href="http://www.w3.org/MarkUp/html-spec/html-spec_8.html#SEC8.2.1">HTML
+ * 2.0</a>-compliant form data.
+ */
+public final class FormEncodingBuilder {
+  private static final MediaType CONTENT_TYPE
+      = MediaType.parse("application/x-www-form-urlencoded");
+
+  private final StringBuilder content = new StringBuilder();
+
+  /** Add new key-value pair. */
+  public FormEncodingBuilder add(String name, String value) {
+    if (content.length() > 0) {
+      content.append('&');
+    }
+    try {
+      content.append(URLEncoder.encode(name, "UTF-8"))
+          .append('=')
+          .append(URLEncoder.encode(value, "UTF-8"));
+    } catch (UnsupportedEncodingException e) {
+      throw new AssertionError(e);
+    }
+    return this;
+  }
+
+  public RequestBody build() {
+    if (content.length() == 0) {
+      throw new IllegalStateException("Form encoded body must have at least one part.");
+    }
+
+    // Convert to bytes so RequestBody.create() doesn't add a charset to the content-type.
+    byte[] contentBytes = content.toString().getBytes(Util.UTF_8);
+    return RequestBody.create(CONTENT_TYPE, contentBytes);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Handshake.java b/okhttp/src/main/java/com/squareup/okhttp/Handshake.java
new file mode 100644
index 0000000000..d9f5366757
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Handshake.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.Collections;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+
+/**
+ * A record of a TLS handshake. For HTTPS clients, the client is <i>local</i>
+ * and the remote server is its <i>peer</i>.
+ *
+ * <p>This value object describes a completed handshake. Use {@link
+ * javax.net.ssl.SSLSocketFactory} to set policy for new handshakes.
+ */
+public final class Handshake {
+  private final String cipherSuite;
+  private final List<Certificate> peerCertificates;
+  private final List<Certificate> localCertificates;
+
+  private Handshake(
+      String cipherSuite, List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+    this.cipherSuite = cipherSuite;
+    this.peerCertificates = peerCertificates;
+    this.localCertificates = localCertificates;
+  }
+
+  public static Handshake get(SSLSession session) {
+    String cipherSuite = session.getCipherSuite();
+    if (cipherSuite == null) throw new IllegalStateException("cipherSuite == null");
+
+    Certificate[] peerCertificates;
+    try {
+      peerCertificates = session.getPeerCertificates();
+    } catch (SSLPeerUnverifiedException ignored) {
+      peerCertificates = null;
+    }
+    List<Certificate> peerCertificatesList = peerCertificates != null
+        ? Util.immutableList(peerCertificates)
+        : Collections.<Certificate>emptyList();
+
+    Certificate[] localCertificates = session.getLocalCertificates();
+    List<Certificate> localCertificatesList = localCertificates != null
+        ? Util.immutableList(localCertificates)
+        : Collections.<Certificate>emptyList();
+
+    return new Handshake(cipherSuite, peerCertificatesList, localCertificatesList);
+  }
+
+  public static Handshake get(
+      String cipherSuite, List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+    if (cipherSuite == null) throw new IllegalArgumentException("cipherSuite == null");
+    return new Handshake(cipherSuite, Util.immutableList(peerCertificates),
+        Util.immutableList(localCertificates));
+  }
+
+  /** Returns a cipher suite name like "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA". */
+  public String cipherSuite() {
+    return cipherSuite;
+  }
+
+  /** Returns a possibly-empty list of certificates that identify the remote peer. */
+  public List<Certificate> peerCertificates() {
+    return peerCertificates;
+  }
+
+  /** Returns the remote peer's principle, or null if that peer is anonymous. */
+  public Principal peerPrincipal() {
+    return !peerCertificates.isEmpty()
+        ? ((X509Certificate) peerCertificates.get(0)).getSubjectX500Principal()
+        : null;
+  }
+
+  /** Returns a possibly-empty list of certificates that identify this peer. */
+  public List<Certificate> localCertificates() {
+    return localCertificates;
+  }
+
+  /** Returns the local principle, or null if this peer is anonymous. */
+  public Principal localPrincipal() {
+    return !localCertificates.isEmpty()
+        ? ((X509Certificate) localCertificates.get(0)).getSubjectX500Principal()
+        : null;
+  }
+
+  @Override public boolean equals(Object other) {
+    if (!(other instanceof Handshake)) return false;
+    Handshake that = (Handshake) other;
+    return cipherSuite.equals(that.cipherSuite)
+        && peerCertificates.equals(that.peerCertificates)
+        && localCertificates.equals(that.localCertificates);
+  }
+
+  @Override public int hashCode() {
+    int result = 17;
+    result = 31 * result + cipherSuite.hashCode();
+    result = 31 * result + peerCertificates.hashCode();
+    result = 31 * result + localCertificates.hashCode();
+    return result;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Headers.java b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
new file mode 100644
index 0000000000..5a5175594b
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
@@ -0,0 +1,255 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.http.HttpDate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeSet;
+
+/**
+ * The header fields of a single HTTP message. Values are uninterpreted strings;
+ * use {@code Request} and {@code Response} for interpreted headers. This class
+ * maintains the order of the header fields within the HTTP message.
+ *
+ * <p>This class tracks header values line-by-line. A field with multiple comma-
+ * separated values on the same line will be treated as a field with a single
+ * value by this class. It is the caller's responsibility to detect and split
+ * on commas if their field permits multiple values. This simplifies use of
+ * single-valued fields whose values routinely contain commas, such as cookies
+ * or dates.
+ *
+ * <p>This class trims whitespace from values. It never returns values with
+ * leading or trailing whitespace.
+ *
+ * <p>Instances of this class are immutable. Use {@link Builder} to create
+ * instances.
+ */
+public final class Headers {
+  private final String[] namesAndValues;
+
+  private Headers(Builder builder) {
+    this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
+  }
+
+  private Headers(String[] namesAndValues) {
+    this.namesAndValues = namesAndValues;
+  }
+
+  /** Returns the last value corresponding to the specified field, or null. */
+  public String get(String name) {
+    return get(namesAndValues, name);
+  }
+
+  /**
+   * Returns the last value corresponding to the specified field parsed as an
+   * HTTP date, or null if either the field is absent or cannot be parsed as a
+   * date.
+   */
+  public Date getDate(String name) {
+    String value = get(name);
+    return value != null ? HttpDate.parse(value) : null;
+  }
+
+  /** Returns the number of field values. */
+  public int size() {
+    return namesAndValues.length / 2;
+  }
+
+  /** Returns the field at {@code position} or null if that is out of range. */
+  public String name(int index) {
+    int nameIndex = index * 2;
+    if (nameIndex < 0 || nameIndex >= namesAndValues.length) {
+      return null;
+    }
+    return namesAndValues[nameIndex];
+  }
+
+  /** Returns the value at {@code index} or null if that is out of range. */
+  public String value(int index) {
+    int valueIndex = index * 2 + 1;
+    if (valueIndex < 0 || valueIndex >= namesAndValues.length) {
+      return null;
+    }
+    return namesAndValues[valueIndex];
+  }
+
+  /** Returns an immutable case-insensitive set of header names. */
+  public Set<String> names() {
+    TreeSet<String> result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
+    for (int i = 0, size = size(); i < size; i++) {
+      result.add(name(i));
+    }
+    return Collections.unmodifiableSet(result);
+  }
+
+  /** Returns an immutable list of the header values for {@code name}. */
+  public List<String> values(String name) {
+    List<String> result = null;
+    for (int i = 0, size = size(); i < size; i++) {
+      if (name.equalsIgnoreCase(name(i))) {
+        if (result == null) result = new ArrayList<>(2);
+        result.add(value(i));
+      }
+    }
+    return result != null
+        ? Collections.unmodifiableList(result)
+        : Collections.<String>emptyList();
+  }
+
+  public Builder newBuilder() {
+    Builder result = new Builder();
+    result.namesAndValues.addAll(Arrays.asList(namesAndValues));
+    return result;
+  }
+
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder();
+    for (int i = 0, size = size(); i < size; i++) {
+      result.append(name(i)).append(": ").append(value(i)).append("\n");
+    }
+    return result.toString();
+  }
+
+  private static String get(String[] namesAndValues, String name) {
+    for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
+      if (name.equalsIgnoreCase(namesAndValues[i])) {
+        return namesAndValues[i + 1];
+      }
+    }
+    return null;
+  }
+
+  /**
+   * Returns headers for the alternating header names and values. There must be
+   * an even number of arguments, and they must alternate between header names
+   * and values.
+   */
+  public static Headers of(String... namesAndValues) {
+    if (namesAndValues == null || namesAndValues.length % 2 != 0) {
+      throw new IllegalArgumentException("Expected alternating header names and values");
+    }
+
+    // Make a defensive copy and clean it up.
+    namesAndValues = namesAndValues.clone();
+    for (int i = 0; i < namesAndValues.length; i++) {
+      if (namesAndValues[i] == null) throw new IllegalArgumentException("Headers cannot be null");
+      namesAndValues[i] = namesAndValues[i].trim();
+    }
+
+    // Check for malformed headers.
+    for (int i = 0; i < namesAndValues.length; i += 2) {
+      String name = namesAndValues[i];
+      String value = namesAndValues[i + 1];
+      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
+      }
+    }
+
+    return new Headers(namesAndValues);
+  }
+
+  public static final class Builder {
+    private final List<String> namesAndValues = new ArrayList<>(20);
+
+    /**
+     * Add a header line without any validation. Only appropriate for headers from the remote peer
+     * or cache.
+     */
+    Builder addLenient(String line) {
+      int index = line.indexOf(":", 1);
+      if (index != -1) {
+        return addLenient(line.substring(0, index), line.substring(index + 1));
+      } else if (line.startsWith(":")) {
+        // Work around empty header names and header names that start with a
+        // colon (created by old broken SPDY versions of the response cache).
+        return addLenient("", line.substring(1)); // Empty header name.
+      } else {
+        return addLenient("", line); // No header name.
+      }
+    }
+
+    /** Add an header line containing a field name, a literal colon, and a value. */
+    public Builder add(String line) {
+      int index = line.indexOf(":");
+      if (index == -1) {
+        throw new IllegalArgumentException("Unexpected header: " + line);
+      }
+      return add(line.substring(0, index).trim(), line.substring(index + 1));
+    }
+
+    /** Add a field with the specified value. */
+    public Builder add(String name, String value) {
+      if (name == null) throw new IllegalArgumentException("name == null");
+      if (value == null) throw new IllegalArgumentException("value == null");
+      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
+      }
+      return addLenient(name, value);
+    }
+
+    /**
+     * Add a field with the specified value without any validation. Only
+     * appropriate for headers from the remote peer.
+     */
+    private Builder addLenient(String name, String value) {
+      namesAndValues.add(name);
+      namesAndValues.add(value.trim());
+      return this;
+    }
+
+    public Builder removeAll(String name) {
+      for (int i = 0; i < namesAndValues.size(); i += 2) {
+        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
+          namesAndValues.remove(i); // name
+          namesAndValues.remove(i); // value
+          i -= 2;
+        }
+      }
+      return this;
+    }
+
+    /**
+     * Set a field with the specified value. If the field is not found, it is
+     * added. If the field is found, the existing values are replaced.
+     */
+    public Builder set(String name, String value) {
+      removeAll(name);
+      add(name, value);
+      return this;
+    }
+
+    /** Equivalent to {@code build().get(name)}, but potentially faster. */
+    public String get(String name) {
+      for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
+        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
+          return namesAndValues.get(i + 1);
+        }
+      }
+      return null;
+    }
+
+    public Headers build() {
+      return new Headers(this);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java b/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
deleted file mode 100644
index 8210318276..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
+++ /dev/null
@@ -1,722 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Base64;
-import com.squareup.okhttp.internal.DiskLruCache;
-import com.squareup.okhttp.internal.StrictLineReader;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
-import com.squareup.okhttp.internal.http.HttpsEngine;
-import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
-import com.squareup.okhttp.internal.http.RawHeaders;
-import com.squareup.okhttp.internal.http.ResponseHeaders;
-import java.io.BufferedWriter;
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FilterInputStream;
-import java.io.FilterOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.SecureCacheResponse;
-import java.net.URI;
-import java.net.URLConnection;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.security.cert.CertificateEncodingException;
-import java.security.cert.CertificateException;
-import java.security.cert.CertificateFactory;
-import java.security.cert.X509Certificate;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocket;
-
-import static com.squareup.okhttp.internal.Util.US_ASCII;
-import static com.squareup.okhttp.internal.Util.UTF_8;
-
-/**
- * Caches HTTP and HTTPS responses to the filesystem so they may be reused,
- * saving time and bandwidth.
- *
- * <h3>Cache Optimization</h3>
- * To measure cache effectiveness, this class tracks three statistics:
- * <ul>
- *     <li><strong>{@link #getRequestCount() Request Count:}</strong> the number
- *         of HTTP requests issued since this cache was created.
- *     <li><strong>{@link #getNetworkCount() Network Count:}</strong> the
- *         number of those requests that required network use.
- *     <li><strong>{@link #getHitCount() Hit Count:}</strong> the number of
- *         those requests whose responses were served by the cache.
- * </ul>
- * Sometimes a request will result in a conditional cache hit. If the cache
- * contains a stale copy of the response, the client will issue a conditional
- * {@code GET}. The server will then send either the updated response if it has
- * changed, or a short 'not modified' response if the client's copy is still
- * valid. Such responses increment both the network count and hit count.
- *
- * <p>The best way to improve the cache hit rate is by configuring the web
- * server to return cacheable responses. Although this client honors all <a
- * href="http://www.ietf.org/rfc/rfc2616.txt">HTTP/1.1 (RFC 2068)</a> cache
- * headers, it doesn't cache partial responses.
- *
- * <h3>Force a Network Response</h3>
- * In some situations, such as after a user clicks a 'refresh' button, it may be
- * necessary to skip the cache, and fetch data directly from the server. To force
- * a full refresh, add the {@code no-cache} directive: <pre>   {@code
- *         connection.addRequestProperty("Cache-Control", "no-cache");
- * }</pre>
- * If it is only necessary to force a cached response to be validated by the
- * server, use the more efficient {@code max-age=0} instead: <pre>   {@code
- *         connection.addRequestProperty("Cache-Control", "max-age=0");
- * }</pre>
- *
- * <h3>Force a Cache Response</h3>
- * Sometimes you'll want to show resources if they are available immediately,
- * but not otherwise. This can be used so your application can show
- * <i>something</i> while waiting for the latest data to be downloaded. To
- * restrict a request to locally-cached resources, add the {@code
- * only-if-cached} directive: <pre>   {@code
- *     try {
- *         connection.addRequestProperty("Cache-Control", "only-if-cached");
- *         InputStream cached = connection.getInputStream();
- *         // the resource was cached! show it
- *     } catch (FileNotFoundException e) {
- *         // the resource was not cached
- *     }
- * }</pre>
- * This technique works even better in situations where a stale response is
- * better than no response. To permit stale cached responses, use the {@code
- * max-stale} directive with the maximum staleness in seconds: <pre>   {@code
- *         int maxStale = 60 * 60 * 24 * 28; // tolerate 4-weeks stale
- *         connection.addRequestProperty("Cache-Control", "max-stale=" + maxStale);
- * }</pre>
- */
-public final class HttpResponseCache extends ResponseCache {
-  // TODO: add APIs to iterate the cache?
-  private static final int VERSION = 201105;
-  private static final int ENTRY_METADATA = 0;
-  private static final int ENTRY_BODY = 1;
-  private static final int ENTRY_COUNT = 2;
-
-  private final DiskLruCache cache;
-
-  /* read and write statistics, all guarded by 'this' */
-  private int writeSuccessCount;
-  private int writeAbortCount;
-  private int networkCount;
-  private int hitCount;
-  private int requestCount;
-
-  /**
-   * Although this class only exposes the limited ResponseCache API, it
-   * implements the full OkResponseCache interface. This field is used as a
-   * package private handle to the complete implementation. It delegates to
-   * public and private members of this type.
-   */
-  final OkResponseCache okResponseCache = new OkResponseCache() {
-    @Override public CacheResponse get(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) throws IOException {
-      return HttpResponseCache.this.get(uri, requestMethod, requestHeaders);
-    }
-
-    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-      return HttpResponseCache.this.put(uri, connection);
-    }
-
-    @Override public void maybeRemove(String requestMethod, URI uri) throws IOException {
-      HttpResponseCache.this.maybeRemove(requestMethod, uri);
-    }
-
-    @Override public void update(
-        CacheResponse conditionalCacheHit, HttpURLConnection connection) throws IOException {
-      HttpResponseCache.this.update(conditionalCacheHit, connection);
-    }
-
-    @Override public void trackConditionalCacheHit() {
-      HttpResponseCache.this.trackConditionalCacheHit();
-    }
-
-    @Override public void trackResponse(ResponseSource source) {
-      HttpResponseCache.this.trackResponse(source);
-    }
-  };
-
-  public HttpResponseCache(File directory, long maxSize) throws IOException {
-    cache = DiskLruCache.open(directory, VERSION, ENTRY_COUNT, maxSize);
-  }
-
-  private String uriToKey(URI uri) {
-    return Util.hash(uri.toString());
-  }
-
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) {
-    String key = uriToKey(uri);
-    DiskLruCache.Snapshot snapshot;
-    Entry entry;
-    try {
-      snapshot = cache.get(key);
-      if (snapshot == null) {
-        return null;
-      }
-      entry = new Entry(snapshot.getInputStream(ENTRY_METADATA));
-    } catch (IOException e) {
-      // Give up because the cache cannot be read.
-      return null;
-    }
-
-    if (!entry.matches(uri, requestMethod, requestHeaders)) {
-      snapshot.close();
-      return null;
-    }
-
-    return entry.isHttps() ? new EntrySecureCacheResponse(entry, snapshot)
-        : new EntryCacheResponse(entry, snapshot);
-  }
-
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    if (!(urlConnection instanceof HttpURLConnection)) {
-      return null;
-    }
-
-    HttpURLConnection httpConnection = (HttpURLConnection) urlConnection;
-    String requestMethod = httpConnection.getRequestMethod();
-
-    if (maybeRemove(requestMethod, uri)) {
-      return null;
-    }
-    if (!requestMethod.equals("GET")) {
-      // Don't cache non-GET responses. We're technically allowed to cache
-      // HEAD requests and some POST requests, but the complexity of doing
-      // so is high and the benefit is low.
-      return null;
-    }
-
-    HttpEngine httpEngine = getHttpEngine(httpConnection);
-    if (httpEngine == null) {
-      // Don't cache unless the HTTP implementation is ours.
-      return null;
-    }
-
-    ResponseHeaders response = httpEngine.getResponseHeaders();
-    if (response.hasVaryAll()) {
-      return null;
-    }
-
-    RawHeaders varyHeaders =
-        httpEngine.getRequestHeaders().getHeaders().getAll(response.getVaryFields());
-    Entry entry = new Entry(uri, varyHeaders, httpConnection);
-    DiskLruCache.Editor editor = null;
-    try {
-      editor = cache.edit(uriToKey(uri));
-      if (editor == null) {
-        return null;
-      }
-      entry.writeTo(editor);
-      return new CacheRequestImpl(editor);
-    } catch (IOException e) {
-      abortQuietly(editor);
-      return null;
-    }
-  }
-
-  /**
-   * Returns true if the supplied {@code requestMethod} potentially invalidates an entry in the
-   * cache.
-   */
-  private boolean maybeRemove(String requestMethod, URI uri) {
-    if (requestMethod.equals("POST") || requestMethod.equals("PUT") || requestMethod.equals(
-        "DELETE")) {
-      try {
-        cache.remove(uriToKey(uri));
-      } catch (IOException ignored) {
-        // The cache cannot be written.
-      }
-      return true;
-    }
-    return false;
-  }
-
-  private void update(CacheResponse conditionalCacheHit, HttpURLConnection httpConnection)
-      throws IOException {
-    HttpEngine httpEngine = getHttpEngine(httpConnection);
-    URI uri = httpEngine.getUri();
-    ResponseHeaders response = httpEngine.getResponseHeaders();
-    RawHeaders varyHeaders =
-        httpEngine.getRequestHeaders().getHeaders().getAll(response.getVaryFields());
-    Entry entry = new Entry(uri, varyHeaders, httpConnection);
-    DiskLruCache.Snapshot snapshot = (conditionalCacheHit instanceof EntryCacheResponse)
-        ? ((EntryCacheResponse) conditionalCacheHit).snapshot
-        : ((EntrySecureCacheResponse) conditionalCacheHit).snapshot;
-    DiskLruCache.Editor editor = null;
-    try {
-      editor = snapshot.edit(); // returns null if snapshot is not current
-      if (editor != null) {
-        entry.writeTo(editor);
-        editor.commit();
-      }
-    } catch (IOException e) {
-      abortQuietly(editor);
-    }
-  }
-
-  private void abortQuietly(DiskLruCache.Editor editor) {
-    // Give up because the cache cannot be written.
-    try {
-      if (editor != null) {
-        editor.abort();
-      }
-    } catch (IOException ignored) {
-    }
-  }
-
-  private HttpEngine getHttpEngine(URLConnection httpConnection) {
-    if (httpConnection instanceof HttpURLConnectionImpl) {
-      return ((HttpURLConnectionImpl) httpConnection).getHttpEngine();
-    } else if (httpConnection instanceof HttpsURLConnectionImpl) {
-      return ((HttpsURLConnectionImpl) httpConnection).getHttpEngine();
-    } else {
-      return null;
-    }
-  }
-
-  /**
-   * Closes the cache and deletes all of its stored values. This will delete
-   * all files in the cache directory including files that weren't created by
-   * the cache.
-   */
-  public void delete() throws IOException {
-    cache.delete();
-  }
-
-  public synchronized int getWriteAbortCount() {
-    return writeAbortCount;
-  }
-
-  public synchronized int getWriteSuccessCount() {
-    return writeSuccessCount;
-  }
-
-  public long getSize() {
-    return cache.size();
-  }
-
-  public long getMaxSize() {
-    return cache.getMaxSize();
-  }
-
-  public void flush() throws IOException {
-    cache.flush();
-  }
-
-  public void close() throws IOException {
-    cache.close();
-  }
-
-  public File getDirectory() {
-    return cache.getDirectory();
-  }
-
-  public boolean isClosed() {
-    return cache.isClosed();
-  }
-
-  private synchronized void trackResponse(ResponseSource source) {
-    requestCount++;
-
-    switch (source) {
-      case CACHE:
-        hitCount++;
-        break;
-      case CONDITIONAL_CACHE:
-      case NETWORK:
-        networkCount++;
-        break;
-    }
-  }
-
-  private synchronized void trackConditionalCacheHit() {
-    hitCount++;
-  }
-
-  public synchronized int getNetworkCount() {
-    return networkCount;
-  }
-
-  public synchronized int getHitCount() {
-    return hitCount;
-  }
-
-  public synchronized int getRequestCount() {
-    return requestCount;
-  }
-
-  private final class CacheRequestImpl extends CacheRequest {
-    private final DiskLruCache.Editor editor;
-    private OutputStream cacheOut;
-    private boolean done;
-    private OutputStream body;
-
-    public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
-      this.editor = editor;
-      this.cacheOut = editor.newOutputStream(ENTRY_BODY);
-      this.body = new FilterOutputStream(cacheOut) {
-        @Override public void close() throws IOException {
-          synchronized (HttpResponseCache.this) {
-            if (done) {
-              return;
-            }
-            done = true;
-            writeSuccessCount++;
-          }
-          super.close();
-          editor.commit();
-        }
-
-        @Override public void write(byte[] buffer, int offset, int length) throws IOException {
-          // Since we don't override "write(int oneByte)", we can write directly to "out"
-          // and avoid the inefficient implementation from the FilterOutputStream.
-          out.write(buffer, offset, length);
-        }
-      };
-    }
-
-    @Override public void abort() {
-      synchronized (HttpResponseCache.this) {
-        if (done) {
-          return;
-        }
-        done = true;
-        writeAbortCount++;
-      }
-      Util.closeQuietly(cacheOut);
-      try {
-        editor.abort();
-      } catch (IOException ignored) {
-      }
-    }
-
-    @Override public OutputStream getBody() throws IOException {
-      return body;
-    }
-  }
-
-  private static final class Entry {
-    private final String uri;
-    private final RawHeaders varyHeaders;
-    private final String requestMethod;
-    private final RawHeaders responseHeaders;
-    private final String cipherSuite;
-    private final Certificate[] peerCertificates;
-    private final Certificate[] localCertificates;
-
-    /**
-     * Reads an entry from an input stream. A typical entry looks like this:
-     * <pre>{@code
-     *   http://google.com/foo
-     *   GET
-     *   2
-     *   Accept-Language: fr-CA
-     *   Accept-Charset: UTF-8
-     *   HTTP/1.1 200 OK
-     *   3
-     *   Content-Type: image/png
-     *   Content-Length: 100
-     *   Cache-Control: max-age=600
-     * }</pre>
-     *
-     * <p>A typical HTTPS file looks like this:
-     * <pre>{@code
-     *   https://google.com/foo
-     *   GET
-     *   2
-     *   Accept-Language: fr-CA
-     *   Accept-Charset: UTF-8
-     *   HTTP/1.1 200 OK
-     *   3
-     *   Content-Type: image/png
-     *   Content-Length: 100
-     *   Cache-Control: max-age=600
-     *
-     *   AES_256_WITH_MD5
-     *   2
-     *   base64-encoded peerCertificate[0]
-     *   base64-encoded peerCertificate[1]
-     *   -1
-     * }</pre>
-     * The file is newline separated. The first two lines are the URL and
-     * the request method. Next is the number of HTTP Vary request header
-     * lines, followed by those lines.
-     *
-     * <p>Next is the response status line, followed by the number of HTTP
-     * response header lines, followed by those lines.
-     *
-     * <p>HTTPS responses also contain SSL session information. This begins
-     * with a blank line, and then a line containing the cipher suite. Next
-     * is the length of the peer certificate chain. These certificates are
-     * base64-encoded and appear each on their own line. The next line
-     * contains the length of the local certificate chain. These
-     * certificates are also base64-encoded and appear each on their own
-     * line. A length of -1 is used to encode a null array.
-     */
-    public Entry(InputStream in) throws IOException {
-      try {
-        StrictLineReader reader = new StrictLineReader(in, US_ASCII);
-        uri = reader.readLine();
-        requestMethod = reader.readLine();
-        varyHeaders = new RawHeaders();
-        int varyRequestHeaderLineCount = reader.readInt();
-        for (int i = 0; i < varyRequestHeaderLineCount; i++) {
-          varyHeaders.addLine(reader.readLine());
-        }
-
-        responseHeaders = new RawHeaders();
-        responseHeaders.setStatusLine(reader.readLine());
-        int responseHeaderLineCount = reader.readInt();
-        for (int i = 0; i < responseHeaderLineCount; i++) {
-          responseHeaders.addLine(reader.readLine());
-        }
-
-        if (isHttps()) {
-          String blank = reader.readLine();
-          if (blank.length() > 0) {
-            throw new IOException("expected \"\" but was \"" + blank + "\"");
-          }
-          cipherSuite = reader.readLine();
-          peerCertificates = readCertArray(reader);
-          localCertificates = readCertArray(reader);
-        } else {
-          cipherSuite = null;
-          peerCertificates = null;
-          localCertificates = null;
-        }
-      } finally {
-        in.close();
-      }
-    }
-
-    public Entry(URI uri, RawHeaders varyHeaders, HttpURLConnection httpConnection)
-        throws IOException {
-      this.uri = uri.toString();
-      this.varyHeaders = varyHeaders;
-      this.requestMethod = httpConnection.getRequestMethod();
-      this.responseHeaders = RawHeaders.fromMultimap(httpConnection.getHeaderFields(), true);
-
-      SSLSocket sslSocket = getSslSocket(httpConnection);
-      if (sslSocket != null) {
-        cipherSuite = sslSocket.getSession().getCipherSuite();
-        Certificate[] peerCertificatesNonFinal = null;
-        try {
-          peerCertificatesNonFinal = sslSocket.getSession().getPeerCertificates();
-        } catch (SSLPeerUnverifiedException ignored) {
-        }
-        peerCertificates = peerCertificatesNonFinal;
-        localCertificates = sslSocket.getSession().getLocalCertificates();
-      } else {
-        cipherSuite = null;
-        peerCertificates = null;
-        localCertificates = null;
-      }
-    }
-
-    /**
-     * Returns the SSL socket used by {@code httpConnection} for HTTPS, nor null
-     * if the connection isn't using HTTPS. Since we permit redirects across
-     * protocols (HTTP to HTTPS or vice versa), the implementation type of the
-     * connection doesn't necessarily match the implementation type of its HTTP
-     * engine.
-     */
-    private SSLSocket getSslSocket(HttpURLConnection httpConnection) {
-      HttpEngine engine = httpConnection instanceof HttpsURLConnectionImpl
-          ? ((HttpsURLConnectionImpl) httpConnection).getHttpEngine()
-          : ((HttpURLConnectionImpl) httpConnection).getHttpEngine();
-      return engine instanceof HttpsEngine
-          ? ((HttpsEngine) engine).getSslSocket()
-          : null;
-    }
-
-    public void writeTo(DiskLruCache.Editor editor) throws IOException {
-      OutputStream out = editor.newOutputStream(ENTRY_METADATA);
-      Writer writer = new BufferedWriter(new OutputStreamWriter(out, UTF_8));
-
-      writer.write(uri + '\n');
-      writer.write(requestMethod + '\n');
-      writer.write(Integer.toString(varyHeaders.length()) + '\n');
-      for (int i = 0; i < varyHeaders.length(); i++) {
-        writer.write(varyHeaders.getFieldName(i) + ": " + varyHeaders.getValue(i) + '\n');
-      }
-
-      writer.write(responseHeaders.getStatusLine() + '\n');
-      writer.write(Integer.toString(responseHeaders.length()) + '\n');
-      for (int i = 0; i < responseHeaders.length(); i++) {
-        writer.write(responseHeaders.getFieldName(i) + ": " + responseHeaders.getValue(i) + '\n');
-      }
-
-      if (isHttps()) {
-        writer.write('\n');
-        writer.write(cipherSuite + '\n');
-        writeCertArray(writer, peerCertificates);
-        writeCertArray(writer, localCertificates);
-      }
-      writer.close();
-    }
-
-    private boolean isHttps() {
-      return uri.startsWith("https://");
-    }
-
-    private Certificate[] readCertArray(StrictLineReader reader) throws IOException {
-      int length = reader.readInt();
-      if (length == -1) {
-        return null;
-      }
-      try {
-        CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-        Certificate[] result = new Certificate[length];
-        for (int i = 0; i < result.length; i++) {
-          String line = reader.readLine();
-          byte[] bytes = Base64.decode(line.getBytes("US-ASCII"));
-          result[i] = certificateFactory.generateCertificate(new ByteArrayInputStream(bytes));
-        }
-        return result;
-      } catch (CertificateException e) {
-        throw new IOException(e.getMessage());
-      }
-    }
-
-    private void writeCertArray(Writer writer, Certificate[] certificates) throws IOException {
-      if (certificates == null) {
-        writer.write("-1\n");
-        return;
-      }
-      try {
-        writer.write(Integer.toString(certificates.length) + '\n');
-        for (Certificate certificate : certificates) {
-          byte[] bytes = certificate.getEncoded();
-          String line = Base64.encode(bytes);
-          writer.write(line + '\n');
-        }
-      } catch (CertificateEncodingException e) {
-        throw new IOException(e.getMessage());
-      }
-    }
-
-    public boolean matches(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) {
-      return this.uri.equals(uri.toString())
-          && this.requestMethod.equals(requestMethod)
-          && new ResponseHeaders(uri, responseHeaders).varyMatches(varyHeaders.toMultimap(false),
-          requestHeaders);
-    }
-  }
-
-  /**
-   * Returns an input stream that reads the body of a snapshot, closing the
-   * snapshot when the stream is closed.
-   */
-  private static InputStream newBodyInputStream(final DiskLruCache.Snapshot snapshot) {
-    return new FilterInputStream(snapshot.getInputStream(ENTRY_BODY)) {
-      @Override public void close() throws IOException {
-        snapshot.close();
-        super.close();
-      }
-    };
-  }
-
-  static class EntryCacheResponse extends CacheResponse {
-    private final Entry entry;
-    private final DiskLruCache.Snapshot snapshot;
-    private final InputStream in;
-
-    public EntryCacheResponse(Entry entry, DiskLruCache.Snapshot snapshot) {
-      this.entry = entry;
-      this.snapshot = snapshot;
-      this.in = newBodyInputStream(snapshot);
-    }
-
-    @Override public Map<String, List<String>> getHeaders() {
-      return entry.responseHeaders.toMultimap(true);
-    }
-
-    @Override public InputStream getBody() {
-      return in;
-    }
-  }
-
-  static class EntrySecureCacheResponse extends SecureCacheResponse {
-    private final Entry entry;
-    private final DiskLruCache.Snapshot snapshot;
-    private final InputStream in;
-
-    public EntrySecureCacheResponse(Entry entry, DiskLruCache.Snapshot snapshot) {
-      this.entry = entry;
-      this.snapshot = snapshot;
-      this.in = newBodyInputStream(snapshot);
-    }
-
-    @Override public Map<String, List<String>> getHeaders() {
-      return entry.responseHeaders.toMultimap(true);
-    }
-
-    @Override public InputStream getBody() {
-      return in;
-    }
-
-    @Override public String getCipherSuite() {
-      return entry.cipherSuite;
-    }
-
-    @Override public List<Certificate> getServerCertificateChain()
-        throws SSLPeerUnverifiedException {
-      if (entry.peerCertificates == null || entry.peerCertificates.length == 0) {
-        throw new SSLPeerUnverifiedException(null);
-      }
-      return Arrays.asList(entry.peerCertificates.clone());
-    }
-
-    @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-      if (entry.peerCertificates == null || entry.peerCertificates.length == 0) {
-        throw new SSLPeerUnverifiedException(null);
-      }
-      return ((X509Certificate) entry.peerCertificates[0]).getSubjectX500Principal();
-    }
-
-    @Override public List<Certificate> getLocalCertificateChain() {
-      if (entry.localCertificates == null || entry.localCertificates.length == 0) {
-        return null;
-      }
-      return Arrays.asList(entry.localCertificates.clone());
-    }
-
-    @Override public Principal getLocalPrincipal() {
-      if (entry.localCertificates == null || entry.localCertificates.length == 0) {
-        return null;
-      }
-      return ((X509Certificate) entry.localCertificates[0]).getSubjectX500Principal();
-    }
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java b/okhttp/src/main/java/com/squareup/okhttp/Interceptor.java
similarity index 51%
rename from okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java
rename to okhttp/src/main/java/com/squareup/okhttp/Interceptor.java
index 4eca172d35..03325be973 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Interceptor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (C) 2014 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,23 +15,19 @@
  */
 package com.squareup.okhttp;
 
-/** The source of an HTTP response. */
-public enum ResponseSource {
+import java.io.IOException;
 
-  /** The response was returned from the local cache. */
-  CACHE,
-
-  /**
-   * The response is available in the cache but must be validated with the
-   * network. The cache result will be used if it is still valid; otherwise
-   * the network's response will be used.
-   */
-  CONDITIONAL_CACHE,
-
-  /** The response was returned from the network. */
-  NETWORK;
+/**
+ * Observes, modifies, and potentially short-circuits requests going out and the corresponding
+ * requests coming back in. Typically interceptors will be used to add, remove, or transform headers
+ * on the request or response.
+ */
+public interface Interceptor {
+  Response intercept(Chain chain) throws IOException;
 
-  public boolean requiresConnection() {
-    return this == CONDITIONAL_CACHE || this == NETWORK;
+  interface Chain {
+    Request request();
+    Response proceed(Request request) throws IOException;
+    Connection connection();
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Job.java b/okhttp/src/main/java/com/squareup/okhttp/Job.java
deleted file mode 100644
index 3a453847a2..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/Job.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-
-final class Job implements Runnable {
-  final HttpURLConnection connection;
-  final Request request;
-  final Response.Receiver responseReceiver;
-  final Dispatcher dispatcher;
-
-  public Job(Dispatcher dispatcher, HttpURLConnection connection, Request request,
-      Response.Receiver responseReceiver) {
-    this.dispatcher = dispatcher;
-    this.connection = connection;
-    this.request = request;
-    this.responseReceiver = responseReceiver;
-  }
-
-  @Override public void run() {
-    try {
-      sendRequest();
-      Response response = readResponse();
-      responseReceiver.onResponse(response);
-    } catch (IOException e) {
-      responseReceiver.onFailure(new Failure.Builder()
-          .request(request)
-          .exception(e)
-          .build());
-    } finally {
-      connection.disconnect();
-      dispatcher.finished(this);
-    }
-  }
-
-  private HttpURLConnection sendRequest() throws IOException {
-    for (int i = 0; i < request.headerCount(); i++) {
-      connection.addRequestProperty(request.headerName(i), request.headerValue(i));
-    }
-    Request.Body body = request.body();
-    if (body != null) {
-      connection.setDoOutput(true);
-      long contentLength = body.contentLength();
-      if (contentLength == -1 || contentLength > Integer.MAX_VALUE) {
-        connection.setChunkedStreamingMode(0);
-      } else {
-        // Don't call setFixedLengthStreamingMode(long); that's only available on Java 1.7+.
-        connection.setFixedLengthStreamingMode((int) contentLength);
-      }
-      body.writeTo(connection.getOutputStream());
-    }
-    return connection;
-  }
-
-  private Response readResponse() throws IOException {
-    int responseCode = connection.getResponseCode();
-    Response.Builder responseBuilder = new Response.Builder(request, responseCode);
-
-    for (int i = 0; true; i++) {
-      String name = connection.getHeaderFieldKey(i);
-      if (name == null) break;
-      String value = connection.getHeaderField(i);
-      responseBuilder.addHeader(name, value);
-    }
-
-    responseBuilder.body(new Dispatcher.RealResponseBody(connection, connection.getInputStream()));
-    // TODO: set redirectedBy
-    return responseBuilder.build();
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/MediaType.java b/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
index 2c09596ff7..4d2f1fcf44 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
@@ -29,7 +29,7 @@
   private static final String QUOTED = "\"([^\"]*)\"";
   private static final Pattern TYPE_SUBTYPE = Pattern.compile(TOKEN + "/" + TOKEN);
   private static final Pattern PARAMETER = Pattern.compile(
-      ";\\s*" + TOKEN + "=(?:" + TOKEN + "|" + QUOTED + ")");
+      ";\\s*(?:" + TOKEN + "=(?:" + TOKEN + "|" + QUOTED + "))?");
 
   private final String mediaType;
   private final String type;
@@ -61,10 +61,13 @@ public static MediaType parse(String string) {
 
       String name = parameter.group(1);
       if (name == null || !name.equalsIgnoreCase("charset")) continue;
-      if (charset != null) throw new IllegalArgumentException("Multiple charsets: " + string);
-      charset = parameter.group(2) != null
+      String charsetParameter = parameter.group(2) != null
           ? parameter.group(2)  // Value is a token.
           : parameter.group(3); // Value is a quoted string.
+      if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
+        throw new IllegalArgumentException("Multiple different charsets: " + string);
+      }
+      charset = charsetParameter;
     }
 
     return new MediaType(string, type, subtype, charset);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
new file mode 100644
index 0000000000..be24c7b8a7
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
@@ -0,0 +1,262 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+import okio.BufferedSink;
+import okio.ByteString;
+
+/**
+ * Fluent API to build <a href="http://www.ietf.org/rfc/rfc2387.txt">RFC
+ * 2387</a>-compliant request bodies.
+ */
+public final class MultipartBuilder {
+  /**
+   * The "mixed" subtype of "multipart" is intended for use when the body
+   * parts are independent and need to be bundled in a particular order. Any
+   * "multipart" subtypes that an implementation does not recognize must be
+   * treated as being of subtype "mixed".
+   */
+  public static final MediaType MIXED = MediaType.parse("multipart/mixed");
+
+  /**
+   * The "multipart/alternative" type is syntactically identical to
+   * "multipart/mixed", but the semantics are different. In particular, each
+   * of the body parts is an "alternative" version of the same information.
+   */
+  public static final MediaType ALTERNATIVE = MediaType.parse("multipart/alternative");
+
+  /**
+   * This type is syntactically identical to "multipart/mixed", but the
+   * semantics are different. In particular, in a digest, the default {@code
+   * Content-Type} value for a body part is changed from "text/plain" to
+   * "message/rfc822".
+   */
+  public static final MediaType DIGEST = MediaType.parse("multipart/digest");
+
+  /**
+   * This type is syntactically identical to "multipart/mixed", but the
+   * semantics are different. In particular, in a parallel entity, the order
+   * of body parts is not significant.
+   */
+  public static final MediaType PARALLEL = MediaType.parse("multipart/parallel");
+
+  /**
+   * The media-type multipart/form-data follows the rules of all multipart
+   * MIME data streams as outlined in RFC 2046. In forms, there are a series
+   * of fields to be supplied by the user who fills out the form. Each field
+   * has a name. Within a given form, the names are unique.
+   */
+  public static final MediaType FORM = MediaType.parse("multipart/form-data");
+
+  private static final byte[] COLONSPACE = { ':', ' ' };
+  private static final byte[] CRLF = { '\r', '\n' };
+  private static final byte[] DASHDASH = { '-', '-' };
+
+  private final ByteString boundary;
+  private MediaType type = MIXED;
+
+  // Parallel lists of nullable headers and non-null bodies.
+  private final List<Headers> partHeaders = new ArrayList<>();
+  private final List<RequestBody> partBodies = new ArrayList<>();
+
+  /** Creates a new multipart builder that uses a random boundary token. */
+  public MultipartBuilder() {
+    this(UUID.randomUUID().toString());
+  }
+
+  /**
+   * Creates a new multipart builder that uses {@code boundary} to separate
+   * parts. Prefer the no-argument constructor to defend against injection
+   * attacks.
+   */
+  public MultipartBuilder(String boundary) {
+    this.boundary = ByteString.encodeUtf8(boundary);
+  }
+
+  /**
+   * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the
+   * default), {@link #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and
+   * {@link #FORM}.
+   */
+  public MultipartBuilder type(MediaType type) {
+    if (type == null) {
+      throw new NullPointerException("type == null");
+    }
+    if (!type.type().equals("multipart")) {
+      throw new IllegalArgumentException("multipart != " + type);
+    }
+    this.type = type;
+    return this;
+  }
+
+  /** Add a part to the body. */
+  public MultipartBuilder addPart(RequestBody body) {
+    return addPart(null, body);
+  }
+
+  /** Add a part to the body. */
+  public MultipartBuilder addPart(Headers headers, RequestBody body) {
+    if (body == null) {
+      throw new NullPointerException("body == null");
+    }
+    if (headers != null && headers.get("Content-Type") != null) {
+      throw new IllegalArgumentException("Unexpected header: Content-Type");
+    }
+    if (headers != null && headers.get("Content-Length") != null) {
+      throw new IllegalArgumentException("Unexpected header: Content-Length");
+    }
+
+    partHeaders.add(headers);
+    partBodies.add(body);
+    return this;
+  }
+
+  /**
+   * Appends a quoted-string to a StringBuilder.
+   *
+   * <p>RFC 2388 is rather vague about how one should escape special characters
+   * in form-data parameters, and as it turns out Firefox and Chrome actually
+   * do rather different things, and both say in their comments that they're
+   * not really sure what the right approach is. We go with Chrome's behavior
+   * (which also experimentally seems to match what IE does), but if you
+   * actually want to have a good chance of things working, please avoid
+   * double-quotes, newlines, percent signs, and the like in your field names.
+   */
+  private static StringBuilder appendQuotedString(StringBuilder target, String key) {
+    target.append('"');
+    for (int i = 0, len = key.length(); i < len; i++) {
+      char ch = key.charAt(i);
+      switch (ch) {
+        case '\n':
+          target.append("%0A");
+          break;
+        case '\r':
+          target.append("%0D");
+          break;
+        case '"':
+          target.append("%22");
+          break;
+        default:
+          target.append(ch);
+          break;
+      }
+    }
+    target.append('"');
+    return target;
+  }
+
+  /** Add a form data part to the body. */
+  public MultipartBuilder addFormDataPart(String name, String value) {
+    return addFormDataPart(name, null, RequestBody.create(null, value));
+  }
+
+  /** Add a form data part to the body. */
+  public MultipartBuilder addFormDataPart(String name, String filename, RequestBody value) {
+    if (name == null) {
+      throw new NullPointerException("name == null");
+    }
+    StringBuilder disposition = new StringBuilder("form-data; name=");
+    appendQuotedString(disposition, name);
+
+    if (filename != null) {
+      disposition.append("; filename=");
+      appendQuotedString(disposition, filename);
+    }
+
+    return addPart(Headers.of("Content-Disposition", disposition.toString()), value);
+  }
+
+  /** Assemble the specified parts into a request body. */
+  public RequestBody build() {
+    if (partHeaders.isEmpty()) {
+      throw new IllegalStateException("Multipart body must have at least one part.");
+    }
+    return new MultipartRequestBody(type, boundary, partHeaders, partBodies);
+  }
+
+  private static final class MultipartRequestBody extends RequestBody {
+    private final ByteString boundary;
+    private final MediaType contentType;
+    private final List<Headers> partHeaders;
+    private final List<RequestBody> partBodies;
+
+    public MultipartRequestBody(MediaType type, ByteString boundary, List<Headers> partHeaders,
+        List<RequestBody> partBodies) {
+      if (type == null) throw new NullPointerException("type == null");
+
+      this.boundary = boundary;
+      this.contentType = MediaType.parse(type + "; boundary=" + boundary.utf8());
+      this.partHeaders = Util.immutableList(partHeaders);
+      this.partBodies = Util.immutableList(partBodies);
+    }
+
+    @Override public MediaType contentType() {
+      return contentType;
+    }
+
+    @Override public long contentLength() throws IOException {
+      return -1L;
+    }
+
+    @Override public void writeTo(BufferedSink sink) throws IOException {
+      for (int p = 0, partCount = partHeaders.size(); p < partCount; p++) {
+        Headers headers = partHeaders.get(p);
+        RequestBody body = partBodies.get(p);
+
+        sink.write(DASHDASH);
+        sink.write(boundary);
+        sink.write(CRLF);
+
+        if (headers != null) {
+          for (int h = 0, headerCount = headers.size(); h < headerCount; h++) {
+            sink.writeUtf8(headers.name(h))
+                .write(COLONSPACE)
+                .writeUtf8(headers.value(h))
+                .write(CRLF);
+          }
+        }
+
+        MediaType contentType = body.contentType();
+        if (contentType != null) {
+          sink.writeUtf8("Content-Type: ")
+              .writeUtf8(contentType.toString())
+              .write(CRLF);
+        }
+
+        long contentLength = body.contentLength();
+        if (contentLength != -1) {
+          sink.writeUtf8("Content-Length: ")
+              .writeUtf8(Long.toString(contentLength))
+              .write(CRLF);
+        }
+
+        sink.write(CRLF);
+        partBodies.get(p).writeTo(sink);
+        sink.write(CRLF);
+      }
+
+      sink.write(DASHDASH);
+      sink.write(boundary);
+      sink.write(DASHDASH);
+      sink.write(CRLF);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkAuthenticator.java b/okhttp/src/main/java/com/squareup/okhttp/OkAuthenticator.java
deleted file mode 100644
index a505419248..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/OkAuthenticator.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Base64;
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.net.Proxy;
-import java.net.URL;
-import java.util.List;
-
-/**
- * Responds to authentication challenges from the remote web or proxy server by
- * returning credentials.
- */
-public interface OkAuthenticator {
-  /**
-   * Returns a credential that satisfies the authentication challenge made by
-   * {@code url}. Returns null if the challenge cannot be satisfied. This method
-   * is called in response to an HTTP 401 unauthorized status code sent by the
-   * origin server.
-   *
-   * @param challenges parsed "WWW-Authenticate" challenge headers from the HTTP
-   *     response.
-   */
-  Credential authenticate(Proxy proxy, URL url, List<Challenge> challenges) throws IOException;
-
-  /**
-   * Returns a credential that satisfies the authentication challenge made by
-   * {@code proxy}. Returns null if the challenge cannot be satisfied. This
-   * method is called in response to an HTTP 401 unauthorized status code sent
-   * by the proxy server.
-   *
-   * @param challenges parsed "Proxy-Authenticate" challenge headers from the
-   *     HTTP response.
-   */
-  Credential authenticateProxy(Proxy proxy, URL url, List<Challenge> challenges) throws IOException;
-
-  /** An RFC 2617 challenge. */
-  public final class Challenge {
-    private final String scheme;
-    private final String realm;
-
-    public Challenge(String scheme, String realm) {
-      this.scheme = scheme;
-      this.realm = realm;
-    }
-
-    /** Returns the authentication scheme, like {@code Basic}. */
-    public String getScheme() {
-      return scheme;
-    }
-
-    /** Returns the protection space. */
-    public String getRealm() {
-      return realm;
-    }
-
-    @Override public boolean equals(Object o) {
-      return o instanceof Challenge
-          && ((Challenge) o).scheme.equals(scheme)
-          && ((Challenge) o).realm.equals(realm);
-    }
-
-    @Override public int hashCode() {
-      return scheme.hashCode() + 31 * realm.hashCode();
-    }
-
-    @Override public String toString() {
-      return scheme + " realm=\"" + realm + "\"";
-    }
-  }
-
-  /** An RFC 2617 credential. */
-  public final class Credential {
-    private final String headerValue;
-
-    private Credential(String headerValue) {
-      this.headerValue = headerValue;
-    }
-
-    /** Returns an auth credential for the Basic scheme. */
-    public static Credential basic(String userName, String password) {
-      try {
-        String usernameAndPassword = userName + ":" + password;
-        byte[] bytes = usernameAndPassword.getBytes("ISO-8859-1");
-        String encoded = Base64.encode(bytes);
-        return new Credential("Basic " + encoded);
-      } catch (UnsupportedEncodingException e) {
-        throw new AssertionError();
-      }
-    }
-
-    public String getHeaderValue() {
-      return headerValue;
-    }
-
-    @Override public boolean equals(Object o) {
-      return o instanceof Credential && ((Credential) o).headerValue.equals(headerValue);
-    }
-
-    @Override public int hashCode() {
-      return headerValue.hashCode();
-    }
-
-    @Override public String toString() {
-      return headerValue;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index 2fe9996dbb..22da6d96be 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -15,56 +15,195 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.InternalCache;
+import com.squareup.okhttp.internal.Network;
+import com.squareup.okhttp.internal.RouteDatabase;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HttpAuthenticator;
-import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
-import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
-import com.squareup.okhttp.internal.http.OkResponseCacheAdapter;
+import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
+import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.Transport;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
+import java.io.IOException;
 import java.net.CookieHandler;
-import java.net.HttpURLConnection;
 import java.net.Proxy;
 import java.net.ProxySelector;
-import java.net.ResponseCache;
-import java.net.URL;
 import java.net.URLConnection;
-import java.net.URLStreamHandler;
-import java.net.URLStreamHandlerFactory;
-import java.util.Arrays;
+import java.security.GeneralSecurityException;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocketFactory;
 
-/** Configures and creates HTTP connections. */
-public final class OkHttpClient implements URLStreamHandlerFactory {
-  private static final List<String> DEFAULT_TRANSPORTS
-      = Util.immutableList(Arrays.asList("spdy/3", "http/1.1"));
+/**
+ * Configures and creates HTTP connections. Most applications can use a single
+ * OkHttpClient for all of their HTTP requests - benefiting from a shared
+ * response cache, thread pool, connection re-use, etc.
+ *
+ * <p>Instances of OkHttpClient are intended to be fully configured before they're
+ * shared - once shared they should be treated as immutable and can safely be used
+ * to concurrently open new connections. If required, threads can call
+ * {@link #clone()} to make a shallow copy of the OkHttpClient that can be
+ * safely modified with further configuration changes.
+ */
+public class OkHttpClient implements Cloneable {
+  private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
+      Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
+
+  private static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
+      ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, ConnectionSpec.CLEARTEXT);
+
+  static {
+    Internal.instance = new Internal() {
+      @Override public Transport newTransport(
+          Connection connection, HttpEngine httpEngine) throws IOException {
+        return connection.newTransport(httpEngine);
+      }
+
+      @Override public boolean clearOwner(Connection connection) {
+        return connection.clearOwner();
+      }
+
+      @Override public void closeIfOwnedBy(Connection connection, Object owner) throws IOException {
+        connection.closeIfOwnedBy(owner);
+      }
+
+      @Override public int recycleCount(Connection connection) {
+        return connection.recycleCount();
+      }
+
+      @Override public void setProtocol(Connection connection, Protocol protocol) {
+        connection.setProtocol(protocol);
+      }
+
+      @Override public void setOwner(Connection connection, HttpEngine httpEngine) {
+        connection.setOwner(httpEngine);
+      }
+
+      @Override public boolean isReadable(Connection pooled) {
+        return pooled.isReadable();
+      }
+
+      @Override public void addLenient(Headers.Builder builder, String line) {
+        builder.addLenient(line);
+      }
+
+      @Override public void setCache(OkHttpClient client, InternalCache internalCache) {
+        client.setInternalCache(internalCache);
+      }
+
+      @Override public InternalCache internalCache(OkHttpClient client) {
+        return client.internalCache();
+      }
+
+      @Override public void recycle(ConnectionPool pool, Connection connection) {
+        pool.recycle(connection);
+      }
+
+      @Override public RouteDatabase routeDatabase(OkHttpClient client) {
+        return client.routeDatabase();
+      }
+
+      @Override public Network network(OkHttpClient client) {
+        return client.network;
+      }
+
+      @Override public void setNetwork(OkHttpClient client, Network network) {
+        client.network = network;
+      }
+
+      @Override public void connectAndSetOwner(OkHttpClient client, Connection connection,
+          HttpEngine owner, Request request) throws IOException {
+        connection.connectAndSetOwner(client, owner, request);
+      }
+
+      @Override public TlsVersion tlsVersionForJavaName(String name) {
+        return TlsVersion.forJavaName(name);
+      }
+
+      @Override
+      public void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket) {
+        call.enqueue(responseCallback, forWebSocket);
+      }
+
+      @Override public void callEngineReleaseConnection(Call call) throws IOException {
+        call.engine.releaseConnection();
+      }
+
+      @Override public Connection callEngineGetConnection(Call call) {
+        return call.engine.getConnection();
+      }
+
+      @Override public void connectionSetOwner(Connection connection, Object owner) {
+        connection.setOwner(owner);
+      }
+    };
+  }
+
+  /** Lazily-initialized. */
+  private static SSLSocketFactory defaultSslSocketFactory;
 
   private final RouteDatabase routeDatabase;
-  private final Dispatcher dispatcher;
+  private Dispatcher dispatcher;
   private Proxy proxy;
-  private List<String> transports;
+  private List<Protocol> protocols;
+  private List<ConnectionSpec> connectionSpecs;
+  private final List<Interceptor> interceptors = new ArrayList<>();
+  private final List<Interceptor> networkInterceptors = new ArrayList<>();
   private ProxySelector proxySelector;
   private CookieHandler cookieHandler;
-  private ResponseCache responseCache;
+
+  /** Non-null if this client is caching; possibly by {@code cache}. */
+  private InternalCache internalCache;
+  private Cache cache;
+
+  private SocketFactory socketFactory;
   private SSLSocketFactory sslSocketFactory;
   private HostnameVerifier hostnameVerifier;
-  private OkAuthenticator authenticator;
+  private CertificatePinner certificatePinner;
+  private Authenticator authenticator;
   private ConnectionPool connectionPool;
-  private boolean followProtocolRedirects = true;
+  private Network network;
+  private boolean followSslRedirects = true;
+  private boolean followRedirects = true;
+  private boolean retryOnConnectionFailure = true;
   private int connectTimeout;
   private int readTimeout;
+  private int writeTimeout;
 
   public OkHttpClient() {
     routeDatabase = new RouteDatabase();
     dispatcher = new Dispatcher();
   }
 
-  private OkHttpClient(OkHttpClient copyFrom) {
-    routeDatabase = copyFrom.routeDatabase;
-    dispatcher = copyFrom.dispatcher;
+  private OkHttpClient(OkHttpClient okHttpClient) {
+    this.routeDatabase = okHttpClient.routeDatabase;
+    this.dispatcher = okHttpClient.dispatcher;
+    this.proxy = okHttpClient.proxy;
+    this.protocols = okHttpClient.protocols;
+    this.connectionSpecs = okHttpClient.connectionSpecs;
+    this.interceptors.addAll(okHttpClient.interceptors);
+    this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
+    this.proxySelector = okHttpClient.proxySelector;
+    this.cookieHandler = okHttpClient.cookieHandler;
+    this.cache = okHttpClient.cache;
+    this.internalCache = cache != null ? cache.internalCache : okHttpClient.internalCache;
+    this.socketFactory = okHttpClient.socketFactory;
+    this.sslSocketFactory = okHttpClient.sslSocketFactory;
+    this.hostnameVerifier = okHttpClient.hostnameVerifier;
+    this.certificatePinner = okHttpClient.certificatePinner;
+    this.authenticator = okHttpClient.authenticator;
+    this.connectionPool = okHttpClient.connectionPool;
+    this.network = okHttpClient.network;
+    this.followSslRedirects = okHttpClient.followSslRedirects;
+    this.followRedirects = okHttpClient.followRedirects;
+    this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
+    this.connectTimeout = okHttpClient.connectTimeout;
+    this.readTimeout = okHttpClient.readTimeout;
+    this.writeTimeout = okHttpClient.writeTimeout;
   }
 
   /**
@@ -72,22 +211,16 @@ private OkHttpClient(OkHttpClient copyFrom) {
    *
    * @see URLConnection#setConnectTimeout(int)
    */
-  public void setConnectTimeout(long timeout, TimeUnit unit) {
-    if (timeout < 0) {
-      throw new IllegalArgumentException("timeout < 0");
-    }
-    if (unit == null) {
-      throw new IllegalArgumentException("unit == null");
-    }
+  public final void setConnectTimeout(long timeout, TimeUnit unit) {
+    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+    if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
-    if (millis > Integer.MAX_VALUE) {
-      throw new IllegalArgumentException("Timeout too large.");
-    }
+    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
     connectTimeout = (int) millis;
   }
 
   /** Default connect timeout (in milliseconds). */
-  public int getConnectTimeout() {
+  public final int getConnectTimeout() {
     return connectTimeout;
   }
 
@@ -96,37 +229,47 @@ public int getConnectTimeout() {
    *
    * @see URLConnection#setReadTimeout(int)
    */
-  public void setReadTimeout(long timeout, TimeUnit unit) {
-    if (timeout < 0) {
-      throw new IllegalArgumentException("timeout < 0");
-    }
-    if (unit == null) {
-      throw new IllegalArgumentException("unit == null");
-    }
+  public final void setReadTimeout(long timeout, TimeUnit unit) {
+    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+    if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
-    if (millis > Integer.MAX_VALUE) {
-      throw new IllegalArgumentException("Timeout too large.");
-    }
+    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
     readTimeout = (int) millis;
   }
 
   /** Default read timeout (in milliseconds). */
-  public int getReadTimeout() {
+  public final int getReadTimeout() {
     return readTimeout;
   }
 
+  /**
+   * Sets the default write timeout for new connections. A value of 0 means no timeout.
+   */
+  public final void setWriteTimeout(long timeout, TimeUnit unit) {
+    if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
+    if (unit == null) throw new IllegalArgumentException("unit == null");
+    long millis = unit.toMillis(timeout);
+    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
+    writeTimeout = (int) millis;
+  }
+
+  /** Default write timeout (in milliseconds). */
+  public final int getWriteTimeout() {
+    return writeTimeout;
+  }
+
   /**
    * Sets the HTTP proxy that will be used by connections created by this
    * client. This takes precedence over {@link #setProxySelector}, which is
    * only honored when this proxy is null (which it is by default). To disable
    * proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
    */
-  public OkHttpClient setProxy(Proxy proxy) {
+  public final OkHttpClient setProxy(Proxy proxy) {
     this.proxy = proxy;
     return this;
   }
 
-  public Proxy getProxy() {
+  public final Proxy getProxy() {
     return proxy;
   }
 
@@ -139,12 +282,12 @@ public Proxy getProxy() {
    * <p>If unset, the {@link ProxySelector#getDefault() system-wide default}
    * proxy selector will be used.
    */
-  public OkHttpClient setProxySelector(ProxySelector proxySelector) {
+  public final OkHttpClient setProxySelector(ProxySelector proxySelector) {
     this.proxySelector = proxySelector;
     return this;
   }
 
-  public ProxySelector getProxySelector() {
+  public final ProxySelector getProxySelector() {
     return proxySelector;
   }
 
@@ -155,52 +298,61 @@ public ProxySelector getProxySelector() {
    * <p>If unset, the {@link CookieHandler#getDefault() system-wide default}
    * cookie handler will be used.
    */
-  public OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
+  public final OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
     this.cookieHandler = cookieHandler;
     return this;
   }
 
-  public CookieHandler getCookieHandler() {
+  public final CookieHandler getCookieHandler() {
     return cookieHandler;
   }
 
+  /** Sets the response cache to be used to read and write cached responses. */
+  final void setInternalCache(InternalCache internalCache) {
+    this.internalCache = internalCache;
+    this.cache = null;
+  }
+
+  final InternalCache internalCache() {
+    return internalCache;
+  }
+
+  public final OkHttpClient setCache(Cache cache) {
+    this.cache = cache;
+    this.internalCache = null;
+    return this;
+  }
+
+  public final Cache getCache() {
+    return cache;
+  }
+
   /**
-   * Sets the response cache to be used to read and write cached responses.
+   * Sets the socket factory used to create connections.
    *
-   * <p>If unset, the {@link ResponseCache#getDefault() system-wide default}
-   * response cache will be used.
+   * <p>If unset, the {@link SocketFactory#getDefault() system-wide default}
+   * socket factory will be used.
    */
-  public OkHttpClient setResponseCache(ResponseCache responseCache) {
-    this.responseCache = responseCache;
+  public final OkHttpClient setSocketFactory(SocketFactory socketFactory) {
+    this.socketFactory = socketFactory;
     return this;
   }
 
-  public ResponseCache getResponseCache() {
-    return responseCache;
-  }
-
-  public OkResponseCache getOkResponseCache() {
-    if (responseCache instanceof HttpResponseCache) {
-      return ((HttpResponseCache) responseCache).okResponseCache;
-    } else if (responseCache != null) {
-      return new OkResponseCacheAdapter(responseCache);
-    } else {
-      return null;
-    }
+  public final SocketFactory getSocketFactory() {
+    return socketFactory;
   }
 
   /**
    * Sets the socket factory used to secure HTTPS connections.
    *
-   * <p>If unset, the {@link HttpsURLConnection#getDefaultSSLSocketFactory()
-   * system-wide default} SSL socket factory will be used.
+   * <p>If unset, a lazily created SSL socket factory will be used.
    */
-  public OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
+  public final OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
     this.sslSocketFactory = sslSocketFactory;
     return this;
   }
 
-  public SSLSocketFactory getSslSocketFactory() {
+  public final SSLSocketFactory getSslSocketFactory() {
     return sslSocketFactory;
   }
 
@@ -208,18 +360,32 @@ public SSLSocketFactory getSslSocketFactory() {
    * Sets the verifier used to confirm that response certificates apply to
    * requested hostnames for HTTPS connections.
    *
-   * <p>If unset, the {@link HttpsURLConnection#getDefaultHostnameVerifier()
-   * system-wide default} hostname verifier will be used.
+   * <p>If unset, a default hostname verifier will be used.
    */
-  public OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
+  public final OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
     this.hostnameVerifier = hostnameVerifier;
     return this;
   }
 
-  public HostnameVerifier getHostnameVerifier() {
+  public final HostnameVerifier getHostnameVerifier() {
     return hostnameVerifier;
   }
 
+  /**
+   * Sets the certificate pinner that constrains which certificates are trusted.
+   * By default HTTPS connections rely on only the {@link #setSslSocketFactory
+   * SSL socket factory} to establish trust. Pinning certificates avoids the
+   * need to trust certificate authorities.
+   */
+  public final OkHttpClient setCertificatePinner(CertificatePinner certificatePinner) {
+    this.certificatePinner = certificatePinner;
+    return this;
+  }
+
+  public final CertificatePinner getCertificatePinner() {
+    return certificatePinner;
+  }
+
   /**
    * Sets the authenticator used to respond to challenges from the remote web
    * server or proxy server.
@@ -227,12 +393,12 @@ public HostnameVerifier getHostnameVerifier() {
    * <p>If unset, the {@link java.net.Authenticator#setDefault system-wide default}
    * authenticator will be used.
    */
-  public OkHttpClient setAuthenticator(OkAuthenticator authenticator) {
+  public final OkHttpClient setAuthenticator(Authenticator authenticator) {
     this.authenticator = authenticator;
     return this;
   }
 
-  public OkAuthenticator getAuthenticator() {
+  public final Authenticator getAuthenticator() {
     return authenticator;
   }
 
@@ -242,12 +408,12 @@ public OkAuthenticator getAuthenticator() {
    * <p>If unset, the {@link ConnectionPool#getDefault() system-wide
    * default} connection pool will be used.
    */
-  public OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
+  public final OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
     this.connectionPool = connectionPool;
     return this;
   }
 
-  public ConnectionPool getConnectionPool() {
+  public final ConnectionPool getConnectionPool() {
     return connectionPool;
   }
 
@@ -258,151 +424,232 @@ public ConnectionPool getConnectionPool() {
    * <p>If unset, protocol redirects will be followed. This is different than
    * the built-in {@code HttpURLConnection}'s default.
    */
-  public OkHttpClient setFollowProtocolRedirects(boolean followProtocolRedirects) {
-    this.followProtocolRedirects = followProtocolRedirects;
+  public final OkHttpClient setFollowSslRedirects(boolean followProtocolRedirects) {
+    this.followSslRedirects = followProtocolRedirects;
     return this;
   }
 
-  public boolean getFollowProtocolRedirects() {
-    return followProtocolRedirects;
+  public final boolean getFollowSslRedirects() {
+    return followSslRedirects;
+  }
+
+  /** Configure this client to follow redirects. If unset, redirects be followed. */
+  public final void setFollowRedirects(boolean followRedirects) {
+    this.followRedirects = followRedirects;
+  }
+
+  public final boolean getFollowRedirects() {
+    return followRedirects;
   }
 
-  public RouteDatabase getRoutesDatabase() {
+  /**
+   * Configure this client to retry or not when a connectivity problem is encountered. By default,
+   * this client silently recovers from the following problems:
+   *
+   * <ul>
+   *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
+   *       failure to reach any individual IP address doesn't fail the overall request. This can
+   *       increase availability of multi-homed services.
+   *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
+   *       to decrease request latency, but these connections will occasionally time out.
+   *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
+   *       attempt multiple proxy servers in sequence, eventually falling back to a direct
+   *       connection.
+   * </ul>
+   *
+   * Set this to false to avoid retrying requests when doing so is destructive. In this case the
+   * calling application should do its own recovery of connectivity failures.
+   */
+  public final void setRetryOnConnectionFailure(boolean retryOnConnectionFailure) {
+    this.retryOnConnectionFailure = retryOnConnectionFailure;
+  }
+
+  public final boolean getRetryOnConnectionFailure() {
+    return retryOnConnectionFailure;
+  }
+
+  final RouteDatabase routeDatabase() {
     return routeDatabase;
   }
 
   /**
-   * Configure the transports used by this client to communicate with remote
+   * Sets the dispatcher used to set policy and execute asynchronous requests.
+   * Must not be null.
+   */
+  public final OkHttpClient setDispatcher(Dispatcher dispatcher) {
+    if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
+    this.dispatcher = dispatcher;
+    return this;
+  }
+
+  public final Dispatcher getDispatcher() {
+    return dispatcher;
+  }
+
+  /**
+   * Configure the protocols used by this client to communicate with remote
    * servers. By default this client will prefer the most efficient transport
-   * available, falling back to more ubiquitous transports. Applications should
+   * available, falling back to more ubiquitous protocols. Applications should
    * only call this method to avoid specific compatibility problems, such as web
    * servers that behave incorrectly when SPDY is enabled.
    *
-   * <p>The following transports are currently supported:
+   * <p>The following protocols are currently supported:
    * <ul>
    *   <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-   *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3">spdy/3</a>
+   *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
+   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-16">h2-16</a>
    * </ul>
    *
    * <p><strong>This is an evolving set.</strong> Future releases may drop
-   * support for transitional transports (like spdy/3), in favor of their
-   * successors (spdy/4 or http/2.0). The http/1.1 transport will never be
-   * dropped.
+   * support for transitional protocols (like h2-16), in favor of their
+   * successors (h2). The http/1.1 transport will never be dropped.
    *
    * <p>If multiple protocols are specified, <a
-   * href="https://technotes.googlecode.com/git/nextprotoneg.html">NPN</a> will
-   * be used to negotiate a transport. Future releases may use another mechanism
-   * (such as <a href="http://tools.ietf.org/html/draft-friedl-tls-applayerprotoneg-02">ALPN</a>)
-   * to negotiate a transport.
+   * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
+   * will be used to negotiate a transport.
    *
-   * @param transports the transports to use, in order of preference. The list
-   *     must contain "http/1.1". It must not contain null.
+   * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are
+   * initiated with {@code HTTP/1.1} only. If the server responds with {@code
+   * HTTP/1.0}, that will be exposed by {@link Response#protocol()}.
+   *
+   * @param protocols the protocols to use, in order of preference. The list
+   *     must contain {@link Protocol#HTTP_1_1}. It must not contain null or
+   *     {@link Protocol#HTTP_1_0}.
    */
-  public OkHttpClient setTransports(List<String> transports) {
-    transports = Util.immutableList(transports);
-    if (!transports.contains("http/1.1")) {
-      throw new IllegalArgumentException("transports doesn't contain http/1.1: " + transports);
+  public final OkHttpClient setProtocols(List<Protocol> protocols) {
+    protocols = Util.immutableList(protocols);
+    if (!protocols.contains(Protocol.HTTP_1_1)) {
+      throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
     }
-    if (transports.contains(null)) {
-      throw new IllegalArgumentException("transports must not contain null");
+    if (protocols.contains(Protocol.HTTP_1_0)) {
+      throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
     }
-    if (transports.contains("")) {
-      throw new IllegalArgumentException("transports contains an empty string");
+    if (protocols.contains(null)) {
+      throw new IllegalArgumentException("protocols must not contain null");
     }
-    this.transports = transports;
+    this.protocols = Util.immutableList(protocols);
+    return this;
+  }
+
+  public final List<Protocol> getProtocols() {
+    return protocols;
+  }
+
+  public final OkHttpClient setConnectionSpecs(List<ConnectionSpec> connectionSpecs) {
+    this.connectionSpecs = Util.immutableList(connectionSpecs);
     return this;
   }
 
-  public List<String> getTransports() {
-    return transports;
+  public final List<ConnectionSpec> getConnectionSpecs() {
+    return connectionSpecs;
   }
 
   /**
-   * Schedules {@code request} to be executed.
+   * Returns a modifiable list of interceptors that observe the full span of each call: from before
+   * the connection is established (if any) until after the response source is selected (either the
+   * origin server, cache, or both).
    */
-  /* OkHttp 2.0: public */ void enqueue(Request request, Response.Receiver responseReceiver) {
-    // Create the HttpURLConnection immediately so the enqueued job gets the current settings of
-    // this client. Otherwise changes to this client (socket factory, redirect policy, etc.) may
-    // incorrectly be reflected in the request when it is dispatched later.
-    dispatcher.enqueue(open(request.url()), request, responseReceiver);
+  public List<Interceptor> interceptors() {
+    return interceptors;
   }
 
   /**
-   * Cancels all scheduled tasks tagged with {@code tag}. Requests that are already
-   * in flight might not be canceled.
+   * Returns a modifiable list of interceptors that observe a single network request and response.
+   * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
+   * a network interceptor to short-circuit or repeat a network request.
    */
-  public void cancel(Object tag) {
-    dispatcher.cancel(tag);
+  public List<Interceptor> networkInterceptors() {
+    return networkInterceptors;
   }
 
-  public HttpURLConnection open(URL url) {
-    return open(url, proxy);
+  /**
+   * Prepares the {@code request} to be executed at some point in the future.
+   */
+  public Call newCall(Request request) {
+    return new Call(this, request);
   }
 
-  HttpURLConnection open(URL url, Proxy proxy) {
-    String protocol = url.getProtocol();
-    OkHttpClient copy = copyWithDefaults();
-    copy.proxy = proxy;
-
-    if (protocol.equals("http")) return new HttpURLConnectionImpl(url, copy);
-    if (protocol.equals("https")) return new HttpsURLConnectionImpl(url, copy);
-    throw new IllegalArgumentException("Unexpected protocol: " + protocol);
+  /**
+   * Cancels all scheduled or in-flight calls tagged with {@code tag}. Requests
+   * that are already complete cannot be canceled.
+   */
+  public OkHttpClient cancel(Object tag) {
+    getDispatcher().cancel(tag);
+    return this;
   }
 
   /**
-   * Returns a shallow copy of this OkHttpClient that uses the system-wide default for
-   * each field that hasn't been explicitly configured.
+   * Returns a shallow copy of this OkHttpClient that uses the system-wide
+   * default for each field that hasn't been explicitly configured.
    */
-  private OkHttpClient copyWithDefaults() {
+  final OkHttpClient copyWithDefaults() {
     OkHttpClient result = new OkHttpClient(this);
-    result.proxy = proxy;
-    result.proxySelector = proxySelector != null ? proxySelector : ProxySelector.getDefault();
-    result.cookieHandler = cookieHandler != null ? cookieHandler : CookieHandler.getDefault();
-    result.responseCache = responseCache != null ? responseCache : ResponseCache.getDefault();
-    result.sslSocketFactory = sslSocketFactory != null
-        ? sslSocketFactory
-        : HttpsURLConnection.getDefaultSSLSocketFactory();
-    result.hostnameVerifier = hostnameVerifier != null
-        ? hostnameVerifier
-        : OkHostnameVerifier.INSTANCE;
-    result.authenticator = authenticator != null
-        ? authenticator
-        : HttpAuthenticator.SYSTEM_DEFAULT;
-    result.connectionPool = connectionPool != null ? connectionPool : ConnectionPool.getDefault();
-    result.followProtocolRedirects = followProtocolRedirects;
-    result.transports = transports != null ? transports : DEFAULT_TRANSPORTS;
-    result.connectTimeout = connectTimeout;
-    result.readTimeout = readTimeout;
+    if (result.proxySelector == null) {
+      result.proxySelector = ProxySelector.getDefault();
+    }
+    if (result.cookieHandler == null) {
+      result.cookieHandler = CookieHandler.getDefault();
+    }
+    if (result.socketFactory == null) {
+      result.socketFactory = SocketFactory.getDefault();
+    }
+    if (result.sslSocketFactory == null) {
+      result.sslSocketFactory = getDefaultSSLSocketFactory();
+    }
+    if (result.hostnameVerifier == null) {
+      result.hostnameVerifier = OkHostnameVerifier.INSTANCE;
+    }
+    if (result.certificatePinner == null) {
+      result.certificatePinner = CertificatePinner.DEFAULT;
+    }
+    if (result.authenticator == null) {
+      result.authenticator = AuthenticatorAdapter.INSTANCE;
+    }
+    if (result.connectionPool == null) {
+      result.connectionPool = ConnectionPool.getDefault();
+    }
+    if (result.protocols == null) {
+      result.protocols = DEFAULT_PROTOCOLS;
+    }
+    if (result.connectionSpecs == null) {
+      result.connectionSpecs = DEFAULT_CONNECTION_SPECS;
+    }
+    if (result.network == null) {
+      result.network = Network.DEFAULT;
+    }
     return result;
   }
 
   /**
-   * Creates a URLStreamHandler as a {@link URL#setURLStreamHandlerFactory}.
-   *
-   * <p>This code configures OkHttp to handle all HTTP and HTTPS connections
-   * created with {@link URL#openConnection()}: <pre>   {@code
+   * Java and Android programs default to using a single global SSL context,
+   * accessible to HTTP clients as {@link SSLSocketFactory#getDefault()}. If we
+   * used the shared SSL context, when OkHttp enables ALPN for its SPDY-related
+   * stuff, it would also enable ALPN for other usages, which might crash them
+   * because ALPN is enabled when it isn't expected to be.
    *
-   *   OkHttpClient okHttpClient = new OkHttpClient();
-   *   URL.setURLStreamHandlerFactory(okHttpClient);
-   * }</pre>
+   * <p>This code avoids that by defaulting to an OkHttp-created SSL context.
+   * The drawback of this approach is that apps that customize the global SSL
+   * context will lose these customizations.
    */
-  public URLStreamHandler createURLStreamHandler(final String protocol) {
-    if (!protocol.equals("http") && !protocol.equals("https")) return null;
-
-    return new URLStreamHandler() {
-      @Override protected URLConnection openConnection(URL url) {
-        return open(url);
-      }
-
-      @Override protected URLConnection openConnection(URL url, Proxy proxy) {
-        return open(url, proxy);
+  private synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
+    if (defaultSslSocketFactory == null) {
+      try {
+        SSLContext sslContext = SSLContext.getInstance("TLS");
+        sslContext.init(null, null, null);
+        defaultSslSocketFactory = sslContext.getSocketFactory();
+      } catch (GeneralSecurityException e) {
+        throw new AssertionError(); // The system has no TLS. Just give up.
       }
+    }
+    return defaultSslSocketFactory;
+  }
 
-      @Override protected int getDefaultPort() {
-        if (protocol.equals("http")) return 80;
-        if (protocol.equals("https")) return 443;
-        throw new AssertionError();
-      }
-    };
+  /** Returns a shallow copy of this OkHttpClient. */
+  @Override public final OkHttpClient clone() {
+    try {
+      return (OkHttpClient) super.clone();
+    } catch (CloneNotSupportedException e) {
+      throw new AssertionError();
+    }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java b/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java
deleted file mode 100644
index ffe6f54b10..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-
-/**
- * An extended response cache API. Unlike {@link java.net.ResponseCache}, this
- * interface supports conditional caching and statistics.
- *
- * <h3>Warning: Experimental OkHttp 2.0 API</h3>
- * This class is in beta. APIs are subject to change!
- */
-public interface OkResponseCache {
-  CacheResponse get(URI uri, String requestMethod, Map<String, List<String>> requestHeaders)
-      throws IOException;
-
-  CacheRequest put(URI uri, URLConnection urlConnection) throws IOException;
-
-  /** Remove any cache entries for the supplied {@code uri} if the request method invalidates. */
-  void maybeRemove(String requestMethod, URI uri) throws IOException;
-
-  /**
-   * Handles a conditional request hit by updating the stored cache response
-   * with the headers from {@code httpConnection}. The cached response body is
-   * not updated. If the stored response has changed since {@code
-   * conditionalCacheHit} was returned, this does nothing.
-   */
-  void update(CacheResponse conditionalCacheHit, HttpURLConnection connection) throws IOException;
-
-  /** Track an conditional GET that was satisfied by this cache. */
-  void trackConditionalCacheHit();
-
-  /** Track an HTTP response being satisfied by {@code source}. */
-  void trackResponse(ResponseSource source);
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
new file mode 100644
index 0000000000..03093df041
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+
+/**
+ * Protocols that OkHttp implements for <a
+ * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a>
+ * selection.
+ *
+ * <h3>Protocol vs Scheme</h3>
+ * Despite its name, {@link java.net.URL#getProtocol()} returns the
+ * {@linkplain java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not
+ * the protocol (http/1.1, spdy/3.1, etc.). OkHttp uses the word <i>protocol</i>
+ * to identify how HTTP messages are framed.
+ */
+public enum Protocol {
+  /**
+   * An obsolete plaintext framing that does not use persistent sockets by
+   * default.
+   */
+  HTTP_1_0("http/1.0"),
+
+  /**
+   * A plaintext framing that includes persistent connections.
+   *
+   * <p>This version of OkHttp implements <a
+   * href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>, and tracks
+   * revisions to that spec.
+   */
+  HTTP_1_1("http/1.1"),
+
+  /**
+   * Chromium's binary-framed protocol that includes header compression,
+   * multiplexing multiple requests on the same socket, and server-push.
+   * HTTP/1.1 semantics are layered on SPDY/3.
+   *
+   * <p>This version of OkHttp implements SPDY 3 <a
+   * href="http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">draft
+   * 3.1</a>. Future releases of OkHttp may use this identifier for a newer draft
+   * of the SPDY spec.
+   */
+  SPDY_3("spdy/3.1"),
+
+  /**
+   * The IETF's binary-framed protocol that includes header compression,
+   * multiplexing multiple requests on the same socket, and server-push.
+   * HTTP/1.1 semantics are layered on HTTP/2.
+   *
+   * <p>This version of OkHttp implements HTTP/2 <a
+   * href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-16">draft 16</a>
+   * with HPACK <a
+   * href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10">draft
+   * 10</a>. Future releases of OkHttp may use this identifier for a newer draft
+   * of these specs.
+   *
+   * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support
+   * {@linkplain com.squareup.okhttp.CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256}
+   * , present in Java 8+ and Android 5+. Servers that enforce this may send an
+   * exception message including the string {@code INADEQUATE_SECURITY}.
+   */
+  HTTP_2("h2-16");
+
+  private final String protocol;
+
+  Protocol(String protocol) {
+    this.protocol = protocol;
+  }
+
+  /**
+   * Returns the protocol identified by {@code protocol}.
+   * @throws IOException if {@code protocol} is unknown.
+   */
+  public static Protocol get(String protocol) throws IOException {
+    // Unroll the loop over values() to save an allocation.
+    if (protocol.equals(HTTP_1_0.protocol)) return HTTP_1_0;
+    if (protocol.equals(HTTP_1_1.protocol)) return HTTP_1_1;
+    if (protocol.equals(HTTP_2.protocol)) return HTTP_2;
+    if (protocol.equals(SPDY_3.protocol)) return SPDY_3;
+    throw new IOException("Unexpected protocol: " + protocol);
+  }
+
+  /**
+   * Returns the string used to identify this protocol for ALPN, like
+   * "http/1.1", "spdy/3.1" or "h2-16".
+   */
+  @Override public String toString() {
+    return protocol;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index a4e83f4889..890a34ad55 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -15,53 +15,70 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.RawHeaders;
-import java.io.File;
-import java.io.FileInputStream;
+import com.squareup.okhttp.internal.http.HttpMethod;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
 import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
 import java.net.URL;
 import java.util.List;
-import java.util.Set;
 
 /**
  * An HTTP request. Instances of this class are immutable if their {@link #body}
  * is null or itself immutable.
- *
- * <h3>Warning: Experimental OkHttp 2.0 API</h3>
- * This class is in beta. APIs are subject to change!
  */
-/* OkHttp 2.0: public */ final class Request {
-  private final URL url;
+public final class Request {
+  private final String urlString;
   private final String method;
-  private final RawHeaders headers;
-  private final Body body;
+  private final Headers headers;
+  private final RequestBody body;
   private final Object tag;
 
+  private volatile URL url; // Lazily initialized.
+  private volatile URI uri; // Lazily initialized.
+  private volatile CacheControl cacheControl; // Lazily initialized.
+
   private Request(Builder builder) {
-    this.url = builder.url;
+    this.urlString = builder.urlString;
     this.method = builder.method;
-    this.headers = new RawHeaders(builder.headers);
+    this.headers = builder.headers.build();
     this.body = builder.body;
     this.tag = builder.tag != null ? builder.tag : this;
+    this.url = builder.url;
   }
 
   public URL url() {
-    return url;
+    try {
+      URL result = url;
+      return result != null ? result : (url = new URL(urlString));
+    } catch (MalformedURLException e) {
+      throw new RuntimeException("Malformed URL: " + urlString, e);
+    }
+  }
+
+  public URI uri() throws IOException {
+    try {
+      URI result = uri;
+      return result != null ? result : (uri = Platform.get().toUriLenient(url()));
+    } catch (URISyntaxException e) {
+      throw new IOException(e.getMessage());
+    }
   }
 
   public String urlString() {
-    return url.toString();
+    return urlString;
   }
 
   public String method() {
     return method;
   }
 
+  public Headers headers() {
+    return headers;
+  }
+
   public String header(String name) {
     return headers.get(name);
   }
@@ -70,23 +87,7 @@ public String header(String name) {
     return headers.values(name);
   }
 
-  public Set<String> headerNames() {
-    return headers.names();
-  }
-
-  public int headerCount() {
-    return headers.length();
-  }
-
-  public String headerName(int index) {
-    return headers.getFieldName(index);
-  }
-
-  public String headerValue(int index) {
-    return headers.getValue(index);
-  }
-
-  public Body body() {
+  public RequestBody body() {
     return body;
   }
 
@@ -94,119 +95,65 @@ public Object tag() {
     return tag;
   }
 
-  public abstract static class Body {
-    /**
-     * Returns the Content-Type header for this body, or null if the content
-     * type is unknown.
-     */
-    public MediaType contentType() {
-      return null;
-    }
-
-    /** Returns the number of bytes in this body, or -1 if that count is unknown. */
-    public long contentLength() {
-      return -1;
-    }
-
-    /** Writes the content of this request to {@code out}. */
-    public abstract void writeTo(OutputStream out) throws IOException;
-
-    /**
-     * Returns a new request body that transmits {@code content}. If {@code
-     * contentType} lacks a charset, this will use UTF-8.
-     */
-    public static Body create(MediaType contentType, String content) {
-      contentType = contentType.charset() != null
-          ? contentType
-          : MediaType.parse(contentType + "; charset=utf-8");
-      try {
-        byte[] bytes = content.getBytes(contentType.charset().name());
-        return create(contentType, bytes);
-      } catch (UnsupportedEncodingException e) {
-        throw new AssertionError();
-      }
-    }
-
-    /** Returns a new request body that transmits {@code content}. */
-    public static Body create(final MediaType contentType, final byte[] content) {
-      if (contentType == null) throw new NullPointerException("contentType == null");
-      if (content == null) throw new NullPointerException("content == null");
-
-      return new Body() {
-        @Override public MediaType contentType() {
-          return contentType;
-        }
+  public Builder newBuilder() {
+    return new Builder(this);
+  }
 
-        @Override public long contentLength() {
-          return content.length;
-        }
+  /**
+   * Returns the cache control directives for this response. This is never null,
+   * even if this response contains no {@code Cache-Control} header.
+   */
+  public CacheControl cacheControl() {
+    CacheControl result = cacheControl;
+    return result != null ? result : (cacheControl = CacheControl.parse(headers));
+  }
 
-        @Override public void writeTo(OutputStream out) throws IOException {
-          out.write(content);
-        }
-      };
-    }
+  public boolean isHttps() {
+    return url().getProtocol().equals("https");
+  }
 
-    /** Returns a new request body that transmits the content of {@code file}. */
-    public static Body create(final MediaType contentType, final File file) {
-      if (contentType == null) throw new NullPointerException("contentType == null");
-      if (file == null) throw new NullPointerException("content == null");
-
-      return new Body() {
-        @Override public MediaType contentType() {
-          return contentType;
-        }
-
-        @Override public long contentLength() {
-          return file.length();
-        }
-
-        @Override public void writeTo(OutputStream out) throws IOException {
-          long length = contentLength();
-          if (length == 0) return;
-
-          InputStream in = null;
-          try {
-            in = new FileInputStream(file);
-            byte[] buffer = new byte[(int) Math.min(8192, length)];
-            for (int c; (c = in.read(buffer)) != -1; ) {
-              out.write(buffer, 0, c);
-            }
-          } finally {
-            Util.closeQuietly(in);
-          }
-        }
-      };
-    }
+  @Override public String toString() {
+    return "Request{method="
+        + method
+        + ", url="
+        + urlString
+        + ", tag="
+        + (tag != this ? tag : null)
+        + '}';
   }
 
   public static class Builder {
+    private String urlString;
     private URL url;
-    private String method = "GET";
-    private final RawHeaders headers = new RawHeaders();
-    private Body body;
+    private String method;
+    private Headers.Builder headers;
+    private RequestBody body;
     private Object tag;
 
-    public Builder(String url) {
-      url(url);
+    public Builder() {
+      this.method = "GET";
+      this.headers = new Headers.Builder();
     }
 
-    public Builder(URL url) {
-      url(url);
+    private Builder(Request request) {
+      this.urlString = request.urlString;
+      this.url = request.url;
+      this.method = request.method;
+      this.body = request.body;
+      this.tag = request.tag;
+      this.headers = request.headers.newBuilder();
     }
 
     public Builder url(String url) {
-      try {
-        this.url = new URL(url);
-        return this;
-      } catch (MalformedURLException e) {
-        throw new IllegalArgumentException("Malformed URL: " + url);
-      }
+      if (url == null) throw new IllegalArgumentException("url == null");
+      urlString = url;
+      return this;
     }
 
     public Builder url(URL url) {
-      if (url == null) throw new IllegalStateException("url == null");
+      if (url == null) throw new IllegalArgumentException("url == null");
       this.url = url;
+      this.urlString = url.toString();
       return this;
     }
 
@@ -228,6 +175,28 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
+    public Builder removeHeader(String name) {
+      headers.removeAll(name);
+      return this;
+    }
+
+    /** Removes all headers on this builder and adds {@code headers}. */
+    public Builder headers(Headers headers) {
+      this.headers = headers.newBuilder();
+      return this;
+    }
+
+    /**
+     * Sets this request's {@code Cache-Control} header, replacing any cache
+     * control headers already present. If {@code cacheControl} doesn't define
+     * any directives, this clears this request's cache-control headers.
+     */
+    public Builder cacheControl(CacheControl cacheControl) {
+      String value = cacheControl.toString();
+      if (value.isEmpty()) return removeHeader("Cache-Control");
+      return header("Cache-Control", value);
+    }
+
     public Builder get() {
       return method("GET", null);
     }
@@ -236,18 +205,32 @@ public Builder head() {
       return method("HEAD", null);
     }
 
-    public Builder post(Body body) {
+    public Builder post(RequestBody body) {
       return method("POST", body);
     }
 
-    public Builder put(Body body) {
+    public Builder delete() {
+      return method("DELETE", null);
+    }
+
+    public Builder put(RequestBody body) {
       return method("PUT", body);
     }
 
-    public Builder method(String method, Body body) {
+    public Builder patch(RequestBody body) {
+      return method("PATCH", body);
+    }
+
+    public Builder method(String method, RequestBody body) {
       if (method == null || method.length() == 0) {
         throw new IllegalArgumentException("method == null || method.length() == 0");
       }
+      if (body != null && !HttpMethod.permitsRequestBody(method)) {
+        throw new IllegalArgumentException("method " + method + " must not have a request body.");
+      }
+      if (body == null && HttpMethod.permitsRequestBody(method)) {
+        body = RequestBody.create(null, Util.EMPTY_BYTE_ARRAY);
+      }
       this.method = method;
       this.body = body;
       return this;
@@ -264,6 +247,7 @@ public Builder tag(Object tag) {
     }
 
     public Request build() {
+      if (urlString == null) throw new IllegalStateException("url == null");
       return new Request(this);
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java b/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
new file mode 100644
index 0000000000..5d7483767e
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Source;
+
+public abstract class RequestBody {
+  /** Returns the Content-Type header for this body. */
+  public abstract MediaType contentType();
+
+  /**
+   * Returns the number of bytes that will be written to {@code out} in a call
+   * to {@link #writeTo}, or -1 if that count is unknown.
+   */
+  public long contentLength() throws IOException {
+    return -1;
+  }
+
+  /** Writes the content of this request to {@code out}. */
+  public abstract void writeTo(BufferedSink sink) throws IOException;
+
+  /**
+   * Returns a new request body that transmits {@code content}. If {@code
+   * contentType} is non-null and lacks a charset, this will use UTF-8.
+   */
+  public static RequestBody create(MediaType contentType, String content) {
+    Charset charset = Util.UTF_8;
+    if (contentType != null) {
+      charset = contentType.charset();
+      if (charset == null) {
+        charset = Util.UTF_8;
+        contentType = MediaType.parse(contentType + "; charset=utf-8");
+      }
+    }
+    byte[] bytes = content.getBytes(charset);
+    return create(contentType, bytes);
+  }
+
+  /** Returns a new request body that transmits {@code content}. */
+  public static RequestBody create(final MediaType contentType, final byte[] content) {
+    if (content == null) throw new NullPointerException("content == null");
+
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() {
+        return content.length;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.write(content);
+      }
+    };
+  }
+
+  /** Returns a new request body that transmits the content of {@code file}. */
+  public static RequestBody create(final MediaType contentType, final File file) {
+    if (file == null) throw new NullPointerException("content == null");
+
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() {
+        return file.length();
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        Source source = null;
+        try {
+          source = Okio.source(file);
+          sink.writeAll(source);
+        } finally {
+          Util.closeQuietly(source);
+        }
+      }
+    };
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index 4cef2cd5c8..bf52795341 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -15,59 +15,104 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.RawHeaders;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
+import com.squareup.okhttp.internal.http.OkHeaders;
+import java.util.Collections;
 import java.util.List;
-import java.util.Set;
+
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
+import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
+import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
 
 /**
  * An HTTP response. Instances of this class are not immutable: the response
  * body is a one-shot value that may be consumed only once. All other properties
  * are immutable.
- *
- * <h3>Warning: Experimental OkHttp 2.0 API</h3>
- * This class is in beta. APIs are subject to change!
  */
-/* OkHttp 2.0: public */ final class Response {
+public final class Response {
   private final Request request;
+  private final Protocol protocol;
   private final int code;
-  private final RawHeaders headers;
-  private final Body body;
-  private final Response redirectedBy;
+  private final String message;
+  private final Handshake handshake;
+  private final Headers headers;
+  private final ResponseBody body;
+  private Response networkResponse;
+  private Response cacheResponse;
+  private final Response priorResponse;
+
+  private volatile CacheControl cacheControl; // Lazily initialized.
 
   private Response(Builder builder) {
     this.request = builder.request;
+    this.protocol = builder.protocol;
     this.code = builder.code;
-    this.headers = new RawHeaders(builder.headers);
+    this.message = builder.message;
+    this.handshake = builder.handshake;
+    this.headers = builder.headers.build();
     this.body = builder.body;
-    this.redirectedBy = builder.redirectedBy;
+    this.networkResponse = builder.networkResponse;
+    this.cacheResponse = builder.cacheResponse;
+    this.priorResponse = builder.priorResponse;
   }
 
   /**
-   * The wire-level request that initiated this HTTP response. This is usually
-   * <strong>not</strong> the same request instance provided to the HTTP client:
+   * The wire-level request that initiated this HTTP response. This is not
+   * necessarily the same request issued by the application:
    * <ul>
    *     <li>It may be transformed by the HTTP client. For example, the client
-   *         may have added its own {@code Content-Encoding} header to enable
-   *         response compression.
-   *     <li>It may be the request generated in response to an HTTP redirect.
-   *         In this case the request URL may be different than the initial
-   *         request URL.
+   *         may copy headers like {@code Content-Length} from the request body.
+   *     <li>It may be the request generated in response to an HTTP redirect or
+   *         authentication challenge. In this case the request URL may be
+   *         different than the initial request URL.
    * </ul>
    */
   public Request request() {
     return request;
   }
 
+  /**
+   * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link
+   * Protocol#HTTP_1_0}.
+   */
+  public Protocol protocol() {
+    return protocol;
+  }
+
+  /** Returns the HTTP status code. */
   public int code() {
     return code;
   }
 
+  /**
+   * Returns true if the code is in [200..300), which means the request was
+   * successfully received, understood, and accepted.
+   */
+  public boolean isSuccessful() {
+    return code >= 200 && code < 300;
+  }
+
+  /** Returns the HTTP status message or null if it is unknown. */
+  public String message() {
+    return message;
+  }
+
+  /**
+   * Returns the TLS handshake of the connection that carried this response, or
+   * null if the response was received without TLS.
+   */
+  public Handshake handshake() {
+    return handshake;
+  }
+
+  public List<String> headers(String name) {
+    return headers.values(name);
+  }
+
   public String header(String name) {
     return header(name, null);
   }
@@ -77,107 +122,154 @@ public String header(String name, String defaultValue) {
     return result != null ? result : defaultValue;
   }
 
-  public List<String> headers(String name) {
-    return headers.values(name);
+  public Headers headers() {
+    return headers;
   }
 
-  public Set<String> headerNames() {
-    return headers.names();
+  public ResponseBody body() {
+    return body;
   }
 
-  public int headerCount() {
-    return headers.length();
+  public Builder newBuilder() {
+    return new Builder(this);
   }
 
-  public String headerName(int index) {
-    return headers.getFieldName(index);
+  /** Returns true if this response redirects to another resource. */
+  public boolean isRedirect() {
+    switch (code) {
+      case HTTP_PERM_REDIRECT:
+      case HTTP_TEMP_REDIRECT:
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+        return true;
+      default:
+        return false;
+    }
   }
 
-  public String headerValue(int index) {
-    return headers.getValue(index);
+  /**
+   * Returns the raw response received from the network. Will be null if this
+   * response didn't use the network, such as when the response is fully cached.
+   * The body of the returned response should not be read.
+   */
+  public Response networkResponse() {
+    return networkResponse;
   }
 
-  public Body body() {
-    return body;
+  /**
+   * Returns the raw response received from the cache. Will be null if this
+   * response didn't use the cache. For conditional get requests the cache
+   * response and network response may both be non-null. The body of the
+   * returned response should not be read.
+   */
+  public Response cacheResponse() {
+    return cacheResponse;
   }
 
   /**
-   * Returns the response for the HTTP redirect that triggered this response, or
-   * null if this response wasn't triggered by an automatic redirect. The body
-   * of the returned response should not be read because it has already been
-   * consumed by the redirecting client.
+   * Returns the response for the HTTP redirect or authorization challenge that
+   * triggered this response, or null if this response wasn't triggered by an
+   * automatic retry. The body of the returned response should not be read
+   * because it has already been consumed by the redirecting client.
    */
-  public Response redirectedBy() {
-    return redirectedBy;
+  public Response priorResponse() {
+    return priorResponse;
   }
 
-  public abstract static class Body {
-    public String contentType() {
-      return null;
+  /**
+   * Returns the authorization challenges appropriate for this response's code.
+   * If the response code is 401 unauthorized, this returns the
+   * "WWW-Authenticate" challenges. If the response code is 407 proxy
+   * unauthorized, this returns the "Proxy-Authenticate" challenges. Otherwise
+   * this returns an empty list of challenges.
+   */
+  public List<Challenge> challenges() {
+    String responseField;
+    if (code == HTTP_UNAUTHORIZED) {
+      responseField = "WWW-Authenticate";
+    } else if (code == HTTP_PROXY_AUTH) {
+      responseField = "Proxy-Authenticate";
+    } else {
+      return Collections.emptyList();
     }
+    return OkHeaders.parseChallenges(headers(), responseField);
+  }
 
-    public long contentLength() {
-      return -1;
-    }
+  /**
+   * Returns the cache control directives for this response. This is never null,
+   * even if this response contains no {@code Cache-Control} header.
+   */
+  public CacheControl cacheControl() {
+    CacheControl result = cacheControl;
+    return result != null ? result : (cacheControl = CacheControl.parse(headers));
+  }
 
-    public abstract InputStream byteStream() throws IOException;
+  @Override public String toString() {
+    return "Response{protocol="
+        + protocol
+        + ", code="
+        + code
+        + ", message="
+        + message
+        + ", url="
+        + request.urlString()
+        + '}';
+  }
 
-    public byte[] bytes() throws IOException {
-      long contentLength = contentLength();
-      if (contentLength > Integer.MAX_VALUE) {
-        throw new IOException("Cannot buffer entire body for content length: " + contentLength);
-      }
+  public static class Builder {
+    private Request request;
+    private Protocol protocol;
+    private int code = -1;
+    private String message;
+    private Handshake handshake;
+    private Headers.Builder headers;
+    private ResponseBody body;
+    private Response networkResponse;
+    private Response cacheResponse;
+    private Response priorResponse;
 
-      if (contentLength != -1) {
-        byte[] content = new byte[(int) contentLength];
-        InputStream in = byteStream();
-        Util.readFully(in, content);
-        if (in.read() != -1) throw new IOException("Content-Length and stream length disagree");
-        return content;
-
-      } else {
-        ByteArrayOutputStream out = new ByteArrayOutputStream();
-        Util.copy(byteStream(), out);
-        return out.toByteArray();
-      }
+    public Builder() {
+      headers = new Headers.Builder();
     }
 
-    /**
-     * Returns the response bytes as a UTF-8 character stream. Do not call this
-     * method if the response content is not a UTF-8 character stream.
-     */
-    public Reader charStream() throws IOException {
-      // TODO: parse content-type.
-      return new InputStreamReader(byteStream(), "UTF-8");
+    private Builder(Response response) {
+      this.request = response.request;
+      this.protocol = response.protocol;
+      this.code = response.code;
+      this.message = response.message;
+      this.handshake = response.handshake;
+      this.headers = response.headers.newBuilder();
+      this.body = response.body;
+      this.networkResponse = response.networkResponse;
+      this.cacheResponse = response.cacheResponse;
+      this.priorResponse = response.priorResponse;
     }
 
-    /**
-     * Returns the response bytes as a UTF-8 string. Do not call this method if
-     * the response content is not a UTF-8 character stream.
-     */
-    public String string() throws IOException {
-      // TODO: parse content-type.
-      return new String(bytes(), "UTF-8");
+    public Builder request(Request request) {
+      this.request = request;
+      return this;
     }
-  }
 
-  public interface Receiver {
-    void onFailure(Failure failure);
-    void onResponse(Response response) throws IOException;
-  }
+    public Builder protocol(Protocol protocol) {
+      this.protocol = protocol;
+      return this;
+    }
 
-  public static class Builder {
-    private final Request request;
-    private final int code;
-    private final RawHeaders headers = new RawHeaders();
-    private Body body;
-    private Response redirectedBy;
-
-    public Builder(Request request, int code) {
-      if (request == null) throw new IllegalArgumentException("request == null");
-      if (code <= 0) throw new IllegalArgumentException("code <= 0");
-      this.request = request;
+    public Builder code(int code) {
       this.code = code;
+      return this;
+    }
+
+    public Builder message(String message) {
+      this.message = message;
+      return this;
+    }
+
+    public Builder handshake(Handshake handshake) {
+      this.handshake = handshake;
+      return this;
     }
 
     /**
@@ -198,19 +290,62 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
-    public Builder body(Body body) {
+    public Builder removeHeader(String name) {
+      headers.removeAll(name);
+      return this;
+    }
+
+    /** Removes all headers on this builder and adds {@code headers}. */
+    public Builder headers(Headers headers) {
+      this.headers = headers.newBuilder();
+      return this;
+    }
+
+    public Builder body(ResponseBody body) {
       this.body = body;
       return this;
     }
 
-    public Builder redirectedBy(Response redirectedBy) {
-      this.redirectedBy = redirectedBy;
+    public Builder networkResponse(Response networkResponse) {
+      if (networkResponse != null) checkSupportResponse("networkResponse", networkResponse);
+      this.networkResponse = networkResponse;
+      return this;
+    }
+
+    public Builder cacheResponse(Response cacheResponse) {
+      if (cacheResponse != null) checkSupportResponse("cacheResponse", cacheResponse);
+      this.cacheResponse = cacheResponse;
       return this;
     }
 
+    private void checkSupportResponse(String name, Response response) {
+      if (response.body != null) {
+        throw new IllegalArgumentException(name + ".body != null");
+      } else if (response.networkResponse != null) {
+        throw new IllegalArgumentException(name + ".networkResponse != null");
+      } else if (response.cacheResponse != null) {
+        throw new IllegalArgumentException(name + ".cacheResponse != null");
+      } else if (response.priorResponse != null) {
+        throw new IllegalArgumentException(name + ".priorResponse != null");
+      }
+    }
+
+    public Builder priorResponse(Response priorResponse) {
+      if (priorResponse != null) checkPriorResponse(priorResponse);
+      this.priorResponse = priorResponse;
+      return this;
+    }
+
+    private void checkPriorResponse(Response response) {
+      if (response.body != null) {
+        throw new IllegalArgumentException("priorResponse.body != null");
+      }
+    }
+
     public Response build() {
-      if (request == null) throw new IllegalStateException("Response has no request.");
-      if (code == -1) throw new IllegalStateException("Response has no code.");
+      if (request == null) throw new IllegalStateException("request == null");
+      if (protocol == null) throw new IllegalStateException("protocol == null");
+      if (code < 0) throw new IllegalStateException("code < 0: " + code);
       return new Response(this);
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java b/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
new file mode 100644
index 0000000000..57e3087d13
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.nio.charset.Charset;
+import okio.Buffer;
+import okio.BufferedSource;
+
+import static com.squareup.okhttp.internal.Util.UTF_8;
+
+public abstract class ResponseBody implements Closeable {
+  /** Multiple calls to {@link #charStream()} must return the same instance. */
+  private Reader reader;
+
+  public abstract MediaType contentType();
+
+  /**
+   * Returns the number of bytes in that will returned by {@link #bytes}, or
+   * {@link #byteStream}, or -1 if unknown.
+   */
+  public abstract long contentLength();
+
+  public final InputStream byteStream() {
+    return source().inputStream();
+  }
+
+  public abstract BufferedSource source();
+
+  public final byte[] bytes() throws IOException {
+    long contentLength = contentLength();
+    if (contentLength > Integer.MAX_VALUE) {
+      throw new IOException("Cannot buffer entire body for content length: " + contentLength);
+    }
+
+    BufferedSource source = source();
+    byte[] bytes;
+    try {
+      bytes = source.readByteArray();
+    } finally {
+      Util.closeQuietly(source);
+    }
+    if (contentLength != -1 && contentLength != bytes.length) {
+      throw new IOException("Content-Length and stream length disagree");
+    }
+    return bytes;
+  }
+
+  /**
+   * Returns the response as a character stream decoded with the charset
+   * of the Content-Type header. If that header is either absent or lacks a
+   * charset, this will attempt to decode the response body as UTF-8.
+   */
+  public final Reader charStream() {
+    Reader r = reader;
+    return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
+  }
+
+  /**
+   * Returns the response as a string decoded with the charset of the
+   * Content-Type header. If that header is either absent or lacks a charset,
+   * this will attempt to decode the response body as UTF-8.
+   */
+  public final String string() throws IOException {
+    return new String(bytes(), charset().name());
+  }
+
+  private Charset charset() {
+    MediaType contentType = contentType();
+    return contentType != null ? contentType.charset(UTF_8) : UTF_8;
+  }
+
+  @Override public void close() throws IOException {
+    source().close();
+  }
+
+  /**
+   * Returns a new response body that transmits {@code content}. If {@code
+   * contentType} is non-null and lacks a charset, this will use UTF-8.
+   */
+  public static ResponseBody create(MediaType contentType, String content) {
+    Charset charset = Util.UTF_8;
+    if (contentType != null) {
+      charset = contentType.charset();
+      if (charset == null) {
+        charset = Util.UTF_8;
+        contentType = MediaType.parse(contentType + "; charset=utf-8");
+      }
+    }
+    Buffer buffer = new Buffer().writeString(content, charset);
+    return create(contentType, buffer.size(), buffer);
+  }
+
+  /** Returns a new response body that transmits {@code content}. */
+  public static ResponseBody create(final MediaType contentType, byte[] content) {
+    Buffer buffer = new Buffer().write(content);
+    return create(contentType, content.length, buffer);
+  }
+
+  /** Returns a new response body that transmits {@code content}. */
+  public static ResponseBody create(
+      final MediaType contentType, final long contentLength, final BufferedSource content) {
+    if (content == null) throw new NullPointerException("source == null");
+    return new ResponseBody() {
+      @Override public MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() {
+        return contentLength;
+      }
+
+      @Override public BufferedSource source() {
+        return content;
+      }
+    };
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Route.java b/okhttp/src/main/java/com/squareup/okhttp/Route.java
index 4b8786d229..f24431132f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Route.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Route.java
@@ -18,25 +18,55 @@
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 
-/** Represents the route used by a connection to reach an endpoint. */
-public class Route {
+/**
+ * The concrete route used by a connection to reach an abstract origin server.
+ * When creating a connection the client has many options:
+ * <ul>
+ *   <li><strong>HTTP proxy:</strong> a proxy server may be explicitly
+ *       configured for the client. Otherwise the {@linkplain java.net.ProxySelector
+ *       proxy selector} is used. It may return multiple proxies to attempt.
+ *   <li><strong>IP address:</strong> whether connecting directly to an origin
+ *       server or a proxy, opening a socket requires an IP address. The DNS
+ *       server may return multiple IP addresses to attempt.
+ *   <li><strong>TLS configuration:</strong> which cipher suites and TLS
+ *       versions to attempt with the HTTPS connection.
+ * </ul>
+ * Each route is a specific selection of these options.
+ */
+public final class Route {
   final Address address;
   final Proxy proxy;
   final InetSocketAddress inetSocketAddress;
-  final boolean modernTls;
+  final ConnectionSpec connectionSpec;
+  final boolean shouldSendTlsFallbackIndicator;
+
+  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
+      ConnectionSpec connectionSpec) {
+    this(address, proxy, inetSocketAddress, connectionSpec,
+        false /* shouldSendTlsFallbackIndicator */);
+  }
 
   public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress,
-      boolean modernTls) {
-    if (address == null) throw new NullPointerException("address == null");
-    if (proxy == null) throw new NullPointerException("proxy == null");
-    if (inetSocketAddress == null) throw new NullPointerException("inetSocketAddress == null");
+      ConnectionSpec connectionSpec, boolean shouldSendTlsFallbackIndicator) {
+    if (address == null) {
+      throw new NullPointerException("address == null");
+    }
+    if (proxy == null) {
+      throw new NullPointerException("proxy == null");
+    }
+    if (inetSocketAddress == null) {
+      throw new NullPointerException("inetSocketAddress == null");
+    }
+    if (connectionSpec == null) {
+      throw new NullPointerException("connectionConfiguration == null");
+    }
     this.address = address;
     this.proxy = proxy;
     this.inetSocketAddress = inetSocketAddress;
-    this.modernTls = modernTls;
+    this.connectionSpec = connectionSpec;
+    this.shouldSendTlsFallbackIndicator = shouldSendTlsFallbackIndicator;
   }
 
-  /** Returns the {@link Address} of this route. */
   public Address getAddress() {
     return address;
   }
@@ -44,38 +74,42 @@ public Address getAddress() {
   /**
    * Returns the {@link Proxy} of this route.
    *
-   * <strong>Warning:</strong> This may be different than the proxy returned
-   * by {@link #getAddress}! That is the proxy that the user asked to be
-   * connected to; this returns the proxy that they were actually connected
-   * to. The two may disagree when a proxy selector selects a different proxy
-   * for a connection.
+   * <strong>Warning:</strong> This may disagree with {@link Address#getProxy}
+   * when it is null. When the address's proxy is null, the proxy selector is
+   * used.
    */
   public Proxy getProxy() {
     return proxy;
   }
 
-  /** Returns the {@link InetSocketAddress} of this route. */
   public InetSocketAddress getSocketAddress() {
     return inetSocketAddress;
   }
 
-  /** Returns true if this route uses modern TLS. */
-  public boolean isModernTls() {
-    return modernTls;
+  public ConnectionSpec getConnectionSpec() {
+    return connectionSpec;
+  }
+
+  public boolean getShouldSendTlsFallbackIndicator() {
+    return shouldSendTlsFallbackIndicator;
   }
 
-  /** Returns a copy of this route with flipped TLS mode. */
-  Route flipTlsMode() {
-    return new Route(address, proxy, inetSocketAddress, !modernTls);
+  /**
+   * Returns true if this route tunnels HTTPS through an HTTP proxy. See <a
+   * href="http://www.ietf.org/rfc/rfc2817.txt">RFC 2817, Section 5.2</a>.
+   */
+  public boolean requiresTunnel() {
+    return address.sslSocketFactory != null && proxy.type() == Proxy.Type.HTTP;
   }
 
   @Override public boolean equals(Object obj) {
     if (obj instanceof Route) {
       Route other = (Route) obj;
-      return (address.equals(other.address)
+      return address.equals(other.address)
           && proxy.equals(other.proxy)
           && inetSocketAddress.equals(other.inetSocketAddress)
-          && modernTls == other.modernTls);
+          && connectionSpec.equals(other.connectionSpec)
+          && shouldSendTlsFallbackIndicator == other.shouldSendTlsFallbackIndicator;
     }
     return false;
   }
@@ -85,7 +119,8 @@ Route flipTlsMode() {
     result = 31 * result + address.hashCode();
     result = 31 * result + proxy.hashCode();
     result = 31 * result + inetSocketAddress.hashCode();
-    result = result + (modernTls ? (31 * result) : 0);
+    result = 31 * result + connectionSpec.hashCode();
+    result = 31 * result + (shouldSendTlsFallbackIndicator ? 1 : 0);
     return result;
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java b/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
new file mode 100644
index 0000000000..b33115ac3d
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/TlsVersion.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import javax.net.ssl.SSLSocket;
+
+/**
+ * Versions of TLS that can be offered when negotiating a secure socket. See
+ * {@link SSLSocket#setEnabledProtocols}.
+ */
+public enum TlsVersion {
+  TLS_1_2("TLSv1.2"), // 2008.
+  TLS_1_1("TLSv1.1"), // 2006.
+  TLS_1_0("TLSv1"),   // 1999.
+  SSL_3_0("SSLv3"),   // 1996.
+  ;
+
+  final String javaName;
+
+  private TlsVersion(String javaName) {
+    this.javaName = javaName;
+  }
+
+  static TlsVersion forJavaName(String javaName) {
+    switch (javaName) {
+      case "TLSv1.2": return TLS_1_2;
+      case "TLSv1.1": return TLS_1_1;
+      case "TLSv1": return TLS_1_0;
+      case "SSLv3": return SSL_3_0;
+    }
+    throw new IllegalArgumentException("Unexpected TLS version: " + javaName);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/TunnelRequest.java b/okhttp/src/main/java/com/squareup/okhttp/TunnelRequest.java
deleted file mode 100644
index 5260b87c49..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/TunnelRequest.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.http.RawHeaders;
-
-import static com.squareup.okhttp.internal.Util.getDefaultPort;
-
-/**
- * Routing and authentication information sent to an HTTP proxy to create a
- * HTTPS to an origin server. Everything in the tunnel request is sent
- * unencrypted to the proxy server.
- *
- * <p>See <a href="http://www.ietf.org/rfc/rfc2817.txt">RFC 2817, Section
- * 5.2</a>.
- */
-public final class TunnelRequest {
-  final String host;
-  final int port;
-  final String userAgent;
-  final String proxyAuthorization;
-
-  /**
-   * @param host the origin server's hostname. Not null.
-   * @param port the origin server's port, like 80 or 443.
-   * @param userAgent the client's user-agent. Not null.
-   * @param proxyAuthorization proxy authorization, or null if the proxy is
-   * used without an authorization header.
-   */
-  public TunnelRequest(String host, int port, String userAgent, String proxyAuthorization) {
-    if (host == null) throw new NullPointerException("host == null");
-    if (userAgent == null) throw new NullPointerException("userAgent == null");
-    this.host = host;
-    this.port = port;
-    this.userAgent = userAgent;
-    this.proxyAuthorization = proxyAuthorization;
-  }
-
-  /**
-   * If we're creating a TLS tunnel, send only the minimum set of headers.
-   * This avoids sending potentially sensitive data like HTTP cookies to
-   * the proxy unencrypted.
-   */
-  RawHeaders getRequestHeaders() {
-    RawHeaders result = new RawHeaders();
-    result.setRequestLine("CONNECT " + host + ":" + port + " HTTP/1.1");
-
-    // Always set Host and User-Agent.
-    result.set("Host", port == getDefaultPort("https") ? host : (host + ":" + port));
-    result.set("User-Agent", userAgent);
-
-    // Copy over the Proxy-Authorization header if it exists.
-    if (proxyAuthorization != null) {
-      result.set("Proxy-Authorization", proxyAuthorization);
-    }
-
-    // Always set the Proxy-Connection to Keep-Alive for the benefit of
-    // HTTP/1.0 proxies like Squid.
-    result.set("Proxy-Connection", "Keep-Alive");
-    return result;
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/AbstractOutputStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/AbstractOutputStream.java
deleted file mode 100644
index 78c9691e6f..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/AbstractOutputStream.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal;
-
-import java.io.IOException;
-import java.io.OutputStream;
-
-/**
- * An output stream for an HTTP request body.
- *
- * <p>Since a single socket's output stream may be used to write multiple HTTP
- * requests to the same server, subclasses should not close the socket stream.
- */
-public abstract class AbstractOutputStream extends OutputStream {
-  protected boolean closed;
-
-  @Override public final void write(int data) throws IOException {
-    write(new byte[] { (byte) data });
-  }
-
-  protected final void checkNotClosed() throws IOException {
-    if (closed) {
-      throw new IOException("stream closed");
-    }
-  }
-
-  /** Returns true if this stream was closed locally. */
-  public boolean isClosed() {
-    return closed;
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Base64.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Base64.java
deleted file mode 100644
index 79cd0206f5..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Base64.java
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-/**
- * @author Alexander Y. Kleymenov
- */
-
-package com.squareup.okhttp.internal;
-
-import java.io.UnsupportedEncodingException;
-
-import static com.squareup.okhttp.internal.Util.EMPTY_BYTE_ARRAY;
-
-/**
- * <a href="http://www.ietf.org/rfc/rfc2045.txt">Base64</a> encoder/decoder.
- * In violation of the RFC, this encoder doesn't wrap lines at 76 columns.
- */
-public final class Base64 {
-  private Base64() {
-  }
-
-  public static byte[] decode(byte[] in) {
-    return decode(in, in.length);
-  }
-
-  public static byte[] decode(byte[] in, int len) {
-    // approximate output length
-    int length = len / 4 * 3;
-    // return an empty array on empty or short input without padding
-    if (length == 0) {
-      return EMPTY_BYTE_ARRAY;
-    }
-    // temporary array
-    byte[] out = new byte[length];
-    // number of padding characters ('=')
-    int pad = 0;
-    byte chr;
-    // compute the number of the padding characters
-    // and adjust the length of the input
-    for (; ; len--) {
-      chr = in[len - 1];
-      // skip the neutral characters
-      if ((chr == '\n') || (chr == '\r') || (chr == ' ') || (chr == '\t')) {
-        continue;
-      }
-      if (chr == '=') {
-        pad++;
-      } else {
-        break;
-      }
-    }
-    // index in the output array
-    int outIndex = 0;
-    // index in the input array
-    int inIndex = 0;
-    // holds the value of the input character
-    int bits = 0;
-    // holds the value of the input quantum
-    int quantum = 0;
-    for (int i = 0; i < len; i++) {
-      chr = in[i];
-      // skip the neutral characters
-      if ((chr == '\n') || (chr == '\r') || (chr == ' ') || (chr == '\t')) {
-        continue;
-      }
-      if ((chr >= 'A') && (chr <= 'Z')) {
-        // char ASCII value
-        //  A    65    0
-        //  Z    90    25 (ASCII - 65)
-        bits = chr - 65;
-      } else if ((chr >= 'a') && (chr <= 'z')) {
-        // char ASCII value
-        //  a    97    26
-        //  z    122   51 (ASCII - 71)
-        bits = chr - 71;
-      } else if ((chr >= '0') && (chr <= '9')) {
-        // char ASCII value
-        //  0    48    52
-        //  9    57    61 (ASCII + 4)
-        bits = chr + 4;
-      } else if (chr == '+') {
-        bits = 62;
-      } else if (chr == '/') {
-        bits = 63;
-      } else {
-        return null;
-      }
-      // append the value to the quantum
-      quantum = (quantum << 6) | (byte) bits;
-      if (inIndex % 4 == 3) {
-        // 4 characters were read, so make the output:
-        out[outIndex++] = (byte) (quantum >> 16);
-        out[outIndex++] = (byte) (quantum >> 8);
-        out[outIndex++] = (byte) quantum;
-      }
-      inIndex++;
-    }
-    if (pad > 0) {
-      // adjust the quantum value according to the padding
-      quantum = quantum << (6 * pad);
-      // make output
-      out[outIndex++] = (byte) (quantum >> 16);
-      if (pad == 1) {
-        out[outIndex++] = (byte) (quantum >> 8);
-      }
-    }
-    // create the resulting array
-    byte[] result = new byte[outIndex];
-    System.arraycopy(out, 0, result, 0, outIndex);
-    return result;
-  }
-
-  private static final byte[] MAP = new byte[] {
-      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
-      'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',
-      'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4',
-      '5', '6', '7', '8', '9', '+', '/'
-  };
-
-  public static String encode(byte[] in) {
-    int length = (in.length + 2) * 4 / 3;
-    byte[] out = new byte[length];
-    int index = 0, end = in.length - in.length % 3;
-    for (int i = 0; i < end; i += 3) {
-      out[index++] = MAP[(in[i] & 0xff) >> 2];
-      out[index++] = MAP[((in[i] & 0x03) << 4) | ((in[i + 1] & 0xff) >> 4)];
-      out[index++] = MAP[((in[i + 1] & 0x0f) << 2) | ((in[i + 2] & 0xff) >> 6)];
-      out[index++] = MAP[(in[i + 2] & 0x3f)];
-    }
-    switch (in.length % 3) {
-      case 1:
-        out[index++] = MAP[(in[end] & 0xff) >> 2];
-        out[index++] = MAP[(in[end] & 0x03) << 4];
-        out[index++] = '=';
-        out[index++] = '=';
-        break;
-      case 2:
-        out[index++] = MAP[(in[end] & 0xff) >> 2];
-        out[index++] = MAP[((in[end] & 0x03) << 4) | ((in[end + 1] & 0xff) >> 4)];
-        out[index++] = MAP[((in[end + 1] & 0x0f) << 2)];
-        out[index++] = '=';
-        break;
-    }
-    try {
-      return new String(out, 0, index, "US-ASCII");
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError(e);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index f7fcb1ed2a..cab1664932 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -16,30 +16,30 @@
 
 package com.squareup.okhttp.internal;
 
-import java.io.BufferedWriter;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.FilterOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.concurrent.Callable;
+import java.util.NoSuchElementException;
+import java.util.concurrent.Executor;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ForwardingSink;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
 
 /**
  * A cache that uses a bounded amount of space on a filesystem. Each cache
@@ -92,7 +92,7 @@
   static final String MAGIC = "libcore.io.DiskLruCache";
   static final String VERSION_1 = "1";
   static final long ANY_SEQUENCE_NUMBER = -1;
-  static final Pattern LEGAL_KEY_PATTERN = Pattern.compile("[a-z0-9_-]{1,64}");
+  static final Pattern LEGAL_KEY_PATTERN = Pattern.compile("[a-z0-9_-]{1,120}");
   private static final String CLEAN = "CLEAN";
   private static final String DIRTY = "DIRTY";
   private static final String REMOVE = "REMOVE";
@@ -146,9 +146,8 @@
   private long maxSize;
   private final int valueCount;
   private long size = 0;
-  private Writer journalWriter;
-  private final LinkedHashMap<String, Entry> lruEntries =
-      new LinkedHashMap<String, Entry>(0, 0.75f, true);
+  private BufferedSink journalWriter;
+  private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
   private int redundantOpCount;
 
   /**
@@ -158,26 +157,28 @@
    */
   private long nextSequenceNumber = 0;
 
-  /** This cache uses a single background thread to evict entries. */
-  final ThreadPoolExecutor executorService =
-      new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
-  private final Callable<Void> cleanupCallable = new Callable<Void>() {
-    public Void call() throws Exception {
+  /** Used to run 'cleanupRunnable' for journal rebuilds. */
+  private final Executor executor;
+  private final Runnable cleanupRunnable = new Runnable() {
+    public void run() {
       synchronized (DiskLruCache.this) {
         if (journalWriter == null) {
-          return null; // Closed.
+          return; // Closed.
         }
-        trimToSize();
-        if (journalRebuildRequired()) {
-          rebuildJournal();
-          redundantOpCount = 0;
+        try {
+          trimToSize();
+          if (journalRebuildRequired()) {
+            rebuildJournal();
+            redundantOpCount = 0;
+          }
+        } catch (IOException e) {
+          throw new RuntimeException(e);
         }
       }
-      return null;
     }
   };
 
-  private DiskLruCache(File directory, int appVersion, int valueCount, long maxSize) {
+  DiskLruCache(File directory, int appVersion, int valueCount, long maxSize, Executor executor) {
     this.directory = directory;
     this.appVersion = appVersion;
     this.journalFile = new File(directory, JOURNAL_FILE);
@@ -185,6 +186,36 @@ private DiskLruCache(File directory, int appVersion, int valueCount, long maxSiz
     this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP);
     this.valueCount = valueCount;
     this.maxSize = maxSize;
+    this.executor = executor;
+  }
+
+  // Visible for testing.
+  void initialize() throws IOException {
+    // If a bkp file exists, use it instead.
+    if (journalFileBackup.exists()) {
+      // If journal file also exists just delete backup file.
+      if (journalFile.exists()) {
+        journalFileBackup.delete();
+      } else {
+        renameTo(journalFileBackup, journalFile, false);
+      }
+    }
+
+    // Prefer to pick up where we left off.
+    if (journalFile.exists()) {
+      try {
+        readJournal();
+        processJournal();
+        return;
+      } catch (IOException journalIsCorrupt) {
+        Platform.get().logW("DiskLruCache " + directory + " is corrupt: "
+            + journalIsCorrupt.getMessage() + ", removing");
+        delete();
+      }
+    }
+
+    directory.mkdirs();
+    rebuildJournal();
   }
 
   /**
@@ -205,49 +236,23 @@ public static DiskLruCache open(File directory, int appVersion, int valueCount,
       throw new IllegalArgumentException("valueCount <= 0");
     }
 
-    // If a bkp file exists, use it instead.
-    File backupFile = new File(directory, JOURNAL_FILE_BACKUP);
-    if (backupFile.exists()) {
-      File journalFile = new File(directory, JOURNAL_FILE);
-      // If journal file also exists just delete backup file.
-      if (journalFile.exists()) {
-        backupFile.delete();
-      } else {
-        renameTo(backupFile, journalFile, false);
-      }
-    }
+    // Use a single background thread to evict entries.
+    Executor executor = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
+        new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp DiskLruCache", true));
 
-    // Prefer to pick up where we left off.
-    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);
-    if (cache.journalFile.exists()) {
-      try {
-        cache.readJournal();
-        cache.processJournal();
-        cache.journalWriter = new BufferedWriter(
-            new OutputStreamWriter(new FileOutputStream(cache.journalFile, true), Util.US_ASCII));
-        return cache;
-      } catch (IOException journalIsCorrupt) {
-        Platform.get().logW("DiskLruCache " + directory + " is corrupt: "
-            + journalIsCorrupt.getMessage() + ", removing");
-        cache.delete();
-      }
-    }
-
-    // Create a new empty cache.
-    directory.mkdirs();
-    cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);
-    cache.rebuildJournal();
+    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize, executor);
+    cache.initialize();
     return cache;
   }
 
   private void readJournal() throws IOException {
-    StrictLineReader reader = new StrictLineReader(new FileInputStream(journalFile), Util.US_ASCII);
+    BufferedSource source = Okio.buffer(Okio.source(journalFile));
     try {
-      String magic = reader.readLine();
-      String version = reader.readLine();
-      String appVersionString = reader.readLine();
-      String valueCountString = reader.readLine();
-      String blank = reader.readLine();
+      String magic = source.readUtf8LineStrict();
+      String version = source.readUtf8LineStrict();
+      String appVersionString = source.readUtf8LineStrict();
+      String valueCountString = source.readUtf8LineStrict();
+      String blank = source.readUtf8LineStrict();
       if (!MAGIC.equals(magic)
           || !VERSION_1.equals(version)
           || !Integer.toString(appVersion).equals(appVersionString)
@@ -260,15 +265,22 @@ private void readJournal() throws IOException {
       int lineCount = 0;
       while (true) {
         try {
-          readJournalLine(reader.readLine());
+          readJournalLine(source.readUtf8LineStrict());
           lineCount++;
         } catch (EOFException endOfJournal) {
           break;
         }
       }
       redundantOpCount = lineCount - lruEntries.size();
+
+      // If we ended on a truncated line, rebuild the journal before appending to it.
+      if (!source.exhausted()) {
+        rebuildJournal();
+      } else {
+        journalWriter = Okio.buffer(Okio.appendingSink(journalFile));
+      }
     } finally {
-      Util.closeQuietly(reader);
+      Util.closeQuietly(source);
     }
   }
 
@@ -326,8 +338,8 @@ private void processJournal() throws IOException {
       } else {
         entry.currentEditor = null;
         for (int t = 0; t < valueCount; t++) {
-          deleteIfExists(entry.getCleanFile(t));
-          deleteIfExists(entry.getDirtyFile(t));
+          deleteIfExists(entry.cleanFiles[t]);
+          deleteIfExists(entry.dirtyFiles[t]);
         }
         i.remove();
       }
@@ -343,24 +355,24 @@ private synchronized void rebuildJournal() throws IOException {
       journalWriter.close();
     }
 
-    Writer writer = new BufferedWriter(
-        new OutputStreamWriter(new FileOutputStream(journalFileTmp), Util.US_ASCII));
+    BufferedSink writer = Okio.buffer(Okio.sink(journalFileTmp));
     try {
-      writer.write(MAGIC);
-      writer.write("\n");
-      writer.write(VERSION_1);
-      writer.write("\n");
-      writer.write(Integer.toString(appVersion));
-      writer.write("\n");
-      writer.write(Integer.toString(valueCount));
-      writer.write("\n");
-      writer.write("\n");
+      writer.writeUtf8(MAGIC).writeByte('\n');
+      writer.writeUtf8(VERSION_1).writeByte('\n');
+      writer.writeUtf8(Integer.toString(appVersion)).writeByte('\n');
+      writer.writeUtf8(Integer.toString(valueCount)).writeByte('\n');
+      writer.writeByte('\n');
 
       for (Entry entry : lruEntries.values()) {
         if (entry.currentEditor != null) {
-          writer.write(DIRTY + ' ' + entry.key + '\n');
+          writer.writeUtf8(DIRTY).writeByte(' ');
+          writer.writeUtf8(entry.key);
+          writer.writeByte('\n');
         } else {
-          writer.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
+          writer.writeUtf8(CLEAN).writeByte(' ');
+          writer.writeUtf8(entry.key);
+          entry.writeLengths(writer);
+          writer.writeByte('\n');
         }
       }
     } finally {
@@ -373,13 +385,13 @@ private synchronized void rebuildJournal() throws IOException {
     renameTo(journalFileTmp, journalFile, false);
     journalFileBackup.delete();
 
-    journalWriter = new BufferedWriter(
-        new OutputStreamWriter(new FileOutputStream(journalFile, true), Util.US_ASCII));
+    journalWriter = Okio.buffer(Okio.appendingSink(journalFile));
   }
 
   private static void deleteIfExists(File file) throws IOException {
-    if (file.exists() && !file.delete()) {
-      throw new IOException();
+    // If delete() fails, make sure it's because the file didn't exist!
+    if (!file.delete() && file.exists()) {
+      throw new IOException("failed to delete " + file);
     }
   }
 
@@ -401,41 +413,18 @@ public synchronized Snapshot get(String key) throws IOException {
     checkNotClosed();
     validateKey(key);
     Entry entry = lruEntries.get(key);
-    if (entry == null) {
-      return null;
-    }
-
-    if (!entry.readable) {
-      return null;
-    }
+    if (entry == null || !entry.readable) return null;
 
-    // Open all streams eagerly to guarantee that we see a single published
-    // snapshot. If we opened streams lazily then the streams could come
-    // from different edits.
-    InputStream[] ins = new InputStream[valueCount];
-    try {
-      for (int i = 0; i < valueCount; i++) {
-        ins[i] = new FileInputStream(entry.getCleanFile(i));
-      }
-    } catch (FileNotFoundException e) {
-      // A file must have been deleted manually!
-      for (int i = 0; i < valueCount; i++) {
-        if (ins[i] != null) {
-          Util.closeQuietly(ins[i]);
-        } else {
-          break;
-        }
-      }
-      return null;
-    }
+    Snapshot snapshot = entry.snapshot();
+    if (snapshot == null) return null;
 
     redundantOpCount++;
-    journalWriter.append(READ + ' ' + key + '\n');
+    journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\n');
     if (journalRebuildRequired()) {
-      executorService.submit(cleanupCallable);
+      executor.execute(cleanupRunnable);
     }
 
-    return new Snapshot(key, entry.sequenceNumber, ins, entry.lengths);
+    return snapshot;
   }
 
   /**
@@ -465,7 +454,7 @@ private synchronized Editor edit(String key, long expectedSequenceNumber) throws
     entry.currentEditor = editor;
 
     // Flush the journal before creating files to prevent file leaks.
-    journalWriter.write(DIRTY + ' ' + key + '\n');
+    journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
     journalWriter.flush();
     return editor;
   }
@@ -479,7 +468,7 @@ public File getDirectory() {
    * Returns the maximum number of bytes that this cache should use to store
    * its data.
    */
-  public long getMaxSize() {
+  public synchronized long getMaxSize() {
     return maxSize;
   }
 
@@ -489,7 +478,7 @@ public long getMaxSize() {
    */
   public synchronized void setMaxSize(long maxSize) {
     this.maxSize = maxSize;
-    executorService.submit(cleanupCallable);
+    executor.execute(cleanupRunnable);
   }
 
   /**
@@ -514,7 +503,7 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
           editor.abort();
           throw new IllegalStateException("Newly created entry didn't create value for index " + i);
         }
-        if (!entry.getDirtyFile(i).exists()) {
+        if (!entry.dirtyFiles[i].exists()) {
           editor.abort();
           return;
         }
@@ -522,10 +511,10 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
     }
 
     for (int i = 0; i < valueCount; i++) {
-      File dirty = entry.getDirtyFile(i);
+      File dirty = entry.dirtyFiles[i];
       if (success) {
         if (dirty.exists()) {
-          File clean = entry.getCleanFile(i);
+          File clean = entry.cleanFiles[i];
           dirty.renameTo(clean);
           long oldLength = entry.lengths[i];
           long newLength = clean.length();
@@ -541,18 +530,23 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
     entry.currentEditor = null;
     if (entry.readable | success) {
       entry.readable = true;
-      journalWriter.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
+      journalWriter.writeUtf8(CLEAN).writeByte(' ');
+      journalWriter.writeUtf8(entry.key);
+      entry.writeLengths(journalWriter);
+      journalWriter.writeByte('\n');
       if (success) {
         entry.sequenceNumber = nextSequenceNumber++;
       }
     } else {
       lruEntries.remove(entry.key);
-      journalWriter.write(REMOVE + ' ' + entry.key + '\n');
+      journalWriter.writeUtf8(REMOVE).writeByte(' ');
+      journalWriter.writeUtf8(entry.key);
+      journalWriter.writeByte('\n');
     }
     journalWriter.flush();
 
     if (size > maxSize || journalRebuildRequired()) {
-      executorService.submit(cleanupCallable);
+      executor.execute(cleanupRunnable);
     }
   }
 
@@ -562,13 +556,14 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
    */
   private boolean journalRebuildRequired() {
     final int redundantOpCompactThreshold = 2000;
-    return redundantOpCount >= redundantOpCompactThreshold //
+    return redundantOpCount >= redundantOpCompactThreshold
         && redundantOpCount >= lruEntries.size();
   }
 
   /**
-   * Drops the entry for {@code key} if it exists and can be removed. Entries
-   * actively being edited cannot be removed.
+   * Drops the entry for {@code key} if it exists and can be removed. If the
+   * entry for {@code key} is currently being edited, that edit will complete
+   * normally but its value will not be stored.
    *
    * @return true if an entry was removed.
    */
@@ -576,25 +571,28 @@ public synchronized boolean remove(String key) throws IOException {
     checkNotClosed();
     validateKey(key);
     Entry entry = lruEntries.get(key);
-    if (entry == null || entry.currentEditor != null) {
-      return false;
+    if (entry == null) return false;
+    return removeEntry(entry);
+  }
+
+  private boolean removeEntry(Entry entry) throws IOException {
+    if (entry.currentEditor != null) {
+      entry.currentEditor.hasErrors = true; // Prevent the edit from completing normally.
     }
 
     for (int i = 0; i < valueCount; i++) {
-      File file = entry.getCleanFile(i);
-      if (!file.delete()) {
-        throw new IOException("failed to delete " + file);
-      }
+      File file = entry.cleanFiles[i];
+      deleteIfExists(file);
       size -= entry.lengths[i];
       entry.lengths[i] = 0;
     }
 
     redundantOpCount++;
-    journalWriter.append(REMOVE + ' ' + key + '\n');
-    lruEntries.remove(key);
+    journalWriter.writeUtf8(REMOVE).writeByte(' ').writeUtf8(entry.key).writeByte('\n');
+    lruEntries.remove(entry.key);
 
     if (journalRebuildRequired()) {
-      executorService.submit(cleanupCallable);
+      executor.execute(cleanupRunnable);
     }
 
     return true;
@@ -623,7 +621,8 @@ public synchronized void close() throws IOException {
     if (journalWriter == null) {
       return; // Already closed.
     }
-    for (Entry entry : new ArrayList<Entry>(lruEntries.values())) {
+    // Copying for safe iteration.
+    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
       if (entry.currentEditor != null) {
         entry.currentEditor.abort();
       }
@@ -635,8 +634,8 @@ public synchronized void close() throws IOException {
 
   private void trimToSize() throws IOException {
     while (size > maxSize) {
-      Map.Entry<String, Entry> toEvict = lruEntries.entrySet().iterator().next();
-      remove(toEvict.getKey());
+      Entry toEvict = lruEntries.values().iterator().next();
+      removeEntry(toEvict);
     }
   }
 
@@ -650,31 +649,117 @@ public void delete() throws IOException {
     Util.deleteContents(directory);
   }
 
+  /**
+   * Deletes all stored values from the cache. In-flight edits will complete
+   * normally but their values will not be stored.
+   */
+  public synchronized void evictAll() throws IOException {
+    // Copying for safe iteration.
+    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
+      removeEntry(entry);
+    }
+  }
+
   private void validateKey(String key) {
     Matcher matcher = LEGAL_KEY_PATTERN.matcher(key);
     if (!matcher.matches()) {
-      throw new IllegalArgumentException("keys must match regex [a-z0-9_-]{1,64}: \"" + key + "\"");
+      throw new IllegalArgumentException(
+          "keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"");
+    }
+  }
+
+  private static String sourceToString(Source in) throws IOException {
+    try {
+      return Okio.buffer(in).readUtf8();
+    } finally {
+      Util.closeQuietly(in);
     }
   }
 
-  private static String inputStreamToString(InputStream in) throws IOException {
-    return Util.readFully(new InputStreamReader(in, Util.UTF_8));
+  /**
+   * Returns an iterator over the cache's current entries. This iterator doesn't throw {@code
+   * ConcurrentModificationException}, but if new entries are added while iterating, those new
+   * entries will not be returned by the iterator. If existing entries are removed during iteration,
+   * they will be absent (unless they were already returned).
+   *
+   * <p>If there are I/O problems during iteration, this iterator fails silently. For example, if
+   * the hosting filesystem becomes unreachable, the iterator will omit elements rather than
+   * throwing exceptions.
+   *
+   * <p><strong>The caller must {@link Snapshot#close close}</strong> each snapshot returned by
+   * {@link Iterator#next}. Failing to do so leaks open files!
+   *
+   * <p>The returned iterator supports {@link Iterator#remove}.
+   */
+  public synchronized Iterator<Snapshot> snapshots() {
+    return new Iterator<Snapshot>() {
+      /** Iterate a copy of the entries to defend against concurrent modification errors. */
+      final Iterator<Entry> delegate = new ArrayList<>(lruEntries.values()).iterator();
+
+      /** The snapshot to return from {@link #next}. Null if we haven't computed that yet. */
+      Snapshot nextSnapshot;
+
+      /** The snapshot to remove with {@link #remove}. Null if removal is illegal. */
+      Snapshot removeSnapshot;
+
+      @Override public boolean hasNext() {
+        if (nextSnapshot != null) return true;
+
+        synchronized (DiskLruCache.this) {
+          // If the cache is closed, truncate the iterator.
+          if (isClosed()) return false;
+
+          while (delegate.hasNext()) {
+            Entry entry = delegate.next();
+            Snapshot snapshot = entry.snapshot();
+            if (snapshot == null) continue; // Evicted since we copied the entries.
+            nextSnapshot = snapshot;
+            return true;
+          }
+        }
+
+        return false;
+      }
+
+      @Override public Snapshot next() {
+        if (!hasNext()) throw new NoSuchElementException();
+        removeSnapshot = nextSnapshot;
+        nextSnapshot = null;
+        return removeSnapshot;
+      }
+
+      @Override public void remove() {
+        if (removeSnapshot == null) throw new IllegalStateException("remove() before next()");
+        try {
+          DiskLruCache.this.remove(removeSnapshot.key);
+        } catch (IOException ignored) {
+          // Nothing useful to do here. We failed to remove from the cache. Most likely that's
+          // because we couldn't update the journal, but the cached entry will still be gone.
+        } finally {
+          removeSnapshot = null;
+        }
+      }
+    };
   }
 
   /** A snapshot of the values for an entry. */
   public final class Snapshot implements Closeable {
     private final String key;
     private final long sequenceNumber;
-    private final InputStream[] ins;
+    private final Source[] sources;
     private final long[] lengths;
 
-    private Snapshot(String key, long sequenceNumber, InputStream[] ins, long[] lengths) {
+    private Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
       this.key = key;
       this.sequenceNumber = sequenceNumber;
-      this.ins = ins;
+      this.sources = sources;
       this.lengths = lengths;
     }
 
+    public String key() {
+      return key;
+    }
+
     /**
      * Returns an editor for this snapshot's entry, or null if either the
      * entry has changed since this snapshot was created or if another edit
@@ -685,13 +770,13 @@ public Editor edit() throws IOException {
     }
 
     /** Returns the unbuffered stream with the value for {@code index}. */
-    public InputStream getInputStream(int index) {
-      return ins[index];
+    public Source getSource(int index) {
+      return sources[index];
     }
 
     /** Returns the string value for {@code index}. */
     public String getString(int index) throws IOException {
-      return inputStreamToString(getInputStream(index));
+      return sourceToString(getSource(index));
     }
 
     /** Returns the byte length of the value for {@code index}. */
@@ -700,17 +785,26 @@ public long getLength(int index) {
     }
 
     public void close() {
-      for (InputStream in : ins) {
+      for (Source in : sources) {
         Util.closeQuietly(in);
       }
     }
   }
 
-  private static final OutputStream NULL_OUTPUT_STREAM = new OutputStream() {
-    @Override
-    public void write(int b) throws IOException {
+  private static final Sink NULL_SINK = new Sink() {
+    @Override public void write(Buffer source, long byteCount) throws IOException {
       // Eat all writes silently. Nom nom.
     }
+
+    @Override public void flush() throws IOException {
+    }
+
+    @Override public Timeout timeout() {
+      return Timeout.NONE;
+    }
+
+    @Override public void close() throws IOException {
+    }
   };
 
   /** Edits the values for an entry. */
@@ -729,7 +823,7 @@ private Editor(Entry entry) {
      * Returns an unbuffered input stream to read the last committed value,
      * or null if no value has been committed.
      */
-    public InputStream newInputStream(int index) throws IOException {
+    public Source newSource(int index) throws IOException {
       synchronized (DiskLruCache.this) {
         if (entry.currentEditor != this) {
           throw new IllegalStateException();
@@ -738,7 +832,7 @@ public InputStream newInputStream(int index) throws IOException {
           return null;
         }
         try {
-          return new FileInputStream(entry.getCleanFile(index));
+          return Okio.source(entry.cleanFiles[index]);
         } catch (FileNotFoundException e) {
           return null;
         }
@@ -750,8 +844,8 @@ public InputStream newInputStream(int index) throws IOException {
      * has been committed.
      */
     public String getString(int index) throws IOException {
-      InputStream in = newInputStream(index);
-      return in != null ? inputStreamToString(in) : null;
+      Source source = newSource(index);
+      return source != null ? sourceToString(source) : null;
     }
 
     /**
@@ -761,7 +855,7 @@ public String getString(int index) throws IOException {
      * {@link #commit} is called. The returned output stream does not throw
      * IOExceptions.
      */
-    public OutputStream newOutputStream(int index) throws IOException {
+    public Sink newSink(int index) throws IOException {
       synchronized (DiskLruCache.this) {
         if (entry.currentEditor != this) {
           throw new IllegalStateException();
@@ -769,33 +863,29 @@ public OutputStream newOutputStream(int index) throws IOException {
         if (!entry.readable) {
           written[index] = true;
         }
-        File dirtyFile = entry.getDirtyFile(index);
-        FileOutputStream outputStream;
+        File dirtyFile = entry.dirtyFiles[index];
+        Sink sink;
         try {
-          outputStream = new FileOutputStream(dirtyFile);
+          sink = Okio.sink(dirtyFile);
         } catch (FileNotFoundException e) {
           // Attempt to recreate the cache directory.
           directory.mkdirs();
           try {
-            outputStream = new FileOutputStream(dirtyFile);
+            sink = Okio.sink(dirtyFile);
           } catch (FileNotFoundException e2) {
             // We are unable to recover. Silently eat the writes.
-            return NULL_OUTPUT_STREAM;
+            return NULL_SINK;
           }
         }
-        return new FaultHidingOutputStream(outputStream);
+        return new FaultHidingSink(sink);
       }
     }
 
     /** Sets the value at {@code index} to {@code value}. */
     public void set(int index, String value) throws IOException {
-      Writer writer = null;
-      try {
-        writer = new OutputStreamWriter(newOutputStream(index), Util.UTF_8);
-        writer.write(value);
-      } finally {
-        Util.closeQuietly(writer);
-      }
+      BufferedSink writer = Okio.buffer(newSink(index));
+      writer.writeUtf8(value);
+      writer.close();
     }
 
     /**
@@ -803,13 +893,15 @@ public void set(int index, String value) throws IOException {
      * edit lock so another edit may be started on the same key.
      */
     public void commit() throws IOException {
-      if (hasErrors) {
-        completeEdit(this, false);
-        remove(entry.key); // The previous entry is stale.
-      } else {
-        completeEdit(this, true);
+      synchronized (DiskLruCache.this) {
+        if (hasErrors) {
+          completeEdit(this, false);
+          removeEntry(entry); // The previous entry is stale.
+        } else {
+          completeEdit(this, true);
+        }
+        committed = true;
       }
-      committed = true;
     }
 
     /**
@@ -817,52 +909,54 @@ public void commit() throws IOException {
      * started on the same key.
      */
     public void abort() throws IOException {
-      completeEdit(this, false);
+      synchronized (DiskLruCache.this) {
+        completeEdit(this, false);
+      }
     }
 
     public void abortUnlessCommitted() {
-      if (!committed) {
-        try {
-          abort();
-        } catch (IOException ignored) {
+      synchronized (DiskLruCache.this) {
+        if (!committed) {
+          try {
+            completeEdit(this, false);
+          } catch (IOException ignored) {
+          }
         }
       }
     }
 
-    private class FaultHidingOutputStream extends FilterOutputStream {
-      private FaultHidingOutputStream(OutputStream out) {
-        super(out);
-      }
-
-      @Override public void write(int oneByte) {
-        try {
-          out.write(oneByte);
-        } catch (IOException e) {
-          hasErrors = true;
-        }
+    private class FaultHidingSink extends ForwardingSink {
+      public FaultHidingSink(Sink delegate) {
+        super(delegate);
       }
 
-      @Override public void write(byte[] buffer, int offset, int length) {
+      @Override public void write(Buffer source, long byteCount) throws IOException {
         try {
-          out.write(buffer, offset, length);
+          super.write(source, byteCount);
         } catch (IOException e) {
-          hasErrors = true;
+          synchronized (DiskLruCache.this) {
+            hasErrors = true;
+          }
         }
       }
 
-      @Override public void close() {
+      @Override public void flush() throws IOException {
         try {
-          out.close();
+          super.flush();
         } catch (IOException e) {
-          hasErrors = true;
+          synchronized (DiskLruCache.this) {
+            hasErrors = true;
+          }
         }
       }
 
-      @Override public void flush() {
+      @Override public void close() throws IOException {
         try {
-          out.flush();
+          super.close();
         } catch (IOException e) {
-          hasErrors = true;
+          synchronized (DiskLruCache.this) {
+            hasErrors = true;
+          }
         }
       }
     }
@@ -873,6 +967,8 @@ private FaultHidingOutputStream(OutputStream out) {
 
     /** Lengths of this entry's files. */
     private final long[] lengths;
+    private final File[] cleanFiles;
+    private final File[] dirtyFiles;
 
     /** True if this entry has ever been published. */
     private boolean readable;
@@ -885,15 +981,21 @@ private FaultHidingOutputStream(OutputStream out) {
 
     private Entry(String key) {
       this.key = key;
-      this.lengths = new long[valueCount];
-    }
 
-    public String getLengths() throws IOException {
-      StringBuilder result = new StringBuilder();
-      for (long size : lengths) {
-        result.append(' ').append(size);
+      lengths = new long[valueCount];
+      cleanFiles = new File[valueCount];
+      dirtyFiles = new File[valueCount];
+
+      // The names are repetitive so re-use the same builder to avoid allocations.
+      StringBuilder fileBuilder = new StringBuilder(key).append('.');
+      int truncateTo = fileBuilder.length();
+      for (int i = 0; i < valueCount; i++) {
+        fileBuilder.append(i);
+        cleanFiles[i] = new File(directory, fileBuilder.toString());
+        fileBuilder.append(".tmp");
+        dirtyFiles[i] = new File(directory, fileBuilder.toString());
+        fileBuilder.setLength(truncateTo);
       }
-      return result.toString();
     }
 
     /** Set lengths using decimal numbers like "10123". */
@@ -911,16 +1013,42 @@ private void setLengths(String[] strings) throws IOException {
       }
     }
 
-    private IOException invalidLengths(String[] strings) throws IOException {
-      throw new IOException("unexpected journal line: " + java.util.Arrays.toString(strings));
+    /** Append space-prefixed lengths to {@code writer}. */
+    void writeLengths(BufferedSink writer) throws IOException {
+      for (long length : lengths) {
+        writer.writeByte(' ').writeUtf8(Long.toString(length));
+      }
     }
 
-    public File getCleanFile(int i) {
-      return new File(directory, key + "." + i);
+    private IOException invalidLengths(String[] strings) throws IOException {
+      throw new IOException("unexpected journal line: " + Arrays.toString(strings));
     }
 
-    public File getDirtyFile(int i) {
-      return new File(directory, key + "." + i + ".tmp");
+    /**
+     * Returns a snapshot of this entry. This opens all streams eagerly to guarantee that we see a
+     * single published snapshot. If we opened streams lazily then the streams could come from
+     * different edits.
+     */
+    Snapshot snapshot() {
+      if (!Thread.holdsLock(DiskLruCache.this)) throw new AssertionError();
+
+      Source[] sources = new Source[valueCount];
+      try {
+        for (int i = 0; i < valueCount; i++) {
+          sources[i] = Okio.source(cleanFiles[i]);
+        }
+        return new Snapshot(key, sequenceNumber, sources, lengths);
+      } catch (FileNotFoundException e) {
+        // A file must have been deleted manually!
+        for (int i = 0; i < valueCount; i++) {
+          if (sources[i] != null) {
+            Util.closeQuietly(sources[i]);
+          } else {
+            break;
+          }
+        }
+        return null;
+      }
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/FaultRecoveringOutputStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/FaultRecoveringOutputStream.java
deleted file mode 100644
index c32b27aebb..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/FaultRecoveringOutputStream.java
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-
-import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
-
-/**
- * An output stream wrapper that recovers from failures in the underlying stream
- * by replacing it with another stream. This class buffers a fixed amount of
- * data under the assumption that failures occur early in a stream's life.
- * If a failure occurs after the buffer has been exhausted, no recovery is
- * attempted.
- *
- * <p>Subclasses must override {@link #replacementStream} which will request a
- * replacement stream each time an {@link IOException} is encountered on the
- * current stream.
- */
-public abstract class FaultRecoveringOutputStream extends AbstractOutputStream {
-  private final int maxReplayBufferLength;
-
-  /** Bytes to transmit on the replacement stream, or null if no recovery is possible. */
-  private ByteArrayOutputStream replayBuffer;
-  private OutputStream out;
-
-  /**
-   * @param maxReplayBufferLength the maximum number of successfully written
-   *     bytes to buffer so they can be replayed in the event of an error.
-   *     Failure recoveries are not possible once this limit has been exceeded.
-   */
-  public FaultRecoveringOutputStream(int maxReplayBufferLength, OutputStream out) {
-    if (maxReplayBufferLength < 0) throw new IllegalArgumentException();
-    this.maxReplayBufferLength = maxReplayBufferLength;
-    this.replayBuffer = new ByteArrayOutputStream(maxReplayBufferLength);
-    this.out = out;
-  }
-
-  @Override public final void write(byte[] buffer, int offset, int count) throws IOException {
-    if (closed) throw new IOException("stream closed");
-    checkOffsetAndCount(buffer.length, offset, count);
-
-    while (true) {
-      try {
-        out.write(buffer, offset, count);
-
-        if (replayBuffer != null) {
-          if (count + replayBuffer.size() > maxReplayBufferLength) {
-            // Failure recovery is no longer possible once we overflow the replay buffer.
-            replayBuffer = null;
-          } else {
-            // Remember the written bytes to the replay buffer.
-            replayBuffer.write(buffer, offset, count);
-          }
-        }
-        return;
-      } catch (IOException e) {
-        if (!recover(e)) throw e;
-      }
-    }
-  }
-
-  @Override public final void flush() throws IOException {
-    if (closed) {
-      return; // don't throw; this stream might have been closed on the caller's behalf
-    }
-    while (true) {
-      try {
-        out.flush();
-        return;
-      } catch (IOException e) {
-        if (!recover(e)) throw e;
-      }
-    }
-  }
-
-  @Override public final void close() throws IOException {
-    if (closed) {
-      return;
-    }
-    while (true) {
-      try {
-        out.close();
-        closed = true;
-        return;
-      } catch (IOException e) {
-        if (!recover(e)) throw e;
-      }
-    }
-  }
-
-  /**
-   * Attempt to replace {@code out} with another equivalent stream. Returns true
-   * if a suitable replacement stream was found.
-   */
-  private boolean recover(IOException e) {
-    if (replayBuffer == null) {
-      return false; // Can't recover because we've dropped data that we would need to replay.
-    }
-
-    while (true) {
-      OutputStream replacementStream = null;
-      try {
-        replacementStream = replacementStream(e);
-        if (replacementStream == null) {
-          return false;
-        }
-        replaceStream(replacementStream);
-        return true;
-      } catch (IOException replacementStreamFailure) {
-        // The replacement was also broken. Loop to ask for another replacement.
-        Util.closeQuietly(replacementStream);
-        e = replacementStreamFailure;
-      }
-    }
-  }
-
-  /**
-   * Returns true if errors in the underlying stream can currently be recovered.
-   */
-  public boolean isRecoverable() {
-    return replayBuffer != null;
-  }
-
-  /**
-   * Replaces the current output stream with {@code replacementStream}, writing
-   * any replay bytes to it if they exist. The current output stream is closed.
-   */
-  public final void replaceStream(OutputStream replacementStream) throws IOException {
-    if (!isRecoverable()) {
-      throw new IllegalStateException();
-    }
-    if (this.out == replacementStream) {
-      return; // Don't replace a stream with itself.
-    }
-    replayBuffer.writeTo(replacementStream);
-    Util.closeQuietly(out);
-    out = replacementStream;
-  }
-
-  /**
-   * Returns a replacement output stream to recover from {@code e} thrown by the
-   * previous stream. Returns a new OutputStream if recovery was successful, in
-   * which case all previously-written data will be replayed. Returns null if
-   * the failure cannot be recovered.
-   */
-  protected abstract OutputStream replacementStream(IOException e) throws IOException;
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
new file mode 100644
index 0000000000..130631aee3
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import com.squareup.okhttp.Call;
+import com.squareup.okhttp.Callback;
+import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.TlsVersion;
+import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.Transport;
+import java.io.IOException;
+import java.util.logging.Logger;
+
+/**
+ * Escalate internal APIs in {@code com.squareup.okhttp} so they can be used
+ * from OkHttp's implementation packages. The only implementation of this
+ * interface is in {@link com.squareup.okhttp.OkHttpClient}.
+ */
+public abstract class Internal {
+  public static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+  public static Internal instance;
+
+  public abstract Transport newTransport(Connection connection, HttpEngine httpEngine)
+      throws IOException;
+
+  public abstract boolean clearOwner(Connection connection);
+
+  public abstract void closeIfOwnedBy(Connection connection, Object owner) throws IOException;
+
+  public abstract int recycleCount(Connection connection);
+
+  public abstract void setProtocol(Connection connection, Protocol protocol);
+
+  public abstract void setOwner(Connection connection, HttpEngine httpEngine);
+
+  public abstract boolean isReadable(Connection pooled);
+
+  public abstract void addLenient(Headers.Builder builder, String line);
+
+  public abstract void setCache(OkHttpClient client, InternalCache internalCache);
+
+  public abstract InternalCache internalCache(OkHttpClient client);
+
+  public abstract void recycle(ConnectionPool pool, Connection connection);
+
+  public abstract RouteDatabase routeDatabase(OkHttpClient client);
+
+  public abstract Network network(OkHttpClient client);
+
+  public abstract void setNetwork(OkHttpClient client, Network network);
+
+  public abstract void connectAndSetOwner(OkHttpClient client, Connection connection,
+      HttpEngine owner, Request request) throws IOException;
+
+  public abstract TlsVersion tlsVersionForJavaName(String name);
+
+  // TODO delete the following when web sockets move into the main package.
+  public abstract void callEnqueue(Call call, Callback responseCallback, boolean forWebSocket);
+  public abstract void callEngineReleaseConnection(Call call) throws IOException;
+  public abstract Connection callEngineGetConnection(Call call);
+  public abstract void connectionSetOwner(Connection connection, Object owner);
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java
new file mode 100644
index 0000000000..4925358225
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.http.CacheRequest;
+import com.squareup.okhttp.internal.http.CacheStrategy;
+import java.io.IOException;
+
+/**
+ * OkHttp's internal cache interface. Applications shouldn't implement this:
+ * instead use {@link com.squareup.okhttp.Cache}.
+ */
+public interface InternalCache {
+  Response get(Request request) throws IOException;
+
+  CacheRequest put(Response response) throws IOException;
+
+  /**
+   * Remove any cache entries for the supplied {@code request}. This is invoked
+   * when the client invalidates the cache, such as when making POST requests.
+   */
+  void remove(Request request) throws IOException;
+
+  /**
+   * Handles a conditional request hit by updating the stored cache response
+   * with the headers from {@code network}. The cached response body is not
+   * updated. If the stored response has changed since {@code cached} was
+   * returned, this does nothing.
+   */
+  void update(Response cached, Response network) throws IOException;
+
+  /** Track an conditional GET that was satisfied by this cache. */
+  void trackConditionalCacheHit();
+
+  /** Track an HTTP response being satisfied with {@code cacheStrategy}. */
+  void trackResponse(CacheStrategy cacheStrategy);
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java b/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
similarity index 97%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
index 992b2ae419..7a02ecfbde 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
@@ -20,7 +20,7 @@
  * Runnable implementation which always sets its thread name.
  */
 public abstract class NamedRunnable implements Runnable {
-  private final String name;
+  protected final String name;
 
   public NamedRunnable(String format, Object... args) {
     this.name = String.format(format, args);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Network.java
similarity index 63%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/Network.java
index 69b2d37e94..a0070651b2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Network.java
@@ -19,15 +19,16 @@
 import java.net.UnknownHostException;
 
 /**
- * Domain name service. Prefer this over {@link InetAddress#getAllByName} to
- * make code more testable.
+ * Services specific to the host device's network interface. Prefer this over {@link
+ * InetAddress#getAllByName} to make code more testable.
  */
-public interface Dns {
-  Dns DEFAULT = new Dns() {
-    @Override public InetAddress[] getAllByName(String host) throws UnknownHostException {
+public interface Network {
+  Network DEFAULT = new Network() {
+    @Override public InetAddress[] resolveInetAddresses(String host) throws UnknownHostException {
+      if (host == null) throw new UnknownHostException("host == null");
       return InetAddress.getAllByName(host);
     }
   };
 
-  InetAddress[] getAllByName(String host) throws UnknownHostException;
+  InetAddress[] resolveInetAddresses(String host) throws UnknownHostException;
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/OptionalMethod.java b/okhttp/src/main/java/com/squareup/okhttp/internal/OptionalMethod.java
new file mode 100644
index 0000000000..21b31cc491
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/OptionalMethod.java
@@ -0,0 +1,176 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.squareup.okhttp.internal;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+
+/**
+ * Duck-typing for methods: Represents a method that may or may not be present on an object.
+ *
+ * @param <T> the type of the object the method might be on, typically an interface or base class
+ */
+class OptionalMethod<T> {
+
+  /** The return type of the method. null means "don't care". */
+  private final Class<?> returnType;
+
+  private final String methodName;
+
+  private final Class[] methodParams;
+
+  /**
+   * Creates an optional method.
+   *
+   * @param returnType the return type to required, null if it does not matter
+   * @param methodName the name of the method
+   * @param methodParams the method parameter types
+   */
+  public OptionalMethod(Class<?> returnType, String methodName, Class... methodParams) {
+    this.returnType = returnType;
+    this.methodName = methodName;
+    this.methodParams = methodParams;
+  }
+
+  /**
+   * Returns true if the method exists on the supplied {@code target}.
+   */
+  public boolean isSupported(T target) {
+    return getMethod(target.getClass()) != null;
+  }
+
+  /**
+   * Invokes the method on {@code target} with {@code args}. If the method does not exist or is not
+   * public then {@code null} is returned. See also
+   * {@link #invokeOptionalWithoutCheckedException(Object, Object...)}.
+   *
+   * @throws IllegalArgumentException if the arguments are invalid
+   * @throws InvocationTargetException if the invocation throws an exception
+   */
+  public Object invokeOptional(T target, Object... args) throws InvocationTargetException {
+    Method m = getMethod(target.getClass());
+    if (m == null) {
+      return null;
+    }
+    try {
+      return m.invoke(target, args);
+    } catch (IllegalAccessException e) {
+      return null;
+    }
+  }
+
+  /**
+   * Invokes the method on {@code target}.  If the method does not exist or is not
+   * public then {@code null} is returned. Any RuntimeException thrown by the method is thrown,
+   * checked exceptions are wrapped in an {@link AssertionError}.
+   *
+   * @throws IllegalArgumentException if the arguments are invalid
+   */
+  public Object invokeOptionalWithoutCheckedException(T target, Object... args) {
+    try {
+      return invokeOptional(target, args);
+    } catch (InvocationTargetException e) {
+      Throwable targetException = e.getTargetException();
+      if (targetException instanceof RuntimeException) {
+        throw (RuntimeException) targetException;
+      }
+      AssertionError error = new AssertionError("Unexpected exception");
+      error.initCause(targetException);
+      throw error;
+    }
+  }
+
+  /**
+   * Invokes the method on {@code target} with {@code args}. Throws an error if the method is not
+   * supported. See also {@link #invokeWithoutCheckedException(Object, Object...)}.
+   *
+   * @throws IllegalArgumentException if the arguments are invalid
+   * @throws InvocationTargetException if the invocation throws an exception
+   */
+  public Object invoke(T target, Object... args) throws InvocationTargetException {
+    Method m = getMethod(target.getClass());
+    if (m == null) {
+      throw new AssertionError("Method " + methodName + " not supported for object " + target);
+    }
+    try {
+      return m.invoke(target, args);
+    } catch (IllegalAccessException e) {
+      // Method should be public: we checked.
+      AssertionError error = new AssertionError("Unexpectedly could not call: " + m);
+      error.initCause(e);
+      throw error;
+    }
+  }
+
+  /**
+   * Invokes the method on {@code target}. Throws an error if the method is not supported. Any
+   * RuntimeException thrown by the method is thrown, checked exceptions are wrapped in
+   * an {@link AssertionError}.
+   *
+   * @throws IllegalArgumentException if the arguments are invalid
+   */
+  public Object invokeWithoutCheckedException(T target, Object... args) {
+    try {
+      return invoke(target, args);
+    } catch (InvocationTargetException e) {
+      Throwable targetException = e.getTargetException();
+      if (targetException instanceof RuntimeException) {
+        throw (RuntimeException) targetException;
+      }
+      AssertionError error = new AssertionError("Unexpected exception");
+      error.initCause(targetException);
+      throw error;
+    }
+  }
+
+  /**
+   * Perform a lookup for the method. No caching.
+   * In order to return a method the method name and arguments must match those specified when
+   * the {@link OptionalMethod} was created. If the return type is specified (i.e. non-null) it
+   * must also be compatible. The method must also be public.
+   */
+  private Method getMethod(Class<?> clazz) {
+    Method method = null;
+    if (methodName != null) {
+      method = getPublicMethod(clazz, methodName, methodParams);
+      if (method != null
+          && returnType != null
+          && !returnType.isAssignableFrom(method.getReturnType())) {
+
+        // If the return type is non-null it must be compatible.
+        method = null;
+      }
+    }
+    return method;
+  }
+
+  private static Method getPublicMethod(Class<?> clazz, String methodName, Class[] parameterTypes) {
+    Method method = null;
+    try {
+      method = clazz.getMethod(methodName, parameterTypes);
+      if ((method.getModifiers() & Modifier.PUBLIC) == 0) {
+        method = null;
+      }
+    } catch (NoSuchMethodException e) {
+      // None.
+    }
+    return method;
+  }
+}
+
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
new file mode 100644
index 0000000000..14b5fb1623
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -0,0 +1,375 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import com.squareup.okhttp.Protocol;
+import java.io.IOException;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.net.SocketException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.logging.Level;
+import javax.net.ssl.SSLSocket;
+import okio.Buffer;
+
+import static com.squareup.okhttp.internal.Internal.logger;
+
+/**
+ * Access to Platform-specific features necessary for SPDY and advanced TLS.
+ * This includes Server Name Indication (SNI) and session tickets.
+ *
+ * <h3>ALPN</h3>
+ * This class uses TLS extension ALPN to negotiate the upgrade from HTTP/1.1
+ * (the default protocol to use with TLS on port 443) to either SPDY or HTTP/2.
+ *
+ * <p>ALPN (Application Layer Protocol Negotiation) first arrived in Android 4.4,
+ * ALPN is supported on OpenJDK 7 and 8 (via the Jetty ALPN-boot library).
+ */
+public class Platform {
+  private static final Platform PLATFORM = findPlatform();
+
+  public static Platform get() {
+    return PLATFORM;
+  }
+
+  /** Prefix used on custom headers. */
+  public String getPrefix() {
+    return "OkHttp";
+  }
+
+  public void logW(String warning) {
+    System.out.println(warning);
+  }
+
+  public void tagSocket(Socket socket) throws SocketException {
+  }
+
+  public void untagSocket(Socket socket) throws SocketException {
+  }
+
+  public URI toUriLenient(URL url) throws URISyntaxException {
+    return url.toURI(); // this isn't as good as the built-in toUriLenient
+  }
+
+  /**
+   * Configure TLS extensions on {@code sslSocket} for {@code route}.
+   *
+   * @param hostname non-null for client-side handshakes; null for
+   *     server-side handshakes.
+   */
+  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
+      List<Protocol> protocols) {
+  }
+
+  /**
+   * Called after the TLS handshake to release resources allocated by {@link
+   * #configureTlsExtensions}.
+   */
+  public void afterHandshake(SSLSocket sslSocket) {
+  }
+
+  /** Returns the negotiated protocol, or null if no protocol was negotiated. */
+  public String getSelectedProtocol(SSLSocket socket) {
+    return null;
+  }
+
+  public void connectSocket(Socket socket, InetSocketAddress address,
+      int connectTimeout) throws IOException {
+    socket.connect(address, connectTimeout);
+  }
+
+  /** Attempt to match the host runtime to a capable Platform implementation. */
+  private static Platform findPlatform() {
+    // Attempt to find Android 2.3+ APIs.
+    try {
+      try {
+        Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl");
+      } catch (ClassNotFoundException ignored) {
+        // Older platform before being unbundled.
+        Class.forName("org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl");
+      }
+
+      // Attempt to find Android 4.0+ APIs.
+      Method trafficStatsTagSocket = null;
+      Method trafficStatsUntagSocket = null;
+      try {
+        Class<?> trafficStats = Class.forName("android.net.TrafficStats");
+        trafficStatsTagSocket = trafficStats.getMethod("tagSocket", Socket.class);
+        trafficStatsUntagSocket = trafficStats.getMethod("untagSocket", Socket.class);
+      } catch (ClassNotFoundException ignored) {
+      } catch (NoSuchMethodException ignored) {
+      }
+
+      return new Android(trafficStatsTagSocket, trafficStatsUntagSocket);
+    } catch (ClassNotFoundException ignored) {
+      // This isn't an Android runtime.
+    }
+
+    try { // to find the Jetty's ALPN extension for OpenJDK.
+      String negoClassName = "org.eclipse.jetty.alpn.ALPN";
+      Class<?> negoClass = Class.forName(negoClassName);
+      Class<?> providerClass = Class.forName(negoClassName + "$Provider");
+      Class<?> clientProviderClass = Class.forName(negoClassName + "$ClientProvider");
+      Class<?> serverProviderClass = Class.forName(negoClassName + "$ServerProvider");
+      Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
+      Method getMethod = negoClass.getMethod("get", SSLSocket.class);
+      Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
+      return new JdkWithJettyBootPlatform(
+          putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
+    } catch (ClassNotFoundException ignored) {
+    } catch (NoSuchMethodException ignored) { // The ALPN version isn't what we expect.
+    }
+
+    return new Platform();
+  }
+
+  /**
+   * Android 2.3 or better. Version 2.3 supports TLS session tickets and server
+   * name indication (SNI). Versions 4.4 supports ALPN.
+   */
+  private static class Android extends Platform {
+
+    // setUseSessionTickets(boolean)
+    private static final OptionalMethod<Socket> SET_USE_SESSION_TICKETS =
+        new OptionalMethod<Socket>(null, "setUseSessionTickets", Boolean.TYPE);
+    // setHostname(String)
+    private static final OptionalMethod<Socket> SET_HOSTNAME =
+        new OptionalMethod<Socket>(null, "setHostname", String.class);
+    // byte[] getAlpnSelectedProtocol()
+    private static final OptionalMethod<Socket> GET_ALPN_SELECTED_PROTOCOL =
+        new OptionalMethod<Socket>(byte[].class, "getAlpnSelectedProtocol");
+    // setAlpnSelectedProtocol(byte[])
+    private static final OptionalMethod<Socket> SET_ALPN_PROTOCOLS =
+        new OptionalMethod<Socket>(null, "setAlpnProtocols", byte[].class);
+
+    // Non-null on Android 4.0+.
+    private final Method trafficStatsTagSocket;
+    private final Method trafficStatsUntagSocket;
+
+    private Android(Method trafficStatsTagSocket, Method trafficStatsUntagSocket) {
+      this.trafficStatsTagSocket = trafficStatsTagSocket;
+      this.trafficStatsUntagSocket = trafficStatsUntagSocket;
+    }
+
+    @Override public void connectSocket(Socket socket, InetSocketAddress address,
+        int connectTimeout) throws IOException {
+      try {
+        socket.connect(address, connectTimeout);
+      } catch (SecurityException se) {
+        // Before android 4.3, socket.connect could throw a SecurityException
+        // if opening a socket resulted in an EACCES error.
+        IOException ioException = new IOException("Exception in connect");
+        ioException.initCause(se);
+        throw ioException;
+      }
+    }
+
+    @Override public void configureTlsExtensions(
+        SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+      // Enable SNI and session tickets.
+      if (hostname != null) {
+        SET_USE_SESSION_TICKETS.invokeOptionalWithoutCheckedException(sslSocket, true);
+        SET_HOSTNAME.invokeOptionalWithoutCheckedException(sslSocket, hostname);
+      }
+
+      // Enable ALPN.
+      boolean alpnSupported = SET_ALPN_PROTOCOLS.isSupported(sslSocket);
+      if (!alpnSupported) {
+        return;
+      }
+
+      Object[] parameters = { concatLengthPrefixed(protocols) };
+      SET_ALPN_PROTOCOLS.invokeWithoutCheckedException(sslSocket, parameters);
+    }
+
+    @Override public String getSelectedProtocol(SSLSocket socket) {
+      boolean alpnSupported = GET_ALPN_SELECTED_PROTOCOL.isSupported(socket);
+      if (!alpnSupported) {
+        return null;
+      }
+
+      byte[] alpnResult =
+          (byte[]) GET_ALPN_SELECTED_PROTOCOL.invokeWithoutCheckedException(socket);
+      if (alpnResult != null) {
+        return new String(alpnResult, Util.UTF_8);
+      }
+      return null;
+    }
+
+    @Override public void tagSocket(Socket socket) throws SocketException {
+      if (trafficStatsTagSocket == null) return;
+
+      try {
+        trafficStatsTagSocket.invoke(null, socket);
+      } catch (IllegalAccessException e) {
+        throw new RuntimeException(e);
+      } catch (InvocationTargetException e) {
+        throw new RuntimeException(e.getCause());
+      }
+    }
+
+    @Override public void untagSocket(Socket socket) throws SocketException {
+      if (trafficStatsUntagSocket == null) return;
+
+      try {
+        trafficStatsUntagSocket.invoke(null, socket);
+      } catch (IllegalAccessException e) {
+        throw new RuntimeException(e);
+      } catch (InvocationTargetException e) {
+        throw new RuntimeException(e.getCause());
+      }
+    }
+  }
+
+  /**
+   * OpenJDK 7+ with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
+   */
+  private static class JdkWithJettyBootPlatform extends Platform {
+    private final Method putMethod;
+    private final Method getMethod;
+    private final Method removeMethod;
+    private final Class<?> clientProviderClass;
+    private final Class<?> serverProviderClass;
+
+    public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
+        Class<?> clientProviderClass, Class<?> serverProviderClass) {
+      this.putMethod = putMethod;
+      this.getMethod = getMethod;
+      this.removeMethod = removeMethod;
+      this.clientProviderClass = clientProviderClass;
+      this.serverProviderClass = serverProviderClass;
+    }
+
+    @Override public void configureTlsExtensions(
+        SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+      List<String> names = new ArrayList<>(protocols.size());
+      for (int i = 0, size = protocols.size(); i < size; i++) {
+        Protocol protocol = protocols.get(i);
+        if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
+        names.add(protocol.toString());
+      }
+      try {
+        Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
+            new Class[] { clientProviderClass, serverProviderClass }, new JettyNegoProvider(names));
+        putMethod.invoke(null, sslSocket, provider);
+      } catch (InvocationTargetException e) {
+        throw new AssertionError(e);
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
+      }
+    }
+
+    @Override public void afterHandshake(SSLSocket sslSocket) {
+      try {
+        removeMethod.invoke(null, sslSocket);
+      } catch (IllegalAccessException ignored) {
+        throw new AssertionError();
+      } catch (InvocationTargetException ignored) {
+        throw new AssertionError();
+      }
+    }
+
+    @Override public String getSelectedProtocol(SSLSocket socket) {
+      try {
+        JettyNegoProvider provider =
+            (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
+        if (!provider.unsupported && provider.selected == null) {
+          logger.log(Level.INFO, "ALPN callback dropped: SPDY and HTTP/2 are disabled. "
+              + "Is alpn-boot on the boot class path?");
+          return null;
+        }
+        return provider.unsupported ? null : provider.selected;
+      } catch (InvocationTargetException e) {
+        throw new AssertionError();
+      } catch (IllegalAccessException e) {
+        throw new AssertionError();
+      }
+    }
+  }
+
+  /**
+   * Handle the methods of ALPN's ClientProvider and ServerProvider
+   * without a compile-time dependency on those interfaces.
+   */
+  private static class JettyNegoProvider implements InvocationHandler {
+    /** This peer's supported protocols. */
+    private final List<String> protocols;
+    /** Set when remote peer notifies ALPN is unsupported. */
+    private boolean unsupported;
+    /** The protocol the server selected. */
+    private String selected;
+
+    public JettyNegoProvider(List<String> protocols) {
+      this.protocols = protocols;
+    }
+
+    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+      String methodName = method.getName();
+      Class<?> returnType = method.getReturnType();
+      if (args == null) {
+        args = Util.EMPTY_STRING_ARRAY;
+      }
+      if (methodName.equals("supports") && boolean.class == returnType) {
+        return true; // ALPN is supported.
+      } else if (methodName.equals("unsupported") && void.class == returnType) {
+        this.unsupported = true; // Peer doesn't support ALPN.
+        return null;
+      } else if (methodName.equals("protocols") && args.length == 0) {
+        return protocols; // Client advertises these protocols.
+      } else if ((methodName.equals("selectProtocol") || methodName.equals("select"))
+          && String.class == returnType && args.length == 1 && args[0] instanceof List) {
+        List<String> peerProtocols = (List) args[0];
+        // Pick the first known protocol the peer advertises.
+        for (int i = 0, size = peerProtocols.size(); i < size; i++) {
+          if (protocols.contains(peerProtocols.get(i))) {
+            return selected = peerProtocols.get(i);
+          }
+        }
+        return selected = protocols.get(0); // On no intersection, try peer's first protocol.
+      } else if ((methodName.equals("protocolSelected") || methodName.equals("selected"))
+          && args.length == 1) {
+        this.selected = (String) args[0]; // Server selected this protocol.
+        return null;
+      } else {
+        return method.invoke(this, args);
+      }
+    }
+  }
+
+  /**
+   * Returns the concatenation of 8-bit, length prefixed protocol names.
+   * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
+   */
+  static byte[] concatLengthPrefixed(List<Protocol> protocols) {
+    Buffer result = new Buffer();
+    for (int i = 0, size = protocols.size(); i < size; i++) {
+      Protocol protocol = protocols.get(i);
+      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
+      result.writeByte(protocol.toString().length());
+      result.writeUtf8(protocol.toString());
+    }
+    return result.readByteArray();
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/RouteDatabase.java b/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
similarity index 75%
rename from okhttp/src/main/java/com/squareup/okhttp/RouteDatabase.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
index 9cbeaa73f1..52c211eb54 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/RouteDatabase.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
@@ -13,12 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package com.squareup.okhttp.internal;
 
-import java.io.IOException;
+import com.squareup.okhttp.Route;
 import java.util.LinkedHashSet;
 import java.util.Set;
-import javax.net.ssl.SSLHandshakeException;
 
 /**
  * A blacklist of failed routes to avoid when creating a new connection to a
@@ -28,17 +27,11 @@
  * preferred.
  */
 public final class RouteDatabase {
-  private final Set<Route> failedRoutes = new LinkedHashSet<Route>();
+  private final Set<Route> failedRoutes = new LinkedHashSet<>();
 
   /** Records a failure connecting to {@code failedRoute}. */
-  public synchronized void failed(Route failedRoute, IOException failure) {
+  public synchronized void failed(Route failedRoute) {
     failedRoutes.add(failedRoute);
-
-    if (!(failure instanceof SSLHandshakeException)) {
-      // If the problem was not related to SSL then it will also fail with
-      // a different TLS mode therefore we can be proactive about it.
-      failedRoutes.add(failedRoute.flipTlsMode());
-    }
   }
 
   /** Records success connecting to {@code failedRoute}. */
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/StrictLineReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/StrictLineReader.java
deleted file mode 100644
index 74af6fd533..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/StrictLineReader.java
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal;
-
-import java.io.ByteArrayOutputStream;
-import java.io.Closeable;
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
-import java.nio.charset.Charset;
-
-/**
- * Buffers input from an {@link InputStream} for reading lines.
- *
- * <p>This class is used for buffered reading of lines. For purposes of this class, a line ends with
- * "\n" or "\r\n". End of input is reported by throwing {@code EOFException}. Unterminated line at
- * end of input is invalid and will be ignored, the caller may use {@code hasUnterminatedLine()}
- * to detect it after catching the {@code EOFException}.
- *
- * <p>This class is intended for reading input that strictly consists of lines, such as line-based
- * cache entries or cache journal. Unlike the {@link java.io.BufferedReader} which in conjunction
- * with {@link java.io.InputStreamReader} provides similar functionality, this class uses different
- * end-of-input reporting and a more restrictive definition of a line.
- *
- * <p>This class supports only charsets that encode '\r' and '\n' as a single byte with value 13
- * and 10, respectively, and the representation of no other character contains these values.
- * We currently check in constructor that the charset is one of US-ASCII, UTF-8 and ISO-8859-1.
- * The default charset is US_ASCII.
- */
-public class StrictLineReader implements Closeable {
-  private static final byte CR = (byte) '\r';
-  private static final byte LF = (byte) '\n';
-
-  private final InputStream in;
-  private final Charset charset;
-
-  /*
-   * Buffered data is stored in {@code buf}. As long as no exception occurs, 0 <= pos <= end
-   * and the data in the range [pos, end) is buffered for reading. At end of input, if there is
-   * an unterminated line, we set end == -1, otherwise end == pos. If the underlying
-   * {@code InputStream} throws an {@code IOException}, end may remain as either pos or -1.
-   */
-  private byte[] buf;
-  private int pos;
-  private int end;
-
-  /**
-   * Constructs a new {@code LineReader} with the specified charset and the default capacity.
-   *
-   * @param in the {@code InputStream} to read data from.
-   * @param charset the charset used to decode data. Only US-ASCII, UTF-8 and ISO-8859-1 are
-   *     supported.
-   * @throws NullPointerException if {@code in} or {@code charset} is null.
-   * @throws IllegalArgumentException if the specified charset is not supported.
-   */
-  public StrictLineReader(InputStream in, Charset charset) {
-    this(in, 8192, charset);
-  }
-
-  /**
-   * Constructs a new {@code LineReader} with the specified capacity and charset.
-   *
-   * @param in the {@code InputStream} to read data from.
-   * @param capacity the capacity of the buffer.
-   * @param charset the charset used to decode data. Only US-ASCII, UTF-8 and ISO-8859-1 are
-   *     supported.
-   * @throws NullPointerException if {@code in} or {@code charset} is null.
-   * @throws IllegalArgumentException if {@code capacity} is negative or zero
-   *     or the specified charset is not supported.
-   */
-  public StrictLineReader(InputStream in, int capacity, Charset charset) {
-    if (in == null || charset == null) {
-      throw new NullPointerException();
-    }
-    if (capacity < 0) {
-      throw new IllegalArgumentException("capacity <= 0");
-    }
-    if (!(charset.equals(Util.US_ASCII))) {
-      throw new IllegalArgumentException("Unsupported encoding");
-    }
-
-    this.in = in;
-    this.charset = charset;
-    buf = new byte[capacity];
-  }
-
-  /**
-   * Closes the reader by closing the underlying {@code InputStream} and
-   * marking this reader as closed.
-   *
-   * @throws IOException for errors when closing the underlying {@code InputStream}.
-   */
-  public void close() throws IOException {
-    synchronized (in) {
-      if (buf != null) {
-        buf = null;
-        in.close();
-      }
-    }
-  }
-
-  /**
-   * Reads the next line. A line ends with {@code "\n"} or {@code "\r\n"},
-   * this end of line marker is not included in the result.
-   *
-   * @return the next line from the input.
-   * @throws IOException for underlying {@code InputStream} errors.
-   * @throws EOFException for the end of source stream.
-   */
-  public String readLine() throws IOException {
-    synchronized (in) {
-      if (buf == null) {
-        throw new IOException("LineReader is closed");
-      }
-
-      // Read more data if we are at the end of the buffered data.
-      // Though it's an error to read after an exception, we will let {@code fillBuf()}
-      // throw again if that happens; thus we need to handle end == -1 as well as end == pos.
-      if (pos >= end) {
-        fillBuf();
-      }
-      // Try to find LF in the buffered data and return the line if successful.
-      for (int i = pos; i != end; ++i) {
-        if (buf[i] == LF) {
-          int lineEnd = (i != pos && buf[i - 1] == CR) ? i - 1 : i;
-          String res = new String(buf, pos, lineEnd - pos, charset.name());
-          pos = i + 1;
-          return res;
-        }
-      }
-
-      // Let's anticipate up to 80 characters on top of those already read.
-      ByteArrayOutputStream out = new ByteArrayOutputStream(end - pos + 80) {
-        @Override public String toString() {
-          int length = (count > 0 && buf[count - 1] == CR) ? count - 1 : count;
-          try {
-            return new String(buf, 0, length, charset.name());
-          } catch (UnsupportedEncodingException e) {
-            throw new AssertionError(e); // Since we control the charset this will never happen.
-          }
-        }
-      };
-
-      while (true) {
-        out.write(buf, pos, end - pos);
-        // Mark unterminated line in case fillBuf throws EOFException or IOException.
-        end = -1;
-        fillBuf();
-        // Try to find LF in the buffered data and return the line if successful.
-        for (int i = pos; i != end; ++i) {
-          if (buf[i] == LF) {
-            if (i != pos) {
-              out.write(buf, pos, i - pos);
-            }
-            pos = i + 1;
-            return out.toString();
-          }
-        }
-      }
-    }
-  }
-
-  /**
-   * Read an {@code int} from a line containing its decimal representation.
-   *
-   * @return the value of the {@code int} from the next line.
-   * @throws IOException for underlying {@code InputStream} errors or conversion error.
-   * @throws EOFException for the end of source stream.
-   */
-  public int readInt() throws IOException {
-    String intString = readLine();
-    try {
-      return Integer.parseInt(intString);
-    } catch (NumberFormatException e) {
-      throw new IOException("expected an int but was \"" + intString + "\"");
-    }
-  }
-
-  /**
-   * Reads new input data into the buffer. Call only with pos == end or end == -1,
-   * depending on the desired outcome if the function throws.
-   */
-  private void fillBuf() throws IOException {
-    int result = in.read(buf, 0, buf.length);
-    if (result == -1) {
-      throw new EOFException();
-    }
-    pos = 0;
-    end = result;
-  }
-}
-
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
new file mode 100644
index 0000000000..6f081d230c
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -0,0 +1,287 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.io.UnsupportedEncodingException;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.URI;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+import okio.Buffer;
+import okio.ByteString;
+import okio.Source;
+
+/** Junk drawer of utility methods. */
+public final class Util {
+  public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
+  public static final String[] EMPTY_STRING_ARRAY = new String[0];
+
+  /** A cheap and type-safe constant for the US-ASCII Charset. */
+  public static final Charset US_ASCII = Charset.forName("US-ASCII");
+
+  /** A cheap and type-safe constant for the UTF-8 Charset. */
+  public static final Charset UTF_8 = Charset.forName("UTF-8");
+
+  private Util() {
+  }
+
+  public static int getEffectivePort(URI uri) {
+    return getEffectivePort(uri.getScheme(), uri.getPort());
+  }
+
+  public static int getEffectivePort(URL url) {
+    return getEffectivePort(url.getProtocol(), url.getPort());
+  }
+
+  private static int getEffectivePort(String scheme, int specifiedPort) {
+    return specifiedPort != -1 ? specifiedPort : getDefaultPort(scheme);
+  }
+
+  public static int getDefaultPort(String protocol) {
+    if ("http".equals(protocol)) return 80;
+    if ("https".equals(protocol)) return 443;
+    return -1;
+  }
+
+  public static void checkOffsetAndCount(long arrayLength, long offset, long count) {
+    if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
+      throw new ArrayIndexOutOfBoundsException();
+    }
+  }
+
+  /** Returns true if two possibly-null objects are equal. */
+  public static boolean equal(Object a, Object b) {
+    return a == b || (a != null && a.equals(b));
+  }
+
+  /**
+   * Closes {@code closeable}, ignoring any checked exceptions. Does nothing
+   * if {@code closeable} is null.
+   */
+  public static void closeQuietly(Closeable closeable) {
+    if (closeable != null) {
+      try {
+        closeable.close();
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+
+  /**
+   * Closes {@code socket}, ignoring any checked exceptions. Does nothing if
+   * {@code socket} is null.
+   */
+  public static void closeQuietly(Socket socket) {
+    if (socket != null) {
+      try {
+        socket.close();
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+
+  /**
+   * Closes {@code serverSocket}, ignoring any checked exceptions. Does nothing if
+   * {@code serverSocket} is null.
+   */
+  public static void closeQuietly(ServerSocket serverSocket) {
+    if (serverSocket != null) {
+      try {
+        serverSocket.close();
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+
+  /**
+   * Closes {@code a} and {@code b}. If either close fails, this completes
+   * the other close and rethrows the first encountered exception.
+   */
+  public static void closeAll(Closeable a, Closeable b) throws IOException {
+    Throwable thrown = null;
+    try {
+      a.close();
+    } catch (Throwable e) {
+      thrown = e;
+    }
+    try {
+      b.close();
+    } catch (Throwable e) {
+      if (thrown == null) thrown = e;
+    }
+    if (thrown == null) return;
+    if (thrown instanceof IOException) throw (IOException) thrown;
+    if (thrown instanceof RuntimeException) throw (RuntimeException) thrown;
+    if (thrown instanceof Error) throw (Error) thrown;
+    throw new AssertionError(thrown);
+  }
+
+  /**
+   * Deletes the contents of {@code dir}. Throws an IOException if any file
+   * could not be deleted, or if {@code dir} is not a readable directory.
+   */
+  public static void deleteContents(File dir) throws IOException {
+    File[] files = dir.listFiles();
+    if (files == null) {
+      throw new IOException("not a readable directory: " + dir);
+    }
+    for (File file : files) {
+      if (file.isDirectory()) {
+        deleteContents(file);
+      }
+      if (!file.delete()) {
+        throw new IOException("failed to delete file: " + file);
+      }
+    }
+  }
+
+  /**
+   * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading
+   * a complete source is helpful, such as when doing so completes a cache body or frees a socket
+   * connection for reuse.
+   */
+  public static boolean discard(Source source, int timeout, TimeUnit timeUnit) {
+    try {
+      return skipAll(source, timeout, timeUnit);
+    } catch (IOException e) {
+      return false;
+    }
+  }
+
+  /**
+   * Reads until {@code in} is exhausted or the deadline has been reached. This is careful to not
+   * extend the deadline if one exists already.
+   */
+  public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) throws IOException {
+    long now = System.nanoTime();
+    long originalDuration = source.timeout().hasDeadline()
+        ? source.timeout().deadlineNanoTime() - now
+        : Long.MAX_VALUE;
+    source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));
+    try {
+      Buffer skipBuffer = new Buffer();
+      while (source.read(skipBuffer, 2048) != -1) {
+        skipBuffer.clear();
+      }
+      return true; // Success! The source has been exhausted.
+    } catch (InterruptedIOException e) {
+      return false; // We ran out of time before exhausting the source.
+    } finally {
+      if (originalDuration == Long.MAX_VALUE) {
+        source.timeout().clearDeadline();
+      } else {
+        source.timeout().deadlineNanoTime(now + originalDuration);
+      }
+    }
+  }
+
+  /** Returns a 32 character string containing an MD5 hash of {@code s}. */
+  public static String md5Hex(String s) {
+    try {
+      MessageDigest messageDigest = MessageDigest.getInstance("MD5");
+      byte[] md5bytes = messageDigest.digest(s.getBytes("UTF-8"));
+      return ByteString.of(md5bytes).hex();
+    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  /** Returns a Base 64-encoded string containing a SHA-1 hash of {@code s}. */
+  public static String shaBase64(String s) {
+    try {
+      MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
+      byte[] sha1Bytes = messageDigest.digest(s.getBytes("UTF-8"));
+      return ByteString.of(sha1Bytes).base64();
+    } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  /** Returns a SHA-1 hash of {@code s}. */
+  public static ByteString sha1(ByteString s) {
+    try {
+      MessageDigest messageDigest = MessageDigest.getInstance("SHA-1");
+      byte[] sha1Bytes = messageDigest.digest(s.toByteArray());
+      return ByteString.of(sha1Bytes);
+    } catch (NoSuchAlgorithmException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  /** Returns an immutable copy of {@code list}. */
+  public static <T> List<T> immutableList(List<T> list) {
+    return Collections.unmodifiableList(new ArrayList<>(list));
+  }
+
+  /** Returns an immutable list containing {@code elements}. */
+  public static <T> List<T> immutableList(T... elements) {
+    return Collections.unmodifiableList(Arrays.asList(elements.clone()));
+  }
+
+  /** Returns an immutable copy of {@code map}. */
+  public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {
+    return Collections.unmodifiableMap(new LinkedHashMap<>(map));
+  }
+
+  public static ThreadFactory threadFactory(final String name, final boolean daemon) {
+    return new ThreadFactory() {
+      @Override public Thread newThread(Runnable runnable) {
+        Thread result = new Thread(runnable, name);
+        result.setDaemon(daemon);
+        return result;
+      }
+    };
+  }
+
+  /**
+   * Returns a mutable copy of {@code first} containing only elements also in {@code second}. The
+   * returned elements are in the same order as in {@code first}.
+   */
+  public static <T> List<T> intersect(T[] first, T[] second) {
+    List<T> result = new ArrayList<>();
+    for (T a : first) {
+      for (T b : second) {
+        if (a.equals(b)) {
+          result.add(b);
+          break;
+        }
+      }
+    }
+    return result;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java
deleted file mode 100644
index a5d39b30a4..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.CacheRequest;
-
-/**
- * An input stream for the body of an HTTP response.
- *
- * <p>Since a single socket's input stream may be used to read multiple HTTP
- * responses from the same server, subclasses shouldn't close the socket stream.
- *
- * <p>A side effect of reading an HTTP response is that the response cache
- * is populated. If the stream is closed early, that cache entry will be
- * invalidated.
- */
-abstract class AbstractHttpInputStream extends InputStream {
-  protected final InputStream in;
-  protected final HttpEngine httpEngine;
-  private final CacheRequest cacheRequest;
-  private final OutputStream cacheBody;
-  protected boolean closed;
-
-  AbstractHttpInputStream(InputStream in, HttpEngine httpEngine, CacheRequest cacheRequest)
-      throws IOException {
-    this.in = in;
-    this.httpEngine = httpEngine;
-
-    OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
-
-    // some apps return a null body; for compatibility we treat that like a null cache request
-    if (cacheBody == null) {
-      cacheRequest = null;
-    }
-
-    this.cacheBody = cacheBody;
-    this.cacheRequest = cacheRequest;
-  }
-
-  /**
-   * read() is implemented using read(byte[], int, int) so subclasses only
-   * need to override the latter.
-   */
-  @Override public final int read() throws IOException {
-    return Util.readSingleByte(this);
-  }
-
-  protected final void checkNotClosed() throws IOException {
-    if (closed) {
-      throw new IOException("stream closed");
-    }
-  }
-
-  protected final void cacheWrite(byte[] buffer, int offset, int count) throws IOException {
-    if (cacheBody != null) {
-      cacheBody.write(buffer, offset, count);
-    }
-  }
-
-  /**
-   * Closes the cache entry and makes the socket available for reuse. This
-   * should be invoked when the end of the body has been reached.
-   */
-  protected final void endOfInput() throws IOException {
-    if (cacheRequest != null) {
-      cacheBody.close();
-    }
-    httpEngine.release(false);
-  }
-
-  /**
-   * Calls abort on the cache entry and disconnects the socket. This
-   * should be invoked when the connection is closed unexpectedly to
-   * invalidate the cache entry and to prevent the HTTP connection from
-   * being reused. HTTP messages are sent in serial so whenever a message
-   * cannot be read to completion, subsequent messages cannot be read
-   * either and the connection must be discarded.
-   *
-   * <p>An earlier implementation skipped the remaining bytes, but this
-   * requires that the entire transfer be completed. If the intention was
-   * to cancel the transfer, closing the connection is the only solution.
-   */
-  protected final void unexpectedEndOfInput() {
-    if (cacheRequest != null) {
-      cacheRequest.abort();
-    }
-    httpEngine.release(true);
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
new file mode 100644
index 0000000000..a517ada7cc
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Authenticator;
+import com.squareup.okhttp.Challenge;
+import com.squareup.okhttp.Credentials;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.net.Authenticator.RequestorType;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.PasswordAuthentication;
+import java.net.Proxy;
+import java.net.URL;
+import java.util.List;
+
+/** Adapts {@link java.net.Authenticator} to {@link com.squareup.okhttp.Authenticator}. */
+public final class AuthenticatorAdapter implements Authenticator {
+  /** Uses the global authenticator to get the password. */
+  public static final Authenticator INSTANCE = new AuthenticatorAdapter();
+
+  @Override public Request authenticate(Proxy proxy, Response response) throws IOException {
+    List<Challenge> challenges = response.challenges();
+    Request request = response.request();
+    URL url = request.url();
+    for (int i = 0, size = challenges.size(); i < size; i++) {
+      Challenge challenge = challenges.get(i);
+      if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
+
+      PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
+          url.getHost(), getConnectToInetAddress(proxy, url), url.getPort(), url.getProtocol(),
+          challenge.getRealm(), challenge.getScheme(), url, RequestorType.SERVER);
+      if (auth == null) continue;
+
+      String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
+      return request.newBuilder()
+          .header("Authorization", credential)
+          .build();
+    }
+    return null;
+
+  }
+
+  @Override public Request authenticateProxy(Proxy proxy, Response response) throws IOException {
+    List<Challenge> challenges = response.challenges();
+    Request request = response.request();
+    URL url = request.url();
+    for (int i = 0, size = challenges.size(); i < size; i++) {
+      Challenge challenge = challenges.get(i);
+      if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
+
+      InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
+      PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
+          proxyAddress.getHostName(), getConnectToInetAddress(proxy, url), proxyAddress.getPort(),
+          url.getProtocol(), challenge.getRealm(), challenge.getScheme(), url,
+          RequestorType.PROXY);
+      if (auth == null) continue;
+
+      String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
+      return request.newBuilder()
+          .header("Proxy-Authorization", credential)
+          .build();
+    }
+    return null;
+  }
+
+  private InetAddress getConnectToInetAddress(Proxy proxy, URL url) throws IOException {
+    return (proxy != null && proxy.type() != Proxy.Type.DIRECT)
+        ? ((InetSocketAddress) proxy.address()).getAddress()
+        : InetAddress.getByName(url.getHost());
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java
new file mode 100644
index 0000000000..b8153e4f07
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+import okio.Sink;
+
+public interface CacheRequest {
+  Sink body() throws IOException;
+  void abort();
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
new file mode 100644
index 0000000000..69db3947f5
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
@@ -0,0 +1,294 @@
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.CacheControl;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.util.Date;
+
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static java.net.HttpURLConnection.HTTP_GONE;
+import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
+import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
+import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
+import static java.net.HttpURLConnection.HTTP_NOT_AUTHORITATIVE;
+import static java.net.HttpURLConnection.HTTP_OK;
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Given a request and cached response, this figures out whether to use the
+ * network, the cache, or both.
+ *
+ * <p>Selecting a cache strategy may add conditions to the request (like the
+ * "If-Modified-Since" header for conditional GETs) or warnings to the cached
+ * response (if the cached data is potentially stale).
+ */
+public final class CacheStrategy {
+  /** The request to send on the network, or null if this call doesn't use the network. */
+  public final Request networkRequest;
+
+  /** The cached response to return or validate; or null if this call doesn't use a cache. */
+  public final Response cacheResponse;
+
+  private CacheStrategy(Request networkRequest, Response cacheResponse) {
+    this.networkRequest = networkRequest;
+    this.cacheResponse = cacheResponse;
+  }
+
+  /**
+   * Returns true if {@code response} can be stored to later serve another
+   * request.
+   */
+  public static boolean isCacheable(Response response, Request request) {
+    // Always go to network for uncacheable response codes (RFC 7231 section 6.1),
+    // This implementation doesn't support caching partial content.
+    switch (response.code()) {
+      case HTTP_OK:
+      case HTTP_NOT_AUTHORITATIVE:
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_GONE:
+      case HTTP_PERM_REDIRECT:
+        // These codes can be cached unless headers forbid it.
+        break;
+
+      case HTTP_MOVED_TEMP:
+      case HTTP_TEMP_REDIRECT:
+        // These codes can only be cached with the right response headers.
+        if (response.header("Expires") != null
+            || response.cacheControl().maxAgeSeconds() != -1
+            || response.cacheControl().sMaxAgeSeconds() != -1
+            || response.cacheControl().isPublic()) {
+          break;
+        }
+        // Fall-through.
+
+      default:
+        // All other codes cannot be cached.
+        return false;
+    }
+
+    // A 'no-store' directive on request or response prevents the response from being cached.
+    return !response.cacheControl().noStore() && !request.cacheControl().noStore();
+  }
+
+  public static class Factory {
+    final long nowMillis;
+    final Request request;
+    final Response cacheResponse;
+
+    /** The server's time when the cached response was served, if known. */
+    private Date servedDate;
+    private String servedDateString;
+
+    /** The last modified date of the cached response, if known. */
+    private Date lastModified;
+    private String lastModifiedString;
+
+    /**
+     * The expiration date of the cached response, if known. If both this field
+     * and the max age are set, the max age is preferred.
+     */
+    private Date expires;
+
+    /**
+     * Extension header set by OkHttp specifying the timestamp when the cached
+     * HTTP request was first initiated.
+     */
+    private long sentRequestMillis;
+
+    /**
+     * Extension header set by OkHttp specifying the timestamp when the cached
+     * HTTP response was first received.
+     */
+    private long receivedResponseMillis;
+
+    /** Etag of the cached response. */
+    private String etag;
+
+    /** Age of the cached response. */
+    private int ageSeconds = -1;
+
+    public Factory(long nowMillis, Request request, Response cacheResponse) {
+      this.nowMillis = nowMillis;
+      this.request = request;
+      this.cacheResponse = cacheResponse;
+
+      if (cacheResponse != null) {
+        Headers headers = cacheResponse.headers();
+        for (int i = 0, size = headers.size(); i < size; i++) {
+          String fieldName = headers.name(i);
+          String value = headers.value(i);
+          if ("Date".equalsIgnoreCase(fieldName)) {
+            servedDate = HttpDate.parse(value);
+            servedDateString = value;
+          } else if ("Expires".equalsIgnoreCase(fieldName)) {
+            expires = HttpDate.parse(value);
+          } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
+            lastModified = HttpDate.parse(value);
+            lastModifiedString = value;
+          } else if ("ETag".equalsIgnoreCase(fieldName)) {
+            etag = value;
+          } else if ("Age".equalsIgnoreCase(fieldName)) {
+            ageSeconds = HeaderParser.parseSeconds(value, -1);
+          } else if (OkHeaders.SENT_MILLIS.equalsIgnoreCase(fieldName)) {
+            sentRequestMillis = Long.parseLong(value);
+          } else if (OkHeaders.RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
+            receivedResponseMillis = Long.parseLong(value);
+          }
+        }
+      }
+    }
+
+    /**
+     * Returns a strategy to satisfy {@code request} using the a cached response
+     * {@code response}.
+     */
+    public CacheStrategy get() {
+      CacheStrategy candidate = getCandidate();
+
+      if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {
+        // We're forbidden from using the network and the cache is insufficient.
+        return new CacheStrategy(null, null);
+      }
+
+      return candidate;
+    }
+
+    /** Returns a strategy to use assuming the request can use the network. */
+    private CacheStrategy getCandidate() {
+      // No cached response.
+      if (cacheResponse == null) {
+        return new CacheStrategy(request, null);
+      }
+
+      // Drop the cached response if it's missing a required handshake.
+      if (request.isHttps() && cacheResponse.handshake() == null) {
+        return new CacheStrategy(request, null);
+      }
+
+      // If this response shouldn't have been stored, it should never be used
+      // as a response source. This check should be redundant as long as the
+      // persistence store is well-behaved and the rules are constant.
+      if (!isCacheable(cacheResponse, request)) {
+        return new CacheStrategy(request, null);
+      }
+
+      CacheControl requestCaching = request.cacheControl();
+      if (requestCaching.noCache() || hasConditions(request)) {
+        return new CacheStrategy(request, null);
+      }
+
+      long ageMillis = cacheResponseAge();
+      long freshMillis = computeFreshnessLifetime();
+
+      if (requestCaching.maxAgeSeconds() != -1) {
+        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
+      }
+
+      long minFreshMillis = 0;
+      if (requestCaching.minFreshSeconds() != -1) {
+        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
+      }
+
+      long maxStaleMillis = 0;
+      CacheControl responseCaching = cacheResponse.cacheControl();
+      if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
+        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
+      }
+
+      if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
+        Response.Builder builder = cacheResponse.newBuilder();
+        if (ageMillis + minFreshMillis >= freshMillis) {
+          builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
+        }
+        long oneDayMillis = 24 * 60 * 60 * 1000L;
+        if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
+          builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
+        }
+        return new CacheStrategy(null, builder.build());
+      }
+
+      Request.Builder conditionalRequestBuilder = request.newBuilder();
+
+      if (lastModified != null) {
+        conditionalRequestBuilder.header("If-Modified-Since", lastModifiedString);
+      } else if (servedDate != null) {
+        conditionalRequestBuilder.header("If-Modified-Since", servedDateString);
+      }
+
+      if (etag != null) {
+        conditionalRequestBuilder.header("If-None-Match", etag);
+      }
+
+      Request conditionalRequest = conditionalRequestBuilder.build();
+      return hasConditions(conditionalRequest)
+          ? new CacheStrategy(conditionalRequest, cacheResponse)
+          : new CacheStrategy(conditionalRequest, null);
+    }
+
+    /**
+     * Returns the number of milliseconds that the response was fresh for,
+     * starting from the served date.
+     */
+    private long computeFreshnessLifetime() {
+      CacheControl responseCaching = cacheResponse.cacheControl();
+      if (responseCaching.maxAgeSeconds() != -1) {
+        return SECONDS.toMillis(responseCaching.maxAgeSeconds());
+      } else if (expires != null) {
+        long servedMillis = servedDate != null
+            ? servedDate.getTime()
+            : receivedResponseMillis;
+        long delta = expires.getTime() - servedMillis;
+        return delta > 0 ? delta : 0;
+      } else if (lastModified != null
+          && cacheResponse.request().url().getQuery() == null) {
+        // As recommended by the HTTP RFC and implemented in Firefox, the
+        // max age of a document should be defaulted to 10% of the
+        // document's age at the time it was served. Default expiration
+        // dates aren't used for URIs containing a query.
+        long servedMillis = servedDate != null
+            ? servedDate.getTime()
+            : sentRequestMillis;
+        long delta = servedMillis - lastModified.getTime();
+        return delta > 0 ? (delta / 10) : 0;
+      }
+      return 0;
+    }
+
+    /**
+     * Returns the current age of the response, in milliseconds. The calculation
+     * is specified by RFC 2616, 13.2.3 Age Calculations.
+     */
+    private long cacheResponseAge() {
+      long apparentReceivedAge = servedDate != null
+          ? Math.max(0, receivedResponseMillis - servedDate.getTime())
+          : 0;
+      long receivedAge = ageSeconds != -1
+          ? Math.max(apparentReceivedAge, SECONDS.toMillis(ageSeconds))
+          : apparentReceivedAge;
+      long responseDuration = receivedResponseMillis - sentRequestMillis;
+      long residentDuration = nowMillis - receivedResponseMillis;
+      return receivedAge + responseDuration + residentDuration;
+    }
+
+    /**
+     * Returns true if computeFreshnessLifetime used a heuristic. If we used a
+     * heuristic to serve a cached response older than 24 hours, we are required
+     * to attach a warning.
+     */
+    private boolean isFreshnessLifetimeHeuristic() {
+      return cacheResponse.cacheControl().maxAgeSeconds() == -1 && expires == null;
+    }
+
+    /**
+     * Returns true if the request contains conditions that save the server from
+     * sending a response that the client has locally. When a request is enqueued
+     * with its own conditions, the built-in response cache won't be used.
+     */
+    private static boolean hasConditions(Request request) {
+      return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
index 12e6409737..55f82ada47 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
@@ -16,50 +16,7 @@
 
 package com.squareup.okhttp.internal.http;
 
-final class HeaderParser {
-
-  public interface CacheControlHandler {
-    void handle(String directive, String parameter);
-  }
-
-  /** Parse a comma-separated list of cache control header values. */
-  public static void parseCacheControl(String value, CacheControlHandler handler) {
-    int pos = 0;
-    while (pos < value.length()) {
-      int tokenStart = pos;
-      pos = skipUntil(value, pos, "=,");
-      String directive = value.substring(tokenStart, pos).trim();
-
-      if (pos == value.length() || value.charAt(pos) == ',') {
-        pos++; // consume ',' (if necessary)
-        handler.handle(directive, null);
-        continue;
-      }
-
-      pos++; // consume '='
-      pos = skipWhitespace(value, pos);
-
-      String parameter;
-
-      // quoted string
-      if (pos < value.length() && value.charAt(pos) == '\"') {
-        pos++; // consume '"' open quote
-        int parameterStart = pos;
-        pos = skipUntil(value, pos, "\"");
-        parameter = value.substring(parameterStart, pos);
-        pos++; // consume '"' close quote (if necessary)
-
-        // unquoted string
-      } else {
-        int parameterStart = pos;
-        pos = skipUntil(value, pos, ",");
-        parameter = value.substring(parameterStart, pos).trim();
-      }
-
-      handler.handle(directive, parameter);
-    }
-  }
-
+public final class HeaderParser {
   /**
    * Returns the next index in {@code input} at or after {@code pos} that
    * contains a character from {@code characters}. Returns the input length if
@@ -90,9 +47,9 @@ public static int skipWhitespace(String input, int pos) {
 
   /**
    * Returns {@code value} as a positive integer, or 0 if it is negative, or
-   * -1 if it cannot be parsed.
+   * {@code defaultValue} if it cannot be parsed.
    */
-  public static int parseSeconds(String value) {
+  public static int parseSeconds(String value, int defaultValue) {
     try {
       long seconds = Long.parseLong(value);
       if (seconds > Integer.MAX_VALUE) {
@@ -103,7 +60,7 @@ public static int parseSeconds(String value) {
         return (int) seconds;
       }
     } catch (NumberFormatException e) {
-      return -1;
+      return defaultValue;
     }
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java
deleted file mode 100644
index 63f39e47f0..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.OkAuthenticator;
-import com.squareup.okhttp.OkAuthenticator.Challenge;
-import java.io.IOException;
-import java.net.Authenticator;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.PasswordAuthentication;
-import java.net.Proxy;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-
-import static com.squareup.okhttp.OkAuthenticator.Credential;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
-import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
-
-/** Handles HTTP authentication headers from origin and proxy servers. */
-public final class HttpAuthenticator {
-  /** Uses the global authenticator to get the password. */
-  public static final OkAuthenticator SYSTEM_DEFAULT = new OkAuthenticator() {
-    @Override public Credential authenticate(
-        Proxy proxy, URL url, List<Challenge> challenges) throws IOException {
-      for (Challenge challenge : challenges) {
-        if (!"Basic".equals(challenge.getScheme())) {
-          continue;
-        }
-
-        PasswordAuthentication auth = Authenticator.requestPasswordAuthentication(url.getHost(),
-            getConnectToInetAddress(proxy, url), url.getPort(), url.getProtocol(),
-            challenge.getRealm(), challenge.getScheme(), url, Authenticator.RequestorType.SERVER);
-        if (auth != null) {
-          return Credential.basic(auth.getUserName(), new String(auth.getPassword()));
-        }
-      }
-      return null;
-    }
-
-    @Override public Credential authenticateProxy(
-        Proxy proxy, URL url, List<Challenge> challenges) throws IOException {
-      for (Challenge challenge : challenges) {
-        if (!"Basic".equals(challenge.getScheme())) {
-          continue;
-        }
-
-        InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
-        PasswordAuthentication auth = Authenticator.requestPasswordAuthentication(
-            proxyAddress.getHostName(), getConnectToInetAddress(proxy, url), proxyAddress.getPort(),
-            url.getProtocol(), challenge.getRealm(), challenge.getScheme(), url,
-            Authenticator.RequestorType.PROXY);
-        if (auth != null) {
-          return Credential.basic(auth.getUserName(), new String(auth.getPassword()));
-        }
-      }
-      return null;
-    }
-
-    private InetAddress getConnectToInetAddress(Proxy proxy, URL url) throws IOException {
-      return (proxy != null && proxy.type() != Proxy.Type.DIRECT)
-          ? ((InetSocketAddress) proxy.address()).getAddress()
-          : InetAddress.getByName(url.getHost());
-    }
-  };
-
-  private HttpAuthenticator() {
-  }
-
-  /**
-   * React to a failed authorization response by looking up new credentials.
-   *
-   * @return true if credentials have been added to successorRequestHeaders
-   *         and another request should be attempted.
-   */
-  public static boolean processAuthHeader(OkAuthenticator authenticator, int responseCode,
-      RawHeaders responseHeaders, RawHeaders successorRequestHeaders, Proxy proxy, URL url)
-      throws IOException {
-    String responseField;
-    String requestField;
-    if (responseCode == HTTP_UNAUTHORIZED) {
-      responseField = "WWW-Authenticate";
-      requestField = "Authorization";
-    } else if (responseCode == HTTP_PROXY_AUTH) {
-      responseField = "Proxy-Authenticate";
-      requestField = "Proxy-Authorization";
-    } else {
-      throw new IllegalArgumentException(); // TODO: ProtocolException?
-    }
-    List<Challenge> challenges = parseChallenges(responseHeaders, responseField);
-    if (challenges.isEmpty()) {
-      return false; // Could not find a challenge so end the request cycle.
-    }
-    Credential credential = responseHeaders.getResponseCode() == HTTP_PROXY_AUTH
-        ? authenticator.authenticateProxy(proxy, url, challenges)
-        : authenticator.authenticate(proxy, url, challenges);
-    if (credential == null) {
-      return false; // Could not satisfy the challenge so end the request cycle.
-    }
-    // Add authorization credentials, bypassing the already-connected check.
-    successorRequestHeaders.set(requestField, credential.getHeaderValue());
-    return true;
-  }
-
-  /**
-   * Parse RFC 2617 challenges. This API is only interested in the scheme
-   * name and realm.
-   */
-  private static List<Challenge> parseChallenges(RawHeaders responseHeaders,
-      String challengeHeader) {
-    // auth-scheme = token
-    // auth-param  = token "=" ( token | quoted-string )
-    // challenge   = auth-scheme 1*SP 1#auth-param
-    // realm       = "realm" "=" realm-value
-    // realm-value = quoted-string
-    List<Challenge> result = new ArrayList<Challenge>();
-    for (int h = 0; h < responseHeaders.length(); h++) {
-      if (!challengeHeader.equalsIgnoreCase(responseHeaders.getFieldName(h))) {
-        continue;
-      }
-      String value = responseHeaders.getValue(h);
-      int pos = 0;
-      while (pos < value.length()) {
-        int tokenStart = pos;
-        pos = HeaderParser.skipUntil(value, pos, " ");
-
-        String scheme = value.substring(tokenStart, pos).trim();
-        pos = HeaderParser.skipWhitespace(value, pos);
-
-        // TODO: This currently only handles schemes with a 'realm' parameter;
-        //       It needs to be fixed to handle any scheme and any parameters
-        //       http://code.google.com/p/android/issues/detail?id=11140
-
-        if (!value.regionMatches(pos, "realm=\"", 0, "realm=\"".length())) {
-          break; // Unexpected challenge parameter; give up!
-        }
-
-        pos += "realm=\"".length();
-        int realmStart = pos;
-        pos = HeaderParser.skipUntil(value, pos, "\"");
-        String realm = value.substring(realmStart, pos);
-        pos++; // Consume '"' close quote.
-        pos = HeaderParser.skipUntil(value, pos, ",");
-        pos++; // Consume ',' comma.
-        pos = HeaderParser.skipWhitespace(value, pos);
-        result.add(new Challenge(scheme, realm));
-      }
-    }
-    return result;
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
new file mode 100644
index 0000000000..d4743d2772
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -0,0 +1,516 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.net.Socket;
+import java.net.SocketTimeoutException;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
+
+import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
+import static com.squareup.okhttp.internal.http.Transport.DISCARD_STREAM_TIMEOUT_MILLIS;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+/**
+ * A socket connection that can be used to send HTTP/1.1 messages. This class
+ * strictly enforces the following lifecycle:
+ * <ol>
+ *   <li>{@link #writeRequest Send request headers}.
+ *   <li>Open a sink to write the request body. Either {@link
+ *       #newFixedLengthSink fixed-length} or {@link #newChunkedSink chunked}.
+ *   <li>Write to and then close that sink.
+ *   <li>{@link #readResponse Read response headers}.
+ *   <li>Open a source to read the response body. Either {@link
+ *       #newFixedLengthSource fixed-length}, {@link #newChunkedSource chunked}
+ *       or {@link #newUnknownLengthSource unknown length}.
+ *   <li>Read from and close that source.
+ * </ol>
+ * <p>Exchanges that do not have a request body may skip creating and closing
+ * the request body. Exchanges that do not have a response body can call {@link
+ * #newFixedLengthSource(long) newFixedLengthSource(0)} and may skip reading and
+ * closing that source.
+ */
+public final class HttpConnection {
+  private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
+  private static final int STATE_OPEN_REQUEST_BODY = 1;
+  private static final int STATE_WRITING_REQUEST_BODY = 2;
+  private static final int STATE_READ_RESPONSE_HEADERS = 3;
+  private static final int STATE_OPEN_RESPONSE_BODY = 4;
+  private static final int STATE_READING_RESPONSE_BODY = 5;
+  private static final int STATE_CLOSED = 6;
+
+  private static final int ON_IDLE_HOLD = 0;
+  private static final int ON_IDLE_POOL = 1;
+  private static final int ON_IDLE_CLOSE = 2;
+
+  private final ConnectionPool pool;
+  private final Connection connection;
+  private final Socket socket;
+  private final BufferedSource source;
+  private final BufferedSink sink;
+
+  private int state = STATE_IDLE;
+  private int onIdle = ON_IDLE_HOLD;
+
+  public HttpConnection(ConnectionPool pool, Connection connection, Socket socket)
+      throws IOException {
+    this.pool = pool;
+    this.connection = connection;
+    this.socket = socket;
+    this.source = Okio.buffer(Okio.source(socket));
+    this.sink = Okio.buffer(Okio.sink(socket));
+  }
+
+  public void setTimeouts(int readTimeoutMillis, int writeTimeoutMillis) {
+    if (readTimeoutMillis != 0) {
+      source.timeout().timeout(readTimeoutMillis, MILLISECONDS);
+    }
+    if (writeTimeoutMillis != 0) {
+      sink.timeout().timeout(writeTimeoutMillis, MILLISECONDS);
+    }
+  }
+
+  /**
+   * Configure this connection to put itself back into the connection pool when
+   * the HTTP response body is exhausted.
+   */
+  public void poolOnIdle() {
+    onIdle = ON_IDLE_POOL;
+
+    // If we're already idle, go to the pool immediately.
+    if (state == STATE_IDLE) {
+      onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
+      Internal.instance.recycle(pool, connection);
+    }
+  }
+
+  /**
+   * Configure this connection to close itself when the HTTP response body is
+   * exhausted.
+   */
+  public void closeOnIdle() throws IOException {
+    onIdle = ON_IDLE_CLOSE;
+
+    // If we're already idle, close immediately.
+    if (state == STATE_IDLE) {
+      state = STATE_CLOSED;
+      connection.getSocket().close();
+    }
+  }
+
+  /** Returns true if this connection is closed. */
+  public boolean isClosed() {
+    return state == STATE_CLOSED;
+  }
+
+  public void closeIfOwnedBy(Object owner) throws IOException {
+    Internal.instance.closeIfOwnedBy(connection, owner);
+  }
+
+  public void flush() throws IOException {
+    sink.flush();
+  }
+
+  /** Returns the number of buffered bytes immediately readable. */
+  public long bufferSize() {
+    return source.buffer().size();
+  }
+
+  /** Test for a stale socket. */
+  public boolean isReadable() {
+    try {
+      int readTimeout = socket.getSoTimeout();
+      try {
+        socket.setSoTimeout(1);
+        if (source.exhausted()) {
+          return false; // Stream is exhausted; socket is closed.
+        }
+        return true;
+      } finally {
+        socket.setSoTimeout(readTimeout);
+      }
+    } catch (SocketTimeoutException ignored) {
+      return true; // Read timed out; socket is good.
+    } catch (IOException e) {
+      return false; // Couldn't read; socket is closed.
+    }
+  }
+
+  /** Returns bytes of a request header for sending on an HTTP transport. */
+  public void writeRequest(Headers headers, String requestLine) throws IOException {
+    if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
+    sink.writeUtf8(requestLine).writeUtf8("\r\n");
+    for (int i = 0, size = headers.size(); i < size; i ++) {
+      sink.writeUtf8(headers.name(i))
+          .writeUtf8(": ")
+          .writeUtf8(headers.value(i))
+          .writeUtf8("\r\n");
+    }
+    sink.writeUtf8("\r\n");
+    state = STATE_OPEN_REQUEST_BODY;
+  }
+
+  /** Parses bytes of a response header from an HTTP transport. */
+  public Response.Builder readResponse() throws IOException {
+    if (state != STATE_OPEN_REQUEST_BODY && state != STATE_READ_RESPONSE_HEADERS) {
+      throw new IllegalStateException("state: " + state);
+    }
+
+    while (true) {
+      StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+
+      Response.Builder responseBuilder = new Response.Builder()
+          .protocol(statusLine.protocol)
+          .code(statusLine.code)
+          .message(statusLine.message);
+
+      Headers.Builder headersBuilder = new Headers.Builder();
+      readHeaders(headersBuilder);
+      headersBuilder.add(OkHeaders.SELECTED_PROTOCOL, statusLine.protocol.toString());
+      responseBuilder.headers(headersBuilder.build());
+
+      if (statusLine.code != HTTP_CONTINUE) {
+        state = STATE_OPEN_RESPONSE_BODY;
+        return responseBuilder;
+      }
+    }
+  }
+
+  /** Reads headers or trailers into {@code builder}. */
+  public void readHeaders(Headers.Builder builder) throws IOException {
+    // parse the result headers until the first blank line
+    for (String line; (line = source.readUtf8LineStrict()).length() != 0; ) {
+      Internal.instance.addLenient(builder, line);
+    }
+  }
+
+  public Sink newChunkedSink() {
+    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_WRITING_REQUEST_BODY;
+    return new ChunkedSink();
+  }
+
+  public Sink newFixedLengthSink(long contentLength) {
+    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_WRITING_REQUEST_BODY;
+    return new FixedLengthSink(contentLength);
+  }
+
+  public void writeRequestBody(RetryableSink requestBody) throws IOException {
+    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_READ_RESPONSE_HEADERS;
+    requestBody.writeToSocket(sink);
+  }
+
+  public Source newFixedLengthSource(long length) throws IOException {
+    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_READING_RESPONSE_BODY;
+    return new FixedLengthSource(length);
+  }
+
+  public Source newChunkedSource(HttpEngine httpEngine) throws IOException {
+    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_READING_RESPONSE_BODY;
+    return new ChunkedSource(httpEngine);
+  }
+
+  public Source newUnknownLengthSource() throws IOException {
+    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_READING_RESPONSE_BODY;
+    return new UnknownLengthSource();
+  }
+
+  /** An HTTP body with a fixed length known in advance. */
+  private final class FixedLengthSink implements Sink {
+    private boolean closed;
+    private long bytesRemaining;
+
+    private FixedLengthSink(long bytesRemaining) {
+      this.bytesRemaining = bytesRemaining;
+    }
+
+    @Override public Timeout timeout() {
+      return sink.timeout();
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      if (closed) throw new IllegalStateException("closed");
+      checkOffsetAndCount(source.size(), 0, byteCount);
+      if (byteCount > bytesRemaining) {
+        throw new ProtocolException("expected " + bytesRemaining
+            + " bytes but received " + byteCount);
+      }
+      sink.write(source, byteCount);
+      bytesRemaining -= byteCount;
+    }
+
+    @Override public void flush() throws IOException {
+      if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
+      sink.flush();
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      closed = true;
+      if (bytesRemaining > 0) throw new ProtocolException("unexpected end of stream");
+      state = STATE_READ_RESPONSE_HEADERS;
+    }
+  }
+
+  private static final byte[] CRLF = { '\r', '\n' };
+  private static final byte[] HEX_DIGITS = {
+      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
+  };
+  private static final byte[] FINAL_CHUNK = { '0', '\r', '\n', '\r', '\n' };
+
+  /**
+   * An HTTP body with alternating chunk sizes and chunk bodies. It is the
+   * caller's responsibility to buffer chunks; typically by using a buffered
+   * sink with this sink.
+   */
+  private final class ChunkedSink implements Sink {
+    /** Scratch space for up to 16 hex digits, and then a constant CRLF. */
+    private final byte[] hex = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '\r', '\n' };
+
+    private boolean closed;
+
+    @Override public Timeout timeout() {
+      return sink.timeout();
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      if (closed) throw new IllegalStateException("closed");
+      if (byteCount == 0) return;
+
+      writeHex(byteCount);
+      sink.write(source, byteCount);
+      sink.write(CRLF);
+    }
+
+    @Override public synchronized void flush() throws IOException {
+      if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
+      sink.flush();
+    }
+
+    @Override public synchronized void close() throws IOException {
+      if (closed) return;
+      closed = true;
+      sink.write(FINAL_CHUNK);
+      state = STATE_READ_RESPONSE_HEADERS;
+    }
+
+    /**
+     * Equivalent to, but cheaper than writing Long.toHexString().getBytes()
+     * followed by CRLF.
+     */
+    private void writeHex(long i) throws IOException {
+      int cursor = 16;
+      do {
+        hex[--cursor] = HEX_DIGITS[((int) (i & 0xf))];
+      } while ((i >>>= 4) != 0);
+      sink.write(hex, cursor, hex.length - cursor);
+    }
+  }
+
+  private abstract class AbstractSource implements Source {
+    protected boolean closed;
+
+    @Override public Timeout timeout() {
+      return source.timeout();
+    }
+
+    /**
+     * Closes the cache entry and makes the socket available for reuse. This
+     * should be invoked when the end of the body has been reached.
+     */
+    protected final void endOfInput(boolean recyclable) throws IOException {
+      if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+
+      state = STATE_IDLE;
+      if (recyclable && onIdle == ON_IDLE_POOL) {
+        onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
+        Internal.instance.recycle(pool, connection);
+      } else if (onIdle == ON_IDLE_CLOSE) {
+        state = STATE_CLOSED;
+        connection.getSocket().close();
+      }
+    }
+
+    /**
+     * Calls abort on the cache entry and disconnects the socket. This
+     * should be invoked when the connection is closed unexpectedly to
+     * invalidate the cache entry and to prevent the HTTP connection from
+     * being reused. HTTP messages are sent in serial so whenever a message
+     * cannot be read to completion, subsequent messages cannot be read
+     * either and the connection must be discarded.
+     *
+     * <p>An earlier implementation skipped the remaining bytes, but this
+     * requires that the entire transfer be completed. If the intention was
+     * to cancel the transfer, closing the connection is the only solution.
+     */
+    protected final void unexpectedEndOfInput() {
+      Util.closeQuietly(connection.getSocket());
+      state = STATE_CLOSED;
+    }
+  }
+
+  /** An HTTP body with a fixed length specified in advance. */
+  private class FixedLengthSource extends AbstractSource {
+    private long bytesRemaining;
+
+    public FixedLengthSource(long length) throws IOException {
+      bytesRemaining = length;
+      if (bytesRemaining == 0) {
+        endOfInput(true);
+      }
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+      if (closed) throw new IllegalStateException("closed");
+      if (bytesRemaining == 0) return -1;
+
+      long read = source.read(sink, Math.min(bytesRemaining, byteCount));
+      if (read == -1) {
+        unexpectedEndOfInput(); // The server didn't supply the promised content length.
+        throw new ProtocolException("unexpected end of stream");
+      }
+
+      bytesRemaining -= read;
+      if (bytesRemaining == 0) {
+        endOfInput(true);
+      }
+      return read;
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+
+      if (bytesRemaining != 0
+          && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+        unexpectedEndOfInput();
+      }
+
+      closed = true;
+    }
+  }
+
+  /** An HTTP body with alternating chunk sizes and chunk bodies. */
+  private class ChunkedSource extends AbstractSource {
+    private static final int NO_CHUNK_YET = -1;
+    private int bytesRemainingInChunk = NO_CHUNK_YET;
+    private boolean hasMoreChunks = true;
+    private final HttpEngine httpEngine;
+
+    ChunkedSource(HttpEngine httpEngine) throws IOException {
+      this.httpEngine = httpEngine;
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+      if (closed) throw new IllegalStateException("closed");
+      if (!hasMoreChunks) return -1;
+
+      if (bytesRemainingInChunk == 0 || bytesRemainingInChunk == NO_CHUNK_YET) {
+        readChunkSize();
+        if (!hasMoreChunks) return -1;
+      }
+
+      long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
+      if (read == -1) {
+        unexpectedEndOfInput(); // The server didn't supply the promised chunk length.
+        throw new IOException("unexpected end of stream");
+      }
+      bytesRemainingInChunk -= read;
+      return read;
+    }
+
+    private void readChunkSize() throws IOException {
+      // Read the suffix of the previous chunk.
+      if (bytesRemainingInChunk != NO_CHUNK_YET) {
+        source.readUtf8LineStrict();
+      }
+      String chunkSizeString = source.readUtf8LineStrict();
+      int index = chunkSizeString.indexOf(";");
+      if (index != -1) {
+        chunkSizeString = chunkSizeString.substring(0, index);
+      }
+      try {
+        bytesRemainingInChunk = Integer.parseInt(chunkSizeString.trim(), 16);
+      } catch (NumberFormatException e) {
+        throw new ProtocolException("Expected a hex chunk size but was " + chunkSizeString);
+      }
+      if (bytesRemainingInChunk == 0) {
+        hasMoreChunks = false;
+        Headers.Builder trailersBuilder = new Headers.Builder();
+        readHeaders(trailersBuilder);
+        httpEngine.receiveHeaders(trailersBuilder.build());
+        endOfInput(true);
+      }
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+        unexpectedEndOfInput();
+      }
+      closed = true;
+    }
+  }
+
+  /** An HTTP message body terminated by the end of the underlying stream. */
+  private class UnknownLengthSource extends AbstractSource {
+    private boolean inputExhausted;
+
+    @Override public long read(Buffer sink, long byteCount)
+        throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+      if (closed) throw new IllegalStateException("closed");
+      if (inputExhausted) return -1;
+
+      long read = source.read(sink, byteCount);
+      if (read == -1) {
+        inputExhausted = true;
+        endOfInput(false);
+        return -1;
+      }
+      return read;
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      if (!inputExhausted) {
+        unexpectedEndOfInput();
+      }
+      closed = true;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
index 8275958293..27511b37ca 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
@@ -17,7 +17,7 @@
 package com.squareup.okhttp.internal.http;
 
 import java.text.DateFormat;
-import java.text.ParseException;
+import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
@@ -26,7 +26,9 @@
 /**
  * Best-effort parser for HTTP dates.
  */
-final class HttpDate {
+public final class HttpDate {
+
+  private static final TimeZone GMT = TimeZone.getTimeZone("GMT");
 
   /**
    * Most websites serve cookies in the blessed format. Eagerly create the parser to ensure such
@@ -35,43 +37,72 @@
   private static final ThreadLocal<DateFormat> STANDARD_DATE_FORMAT =
       new ThreadLocal<DateFormat>() {
         @Override protected DateFormat initialValue() {
-          DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-          rfc1123.setTimeZone(TimeZone.getTimeZone("UTC"));
+          // RFC 2616 specified: RFC 822, updated by RFC 1123 format with fixed GMT.
+          DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US);
+          rfc1123.setLenient(false);
+          rfc1123.setTimeZone(GMT);
           return rfc1123;
         }
       };
 
   /** If we fail to parse a date in a non-standard format, try each of these formats in sequence. */
   private static final String[] BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS = new String[] {
-      "EEEE, dd-MMM-yy HH:mm:ss zzz", // RFC 1036
-      "EEE MMM d HH:mm:ss yyyy", // ANSI C asctime()
-      "EEE, dd-MMM-yyyy HH:mm:ss z", "EEE, dd-MMM-yyyy HH-mm-ss z", "EEE, dd MMM yy HH:mm:ss z",
-      "EEE dd-MMM-yyyy HH:mm:ss z", "EEE dd MMM yyyy HH:mm:ss z", "EEE dd-MMM-yyyy HH-mm-ss z",
-      "EEE dd-MMM-yy HH:mm:ss z", "EEE dd MMM yy HH:mm:ss z", "EEE,dd-MMM-yy HH:mm:ss z",
-      "EEE,dd-MMM-yyyy HH:mm:ss z", "EEE, dd-MM-yyyy HH:mm:ss z",
+      // HTTP formats required by RFC2616 but with any timezone.
+      "EEE, dd MMM yyyy HH:mm:ss zzz", // RFC 822, updated by RFC 1123 with any TZ
+      "EEEE, dd-MMM-yy HH:mm:ss zzz", // RFC 850, obsoleted by RFC 1036 with any TZ.
+      "EEE MMM d HH:mm:ss yyyy", // ANSI C's asctime() format
+       // Alternative formats.
+      "EEE, dd-MMM-yyyy HH:mm:ss z",
+      "EEE, dd-MMM-yyyy HH-mm-ss z",
+      "EEE, dd MMM yy HH:mm:ss z",
+      "EEE dd-MMM-yyyy HH:mm:ss z",
+      "EEE dd MMM yyyy HH:mm:ss z",
+      "EEE dd-MMM-yyyy HH-mm-ss z",
+      "EEE dd-MMM-yy HH:mm:ss z",
+      "EEE dd MMM yy HH:mm:ss z",
+      "EEE,dd-MMM-yy HH:mm:ss z",
+      "EEE,dd-MMM-yyyy HH:mm:ss z",
+      "EEE, dd-MM-yyyy HH:mm:ss z",
 
-            /* RI bug 6641315 claims a cookie of this format was once served by www.yahoo.com */
-      "EEE MMM d yyyy HH:mm:ss z", };
+      /* RI bug 6641315 claims a cookie of this format was once served by www.yahoo.com */
+      "EEE MMM d yyyy HH:mm:ss z",
+  };
 
   private static final DateFormat[] BROWSER_COMPATIBLE_DATE_FORMATS =
       new DateFormat[BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.length];
 
   /** Returns the date for {@code value}. Returns null if the value couldn't be parsed. */
   public static Date parse(String value) {
-    try {
-      return STANDARD_DATE_FORMAT.get().parse(value);
-    } catch (ParseException ignored) {
+    if (value.length() == 0) {
+      return null;
+    }
+
+    ParsePosition position = new ParsePosition(0);
+    Date result = STANDARD_DATE_FORMAT.get().parse(value, position);
+    if (position.getIndex() == value.length()) {
+      // STANDARD_DATE_FORMAT must match exactly; all text must be consumed, e.g. no ignored
+      // non-standard trailing "+01:00". Those cases are covered below.
+      return result;
     }
     synchronized (BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS) {
       for (int i = 0, count = BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.length; i < count; i++) {
         DateFormat format = BROWSER_COMPATIBLE_DATE_FORMATS[i];
         if (format == null) {
           format = new SimpleDateFormat(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS[i], Locale.US);
+          // Set the timezone to use when interpreting formats that don't have a timezone. GMT is
+          // specified by RFC 2616.
+          format.setTimeZone(GMT);
           BROWSER_COMPATIBLE_DATE_FORMATS[i] = format;
         }
-        try {
-          return format.parse(value);
-        } catch (ParseException ignored) {
+        position.setIndex(0);
+        result = format.parse(value, position);
+        if (position.getIndex() != 0) {
+          // Something was parsed. It's possible the entire string was not consumed but we ignore
+          // that. If any of the BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS ended in "'GMT'" we'd have
+          // to also check that position.getIndex() == value.length() otherwise parsing might have
+          // terminated early, ignoring things like "+01:00". Leaving this as != 0 means that any
+          // trailing junk is ignored.
+          return result;
         }
       }
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 142def4665..d4d9b4cb1b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -19,38 +19,55 @@
 
 import com.squareup.okhttp.Address;
 import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Interceptor;
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.OkResponseCache;
-import com.squareup.okhttp.ResponseSource;
-import com.squareup.okhttp.TunnelRequest;
-import com.squareup.okhttp.internal.Dns;
-import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.Route;
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.InternalCache;
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayInputStream;
+import com.squareup.okhttp.internal.Version;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
+import java.io.InterruptedIOException;
 import java.net.CookieHandler;
-import java.net.HttpURLConnection;
+import java.net.ProtocolException;
 import java.net.Proxy;
-import java.net.URI;
-import java.net.URISyntaxException;
 import java.net.URL;
-import java.net.UnknownHostException;
-import java.util.Collections;
+import java.security.cert.CertificateException;
 import java.util.Date;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.zip.GZIPInputStream;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSocketFactory;
-
-import static com.squareup.okhttp.internal.Util.EMPTY_BYTE_ARRAY;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.GzipSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
+
+import static com.squareup.okhttp.internal.Util.closeQuietly;
 import static com.squareup.okhttp.internal.Util.getDefaultPort;
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
+import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
+import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
+import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 /**
  * Handles a single HTTP request/response pair. Each HTTP engine follows this
@@ -69,106 +86,118 @@
  *
  * <p>The request and response may be served by the HTTP response cache, by the
  * network, or by both in the event of a conditional GET.
- *
- * <p>This class may hold a socket connection that needs to be released or
- * recycled. By default, this socket connection is held when the last byte of
- * the response is consumed. To release the connection when it is no longer
- * required, use {@link #automaticallyReleaseConnectionToPool()}.
  */
-public class HttpEngine {
-  private static final CacheResponse GATEWAY_TIMEOUT_RESPONSE = new CacheResponse() {
-    @Override public Map<String, List<String>> getHeaders() throws IOException {
-      Map<String, List<String>> result = new HashMap<String, List<String>>();
-      result.put(null, Collections.singletonList("HTTP/1.1 504 Gateway Timeout"));
-      return result;
+public final class HttpEngine {
+  /**
+   * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,
+   * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
+   */
+  public static final int MAX_FOLLOW_UPS = 20;
+
+  private static final ResponseBody EMPTY_BODY = new ResponseBody() {
+    @Override public MediaType contentType() {
+      return null;
+    }
+    @Override public long contentLength() {
+      return 0;
     }
-    @Override public InputStream getBody() throws IOException {
-      return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);
+    @Override public BufferedSource source() {
+      return new Buffer();
     }
   };
-  public static final int HTTP_CONTINUE = 100;
-
-  protected final Policy policy;
-  protected final OkHttpClient client;
-
-  protected final String method;
 
-  private ResponseSource responseSource;
+  final OkHttpClient client;
 
-  protected Connection connection;
-  protected RouteSelector routeSelector;
-  private OutputStream requestBodyOut;
+  private Connection connection;
+  private RouteSelector routeSelector;
+  private Route route;
+  private final Response priorResponse;
 
   private Transport transport;
 
-  private InputStream responseTransferIn;
-  private InputStream responseBodyIn;
-
-  private CacheResponse cacheResponse;
-  private CacheRequest cacheRequest;
-
   /** The time when the request headers were written, or -1 if they haven't been written yet. */
   long sentRequestMillis = -1;
 
-  /** Whether the connection has been established. */
-  boolean connected;
-
   /**
    * True if this client added an "Accept-Encoding: gzip" header field and is
    * therefore responsible for also decompressing the transfer stream.
    */
   private boolean transparentGzip;
 
-  final URI uri;
+  /**
+   * True if the request body must be completely buffered before transmission;
+   * false if it can be streamed. Buffering has two advantages: we don't need
+   * the content-length in advance and we can retransmit if necessary. The
+   * upside of streaming is that we can save memory.
+   */
+  public final boolean bufferRequestBody;
 
-  final RequestHeaders requestHeaders;
+  /**
+   * The original application-provided request. Never modified by OkHttp. When
+   * follow-up requests are necessary, they are derived from this request.
+   */
+  private final Request userRequest;
 
-  /** Null until a response is received from the network or the cache. */
-  ResponseHeaders responseHeaders;
+  /**
+   * The request to send on the network, or null for no network request. This is
+   * derived from the user request, and customized to support OkHttp features
+   * like compression and caching.
+   */
+  private Request networkRequest;
 
-  // The cache response currently being validated on a conditional get. Null
-  // if the cached response doesn't exist or doesn't need validation. If the
-  // conditional get succeeds, these will be used for the response headers and
-  // body. If it fails, these be closed and set to null.
-  private ResponseHeaders cachedResponseHeaders;
-  private InputStream cachedResponseBody;
+  /**
+   * The cached response, or null if the cache doesn't exist or cannot be used
+   * for this request. Conditional caching means this may be non-null even when
+   * the network request is non-null. Never modified by OkHttp.
+   */
+  private Response cacheResponse;
 
   /**
-   * True if the socket connection should be released to the connection pool
-   * when the response has been fully read.
+   * The user-visible response. This is derived from either the network
+   * response, cache response, or both. It is customized to support OkHttp
+   * features like compression and caching.
    */
-  private boolean automaticallyReleaseConnectionToPool;
+  private Response userResponse;
 
-  /** True if the socket connection is no longer needed by this engine. */
-  private boolean connectionReleased;
+  private Sink requestBodyOut;
+  private BufferedSink bufferedRequestBody;
+  private final boolean callerWritesRequestBody;
+  private final boolean forWebSocket;
+
+  /** The cache request currently being populated from a network response. */
+  private CacheRequest storeRequest;
+  private CacheStrategy cacheStrategy;
 
   /**
-   * @param requestHeaders the client's supplied request headers. This class
-   *     creates a private copy that it can mutate.
-   * @param connection the connection used for an intermediate response
-   *     immediately prior to this request/response pair, such as a same-host
-   *     redirect. This engine assumes ownership of the connection and must
-   *     release it when it is unneeded.
+   * @param request the HTTP request without a body. The body must be written via the engine's
+   *     request body stream.
+   * @param callerWritesRequestBody true for the {@code HttpURLConnection}-style interaction
+   *     model where control flow is returned to the calling application to write the request body
+   *     before the response body is readable.
+   * @param connection the connection used for an intermediate response immediately prior to this
+   *     request/response pair, such as a same-host redirect. This engine assumes ownership of the
+   *     connection and must release it when it is unneeded.
+   * @param routeSelector the route selector used for a failed attempt immediately preceding this
    */
-  public HttpEngine(OkHttpClient client, Policy policy, String method, RawHeaders requestHeaders,
-      Connection connection, RetryableOutputStream requestBodyOut) throws IOException {
+  public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
+      boolean callerWritesRequestBody, boolean forWebSocket, Connection connection,
+      RouteSelector routeSelector, RetryableSink requestBodyOut, Response priorResponse) {
     this.client = client;
-    this.policy = policy;
-    this.method = method;
+    this.userRequest = request;
+    this.bufferRequestBody = bufferRequestBody;
+    this.callerWritesRequestBody = callerWritesRequestBody;
+    this.forWebSocket = forWebSocket;
     this.connection = connection;
+    this.routeSelector = routeSelector;
     this.requestBodyOut = requestBodyOut;
+    this.priorResponse = priorResponse;
 
-    try {
-      uri = Platform.get().toUriLenient(policy.getURL());
-    } catch (URISyntaxException e) {
-      throw new IOException(e.getMessage());
+    if (connection != null) {
+      Internal.instance.setOwner(connection, this);
+      this.route = connection.getRoute();
+    } else {
+      this.route = null;
     }
-
-    this.requestHeaders = new RequestHeaders(uri, new RawHeaders(requestHeaders));
-  }
-
-  public URI getUri() {
-    return uri;
   }
 
   /**
@@ -176,141 +205,112 @@ public URI getUri() {
    * source if necessary. Prepares the request headers and gets ready to start
    * writing the request body if it exists.
    */
-  public final void sendRequest() throws IOException {
-    if (responseSource != null) {
-      return;
-    }
+  public void sendRequest() throws IOException {
+    if (cacheStrategy != null) return; // Already sent.
+    if (transport != null) throw new IllegalStateException();
 
-    prepareRawRequestHeaders();
-    initResponseSource();
-    OkResponseCache responseCache = client.getOkResponseCache();
-    if (responseCache != null) {
-      responseCache.trackResponse(responseSource);
-    }
+    Request request = networkRequest(userRequest);
 
-    // The raw response source may require the network, but the request
-    // headers may forbid network use. In that case, dispose of the network
-    // response and use a GATEWAY_TIMEOUT response instead, as specified
-    // by http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.4.
-    if (requestHeaders.isOnlyIfCached() && responseSource.requiresConnection()) {
-      if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-        Util.closeQuietly(cachedResponseBody);
-      }
-      this.responseSource = ResponseSource.CACHE;
-      this.cacheResponse = GATEWAY_TIMEOUT_RESPONSE;
-      RawHeaders rawResponseHeaders = RawHeaders.fromMultimap(cacheResponse.getHeaders(), true);
-      setResponse(new ResponseHeaders(uri, rawResponseHeaders), cacheResponse.getBody());
-    }
+    InternalCache responseCache = Internal.instance.internalCache(client);
+    Response cacheCandidate = responseCache != null
+        ? responseCache.get(request)
+        : null;
 
-    if (responseSource.requiresConnection()) {
-      sendSocketRequest();
-    } else if (connection != null) {
-      client.getConnectionPool().recycle(connection);
-      connection = null;
-    }
-  }
+    long now = System.currentTimeMillis();
+    cacheStrategy = new CacheStrategy.Factory(now, request, cacheCandidate).get();
+    networkRequest = cacheStrategy.networkRequest;
+    cacheResponse = cacheStrategy.cacheResponse;
 
-  /**
-   * Initialize the source for this response. It may be corrected later if the
-   * request headers forbids network use.
-   */
-  private void initResponseSource() throws IOException {
-    responseSource = ResponseSource.NETWORK;
-    if (!policy.getUseCaches()) return;
+    if (responseCache != null) {
+      responseCache.trackResponse(cacheStrategy);
+    }
 
-    OkResponseCache responseCache = client.getOkResponseCache();
-    if (responseCache == null) return;
+    if (cacheCandidate != null && cacheResponse == null) {
+      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
+    }
 
-    CacheResponse candidate = responseCache.get(
-        uri, method, requestHeaders.getHeaders().toMultimap(false));
-    if (candidate == null) return;
+    if (networkRequest != null) {
+      // Open a connection unless we inherited one from a redirect.
+      if (connection == null) {
+        connect(networkRequest);
+      }
 
-    Map<String, List<String>> responseHeadersMap = candidate.getHeaders();
-    cachedResponseBody = candidate.getBody();
-    if (!acceptCacheResponseType(candidate)
-        || responseHeadersMap == null
-        || cachedResponseBody == null) {
-      Util.closeQuietly(cachedResponseBody);
-      return;
-    }
+      transport = Internal.instance.newTransport(connection, this);
+
+      // If the caller's control flow writes the request body, we need to create that stream
+      // immediately. And that means we need to immediately write the request headers, so we can
+      // start streaming the request body. (We may already have a request body if we're retrying a
+      // failed POST.)
+      if (callerWritesRequestBody && permitsRequestBody() && requestBodyOut == null) {
+        long contentLength = OkHeaders.contentLength(request);
+        if (bufferRequestBody) {
+          if (contentLength > Integer.MAX_VALUE) {
+            throw new IllegalStateException("Use setFixedLengthStreamingMode() or "
+                + "setChunkedStreamingMode() for requests larger than 2 GiB.");
+          }
+
+          if (contentLength != -1) {
+            // Buffer a request body of a known length.
+            transport.writeRequestHeaders(networkRequest);
+            requestBodyOut = new RetryableSink((int) contentLength);
+          } else {
+            // Buffer a request body of an unknown length. Don't write request
+            // headers until the entire body is ready; otherwise we can't set the
+            // Content-Length header correctly.
+            requestBodyOut = new RetryableSink();
+          }
+        } else {
+          transport.writeRequestHeaders(networkRequest);
+          requestBodyOut = transport.createRequestBody(networkRequest, contentLength);
+        }
+      }
 
-    RawHeaders rawResponseHeaders = RawHeaders.fromMultimap(responseHeadersMap, true);
-    cachedResponseHeaders = new ResponseHeaders(uri, rawResponseHeaders);
-    long now = System.currentTimeMillis();
-    this.responseSource = cachedResponseHeaders.chooseResponseSource(now, requestHeaders);
-    if (responseSource == ResponseSource.CACHE) {
-      this.cacheResponse = candidate;
-      setResponse(cachedResponseHeaders, cachedResponseBody);
-    } else if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-      this.cacheResponse = candidate;
-    } else if (responseSource == ResponseSource.NETWORK) {
-      Util.closeQuietly(cachedResponseBody);
     } else {
-      throw new AssertionError();
-    }
-  }
+      // We aren't using the network. Recycle a connection we may have inherited from a redirect.
+      if (connection != null) {
+        Internal.instance.recycle(client.getConnectionPool(), connection);
+        connection = null;
+      }
 
-  private void sendSocketRequest() throws IOException {
-    if (connection == null) {
-      connect();
-    }
+      if (cacheResponse != null) {
+        // We have a valid cached response. Promote it to the user response immediately.
+        this.userResponse = cacheResponse.newBuilder()
+            .request(userRequest)
+            .priorResponse(stripBody(priorResponse))
+            .cacheResponse(stripBody(cacheResponse))
+            .build();
+      } else {
+        // We're forbidden from using the network, and the cache is insufficient.
+        this.userResponse = new Response.Builder()
+            .request(userRequest)
+            .priorResponse(stripBody(priorResponse))
+            .protocol(Protocol.HTTP_1_1)
+            .code(504)
+            .message("Unsatisfiable Request (only-if-cached)")
+            .body(EMPTY_BODY)
+            .build();
+      }
 
-    if (transport != null) {
-      throw new IllegalStateException();
+      userResponse = unzip(userResponse);
     }
+  }
 
-    transport = (Transport) connection.newTransport(this);
-
-    if (hasRequestBody() && requestBodyOut == null) {
-      // Create a request body if we don't have one already. We'll already
-      // have one if we're retrying a failed POST.
-      requestBodyOut = transport.createRequestBody();
-    }
+  private static Response stripBody(Response response) {
+    return response != null && response.body() != null
+        ? response.newBuilder().body(null).build()
+        : response;
   }
 
   /** Connect to the origin server either directly or via a proxy. */
-  protected final void connect() throws IOException {
-    if (connection != null) {
-      return;
-    }
+  private void connect(Request request) throws IOException {
+    if (connection != null) throw new IllegalStateException();
+
     if (routeSelector == null) {
-      String uriHost = uri.getHost();
-      if (uriHost == null) {
-        throw new UnknownHostException(uri.toString());
-      }
-      SSLSocketFactory sslSocketFactory = null;
-      HostnameVerifier hostnameVerifier = null;
-      if (uri.getScheme().equalsIgnoreCase("https")) {
-        sslSocketFactory = client.getSslSocketFactory();
-        hostnameVerifier = client.getHostnameVerifier();
-      }
-      Address address = new Address(uriHost, getEffectivePort(uri), sslSocketFactory,
-          hostnameVerifier, client.getAuthenticator(), client.getProxy(), client.getTransports());
-      routeSelector = new RouteSelector(address, uri, client.getProxySelector(),
-          client.getConnectionPool(), Dns.DEFAULT, client.getRoutesDatabase());
-    }
-    connection = routeSelector.next(method);
-    if (!connection.isConnected()) {
-      connection.connect(client.getConnectTimeout(), client.getReadTimeout(), getTunnelConfig());
-      client.getConnectionPool().maybeShare(connection);
-      client.getRoutesDatabase().connected(connection.getRoute());
-    } else {
-      connection.updateReadTimeout(client.getReadTimeout());
-    }
-    connected(connection);
-    if (connection.getRoute().getProxy() != client.getProxy()) {
-      // Update the request line if the proxy changed; it may need a host name.
-      requestHeaders.getHeaders().setRequestLine(getRequestLine());
+      routeSelector = RouteSelector.get(request, client);
     }
-  }
 
-  /**
-   * Called after a socket connection has been created or retrieved from the
-   * pool. Subclasses use this hook to get a reference to the TLS data.
-   */
-  protected void connected(Connection connection) {
-    policy.setSelectedProxy(connection.getRoute().getProxy());
-    connected = true;
+    connection = routeSelector.next(this);
+    route = connection.getRoute();
   }
 
   /**
@@ -318,181 +318,253 @@ protected void connected(Connection connection) {
    * This is used to observe the sent time should the request be cached.
    */
   public void writingRequestHeaders() {
-    if (sentRequestMillis != -1) {
-      throw new IllegalStateException();
-    }
+    if (sentRequestMillis != -1) throw new IllegalStateException();
     sentRequestMillis = System.currentTimeMillis();
   }
 
-  /**
-   * @param body the response body, or null if it doesn't exist or isn't
-   * available.
-   */
-  private void setResponse(ResponseHeaders headers, InputStream body) throws IOException {
-    if (this.responseBodyIn != null) {
-      throw new IllegalStateException();
-    }
-    this.responseHeaders = headers;
-    if (body != null) {
-      initContentStream(body);
-    }
-  }
-
-  boolean hasRequestBody() {
-    return method.equals("POST") || method.equals("PUT");
+  boolean permitsRequestBody() {
+    return HttpMethod.permitsRequestBody(userRequest.method());
   }
 
   /** Returns the request body or null if this request doesn't have a body. */
-  public final OutputStream getRequestBody() {
-    if (responseSource == null) {
-      throw new IllegalStateException();
-    }
+  public Sink getRequestBody() {
+    if (cacheStrategy == null) throw new IllegalStateException();
     return requestBodyOut;
   }
 
-  public final boolean hasResponse() {
-    return responseHeaders != null;
+  public BufferedSink getBufferedRequestBody() {
+    BufferedSink result = bufferedRequestBody;
+    if (result != null) return result;
+    Sink requestBody = getRequestBody();
+    return requestBody != null
+        ? (bufferedRequestBody = Okio.buffer(requestBody))
+        : null;
   }
 
-  public final RequestHeaders getRequestHeaders() {
-    return requestHeaders;
+  public boolean hasResponse() {
+    return userResponse != null;
   }
 
-  public final ResponseHeaders getResponseHeaders() {
-    if (responseHeaders == null) {
-      throw new IllegalStateException();
-    }
-    return responseHeaders;
+  public Request getRequest() {
+    return userRequest;
   }
 
-  public final int getResponseCode() {
-    if (responseHeaders == null) {
-      throw new IllegalStateException();
-    }
-    return responseHeaders.getHeaders().getResponseCode();
+  /** Returns the engine's response. */
+  // TODO: the returned body will always be null.
+  public Response getResponse() {
+    if (userResponse == null) throw new IllegalStateException();
+    return userResponse;
+  }
+
+  public Connection getConnection() {
+    return connection;
   }
 
-  public final InputStream getResponseBody() {
-    if (responseHeaders == null) {
-      throw new IllegalStateException();
+  /**
+   * Report and attempt to recover from {@code e}. Returns a new HTTP engine
+   * that should be used for the retry if {@code e} is recoverable, or null if
+   * the failure is permanent. Requests with a body can only be recovered if the
+   * body is buffered.
+   */
+  public HttpEngine recover(IOException e, Sink requestBodyOut) {
+    if (routeSelector != null && connection != null) {
+      routeSelector.connectFailed(connection, e);
+    }
+
+    boolean canRetryRequestBody = requestBodyOut == null || requestBodyOut instanceof RetryableSink;
+    if (routeSelector == null && connection == null // No connection.
+        || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
+        || !isRecoverable(e)
+        || !canRetryRequestBody) {
+      return null;
     }
-    return responseBodyIn;
+
+    Connection connection = close();
+
+    // For failure recovery, use the same route selector with a new connection.
+    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
+        forWebSocket, connection, routeSelector, (RetryableSink) requestBodyOut, priorResponse);
   }
 
-  public final CacheResponse getCacheResponse() {
-    return cacheResponse;
+  public HttpEngine recover(IOException e) {
+    return recover(e, requestBodyOut);
   }
 
-  public final Connection getConnection() {
-    return connection;
+  private boolean isRecoverable(IOException e) {
+    // If the application has opted-out of recovery, don't recover.
+    if (!client.getRetryOnConnectionFailure()) {
+      return false;
+    }
+
+    // If the problem was a CertificateException from the X509TrustManager,
+    // do not retry, we didn't have an abrupt server-initiated exception.
+    if (e instanceof SSLPeerUnverifiedException
+        || (e instanceof SSLHandshakeException && e.getCause() instanceof CertificateException)) {
+      return false;
+    }
+
+    // If there was a protocol problem, don't recover.
+    if (e instanceof ProtocolException) {
+      return false;
+    }
+
+    // If there was an interruption or timeout, don't recover.
+    if (e instanceof InterruptedIOException) {
+      return false;
+    }
+
+    return true;
   }
 
   /**
-   * Returns true if {@code cacheResponse} is of the right type. This
-   * condition is necessary but not sufficient for the cached response to
-   * be used.
+   * Returns the route used to retrieve the response. Null if we haven't
+   * connected yet, or if no connection was necessary.
    */
-  protected boolean acceptCacheResponseType(CacheResponse cacheResponse) {
-    return true;
+  public Route getRoute() {
+    return route;
   }
 
   private void maybeCache() throws IOException {
-    // Are we caching at all?
-    if (!policy.getUseCaches()) return;
-    OkResponseCache responseCache = client.getOkResponseCache();
+    InternalCache responseCache = Internal.instance.internalCache(client);
     if (responseCache == null) return;
 
-    HttpURLConnection connectionToCache = policy.getHttpConnectionToCache();
-
     // Should we cache this response for this request?
-    if (!responseHeaders.isCacheable(requestHeaders)) {
-      responseCache.maybeRemove(connectionToCache.getRequestMethod(), uri);
+    if (!CacheStrategy.isCacheable(userResponse, networkRequest)) {
+      if (HttpMethod.invalidatesCache(networkRequest.method())) {
+        try {
+          responseCache.remove(networkRequest);
+        } catch (IOException ignored) {
+          // The cache cannot be written.
+        }
+      }
       return;
     }
 
     // Offer this request to the cache.
-    cacheRequest = responseCache.put(uri, connectionToCache);
+    storeRequest = responseCache.put(stripBody(userResponse));
   }
 
   /**
-   * Cause the socket connection to be released to the connection pool when
-   * it is no longer needed. If it is already unneeded, it will be pooled
-   * immediately. Otherwise the connection is held so that redirects can be
-   * handled by the same connection.
+   * Configure the socket connection to be either pooled or closed when it is
+   * either exhausted or closed. If it is unneeded when this is called, it will
+   * be released immediately.
    */
-  public final void automaticallyReleaseConnectionToPool() {
-    automaticallyReleaseConnectionToPool = true;
-    if (connection != null && connectionReleased) {
-      client.getConnectionPool().recycle(connection);
-      connection = null;
+  public void releaseConnection() throws IOException {
+    if (transport != null && connection != null) {
+      transport.releaseConnectionOnIdle();
     }
+    connection = null;
   }
 
   /**
-   * Releases this engine so that its resources may be either reused or
-   * closed. Also call {@link #automaticallyReleaseConnectionToPool} unless
-   * the connection will be used to follow a redirect.
+   * Immediately closes the socket connection if it's currently held by this
+   * engine. Use this to interrupt an in-flight request from any thread. It's
+   * the caller's responsibility to close the request body and response body
+   * streams; otherwise resources may be leaked.
    */
-  public final void release(boolean streamCanceled) {
-    // If the response body comes from the cache, close it.
-    if (responseBodyIn == cachedResponseBody) {
-      Util.closeQuietly(responseBodyIn);
+  public void disconnect() {
+    if (transport != null) {
+      try {
+        transport.disconnect(this);
+      } catch (IOException ignored) {
+      }
     }
+  }
 
-    if (!connectionReleased && connection != null) {
-      connectionReleased = true;
+  /**
+   * Release any resources held by this engine. If a connection is still held by
+   * this engine, it is returned.
+   */
+  public Connection close() {
+    if (bufferedRequestBody != null) {
+      // This also closes the wrapped requestBodyOut.
+      closeQuietly(bufferedRequestBody);
+    } else if (requestBodyOut != null) {
+      closeQuietly(requestBodyOut);
+    }
 
-      if (transport == null
-          || !transport.makeReusable(streamCanceled, requestBodyOut, responseTransferIn)) {
-        Util.closeQuietly(connection);
-        connection = null;
-      } else if (automaticallyReleaseConnectionToPool) {
-        client.getConnectionPool().recycle(connection);
-        connection = null;
-      }
+    // If this engine never achieved a response body, its connection cannot be reused.
+    if (userResponse == null) {
+      if (connection != null) closeQuietly(connection.getSocket()); // TODO: does this break SPDY?
+      connection = null;
+      return null;
     }
+
+    // Close the response body. This will recycle the connection if it is eligible.
+    closeQuietly(userResponse.body());
+
+    // Close the connection if it cannot be reused.
+    if (transport != null && connection != null && !transport.canReuseConnection()) {
+      closeQuietly(connection.getSocket());
+      connection = null;
+      return null;
+    }
+
+    // Prevent this engine from disconnecting a connection it no longer owns.
+    if (connection != null && !Internal.instance.clearOwner(connection)) {
+      connection = null;
+    }
+
+    Connection result = connection;
+    connection = null;
+    return result;
   }
 
-  private void initContentStream(InputStream transferStream) throws IOException {
-    responseTransferIn = transferStream;
-    if (transparentGzip && responseHeaders.isContentEncodingGzip()) {
-      // If the response was transparently gzipped, remove the gzip header field
-      // so clients don't double decompress. http://b/3009828
-      //
-      // Also remove the Content-Length in this case because it contains the
-      // length 528 of the gzipped response. This isn't terribly useful and is
-      // dangerous because 529 clients can query the content length, but not
-      // the content encoding.
-      responseHeaders.stripContentEncoding();
-      responseHeaders.stripContentLength();
-      responseBodyIn = new GZIPInputStream(transferStream);
-    } else {
-      responseBodyIn = transferStream;
+  /**
+   * Returns a new response that does gzip decompression on {@code response}, if transparent gzip
+   * was both offered by OkHttp and used by the origin server.
+   *
+   * <p>In addition to decompression, this will also strip the corresponding headers. We strip the
+   * Content-Encoding header to prevent the application from attempting to double decompress. We
+   * strip the Content-Length header because it is the length of the compressed content, but the
+   * application is only interested in the length of the uncompressed content.
+   *
+   * <p>This method should only be used for non-empty response bodies. Response codes like "304 Not
+   * Modified" can include "Content-Encoding: gzip" without a response body and we will crash if we
+   * attempt to decompress the zero-byte source.
+   */
+  private Response unzip(final Response response) throws IOException {
+    if (!transparentGzip || !"gzip".equalsIgnoreCase(userResponse.header("Content-Encoding"))) {
+      return response;
     }
+
+    if (response.body() == null) {
+      return response;
+    }
+
+    GzipSource responseBody = new GzipSource(response.body().source());
+    Headers strippedHeaders = response.headers().newBuilder()
+        .removeAll("Content-Encoding")
+        .removeAll("Content-Length")
+        .build();
+    return response.newBuilder()
+        .headers(strippedHeaders)
+        .body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)))
+        .build();
   }
 
   /**
    * Returns true if the response must have a (possibly 0-length) body.
    * See RFC 2616 section 4.3.
    */
-  public final boolean hasResponseBody() {
-    int responseCode = responseHeaders.getHeaders().getResponseCode();
-
+  public static boolean hasBody(Response response) {
     // HEAD requests never yield a body regardless of the response headers.
-    if (method.equals("HEAD")) {
+    if (response.request().method().equals("HEAD")) {
       return false;
     }
 
+    int responseCode = response.code();
     if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
-        && responseCode != HttpURLConnectionImpl.HTTP_NO_CONTENT
-        && responseCode != HttpURLConnectionImpl.HTTP_NOT_MODIFIED) {
+        && responseCode != HTTP_NO_CONTENT
+        && responseCode != HTTP_NOT_MODIFIED) {
       return true;
     }
 
     // If the Content-Length or Transfer-Encoding headers disagree with the
     // response code, the response is malformed. For best compatibility, we
     // honor the headers.
-    if (responseHeaders.getContentLength() != -1 || responseHeaders.isChunked()) {
+    if (OkHeaders.contentLength(response) != -1
+        || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
       return true;
     }
 
@@ -500,180 +572,441 @@ public final boolean hasResponseBody() {
   }
 
   /**
-   * Populates requestHeaders with defaults and cookies.
+   * Populates request with defaults and cookies.
    *
    * <p>This client doesn't specify a default {@code Accept} header because it
    * doesn't know what content types the application is interested in.
    */
-  private void prepareRawRequestHeaders() throws IOException {
-    requestHeaders.getHeaders().setRequestLine(getRequestLine());
-
-    if (requestHeaders.getUserAgent() == null) {
-      requestHeaders.setUserAgent(getDefaultUserAgent());
-    }
+  private Request networkRequest(Request request) throws IOException {
+    Request.Builder result = request.newBuilder();
 
-    if (requestHeaders.getHost() == null) {
-      requestHeaders.setHost(getOriginAddress(policy.getURL()));
+    if (request.header("Host") == null) {
+      result.header("Host", hostHeader(request.url()));
     }
 
-    if ((connection == null || connection.getHttpMinorVersion() != 0)
-        && requestHeaders.getConnection() == null) {
-      requestHeaders.setConnection("Keep-Alive");
+    if ((connection == null || connection.getProtocol() != Protocol.HTTP_1_0)
+        && request.header("Connection") == null) {
+      result.header("Connection", "Keep-Alive");
     }
 
-    if (requestHeaders.getAcceptEncoding() == null) {
+    if (request.header("Accept-Encoding") == null) {
       transparentGzip = true;
-      requestHeaders.setAcceptEncoding("gzip");
+      result.header("Accept-Encoding", "gzip");
     }
 
-    if (hasRequestBody() && requestHeaders.getContentType() == null) {
-      requestHeaders.setContentType("application/x-www-form-urlencoded");
-    }
+    CookieHandler cookieHandler = client.getCookieHandler();
+    if (cookieHandler != null) {
+      // Capture the request headers added so far so that they can be offered to the CookieHandler.
+      // This is mostly to stay close to the RI; it is unlikely any of the headers above would
+      // affect cookie choice besides "Host".
+      Map<String, List<String>> headers = OkHeaders.toMultimap(result.build().headers(), null);
+
+      Map<String, List<String>> cookies = cookieHandler.get(request.uri(), headers);
 
-    long ifModifiedSince = policy.getIfModifiedSince();
-    if (ifModifiedSince != 0) {
-      requestHeaders.setIfModifiedSince(new Date(ifModifiedSince));
+      // Add any new cookies to the request.
+      OkHeaders.addCookies(result, cookies);
     }
 
-    CookieHandler cookieHandler = client.getCookieHandler();
-    if (cookieHandler != null) {
-      requestHeaders.addCookies(
-          cookieHandler.get(uri, requestHeaders.getHeaders().toMultimap(false)));
+    if (request.header("User-Agent") == null) {
+      result.header("User-Agent", Version.userAgent());
     }
-  }
 
-  /**
-   * Returns the request status line, like "GET / HTTP/1.1". This is exposed
-   * to the application by {@link HttpURLConnectionImpl#getHeaderFields}, so
-   * it needs to be set even if the transport is SPDY.
-   */
-  String getRequestLine() {
-    String protocol =
-        (connection == null || connection.getHttpMinorVersion() != 0) ? "HTTP/1.1" : "HTTP/1.0";
-    return method + " " + requestString() + " " + protocol;
+    return result.build();
   }
 
-  private String requestString() {
-    URL url = policy.getURL();
-    if (includeAuthorityInRequestLine()) {
-      return url.toString();
-    } else {
-      return requestPath(url);
-    }
+  public static String hostHeader(URL url) {
+    return getEffectivePort(url) != getDefaultPort(url.getProtocol())
+        ? url.getHost() + ":" + url.getPort()
+        : url.getHost();
   }
 
   /**
-   * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never
-   * empty, even if the request URL is. Includes the query component if it
-   * exists.
+   * Flushes the remaining request header and body, parses the HTTP response
+   * headers and starts reading the HTTP response body if it exists.
    */
-  public static String requestPath(URL url) {
-    String fileOnly = url.getFile();
-    if (fileOnly == null) {
-      return "/";
-    } else if (!fileOnly.startsWith("/")) {
-      return "/" + fileOnly;
+  public void readResponse() throws IOException {
+    if (userResponse != null) {
+      return; // Already ready.
+    }
+    if (networkRequest == null && cacheResponse == null) {
+      throw new IllegalStateException("call sendRequest() first!");
+    }
+    if (networkRequest == null) {
+      return; // No network response to read.
+    }
+
+    Response networkResponse;
+
+    if (forWebSocket) {
+      transport.writeRequestHeaders(networkRequest);
+      networkResponse = readNetworkResponse();
+
+    } else if (!callerWritesRequestBody) {
+      networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);
+
     } else {
-      return fileOnly;
+      // Emit the request body's buffer so that everything is in requestBodyOut.
+      if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
+        bufferedRequestBody.emit();
+      }
+
+      // Emit the request headers if we haven't yet. We might have just learned the Content-Length.
+      if (sentRequestMillis == -1) {
+        if (OkHeaders.contentLength(networkRequest) == -1
+            && requestBodyOut instanceof RetryableSink) {
+          long contentLength = ((RetryableSink) requestBodyOut).contentLength();
+          networkRequest = networkRequest.newBuilder()
+              .header("Content-Length", Long.toString(contentLength))
+              .build();
+        }
+        transport.writeRequestHeaders(networkRequest);
+      }
+
+      // Write the request body to the socket.
+      if (requestBodyOut != null) {
+        if (bufferedRequestBody != null) {
+          // This also closes the wrapped requestBodyOut.
+          bufferedRequestBody.close();
+        } else {
+          requestBodyOut.close();
+        }
+        if (requestBodyOut instanceof RetryableSink) {
+          transport.writeRequestBody((RetryableSink) requestBodyOut);
+        }
+      }
+
+      networkResponse = readNetworkResponse();
     }
-  }
 
-  /**
-   * Returns true if the request line should contain the full URL with host
-   * and port (like "GET http://android.com/foo HTTP/1.1") or only the path
-   * (like "GET /foo HTTP/1.1").
-   *
-   * <p>This is non-final because for HTTPS it's never necessary to supply the
-   * full URL, even if a proxy is in use.
-   */
-  protected boolean includeAuthorityInRequestLine() {
-    return connection == null
-        ? policy.usingProxy() // A proxy was requested.
-        : connection.getRoute().getProxy().type() == Proxy.Type.HTTP; // A proxy was selected.
-  }
+    receiveHeaders(networkResponse.headers());
 
-  public static String getDefaultUserAgent() {
-    String agent = System.getProperty("http.agent");
-    return agent != null ? agent : ("Java" + System.getProperty("java.version"));
-  }
+    // If we have a cache response too, then we're doing a conditional get.
+    if (cacheResponse != null) {
+      if (validate(cacheResponse, networkResponse)) {
+        userResponse = cacheResponse.newBuilder()
+            .request(userRequest)
+            .priorResponse(stripBody(priorResponse))
+            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
+            .cacheResponse(stripBody(cacheResponse))
+            .networkResponse(stripBody(networkResponse))
+            .build();
+        networkResponse.body().close();
+        releaseConnection();
+
+        // Update the cache after combining headers but before stripping the
+        // Content-Encoding header (as performed by initContentStream()).
+        InternalCache responseCache = Internal.instance.internalCache(client);
+        responseCache.trackConditionalCacheHit();
+        responseCache.update(cacheResponse, stripBody(userResponse));
+        userResponse = unzip(userResponse);
+        return;
+      } else {
+        closeQuietly(cacheResponse.body());
+      }
+    }
+
+    userResponse = networkResponse.newBuilder()
+        .request(userRequest)
+        .priorResponse(stripBody(priorResponse))
+        .cacheResponse(stripBody(cacheResponse))
+        .networkResponse(stripBody(networkResponse))
+        .build();
 
-  public static String getOriginAddress(URL url) {
-    int port = url.getPort();
-    String result = url.getHost();
-    if (port > 0 && port != getDefaultPort(url.getProtocol())) {
-      result = result + ":" + port;
+    if (hasBody(userResponse)) {
+      maybeCache();
+      userResponse = unzip(cacheWritingResponse(storeRequest, userResponse));
     }
-    return result;
   }
 
-  /**
-   * Flushes the remaining request header and body, parses the HTTP response
-   * headers and starts reading the HTTP response body if it exists.
-   */
-  public final void readResponse() throws IOException {
-    if (hasResponse()) {
-      responseHeaders.setResponseSource(responseSource);
-      return;
+  class NetworkInterceptorChain implements Interceptor.Chain {
+    private final int index;
+    private final Request request;
+    private int calls;
+
+    NetworkInterceptorChain(int index, Request request) {
+      this.index = index;
+      this.request = request;
     }
 
-    if (responseSource == null) {
-      throw new IllegalStateException("readResponse() without sendRequest()");
+    @Override public Connection connection() {
+      return connection;
     }
 
-    if (!responseSource.requiresConnection()) {
-      return;
+    @Override public Request request() {
+      return request;
     }
 
-    if (sentRequestMillis == -1) {
-      if (requestBodyOut instanceof RetryableOutputStream) {
-        int contentLength = ((RetryableOutputStream) requestBodyOut).contentLength();
-        requestHeaders.setContentLength(contentLength);
+    @Override public Response proceed(Request request) throws IOException {
+      calls++;
+
+      if (index > 0) {
+        Interceptor caller = client.networkInterceptors().get(index - 1);
+        Address address = connection().getRoute().getAddress();
+
+        // Confirm that the interceptor uses the connection we've already prepared.
+        if (!request.url().getHost().equals(address.getUriHost())
+            || getEffectivePort(request.url()) != address.getUriPort()) {
+          throw new IllegalStateException("network interceptor " + caller
+              + " must retain the same host and port");
+        }
+
+        // Confirm that this is the interceptor's first call to chain.proceed().
+        if (calls > 1) {
+          throw new IllegalStateException("network interceptor " + caller
+              + " must call proceed() exactly once");
+        }
       }
-      transport.writeRequestHeaders();
-    }
 
-    if (requestBodyOut != null) {
-      requestBodyOut.close();
-      if (requestBodyOut instanceof RetryableOutputStream) {
-        transport.writeRequestBody((RetryableOutputStream) requestBodyOut);
+      if (index < client.networkInterceptors().size()) {
+        // There's another interceptor in the chain. Call that.
+        NetworkInterceptorChain chain = new NetworkInterceptorChain(index + 1, request);
+        Interceptor interceptor = client.networkInterceptors().get(index);
+        Response interceptedResponse = interceptor.intercept(chain);
+
+        // Confirm that the interceptor made the required call to chain.proceed().
+        if (chain.calls != 1) {
+          throw new IllegalStateException("network interceptor " + interceptor
+              + " must call proceed() exactly once");
+        }
+
+        return interceptedResponse;
       }
+
+      transport.writeRequestHeaders(request);
+
+      if (permitsRequestBody() && request.body() != null) {
+        Sink requestBodyOut = transport.createRequestBody(request, request.body().contentLength());
+        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+        request.body().writeTo(bufferedRequestBody);
+        bufferedRequestBody.close();
+      }
+
+      return readNetworkResponse();
     }
+  }
 
-    transport.flushRequest();
+  private Response readNetworkResponse() throws IOException {
+    transport.finishRequest();
 
-    responseHeaders = transport.readResponseHeaders();
-    responseHeaders.setLocalTimestamps(sentRequestMillis, System.currentTimeMillis());
-    responseHeaders.setResponseSource(responseSource);
+    Response networkResponse = transport.readResponseHeaders()
+        .request(networkRequest)
+        .handshake(connection.getHandshake())
+        .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
+        .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
+        .build();
 
-    if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-      if (cachedResponseHeaders.validate(responseHeaders)) {
-        release(false);
-        ResponseHeaders combinedHeaders = cachedResponseHeaders.combine(responseHeaders);
-        setResponse(combinedHeaders, cachedResponseBody);
-        OkResponseCache responseCache = client.getOkResponseCache();
-        responseCache.trackConditionalCacheHit();
-        responseCache.update(cacheResponse, policy.getHttpConnectionToCache());
-        return;
-      } else {
-        Util.closeQuietly(cachedResponseBody);
+    if (!forWebSocket) {
+      networkResponse = networkResponse.newBuilder()
+          .body(transport.openResponseBody(networkResponse))
+          .build();
+    }
+
+    Internal.instance.setProtocol(connection, networkResponse.protocol());
+    return networkResponse;
+  }
+
+  /**
+   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
+   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
+   * may never exhaust the source stream and therefore not complete the cached response.
+   */
+  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
+      throws IOException {
+    // Some apps return a null body; for compatibility we treat that like a null cache request.
+    if (cacheRequest == null) return response;
+    Sink cacheBodyUnbuffered = cacheRequest.body();
+    if (cacheBodyUnbuffered == null) return response;
+
+    final BufferedSource source = response.body().source();
+    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);
+
+    Source cacheWritingSource = new Source() {
+      boolean cacheRequestClosed;
+
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        long bytesRead;
+        try {
+          bytesRead = source.read(sink, byteCount);
+        } catch (IOException e) {
+          if (!cacheRequestClosed) {
+            cacheRequestClosed = true;
+            cacheRequest.abort(); // Failed to write a complete cache response.
+          }
+          throw e;
+        }
+
+        if (bytesRead == -1) {
+          if (!cacheRequestClosed) {
+            cacheRequestClosed = true;
+            cacheBody.close(); // The cache response is complete!
+          }
+          return -1;
+        }
+
+        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
+        cacheBody.emitCompleteSegments();
+        return bytesRead;
+      }
+
+      @Override public Timeout timeout() {
+        return source.timeout();
       }
+
+      @Override public void close() throws IOException {
+        if (!cacheRequestClosed
+            && !Util.discard(this, Transport.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+          cacheRequestClosed = true;
+          cacheRequest.abort();
+        }
+        source.close();
+      }
+    };
+
+    return response.newBuilder()
+        .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
+        .build();
+  }
+
+  /**
+   * Returns true if {@code cached} should be used; false if {@code network}
+   * response should be used.
+   */
+  private static boolean validate(Response cached, Response network) {
+    if (network.code() == HTTP_NOT_MODIFIED) {
+      return true;
     }
 
-    if (hasResponseBody()) {
-      maybeCache(); // reentrant. this calls into user code which may call back into this!
+    // The HTTP spec says that if the network's response is older than our
+    // cached response, we may return the cache's response. Like Chrome (but
+    // unlike Firefox), this client prefers to return the newer response.
+    Date lastModified = cached.headers().getDate("Last-Modified");
+    if (lastModified != null) {
+      Date networkLastModified = network.headers().getDate("Last-Modified");
+      if (networkLastModified != null
+          && networkLastModified.getTime() < lastModified.getTime()) {
+        return true;
+      }
     }
 
-    initContentStream(transport.getTransferStream(cacheRequest));
+    return false;
   }
 
-  protected TunnelRequest getTunnelConfig() {
-    return null;
+  /**
+   * Combines cached headers with a network headers as defined by RFC 2616,
+   * 13.5.3.
+   */
+  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) throws IOException {
+    Headers.Builder result = new Headers.Builder();
+
+    for (int i = 0, size = cachedHeaders.size(); i < size; i++) {
+      String fieldName = cachedHeaders.name(i);
+      String value = cachedHeaders.value(i);
+      if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
+        continue; // Drop 100-level freshness warnings.
+      }
+      if (!OkHeaders.isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
+        result.add(fieldName, value);
+      }
+    }
+
+    for (int i = 0, size = networkHeaders.size(); i < size; i++) {
+      String fieldName = networkHeaders.name(i);
+      if ("Content-Length".equalsIgnoreCase(fieldName)) {
+        continue; // Ignore content-length headers of validating responses.
+      }
+      if (OkHeaders.isEndToEnd(fieldName)) {
+        result.add(fieldName, networkHeaders.value(i));
+      }
+    }
+
+    return result.build();
   }
 
-  public void receiveHeaders(RawHeaders headers) throws IOException {
+  public void receiveHeaders(Headers headers) throws IOException {
     CookieHandler cookieHandler = client.getCookieHandler();
     if (cookieHandler != null) {
-      cookieHandler.put(uri, headers.toMultimap(true));
+      cookieHandler.put(userRequest.uri(), OkHeaders.toMultimap(headers, null));
+    }
+  }
+
+  /**
+   * Figures out the HTTP request to make in response to receiving this engine's
+   * response. This will either add authentication headers or follow redirects.
+   * If a follow-up is either unnecessary or not applicable, this returns null.
+   */
+  public Request followUpRequest() throws IOException {
+    if (userResponse == null) throw new IllegalStateException();
+    Proxy selectedProxy = getRoute() != null
+        ? getRoute().getProxy()
+        : client.getProxy();
+    int responseCode = userResponse.code();
+
+    switch (responseCode) {
+      case HTTP_PROXY_AUTH:
+        if (selectedProxy.type() != Proxy.Type.HTTP) {
+          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+        }
+        // fall-through
+      case HTTP_UNAUTHORIZED:
+        return OkHeaders.processAuthHeader(client.getAuthenticator(), userResponse, selectedProxy);
+
+      case HTTP_PERM_REDIRECT:
+      case HTTP_TEMP_REDIRECT:
+        // "If the 307 or 308 status code is received in response to a request other than GET
+        // or HEAD, the user agent MUST NOT automatically redirect the request"
+        if (!userRequest.method().equals("GET") && !userRequest.method().equals("HEAD")) {
+            return null;
+        }
+        // fall-through
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+        // Does the client allow redirects?
+        if (!client.getFollowRedirects()) return null;
+
+        String location = userResponse.header("Location");
+        if (location == null) return null;
+        URL url = new URL(userRequest.url(), location);
+
+        // Don't follow redirects to unsupported protocols.
+        if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) return null;
+
+        // If configured, don't follow redirects between SSL and non-SSL.
+        boolean sameProtocol = url.getProtocol().equals(userRequest.url().getProtocol());
+        if (!sameProtocol && !client.getFollowSslRedirects()) return null;
+
+        // Redirects don't include a request body.
+        Request.Builder requestBuilder = userRequest.newBuilder();
+        if (HttpMethod.permitsRequestBody(userRequest.method())) {
+          requestBuilder.method("GET", null);
+          requestBuilder.removeHeader("Transfer-Encoding");
+          requestBuilder.removeHeader("Content-Length");
+          requestBuilder.removeHeader("Content-Type");
+        }
+
+        // When redirecting across hosts, drop all authentication headers. This
+        // is potentially annoying to the application layer since they have no
+        // way to retain them.
+        if (!sameConnection(url)) {
+          requestBuilder.removeHeader("Authorization");
+        }
+
+        return requestBuilder.url(url).build();
+
+      default:
+        return null;
     }
   }
+
+  /**
+   * Returns true if an HTTP request for {@code followUp} can reuse the
+   * connection used by this engine.
+   */
+  public boolean sameConnection(URL followUp) {
+    URL url = userRequest.url();
+    return url.getHost().equals(followUp.getHost())
+        && getEffectivePort(url) == getEffectivePort(followUp)
+        && url.getProtocol().equals(followUp.getProtocol());
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
new file mode 100644
index 0000000000..b5f2a48f86
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+public final class HttpMethod {
+  public static boolean invalidatesCache(String method) {
+    return method.equals("POST")
+        || method.equals("PATCH")
+        || method.equals("PUT")
+        || method.equals("DELETE");
+  }
+
+  public static boolean requiresRequestBody(String method) {
+    return method.equals("POST")
+        || method.equals("PUT")
+        || method.equals("PATCH");
+  }
+
+  public static boolean permitsRequestBody(String method) {
+    return requiresRequestBody(method)
+        || method.equals("DELETE"); // Permitted as spec is ambiguous.
+  }
+
+  private HttpMethod() {
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
index f8f9f17266..d02e1e56d1 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
@@ -16,100 +16,44 @@
 
 package com.squareup.okhttp.internal.http;
 
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.internal.AbstractOutputStream;
-import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.CacheRequest;
-import java.net.ProtocolException;
-import java.net.Socket;
-
-import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
 
 public final class HttpTransport implements Transport {
-  /**
-   * The timeout to use while discarding a stream of input data. Since this is
-   * used for connection reuse, this timeout should be significantly less than
-   * the time it takes to establish a new connection.
-   */
-  private static final int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
-
-  public static final int DEFAULT_CHUNK_LENGTH = 1024;
-
   private final HttpEngine httpEngine;
-  private final InputStream socketIn;
-  private final OutputStream socketOut;
+  private final HttpConnection httpConnection;
 
-  /**
-   * This stream buffers the request headers and the request body when their
-   * combined size is less than MAX_REQUEST_BUFFER_LENGTH. By combining them
-   * we can save socket writes, which in turn saves a packet transmission.
-   * This is socketOut if the request size is large or unknown.
-   */
-  private OutputStream requestOut;
-
-  public HttpTransport(HttpEngine httpEngine, OutputStream outputStream, InputStream inputStream) {
+  public HttpTransport(HttpEngine httpEngine, HttpConnection httpConnection) {
     this.httpEngine = httpEngine;
-    this.socketOut = outputStream;
-    this.requestOut = outputStream;
-    this.socketIn = inputStream;
+    this.httpConnection = httpConnection;
   }
 
-  @Override public OutputStream createRequestBody() throws IOException {
-    boolean chunked = httpEngine.requestHeaders.isChunked();
-    if (!chunked
-        && httpEngine.policy.getChunkLength() > 0
-        && httpEngine.connection.getHttpMinorVersion() != 0) {
-      httpEngine.requestHeaders.setChunked();
-      chunked = true;
+  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
+    if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
+      // Stream a request body of unknown length.
+      return httpConnection.newChunkedSink();
     }
 
-    // Stream a request body of unknown length.
-    if (chunked) {
-      int chunkLength = httpEngine.policy.getChunkLength();
-      if (chunkLength == -1) {
-        chunkLength = DEFAULT_CHUNK_LENGTH;
-      }
-      writeRequestHeaders();
-      return new ChunkedOutputStream(requestOut, chunkLength);
-    }
-
-    // Stream a request body of a known length.
-    long fixedContentLength = httpEngine.policy.getFixedContentLength();
-    if (fixedContentLength != -1) {
-      httpEngine.requestHeaders.setContentLength(fixedContentLength);
-      writeRequestHeaders();
-      return new FixedLengthOutputStream(requestOut, fixedContentLength);
-    }
-
-    long contentLength = httpEngine.requestHeaders.getContentLength();
-    if (contentLength > Integer.MAX_VALUE) {
-      throw new IllegalArgumentException("Use setFixedLengthStreamingMode() or "
-          + "setChunkedStreamingMode() for requests larger than 2 GiB.");
-    }
-
-    // Buffer a request body of a known length.
     if (contentLength != -1) {
-      writeRequestHeaders();
-      return new RetryableOutputStream((int) contentLength);
+      // Stream a request body of a known length.
+      return httpConnection.newFixedLengthSink(contentLength);
     }
 
-    // Buffer a request body of an unknown length. Don't write request
-    // headers until the entire body is ready; otherwise we can't set the
-    // Content-Length header correctly.
-    return new RetryableOutputStream();
+    throw new IllegalStateException(
+        "Cannot stream a request body without chunked encoding or a known content length!");
   }
 
-  @Override public void flushRequest() throws IOException {
-    requestOut.flush();
-    requestOut = socketOut;
+  @Override public void finishRequest() throws IOException {
+    httpConnection.flush();
   }
 
-  @Override public void writeRequestBody(RetryableOutputStream requestBody) throws IOException {
-    requestBody.writeToSocket(requestOut);
+  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
+    httpConnection.writeRequestBody(requestBody);
   }
 
   /**
@@ -124,374 +68,70 @@ public HttpTransport(HttpEngine httpEngine, OutputStream outputStream, InputStre
    * This ensures that the {@code Content-Length} header field receives the
    * proper value.
    */
-  public void writeRequestHeaders() throws IOException {
+  public void writeRequestHeaders(Request request) throws IOException {
     httpEngine.writingRequestHeaders();
-    RawHeaders headersToSend = httpEngine.requestHeaders.getHeaders();
-    byte[] bytes = headersToSend.toBytes();
-    requestOut.write(bytes);
+    String requestLine = RequestLine.get(request,
+        httpEngine.getConnection().getRoute().getProxy().type(),
+        httpEngine.getConnection().getProtocol());
+    httpConnection.writeRequest(request.headers(), requestLine);
   }
 
-  @Override public ResponseHeaders readResponseHeaders() throws IOException {
-    RawHeaders rawHeaders = RawHeaders.fromBytes(socketIn);
-    httpEngine.connection.setHttpMinorVersion(rawHeaders.getHttpMinorVersion());
-    httpEngine.receiveHeaders(rawHeaders);
-
-    ResponseHeaders headers = new ResponseHeaders(httpEngine.uri, rawHeaders);
-    headers.setTransport("http/1.1");
-    return headers;
+  @Override public Response.Builder readResponseHeaders() throws IOException {
+    return httpConnection.readResponse();
   }
 
-  public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
-      InputStream responseBodyIn) {
-    if (streamCanceled) {
-      return false;
-    }
-
-    // We cannot reuse sockets that have incomplete output.
-    if (requestBodyOut != null && !((AbstractOutputStream) requestBodyOut).isClosed()) {
-      return false;
+  @Override public void releaseConnectionOnIdle() throws IOException {
+    if (canReuseConnection()) {
+      httpConnection.poolOnIdle();
+    } else {
+      httpConnection.closeOnIdle();
     }
+  }
 
+  @Override public boolean canReuseConnection() {
     // If the request specified that the connection shouldn't be reused, don't reuse it.
-    if (httpEngine.requestHeaders.hasConnectionClose()) {
+    if ("close".equalsIgnoreCase(httpEngine.getRequest().header("Connection"))) {
       return false;
     }
 
     // If the response specified that the connection shouldn't be reused, don't reuse it.
-    if (httpEngine.responseHeaders != null && httpEngine.responseHeaders.hasConnectionClose()) {
+    if ("close".equalsIgnoreCase(httpEngine.getResponse().header("Connection"))) {
       return false;
     }
 
-    if (responseBodyIn instanceof UnknownLengthHttpInputStream) {
+    if (httpConnection.isClosed()) {
       return false;
     }
 
-    if (responseBodyIn != null) {
-      return discardStream(httpEngine, responseBodyIn);
-    }
-
     return true;
   }
 
-  /**
-   * Discards the response body so that the connection can be reused. This
-   * needs to be done judiciously, since it delays the current request in
-   * order to speed up a potential future request that may never occur.
-   *
-   * <p>A stream may be discarded to encourage response caching (a response
-   * cannot be cached unless it is consumed completely) or to enable connection
-   * reuse.
-   */
-  private static boolean discardStream(HttpEngine httpEngine, InputStream responseBodyIn) {
-    Connection connection = httpEngine.connection;
-    if (connection == null) return false;
-    Socket socket = connection.getSocket();
-    if (socket == null) return false;
-    try {
-      int socketTimeout = socket.getSoTimeout();
-      socket.setSoTimeout(DISCARD_STREAM_TIMEOUT_MILLIS);
-      try {
-        Util.skipAll(responseBodyIn);
-        return true;
-      } finally {
-        socket.setSoTimeout(socketTimeout);
-      }
-    } catch (IOException e) {
-      return false;
-    }
+  @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    Source source = getTransferStream(response);
+    return new RealResponseBody(response.headers(), Okio.buffer(source));
   }
 
-  @Override public InputStream getTransferStream(CacheRequest cacheRequest) throws IOException {
-    if (!httpEngine.hasResponseBody()) {
-      return new FixedLengthInputStream(socketIn, cacheRequest, httpEngine, 0);
+  private Source getTransferStream(Response response) throws IOException {
+    if (!HttpEngine.hasBody(response)) {
+      return httpConnection.newFixedLengthSource(0);
     }
 
-    if (httpEngine.responseHeaders.isChunked()) {
-      return new ChunkedInputStream(socketIn, cacheRequest, this);
+    if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
+      return httpConnection.newChunkedSource(httpEngine);
     }
 
-    if (httpEngine.responseHeaders.getContentLength() != -1) {
-      return new FixedLengthInputStream(socketIn, cacheRequest, httpEngine,
-          httpEngine.responseHeaders.getContentLength());
+    long contentLength = OkHeaders.contentLength(response);
+    if (contentLength != -1) {
+      return httpConnection.newFixedLengthSource(contentLength);
     }
 
     // Wrap the input stream from the connection (rather than just returning
     // "socketIn" directly here), so that we can control its use after the
     // reference escapes.
-    return new UnknownLengthHttpInputStream(socketIn, cacheRequest, httpEngine);
+    return httpConnection.newUnknownLengthSource();
   }
 
-  /** An HTTP body with a fixed length known in advance. */
-  private static final class FixedLengthOutputStream extends AbstractOutputStream {
-    private final OutputStream socketOut;
-    private long bytesRemaining;
-
-    private FixedLengthOutputStream(OutputStream socketOut, long bytesRemaining) {
-      this.socketOut = socketOut;
-      this.bytesRemaining = bytesRemaining;
-    }
-
-    @Override public void write(byte[] buffer, int offset, int count) throws IOException {
-      checkNotClosed();
-      checkOffsetAndCount(buffer.length, offset, count);
-      if (count > bytesRemaining) {
-        throw new ProtocolException("expected " + bytesRemaining + " bytes but received " + count);
-      }
-      socketOut.write(buffer, offset, count);
-      bytesRemaining -= count;
-    }
-
-    @Override public void flush() throws IOException {
-      if (closed) {
-        return; // don't throw; this stream might have been closed on the caller's behalf
-      }
-      socketOut.flush();
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) {
-        return;
-      }
-      closed = true;
-      if (bytesRemaining > 0) {
-        throw new ProtocolException("unexpected end of stream");
-      }
-    }
-  }
-
-  /**
-   * An HTTP body with alternating chunk sizes and chunk bodies. Chunks are
-   * buffered until {@code maxChunkLength} bytes are ready, at which point the
-   * chunk is written and the buffer is cleared.
-   */
-  private static final class ChunkedOutputStream extends AbstractOutputStream {
-    private static final byte[] CRLF = { '\r', '\n' };
-    private static final byte[] HEX_DIGITS = {
-        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
-    };
-    private static final byte[] FINAL_CHUNK = new byte[] { '0', '\r', '\n', '\r', '\n' };
-
-    /** Scratch space for up to 8 hex digits, and then a constant CRLF. */
-    private final byte[] hex = { 0, 0, 0, 0, 0, 0, 0, 0, '\r', '\n' };
-
-    private final OutputStream socketOut;
-    private final int maxChunkLength;
-    private final ByteArrayOutputStream bufferedChunk;
-
-    private ChunkedOutputStream(OutputStream socketOut, int maxChunkLength) {
-      this.socketOut = socketOut;
-      this.maxChunkLength = Math.max(1, dataLength(maxChunkLength));
-      this.bufferedChunk = new ByteArrayOutputStream(maxChunkLength);
-    }
-
-    /**
-     * Returns the amount of data that can be transmitted in a chunk whose total
-     * length (data+headers) is {@code dataPlusHeaderLength}. This is presumably
-     * useful to match sizes with wire-protocol packets.
-     */
-    private int dataLength(int dataPlusHeaderLength) {
-      int headerLength = 4; // "\r\n" after the size plus another "\r\n" after the data
-      for (int i = dataPlusHeaderLength - headerLength; i > 0; i >>= 4) {
-        headerLength++;
-      }
-      return dataPlusHeaderLength - headerLength;
-    }
-
-    @Override public synchronized void write(byte[] buffer, int offset, int count)
-        throws IOException {
-      checkNotClosed();
-      checkOffsetAndCount(buffer.length, offset, count);
-
-      while (count > 0) {
-        int numBytesWritten;
-
-        if (bufferedChunk.size() > 0 || count < maxChunkLength) {
-          // fill the buffered chunk and then maybe write that to the stream
-          numBytesWritten = Math.min(count, maxChunkLength - bufferedChunk.size());
-          // TODO: skip unnecessary copies from buffer->bufferedChunk?
-          bufferedChunk.write(buffer, offset, numBytesWritten);
-          if (bufferedChunk.size() == maxChunkLength) {
-            writeBufferedChunkToSocket();
-          }
-        } else {
-          // write a single chunk of size maxChunkLength to the stream
-          numBytesWritten = maxChunkLength;
-          writeHex(numBytesWritten);
-          socketOut.write(buffer, offset, numBytesWritten);
-          socketOut.write(CRLF);
-        }
-
-        offset += numBytesWritten;
-        count -= numBytesWritten;
-      }
-    }
-
-    /**
-     * Equivalent to, but cheaper than writing Integer.toHexString().getBytes()
-     * followed by CRLF.
-     */
-    private void writeHex(int i) throws IOException {
-      int cursor = 8;
-      do {
-        hex[--cursor] = HEX_DIGITS[i & 0xf];
-      } while ((i >>>= 4) != 0);
-      socketOut.write(hex, cursor, hex.length - cursor);
-    }
-
-    @Override public synchronized void flush() throws IOException {
-      if (closed) {
-        return; // don't throw; this stream might have been closed on the caller's behalf
-      }
-      writeBufferedChunkToSocket();
-      socketOut.flush();
-    }
-
-    @Override public synchronized void close() throws IOException {
-      if (closed) {
-        return;
-      }
-      closed = true;
-      writeBufferedChunkToSocket();
-      socketOut.write(FINAL_CHUNK);
-    }
-
-    private void writeBufferedChunkToSocket() throws IOException {
-      int size = bufferedChunk.size();
-      if (size <= 0) {
-        return;
-      }
-
-      writeHex(size);
-      bufferedChunk.writeTo(socketOut);
-      bufferedChunk.reset();
-      socketOut.write(CRLF);
-    }
-  }
-
-  /** An HTTP body with a fixed length specified in advance. */
-  private static class FixedLengthInputStream extends AbstractHttpInputStream {
-    private int bytesRemaining;
-
-    public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEngine httpEngine,
-        int length) throws IOException {
-      super(is, httpEngine, cacheRequest);
-      bytesRemaining = length;
-      if (bytesRemaining == 0) {
-        endOfInput();
-      }
-    }
-
-    @Override public int read(byte[] buffer, int offset, int count) throws IOException {
-      checkOffsetAndCount(buffer.length, offset, count);
-      checkNotClosed();
-      if (bytesRemaining == 0) {
-        return -1;
-      }
-      int read = in.read(buffer, offset, Math.min(count, bytesRemaining));
-      if (read == -1) {
-        unexpectedEndOfInput(); // the server didn't supply the promised content length
-        throw new ProtocolException("unexpected end of stream");
-      }
-      bytesRemaining -= read;
-      cacheWrite(buffer, offset, read);
-      if (bytesRemaining == 0) {
-        endOfInput();
-      }
-      return read;
-    }
-
-    @Override public int available() throws IOException {
-      checkNotClosed();
-      return bytesRemaining == 0 ? 0 : Math.min(in.available(), bytesRemaining);
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) {
-        return;
-      }
-      if (bytesRemaining != 0 && !discardStream(httpEngine, this)) {
-        unexpectedEndOfInput();
-      }
-      closed = true;
-    }
-  }
-
-  /** An HTTP body with alternating chunk sizes and chunk bodies. */
-  private static class ChunkedInputStream extends AbstractHttpInputStream {
-    private static final int NO_CHUNK_YET = -1;
-    private final HttpTransport transport;
-    private int bytesRemainingInChunk = NO_CHUNK_YET;
-    private boolean hasMoreChunks = true;
-
-    ChunkedInputStream(InputStream is, CacheRequest cacheRequest, HttpTransport transport)
-        throws IOException {
-      super(is, transport.httpEngine, cacheRequest);
-      this.transport = transport;
-    }
-
-    @Override public int read(byte[] buffer, int offset, int count) throws IOException {
-      checkOffsetAndCount(buffer.length, offset, count);
-      checkNotClosed();
-
-      if (!hasMoreChunks) {
-        return -1;
-      }
-      if (bytesRemainingInChunk == 0 || bytesRemainingInChunk == NO_CHUNK_YET) {
-        readChunkSize();
-        if (!hasMoreChunks) {
-          return -1;
-        }
-      }
-      int read = in.read(buffer, offset, Math.min(count, bytesRemainingInChunk));
-      if (read == -1) {
-        unexpectedEndOfInput(); // the server didn't supply the promised chunk length
-        throw new IOException("unexpected end of stream");
-      }
-      bytesRemainingInChunk -= read;
-      cacheWrite(buffer, offset, read);
-      return read;
-    }
-
-    private void readChunkSize() throws IOException {
-      // read the suffix of the previous chunk
-      if (bytesRemainingInChunk != NO_CHUNK_YET) {
-        Util.readAsciiLine(in);
-      }
-      String chunkSizeString = Util.readAsciiLine(in);
-      int index = chunkSizeString.indexOf(";");
-      if (index != -1) {
-        chunkSizeString = chunkSizeString.substring(0, index);
-      }
-      try {
-        bytesRemainingInChunk = Integer.parseInt(chunkSizeString.trim(), 16);
-      } catch (NumberFormatException e) {
-        throw new ProtocolException("Expected a hex chunk size but was " + chunkSizeString);
-      }
-      if (bytesRemainingInChunk == 0) {
-        hasMoreChunks = false;
-        RawHeaders rawResponseHeaders = httpEngine.responseHeaders.getHeaders();
-        RawHeaders.readHeaders(transport.socketIn, rawResponseHeaders);
-        httpEngine.receiveHeaders(rawResponseHeaders);
-        endOfInput();
-      }
-    }
-
-    @Override public int available() throws IOException {
-      checkNotClosed();
-      if (!hasMoreChunks || bytesRemainingInChunk == NO_CHUNK_YET) {
-        return 0;
-      }
-      return Math.min(in.available(), bytesRemainingInChunk);
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) {
-        return;
-      }
-      if (hasMoreChunks && !discardStream(httpEngine, this)) {
-        unexpectedEndOfInput();
-      }
-      closed = true;
-    }
+  @Override public void disconnect(HttpEngine engine) throws IOException {
+    httpConnection.closeIfOwnedBy(engine);
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsEngine.java
deleted file mode 100644
index 2bc1d68e42..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsEngine.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.TunnelRequest;
-import java.io.IOException;
-import java.net.CacheResponse;
-import java.net.SecureCacheResponse;
-import java.net.URL;
-import javax.net.ssl.SSLSocket;
-
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
-
-public final class HttpsEngine extends HttpEngine {
-  /**
-   * Stash of HttpsEngine.connection.socket to implement requests like {@code
-   * HttpsURLConnection#getCipherSuite} even after the connection has been
-   * recycled.
-   */
-  private SSLSocket sslSocket;
-
-  public HttpsEngine(OkHttpClient client, Policy policy, String method, RawHeaders requestHeaders,
-      Connection connection, RetryableOutputStream requestBody) throws IOException {
-    super(client, policy, method, requestHeaders, connection, requestBody);
-    this.sslSocket = connection != null ? (SSLSocket) connection.getSocket() : null;
-  }
-
-  @Override protected void connected(Connection connection) {
-    this.sslSocket = (SSLSocket) connection.getSocket();
-    super.connected(connection);
-  }
-
-  @Override protected boolean acceptCacheResponseType(CacheResponse cacheResponse) {
-    return cacheResponse instanceof SecureCacheResponse;
-  }
-
-  @Override protected boolean includeAuthorityInRequestLine() {
-    // Even if there is a proxy, it isn't involved. Always request just the path.
-    return false;
-  }
-
-  public SSLSocket getSslSocket() {
-    return sslSocket;
-  }
-
-  @Override protected TunnelRequest getTunnelConfig() {
-    String userAgent = requestHeaders.getUserAgent();
-    if (userAgent == null) {
-      userAgent = getDefaultUserAgent();
-    }
-
-    URL url = policy.getURL();
-    return new TunnelRequest(url.getHost(), getEffectivePort(url), userAgent,
-        requestHeaders.getProxyAuthorization());
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
new file mode 100644
index 0000000000..a39c657efa
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
@@ -0,0 +1,264 @@
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Authenticator;
+import com.squareup.okhttp.Challenge;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.Platform;
+import java.io.IOException;
+import java.net.Proxy;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.TreeSet;
+
+import static com.squareup.okhttp.internal.Util.equal;
+import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
+
+/** Headers and utilities for internal use by OkHttp. */
+public final class OkHeaders {
+  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
+    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
+    @Override public int compare(String a, String b) {
+      if (a == b) {
+        return 0;
+      } else if (a == null) {
+        return -1;
+      } else if (b == null) {
+        return 1;
+      } else {
+        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
+      }
+    }
+  };
+
+  static final String PREFIX = Platform.get().getPrefix();
+
+  /**
+   * Synthetic response header: the local time when the request was sent.
+   */
+  public static final String SENT_MILLIS = PREFIX + "-Sent-Millis";
+
+  /**
+   * Synthetic response header: the local time when the response was received.
+   */
+  public static final String RECEIVED_MILLIS = PREFIX + "-Received-Millis";
+
+  /**
+   * Synthetic response header: the selected
+   * {@link com.squareup.okhttp.Protocol protocol} ("spdy/3.1", "http/1.1", etc).
+   */
+  public static final String SELECTED_PROTOCOL = PREFIX + "-Selected-Protocol";
+
+  private OkHeaders() {
+  }
+
+  public static long contentLength(Request request) {
+    return contentLength(request.headers());
+  }
+
+  public static long contentLength(Response response) {
+    return contentLength(response.headers());
+  }
+
+  public static long contentLength(Headers headers) {
+    return stringToLong(headers.get("Content-Length"));
+  }
+
+  private static long stringToLong(String s) {
+    if (s == null) return -1;
+    try {
+      return Long.parseLong(s);
+    } catch (NumberFormatException e) {
+      return -1;
+    }
+  }
+
+  /**
+   * Returns an immutable map containing each field to its list of values.
+   *
+   * @param valueForNullKey the request line for requests, or the status line
+   *     for responses. If non-null, this value is mapped to the null key.
+   */
+  public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
+    Map<String, List<String>> result = new TreeMap<>(FIELD_NAME_COMPARATOR);
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String fieldName = headers.name(i);
+      String value = headers.value(i);
+
+      List<String> allValues = new ArrayList<>();
+      List<String> otherValues = result.get(fieldName);
+      if (otherValues != null) {
+        allValues.addAll(otherValues);
+      }
+      allValues.add(value);
+      result.put(fieldName, Collections.unmodifiableList(allValues));
+    }
+    if (valueForNullKey != null) {
+      result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));
+    }
+    return Collections.unmodifiableMap(result);
+  }
+
+  public static void addCookies(Request.Builder builder, Map<String, List<String>> cookieHeaders) {
+    for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
+      String key = entry.getKey();
+      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
+          && !entry.getValue().isEmpty()) {
+        builder.addHeader(key, buildCookieHeader(entry.getValue()));
+      }
+    }
+  }
+
+  /**
+   * Send all cookies in one big header, as recommended by
+   * <a href="http://tools.ietf.org/html/rfc6265#section-4.2.1">RFC 6265</a>.
+   */
+  private static String buildCookieHeader(List<String> cookies) {
+    if (cookies.size() == 1) return cookies.get(0);
+    StringBuilder sb = new StringBuilder();
+    for (int i = 0, size = cookies.size(); i < size; i++) {
+      if (i > 0) sb.append("; ");
+      sb.append(cookies.get(i));
+    }
+    return sb.toString();
+  }
+
+  /**
+   * Returns true if none of the Vary headers have changed between {@code
+   * cachedRequest} and {@code newRequest}.
+   */
+  public static boolean varyMatches(
+      Response cachedResponse, Headers cachedRequest, Request newRequest) {
+    for (String field : varyFields(cachedResponse)) {
+      if (!equal(cachedRequest.values(field), newRequest.headers(field))) return false;
+    }
+    return true;
+  }
+
+  /**
+   * Returns true if a Vary header contains an asterisk. Such responses cannot
+   * be cached.
+   */
+  public static boolean hasVaryAll(Response response) {
+    return varyFields(response).contains("*");
+  }
+
+  private static Set<String> varyFields(Response response) {
+    Set<String> result = Collections.emptySet();
+    Headers headers = response.headers();
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      if (!"Vary".equalsIgnoreCase(headers.name(i))) continue;
+
+      String value = headers.value(i);
+      if (result.isEmpty()) {
+        result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
+      }
+      for (String varyField : value.split(",")) {
+        result.add(varyField.trim());
+      }
+    }
+    return result;
+  }
+
+  /**
+   * Returns the subset of the headers in {@code response}'s request that
+   * impact the content of response's body.
+   */
+  public static Headers varyHeaders(Response response) {
+    Set<String> varyFields = varyFields(response);
+    if (varyFields.isEmpty()) return new Headers.Builder().build();
+
+    // Use the request headers sent over the network, since that's what the
+    // response varies on. Otherwise OkHttp-supplied headers like
+    // "Accept-Encoding: gzip" may be lost.
+    Headers requestHeaders = response.networkResponse().request().headers();
+
+    Headers.Builder result = new Headers.Builder();
+    for (int i = 0, size = requestHeaders.size(); i < size; i++) {
+      String fieldName = requestHeaders.name(i);
+      if (varyFields.contains(fieldName)) {
+        result.add(fieldName, requestHeaders.value(i));
+      }
+    }
+    return result.build();
+  }
+
+  /**
+   * Returns true if {@code fieldName} is an end-to-end HTTP header, as
+   * defined by RFC 2616, 13.5.1.
+   */
+  static boolean isEndToEnd(String fieldName) {
+    return !"Connection".equalsIgnoreCase(fieldName)
+        && !"Keep-Alive".equalsIgnoreCase(fieldName)
+        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
+        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
+        && !"TE".equalsIgnoreCase(fieldName)
+        && !"Trailers".equalsIgnoreCase(fieldName)
+        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
+        && !"Upgrade".equalsIgnoreCase(fieldName);
+  }
+
+  /**
+   * Parse RFC 2617 challenges. This API is only interested in the scheme
+   * name and realm.
+   */
+  public static List<Challenge> parseChallenges(Headers responseHeaders, String challengeHeader) {
+    // auth-scheme = token
+    // auth-param  = token "=" ( token | quoted-string )
+    // challenge   = auth-scheme 1*SP 1#auth-param
+    // realm       = "realm" "=" realm-value
+    // realm-value = quoted-string
+    List<Challenge> result = new ArrayList<>();
+    for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+      if (!challengeHeader.equalsIgnoreCase(responseHeaders.name(i))) {
+        continue;
+      }
+      String value = responseHeaders.value(i);
+      int pos = 0;
+      while (pos < value.length()) {
+        int tokenStart = pos;
+        pos = HeaderParser.skipUntil(value, pos, " ");
+
+        String scheme = value.substring(tokenStart, pos).trim();
+        pos = HeaderParser.skipWhitespace(value, pos);
+
+        // TODO: This currently only handles schemes with a 'realm' parameter;
+        //       It needs to be fixed to handle any scheme and any parameters
+        //       http://code.google.com/p/android/issues/detail?id=11140
+
+        if (!value.regionMatches(true, pos, "realm=\"", 0, "realm=\"".length())) {
+          break; // Unexpected challenge parameter; give up!
+        }
+
+        pos += "realm=\"".length();
+        int realmStart = pos;
+        pos = HeaderParser.skipUntil(value, pos, "\"");
+        String realm = value.substring(realmStart, pos);
+        pos++; // Consume '"' close quote.
+        pos = HeaderParser.skipUntil(value, pos, ",");
+        pos++; // Consume ',' comma.
+        pos = HeaderParser.skipWhitespace(value, pos);
+        result.add(new Challenge(scheme, realm));
+      }
+    }
+    return result;
+  }
+
+  /**
+   * React to a failed authorization response by looking up new credentials.
+   * Returns a request for a subsequent attempt, or null if no further attempts
+   * should be made.
+   */
+  public static Request processAuthHeader(Authenticator authenticator, Response response,
+      Proxy proxy) throws IOException {
+    return response.code() == HTTP_PROXY_AUTH
+        ? authenticator.authenticateProxy(proxy, response)
+        : authenticator.authenticate(proxy, response);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkResponseCacheAdapter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkResponseCacheAdapter.java
deleted file mode 100644
index 5335c2bce8..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkResponseCacheAdapter.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.OkResponseCache;
-import com.squareup.okhttp.ResponseSource;
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-
-public final class OkResponseCacheAdapter implements OkResponseCache {
-  private final ResponseCache responseCache;
-  public OkResponseCacheAdapter(ResponseCache responseCache) {
-    this.responseCache = responseCache;
-  }
-
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) throws IOException {
-    return responseCache.get(uri, requestMethod, requestHeaders);
-  }
-
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    return responseCache.put(uri, urlConnection);
-  }
-
-  @Override public void maybeRemove(String requestMethod, URI uri) throws IOException {
-  }
-
-  @Override public void update(CacheResponse conditionalCacheHit, HttpURLConnection connection)
-      throws IOException {
-  }
-
-  @Override public void trackConditionalCacheHit() {
-  }
-
-  @Override public void trackResponse(ResponseSource source) {
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Policy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Policy.java
deleted file mode 100644
index 0a29d4b1ab..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Policy.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import java.net.HttpURLConnection;
-import java.net.Proxy;
-import java.net.URL;
-
-public interface Policy {
-  /** Returns true if HTTP response caches should be used. */
-  boolean getUseCaches();
-
-  /** Returns the HttpURLConnection instance to store in the cache. */
-  HttpURLConnection getHttpConnectionToCache();
-
-  /** Returns the current destination URL, possibly a redirect. */
-  URL getURL();
-
-  /** Returns the If-Modified-Since timestamp, or 0 if none is set. */
-  long getIfModifiedSince();
-
-  /** Returns true if a non-direct proxy is specified. */
-  boolean usingProxy();
-
-  /** @see java.net.HttpURLConnection#setChunkedStreamingMode(int) */
-  int getChunkLength();
-
-  /** @see java.net.HttpURLConnection#setFixedLengthStreamingMode(int) */
-  long getFixedContentLength();
-
-  /**
-   * Sets the current proxy that this connection is using.
-   * @see java.net.HttpURLConnection#usingProxy
-   */
-  void setSelectedProxy(Proxy proxy);
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RawHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RawHeaders.java
deleted file mode 100644
index 8b45320704..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RawHeaders.java
+++ /dev/null
@@ -1,447 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
-import java.net.ProtocolException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.TreeMap;
-import java.util.TreeSet;
-
-/**
- * The HTTP status and unparsed header fields of a single HTTP message. Values
- * are represented as uninterpreted strings; use {@link RequestHeaders} and
- * {@link ResponseHeaders} for interpreted headers. This class maintains the
- * order of the header fields within the HTTP message.
- *
- * <p>This class tracks fields line-by-line. A field with multiple comma-
- * separated values on the same line will be treated as a field with a single
- * value by this class. It is the caller's responsibility to detect and split
- * on commas if their field permits multiple values. This simplifies use of
- * single-valued fields whose values routinely contain commas, such as cookies
- * or dates.
- *
- * <p>This class trims whitespace from values. It never returns values with
- * leading or trailing whitespace.
- */
-public final class RawHeaders {
-  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
-    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
-    @Override public int compare(String a, String b) {
-      if (a == b) {
-        return 0;
-      } else if (a == null) {
-        return -1;
-      } else if (b == null) {
-        return 1;
-      } else {
-        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
-      }
-    }
-  };
-
-  private final List<String> namesAndValues = new ArrayList<String>(20);
-  private String requestLine;
-  private String statusLine;
-  private int httpMinorVersion = 1;
-  private int responseCode = -1;
-  private String responseMessage;
-
-  public RawHeaders() {
-  }
-
-  public RawHeaders(RawHeaders copyFrom) {
-    namesAndValues.addAll(copyFrom.namesAndValues);
-    requestLine = copyFrom.requestLine;
-    statusLine = copyFrom.statusLine;
-    httpMinorVersion = copyFrom.httpMinorVersion;
-    responseCode = copyFrom.responseCode;
-    responseMessage = copyFrom.responseMessage;
-  }
-
-  /** Sets the request line (like "GET / HTTP/1.1"). */
-  public void setRequestLine(String requestLine) {
-    requestLine = requestLine.trim();
-    this.requestLine = requestLine;
-  }
-
-  /** Sets the response status line (like "HTTP/1.0 200 OK"). */
-  public void setStatusLine(String statusLine) throws IOException {
-    // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
-    // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
-    if (this.responseMessage != null) {
-      throw new IllegalStateException("statusLine is already set");
-    }
-    // We allow empty message without leading white space since some servers
-    // do not send the white space when the message is empty.
-    boolean hasMessage = statusLine.length() > 13;
-    if (!statusLine.startsWith("HTTP/1.")
-        || statusLine.length() < 12
-        || statusLine.charAt(8) != ' '
-        || (hasMessage && statusLine.charAt(12) != ' ')) {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
-    int httpMinorVersion = statusLine.charAt(7) - '0';
-    if (httpMinorVersion < 0 || httpMinorVersion > 9) {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
-    int responseCode;
-    try {
-      responseCode = Integer.parseInt(statusLine.substring(9, 12));
-    } catch (NumberFormatException e) {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
-    this.responseMessage = hasMessage ? statusLine.substring(13) : "";
-    this.responseCode = responseCode;
-    this.statusLine = statusLine;
-    this.httpMinorVersion = httpMinorVersion;
-  }
-
-  /**
-   * @param method like "GET", "POST", "HEAD", etc.
-   * @param path like "/foo/bar.html"
-   * @param version like "HTTP/1.1"
-   * @param host like "www.android.com:1234"
-   * @param scheme like "https"
-   */
-  public void addSpdyRequestHeaders(String method, String path, String version, String host,
-      String scheme) {
-    // TODO: populate the statusLine for the client's benefit?
-    add(":method", method);
-    add(":scheme", scheme);
-    add(":path", path);
-    add(":version", version);
-    add(":host", host);
-  }
-
-  public String getStatusLine() {
-    return statusLine;
-  }
-
-  /**
-   * Returns the status line's HTTP minor version. This returns 0 for HTTP/1.0
-   * and 1 for HTTP/1.1. This returns 1 if the HTTP version is unknown.
-   */
-  public int getHttpMinorVersion() {
-    return httpMinorVersion != -1 ? httpMinorVersion : 1;
-  }
-
-  /** Returns the HTTP status code or -1 if it is unknown. */
-  public int getResponseCode() {
-    return responseCode;
-  }
-
-  /** Returns the HTTP status message or null if it is unknown. */
-  public String getResponseMessage() {
-    return responseMessage;
-  }
-
-  /**
-   * Add an HTTP header line containing a field name, a literal colon, and a
-   * value. This works around empty header names and header names that start
-   * with a colon (created by old broken SPDY versions of the response cache).
-   */
-  public void addLine(String line) {
-    int index = line.indexOf(":", 1);
-    if (index != -1) {
-      addLenient(line.substring(0, index), line.substring(index + 1));
-    } else if (line.startsWith(":")) {
-      addLenient("", line.substring(1)); // Empty header name.
-    } else {
-      addLenient("", line); // No header name.
-    }
-  }
-
-  /** Add a field with the specified value. */
-  public void add(String fieldName, String value) {
-    if (fieldName == null) throw new IllegalArgumentException("fieldname == null");
-    if (value == null) throw new IllegalArgumentException("value == null");
-    if (fieldName.length() == 0 || fieldName.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-      throw new IllegalArgumentException("Unexpected header: " + fieldName + ": " + value);
-    }
-    addLenient(fieldName, value);
-  }
-
-  /**
-   * Add a field with the specified value without any validation. Only
-   * appropriate for headers from the remote peer.
-   */
-  private void addLenient(String fieldName, String value) {
-    namesAndValues.add(fieldName);
-    namesAndValues.add(value.trim());
-  }
-
-  public void removeAll(String fieldName) {
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
-        namesAndValues.remove(i); // field name
-        namesAndValues.remove(i); // value
-      }
-    }
-  }
-
-  public void addAll(String fieldName, List<String> headerFields) {
-    for (String value : headerFields) {
-      add(fieldName, value);
-    }
-  }
-
-  /**
-   * Set a field with the specified value. If the field is not found, it is
-   * added. If the field is found, the existing values are replaced.
-   */
-  public void set(String fieldName, String value) {
-    removeAll(fieldName);
-    add(fieldName, value);
-  }
-
-  /** Returns the number of field values. */
-  public int length() {
-    return namesAndValues.size() / 2;
-  }
-
-  /** Returns the field at {@code position} or null if that is out of range. */
-  public String getFieldName(int index) {
-    int fieldNameIndex = index * 2;
-    if (fieldNameIndex < 0 || fieldNameIndex >= namesAndValues.size()) {
-      return null;
-    }
-    return namesAndValues.get(fieldNameIndex);
-  }
-
-  /** Returns an immutable case-insensitive set of header names. */
-  public Set<String> names() {
-    TreeSet<String> result = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
-    for (int i = 0; i < length(); i++) {
-      result.add(getFieldName(i));
-    }
-    return Collections.unmodifiableSet(result);
-  }
-
-  /** Returns the value at {@code index} or null if that is out of range. */
-  public String getValue(int index) {
-    int valueIndex = index * 2 + 1;
-    if (valueIndex < 0 || valueIndex >= namesAndValues.size()) {
-      return null;
-    }
-    return namesAndValues.get(valueIndex);
-  }
-
-  /** Returns the last value corresponding to the specified field, or null. */
-  public String get(String fieldName) {
-    for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
-      if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
-        return namesAndValues.get(i + 1);
-      }
-    }
-    return null;
-  }
-
-  /** Returns an immutable list of the header values for {@code name}. */
-  public List<String> values(String name) {
-    List<String> result = null;
-    for (int i = 0; i < length(); i++) {
-      if (name.equalsIgnoreCase(getFieldName(i))) {
-        if (result == null) result = new ArrayList<String>(2);
-        result.add(getValue(i));
-      }
-    }
-    return result != null
-        ? Collections.unmodifiableList(result)
-        : Collections.<String>emptyList();
-  }
-
-  /** @param fieldNames a case-insensitive set of HTTP header field names. */
-  public RawHeaders getAll(Set<String> fieldNames) {
-    RawHeaders result = new RawHeaders();
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      String fieldName = namesAndValues.get(i);
-      if (fieldNames.contains(fieldName)) {
-        result.add(fieldName, namesAndValues.get(i + 1));
-      }
-    }
-    return result;
-  }
-
-  /** Returns bytes of a request header for sending on an HTTP transport. */
-  public byte[] toBytes() throws UnsupportedEncodingException {
-    StringBuilder result = new StringBuilder(256);
-    result.append(requestLine).append("\r\n");
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      result.append(namesAndValues.get(i))
-          .append(": ")
-          .append(namesAndValues.get(i + 1))
-          .append("\r\n");
-    }
-    result.append("\r\n");
-    return result.toString().getBytes("ISO-8859-1");
-  }
-
-  /** Parses bytes of a response header from an HTTP transport. */
-  public static RawHeaders fromBytes(InputStream in) throws IOException {
-    RawHeaders headers;
-    do {
-      headers = new RawHeaders();
-      headers.setStatusLine(Util.readAsciiLine(in));
-      readHeaders(in, headers);
-    } while (headers.getResponseCode() == HttpEngine.HTTP_CONTINUE);
-    return headers;
-  }
-
-  /** Reads headers or trailers into {@code out}. */
-  public static void readHeaders(InputStream in, RawHeaders out) throws IOException {
-    // parse the result headers until the first blank line
-    String line;
-    while ((line = Util.readAsciiLine(in)).length() != 0) {
-      out.addLine(line);
-    }
-  }
-
-  /**
-   * Returns an immutable map containing each field to its list of values. The
-   * status line is mapped to null.
-   */
-  public Map<String, List<String>> toMultimap(boolean response) {
-    Map<String, List<String>> result = new TreeMap<String, List<String>>(FIELD_NAME_COMPARATOR);
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      String fieldName = namesAndValues.get(i);
-      String value = namesAndValues.get(i + 1);
-
-      List<String> allValues = new ArrayList<String>();
-      List<String> otherValues = result.get(fieldName);
-      if (otherValues != null) {
-        allValues.addAll(otherValues);
-      }
-      allValues.add(value);
-      result.put(fieldName, Collections.unmodifiableList(allValues));
-    }
-    if (response && statusLine != null) {
-      result.put(null, Collections.unmodifiableList(Collections.singletonList(statusLine)));
-    } else if (requestLine != null) {
-      result.put(null, Collections.unmodifiableList(Collections.singletonList(requestLine)));
-    }
-    return Collections.unmodifiableMap(result);
-  }
-
-  /**
-   * Creates a new instance from the given map of fields to values. If
-   * present, the null field's last element will be used to set the status
-   * line.
-   */
-  public static RawHeaders fromMultimap(Map<String, List<String>> map, boolean response)
-      throws IOException {
-    if (!response) throw new UnsupportedOperationException();
-    RawHeaders result = new RawHeaders();
-    for (Entry<String, List<String>> entry : map.entrySet()) {
-      String fieldName = entry.getKey();
-      List<String> values = entry.getValue();
-      if (fieldName != null) {
-        for (String value : values) {
-          result.addLenient(fieldName, value);
-        }
-      } else if (!values.isEmpty()) {
-        result.setStatusLine(values.get(values.size() - 1));
-      }
-    }
-    return result;
-  }
-
-  /**
-   * Returns a list of alternating names and values. Names are all lower case.
-   * No names are repeated. If any name has multiple values, they are
-   * concatenated using "\0" as a delimiter.
-   */
-  public List<String> toNameValueBlock() {
-    Set<String> names = new HashSet<String>();
-    List<String> result = new ArrayList<String>();
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      String name = namesAndValues.get(i).toLowerCase(Locale.US);
-      String value = namesAndValues.get(i + 1);
-
-      // Drop headers that are forbidden when layering HTTP over SPDY.
-      if (name.equals("connection")
-          || name.equals("host")
-          || name.equals("keep-alive")
-          || name.equals("proxy-connection")
-          || name.equals("transfer-encoding")) {
-        continue;
-      }
-
-      // If we haven't seen this name before, add the pair to the end of the list...
-      if (names.add(name)) {
-        result.add(name);
-        result.add(value);
-        continue;
-      }
-
-      // ...otherwise concatenate the existing values and this value.
-      for (int j = 0; j < result.size(); j += 2) {
-        if (name.equals(result.get(j))) {
-          result.set(j + 1, result.get(j + 1) + "\0" + value);
-          break;
-        }
-      }
-    }
-    return result;
-  }
-
-  /** Returns headers for a name value block containing a SPDY response. */
-  public static RawHeaders fromNameValueBlock(List<String> nameValueBlock) throws IOException {
-    if (nameValueBlock.size() % 2 != 0) {
-      throw new IllegalArgumentException("Unexpected name value block: " + nameValueBlock);
-    }
-    String status = null;
-    String version = null;
-    RawHeaders result = new RawHeaders();
-    for (int i = 0; i < nameValueBlock.size(); i += 2) {
-      String name = nameValueBlock.get(i);
-      String values = nameValueBlock.get(i + 1);
-      for (int start = 0; start < values.length(); ) {
-        int end = values.indexOf('\0', start);
-        if (end == -1) {
-          end = values.length();
-        }
-        String value = values.substring(start, end);
-        if (":status".equals(name)) {
-          status = value;
-        } else if (":version".equals(name)) {
-          version = value;
-        } else {
-          result.namesAndValues.add(name);
-          result.namesAndValues.add(value);
-        }
-        start = end + 1;
-      }
-    }
-    if (status == null) throw new ProtocolException("Expected ':status' header not present");
-    if (version == null) throw new ProtocolException("Expected ':version' header not present");
-    result.setStatusLine(version + " " + status);
-    return result;
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RealResponseBody.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RealResponseBody.java
new file mode 100644
index 0000000000..18d026f11a
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RealResponseBody.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.ResponseBody;
+import okio.BufferedSource;
+
+public final class RealResponseBody extends ResponseBody {
+  private final Headers headers;
+  private final BufferedSource source;
+
+  public RealResponseBody(Headers headers, BufferedSource source) {
+    this.headers = headers;
+    this.source = source;
+  }
+
+  @Override public MediaType contentType() {
+    String contentType = headers.get("Content-Type");
+    return contentType != null ? MediaType.parse(contentType) : null;
+  }
+
+  @Override public long contentLength() {
+    return OkHeaders.contentLength(headers);
+  }
+
+  @Override public BufferedSource source() {
+    return source;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestHeaders.java
deleted file mode 100644
index 71c3cd0f21..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestHeaders.java
+++ /dev/null
@@ -1,317 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import java.net.URI;
-import java.util.Date;
-import java.util.List;
-import java.util.Map;
-
-/** Parsed HTTP request headers. */
-public final class RequestHeaders {
-  private final URI uri;
-  private final RawHeaders headers;
-
-  /** Don't use a cache to satisfy this request. */
-  private boolean noCache;
-  private int maxAgeSeconds = -1;
-  private int maxStaleSeconds = -1;
-  private int minFreshSeconds = -1;
-
-  /**
-   * This field's name "only-if-cached" is misleading. It actually means "do
-   * not use the network". It is set by a client who only wants to make a
-   * request if it can be fully satisfied by the cache. Cached responses that
-   * would require validation (ie. conditional gets) are not permitted if this
-   * header is set.
-   */
-  private boolean onlyIfCached;
-
-  /**
-   * True if the request contains an authorization field. Although this isn't
-   * necessarily a shared cache, it follows the spec's strict requirements for
-   * shared caches.
-   */
-  private boolean hasAuthorization;
-
-  private long contentLength = -1;
-  private String transferEncoding;
-  private String userAgent;
-  private String host;
-  private String connection;
-  private String acceptEncoding;
-  private String contentType;
-  private String ifModifiedSince;
-  private String ifNoneMatch;
-  private String proxyAuthorization;
-
-  public RequestHeaders(URI uri, RawHeaders headers) {
-    this.uri = uri;
-    this.headers = headers;
-
-    HeaderParser.CacheControlHandler handler = new HeaderParser.CacheControlHandler() {
-      @Override public void handle(String directive, String parameter) {
-        if ("no-cache".equalsIgnoreCase(directive)) {
-          noCache = true;
-        } else if ("max-age".equalsIgnoreCase(directive)) {
-          maxAgeSeconds = HeaderParser.parseSeconds(parameter);
-        } else if ("max-stale".equalsIgnoreCase(directive)) {
-          maxStaleSeconds = HeaderParser.parseSeconds(parameter);
-        } else if ("min-fresh".equalsIgnoreCase(directive)) {
-          minFreshSeconds = HeaderParser.parseSeconds(parameter);
-        } else if ("only-if-cached".equalsIgnoreCase(directive)) {
-          onlyIfCached = true;
-        }
-      }
-    };
-
-    for (int i = 0; i < headers.length(); i++) {
-      String fieldName = headers.getFieldName(i);
-      String value = headers.getValue(i);
-      if ("Cache-Control".equalsIgnoreCase(fieldName)) {
-        HeaderParser.parseCacheControl(value, handler);
-      } else if ("Pragma".equalsIgnoreCase(fieldName)) {
-        if ("no-cache".equalsIgnoreCase(value)) {
-          noCache = true;
-        }
-      } else if ("If-None-Match".equalsIgnoreCase(fieldName)) {
-        ifNoneMatch = value;
-      } else if ("If-Modified-Since".equalsIgnoreCase(fieldName)) {
-        ifModifiedSince = value;
-      } else if ("Authorization".equalsIgnoreCase(fieldName)) {
-        hasAuthorization = true;
-      } else if ("Content-Length".equalsIgnoreCase(fieldName)) {
-        try {
-          contentLength = Integer.parseInt(value);
-        } catch (NumberFormatException ignored) {
-        }
-      } else if ("Transfer-Encoding".equalsIgnoreCase(fieldName)) {
-        transferEncoding = value;
-      } else if ("User-Agent".equalsIgnoreCase(fieldName)) {
-        userAgent = value;
-      } else if ("Host".equalsIgnoreCase(fieldName)) {
-        host = value;
-      } else if ("Connection".equalsIgnoreCase(fieldName)) {
-        connection = value;
-      } else if ("Accept-Encoding".equalsIgnoreCase(fieldName)) {
-        acceptEncoding = value;
-      } else if ("Content-Type".equalsIgnoreCase(fieldName)) {
-        contentType = value;
-      } else if ("Proxy-Authorization".equalsIgnoreCase(fieldName)) {
-        proxyAuthorization = value;
-      }
-    }
-  }
-
-  public boolean isChunked() {
-    return "chunked".equalsIgnoreCase(transferEncoding);
-  }
-
-  public boolean hasConnectionClose() {
-    return "close".equalsIgnoreCase(connection);
-  }
-
-  public URI getUri() {
-    return uri;
-  }
-
-  public RawHeaders getHeaders() {
-    return headers;
-  }
-
-  public boolean isNoCache() {
-    return noCache;
-  }
-
-  public int getMaxAgeSeconds() {
-    return maxAgeSeconds;
-  }
-
-  public int getMaxStaleSeconds() {
-    return maxStaleSeconds;
-  }
-
-  public int getMinFreshSeconds() {
-    return minFreshSeconds;
-  }
-
-  public boolean isOnlyIfCached() {
-    return onlyIfCached;
-  }
-
-  public boolean hasAuthorization() {
-    return hasAuthorization;
-  }
-
-  public long getContentLength() {
-    return contentLength;
-  }
-
-  public String getTransferEncoding() {
-    return transferEncoding;
-  }
-
-  public String getUserAgent() {
-    return userAgent;
-  }
-
-  public String getHost() {
-    return host;
-  }
-
-  public String getConnection() {
-    return connection;
-  }
-
-  public String getAcceptEncoding() {
-    return acceptEncoding;
-  }
-
-  public String getContentType() {
-    return contentType;
-  }
-
-  public String getIfModifiedSince() {
-    return ifModifiedSince;
-  }
-
-  public String getIfNoneMatch() {
-    return ifNoneMatch;
-  }
-
-  public String getProxyAuthorization() {
-    return proxyAuthorization;
-  }
-
-  public void setChunked() {
-    if (this.transferEncoding != null) {
-      headers.removeAll("Transfer-Encoding");
-    }
-    headers.add("Transfer-Encoding", "chunked");
-    this.transferEncoding = "chunked";
-  }
-
-  public void setContentLength(long contentLength) {
-    if (this.contentLength != -1) {
-      headers.removeAll("Content-Length");
-    }
-    headers.add("Content-Length", Long.toString(contentLength));
-    this.contentLength = contentLength;
-  }
-
-  /**
-   * Remove the Content-Length headers. Call this when dropping the body on a
-   * request or response, such as when a redirect changes the method from POST
-   * to GET.
-   */
-  public void removeContentLength() {
-    if (contentLength != -1) {
-      headers.removeAll("Content-Length");
-      contentLength = -1;
-    }
-  }
-
-  public void setUserAgent(String userAgent) {
-    if (this.userAgent != null) {
-      headers.removeAll("User-Agent");
-    }
-    headers.add("User-Agent", userAgent);
-    this.userAgent = userAgent;
-  }
-
-  public void setHost(String host) {
-    if (this.host != null) {
-      headers.removeAll("Host");
-    }
-    headers.add("Host", host);
-    this.host = host;
-  }
-
-  public void setConnection(String connection) {
-    if (this.connection != null) {
-      headers.removeAll("Connection");
-    }
-    headers.add("Connection", connection);
-    this.connection = connection;
-  }
-
-  public void setAcceptEncoding(String acceptEncoding) {
-    if (this.acceptEncoding != null) {
-      headers.removeAll("Accept-Encoding");
-    }
-    headers.add("Accept-Encoding", acceptEncoding);
-    this.acceptEncoding = acceptEncoding;
-  }
-
-  public void setContentType(String contentType) {
-    if (this.contentType != null) {
-      headers.removeAll("Content-Type");
-    }
-    headers.add("Content-Type", contentType);
-    this.contentType = contentType;
-  }
-
-  public void setIfModifiedSince(Date date) {
-    if (ifModifiedSince != null) {
-      headers.removeAll("If-Modified-Since");
-    }
-    String formattedDate = HttpDate.format(date);
-    headers.add("If-Modified-Since", formattedDate);
-    ifModifiedSince = formattedDate;
-  }
-
-  public void setIfNoneMatch(String ifNoneMatch) {
-    if (this.ifNoneMatch != null) {
-      headers.removeAll("If-None-Match");
-    }
-    headers.add("If-None-Match", ifNoneMatch);
-    this.ifNoneMatch = ifNoneMatch;
-  }
-
-  /**
-   * Returns true if the request contains conditions that save the server from
-   * sending a response that the client has locally. When the caller adds
-   * conditions, this cache won't participate in the request.
-   */
-  public boolean hasConditions() {
-    return ifModifiedSince != null || ifNoneMatch != null;
-  }
-
-  public void addCookies(Map<String, List<String>> allCookieHeaders) {
-    for (Map.Entry<String, List<String>> entry : allCookieHeaders.entrySet()) {
-      String key = entry.getKey();
-      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
-          && !entry.getValue().isEmpty()) {
-        headers.add(key, buildCookieHeader(entry.getValue()));
-      }
-    }
-  }
-
-  /**
-   * Send all cookies in one big header, as recommended by
-   * <a href="http://tools.ietf.org/html/rfc6265#section-4.2.1">RFC 6265</a>.
-   */
-  private String buildCookieHeader(List<String> cookies) {
-    if (cookies.size() == 1) return cookies.get(0);
-    StringBuilder sb = new StringBuilder();
-    for (int i = 0; i < cookies.size(); i++) {
-      if (i > 0) sb.append("; ");
-      sb.append(cookies.get(i));
-    }
-    return sb.toString();
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
new file mode 100644
index 0000000000..f764afd326
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
@@ -0,0 +1,57 @@
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import java.net.HttpURLConnection;
+import java.net.Proxy;
+import java.net.URL;
+
+public final class RequestLine {
+  private RequestLine() {
+  }
+
+  /**
+   * Returns the request status line, like "GET / HTTP/1.1". This is exposed
+   * to the application by {@link HttpURLConnection#getHeaderFields}, so it
+   * needs to be set even if the transport is SPDY.
+   */
+  static String get(Request request, Proxy.Type proxyType, Protocol protocol) {
+    StringBuilder result = new StringBuilder();
+    result.append(request.method());
+    result.append(' ');
+
+    if (includeAuthorityInRequestLine(request, proxyType)) {
+      result.append(request.url());
+    } else {
+      result.append(requestPath(request.url()));
+    }
+
+    result.append(' ');
+    result.append(version(protocol));
+    return result.toString();
+  }
+
+  /**
+   * Returns true if the request line should contain the full URL with host
+   * and port (like "GET http://android.com/foo HTTP/1.1") or only the path
+   * (like "GET /foo HTTP/1.1").
+   */
+  private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type proxyType) {
+    return !request.isHttps() && proxyType == Proxy.Type.HTTP;
+  }
+
+  /**
+   * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty,
+   * even if the request URL is. Includes the query component if it exists.
+   */
+  public static String requestPath(URL url) {
+    String pathAndQuery = url.getFile();
+    if (pathAndQuery == null) return "/";
+    if (!pathAndQuery.startsWith("/")) return "/" + pathAndQuery;
+    return pathAndQuery;
+  }
+
+  public static String version(Protocol protocol) {
+    return protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1";
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseHeaders.java
deleted file mode 100644
index 461de8efb9..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseHeaders.java
+++ /dev/null
@@ -1,505 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.ResponseSource;
-import com.squareup.okhttp.internal.Platform;
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URI;
-import java.util.Collections;
-import java.util.Date;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeSet;
-import java.util.concurrent.TimeUnit;
-
-import static com.squareup.okhttp.internal.Util.equal;
-
-/** Parsed HTTP response headers. */
-public final class ResponseHeaders {
-
-  /** HTTP header name for the local time when the request was sent. */
-  private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
-
-  /** HTTP header name for the local time when the response was received. */
-  private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
-
-  /** HTTP synthetic header with the response source. */
-  static final String RESPONSE_SOURCE = Platform.get().getPrefix() + "-Response-Source";
-
-  /** HTTP synthetic header with the selected transport (spdy/3, http/1.1, etc). */
-  static final String SELECTED_TRANSPORT = Platform.get().getPrefix() + "-Selected-Transport";
-
-  private final URI uri;
-  private final RawHeaders headers;
-
-  /** The server's time when this response was served, if known. */
-  private Date servedDate;
-
-  /** The last modified date of the response, if known. */
-  private Date lastModified;
-
-  /**
-   * The expiration date of the response, if known. If both this field and the
-   * max age are set, the max age is preferred.
-   */
-  private Date expires;
-
-  /**
-   * Extension header set by HttpURLConnectionImpl specifying the timestamp
-   * when the HTTP request was first initiated.
-   */
-  private long sentRequestMillis;
-
-  /**
-   * Extension header set by HttpURLConnectionImpl specifying the timestamp
-   * when the HTTP response was first received.
-   */
-  private long receivedResponseMillis;
-
-  /**
-   * In the response, this field's name "no-cache" is misleading. It doesn't
-   * prevent us from caching the response; it only means we have to validate
-   * the response with the origin server before returning it. We can do this
-   * with a conditional get.
-   */
-  private boolean noCache;
-
-  /** If true, this response should not be cached. */
-  private boolean noStore;
-
-  /**
-   * The duration past the response's served date that it can be served
-   * without validation.
-   */
-  private int maxAgeSeconds = -1;
-
-  /**
-   * The "s-maxage" directive is the max age for shared caches. Not to be
-   * confused with "max-age" for non-shared caches, As in Firefox and Chrome,
-   * this directive is not honored by this cache.
-   */
-  private int sMaxAgeSeconds = -1;
-
-  /**
-   * This request header field's name "only-if-cached" is misleading. It
-   * actually means "do not use the network". It is set by a client who only
-   * wants to make a request if it can be fully satisfied by the cache.
-   * Cached responses that would require validation (ie. conditional gets) are
-   * not permitted if this header is set.
-   */
-  private boolean isPublic;
-  private boolean mustRevalidate;
-  private String etag;
-  private int ageSeconds = -1;
-
-  /** Case-insensitive set of field names. */
-  private Set<String> varyFields = Collections.emptySet();
-
-  private String contentEncoding;
-  private String transferEncoding;
-  private int contentLength = -1;
-  private String connection;
-
-  public ResponseHeaders(URI uri, RawHeaders headers) {
-    this.uri = uri;
-    this.headers = headers;
-
-    HeaderParser.CacheControlHandler handler = new HeaderParser.CacheControlHandler() {
-      @Override public void handle(String directive, String parameter) {
-        if ("no-cache".equalsIgnoreCase(directive)) {
-          noCache = true;
-        } else if ("no-store".equalsIgnoreCase(directive)) {
-          noStore = true;
-        } else if ("max-age".equalsIgnoreCase(directive)) {
-          maxAgeSeconds = HeaderParser.parseSeconds(parameter);
-        } else if ("s-maxage".equalsIgnoreCase(directive)) {
-          sMaxAgeSeconds = HeaderParser.parseSeconds(parameter);
-        } else if ("public".equalsIgnoreCase(directive)) {
-          isPublic = true;
-        } else if ("must-revalidate".equalsIgnoreCase(directive)) {
-          mustRevalidate = true;
-        }
-      }
-    };
-
-    for (int i = 0; i < headers.length(); i++) {
-      String fieldName = headers.getFieldName(i);
-      String value = headers.getValue(i);
-      if ("Cache-Control".equalsIgnoreCase(fieldName)) {
-        HeaderParser.parseCacheControl(value, handler);
-      } else if ("Date".equalsIgnoreCase(fieldName)) {
-        servedDate = HttpDate.parse(value);
-      } else if ("Expires".equalsIgnoreCase(fieldName)) {
-        expires = HttpDate.parse(value);
-      } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
-        lastModified = HttpDate.parse(value);
-      } else if ("ETag".equalsIgnoreCase(fieldName)) {
-        etag = value;
-      } else if ("Pragma".equalsIgnoreCase(fieldName)) {
-        if ("no-cache".equalsIgnoreCase(value)) {
-          noCache = true;
-        }
-      } else if ("Age".equalsIgnoreCase(fieldName)) {
-        ageSeconds = HeaderParser.parseSeconds(value);
-      } else if ("Vary".equalsIgnoreCase(fieldName)) {
-        // Replace the immutable empty set with something we can mutate.
-        if (varyFields.isEmpty()) {
-          varyFields = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
-        }
-        for (String varyField : value.split(",")) {
-          varyFields.add(varyField.trim());
-        }
-      } else if ("Content-Encoding".equalsIgnoreCase(fieldName)) {
-        contentEncoding = value;
-      } else if ("Transfer-Encoding".equalsIgnoreCase(fieldName)) {
-        transferEncoding = value;
-      } else if ("Content-Length".equalsIgnoreCase(fieldName)) {
-        try {
-          contentLength = Integer.parseInt(value);
-        } catch (NumberFormatException ignored) {
-        }
-      } else if ("Connection".equalsIgnoreCase(fieldName)) {
-        connection = value;
-      } else if (SENT_MILLIS.equalsIgnoreCase(fieldName)) {
-        sentRequestMillis = Long.parseLong(value);
-      } else if (RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
-        receivedResponseMillis = Long.parseLong(value);
-      }
-    }
-  }
-
-  public boolean isContentEncodingGzip() {
-    return "gzip".equalsIgnoreCase(contentEncoding);
-  }
-
-  public void stripContentEncoding() {
-    contentEncoding = null;
-    headers.removeAll("Content-Encoding");
-  }
-
-  public void stripContentLength() {
-    contentLength = -1;
-    headers.removeAll("Content-Length");
-  }
-
-  public boolean isChunked() {
-    return "chunked".equalsIgnoreCase(transferEncoding);
-  }
-
-  public boolean hasConnectionClose() {
-    return "close".equalsIgnoreCase(connection);
-  }
-
-  public URI getUri() {
-    return uri;
-  }
-
-  public RawHeaders getHeaders() {
-    return headers;
-  }
-
-  public Date getServedDate() {
-    return servedDate;
-  }
-
-  public Date getLastModified() {
-    return lastModified;
-  }
-
-  public Date getExpires() {
-    return expires;
-  }
-
-  public boolean isNoCache() {
-    return noCache;
-  }
-
-  public boolean isNoStore() {
-    return noStore;
-  }
-
-  public int getMaxAgeSeconds() {
-    return maxAgeSeconds;
-  }
-
-  public int getSMaxAgeSeconds() {
-    return sMaxAgeSeconds;
-  }
-
-  public boolean isPublic() {
-    return isPublic;
-  }
-
-  public boolean isMustRevalidate() {
-    return mustRevalidate;
-  }
-
-  public String getEtag() {
-    return etag;
-  }
-
-  public Set<String> getVaryFields() {
-    return varyFields;
-  }
-
-  public String getContentEncoding() {
-    return contentEncoding;
-  }
-
-  public int getContentLength() {
-    return contentLength;
-  }
-
-  public String getConnection() {
-    return connection;
-  }
-
-  public void setLocalTimestamps(long sentRequestMillis, long receivedResponseMillis) {
-    this.sentRequestMillis = sentRequestMillis;
-    headers.add(SENT_MILLIS, Long.toString(sentRequestMillis));
-    this.receivedResponseMillis = receivedResponseMillis;
-    headers.add(RECEIVED_MILLIS, Long.toString(receivedResponseMillis));
-  }
-
-  public void setResponseSource(ResponseSource responseSource) {
-    headers.set(RESPONSE_SOURCE, responseSource.toString() + " " + headers.getResponseCode());
-  }
-
-  public void setTransport(String transport) {
-    headers.set(SELECTED_TRANSPORT, transport);
-  }
-
-  /**
-   * Returns the current age of the response, in milliseconds. The calculation
-   * is specified by RFC 2616, 13.2.3 Age Calculations.
-   */
-  private long computeAge(long nowMillis) {
-    long apparentReceivedAge =
-        servedDate != null ? Math.max(0, receivedResponseMillis - servedDate.getTime()) : 0;
-    long receivedAge =
-        ageSeconds != -1 ? Math.max(apparentReceivedAge, TimeUnit.SECONDS.toMillis(ageSeconds))
-            : apparentReceivedAge;
-    long responseDuration = receivedResponseMillis - sentRequestMillis;
-    long residentDuration = nowMillis - receivedResponseMillis;
-    return receivedAge + responseDuration + residentDuration;
-  }
-
-  /**
-   * Returns the number of milliseconds that the response was fresh for,
-   * starting from the served date.
-   */
-  private long computeFreshnessLifetime() {
-    if (maxAgeSeconds != -1) {
-      return TimeUnit.SECONDS.toMillis(maxAgeSeconds);
-    } else if (expires != null) {
-      long servedMillis = servedDate != null ? servedDate.getTime() : receivedResponseMillis;
-      long delta = expires.getTime() - servedMillis;
-      return delta > 0 ? delta : 0;
-    } else if (lastModified != null && uri.getRawQuery() == null) {
-      // As recommended by the HTTP RFC and implemented in Firefox, the
-      // max age of a document should be defaulted to 10% of the
-      // document's age at the time it was served. Default expiration
-      // dates aren't used for URIs containing a query.
-      long servedMillis = servedDate != null ? servedDate.getTime() : sentRequestMillis;
-      long delta = servedMillis - lastModified.getTime();
-      return delta > 0 ? (delta / 10) : 0;
-    }
-    return 0;
-  }
-
-  /**
-   * Returns true if computeFreshnessLifetime used a heuristic. If we used a
-   * heuristic to serve a cached response older than 24 hours, we are required
-   * to attach a warning.
-   */
-  private boolean isFreshnessLifetimeHeuristic() {
-    return maxAgeSeconds == -1 && expires == null;
-  }
-
-  /**
-   * Returns true if this response can be stored to later serve another
-   * request.
-   */
-  public boolean isCacheable(RequestHeaders request) {
-    // Always go to network for uncacheable response codes (RFC 2616, 13.4),
-    // This implementation doesn't support caching partial content.
-    int responseCode = headers.getResponseCode();
-    if (responseCode != HttpURLConnection.HTTP_OK
-        && responseCode != HttpURLConnection.HTTP_NOT_AUTHORITATIVE
-        && responseCode != HttpURLConnection.HTTP_MULT_CHOICE
-        && responseCode != HttpURLConnection.HTTP_MOVED_PERM
-        && responseCode != HttpURLConnection.HTTP_GONE) {
-      return false;
-    }
-
-    // Responses to authorized requests aren't cacheable unless they include
-    // a 'public', 'must-revalidate' or 's-maxage' directive.
-    if (request.hasAuthorization() && !isPublic && !mustRevalidate && sMaxAgeSeconds == -1) {
-      return false;
-    }
-
-    if (noStore) {
-      return false;
-    }
-
-    return true;
-  }
-
-  /**
-   * Returns true if a Vary header contains an asterisk. Such responses cannot
-   * be cached.
-   */
-  public boolean hasVaryAll() {
-    return varyFields.contains("*");
-  }
-
-  /**
-   * Returns true if none of the Vary headers on this response have changed
-   * between {@code cachedRequest} and {@code newRequest}.
-   */
-  public boolean varyMatches(Map<String, List<String>> cachedRequest,
-      Map<String, List<String>> newRequest) {
-    for (String field : varyFields) {
-      if (!equal(cachedRequest.get(field), newRequest.get(field))) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  /** Returns the source to satisfy {@code request} given this cached response. */
-  public ResponseSource chooseResponseSource(long nowMillis, RequestHeaders request) {
-    // If this response shouldn't have been stored, it should never be used
-    // as a response source. This check should be redundant as long as the
-    // persistence store is well-behaved and the rules are constant.
-    if (!isCacheable(request)) {
-      return ResponseSource.NETWORK;
-    }
-
-    if (request.isNoCache() || request.hasConditions()) {
-      return ResponseSource.NETWORK;
-    }
-
-    long ageMillis = computeAge(nowMillis);
-    long freshMillis = computeFreshnessLifetime();
-
-    if (request.getMaxAgeSeconds() != -1) {
-      freshMillis = Math.min(freshMillis, TimeUnit.SECONDS.toMillis(request.getMaxAgeSeconds()));
-    }
-
-    long minFreshMillis = 0;
-    if (request.getMinFreshSeconds() != -1) {
-      minFreshMillis = TimeUnit.SECONDS.toMillis(request.getMinFreshSeconds());
-    }
-
-    long maxStaleMillis = 0;
-    if (!mustRevalidate && request.getMaxStaleSeconds() != -1) {
-      maxStaleMillis = TimeUnit.SECONDS.toMillis(request.getMaxStaleSeconds());
-    }
-
-    if (!noCache && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
-      if (ageMillis + minFreshMillis >= freshMillis) {
-        headers.add("Warning", "110 HttpURLConnection \"Response is stale\"");
-      }
-      long oneDayMillis = 24 * 60 * 60 * 1000L;
-      if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
-        headers.add("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
-      }
-      return ResponseSource.CACHE;
-    }
-
-    if (lastModified != null) {
-      request.setIfModifiedSince(lastModified);
-    } else if (servedDate != null) {
-      request.setIfModifiedSince(servedDate);
-    }
-
-    if (etag != null) {
-      request.setIfNoneMatch(etag);
-    }
-
-    return request.hasConditions() ? ResponseSource.CONDITIONAL_CACHE : ResponseSource.NETWORK;
-  }
-
-  /**
-   * Returns true if this cached response should be used; false if the
-   * network response should be used.
-   */
-  public boolean validate(ResponseHeaders networkResponse) {
-    if (networkResponse.headers.getResponseCode() == HttpURLConnection.HTTP_NOT_MODIFIED) {
-      return true;
-    }
-
-    // The HTTP spec says that if the network's response is older than our
-    // cached response, we may return the cache's response. Like Chrome (but
-    // unlike Firefox), this client prefers to return the newer response.
-    if (lastModified != null
-        && networkResponse.lastModified != null
-        && networkResponse.lastModified.getTime() < lastModified.getTime()) {
-      return true;
-    }
-
-    return false;
-  }
-
-  /**
-   * Combines this cached header with a network header as defined by RFC 2616,
-   * 13.5.3.
-   */
-  public ResponseHeaders combine(ResponseHeaders network) throws IOException {
-    RawHeaders result = new RawHeaders();
-    result.setStatusLine(headers.getStatusLine());
-
-    for (int i = 0; i < headers.length(); i++) {
-      String fieldName = headers.getFieldName(i);
-      String value = headers.getValue(i);
-      if ("Warning".equals(fieldName) && value.startsWith("1")) {
-        continue; // drop 100-level freshness warnings
-      }
-      if (!isEndToEnd(fieldName) || network.headers.get(fieldName) == null) {
-        result.add(fieldName, value);
-      }
-    }
-
-    for (int i = 0; i < network.headers.length(); i++) {
-      String fieldName = network.headers.getFieldName(i);
-      if (isEndToEnd(fieldName)) {
-        result.add(fieldName, network.headers.getValue(i));
-      }
-    }
-
-    return new ResponseHeaders(uri, result);
-  }
-
-  /**
-   * Returns true if {@code fieldName} is an end-to-end HTTP header, as
-   * defined by RFC 2616, 13.5.1.
-   */
-  private static boolean isEndToEnd(String fieldName) {
-    return !"Connection".equalsIgnoreCase(fieldName)
-        && !"Keep-Alive".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
-        && !"TE".equalsIgnoreCase(fieldName)
-        && !"Trailers".equalsIgnoreCase(fieldName)
-        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
-        && !"Upgrade".equalsIgnoreCase(fieldName);
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableOutputStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
similarity index 57%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableOutputStream.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
index 5eb6b76455..9c50b702fe 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableOutputStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
@@ -16,11 +16,11 @@
 
 package com.squareup.okhttp.internal.http;
 
-import com.squareup.okhttp.internal.AbstractOutputStream;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.OutputStream;
 import java.net.ProtocolException;
+import okio.Buffer;
+import okio.Sink;
+import okio.Timeout;
 
 import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
 
@@ -29,24 +29,21 @@
  * the post body to be transparently re-sent if the HTTP request must be
  * sent multiple times.
  */
-final class RetryableOutputStream extends AbstractOutputStream {
+public final class RetryableSink implements Sink {
+  private boolean closed;
   private final int limit;
-  private final ByteArrayOutputStream content;
+  private final Buffer content = new Buffer();
 
-  public RetryableOutputStream(int limit) {
+  public RetryableSink(int limit) {
     this.limit = limit;
-    this.content = new ByteArrayOutputStream(limit);
   }
 
-  public RetryableOutputStream() {
-    this.limit = -1;
-    this.content = new ByteArrayOutputStream();
+  public RetryableSink() {
+    this(-1);
   }
 
-  @Override public synchronized void close() throws IOException {
-    if (closed) {
-      return;
-    }
+  @Override public void close() throws IOException {
+    if (closed) return;
     closed = true;
     if (content.size() < limit) {
       throw new ProtocolException(
@@ -54,22 +51,29 @@ public RetryableOutputStream() {
     }
   }
 
-  @Override public synchronized void write(byte[] buffer, int offset, int count)
-      throws IOException {
-    checkNotClosed();
-    checkOffsetAndCount(buffer.length, offset, count);
-    if (limit != -1 && content.size() > limit - count) {
+  @Override public void write(Buffer source, long byteCount) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    checkOffsetAndCount(source.size(), 0, byteCount);
+    if (limit != -1 && content.size() > limit - byteCount) {
       throw new ProtocolException("exceeded content-length limit of " + limit + " bytes");
     }
-    content.write(buffer, offset, count);
+    content.write(source, byteCount);
+  }
+
+  @Override public void flush() throws IOException {
+  }
+
+  @Override public Timeout timeout() {
+    return Timeout.NONE;
   }
 
-  public synchronized int contentLength() throws IOException {
-    close();
+  public long contentLength() throws IOException {
     return content.size();
   }
 
-  public void writeToSocket(OutputStream socketOut) throws IOException {
-    content.writeTo(socketOut);
+  public void writeToSocket(Sink socketOut) throws IOException {
+    // Clone the content; otherwise we won't have data to retry.
+    Buffer buffer = content.clone();
+    socketOut.write(buffer, buffer.size());
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
index 1055e4f09f..0700cb955c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
@@ -16,23 +16,32 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Address;
+import com.squareup.okhttp.CertificatePinner;
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.ConnectionSpec;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Route;
-import com.squareup.okhttp.RouteDatabase;
-import com.squareup.okhttp.internal.Dns;
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.Network;
+import com.squareup.okhttp.internal.RouteDatabase;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
-import java.net.ProxySelector;
 import java.net.SocketAddress;
+import java.net.SocketException;
 import java.net.URI;
 import java.net.UnknownHostException;
-import java.util.Iterator;
-import java.util.LinkedList;
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.NoSuchElementException;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLProtocolException;
+import javax.net.ssl.SSLSocketFactory;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
 
@@ -42,99 +51,129 @@
  * recycled.
  */
 public final class RouteSelector {
-  /** Uses {@link com.squareup.okhttp.internal.Platform#enableTlsExtensions}. */
-  private static final int TLS_MODE_MODERN = 1;
-  /** Uses {@link com.squareup.okhttp.internal.Platform#supportTlsIntolerantServer}. */
-  private static final int TLS_MODE_COMPATIBLE = 0;
-  /** No TLS mode. */
-  private static final int TLS_MODE_NULL = -1;
-
   private final Address address;
   private final URI uri;
-  private final ProxySelector proxySelector;
+  private final Network network;
+  private final OkHttpClient client;
   private final ConnectionPool pool;
-  private final Dns dns;
   private final RouteDatabase routeDatabase;
+  private final Request request;
 
   /* The most recently attempted route. */
   private Proxy lastProxy;
   private InetSocketAddress lastInetSocketAddress;
+  private ConnectionSpec lastSpec;
 
   /* State for negotiating the next proxy to use. */
-  private boolean hasNextProxy;
-  private Proxy userSpecifiedProxy;
-  private Iterator<Proxy> proxySelectorProxies;
+  private List<Proxy> proxies = Collections.emptyList();
+  private int nextProxyIndex;
 
-  /* State for negotiating the next InetSocketAddress to use. */
-  private InetAddress[] socketAddresses;
-  private int nextSocketAddressIndex;
-  private int socketPort;
+  /* State for negotiating the next socket address to use. */
+  private List<InetSocketAddress> inetSocketAddresses = Collections.emptyList();
+  private int nextInetSocketAddressIndex;
 
-  /* State for negotiating the next TLS configuration */
-  private int nextTlsMode = TLS_MODE_NULL;
+  /* Specs to attempt with the connection. */
+  private List<ConnectionSpec> connectionSpecs = Collections.emptyList();
+  private int nextSpecIndex;
 
   /* State for negotiating failed routes */
-  private final List<Route> postponedRoutes;
+  private final List<Route> postponedRoutes = new ArrayList<>();
 
-  public RouteSelector(Address address, URI uri, ProxySelector proxySelector, ConnectionPool pool,
-      Dns dns, RouteDatabase routeDatabase) {
+  private RouteSelector(Address address, URI uri, OkHttpClient client, Request request) {
     this.address = address;
     this.uri = uri;
-    this.proxySelector = proxySelector;
-    this.pool = pool;
-    this.dns = dns;
-    this.routeDatabase = routeDatabase;
-    this.postponedRoutes = new LinkedList<Route>();
+    this.client = client;
+    this.pool = client.getConnectionPool();
+    this.routeDatabase = Internal.instance.routeDatabase(client);
+    this.network = Internal.instance.network(client);
+    this.request = request;
 
     resetNextProxy(uri, address.getProxy());
   }
 
+  public static RouteSelector get(Request request, OkHttpClient client) throws IOException {
+    String uriHost = request.url().getHost();
+    if (uriHost == null || uriHost.length() == 0) {
+      throw new UnknownHostException(request.url().toString());
+    }
+
+    SSLSocketFactory sslSocketFactory = null;
+    HostnameVerifier hostnameVerifier = null;
+    CertificatePinner certificatePinner = null;
+    if (request.isHttps()) {
+      sslSocketFactory = client.getSslSocketFactory();
+      hostnameVerifier = client.getHostnameVerifier();
+      certificatePinner = client.getCertificatePinner();
+    }
+
+    Address address = new Address(uriHost, getEffectivePort(request.url()),
+        client.getSocketFactory(), sslSocketFactory, hostnameVerifier, certificatePinner,
+        client.getAuthenticator(), client.getProxy(), client.getProtocols(),
+        client.getConnectionSpecs(), client.getProxySelector());
+
+    return new RouteSelector(address, request.uri(), client, request);
+  }
+
   /**
    * Returns true if there's another route to attempt. Every address has at
    * least one route.
    */
   public boolean hasNext() {
-    return hasNextTlsMode() || hasNextInetSocketAddress() || hasNextProxy() || hasNextPostponed();
+    return hasNextConnectionSpec()
+        || hasNextInetSocketAddress()
+        || hasNextProxy()
+        || hasNextPostponed();
+  }
+
+  /** Selects a route to attempt and connects it if it isn't already. */
+  public Connection next(HttpEngine owner) throws IOException {
+    Connection connection = nextUnconnected();
+    Internal.instance.connectAndSetOwner(client, connection, owner, request);
+    return connection;
   }
 
   /**
-   * Returns the next route address to attempt.
+   * Returns the next connection to attempt.
    *
    * @throws NoSuchElementException if there are no more routes to attempt.
    */
-  public Connection next(String method) throws IOException {
+  Connection nextUnconnected() throws IOException {
     // Always prefer pooled connections over new connections.
     for (Connection pooled; (pooled = pool.get(address)) != null; ) {
-      if (method.equals("GET") || pooled.isReadable()) return pooled;
-      pooled.close();
+      if (request.method().equals("GET") || Internal.instance.isReadable(pooled)) return pooled;
+      pooled.getSocket().close();
     }
 
     // Compute the next route to attempt.
-    if (!hasNextTlsMode()) {
+    if (!hasNextConnectionSpec()) {
       if (!hasNextInetSocketAddress()) {
         if (!hasNextProxy()) {
           if (!hasNextPostponed()) {
             throw new NoSuchElementException();
           }
-          return new Connection(nextPostponed());
+          return new Connection(pool, nextPostponed());
         }
         lastProxy = nextProxy();
-        resetNextInetSocketAddress(lastProxy);
       }
       lastInetSocketAddress = nextInetSocketAddress();
-      resetNextTlsMode();
     }
+    lastSpec = nextConnectionSpec();
 
-    boolean modernTls = nextTlsMode() == TLS_MODE_MODERN;
-    Route route = new Route(address, lastProxy, lastInetSocketAddress, modernTls);
+    final boolean shouldSendTlsFallbackIndicator = shouldSendTlsFallbackIndicator(lastSpec);
+    Route route = new Route(address, lastProxy, lastInetSocketAddress, lastSpec,
+        shouldSendTlsFallbackIndicator);
     if (routeDatabase.shouldPostpone(route)) {
       postponedRoutes.add(route);
-      // We will only recurse in order to skip previously failed routes. They will be
-      // tried last.
-      return next(method);
+      // We will only recurse in order to skip previously failed routes. They will be tried last.
+      return nextUnconnected();
     }
 
-    return new Connection(route);
+    return new Connection(pool, route);
+  }
+
+  private boolean shouldSendTlsFallbackIndicator(ConnectionSpec connectionSpec) {
+    return connectionSpec != connectionSpecs.get(0)
+        && connectionSpec.isTls();
   }
 
   /**
@@ -142,64 +181,75 @@ public Connection next(String method) throws IOException {
    * failure on a connection returned by this route selector.
    */
   public void connectFailed(Connection connection, IOException failure) {
+    // If this is a recycled connection, don't count its failure against the route.
+    if (Internal.instance.recycleCount(connection) > 0) return;
+
     Route failedRoute = connection.getRoute();
-    if (failedRoute.getProxy().type() != Proxy.Type.DIRECT && proxySelector != null) {
+    if (failedRoute.getProxy().type() != Proxy.Type.DIRECT && address.getProxySelector() != null) {
       // Tell the proxy selector when we fail to connect on a fresh connection.
-      proxySelector.connectFailed(uri, failedRoute.getProxy().address(), failure);
+      address.getProxySelector().connectFailed(uri, failedRoute.getProxy().address(), failure);
     }
 
-    routeDatabase.failed(failedRoute, failure);
+    routeDatabase.failed(failedRoute);
+
+    // If the previously returned route's problem was not related to the connection's spec, and the
+    // next route only changes that, we shouldn't even attempt it. This suppresses it in both this
+    // selector and also in the route database.
+    if (!(failure instanceof SSLHandshakeException) && !(failure instanceof SSLProtocolException)) {
+      while (nextSpecIndex < connectionSpecs.size()) {
+        ConnectionSpec connectionSpec = connectionSpecs.get(nextSpecIndex++);
+        final boolean shouldSendTlsFallbackIndicator =
+            shouldSendTlsFallbackIndicator(connectionSpec);
+        Route toSuppress = new Route(address, lastProxy, lastInetSocketAddress, connectionSpec,
+            shouldSendTlsFallbackIndicator);
+        routeDatabase.failed(toSuppress);
+      }
+    }
   }
 
-  /** Resets {@link #nextProxy} to the first option. */
+  /** Prepares the proxy servers to try. */
   private void resetNextProxy(URI uri, Proxy proxy) {
-    this.hasNextProxy = true; // This includes NO_PROXY!
     if (proxy != null) {
-      this.userSpecifiedProxy = proxy;
+      // If the user specifies a proxy, try that and only that.
+      proxies = Collections.singletonList(proxy);
     } else {
-      List<Proxy> proxyList = proxySelector.select(uri);
-      if (proxyList != null) {
-        this.proxySelectorProxies = proxyList.iterator();
-      }
+      // Try each of the ProxySelector choices until one connection succeeds. If none succeed
+      // then we'll try a direct connection below.
+      proxies = new ArrayList<>();
+      List<Proxy> selectedProxies = client.getProxySelector().select(uri);
+      if (selectedProxies != null) proxies.addAll(selectedProxies);
+      // Finally try a direct connection. We only try it once!
+      proxies.removeAll(Collections.singleton(Proxy.NO_PROXY));
+      proxies.add(Proxy.NO_PROXY);
     }
+    nextProxyIndex = 0;
   }
 
   /** Returns true if there's another proxy to try. */
   private boolean hasNextProxy() {
-    return hasNextProxy;
+    return nextProxyIndex < proxies.size();
   }
 
   /** Returns the next proxy to try. May be PROXY.NO_PROXY but never null. */
-  private Proxy nextProxy() {
-    // If the user specifies a proxy, try that and only that.
-    if (userSpecifiedProxy != null) {
-      hasNextProxy = false;
-      return userSpecifiedProxy;
+  private Proxy nextProxy() throws IOException {
+    if (!hasNextProxy()) {
+      throw new SocketException("No route to " + address.getUriHost()
+          + "; exhausted proxy configurations: " + proxies);
     }
-
-    // Try each of the ProxySelector choices until one connection succeeds. If none succeed
-    // then we'll try a direct connection below.
-    if (proxySelectorProxies != null) {
-      while (proxySelectorProxies.hasNext()) {
-        Proxy candidate = proxySelectorProxies.next();
-        if (candidate.type() != Proxy.Type.DIRECT) {
-          return candidate;
-        }
-      }
-    }
-
-    // Finally try a direct connection.
-    hasNextProxy = false;
-    return Proxy.NO_PROXY;
+    Proxy result = proxies.get(nextProxyIndex++);
+    resetNextInetSocketAddress(result);
+    return result;
   }
 
-  /** Resets {@link #nextInetSocketAddress} to the first option. */
+  /** Prepares the socket addresses to attempt for the current proxy or host. */
   private void resetNextInetSocketAddress(Proxy proxy) throws UnknownHostException {
-    socketAddresses = null; // Clear the addresses. Necessary if getAllByName() below throws!
+    // Clear the addresses. Necessary if getAllByName() below throws!
+    inetSocketAddresses = new ArrayList<>();
 
     String socketHost;
-    if (proxy.type() == Proxy.Type.DIRECT) {
-      socketHost = uri.getHost();
+    int socketPort;
+    if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) {
+      socketHost = address.getUriHost();
       socketPort = getEffectivePort(uri);
     } else {
       SocketAddress proxyAddress = proxy.address();
@@ -208,53 +258,76 @@ private void resetNextInetSocketAddress(Proxy proxy) throws UnknownHostException
             "Proxy.address() is not an " + "InetSocketAddress: " + proxyAddress.getClass());
       }
       InetSocketAddress proxySocketAddress = (InetSocketAddress) proxyAddress;
-      socketHost = proxySocketAddress.getHostName();
+      socketHost = getHostString(proxySocketAddress);
       socketPort = proxySocketAddress.getPort();
     }
 
     // Try each address for best behavior in mixed IPv4/IPv6 environments.
-    socketAddresses = dns.getAllByName(socketHost);
-    nextSocketAddressIndex = 0;
+    for (InetAddress inetAddress : network.resolveInetAddresses(socketHost)) {
+      inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
+    }
+    nextInetSocketAddressIndex = 0;
+  }
+
+  /**
+   * Obtain a "host" from an {@link InetSocketAddress}. This returns a string containing either an
+   * actual host name or a numeric IP address.
+   */
+  // Visible for testing
+  static String getHostString(InetSocketAddress socketAddress) {
+    InetAddress address = socketAddress.getAddress();
+    if (address == null) {
+      // The InetSocketAddress was specified with a string (either a numeric IP or a host name). If
+      // it is a name, all IPs for that name should be tried. If it is an IP address, only that IP
+      // address should be tried.
+      return socketAddress.getHostName();
+    }
+    // The InetSocketAddress has a specific address: we should only try that address. Therefore we
+    // return the address and ignore any host name that may be available.
+    return address.getHostAddress();
   }
 
   /** Returns true if there's another socket address to try. */
   private boolean hasNextInetSocketAddress() {
-    return socketAddresses != null;
+    return nextInetSocketAddressIndex < inetSocketAddresses.size();
   }
 
   /** Returns the next socket address to try. */
-  private InetSocketAddress nextInetSocketAddress() throws UnknownHostException {
-    InetSocketAddress result =
-        new InetSocketAddress(socketAddresses[nextSocketAddressIndex++], socketPort);
-    if (nextSocketAddressIndex == socketAddresses.length) {
-      socketAddresses = null; // So that hasNextInetSocketAddress() returns false.
-      nextSocketAddressIndex = 0;
+  private InetSocketAddress nextInetSocketAddress() throws IOException {
+    if (!hasNextInetSocketAddress()) {
+      throw new SocketException("No route to " + address.getUriHost()
+          + "; exhausted inet socket addresses: " + inetSocketAddresses);
     }
-
+    InetSocketAddress result = inetSocketAddresses.get(nextInetSocketAddressIndex++);
+    resetConnectionSpecs();
     return result;
   }
 
-  /** Resets {@link #nextTlsMode} to the first option. */
-  private void resetNextTlsMode() {
-    nextTlsMode = (address.getSslSocketFactory() != null) ? TLS_MODE_MODERN : TLS_MODE_COMPATIBLE;
+  /** Prepares the connection specs to attempt. */
+  private void resetConnectionSpecs() {
+    connectionSpecs = new ArrayList<>();
+    List<ConnectionSpec> specs = address.getConnectionSpecs();
+    for (int i = 0, size = specs.size(); i < size; i++) {
+      ConnectionSpec spec = specs.get(i);
+      if (request.isHttps() == spec.isTls()) {
+        connectionSpecs.add(spec);
+      }
+    }
+    nextSpecIndex = 0;
   }
 
-  /** Returns true if there's another TLS mode to try. */
-  private boolean hasNextTlsMode() {
-    return nextTlsMode != TLS_MODE_NULL;
+  /** Returns true if there's another connection spec to try. */
+  private boolean hasNextConnectionSpec() {
+    return nextSpecIndex < connectionSpecs.size();
   }
 
-  /** Returns the next TLS mode to try. */
-  private int nextTlsMode() {
-    if (nextTlsMode == TLS_MODE_MODERN) {
-      nextTlsMode = TLS_MODE_COMPATIBLE;
-      return TLS_MODE_MODERN;
-    } else if (nextTlsMode == TLS_MODE_COMPATIBLE) {
-      nextTlsMode = TLS_MODE_NULL;  // So that hasNextTlsMode() returns false.
-      return TLS_MODE_COMPATIBLE;
-    } else {
-      throw new AssertionError();
+  /** Returns the next connection spec to try. */
+  private ConnectionSpec nextConnectionSpec() throws IOException {
+    if (!hasNextConnectionSpec()) {
+      throw new SocketException("No route to " + address.getUriHost()
+          + "; exhausted connection specs: " + connectionSpecs);
     }
+    return connectionSpecs.get(nextSpecIndex++);
   }
 
   /** Returns true if there is another postponed route to try. */
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index fce58f4742..61b6610810 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -16,17 +16,56 @@
 
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
+import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.spdy.ErrorCode;
+import com.squareup.okhttp.internal.spdy.Header;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.CacheRequest;
-import java.net.URL;
+import java.net.ProtocolException;
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import okio.ByteString;
+import okio.Okio;
+import okio.Sink;
+
+import static com.squareup.okhttp.internal.spdy.Header.RESPONSE_STATUS;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_AUTHORITY;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_HOST;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_METHOD;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_PATH;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_SCHEME;
+import static com.squareup.okhttp.internal.spdy.Header.VERSION;
 
 public final class SpdyTransport implements Transport {
+  /** See http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1#TOC-3.2.1-Request. */
+  private static final List<ByteString> SPDY_3_PROHIBITED_HEADERS = Util.immutableList(
+      ByteString.encodeUtf8("connection"),
+      ByteString.encodeUtf8("host"),
+      ByteString.encodeUtf8("keep-alive"),
+      ByteString.encodeUtf8("proxy-connection"),
+      ByteString.encodeUtf8("transfer-encoding"));
+
+  /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
+  private static final List<ByteString> HTTP_2_PROHIBITED_HEADERS = Util.immutableList(
+      ByteString.encodeUtf8("connection"),
+      ByteString.encodeUtf8("host"),
+      ByteString.encodeUtf8("keep-alive"),
+      ByteString.encodeUtf8("proxy-connection"),
+      ByteString.encodeUtf8("te"),
+      ByteString.encodeUtf8("transfer-encoding"),
+      ByteString.encodeUtf8("encoding"),
+      ByteString.encodeUtf8("upgrade"));
+
   private final HttpEngine httpEngine;
   private final SpdyConnection spdyConnection;
   private SpdyStream stream;
@@ -36,64 +75,158 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     this.spdyConnection = spdyConnection;
   }
 
-  @Override public OutputStream createRequestBody() throws IOException {
-    // TODO: if we aren't streaming up to the server, we should buffer the whole request
-    writeRequestHeaders();
-    return stream.getOutputStream();
+  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
+    return stream.getSink();
   }
 
-  @Override public void writeRequestHeaders() throws IOException {
-    if (stream != null) {
-      return;
-    }
+  @Override public void writeRequestHeaders(Request request) throws IOException {
+    if (stream != null) return;
+
     httpEngine.writingRequestHeaders();
-    RawHeaders requestHeaders = httpEngine.requestHeaders.getHeaders();
-    String version = httpEngine.connection.getHttpMinorVersion() == 1 ? "HTTP/1.1" : "HTTP/1.0";
-    URL url = httpEngine.policy.getURL();
-    requestHeaders.addSpdyRequestHeaders(httpEngine.method, HttpEngine.requestPath(url), version,
-        HttpEngine.getOriginAddress(url), httpEngine.uri.getScheme());
-    boolean hasRequestBody = httpEngine.hasRequestBody();
+    boolean permitsRequestBody = httpEngine.permitsRequestBody();
     boolean hasResponseBody = true;
-    stream = spdyConnection.newStream(requestHeaders.toNameValueBlock(), hasRequestBody,
+    String version = RequestLine.version(httpEngine.getConnection().getProtocol());
+    stream = spdyConnection.newStream(
+        writeNameValueBlock(request, spdyConnection.getProtocol(), version), permitsRequestBody,
         hasResponseBody);
-    stream.setReadTimeout(httpEngine.client.getReadTimeout());
+    stream.readTimeout().timeout(httpEngine.client.getReadTimeout(), TimeUnit.MILLISECONDS);
+  }
+
+  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
+    requestBody.writeToSocket(stream.getSink());
   }
 
-  @Override public void writeRequestBody(RetryableOutputStream requestBody) throws IOException {
-    throw new UnsupportedOperationException();
+  @Override public void finishRequest() throws IOException {
+    stream.getSink().close();
   }
 
-  @Override public void flushRequest() throws IOException {
-    stream.getOutputStream().close();
+  @Override public Response.Builder readResponseHeaders() throws IOException {
+    return readNameValueBlock(stream.getResponseHeaders(), spdyConnection.getProtocol());
   }
 
-  @Override public ResponseHeaders readResponseHeaders() throws IOException {
-    List<String> nameValueBlock = stream.getResponseHeaders();
-    RawHeaders rawHeaders = RawHeaders.fromNameValueBlock(nameValueBlock);
-    httpEngine.receiveHeaders(rawHeaders);
+  /**
+   * Returns a list of alternating names and values containing a SPDY request.
+   * Names are all lowercase. No names are repeated. If any name has multiple
+   * values, they are concatenated using "\0" as a delimiter.
+   */
+  public static List<Header> writeNameValueBlock(Request request, Protocol protocol,
+      String version) {
+    Headers headers = request.headers();
+    List<Header> result = new ArrayList<>(headers.size() + 10);
+    result.add(new Header(TARGET_METHOD, request.method()));
+    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
+    String host = HttpEngine.hostHeader(request.url());
+    if (Protocol.SPDY_3 == protocol) {
+      result.add(new Header(VERSION, version));
+      result.add(new Header(TARGET_HOST, host));
+    } else if (Protocol.HTTP_2 == protocol) {
+      result.add(new Header(TARGET_AUTHORITY, host)); // Optional in HTTP/2
+    } else {
+      throw new AssertionError();
+    }
+    result.add(new Header(TARGET_SCHEME, request.url().getProtocol()));
 
-    ResponseHeaders headers = new ResponseHeaders(httpEngine.uri, rawHeaders);
-    headers.setTransport("spdy/3");
-    return headers;
+    Set<ByteString> names = new LinkedHashSet<ByteString>();
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      // header names must be lowercase.
+      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
+      String value = headers.value(i);
+
+      // Drop headers that are forbidden when layering HTTP over SPDY.
+      if (isProhibitedHeader(protocol, name)) continue;
+
+      // They shouldn't be set, but if they are, drop them. We've already written them!
+      if (name.equals(TARGET_METHOD)
+          || name.equals(TARGET_PATH)
+          || name.equals(TARGET_SCHEME)
+          || name.equals(TARGET_AUTHORITY)
+          || name.equals(TARGET_HOST)
+          || name.equals(VERSION)) {
+        continue;
+      }
+
+      // If we haven't seen this name before, add the pair to the end of the list...
+      if (names.add(name)) {
+        result.add(new Header(name, value));
+        continue;
+      }
+
+      // ...otherwise concatenate the existing values and this value.
+      for (int j = 0; j < result.size(); j++) {
+        if (result.get(j).name.equals(name)) {
+          String concatenated = joinOnNull(result.get(j).value.utf8(), value);
+          result.set(j, new Header(name, concatenated));
+          break;
+        }
+      }
+    }
+    return result;
   }
 
-  @Override public InputStream getTransferStream(CacheRequest cacheRequest) throws IOException {
-    return new UnknownLengthHttpInputStream(stream.getInputStream(), cacheRequest, httpEngine);
+  private static String joinOnNull(String first, String second) {
+    return new StringBuilder(first).append('\0').append(second).toString();
   }
 
-  @Override public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
-      InputStream responseBodyIn) {
-    if (streamCanceled) {
-      if (stream != null) {
-        stream.closeLater(ErrorCode.CANCEL);
-        return true;
-      } else {
-        // If stream is null, it either means that writeRequestHeaders wasn't called
-        // or that SpdyConnection#newStream threw an IOException. In both cases there's
-        // nothing to do here and this stream can't be reused.
-        return false;
+  /** Returns headers for a name value block containing a SPDY response. */
+  public static Response.Builder readNameValueBlock(List<Header> headerBlock,
+      Protocol protocol) throws IOException {
+    String status = null;
+    String version = "HTTP/1.1"; // :version present only in spdy/3.
+
+    Headers.Builder headersBuilder = new Headers.Builder();
+    headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.toString());
+    for (int i = 0, size = headerBlock.size(); i < size; i++) {
+      ByteString name = headerBlock.get(i).name;
+      String values = headerBlock.get(i).value.utf8();
+      for (int start = 0; start < values.length(); ) {
+        int end = values.indexOf('\0', start);
+        if (end == -1) {
+          end = values.length();
+        }
+        String value = values.substring(start, end);
+        if (name.equals(RESPONSE_STATUS)) {
+          status = value;
+        } else if (name.equals(VERSION)) {
+          version = value;
+        } else if (!isProhibitedHeader(protocol, name)) { // Don't write forbidden headers!
+          headersBuilder.add(name.utf8(), value);
+        }
+        start = end + 1;
       }
     }
-    return true;
+    if (status == null) throw new ProtocolException("Expected ':status' header not present");
+
+    StatusLine statusLine = StatusLine.parse(version + " " + status);
+    return new Response.Builder()
+        .protocol(protocol)
+        .code(statusLine.code)
+        .message(statusLine.message)
+        .headers(headersBuilder.build());
+  }
+
+  @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    return new RealResponseBody(response.headers(), Okio.buffer(stream.getSource()));
+  }
+
+  @Override public void releaseConnectionOnIdle() {
+  }
+
+  @Override public void disconnect(HttpEngine engine) throws IOException {
+    if (stream != null) stream.close(ErrorCode.CANCEL);
+  }
+
+  @Override public boolean canReuseConnection() {
+    return true; // TODO: spdyConnection.isClosed() ?
+  }
+
+  /** When true, this header should not be emitted or consumed. */
+  private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
+    if (protocol == Protocol.SPDY_3) {
+      return SPDY_3_PROHIBITED_HEADERS.contains(name);
+    } else if (protocol == Protocol.HTTP_2) {
+      return HTTP_2_PROHIBITED_HEADERS.contains(name);
+    } else {
+      throw new AssertionError(protocol);
+    }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
new file mode 100644
index 0000000000..ab9ebc1535
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
@@ -0,0 +1,90 @@
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.net.ProtocolException;
+
+/** An HTTP response status line like "HTTP/1.1 200 OK". */
+public final class StatusLine {
+  /** Numeric status code, 307: Temporary Redirect. */
+  public static final int HTTP_TEMP_REDIRECT = 307;
+  public static final int HTTP_PERM_REDIRECT = 308;
+  public static final int HTTP_CONTINUE = 100;
+
+  public final Protocol protocol;
+  public final int code;
+  public final String message;
+
+  public StatusLine(Protocol protocol, int code, String message) {
+    this.protocol = protocol;
+    this.code = code;
+    this.message = message;
+  }
+
+  public static StatusLine get(Response response) {
+    return new StatusLine(response.protocol(), response.code(), response.message());
+  }
+
+  public static StatusLine parse(String statusLine) throws IOException {
+    // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
+    // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
+
+    // Parse protocol like "HTTP/1.1" followed by a space.
+    int codeStart;
+    Protocol protocol;
+    if (statusLine.startsWith("HTTP/1.")) {
+      if (statusLine.length() < 9 || statusLine.charAt(8) != ' ') {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+      int httpMinorVersion = statusLine.charAt(7) - '0';
+      codeStart = 9;
+      if (httpMinorVersion == 0) {
+        protocol = Protocol.HTTP_1_0;
+      } else if (httpMinorVersion == 1) {
+        protocol = Protocol.HTTP_1_1;
+      } else {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+    } else if (statusLine.startsWith("ICY ")) {
+      // Shoutcast uses ICY instead of "HTTP/1.0".
+      protocol = Protocol.HTTP_1_0;
+      codeStart = 4;
+    } else {
+      throw new ProtocolException("Unexpected status line: " + statusLine);
+    }
+
+    // Parse response code like "200". Always 3 digits.
+    if (statusLine.length() < codeStart + 3) {
+      throw new ProtocolException("Unexpected status line: " + statusLine);
+    }
+    int code;
+    try {
+      code = Integer.parseInt(statusLine.substring(codeStart, codeStart + 3));
+    } catch (NumberFormatException e) {
+      throw new ProtocolException("Unexpected status line: " + statusLine);
+    }
+
+    // Parse an optional response message like "OK" or "Not Modified". If it
+    // exists, it is separated from the response code by a space.
+    String message = "";
+    if (statusLine.length() > codeStart + 3) {
+      if (statusLine.charAt(codeStart + 3) != ' ') {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+      message = statusLine.substring(codeStart + 4);
+    }
+
+    return new StatusLine(protocol, code, message);
+  }
+
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder();
+    result.append(protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1");
+    result.append(' ').append(code);
+    if (message != null) {
+      result.append(' ').append(message);
+    }
+    return result.toString();
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
index d408bfec03..77f7c9e746 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
@@ -16,49 +16,52 @@
 
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.CacheRequest;
+import okio.Sink;
 
-interface Transport {
+public interface Transport {
   /**
-   * Returns an output stream where the request body can be written. The
-   * returned stream will of one of two types:
-   * <ul>
-   * <li><strong>Direct.</strong> Bytes are written to the socket and
-   * forgotten. This is most efficient, particularly for large request
-   * bodies. The returned stream may be buffered; the caller must call
-   * {@link #flushRequest} before reading the response.</li>
-   * <li><strong>Buffered.</strong> Bytes are written to an in memory
-   * buffer, and must be explicitly flushed with a call to {@link
-   * #writeRequestBody}. This allows HTTP authorization (401, 407)
-   * responses to be retransmitted transparently.</li>
-   * </ul>
+   * The timeout to use while discarding a stream of input data. Since this is
+   * used for connection reuse, this timeout should be significantly less than
+   * the time it takes to establish a new connection.
    */
-  // TODO: don't bother retransmitting the request body? It's quite a corner
-  // case and there's uncertainty whether Firefox or Chrome do this
-  OutputStream createRequestBody() throws IOException;
+  int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
+
+  /** Returns an output stream where the request body can be streamed. */
+  Sink createRequestBody(Request request, long contentLength) throws IOException;
 
   /** This should update the HTTP engine's sentRequestMillis field. */
-  void writeRequestHeaders() throws IOException;
+  void writeRequestHeaders(Request request) throws IOException;
 
   /**
    * Sends the request body returned by {@link #createRequestBody} to the
    * remote peer.
    */
-  void writeRequestBody(RetryableOutputStream requestBody) throws IOException;
+  void writeRequestBody(RetryableSink requestBody) throws IOException;
+
+  /** Flush the request to the underlying socket. */
+  void finishRequest() throws IOException;
 
-  /** Flush the request body to the underlying socket. */
-  void flushRequest() throws IOException;
+  /** Read and return response headers. */
+  Response.Builder readResponseHeaders() throws IOException;
 
-  /** Read response headers and update the cookie manager. */
-  ResponseHeaders readResponseHeaders() throws IOException;
+  /** Returns a stream that reads the response body. */
+  ResponseBody openResponseBody(Response response) throws IOException;
 
-  // TODO: make this the content stream?
-  InputStream getTransferStream(CacheRequest cacheRequest) throws IOException;
+  /**
+   * Configures the response body to pool or close the socket connection when
+   * the response body is closed.
+   */
+  void releaseConnectionOnIdle() throws IOException;
 
-  /** Returns true if the underlying connection can be recycled. */
-  boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
-      InputStream responseBodyIn);
+  void disconnect(HttpEngine engine) throws IOException;
+
+  /**
+   * Returns true if the socket connection held by this transport can be reused
+   * for a follow-up exchange.
+   */
+  boolean canReuseConnection();
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/UnknownLengthHttpInputStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/UnknownLengthHttpInputStream.java
deleted file mode 100644
index ca6bb59f2e..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/UnknownLengthHttpInputStream.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.CacheRequest;
-
-import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
-
-/** An HTTP message body terminated by the end of the underlying stream. */
-final class UnknownLengthHttpInputStream extends AbstractHttpInputStream {
-  private boolean inputExhausted;
-
-  UnknownLengthHttpInputStream(InputStream in, CacheRequest cacheRequest, HttpEngine httpEngine)
-      throws IOException {
-    super(in, httpEngine, cacheRequest);
-  }
-
-  @Override public int read(byte[] buffer, int offset, int count) throws IOException {
-    checkOffsetAndCount(buffer.length, offset, count);
-    checkNotClosed();
-    if (in == null || inputExhausted) {
-      return -1;
-    }
-    int read = in.read(buffer, offset, count);
-    if (read == -1) {
-      inputExhausted = true;
-      endOfInput();
-      return -1;
-    }
-    cacheWrite(buffer, offset, read);
-    return read;
-  }
-
-  @Override public int available() throws IOException {
-    checkNotClosed();
-    return in == null ? 0 : in.available();
-  }
-
-  @Override public void close() throws IOException {
-    if (closed) {
-      return;
-    }
-    closed = true;
-    if (!inputExhausted) {
-      unexpectedEndOfInput();
-    }
-  }
-}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
similarity index 66%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
index d3a32e1172..b5f46b8bee 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
@@ -1,5 +1,21 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.squareup.okhttp.internal.spdy;
 
+// http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-7
 public enum ErrorCode {
   /** Not an error! For SPDY stream resets, prefer null over NO_ERROR. */
   NO_ERROR(0, -1, 0),
@@ -32,6 +48,14 @@
 
   COMPRESSION_ERROR(9, -1, -1),
 
+  CONNECT_ERROR(10, -1, -1),
+
+  ENHANCE_YOUR_CALM(11, -1, -1),
+
+  INADEQUATE_SECURITY(12, -1, -1),
+
+  HTTP_1_1_REQUIRED(13, -1, -1),
+
   INVALID_CREDENTIALS(-1, 10, -1);
 
   public final int httpCode;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
new file mode 100644
index 0000000000..e3736c5fe4
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.List;
+import okio.BufferedSource;
+import okio.ByteString;
+
+/** Reads transport frames for SPDY/3 or HTTP/2. */
+public interface FrameReader extends Closeable {
+  void readConnectionPreface() throws IOException;
+  boolean nextFrame(Handler handler) throws IOException;
+
+  public interface Handler {
+    void data(boolean inFinished, int streamId, BufferedSource source, int length)
+        throws IOException;
+
+    /**
+     * Create or update incoming headers, creating the corresponding streams
+     * if necessary. Frames that trigger this are SPDY SYN_STREAM, HEADERS, and
+     * SYN_REPLY, and HTTP/2 HEADERS and PUSH_PROMISE.
+     *
+     * @param outFinished true if the receiver should not send further frames.
+     * @param inFinished true if the sender will not send further frames.
+     * @param streamId the stream owning these headers.
+     * @param associatedStreamId the stream that triggered the sender to create
+     *     this stream.
+     */
+    void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
+        List<Header> headerBlock, HeadersMode headersMode);
+    void rstStream(int streamId, ErrorCode errorCode);
+    void settings(boolean clearPrevious, Settings settings);
+
+    /** HTTP/2 only. */
+    void ackSettings();
+
+    /**
+     *  Read a connection-level ping from the peer.  {@code ack} indicates this
+     *  is a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
+     *  <p>
+     *  In SPDY/3, only the first {@code payload1} parameter is set.  If the
+     *  reader is a client, it is an unsigned even number.  Likewise, a server
+     *  will receive an odd number.
+     *  <p>
+     *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
+     *  set. The data is opaque binary, and there are no rules on the content.
+     */
+    void ping(boolean ack, int payload1, int payload2);
+
+    /**
+     * The peer tells us to stop creating streams.  It is safe to replay
+     * streams with {@code ID > lastGoodStreamId} on a new connection.  In-
+     * flight streams with {@code ID <= lastGoodStreamId} can only be replayed
+     * on a new connection if they are idempotent.
+     *
+     * @param lastGoodStreamId the last stream ID the peer processed before
+     *     sending this message. If {@code lastGoodStreamId} is zero, the peer
+     *     processed no frames.
+     * @param errorCode reason for closing the connection.
+     * @param debugData only valid for HTTP/2; opaque debug data to send.
+     */
+    void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData);
+
+    /**
+     * Notifies that an additional {@code windowSizeIncrement} bytes can be
+     * sent on {@code streamId}, or the connection if {@code streamId} is zero.
+     */
+    void windowUpdate(int streamId, long windowSizeIncrement);
+
+    /**
+     * Called when reading a headers or priority frame. This may be used to
+     * change the stream's weight from the default (16) to a new value.
+     *
+     * @param streamId stream which has a priority change.
+     * @param streamDependency the stream ID this stream is dependent on.
+     * @param weight relative proportion of priority in [1..256].
+     * @param exclusive inserts this stream ID as the sole child of
+     *     {@code streamDependency}.
+     */
+    void priority(int streamId, int streamDependency, int weight, boolean exclusive);
+
+    /**
+     * HTTP/2 only. Receive a push promise header block.
+     * <p>
+     * A push promise contains all the headers that pertain to a server-initiated
+     * request, and a {@code promisedStreamId} to which response frames will be
+     * delivered. Push promise frames are sent as a part of the response to
+     * {@code streamId}.
+     *
+     * @param streamId client-initiated stream ID.  Must be an odd number.
+     * @param promisedStreamId server-initiated stream ID.  Must be an even
+     * number.
+     * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
+     * {@code :authority}, and (@code :path}.
+     */
+    void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+        throws IOException;
+
+    /**
+     * HTTP/2 only. Expresses that resources for the connection or a client-
+     * initiated stream are available from a different network location or
+     * protocol configuration.
+     *
+     * <p>See <a href="http://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>
+     *
+     * @param streamId when a client-initiated stream ID (odd number), the
+     *     origin of this alternate service is the origin of the stream. When
+     *     zero, the origin is specified in the {@code origin} parameter.
+     * @param origin when present, the
+     *     <a href="http://tools.ietf.org/html/rfc6454">origin</a> is typically
+     *     represented as a combination of scheme, host and port. When empty,
+     *     the origin is that of the {@code streamId}.
+     * @param protocol an ALPN protocol, such as {@code h2}.
+     * @param host an IP address or hostname.
+     * @param port the IP port associated with the service.
+     * @param maxAge time in seconds that this alternative is considered fresh.
+     */
+    void alternateService(int streamId, String origin, ByteString protocol, String host, int port,
+        long maxAge);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
new file mode 100644
index 0000000000..0f4b799366
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.List;
+import okio.Buffer;
+
+/** Writes transport frames for SPDY/3 or HTTP/2. */
+public interface FrameWriter extends Closeable {
+  /** HTTP/2 only. */
+  void connectionPreface() throws IOException;
+  /** Informs the peer that we've applied its latest settings. */
+  void ackSettings(Settings peerSettings) throws IOException;
+
+  /**
+   * HTTP/2 only. Send a push promise header block.
+   * <p>
+   * A push promise contains all the headers that pertain to a server-initiated
+   * request, and a {@code promisedStreamId} to which response frames will be
+   * delivered. Push promise frames are sent as a part of the response to
+   * {@code streamId}.  The {@code promisedStreamId} has a priority of one
+   * greater than {@code streamId}.
+   *
+   * @param streamId client-initiated stream ID.  Must be an odd number.
+   * @param promisedStreamId server-initiated stream ID.  Must be an even
+   * number.
+   * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
+   * {@code :authority}, and (@code :path}.
+   */
+  void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+      throws IOException;
+
+  /** SPDY/3 only. */
+  void flush() throws IOException;
+  void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
+      List<Header> headerBlock) throws IOException;
+  void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
+      throws IOException;
+  void headers(int streamId, List<Header> headerBlock) throws IOException;
+  void rstStream(int streamId, ErrorCode errorCode) throws IOException;
+
+  /** The maximum size of bytes that may be sent in a single call to {@link #data}. */
+  int maxDataLength();
+
+  /**
+   * {@code source.length} may be longer than the max length of the variant's data frame.
+   * Implementations must send multiple frames as necessary.
+   *
+   * @param source the buffer to draw bytes from. May be null if byteCount is 0.
+   * @param byteCount must be between 0 and the minimum of {code source.length}
+   * and {@link #maxDataLength}.
+   */
+  void data(boolean outFinished, int streamId, Buffer source, int byteCount) throws IOException;
+
+  /** Write okhttp's settings to the peer. */
+  void settings(Settings okHttpSettings) throws IOException;
+
+  /**
+   *  Send a connection-level ping to the peer.  {@code ack} indicates this is
+   *  a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
+   *  <p>
+   *  In SPDY/3, only the first {@code payload1} parameter is sent.  If the
+   *  sender is a client, it is an unsigned odd number.  Likewise, a server
+   *  will send an even number.
+   *  <p>
+   *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
+   *  sent.  The data is opaque binary, and there are no rules on the content.
+   */
+  void ping(boolean ack, int payload1, int payload2) throws IOException;
+
+  /**
+   * Tell the peer to stop creating streams and that we last processed
+   * {@code lastGoodStreamId}, or zero if no streams were processed.
+   *
+   * @param lastGoodStreamId the last stream ID processed, or zero if no
+   * streams were processed.
+   * @param errorCode reason for closing the connection.
+   * @param debugData only valid for HTTP/2; opaque debug data to send.
+   */
+  void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) throws IOException;
+
+  /**
+   * Inform peer that an additional {@code windowSizeIncrement} bytes can be
+   * sent on {@code streamId}, or the connection if {@code streamId} is zero.
+   */
+  void windowUpdate(int streamId, long windowSizeIncrement) throws IOException;
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
new file mode 100644
index 0000000000..d14d13115d
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
@@ -0,0 +1,56 @@
+package com.squareup.okhttp.internal.spdy;
+
+import okio.ByteString;
+
+/** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
+public final class Header {
+  // Special header names defined in the SPDY and HTTP/2 specs.
+  public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(":status");
+  public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(":method");
+  public static final ByteString TARGET_PATH = ByteString.encodeUtf8(":path");
+  public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(":scheme");
+  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority"); // HTTP/2
+  public static final ByteString TARGET_HOST = ByteString.encodeUtf8(":host"); // spdy/3
+  public static final ByteString VERSION = ByteString.encodeUtf8(":version"); // spdy/3
+
+  /** Name in case-insensitive ASCII encoding. */
+  public final ByteString name;
+  /** Value in UTF-8 encoding. */
+  public final ByteString value;
+  final int hpackSize;
+
+  // TODO: search for toLowerCase and consider moving logic here.
+  public Header(String name, String value) {
+    this(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value));
+  }
+
+  public Header(ByteString name, String value) {
+    this(name, ByteString.encodeUtf8(value));
+  }
+
+  public Header(ByteString name, ByteString value) {
+    this.name = name;
+    this.value = value;
+    this.hpackSize = 32 + name.size() + value.size();
+  }
+
+  @Override public boolean equals(Object other) {
+    if (other instanceof Header) {
+      Header that = (Header) other;
+      return this.name.equals(that.name)
+          && this.value.equals(that.value);
+    }
+    return false;
+  }
+
+  @Override public int hashCode() {
+    int result = 17;
+    result = 31 * result + name.hashCode();
+    result = 31 * result + value.hashCode();
+    return result;
+  }
+
+  @Override public String toString() {
+    return String.format("%s: %s", name.utf8(), value.utf8());
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
similarity index 98%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
index e16e176a16..c06327acf4 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
@@ -15,7 +15,7 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-enum HeadersMode {
+public enum HeadersMode {
   SPDY_SYN_STREAM,
   SPDY_REPLY,
   SPDY_HEADERS,
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft10.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft10.java
new file mode 100644
index 0000000000..2e7801533b
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft10.java
@@ -0,0 +1,435 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+import okio.Source;
+
+/**
+ * Read and write HPACK v10.
+ *
+ * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10
+ *
+ * This implementation uses an array for the dynamic table and a list for
+ * indexed entries.  Dynamic entries are added to the array, starting in the
+ * last position moving forward.  When the array fills, it is doubled.
+ */
+final class HpackDraft10 {
+  private static final int PREFIX_4_BITS = 0x0f;
+  private static final int PREFIX_5_BITS = 0x1f;
+  private static final int PREFIX_6_BITS = 0x3f;
+  private static final int PREFIX_7_BITS = 0x7f;
+
+  private static final Header[] STATIC_HEADER_TABLE = new Header[] {
+      new Header(Header.TARGET_AUTHORITY, ""),
+      new Header(Header.TARGET_METHOD, "GET"),
+      new Header(Header.TARGET_METHOD, "POST"),
+      new Header(Header.TARGET_PATH, "/"),
+      new Header(Header.TARGET_PATH, "/index.html"),
+      new Header(Header.TARGET_SCHEME, "http"),
+      new Header(Header.TARGET_SCHEME, "https"),
+      new Header(Header.RESPONSE_STATUS, "200"),
+      new Header(Header.RESPONSE_STATUS, "204"),
+      new Header(Header.RESPONSE_STATUS, "206"),
+      new Header(Header.RESPONSE_STATUS, "304"),
+      new Header(Header.RESPONSE_STATUS, "400"),
+      new Header(Header.RESPONSE_STATUS, "404"),
+      new Header(Header.RESPONSE_STATUS, "500"),
+      new Header("accept-charset", ""),
+      new Header("accept-encoding", "gzip, deflate"),
+      new Header("accept-language", ""),
+      new Header("accept-ranges", ""),
+      new Header("accept", ""),
+      new Header("access-control-allow-origin", ""),
+      new Header("age", ""),
+      new Header("allow", ""),
+      new Header("authorization", ""),
+      new Header("cache-control", ""),
+      new Header("content-disposition", ""),
+      new Header("content-encoding", ""),
+      new Header("content-language", ""),
+      new Header("content-length", ""),
+      new Header("content-location", ""),
+      new Header("content-range", ""),
+      new Header("content-type", ""),
+      new Header("cookie", ""),
+      new Header("date", ""),
+      new Header("etag", ""),
+      new Header("expect", ""),
+      new Header("expires", ""),
+      new Header("from", ""),
+      new Header("host", ""),
+      new Header("if-match", ""),
+      new Header("if-modified-since", ""),
+      new Header("if-none-match", ""),
+      new Header("if-range", ""),
+      new Header("if-unmodified-since", ""),
+      new Header("last-modified", ""),
+      new Header("link", ""),
+      new Header("location", ""),
+      new Header("max-forwards", ""),
+      new Header("proxy-authenticate", ""),
+      new Header("proxy-authorization", ""),
+      new Header("range", ""),
+      new Header("referer", ""),
+      new Header("refresh", ""),
+      new Header("retry-after", ""),
+      new Header("server", ""),
+      new Header("set-cookie", ""),
+      new Header("strict-transport-security", ""),
+      new Header("transfer-encoding", ""),
+      new Header("user-agent", ""),
+      new Header("vary", ""),
+      new Header("via", ""),
+      new Header("www-authenticate", "")
+  };
+
+  private HpackDraft10() {
+  }
+
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-3.1
+  static final class Reader {
+
+    private final List<Header> headerList = new ArrayList<>();
+    private final BufferedSource source;
+
+    private int headerTableSizeSetting;
+    private int maxDynamicTableByteCount;
+    // Visible for testing.
+    Header[] dynamicTable = new Header[8];
+    // Array is populated back to front, so new entries always have lowest index.
+    int nextHeaderIndex = dynamicTable.length - 1;
+    int headerCount = 0;
+    int dynamicTableByteCount = 0;
+
+    Reader(int headerTableSizeSetting, Source source) {
+      this.headerTableSizeSetting = headerTableSizeSetting;
+      this.maxDynamicTableByteCount = headerTableSizeSetting;
+      this.source = Okio.buffer(source);
+    }
+
+    int maxDynamicTableByteCount() {
+      return maxDynamicTableByteCount;
+    }
+
+    /**
+     * Called by the reader when the peer sent {@link Settings#HEADER_TABLE_SIZE}.
+     * While this establishes the maximum dynamic table size, the
+     * {@link #maxDynamicTableByteCount} set during processing may limit the
+     * table size to a smaller amount.
+     * <p> Evicts entries or clears the table as needed.
+     */
+    void headerTableSizeSetting(int headerTableSizeSetting) {
+      this.headerTableSizeSetting = headerTableSizeSetting;
+      this.maxDynamicTableByteCount = headerTableSizeSetting;
+      adjustDynamicTableByteCount();
+    }
+
+    private void adjustDynamicTableByteCount() {
+      if (maxDynamicTableByteCount < dynamicTableByteCount) {
+        if (maxDynamicTableByteCount == 0) {
+          clearDynamicTable();
+        } else {
+          evictToRecoverBytes(dynamicTableByteCount - maxDynamicTableByteCount);
+        }
+      }
+    }
+
+    private void clearDynamicTable() {
+      headerList.clear();
+      Arrays.fill(dynamicTable, null);
+      nextHeaderIndex = dynamicTable.length - 1;
+      headerCount = 0;
+      dynamicTableByteCount = 0;
+    }
+
+    /** Returns the count of entries evicted. */
+    private int evictToRecoverBytes(int bytesToRecover) {
+      int entriesToEvict = 0;
+      if (bytesToRecover > 0) {
+        // determine how many headers need to be evicted.
+        for (int j = dynamicTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
+          bytesToRecover -= dynamicTable[j].hpackSize;
+          dynamicTableByteCount -= dynamicTable[j].hpackSize;
+          headerCount--;
+          entriesToEvict++;
+        }
+        System.arraycopy(dynamicTable, nextHeaderIndex + 1, dynamicTable,
+            nextHeaderIndex + 1 + entriesToEvict, headerCount);
+        nextHeaderIndex += entriesToEvict;
+      }
+      return entriesToEvict;
+    }
+
+    /**
+     * Read {@code byteCount} bytes of headers from the source stream. This
+     * implementation does not propagate the never indexed flag of a header.
+     */
+    void readHeaders() throws IOException {
+      while (!source.exhausted()) {
+        int b = source.readByte() & 0xff;
+        if (b == 0x80) { // 10000000
+          throw new IOException("index == 0");
+        } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
+          int index = readInt(b, PREFIX_7_BITS);
+          readIndexedHeader(index - 1);
+        } else if (b == 0x40) { // 01000000
+          readLiteralHeaderWithIncrementalIndexingNewName();
+        } else if ((b & 0x40) == 0x40) {  // 01NNNNNN
+          int index = readInt(b, PREFIX_6_BITS);
+          readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
+        } else if ((b & 0x20) == 0x20) {  // 001NNNNN
+          maxDynamicTableByteCount = readInt(b, PREFIX_5_BITS);
+          if (maxDynamicTableByteCount < 0
+              || maxDynamicTableByteCount > headerTableSizeSetting) {
+            throw new IOException("Invalid dynamic table size update " + maxDynamicTableByteCount);
+          }
+          adjustDynamicTableByteCount();
+        } else if (b == 0x10 || b == 0) { // 000?0000 - Ignore never indexed bit.
+          readLiteralHeaderWithoutIndexingNewName();
+        } else { // 000?NNNN - Ignore never indexed bit.
+          int index = readInt(b, PREFIX_4_BITS);
+          readLiteralHeaderWithoutIndexingIndexedName(index - 1);
+        }
+      }
+    }
+
+    public List<Header> getAndResetHeaderList() {
+      List<Header> result = new ArrayList<>(headerList);
+      headerList.clear();
+      return result;
+    }
+
+    private void readIndexedHeader(int index) throws IOException {
+      if (isStaticHeader(index)) {
+        Header staticEntry = STATIC_HEADER_TABLE[index];
+        headerList.add(staticEntry);
+      } else {
+        int dynamicTableIndex = dynamicTableIndex(index - STATIC_HEADER_TABLE.length);
+        if (dynamicTableIndex < 0 || dynamicTableIndex > dynamicTable.length - 1) {
+          throw new IOException("Header index too large " + (index + 1));
+        }
+        headerList.add(dynamicTable[dynamicTableIndex]);
+      }
+    }
+
+    // referencedHeaders is relative to nextHeaderIndex + 1.
+    private int dynamicTableIndex(int index) {
+      return nextHeaderIndex + 1 + index;
+    }
+
+    private void readLiteralHeaderWithoutIndexingIndexedName(int index) throws IOException {
+      ByteString name = getName(index);
+      ByteString value = readByteString();
+      headerList.add(new Header(name, value));
+    }
+
+    private void readLiteralHeaderWithoutIndexingNewName() throws IOException {
+      ByteString name = checkLowercase(readByteString());
+      ByteString value = readByteString();
+      headerList.add(new Header(name, value));
+    }
+
+    private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
+        throws IOException {
+      ByteString name = getName(nameIndex);
+      ByteString value = readByteString();
+      insertIntoDynamicTable(-1, new Header(name, value));
+    }
+
+    private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
+      ByteString name = checkLowercase(readByteString());
+      ByteString value = readByteString();
+      insertIntoDynamicTable(-1, new Header(name, value));
+    }
+
+    private ByteString getName(int index) {
+      if (isStaticHeader(index)) {
+        return STATIC_HEADER_TABLE[index].name;
+      } else {
+        return dynamicTable[dynamicTableIndex(index - STATIC_HEADER_TABLE.length)].name;
+      }
+    }
+
+    private boolean isStaticHeader(int index) {
+      return index >= 0 && index <= STATIC_HEADER_TABLE.length - 1;
+    }
+
+    /** index == -1 when new. */
+    private void insertIntoDynamicTable(int index, Header entry) {
+      headerList.add(entry);
+
+      int delta = entry.hpackSize;
+      if (index != -1) { // Index -1 == new header.
+        delta -= dynamicTable[dynamicTableIndex(index)].hpackSize;
+      }
+
+      // if the new or replacement header is too big, drop all entries.
+      if (delta > maxDynamicTableByteCount) {
+        clearDynamicTable();
+        return;
+      }
+
+      // Evict headers to the required length.
+      int bytesToRecover = (dynamicTableByteCount + delta) - maxDynamicTableByteCount;
+      int entriesEvicted = evictToRecoverBytes(bytesToRecover);
+
+      if (index == -1) { // Adding a value to the dynamic table.
+        if (headerCount + 1 > dynamicTable.length) { // Need to grow the dynamic table.
+          Header[] doubled = new Header[dynamicTable.length * 2];
+          System.arraycopy(dynamicTable, 0, doubled, dynamicTable.length, dynamicTable.length);
+          nextHeaderIndex = dynamicTable.length - 1;
+          dynamicTable = doubled;
+        }
+        index = nextHeaderIndex--;
+        dynamicTable[index] = entry;
+        headerCount++;
+      } else { // Replace value at same position.
+        index += dynamicTableIndex(index) + entriesEvicted;
+        dynamicTable[index] = entry;
+      }
+      dynamicTableByteCount += delta;
+    }
+
+    private int readByte() throws IOException {
+      return source.readByte() & 0xff;
+    }
+
+    int readInt(int firstByte, int prefixMask) throws IOException {
+      int prefix = firstByte & prefixMask;
+      if (prefix < prefixMask) {
+        return prefix; // This was a single byte value.
+      }
+
+      // This is a multibyte value. Read 7 bits at a time.
+      int result = prefixMask;
+      int shift = 0;
+      while (true) {
+        int b = readByte();
+        if ((b & 0x80) != 0) { // Equivalent to (b >= 128) since b is in [0..255].
+          result += (b & 0x7f) << shift;
+          shift += 7;
+        } else {
+          result += b << shift; // Last byte.
+          break;
+        }
+      }
+      return result;
+    }
+
+    /** Reads a potentially Huffman encoded byte string. */
+    ByteString readByteString() throws IOException {
+      int firstByte = readByte();
+      boolean huffmanDecode = (firstByte & 0x80) == 0x80; // 1NNNNNNN
+      int length = readInt(firstByte, PREFIX_7_BITS);
+
+      if (huffmanDecode) {
+        return ByteString.of(Huffman.get().decode(source.readByteArray(length)));
+      } else {
+        return source.readByteString(length);
+      }
+    }
+  }
+
+  private static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
+
+  private static Map<ByteString, Integer> nameToFirstIndex() {
+    Map<ByteString, Integer> result = new LinkedHashMap<>(STATIC_HEADER_TABLE.length);
+    for (int i = 0; i < STATIC_HEADER_TABLE.length; i++) {
+      if (!result.containsKey(STATIC_HEADER_TABLE[i].name)) {
+        result.put(STATIC_HEADER_TABLE[i].name, i);
+      }
+    }
+    return Collections.unmodifiableMap(result);
+  }
+
+  static final class Writer {
+    private final Buffer out;
+
+    Writer(Buffer out) {
+      this.out = out;
+    }
+
+    /** This does not use "never indexed" semantics for sensitive headers. */
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-6.2.3
+    void writeHeaders(List<Header> headerBlock) throws IOException {
+      // TODO: implement index tracking
+      for (int i = 0, size = headerBlock.size(); i < size; i++) {
+        ByteString name = headerBlock.get(i).name.toAsciiLowercase();
+        Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);
+        if (staticIndex != null) {
+          // Literal Header Field without Indexing - Indexed Name.
+          writeInt(staticIndex + 1, PREFIX_4_BITS, 0);
+          writeByteString(headerBlock.get(i).value);
+        } else {
+          out.writeByte(0x00); // Literal Header without Indexing - New Name.
+          writeByteString(name);
+          writeByteString(headerBlock.get(i).value);
+        }
+      }
+    }
+
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-4.1.1
+    void writeInt(int value, int prefixMask, int bits) throws IOException {
+      // Write the raw value for a single byte value.
+      if (value < prefixMask) {
+        out.writeByte(bits | value);
+        return;
+      }
+
+      // Write the mask to start a multibyte value.
+      out.writeByte(bits | prefixMask);
+      value -= prefixMask;
+
+      // Write 7 bits at a time 'til we're done.
+      while (value >= 0x80) {
+        int b = value & 0x7f;
+        out.writeByte(b | 0x80);
+        value >>>= 7;
+      }
+      out.writeByte(value);
+    }
+
+    void writeByteString(ByteString data) throws IOException {
+      writeInt(data.size(), PREFIX_7_BITS, 0);
+      out.write(data);
+    }
+  }
+
+  /**
+   * An HTTP/2 response cannot contain uppercase header characters and must
+   * be treated as malformed.
+   */
+  private static ByteString checkLowercase(ByteString name) throws IOException {
+    for (int i = 0, length = name.size(); i < length; i++) {
+      byte c = name.getByte(i);
+      if (c >= 'A' && c <= 'Z') {
+        throw new IOException("PROTOCOL_ERROR response malformed: mixed case name: " + name.utf8());
+      }
+    }
+    return name;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft16.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft16.java
new file mode 100644
index 0000000000..3b6095ce0a
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft16.java
@@ -0,0 +1,773 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.Protocol;
+import java.io.IOException;
+import java.util.List;
+import java.util.logging.Logger;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Source;
+import okio.Timeout;
+
+import static com.squareup.okhttp.internal.spdy.Http20Draft16.FrameLogger.formatHeader;
+import static java.lang.String.format;
+import static java.util.logging.Level.FINE;
+import static okio.ByteString.EMPTY;
+
+/**
+ * Read and write HTTP/2 v16 frames.
+ * <p>
+ * This implementation assumes we do not send an increased
+ * {@link Settings#getMaxFrameSize frame size setting} to the peer. Hence, we
+ * expect all frames to have a max length of {@link #INITIAL_MAX_FRAME_SIZE}.
+ * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-16
+ */
+public final class Http20Draft16 implements Variant {
+  private static final Logger logger = Logger.getLogger(FrameLogger.class.getName());
+
+  @Override public Protocol getProtocol() {
+    return Protocol.HTTP_2;
+  }
+
+  private static final ByteString CONNECTION_PREFACE
+      = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
+
+  /** The initial max frame size, applied independently writing to, or reading from the peer. */
+  static final int INITIAL_MAX_FRAME_SIZE = 0x4000; // 16384
+
+  static final byte TYPE_DATA = 0x0;
+  static final byte TYPE_HEADERS = 0x1;
+  static final byte TYPE_PRIORITY = 0x2;
+  static final byte TYPE_RST_STREAM = 0x3;
+  static final byte TYPE_SETTINGS = 0x4;
+  static final byte TYPE_PUSH_PROMISE = 0x5;
+  static final byte TYPE_PING = 0x6;
+  static final byte TYPE_GOAWAY = 0x7;
+  static final byte TYPE_WINDOW_UPDATE = 0x8;
+  static final byte TYPE_CONTINUATION = 0x9;
+
+  static final byte FLAG_NONE = 0x0;
+  static final byte FLAG_ACK = 0x1; // Used for settings and ping.
+  static final byte FLAG_END_STREAM = 0x1; // Used for headers and data.
+  static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
+  static final byte FLAG_END_PUSH_PROMISE = 0x4;
+  static final byte FLAG_PADDED = 0x8; // Used for headers and data.
+  static final byte FLAG_PRIORITY = 0x20; // Used for headers.
+  static final byte FLAG_COMPRESSED = 0x20; // Used for data.
+
+  /**
+   * Creates a frame reader with max header table size of 4096 and data frame
+   * compression disabled.
+   */
+  @Override public FrameReader newReader(BufferedSource source, boolean client) {
+    return new Reader(source, 4096, client);
+  }
+
+  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
+    return new Writer(sink, client);
+  }
+
+  static final class Reader implements FrameReader {
+    private final BufferedSource source;
+    private final ContinuationSource continuation;
+    private final boolean client;
+
+    // Visible for testing.
+    final HpackDraft10.Reader hpackReader;
+
+    Reader(BufferedSource source, int headerTableSize, boolean client) {
+      this.source = source;
+      this.client = client;
+      this.continuation = new ContinuationSource(this.source);
+      this.hpackReader = new HpackDraft10.Reader(headerTableSize, continuation);
+    }
+
+    @Override public void readConnectionPreface() throws IOException {
+      if (client) return; // Nothing to read; servers doesn't send a connection preface!
+      ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
+      if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
+      if (!CONNECTION_PREFACE.equals(connectionPreface)) {
+        throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
+      }
+    }
+
+    @Override public boolean nextFrame(Handler handler) throws IOException {
+      try {
+        source.require(9); // Frame header size
+      } catch (IOException e) {
+        return false; // This might be a normal socket close.
+      }
+
+      /*  0                   1                   2                   3
+       *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+       * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       * |                 Length (24)                   |
+       * +---------------+---------------+---------------+
+       * |   Type (8)    |   Flags (8)   |
+       * +-+-+-----------+---------------+-------------------------------+
+       * |R|                 Stream Identifier (31)                      |
+       * +=+=============================================================+
+       * |                   Frame Payload (0...)                      ...
+       * +---------------------------------------------------------------+
+       */
+      int length = readMedium(source);
+      if (length < 0 || length > INITIAL_MAX_FRAME_SIZE) {
+        throw ioException("FRAME_SIZE_ERROR: %s", length);
+      }
+      byte type = (byte) (source.readByte() & 0xff);
+      byte flags = (byte) (source.readByte() & 0xff);
+      int streamId = (source.readInt() & 0x7fffffff); // Ignore reserved bit.
+      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
+
+      switch (type) {
+        case TYPE_DATA:
+          readData(handler, length, flags, streamId);
+          break;
+
+        case TYPE_HEADERS:
+          readHeaders(handler, length, flags, streamId);
+          break;
+
+        case TYPE_PRIORITY:
+          readPriority(handler, length, flags, streamId);
+          break;
+
+        case TYPE_RST_STREAM:
+          readRstStream(handler, length, flags, streamId);
+          break;
+
+        case TYPE_SETTINGS:
+          readSettings(handler, length, flags, streamId);
+          break;
+
+        case TYPE_PUSH_PROMISE:
+          readPushPromise(handler, length, flags, streamId);
+          break;
+
+        case TYPE_PING:
+          readPing(handler, length, flags, streamId);
+          break;
+
+        case TYPE_GOAWAY:
+          readGoAway(handler, length, flags, streamId);
+          break;
+
+        case TYPE_WINDOW_UPDATE:
+          readWindowUpdate(handler, length, flags, streamId);
+          break;
+
+        default:
+          // Implementations MUST discard frames that have unknown or unsupported types.
+          source.skip(length);
+      }
+      return true;
+    }
+
+    private void readHeaders(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
+
+      boolean endStream = (flags & FLAG_END_STREAM) != 0;
+
+      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+
+      if ((flags & FLAG_PRIORITY) != 0) {
+        readPriority(handler, streamId);
+        length -= 5; // account for above read.
+      }
+
+      length = lengthWithoutPadding(length, flags, padding);
+
+      List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
+
+      handler.headers(false, endStream, streamId, -1, headerBlock, HeadersMode.HTTP_20_HEADERS);
+    }
+
+    private List<Header> readHeaderBlock(int length, short padding, byte flags, int streamId)
+        throws IOException {
+      continuation.length = continuation.left = length;
+      continuation.padding = padding;
+      continuation.flags = flags;
+      continuation.streamId = streamId;
+
+      // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
+      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-8.1.2.5
+      hpackReader.readHeaders();
+      return hpackReader.getAndResetHeaderList();
+    }
+
+    private void readData(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
+      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
+      boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
+      if (gzipped) {
+        throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
+      }
+
+      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+      length = lengthWithoutPadding(length, flags, padding);
+
+      handler.data(inFinished, streamId, source, length);
+      source.skip(padding);
+    }
+
+    private void readPriority(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      if (length != 5) throw ioException("TYPE_PRIORITY length: %d != 5", length);
+      if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
+      readPriority(handler, streamId);
+    }
+
+    private void readPriority(Handler handler, int streamId) throws IOException {
+      int w1 = source.readInt();
+      boolean exclusive = (w1 & 0x80000000) != 0;
+      int streamDependency = (w1 & 0x7fffffff);
+      int weight = (source.readByte() & 0xff) + 1;
+      handler.priority(streamId, streamDependency, weight, exclusive);
+    }
+
+    private void readRstStream(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
+      if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
+      int errorCodeInt = source.readInt();
+      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+      if (errorCode == null) {
+        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
+      }
+      handler.rstStream(streamId, errorCode);
+    }
+
+    private void readSettings(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
+      if ((flags & FLAG_ACK) != 0) {
+        if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
+        handler.ackSettings();
+        return;
+      }
+
+      if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
+      Settings settings = new Settings();
+      for (int i = 0; i < length; i += 6) {
+        short id = source.readShort();
+        int value = source.readInt();
+
+        switch (id) {
+          case 1: // SETTINGS_HEADER_TABLE_SIZE
+            break;
+          case 2: // SETTINGS_ENABLE_PUSH
+            if (value != 0 && value != 1) {
+              throw ioException("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
+            }
+            break;
+          case 3: // SETTINGS_MAX_CONCURRENT_STREAMS
+            id = 4; // Renumbered in draft 10.
+            break;
+          case 4: // SETTINGS_INITIAL_WINDOW_SIZE
+            id = 7; // Renumbered in draft 10.
+            if (value < 0) {
+              throw ioException("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
+            }
+            break;
+          case 5: // SETTINGS_MAX_FRAME_SIZE
+            if (value < INITIAL_MAX_FRAME_SIZE || value > 16777215) {
+              throw ioException("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: %s", value);
+            }
+            break;
+          case 6: // SETTINGS_MAX_HEADER_LIST_SIZE
+            break; // Advisory only, so ignored.
+          default:
+            throw ioException("PROTOCOL_ERROR invalid settings id: %s", id);
+        }
+        settings.set(id, 0, value);
+      }
+      handler.settings(false, settings);
+      if (settings.getHeaderTableSize() >= 0) {
+        hpackReader.headerTableSizeSetting(settings.getHeaderTableSize());
+      }
+    }
+
+    private void readPushPromise(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      if (streamId == 0) {
+        throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
+      }
+      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
+      int promisedStreamId = source.readInt() & 0x7fffffff;
+      length -= 4; // account for above read.
+      length = lengthWithoutPadding(length, flags, padding);
+      List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
+      handler.pushPromise(streamId, promisedStreamId, headerBlock);
+    }
+
+    private void readPing(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
+      if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
+      int payload1 = source.readInt();
+      int payload2 = source.readInt();
+      boolean ack = (flags & FLAG_ACK) != 0;
+      handler.ping(ack, payload1, payload2);
+    }
+
+    private void readGoAway(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
+      if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
+      int lastStreamId = source.readInt();
+      int errorCodeInt = source.readInt();
+      int opaqueDataLength = length - 8;
+      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+      if (errorCode == null) {
+        throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
+      }
+      ByteString debugData = EMPTY;
+      if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
+        debugData = source.readByteString(opaqueDataLength);
+      }
+      handler.goAway(lastStreamId, errorCode, debugData);
+    }
+
+    private void readWindowUpdate(Handler handler, int length, byte flags, int streamId)
+        throws IOException {
+      if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
+      long increment = (source.readInt() & 0x7fffffffL);
+      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
+      handler.windowUpdate(streamId, increment);
+    }
+
+    @Override public void close() throws IOException {
+      source.close();
+    }
+  }
+
+  static final class Writer implements FrameWriter {
+    private final BufferedSink sink;
+    private final boolean client;
+    private final Buffer hpackBuffer;
+    private final HpackDraft10.Writer hpackWriter;
+    private int maxFrameSize;
+    private boolean closed;
+
+    Writer(BufferedSink sink, boolean client) {
+      this.sink = sink;
+      this.client = client;
+      this.hpackBuffer = new Buffer();
+      this.hpackWriter = new HpackDraft10.Writer(hpackBuffer);
+      this.maxFrameSize = INITIAL_MAX_FRAME_SIZE;
+    }
+
+    @Override public synchronized void flush() throws IOException {
+      if (closed) throw new IOException("closed");
+      sink.flush();
+    }
+
+    @Override public synchronized void ackSettings(Settings peerSettings) throws IOException {
+      if (closed) throw new IOException("closed");
+      this.maxFrameSize = peerSettings.getMaxFrameSize(maxFrameSize);
+      int length = 0;
+      byte type = TYPE_SETTINGS;
+      byte flags = FLAG_ACK;
+      int streamId = 0;
+      frameHeader(streamId, length, type, flags);
+      sink.flush();
+    }
+
+    @Override public synchronized void connectionPreface() throws IOException {
+      if (closed) throw new IOException("closed");
+      if (!client) return; // Nothing to write; servers don't send connection headers!
+      if (logger.isLoggable(FINE)) {
+        logger.fine(format(">> CONNECTION %s", CONNECTION_PREFACE.hex()));
+      }
+      sink.write(CONNECTION_PREFACE.toByteArray());
+      sink.flush();
+    }
+
+    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
+        int streamId, int associatedStreamId, List<Header> headerBlock)
+        throws IOException {
+      if (inFinished) throw new UnsupportedOperationException();
+      if (closed) throw new IOException("closed");
+      headers(outFinished, streamId, headerBlock);
+    }
+
+    @Override public synchronized void synReply(boolean outFinished, int streamId,
+        List<Header> headerBlock) throws IOException {
+      if (closed) throw new IOException("closed");
+      headers(outFinished, streamId, headerBlock);
+    }
+
+    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
+        throws IOException {
+      if (closed) throw new IOException("closed");
+      headers(false, streamId, headerBlock);
+    }
+
+    @Override public synchronized void pushPromise(int streamId, int promisedStreamId,
+        List<Header> requestHeaders) throws IOException {
+      if (closed) throw new IOException("closed");
+      if (hpackBuffer.size() != 0) throw new IllegalStateException();
+      hpackWriter.writeHeaders(requestHeaders);
+
+      long byteCount = hpackBuffer.size();
+      int length = (int) Math.min(maxFrameSize - 4, byteCount);
+      byte type = TYPE_PUSH_PROMISE;
+      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+      frameHeader(streamId, length + 4, type, flags);
+      sink.writeInt(promisedStreamId & 0x7fffffff);
+      sink.write(hpackBuffer, length);
+
+      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+    }
+
+    void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
+      if (closed) throw new IOException("closed");
+      if (hpackBuffer.size() != 0) throw new IllegalStateException();
+      hpackWriter.writeHeaders(headerBlock);
+
+      long byteCount = hpackBuffer.size();
+      int length = (int) Math.min(maxFrameSize, byteCount);
+      byte type = TYPE_HEADERS;
+      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+      if (outFinished) flags |= FLAG_END_STREAM;
+      frameHeader(streamId, length, type, flags);
+      sink.write(hpackBuffer, length);
+
+      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+    }
+
+    private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
+      while (byteCount > 0) {
+        int length = (int) Math.min(maxFrameSize, byteCount);
+        byteCount -= length;
+        frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
+        sink.write(hpackBuffer, length);
+      }
+    }
+
+    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
+        throws IOException {
+      if (closed) throw new IOException("closed");
+      if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
+
+      int length = 4;
+      byte type = TYPE_RST_STREAM;
+      byte flags = FLAG_NONE;
+      frameHeader(streamId, length, type, flags);
+      sink.writeInt(errorCode.httpCode);
+      sink.flush();
+    }
+
+    @Override public int maxDataLength() {
+      return maxFrameSize;
+    }
+
+    @Override public synchronized void data(boolean outFinished, int streamId, Buffer source,
+        int byteCount) throws IOException {
+      if (closed) throw new IOException("closed");
+      byte flags = FLAG_NONE;
+      if (outFinished) flags |= FLAG_END_STREAM;
+      dataFrame(streamId, flags, source, byteCount);
+    }
+
+    void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IOException {
+      byte type = TYPE_DATA;
+      frameHeader(streamId, byteCount, type, flags);
+      if (byteCount > 0) {
+        sink.write(buffer, byteCount);
+      }
+    }
+
+    @Override public synchronized void settings(Settings settings) throws IOException {
+      if (closed) throw new IOException("closed");
+      int length = settings.size() * 6;
+      byte type = TYPE_SETTINGS;
+      byte flags = FLAG_NONE;
+      int streamId = 0;
+      frameHeader(streamId, length, type, flags);
+      for (int i = 0; i < Settings.COUNT; i++) {
+        if (!settings.isSet(i)) continue;
+        int id = i;
+        if (id == 4) id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
+        else if (id == 7) id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
+        sink.writeShort(id);
+        sink.writeInt(settings.get(i));
+      }
+      sink.flush();
+    }
+
+    @Override public synchronized void ping(boolean ack, int payload1, int payload2)
+        throws IOException {
+      if (closed) throw new IOException("closed");
+      int length = 8;
+      byte type = TYPE_PING;
+      byte flags = ack ? FLAG_ACK : FLAG_NONE;
+      int streamId = 0;
+      frameHeader(streamId, length, type, flags);
+      sink.writeInt(payload1);
+      sink.writeInt(payload2);
+      sink.flush();
+    }
+
+    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
+        byte[] debugData) throws IOException {
+      if (closed) throw new IOException("closed");
+      if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
+      int length = 8 + debugData.length;
+      byte type = TYPE_GOAWAY;
+      byte flags = FLAG_NONE;
+      int streamId = 0;
+      frameHeader(streamId, length, type, flags);
+      sink.writeInt(lastGoodStreamId);
+      sink.writeInt(errorCode.httpCode);
+      if (debugData.length > 0) {
+        sink.write(debugData);
+      }
+      sink.flush();
+    }
+
+    @Override public synchronized void windowUpdate(int streamId, long windowSizeIncrement)
+        throws IOException {
+      if (closed) throw new IOException("closed");
+      if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
+        throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
+            windowSizeIncrement);
+      }
+      int length = 4;
+      byte type = TYPE_WINDOW_UPDATE;
+      byte flags = FLAG_NONE;
+      frameHeader(streamId, length, type, flags);
+      sink.writeInt((int) windowSizeIncrement);
+      sink.flush();
+    }
+
+    @Override public synchronized void close() throws IOException {
+      closed = true;
+      sink.close();
+    }
+
+    void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
+      if (logger.isLoggable(FINE)) logger.fine(formatHeader(false, streamId, length, type, flags));
+      if (length > maxFrameSize) {
+        throw illegalArgument("FRAME_SIZE_ERROR length > %d: %d", maxFrameSize, length);
+      }
+      if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
+      writeMedium(sink, length);
+      sink.writeByte(type & 0xff);
+      sink.writeByte(flags & 0xff);
+      sink.writeInt(streamId & 0x7fffffff);
+    }
+  }
+
+  private static IllegalArgumentException illegalArgument(String message, Object... args) {
+    throw new IllegalArgumentException(format(message, args));
+  }
+
+  private static IOException ioException(String message, Object... args) throws IOException {
+    throw new IOException(format(message, args));
+  }
+
+  /**
+   * Decompression of the header block occurs above the framing layer. This
+   * class lazily reads continuation frames as they are needed by {@link
+   * HpackDraft10.Reader#readHeaders()}.
+   */
+  static final class ContinuationSource implements Source {
+    private final BufferedSource source;
+
+    int length;
+    byte flags;
+    int streamId;
+
+    int left;
+    short padding;
+
+    public ContinuationSource(BufferedSource source) {
+      this.source = source;
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      while (left == 0) {
+        source.skip(padding);
+        padding = 0;
+        if ((flags & FLAG_END_HEADERS) != 0) return -1;
+        readContinuationHeader();
+        // TODO: test case for empty continuation header?
+      }
+
+      long read = source.read(sink, Math.min(byteCount, left));
+      if (read == -1) return -1;
+      left -= read;
+      return read;
+    }
+
+    @Override public Timeout timeout() {
+      return source.timeout();
+    }
+
+    @Override public void close() throws IOException {
+    }
+
+    private void readContinuationHeader() throws IOException {
+      int previousStreamId = streamId;
+
+      length = left = readMedium(source);
+      byte type = (byte) (source.readByte() & 0xff);
+      flags = (byte) (source.readByte() & 0xff);
+      if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
+      streamId = (source.readInt() & 0x7fffffff);
+      if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
+      if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
+    }
+  }
+
+  private static int lengthWithoutPadding(int length, byte flags, short padding)
+      throws IOException {
+    if ((flags & FLAG_PADDED) != 0) length--; // Account for reading the padding length.
+    if (padding > length) {
+      throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length);
+    }
+    return (short) (length - padding);
+  }
+
+  /**
+   * Logs a human-readable representation of HTTP/2 frame headers.
+   *
+   * <p>The format is:
+   *
+   * <pre>
+   *   direction streamID length type flags
+   * </pre>
+   * Where direction is {@code <<} for inbound and {@code >>} for outbound.
+   *
+   * <p> For example, the following would indicate a HEAD request sent from
+   * the client.
+   * <pre>
+   * {@code
+   *   << 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
+   * }
+   * </pre>
+   */
+  static final class FrameLogger {
+
+    static String formatHeader(boolean inbound, int streamId, int length, byte type, byte flags) {
+      String formattedType = type < TYPES.length ? TYPES[type] : format("0x%02x", type);
+      String formattedFlags = formatFlags(type, flags);
+      return format("%s 0x%08x %5d %-13s %s", inbound ? "<<" : ">>", streamId, length,
+          formattedType, formattedFlags);
+    }
+
+    /**
+     * Looks up valid string representing flags from the table. Invalid
+     * combinations are represented in binary.
+     */
+    // Visible for testing.
+    static String formatFlags(byte type, byte flags) {
+      if (flags == 0) return "";
+      switch (type) { // Special case types that have 0 or 1 flag.
+        case TYPE_SETTINGS:
+        case TYPE_PING:
+          return flags == FLAG_ACK ? "ACK" : BINARY[flags];
+        case TYPE_PRIORITY:
+        case TYPE_RST_STREAM:
+        case TYPE_GOAWAY:
+        case TYPE_WINDOW_UPDATE:
+          return BINARY[flags];
+      }
+      String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
+      // Special case types that have overlap flag values.
+      if (type == TYPE_PUSH_PROMISE && (flags & FLAG_END_PUSH_PROMISE) != 0) {
+        return result.replace("HEADERS", "PUSH_PROMISE"); // TODO: Avoid allocation.
+      } else if (type == TYPE_DATA && (flags & FLAG_COMPRESSED) != 0) {
+        return result.replace("PRIORITY", "COMPRESSED"); // TODO: Avoid allocation.
+      }
+      return result;
+    }
+
+    /** Lookup table for valid frame types. */
+    private static final String[] TYPES = new String[] {
+        "DATA",
+        "HEADERS",
+        "PRIORITY",
+        "RST_STREAM",
+        "SETTINGS",
+        "PUSH_PROMISE",
+        "PING",
+        "GOAWAY",
+        "WINDOW_UPDATE",
+        "CONTINUATION"
+    };
+
+    /**
+     * Lookup table for valid flags for DATA, HEADERS, CONTINUATION. Invalid
+     * combinations are represented in binary.
+     */
+    private static final String[] FLAGS = new String[0x40]; // Highest bit flag is 0x20.
+    private static final String[] BINARY = new String[256];
+
+    static {
+      for (int i = 0; i < BINARY.length; i++) {
+        BINARY[i] = format("%8s", Integer.toBinaryString(i)).replace(' ', '0');
+      }
+
+      FLAGS[FLAG_NONE] = "";
+      FLAGS[FLAG_END_STREAM] = "END_STREAM";
+
+      int[] prefixFlags = new int[] {FLAG_END_STREAM};
+
+      FLAGS[FLAG_PADDED] = "PADDED";
+      for (int prefixFlag : prefixFlags) {
+         FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
+      }
+
+      FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
+      FLAGS[FLAG_PRIORITY] = "PRIORITY"; // Same as FLAG_COMPRESSED.
+      FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY"; // Only valid on HEADERS.
+      int[] frameFlags =
+          new int[] {FLAG_END_HEADERS, FLAG_PRIORITY, FLAG_END_HEADERS | FLAG_PRIORITY};
+
+      for (int frameFlag : frameFlags) {
+        for (int prefixFlag : prefixFlags) {
+          FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
+          FLAGS[prefixFlag | frameFlag | FLAG_PADDED] =
+              FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + "|PADDED";
+        }
+      }
+
+      for (int i = 0; i < FLAGS.length; i++) { // Fill in holes with binary representation.
+        if (FLAGS[i] == null) FLAGS[i] = BINARY[i];
+      }
+    }
+  }
+
+  private static int readMedium(BufferedSource source) throws IOException {
+    return (source.readByte() & 0xff) << 16
+        |  (source.readByte() & 0xff) <<  8
+        |  (source.readByte() & 0xff);
+  }
+
+  private static void writeMedium(BufferedSink sink, int i) throws IOException {
+    sink.writeByte((i >>> 16) & 0xff);
+    sink.writeByte((i >>>  8) & 0xff);
+    sink.writeByte(i          & 0xff);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
new file mode 100644
index 0000000000..298087bf21
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
@@ -0,0 +1,225 @@
+/*
+ * Copyright 2013 Twitter, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * This class was originally composed from the following classes in
+ * <a href="https://github.com/twitter/hpack">Twitter Hpack</a>.
+ * <ul>
+ * <li>{@code com.twitter.hpack.HuffmanEncoder}</li>
+ * <li>{@code com.twitter.hpack.HuffmanDecoder}</li>
+ * <li>{@code com.twitter.hpack.HpackUtil}</li>
+ * </ul>
+ */
+class Huffman {
+
+  // Appendix C: Huffman Codes
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-B
+  private static final int[] CODES = {
+      0x1ff8, 0x7fffd8, 0xfffffe2, 0xfffffe3, 0xfffffe4, 0xfffffe5, 0xfffffe6, 0xfffffe7, 0xfffffe8,
+      0xffffea, 0x3ffffffc, 0xfffffe9, 0xfffffea, 0x3ffffffd, 0xfffffeb, 0xfffffec, 0xfffffed,
+      0xfffffee, 0xfffffef, 0xffffff0, 0xffffff1, 0xffffff2, 0x3ffffffe, 0xffffff3, 0xffffff4,
+      0xffffff5, 0xffffff6, 0xffffff7, 0xffffff8, 0xffffff9, 0xffffffa, 0xffffffb, 0x14, 0x3f8,
+      0x3f9, 0xffa, 0x1ff9, 0x15, 0xf8, 0x7fa, 0x3fa, 0x3fb, 0xf9, 0x7fb, 0xfa, 0x16, 0x17, 0x18,
+      0x0, 0x1, 0x2, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x5c, 0xfb, 0x7ffc, 0x20, 0xffb,
+      0x3fc, 0x1ffa, 0x21, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
+      0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0xfc, 0x73, 0xfd, 0x1ffb, 0x7fff0,
+      0x1ffc, 0x3ffc, 0x22, 0x7ffd, 0x3, 0x23, 0x4, 0x24, 0x5, 0x25, 0x26, 0x27, 0x6, 0x74, 0x75,
+      0x28, 0x29, 0x2a, 0x7, 0x2b, 0x76, 0x2c, 0x8, 0x9, 0x2d, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7ffe,
+      0x7fc, 0x3ffd, 0x1ffd, 0xffffffc, 0xfffe6, 0x3fffd2, 0xfffe7, 0xfffe8, 0x3fffd3, 0x3fffd4,
+      0x3fffd5, 0x7fffd9, 0x3fffd6, 0x7fffda, 0x7fffdb, 0x7fffdc, 0x7fffdd, 0x7fffde, 0xffffeb,
+      0x7fffdf, 0xffffec, 0xffffed, 0x3fffd7, 0x7fffe0, 0xffffee, 0x7fffe1, 0x7fffe2, 0x7fffe3,
+      0x7fffe4, 0x1fffdc, 0x3fffd8, 0x7fffe5, 0x3fffd9, 0x7fffe6, 0x7fffe7, 0xffffef, 0x3fffda,
+      0x1fffdd, 0xfffe9, 0x3fffdb, 0x3fffdc, 0x7fffe8, 0x7fffe9, 0x1fffde, 0x7fffea, 0x3fffdd,
+      0x3fffde, 0xfffff0, 0x1fffdf, 0x3fffdf, 0x7fffeb, 0x7fffec, 0x1fffe0, 0x1fffe1, 0x3fffe0,
+      0x1fffe2, 0x7fffed, 0x3fffe1, 0x7fffee, 0x7fffef, 0xfffea, 0x3fffe2, 0x3fffe3, 0x3fffe4,
+      0x7ffff0, 0x3fffe5, 0x3fffe6, 0x7ffff1, 0x3ffffe0, 0x3ffffe1, 0xfffeb, 0x7fff1, 0x3fffe7,
+      0x7ffff2, 0x3fffe8, 0x1ffffec, 0x3ffffe2, 0x3ffffe3, 0x3ffffe4, 0x7ffffde, 0x7ffffdf,
+      0x3ffffe5, 0xfffff1, 0x1ffffed, 0x7fff2, 0x1fffe3, 0x3ffffe6, 0x7ffffe0, 0x7ffffe1, 0x3ffffe7,
+      0x7ffffe2, 0xfffff2, 0x1fffe4, 0x1fffe5, 0x3ffffe8, 0x3ffffe9, 0xffffffd, 0x7ffffe3,
+      0x7ffffe4, 0x7ffffe5, 0xfffec, 0xfffff3, 0xfffed, 0x1fffe6, 0x3fffe9, 0x1fffe7, 0x1fffe8,
+      0x7ffff3, 0x3fffea, 0x3fffeb, 0x1ffffee, 0x1ffffef, 0xfffff4, 0xfffff5, 0x3ffffea, 0x7ffff4,
+      0x3ffffeb, 0x7ffffe6, 0x3ffffec, 0x3ffffed, 0x7ffffe7, 0x7ffffe8, 0x7ffffe9, 0x7ffffea,
+      0x7ffffeb, 0xffffffe, 0x7ffffec, 0x7ffffed, 0x7ffffee, 0x7ffffef, 0x7fffff0, 0x3ffffee
+  };
+
+  private static final byte[] CODE_LENGTHS = {
+      13, 23, 28, 28, 28, 28, 28, 28, 28, 24, 30, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 28, 30,
+      28, 28, 28, 28, 28, 28, 28, 28, 28, 6, 10, 10, 12, 13, 6, 8, 11, 10, 10, 8, 11, 8, 6, 6, 6, 5,
+      5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 8, 15, 6, 12, 10, 13, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+      7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 8, 13, 19, 13, 14, 6, 15, 5, 6, 5, 6, 5, 6, 6, 6, 5, 7, 7, 6,
+      6, 6, 5, 6, 7, 6, 5, 5, 6, 7, 7, 7, 7, 7, 15, 11, 14, 13, 28, 20, 22, 20, 20, 22, 22, 22, 23,
+      22, 23, 23, 23, 23, 23, 24, 23, 24, 24, 22, 23, 24, 23, 23, 23, 23, 21, 22, 23, 22, 23, 23,
+      24, 22, 21, 20, 22, 22, 23, 23, 21, 23, 22, 22, 24, 21, 22, 23, 23, 21, 21, 22, 21, 23, 22,
+      23, 23, 20, 22, 22, 22, 23, 22, 22, 23, 26, 26, 20, 19, 22, 23, 22, 25, 26, 26, 26, 27, 27,
+      26, 24, 25, 19, 21, 26, 27, 27, 26, 27, 24, 21, 21, 26, 26, 28, 27, 27, 27, 20, 24, 20, 21,
+      22, 21, 21, 23, 22, 22, 25, 25, 24, 24, 26, 23, 26, 27, 26, 26, 27, 27, 27, 27, 27, 28, 27,
+      27, 27, 27, 27, 26
+  };
+
+  private static final Huffman INSTANCE = new Huffman();
+
+  public static Huffman get() {
+    return INSTANCE;
+  }
+
+  private final Node root = new Node();
+
+  private Huffman() {
+    buildTree();
+  }
+
+  void encode(byte[] data, OutputStream out) throws IOException {
+    long current = 0;
+    int n = 0;
+
+    for (int i = 0; i < data.length; i++) {
+      int b = data[i] & 0xFF;
+      int code = CODES[b];
+      int nbits = CODE_LENGTHS[b];
+
+      current <<= nbits;
+      current |= code;
+      n += nbits;
+
+      while (n >= 8) {
+        n -= 8;
+        out.write(((int) (current >> n)));
+      }
+    }
+
+    if (n > 0) {
+      current <<= (8 - n);
+      current |= (0xFF >>> n);
+      out.write((int) current);
+    }
+  }
+
+  int encodedLength(byte[] bytes) {
+    long len = 0;
+
+    for (int i = 0; i < bytes.length; i++) {
+      int b = bytes[i] & 0xFF;
+      len += CODE_LENGTHS[b];
+    }
+
+    return (int) ((len + 7) >> 3);
+  }
+
+  byte[] decode(byte[] buf) throws IOException {
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    Node node = root;
+    int current = 0;
+    int nbits = 0;
+    for (int i = 0; i < buf.length; i++) {
+      int b = buf[i] & 0xFF;
+      current = (current << 8) | b;
+      nbits += 8;
+      while (nbits >= 8) {
+        int c = (current >>> (nbits - 8)) & 0xFF;
+        node = node.children[c];
+        if (node.children == null) {
+          // terminal node
+          baos.write(node.symbol);
+          nbits -= node.terminalBits;
+          node = root;
+        } else {
+          // non-terminal node
+          nbits -= 8;
+        }
+      }
+    }
+
+    while (nbits > 0) {
+      int c = (current << (8 - nbits)) & 0xFF;
+      node = node.children[c];
+      if (node.children != null || node.terminalBits > nbits) {
+        break;
+      }
+      baos.write(node.symbol);
+      nbits -= node.terminalBits;
+      node = root;
+    }
+
+    return baos.toByteArray();
+  }
+
+  private void buildTree() {
+    for (int i = 0; i < CODE_LENGTHS.length; i++) {
+      addCode(i, CODES[i], CODE_LENGTHS[i]);
+    }
+  }
+
+  private void addCode(int sym, int code, byte len) {
+    Node terminal = new Node(sym, len);
+
+    Node current = root;
+    while (len > 8) {
+      len -= 8;
+      int i = ((code >>> len) & 0xFF);
+      if (current.children == null) {
+        throw new IllegalStateException("invalid dictionary: prefix not unique");
+      }
+      if (current.children[i] == null) {
+        current.children[i] = new Node();
+      }
+      current = current.children[i];
+    }
+
+    int shift = 8 - len;
+    int start = (code << shift) & 0xFF;
+    int end = 1 << shift;
+    for (int i = start; i < start + end; i++) {
+      current.children[i] = terminal;
+    }
+  }
+
+  private static final class Node {
+
+    // Null if terminal.
+    private final Node[] children;
+
+    // Terminal nodes have a symbol.
+    private final int symbol;
+
+    // Number of bits represented in the terminal node.
+    private final int terminalBits;
+
+    /** Construct an internal node. */
+    Node() {
+      this.children = new Node[256];
+      this.symbol = 0; // Not read.
+      this.terminalBits = 0; // Not read.
+    }
+
+    /**
+     * Construct a terminal node.
+     *
+     * @param symbol symbol the node represents
+     * @param bits length of Huffman code in bits
+     */
+    Node(int symbol, int bits) {
+      this.children = null;
+      this.symbol = symbol;
+      int b = bits & 0x07;
+      this.terminalBits = b == 0 ? 8 : b;
+    }
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
new file mode 100644
index 0000000000..6413f36345
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.zip.DataFormatException;
+import java.util.zip.Inflater;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.ForwardingSource;
+import okio.InflaterSource;
+import okio.Okio;
+import okio.Source;
+
+/**
+ * Reads a SPDY/3 Name/Value header block. This class is made complicated by the
+ * requirement that we're strict with which bytes we put in the compressed bytes
+ * buffer. We need to put all compressed bytes into that buffer -- but no other
+ * bytes.
+ */
+class NameValueBlockReader {
+  /** This source transforms compressed bytes into uncompressed bytes. */
+  private final InflaterSource inflaterSource;
+
+  /**
+   * How many compressed bytes must be read into inflaterSource before
+   * {@link #readNameValueBlock} returns.
+   */
+  private int compressedLimit;
+
+  /** This source holds inflated bytes. */
+  private final BufferedSource source;
+
+  public NameValueBlockReader(BufferedSource source) {
+    // Limit the inflater input stream to only those bytes in the Name/Value
+    // block. We cut the inflater off at its source because we can't predict the
+    // ratio of compressed bytes to uncompressed bytes.
+    Source throttleSource = new ForwardingSource(source) {
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        if (compressedLimit == 0) return -1; // Out of data for the current block.
+        long read = super.read(sink, Math.min(byteCount, compressedLimit));
+        if (read == -1) return -1;
+        compressedLimit -= read;
+        return read;
+      }
+    };
+
+    // Subclass inflater to install a dictionary when it's needed.
+    Inflater inflater = new Inflater() {
+      @Override public int inflate(byte[] buffer, int offset, int count)
+          throws DataFormatException {
+        int result = super.inflate(buffer, offset, count);
+        if (result == 0 && needsDictionary()) {
+          setDictionary(Spdy3.DICTIONARY);
+          result = super.inflate(buffer, offset, count);
+        }
+        return result;
+      }
+    };
+
+    this.inflaterSource = new InflaterSource(throttleSource, inflater);
+    this.source = Okio.buffer(inflaterSource);
+  }
+
+  public List<Header> readNameValueBlock(int length) throws IOException {
+    this.compressedLimit += length;
+
+    int numberOfPairs = source.readInt();
+    if (numberOfPairs < 0) throw new IOException("numberOfPairs < 0: " + numberOfPairs);
+    if (numberOfPairs > 1024) throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
+
+    List<Header> entries = new ArrayList<>(numberOfPairs);
+    for (int i = 0; i < numberOfPairs; i++) {
+      ByteString name = readByteString().toAsciiLowercase();
+      ByteString values = readByteString();
+      if (name.size() == 0) throw new IOException("name.size == 0");
+      entries.add(new Header(name, values));
+    }
+
+    doneReading();
+    return entries;
+  }
+
+  private ByteString readByteString() throws IOException {
+    int length = source.readInt();
+    return source.readByteString(length);
+  }
+
+  private void doneReading() throws IOException {
+    // Move any outstanding unread bytes into the inflater. One side-effect of
+    // deflate compression is that sometimes there are bytes remaining in the
+    // stream after we've consumed all of the content.
+    if (compressedLimit > 0) {
+      inflaterSource.refill();
+      if (compressedLimit != 0) throw new IOException("compressedLimit > 0: " + compressedLimit);
+    }
+  }
+
+  public void close() throws IOException {
+    source.close();
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
similarity index 95%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
index c585255780..06b0aefccf 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
@@ -49,7 +49,7 @@ void cancel() {
   /**
    * Returns the round trip time for this ping in nanoseconds, waiting for the
    * response to arrive if necessary. Returns -1 if the response was
-   * cancelled.
+   * canceled.
    */
   public long roundTripTime() throws InterruptedException {
     latch.await();
@@ -58,7 +58,7 @@ public long roundTripTime() throws InterruptedException {
 
   /**
    * Returns the round trip time for this ping in nanoseconds, or -1 if the
-   * response was cancelled, or -2 if the timeout elapsed before the round
+   * response was canceled, or -2 if the timeout elapsed before the round
    * trip completed.
    */
   public long roundTripTime(long timeout, TimeUnit unit) throws InterruptedException {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
new file mode 100644
index 0000000000..cdb51f65a5
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.IOException;
+import java.util.List;
+import okio.BufferedSource;
+
+/**
+ * {@link com.squareup.okhttp.Protocol#HTTP_2 HTTP/2} only.
+ * Processes server-initiated HTTP requests on the client. Implementations must
+ * quickly dispatch callbacks to avoid creating a bottleneck.
+ *
+ * <p>While {@link #onReset} may occur at any time, the following callbacks are
+ * expected in order, correlated by stream ID.
+ * <ul>
+ *   <li>{@link #onRequest}</li>
+ *   <li>{@link #onHeaders} (unless canceled)</li>
+ *   <li>{@link #onData} (optional sequence of data frames)</li>
+ * </ul>
+ *
+ * <p>As a stream ID is scoped to a single HTTP/2 connection, implementations
+ * which target multiple connections should expect repetition of stream IDs.
+ *
+ * <p>Return true to request cancellation of a pushed stream.  Note that this
+ * does not guarantee future frames won't arrive on the stream ID.
+ */
+public interface PushObserver {
+  /**
+   * Describes the request that the server intends to push a response for.
+   *
+   * @param streamId server-initiated stream ID: an even number.
+   * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
+   * {@code :authority}, and (@code :path}.
+   */
+  boolean onRequest(int streamId, List<Header> requestHeaders);
+
+  /**
+   * The response headers corresponding to a pushed request.  When {@code last}
+   * is true, there are no data frames to follow.
+   *
+   * @param streamId server-initiated stream ID: an even number.
+   * @param responseHeaders minimally includes {@code :status}.
+   * @param last when true, there is no response data.
+   */
+  boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last);
+
+  /**
+   * A chunk of response data corresponding to a pushed request.  This data
+   * must either be read or skipped.
+   *
+   * @param streamId server-initiated stream ID: an even number.
+   * @param source location of data corresponding with this stream ID.
+   * @param byteCount number of bytes to read or skip from the source.
+   * @param last when true, there are no data frames to follow.
+   */
+  boolean onData(int streamId, BufferedSource source, int byteCount, boolean last)
+      throws IOException;
+
+  /** Indicates the reason why this stream was canceled. */
+  void onReset(int streamId, ErrorCode errorCode);
+
+  PushObserver CANCEL = new PushObserver() {
+
+    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
+      return true;
+    }
+
+    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
+      return true;
+    }
+
+    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
+        boolean last) throws IOException {
+      source.skip(byteCount);
+      return true;
+    }
+
+    @Override public void onReset(int streamId, ErrorCode errorCode) {
+    }
+  };
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
similarity index 67%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
index 05380e27e1..bb67b8311a 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
@@ -15,10 +15,16 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-final class Settings {
+import java.util.Arrays;
+
+/**
+ * Settings describe characteristics of the sending peer, which are used by the receiving peer.
+ * Settings are {@link com.squareup.okhttp.internal.spdy.SpdyConnection connection} scoped.
+ */
+public final class Settings {
   /**
-   * From the spdy/3 spec, the default initial window size for all streams is
-   * 64 KiB. (Chrome 25 uses 10 MiB).
+   * From the SPDY/3 and HTTP/2 specs, the default initial window size for all
+   * streams is 64 KiB. (Chrome 25 uses 10 MiB).
    */
   static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
 
@@ -30,24 +36,32 @@
   /** Sent by clients only. The client is reminding the server of a persisted value. */
   static final int PERSISTED = 0x2;
 
-  /** Sender's estimate of max incoming kbps. */
+  /** spdy/3: Sender's estimate of max incoming kbps. */
   static final int UPLOAD_BANDWIDTH = 1;
-  /** Sender's estimate of max outgoing kbps. */
+  /** HTTP/2: Size in bytes of the table used to decode the sender's header blocks. */
+  static final int HEADER_TABLE_SIZE = 1;
+  /** spdy/3: Sender's estimate of max outgoing kbps. */
   static final int DOWNLOAD_BANDWIDTH = 2;
-  /** Sender's estimate of milliseconds between sending a request and receiving a response. */
+  /** HTTP/2: The peer must not send a PUSH_PROMISE frame when this is 0. */
+  static final int ENABLE_PUSH = 2;
+  /** spdy/3: Sender's estimate of millis between sending a request and receiving a response. */
   static final int ROUND_TRIP_TIME = 3;
   /** Sender's maximum number of concurrent streams. */
   static final int MAX_CONCURRENT_STREAMS = 4;
-  /** Current CWND in Packets. */
+  /** spdy/3: Current CWND in Packets. */
   static final int CURRENT_CWND = 5;
-  /** Retransmission rate. Percentage */
+  /** HTTP/2: Size in bytes of the largest frame payload the sender will accept. */
+  static final int MAX_FRAME_SIZE = 5;
+  /** spdy/3: Retransmission rate. Percentage */
   static final int DOWNLOAD_RETRANS_RATE = 6;
+  /** HTTP/2: Advisory only. Size in bytes of the largest header list the sender will accept. */
+  static final int MAX_HEADER_LIST_SIZE = 6;
   /** Window size in bytes. */
   static final int INITIAL_WINDOW_SIZE = 7;
-  /** Window size in bytes. */
+  /** spdy/3: Size of the client certificate vector. Unsupported. */
   static final int CLIENT_CERTIFICATE_VECTOR_SIZE = 8;
   /** Flow control options. */
-  static final int FLOW_CONTROL_OPTIONS = 9;
+  static final int FLOW_CONTROL_OPTIONS = 10;
 
   /** Total number of settings. */
   static final int COUNT = 10;
@@ -67,9 +81,14 @@
   /** Flag values. */
   private final int[] values = new int[COUNT];
 
-  void set(int id, int idFlags, int value) {
+  void clear() {
+    set = persistValue = persisted = 0;
+    Arrays.fill(values, 0);
+  }
+
+  Settings set(int id, int idFlags, int value) {
     if (id >= values.length) {
-      return; // Discard unknown settings.
+      return this; // Discard unknown settings.
     }
 
     int bit = 1 << id;
@@ -86,6 +105,7 @@ void set(int id, int idFlags, int value) {
     }
 
     values[id] = value;
+    return this;
   }
 
   /** Returns true if a value has been assigned for the setting {@code id}. */
@@ -112,47 +132,79 @@ int size() {
     return Integer.bitCount(set);
   }
 
+  /** spdy/3 only. */
   int getUploadBandwidth(int defaultValue) {
     int bit = 1 << UPLOAD_BANDWIDTH;
     return (bit & set) != 0 ? values[UPLOAD_BANDWIDTH] : defaultValue;
   }
 
+  /** HTTP/2 only. Returns -1 if unset. */
+  int getHeaderTableSize() {
+    int bit = 1 << HEADER_TABLE_SIZE;
+    return (bit & set) != 0 ? values[HEADER_TABLE_SIZE] : -1;
+  }
+
+  /** spdy/3 only. */
   int getDownloadBandwidth(int defaultValue) {
     int bit = 1 << DOWNLOAD_BANDWIDTH;
     return (bit & set) != 0 ? values[DOWNLOAD_BANDWIDTH] : defaultValue;
   }
 
+  /** HTTP/2 only. */
+  // TODO: honor this setting in HTTP/2.
+  boolean getEnablePush(boolean defaultValue) {
+    int bit = 1 << ENABLE_PUSH;
+    return ((bit & set) != 0 ? values[ENABLE_PUSH] : defaultValue ? 1 : 0) == 1;
+  }
+
+  /** spdy/3 only. */
   int getRoundTripTime(int defaultValue) {
     int bit = 1 << ROUND_TRIP_TIME;
     return (bit & set) != 0 ? values[ROUND_TRIP_TIME] : defaultValue;
   }
 
+  // TODO: honor this setting in spdy/3 and HTTP/2.
   int getMaxConcurrentStreams(int defaultValue) {
     int bit = 1 << MAX_CONCURRENT_STREAMS;
     return (bit & set) != 0 ? values[MAX_CONCURRENT_STREAMS] : defaultValue;
   }
 
+  /** spdy/3 only. */
   int getCurrentCwnd(int defaultValue) {
     int bit = 1 << CURRENT_CWND;
     return (bit & set) != 0 ? values[CURRENT_CWND] : defaultValue;
   }
 
+  /** HTTP/2 only. */
+  int getMaxFrameSize(int defaultValue) {
+    int bit = 1 << MAX_FRAME_SIZE;
+    return (bit & set) != 0 ? values[MAX_FRAME_SIZE] : defaultValue;
+  }
+
+  /** spdy/3 only. */
   int getDownloadRetransRate(int defaultValue) {
     int bit = 1 << DOWNLOAD_RETRANS_RATE;
     return (bit & set) != 0 ? values[DOWNLOAD_RETRANS_RATE] : defaultValue;
   }
 
+  /** HTTP/2 only. */
+  int getMaxHeaderListSize(int defaultValue) {
+    int bit = 1 << MAX_HEADER_LIST_SIZE;
+    return (bit & set) != 0 ? values[MAX_HEADER_LIST_SIZE] : defaultValue;
+  }
+
   int getInitialWindowSize(int defaultValue) {
     int bit = 1 << INITIAL_WINDOW_SIZE;
     return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : defaultValue;
   }
 
+  /** spdy/3 only. */
   int getClientCertificateVectorSize(int defaultValue) {
     int bit = 1 << CLIENT_CERTIFICATE_VECTOR_SIZE;
     return (bit & set) != 0 ? values[CLIENT_CERTIFICATE_VECTOR_SIZE] : defaultValue;
   }
 
-  // TODO: honor this setting.
+  // TODO: honor this setting in spdy/3 and HTTP/2.
   boolean isFlowControlDisabled() {
     int bit = 1 << FLOW_CONTROL_OPTIONS;
     int value = (bit & set) != 0 ? values[FLOW_CONTROL_OPTIONS] : 0;
@@ -160,7 +212,7 @@ boolean isFlowControlDisabled() {
   }
 
   /**
-   * Returns true if this user agent should use this setting in future SPDY
+   * Returns true if this user agent should use this setting in future spdy/3
    * connections to the same host.
    */
   boolean persistValue(int id) {
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
similarity index 53%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 4a1cbb28e6..c5cebe7c73 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -15,36 +15,39 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.ProtocolException;
-import java.util.ArrayList;
 import java.util.List;
-import java.util.logging.Logger;
-import java.util.zip.DataFormatException;
 import java.util.zip.Deflater;
-import java.util.zip.Inflater;
-import java.util.zip.InflaterInputStream;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.DeflaterSink;
+import okio.Okio;
+
+/**
+ * Read and write spdy/3.1 frames.
+ * http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1
+ */
+public final class Spdy3 implements Variant {
+
+  @Override public Protocol getProtocol() {
+    return Protocol.SPDY_3;
+  }
 
-final class Spdy3 implements Variant {
   static final int TYPE_DATA = 0x0;
   static final int TYPE_SYN_STREAM = 0x1;
   static final int TYPE_SYN_REPLY = 0x2;
   static final int TYPE_RST_STREAM = 0x3;
   static final int TYPE_SETTINGS = 0x4;
-  static final int TYPE_NOOP = 0x5;
   static final int TYPE_PING = 0x6;
   static final int TYPE_GOAWAY = 0x7;
   static final int TYPE_HEADERS = 0x8;
   static final int TYPE_WINDOW_UPDATE = 0x9;
-  static final int TYPE_CREDENTIAL = 0x10;
 
   static final int FLAG_FIN = 0x1;
   static final int FLAG_UNIDIRECTIONAL = 0x2;
@@ -92,28 +95,27 @@
     }
   }
 
-  @Override public FrameReader newReader(InputStream in, boolean client) {
-    return new Reader(in, client);
+  @Override public FrameReader newReader(BufferedSource source, boolean client) {
+    return new Reader(source, client);
   }
 
-  @Override public FrameWriter newWriter(OutputStream out, boolean client) {
-    return new Writer(out, client);
+  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
+    return new Writer(sink, client);
   }
 
   /** Read spdy/3 frames. */
   static final class Reader implements FrameReader {
-    private final DataInputStream in;
-    private final DataInputStream nameValueBlockIn;
+    private final BufferedSource source;
     private final boolean client;
-    private int compressedLimit;
+    private final NameValueBlockReader headerBlockReader;
 
-    Reader(InputStream in, boolean client) {
-      this.in = new DataInputStream(in);
-      this.nameValueBlockIn = newNameValueBlockStream();
+    Reader(BufferedSource source, boolean client) {
+      this.source = source;
+      this.headerBlockReader = new NameValueBlockReader(this.source);
       this.client = client;
     }
 
-    @Override public void readConnectionHeader() {
+    @Override public void readConnectionPreface() {
     }
 
     /**
@@ -122,12 +124,13 @@
      */
     @Override public boolean nextFrame(Handler handler) throws IOException {
       int w1;
+      int w2;
       try {
-        w1 = in.readInt();
+        w1 = source.readInt();
+        w2 = source.readInt();
       } catch (IOException e) {
         return false; // This might be a normal socket close.
       }
-      int w2 = in.readInt();
 
       boolean control = (w1 & 0x80000000) != 0;
       int flags = (w2 & 0xff000000) >>> 24;
@@ -158,11 +161,6 @@
             readSettings(handler, flags, length);
             return true;
 
-          case TYPE_NOOP:
-            if (length != 0) throw ioException("TYPE_NOOP length: %d != 0", length);
-            handler.noop();
-            return true;
-
           case TYPE_PING:
             readPing(handler, flags, length);
             return true;
@@ -179,49 +177,44 @@
             readWindowUpdate(handler, flags, length);
             return true;
 
-          case TYPE_CREDENTIAL:
-            Util.skipByReading(in, length);
-            throw new UnsupportedOperationException("TODO"); // TODO: implement
-
           default:
-            throw new IOException("Unexpected frame");
+            source.skip(length);
+            return true;
         }
       } else {
         int streamId = w1 & 0x7fffffff;
         boolean inFinished = (flags & FLAG_FIN) != 0;
-        handler.data(inFinished, streamId, in, length);
+        handler.data(inFinished, streamId, source, length);
         return true;
       }
     }
 
     private void readSynStream(Handler handler, int flags, int length) throws IOException {
-      int w1 = in.readInt();
-      int w2 = in.readInt();
-      int s3 = in.readShort();
+      int w1 = source.readInt();
+      int w2 = source.readInt();
       int streamId = w1 & 0x7fffffff;
       int associatedStreamId = w2 & 0x7fffffff;
-      int priority = (s3 & 0xe000) >>> 13;
-      int slot = s3 & 0xff;
-      List<String> nameValueBlock = readNameValueBlock(length - 10);
+      source.readShort(); // int priority = (s3 & 0xe000) >>> 13; int slot = s3 & 0xff;
+      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 10);
 
       boolean inFinished = (flags & FLAG_FIN) != 0;
       boolean outFinished = (flags & FLAG_UNIDIRECTIONAL) != 0;
-      handler.headers(outFinished, inFinished, streamId, associatedStreamId, priority,
-          nameValueBlock, HeadersMode.SPDY_SYN_STREAM);
+      handler.headers(outFinished, inFinished, streamId, associatedStreamId, headerBlock,
+          HeadersMode.SPDY_SYN_STREAM);
     }
 
     private void readSynReply(Handler handler, int flags, int length) throws IOException {
-      int w1 = in.readInt();
+      int w1 = source.readInt();
       int streamId = w1 & 0x7fffffff;
-      List<String> nameValueBlock = readNameValueBlock(length - 4);
+      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
       boolean inFinished = (flags & FLAG_FIN) != 0;
-      handler.headers(false, inFinished, streamId, -1, -1, nameValueBlock, HeadersMode.SPDY_REPLY);
+      handler.headers(false, inFinished, streamId, -1, headerBlock, HeadersMode.SPDY_REPLY);
     }
 
     private void readRstStream(Handler handler, int flags, int length) throws IOException {
       if (length != 8) throw ioException("TYPE_RST_STREAM length: %d != 8", length);
-      int streamId = in.readInt() & 0x7fffffff;
-      int errorCodeInt = in.readInt();
+      int streamId = source.readInt() & 0x7fffffff;
+      int errorCodeInt = source.readInt();
       ErrorCode errorCode = ErrorCode.fromSpdy3Rst(errorCodeInt);
       if (errorCode == null) {
         throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
@@ -230,121 +223,49 @@ private void readRstStream(Handler handler, int flags, int length) throws IOExce
     }
 
     private void readHeaders(Handler handler, int flags, int length) throws IOException {
-      int w1 = in.readInt();
+      int w1 = source.readInt();
       int streamId = w1 & 0x7fffffff;
-      List<String> nameValueBlock = readNameValueBlock(length - 4);
-      handler.headers(false, false, streamId, -1, -1, nameValueBlock, HeadersMode.SPDY_HEADERS);
+      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
+      handler.headers(false, false, streamId, -1, headerBlock, HeadersMode.SPDY_HEADERS);
     }
 
     private void readWindowUpdate(Handler handler, int flags, int length) throws IOException {
       if (length != 8) throw ioException("TYPE_WINDOW_UPDATE length: %d != 8", length);
-      int w1 = in.readInt();
-      int w2 = in.readInt();
+      int w1 = source.readInt();
+      int w2 = source.readInt();
       int streamId = w1 & 0x7fffffff;
-      int deltaWindowSize = w2 & 0x7fffffff;
-      handler.windowUpdate(streamId, deltaWindowSize, false);
-    }
-
-    private DataInputStream newNameValueBlockStream() {
-      // Limit the inflater input stream to only those bytes in the Name/Value block.
-      final InputStream throttleStream = new InputStream() {
-        @Override public int read() throws IOException {
-          return Util.readSingleByte(this);
-        }
-
-        @Override public int read(byte[] buffer, int offset, int byteCount) throws IOException {
-          byteCount = Math.min(byteCount, compressedLimit);
-          int consumed = in.read(buffer, offset, byteCount);
-          compressedLimit -= consumed;
-          return consumed;
-        }
-
-        @Override public void close() throws IOException {
-          in.close();
-        }
-      };
-
-      // Subclass inflater to install a dictionary when it's needed.
-      Inflater inflater = new Inflater() {
-        @Override public int inflate(byte[] buffer, int offset, int count)
-            throws DataFormatException {
-          int result = super.inflate(buffer, offset, count);
-          if (result == 0 && needsDictionary()) {
-            setDictionary(DICTIONARY);
-            result = super.inflate(buffer, offset, count);
-          }
-          return result;
-        }
-      };
-
-      return new DataInputStream(new InflaterInputStream(throttleStream, inflater));
-    }
-
-    private List<String> readNameValueBlock(int length) throws IOException {
-      this.compressedLimit += length;
-      try {
-        int numberOfPairs = nameValueBlockIn.readInt();
-        if (numberOfPairs < 0) {
-          Logger.getLogger(getClass().getName()).warning("numberOfPairs < 0: " + numberOfPairs);
-          throw ioException("numberOfPairs < 0");
-        }
-        if (numberOfPairs > 1024) {
-          Logger.getLogger(getClass().getName()).warning("numberOfPairs > 1024: " + numberOfPairs);
-          throw ioException("numberOfPairs > 1024");
-        }
-        List<String> entries = new ArrayList<String>(numberOfPairs * 2);
-        for (int i = 0; i < numberOfPairs; i++) {
-          String name = readString();
-          String values = readString();
-          if (name.length() == 0) throw ioException("name.length == 0");
-          entries.add(name);
-          entries.add(values);
-        }
-
-        if (compressedLimit != 0) {
-          Logger.getLogger(getClass().getName()).warning("compressedLimit > 0: " + compressedLimit);
-        }
-
-        return entries;
-      } catch (DataFormatException e) {
-        throw new IOException(e.getMessage());
-      }
-    }
-
-    private String readString() throws DataFormatException, IOException {
-      int length = nameValueBlockIn.readInt();
-      byte[] bytes = new byte[length];
-      Util.readFully(nameValueBlockIn, bytes);
-      return new String(bytes, 0, length, "UTF-8");
+      long increment = w2 & 0x7fffffff;
+      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
+      handler.windowUpdate(streamId, increment);
     }
 
     private void readPing(Handler handler, int flags, int length) throws IOException {
       if (length != 4) throw ioException("TYPE_PING length: %d != 4", length);
-      int id = in.readInt();
-      boolean reply = client == ((id % 2) == 1);
-      handler.ping(reply, id, 0);
+      int id = source.readInt();
+      boolean ack = client == ((id & 1) == 1);
+      handler.ping(ack, id, 0);
     }
 
     private void readGoAway(Handler handler, int flags, int length) throws IOException {
       if (length != 8) throw ioException("TYPE_GOAWAY length: %d != 8", length);
-      int lastGoodStreamId = in.readInt() & 0x7fffffff;
-      int errorCodeInt = in.readInt();
+      int lastGoodStreamId = source.readInt() & 0x7fffffff;
+      int errorCodeInt = source.readInt();
       ErrorCode errorCode = ErrorCode.fromSpdyGoAway(errorCodeInt);
       if (errorCode == null) {
         throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
       }
-      handler.goAway(lastGoodStreamId, errorCode);
+      handler.goAway(lastGoodStreamId, errorCode, ByteString.EMPTY);
     }
 
     private void readSettings(Handler handler, int flags, int length) throws IOException {
-      int numberOfEntries = in.readInt();
+      int numberOfEntries = source.readInt();
       if (length != 4 + 8 * numberOfEntries) {
         throw ioException("TYPE_SETTINGS length: %d != 4 + 8 * %d", length, numberOfEntries);
       }
       Settings settings = new Settings();
       for (int i = 0; i < numberOfEntries; i++) {
-        int w1 = in.readInt();
-        int value = in.readInt();
+        int w1 = source.readInt();
+        int value = source.readInt();
         int idFlags = (w1 & 0xff000000) >>> 24;
         int id = w1 & 0xffffff;
         settings.set(id, idFlags, value);
@@ -358,185 +279,214 @@ private static IOException ioException(String message, Object... args) throws IO
     }
 
     @Override public void close() throws IOException {
-      Util.closeAll(in, nameValueBlockIn);
+      headerBlockReader.close();
     }
   }
 
   /** Write spdy/3 frames. */
   static final class Writer implements FrameWriter {
-    private final DataOutputStream out;
-    private final ByteArrayOutputStream nameValueBlockBuffer;
-    private final DataOutputStream nameValueBlockOut;
+    private final BufferedSink sink;
+    private final Buffer headerBlockBuffer;
+    private final BufferedSink headerBlockOut;
     private final boolean client;
+    private boolean closed;
 
-    Writer(OutputStream out, boolean client) {
-      this.out = new DataOutputStream(out);
+    Writer(BufferedSink sink, boolean client) {
+      this.sink = sink;
       this.client = client;
 
       Deflater deflater = new Deflater();
       deflater.setDictionary(DICTIONARY);
-      nameValueBlockBuffer = new ByteArrayOutputStream();
-      nameValueBlockOut = new DataOutputStream(
-          Platform.get().newDeflaterOutputStream(nameValueBlockBuffer, deflater, true));
+      headerBlockBuffer = new Buffer();
+      headerBlockOut = Okio.buffer(new DeflaterSink(headerBlockBuffer, deflater));
+    }
+
+    @Override public void ackSettings(Settings peerSettings) {
+      // Do nothing: no ACK for SPDY/3 settings.
     }
 
-    @Override public synchronized void connectionHeader() {
-      // Do nothing: no connection header for SPDY/3.
+    @Override
+    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+        throws IOException {
+      // Do nothing: no push promise for SPDY/3.
+    }
+
+    @Override public synchronized void connectionPreface() {
+      // Do nothing: no connection preface for SPDY/3.
     }
 
     @Override public synchronized void flush() throws IOException {
-      out.flush();
+      if (closed) throw new IOException("closed");
+      sink.flush();
     }
 
     @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, int priority, int slot, List<String> nameValueBlock)
+        int streamId, int associatedStreamId, List<Header> headerBlock)
         throws IOException {
-      writeNameValueBlockToBuffer(nameValueBlock);
-      int length = 10 + nameValueBlockBuffer.size();
+      if (closed) throw new IOException("closed");
+      writeNameValueBlockToBuffer(headerBlock);
+      int length = (int) (10 + headerBlockBuffer.size());
       int type = TYPE_SYN_STREAM;
       int flags = (outFinished ? FLAG_FIN : 0) | (inFinished ? FLAG_UNIDIRECTIONAL : 0);
 
       int unused = 0;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(streamId & 0x7fffffff);
-      out.writeInt(associatedStreamId & 0x7fffffff);
-      out.writeShort((priority & 0x7) << 13 | (unused & 0x1f) << 8 | (slot & 0xff));
-      nameValueBlockBuffer.writeTo(out);
-      out.flush();
-    }
-
-    @Override public synchronized void synReply(
-        boolean outFinished, int streamId, List<String> nameValueBlock) throws IOException {
-      writeNameValueBlockToBuffer(nameValueBlock);
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(streamId & 0x7fffffff);
+      sink.writeInt(associatedStreamId & 0x7fffffff);
+      sink.writeShort((unused & 0x7) << 13 | (unused & 0x1f) << 8 | (unused & 0xff));
+      sink.writeAll(headerBlockBuffer);
+      sink.flush();
+    }
+
+    @Override public synchronized void synReply(boolean outFinished, int streamId,
+        List<Header> headerBlock) throws IOException {
+      if (closed) throw new IOException("closed");
+      writeNameValueBlockToBuffer(headerBlock);
       int type = TYPE_SYN_REPLY;
       int flags = (outFinished ? FLAG_FIN : 0);
-      int length = nameValueBlockBuffer.size() + 4;
+      int length = (int) (headerBlockBuffer.size() + 4);
 
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(streamId & 0x7fffffff);
-      nameValueBlockBuffer.writeTo(out);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(streamId & 0x7fffffff);
+      sink.writeAll(headerBlockBuffer);
+      sink.flush();
     }
 
-    @Override public synchronized void headers(int streamId, List<String> nameValueBlock)
+    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
         throws IOException {
-      writeNameValueBlockToBuffer(nameValueBlock);
+      if (closed) throw new IOException("closed");
+      writeNameValueBlockToBuffer(headerBlock);
       int flags = 0;
       int type = TYPE_HEADERS;
-      int length = nameValueBlockBuffer.size() + 4;
+      int length = (int) (headerBlockBuffer.size() + 4);
 
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(streamId & 0x7fffffff);
-      nameValueBlockBuffer.writeTo(out);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(streamId & 0x7fffffff);
+      sink.writeAll(headerBlockBuffer);
     }
 
     @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
         throws IOException {
+      if (closed) throw new IOException("closed");
       if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
       int flags = 0;
       int type = TYPE_RST_STREAM;
       int length = 8;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(streamId & 0x7fffffff);
-      out.writeInt(errorCode.spdyRstCode);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(streamId & 0x7fffffff);
+      sink.writeInt(errorCode.spdyRstCode);
+      sink.flush();
     }
 
-    @Override public synchronized void data(boolean outFinished, int streamId, byte[] data)
-        throws IOException {
-      data(outFinished, streamId, data, 0, data.length);
+    @Override public int maxDataLength() {
+      return 16383;
     }
 
-    @Override public synchronized void data(boolean outFinished, int streamId, byte[] data,
-        int offset, int byteCount) throws IOException {
+    @Override public synchronized void data(boolean outFinished, int streamId, Buffer source,
+        int byteCount) throws IOException {
       int flags = (outFinished ? FLAG_FIN : 0);
-      out.writeInt(streamId & 0x7fffffff);
-      out.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
-      out.write(data, offset, byteCount);
-    }
-
-    private void writeNameValueBlockToBuffer(List<String> nameValueBlock) throws IOException {
-      nameValueBlockBuffer.reset();
-      int numberOfPairs = nameValueBlock.size() / 2;
-      nameValueBlockOut.writeInt(numberOfPairs);
-      for (String s : nameValueBlock) {
-        nameValueBlockOut.writeInt(s.length());
-        nameValueBlockOut.write(s.getBytes("UTF-8"));
+      sendDataFrame(streamId, flags, source, byteCount);
+    }
+
+    void sendDataFrame(int streamId, int flags, Buffer buffer, int byteCount)
+        throws IOException {
+      if (closed) throw new IOException("closed");
+      if (byteCount > 0xffffffL) {
+        throw new IllegalArgumentException("FRAME_TOO_LARGE max size is 16Mib: " + byteCount);
+      }
+      sink.writeInt(streamId & 0x7fffffff);
+      sink.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
+      if (byteCount > 0) {
+        sink.write(buffer, byteCount);
+      }
+    }
+
+    private void writeNameValueBlockToBuffer(List<Header> headerBlock) throws IOException {
+      if (headerBlockBuffer.size() != 0) throw new IllegalStateException();
+      headerBlockOut.writeInt(headerBlock.size());
+      for (int i = 0, size = headerBlock.size(); i < size; i++) {
+        ByteString name = headerBlock.get(i).name;
+        headerBlockOut.writeInt(name.size());
+        headerBlockOut.write(name);
+        ByteString value = headerBlock.get(i).value;
+        headerBlockOut.writeInt(value.size());
+        headerBlockOut.write(value);
       }
-      nameValueBlockOut.flush();
+      headerBlockOut.flush();
     }
 
     @Override public synchronized void settings(Settings settings) throws IOException {
+      if (closed) throw new IOException("closed");
       int type = TYPE_SETTINGS;
       int flags = 0;
       int size = settings.size();
       int length = 4 + size * 8;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(size);
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(size);
       for (int i = 0; i <= Settings.COUNT; i++) {
         if (!settings.isSet(i)) continue;
         int settingsFlags = settings.flags(i);
-        out.writeInt((settingsFlags & 0xff) << 24 | (i & 0xffffff));
-        out.writeInt(settings.get(i));
+        sink.writeInt((settingsFlags & 0xff) << 24 | (i & 0xffffff));
+        sink.writeInt(settings.get(i));
       }
-      out.flush();
-    }
-
-    @Override public synchronized void noop() throws IOException {
-      int type = TYPE_NOOP;
-      int length = 0;
-      int flags = 0;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.flush();
+      sink.flush();
     }
 
     @Override public synchronized void ping(boolean reply, int payload1, int payload2)
         throws IOException {
-      boolean payloadIsReply = client != ((payload1 % 2) == 1);
+      if (closed) throw new IOException("closed");
+      boolean payloadIsReply = client != ((payload1 & 1) == 1);
       if (reply != payloadIsReply) throw new IllegalArgumentException("payload != reply");
       int type = TYPE_PING;
       int flags = 0;
       int length = 4;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(payload1);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(payload1);
+      sink.flush();
     }
 
-    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode)
-        throws IOException {
-      if (errorCode.spdyGoAwayCode == -1) throw new IllegalArgumentException();
+    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
+        byte[] ignored) throws IOException {
+      if (closed) throw new IOException("closed");
+      if (errorCode.spdyGoAwayCode == -1) {
+        throw new IllegalArgumentException("errorCode.spdyGoAwayCode == -1");
+      }
       int type = TYPE_GOAWAY;
       int flags = 0;
       int length = 8;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(lastGoodStreamId);
-      out.writeInt(errorCode.spdyGoAwayCode);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(lastGoodStreamId);
+      sink.writeInt(errorCode.spdyGoAwayCode);
+      sink.flush();
     }
 
-    @Override public synchronized void windowUpdate(int streamId, int deltaWindowSize)
+    @Override public synchronized void windowUpdate(int streamId, long increment)
         throws IOException {
+      if (closed) throw new IOException("closed");
+      if (increment == 0 || increment > 0x7fffffffL) {
+        throw new IllegalArgumentException(
+            "windowSizeIncrement must be between 1 and 0x7fffffff: " + increment);
+      }
       int type = TYPE_WINDOW_UPDATE;
       int flags = 0;
       int length = 8;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(streamId);
-      out.writeInt(deltaWindowSize);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(streamId);
+      sink.writeInt((int) increment);
+      sink.flush();
     }
 
-    @Override public void close() throws IOException {
-      Util.closeAll(out, nameValueBlockOut);
+    @Override public synchronized void close() throws IOException {
+      closed = true;
+      Util.closeAll(sink, headerBlockOut);
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
new file mode 100644
index 0000000000..e7ab87348a
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -0,0 +1,871 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.NamedRunnable;
+import com.squareup.okhttp.internal.Util;
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+
+import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+
+/**
+ * A socket connection to a remote peer. A connection hosts streams which can
+ * send and receive data.
+ *
+ * <p>Many methods in this API are <strong>synchronous:</strong> the call is
+ * completed before the method returns. This is typical for Java but atypical
+ * for SPDY. This is motivated by exception transparency: an IOException that
+ * was triggered by a certain caller can be caught and handled by that caller.
+ */
+public final class SpdyConnection implements Closeable {
+
+  // Internal state of this connection is guarded by 'this'. No blocking
+  // operations may be performed while holding this lock!
+  //
+  // Socket writes are guarded by frameWriter.
+  //
+  // Socket reads are unguarded but are only made by the reader thread.
+  //
+  // Certain operations (like SYN_STREAM) need to synchronize on both the
+  // frameWriter (to do blocking I/O) and this (to create streams). Such
+  // operations must synchronize on 'this' last. This ensures that we never
+  // wait for a blocking operation while holding 'this'.
+
+  private static final ExecutorService executor = new ThreadPoolExecutor(0,
+      Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
+      Util.threadFactory("OkHttp SpdyConnection", true));
+
+  /** The protocol variant, like {@link com.squareup.okhttp.internal.spdy.Spdy3}. */
+  final Protocol protocol;
+
+  /** True if this peer initiated the connection. */
+  final boolean client;
+
+  /**
+   * User code to run in response to an incoming stream. Callbacks must not be
+   * run on the callback executor.
+   */
+  private final IncomingStreamHandler handler;
+  private final Map<Integer, SpdyStream> streams = new HashMap<>();
+  private final String hostName;
+  private int lastGoodStreamId;
+  private int nextStreamId;
+  private boolean shutdown;
+  private long idleStartTimeNs = System.nanoTime();
+
+  /** Ensures push promise callbacks events are sent in order per stream. */
+  private final ExecutorService pushExecutor;
+
+  /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
+  private Map<Integer, Ping> pings;
+  /** User code to run in response to push promise events. */
+  private final PushObserver pushObserver;
+  private int nextPingId;
+
+  /**
+   * The total number of bytes consumed by the application, but not yet
+   * acknowledged by sending a {@code WINDOW_UPDATE} frame on this connection.
+   */
+  // Visible for testing
+  long unacknowledgedBytesRead = 0;
+
+  /**
+   * Count of bytes that can be written on the connection before receiving a
+   * window update.
+   */
+  // Visible for testing
+  long bytesLeftInWriteWindow;
+
+  /** Settings we communicate to the peer. */
+  // TODO: Do we want to dynamically adjust settings, or KISS and only set once?
+  final Settings okHttpSettings = new Settings();
+      // okHttpSettings.set(Settings.MAX_CONCURRENT_STREAMS, 0, max);
+  private static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
+
+  /** Settings we receive from the peer. */
+  // TODO: MWS will need to guard on this setting before attempting to push.
+  final Settings peerSettings = new Settings();
+
+  private boolean receivedInitialPeerSettings = false;
+  final Variant variant;
+  final Socket socket;
+  final FrameWriter frameWriter;
+
+  // Visible for testing
+  final Reader readerRunnable;
+
+  private SpdyConnection(Builder builder) throws IOException {
+    protocol = builder.protocol;
+    pushObserver = builder.pushObserver;
+    client = builder.client;
+    handler = builder.handler;
+    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-5.1.1
+    nextStreamId = builder.client ? 1 : 2;
+    if (builder.client && protocol == Protocol.HTTP_2) {
+      nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
+    }
+
+    nextPingId = builder.client ? 1 : 2;
+
+    // Flow control was designed more for servers, or proxies than edge clients.
+    // If we are a client, set the flow control window to 16MiB.  This avoids
+    // thrashing window updates every 64KiB, yet small enough to avoid blowing
+    // up the heap.
+    if (builder.client) {
+      okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, OKHTTP_CLIENT_WINDOW_SIZE);
+    }
+
+    hostName = builder.hostName;
+
+    if (protocol == Protocol.HTTP_2) {
+      variant = new Http20Draft16();
+      // Like newSingleThreadExecutor, except lazy creates the thread.
+      pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
+          new LinkedBlockingQueue<Runnable>(),
+          Util.threadFactory(String.format("OkHttp %s Push Observer", hostName), true));
+      // 1 less than SPDY http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-6.9.2
+      peerSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
+      peerSettings.set(Settings.MAX_FRAME_SIZE, 0, Http20Draft16.INITIAL_MAX_FRAME_SIZE);
+    } else if (protocol == Protocol.SPDY_3) {
+      variant = new Spdy3();
+      pushExecutor = null;
+    } else {
+      throw new AssertionError(protocol);
+    }
+    bytesLeftInWriteWindow = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+    socket = builder.socket;
+    frameWriter = variant.newWriter(Okio.buffer(Okio.sink(builder.socket)), client);
+
+    readerRunnable = new Reader();
+    new Thread(readerRunnable).start(); // Not a daemon thread.
+  }
+
+  /** The protocol as selected using ALPN. */
+  public Protocol getProtocol() {
+    return protocol;
+  }
+
+  /**
+   * Returns the number of {@link SpdyStream#isOpen() open streams} on this
+   * connection.
+   */
+  public synchronized int openStreamCount() {
+    return streams.size();
+  }
+
+  synchronized SpdyStream getStream(int id) {
+    return streams.get(id);
+  }
+
+  synchronized SpdyStream removeStream(int streamId) {
+    SpdyStream stream = streams.remove(streamId);
+    if (stream != null && streams.isEmpty()) {
+      setIdle(true);
+    }
+    return stream;
+  }
+
+  private synchronized void setIdle(boolean value) {
+    idleStartTimeNs = value ? System.nanoTime() : Long.MAX_VALUE;
+  }
+
+  /** Returns true if this connection is idle. */
+  public synchronized boolean isIdle() {
+    return idleStartTimeNs != Long.MAX_VALUE;
+  }
+
+  /**
+   * Returns the time in ns when this connection became idle or Long.MAX_VALUE
+   * if connection is not idle.
+   */
+  public synchronized long getIdleStartTimeNs() {
+    return idleStartTimeNs;
+  }
+
+  /**
+   * Returns a new server-initiated stream.
+   *
+   * @param associatedStreamId the stream that triggered the sender to create
+   *     this stream.
+   * @param out true to create an output stream that we can use to send data
+   *     to the remote peer. Corresponds to {@code FLAG_FIN}.
+   */
+  public SpdyStream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
+      throws IOException {
+    if (client) throw new IllegalStateException("Client cannot push requests.");
+    if (protocol != Protocol.HTTP_2) throw new IllegalStateException("protocol != HTTP_2");
+    return newStream(associatedStreamId, requestHeaders, out, false);
+  }
+
+  /**
+   * Returns a new locally-initiated stream.
+   *
+   * @param out true to create an output stream that we can use to send data to the remote peer.
+   *     Corresponds to {@code FLAG_FIN}.
+   * @param in true to create an input stream that the remote peer can use to send data to us.
+   *     Corresponds to {@code FLAG_UNIDIRECTIONAL}.
+   */
+  public SpdyStream newStream(List<Header> requestHeaders, boolean out, boolean in)
+      throws IOException {
+    return newStream(0, requestHeaders, out, in);
+  }
+
+  private SpdyStream newStream(int associatedStreamId, List<Header> requestHeaders, boolean out,
+      boolean in) throws IOException {
+    boolean outFinished = !out;
+    boolean inFinished = !in;
+    SpdyStream stream;
+    int streamId;
+
+    synchronized (frameWriter) {
+      synchronized (this) {
+        if (shutdown) {
+          throw new IOException("shutdown");
+        }
+        streamId = nextStreamId;
+        nextStreamId += 2;
+        stream = new SpdyStream(streamId, this, outFinished, inFinished, requestHeaders);
+        if (stream.isOpen()) {
+          streams.put(streamId, stream);
+          setIdle(false);
+        }
+      }
+      if (associatedStreamId == 0) {
+        frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId,
+            requestHeaders);
+      } else if (client) {
+        throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
+      } else { // HTTP/2 has a PUSH_PROMISE frame.
+        frameWriter.pushPromise(associatedStreamId, streamId, requestHeaders);
+      }
+    }
+
+    if (!out) {
+      frameWriter.flush();
+    }
+
+    return stream;
+  }
+
+  void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
+      throws IOException {
+    frameWriter.synReply(outFinished, streamId, alternating);
+  }
+
+  /**
+   * Callers of this method are not thread safe, and sometimes on application
+   * threads.  Most often, this method will be called to send a buffer worth of
+   * data to the peer.
+   * <p>
+   * Writes are subject to the write window of the stream and the connection.
+   * Until there is a window sufficient to send {@code byteCount}, the caller
+   * will block.  For example, a user of {@code HttpURLConnection} who flushes
+   * more bytes to the output stream than the connection's write window will
+   * block.
+   * <p>
+   * Zero {@code byteCount} writes are not subject to flow control and
+   * will not block.  The only use case for zero {@code byteCount} is closing
+   * a flushed output stream.
+   */
+  public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount)
+      throws IOException {
+    if (byteCount == 0) { // Empty data frames are not flow-controlled.
+      frameWriter.data(outFinished, streamId, buffer, 0);
+      return;
+    }
+
+    while (byteCount > 0) {
+      int toWrite;
+      synchronized (SpdyConnection.this) {
+        try {
+          while (bytesLeftInWriteWindow <= 0) {
+            SpdyConnection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
+          }
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+
+        toWrite = (int) Math.min(byteCount, bytesLeftInWriteWindow);
+        toWrite = Math.min(toWrite, frameWriter.maxDataLength());
+        bytesLeftInWriteWindow -= toWrite;
+      }
+
+      byteCount -= toWrite;
+      frameWriter.data(outFinished && byteCount == 0, streamId, buffer, toWrite);
+    }
+  }
+
+  /**
+   * {@code delta} will be negative if a settings frame initial window is
+   * smaller than the last.
+   */
+  void addBytesToWriteWindow(long delta) {
+    bytesLeftInWriteWindow += delta;
+    if (delta > 0) SpdyConnection.this.notifyAll();
+  }
+
+  void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
+    executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
+      @Override public void execute() {
+        try {
+          writeSynReset(streamId, errorCode);
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
+    frameWriter.rstStream(streamId, statusCode);
+  }
+
+  void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
+    executor.submit(new NamedRunnable("OkHttp Window Update %s stream %d", hostName, streamId) {
+      @Override public void execute() {
+        try {
+          frameWriter.windowUpdate(streamId, unacknowledgedBytesRead);
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  /**
+   * Sends a ping frame to the peer. Use the returned object to await the
+   * ping's response and observe its round trip time.
+   */
+  public Ping ping() throws IOException {
+    Ping ping = new Ping();
+    int pingId;
+    synchronized (this) {
+      if (shutdown) {
+        throw new IOException("shutdown");
+      }
+      pingId = nextPingId;
+      nextPingId += 2;
+      if (pings == null) pings = new HashMap<>();
+      pings.put(pingId, ping);
+    }
+    writePing(false, pingId, 0x4f4b6f6b /* ASCII "OKok" */, ping);
+    return ping;
+  }
+
+  private void writePingLater(
+      final boolean reply, final int payload1, final int payload2, final Ping ping) {
+    executor.submit(new NamedRunnable("OkHttp %s ping %08x%08x",
+        hostName, payload1, payload2) {
+      @Override public void execute() {
+        try {
+          writePing(reply, payload1, payload2, ping);
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  private void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
+    synchronized (frameWriter) {
+      // Observe the sent time immediately before performing I/O.
+      if (ping != null) ping.send();
+      frameWriter.ping(reply, payload1, payload2);
+    }
+  }
+
+  private synchronized Ping removePing(int id) {
+    return pings != null ? pings.remove(id) : null;
+  }
+
+  public void flush() throws IOException {
+    frameWriter.flush();
+  }
+
+  /**
+   * Degrades this connection such that new streams can neither be created
+   * locally, nor accepted from the remote peer. Existing streams are not
+   * impacted. This is intended to permit an endpoint to gracefully stop
+   * accepting new requests without harming previously established streams.
+   */
+  public void shutdown(ErrorCode statusCode) throws IOException {
+    synchronized (frameWriter) {
+      int lastGoodStreamId;
+      synchronized (this) {
+        if (shutdown) {
+          return;
+        }
+        shutdown = true;
+        lastGoodStreamId = this.lastGoodStreamId;
+      }
+      // TODO: propagate exception message into debugData
+      frameWriter.goAway(lastGoodStreamId, statusCode, Util.EMPTY_BYTE_ARRAY);
+    }
+  }
+
+  /**
+   * Closes this connection. This cancels all open streams and unanswered
+   * pings. It closes the underlying input and output streams and shuts down
+   * internal executor services.
+   */
+  @Override public void close() throws IOException {
+    close(ErrorCode.NO_ERROR, ErrorCode.CANCEL);
+  }
+
+  private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
+    assert (!Thread.holdsLock(this));
+    IOException thrown = null;
+    try {
+      shutdown(connectionCode);
+    } catch (IOException e) {
+      thrown = e;
+    }
+
+    SpdyStream[] streamsToClose = null;
+    Ping[] pingsToCancel = null;
+    synchronized (this) {
+      if (!streams.isEmpty()) {
+        streamsToClose = streams.values().toArray(new SpdyStream[streams.size()]);
+        streams.clear();
+        setIdle(false);
+      }
+      if (pings != null) {
+        pingsToCancel = pings.values().toArray(new Ping[pings.size()]);
+        pings = null;
+      }
+    }
+
+    if (streamsToClose != null) {
+      for (SpdyStream stream : streamsToClose) {
+        try {
+          stream.close(streamCode);
+        } catch (IOException e) {
+          if (thrown != null) thrown = e;
+        }
+      }
+    }
+
+    if (pingsToCancel != null) {
+      for (Ping ping : pingsToCancel) {
+        ping.cancel();
+      }
+    }
+
+    // Close the writer to release its resources (such as deflaters).
+    try {
+      frameWriter.close();
+    } catch (IOException e) {
+      if (thrown == null) thrown = e;
+    }
+
+    // Close the socket to break out the reader thread, which will clean up after itself.
+    try {
+      socket.close();
+    } catch (IOException e) {
+      thrown = e;
+    }
+
+    if (thrown != null) throw thrown;
+  }
+
+  /**
+   * Sends a connection header if the current variant requires it. This should
+   * be called after {@link Builder#build} for all new connections.
+   */
+  public void sendConnectionPreface() throws IOException {
+    frameWriter.connectionPreface();
+    frameWriter.settings(okHttpSettings);
+    int windowSize = okHttpSettings.getInitialWindowSize(Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+    if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) {
+      frameWriter.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+    }
+  }
+
+  public static class Builder {
+    private String hostName;
+    private Socket socket;
+    private IncomingStreamHandler handler = IncomingStreamHandler.REFUSE_INCOMING_STREAMS;
+    private Protocol protocol = Protocol.SPDY_3;
+    private PushObserver pushObserver = PushObserver.CANCEL;
+    private boolean client;
+
+    public Builder(boolean client, Socket socket) throws IOException {
+      this(((InetSocketAddress) socket.getRemoteSocketAddress()).getHostName(), client, socket);
+    }
+
+    /**
+     * @param client true if this peer initiated the connection; false if this
+     *     peer accepted the connection.
+     */
+    public Builder(String hostName, boolean client, Socket socket) throws IOException {
+      this.hostName = hostName;
+      this.client = client;
+      this.socket = socket;
+    }
+
+    public Builder handler(IncomingStreamHandler handler) {
+      this.handler = handler;
+      return this;
+    }
+
+    public Builder protocol(Protocol protocol) {
+      this.protocol = protocol;
+      return this;
+    }
+
+    public Builder pushObserver(PushObserver pushObserver) {
+      this.pushObserver = pushObserver;
+      return this;
+    }
+
+    public SpdyConnection build() throws IOException {
+      return new SpdyConnection(this);
+    }
+  }
+
+  /**
+   * Methods in this class must not lock FrameWriter.  If a method needs to
+   * write a frame, create an async task to do so.
+   */
+  class Reader extends NamedRunnable implements FrameReader.Handler {
+    FrameReader frameReader;
+
+    private Reader() {
+      super("OkHttp %s", hostName);
+    }
+
+    @Override protected void execute() {
+      ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
+      ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
+      try {
+        frameReader = variant.newReader(Okio.buffer(Okio.source(socket)), client);
+        if (!client) {
+          frameReader.readConnectionPreface();
+        }
+        while (frameReader.nextFrame(this)) {
+        }
+        connectionErrorCode = ErrorCode.NO_ERROR;
+        streamErrorCode = ErrorCode.CANCEL;
+      } catch (IOException e) {
+        connectionErrorCode = ErrorCode.PROTOCOL_ERROR;
+        streamErrorCode = ErrorCode.PROTOCOL_ERROR;
+      } finally {
+        try {
+          close(connectionErrorCode, streamErrorCode);
+        } catch (IOException ignored) {
+        }
+        Util.closeQuietly(frameReader);
+      }
+    }
+
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
+        throws IOException {
+      if (pushedStream(streamId)) {
+        pushDataLater(streamId, source, length, inFinished);
+        return;
+      }
+      SpdyStream dataStream = getStream(streamId);
+      if (dataStream == null) {
+        writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
+        source.skip(length);
+        return;
+      }
+      dataStream.receiveData(source, length);
+      if (inFinished) {
+        dataStream.receiveFin();
+      }
+    }
+
+    @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
+        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+      if (pushedStream(streamId)) {
+        pushHeadersLater(streamId, headerBlock, inFinished);
+        return;
+      }
+      SpdyStream stream;
+      synchronized (SpdyConnection.this) {
+        // If we're shutdown, don't bother with this stream.
+        if (shutdown) return;
+
+        stream = getStream(streamId);
+
+        if (stream == null) {
+          // The headers claim to be for an existing stream, but we don't have one.
+          if (headersMode.failIfStreamAbsent()) {
+            writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
+            return;
+          }
+
+          // If the stream ID is less than the last created ID, assume it's already closed.
+          if (streamId <= lastGoodStreamId) return;
+
+          // If the stream ID is in the client's namespace, assume it's already closed.
+          if (streamId % 2 == nextStreamId % 2) return;
+
+          // Create a stream.
+          final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,
+              inFinished, headerBlock);
+          lastGoodStreamId = streamId;
+          streams.put(streamId, newStream);
+          executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
+            @Override public void execute() {
+              try {
+                handler.receive(newStream);
+              } catch (IOException e) {
+                throw new RuntimeException(e);
+              }
+            }
+          });
+          return;
+        }
+      }
+
+      // The headers claim to be for a new stream, but we already have one.
+      if (headersMode.failIfStreamPresent()) {
+        stream.closeLater(ErrorCode.PROTOCOL_ERROR);
+        removeStream(streamId);
+        return;
+      }
+
+      // Update an existing stream.
+      stream.receiveHeaders(headerBlock, headersMode);
+      if (inFinished) stream.receiveFin();
+    }
+
+    @Override public void rstStream(int streamId, ErrorCode errorCode) {
+      if (pushedStream(streamId)) {
+        pushResetLater(streamId, errorCode);
+        return;
+      }
+      SpdyStream rstStream = removeStream(streamId);
+      if (rstStream != null) {
+        rstStream.receiveRstStream(errorCode);
+      }
+    }
+
+    @Override public void settings(boolean clearPrevious, Settings newSettings) {
+      long delta = 0;
+      SpdyStream[] streamsToNotify = null;
+      synchronized (SpdyConnection.this) {
+        int priorWriteWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+        if (clearPrevious) peerSettings.clear();
+        peerSettings.merge(newSettings);
+        if (getProtocol() == Protocol.HTTP_2) {
+          ackSettingsLater(newSettings);
+        }
+        int peerInitialWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+        if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
+          delta = peerInitialWindowSize - priorWriteWindowSize;
+          if (!receivedInitialPeerSettings) {
+            addBytesToWriteWindow(delta);
+            receivedInitialPeerSettings = true;
+          }
+          if (!streams.isEmpty()) {
+            streamsToNotify = streams.values().toArray(new SpdyStream[streams.size()]);
+          }
+        }
+      }
+      if (streamsToNotify != null && delta != 0) {
+        for (SpdyStream stream : streamsToNotify) {
+          synchronized (stream) {
+            stream.addBytesToWriteWindow(delta);
+          }
+        }
+      }
+    }
+
+    private void ackSettingsLater(final Settings peerSettings) {
+      executor.submit(new NamedRunnable("OkHttp %s ACK Settings", hostName) {
+        @Override public void execute() {
+          try {
+            frameWriter.ackSettings(peerSettings);
+          } catch (IOException ignored) {
+          }
+        }
+      });
+    }
+
+    @Override public void ackSettings() {
+      // TODO: If we don't get this callback after sending settings to the peer, SETTINGS_TIMEOUT.
+    }
+
+    @Override public void ping(boolean reply, int payload1, int payload2) {
+      if (reply) {
+        Ping ping = removePing(payload1);
+        if (ping != null) {
+          ping.receive();
+        }
+      } else {
+        // Send a reply to a client ping if this is a server and vice versa.
+        writePingLater(true, payload1, payload2, null);
+      }
+    }
+
+    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+      if (debugData.size() > 0) { // TODO: log the debugData
+      }
+
+      // Copy the streams first. We don't want to hold a lock when we call receiveRstStream().
+      SpdyStream[] streamsCopy;
+      synchronized (SpdyConnection.this) {
+        streamsCopy = streams.values().toArray(new SpdyStream[streams.size()]);
+        shutdown = true;
+      }
+
+      // Fail all streams created after the last good stream ID.
+      for (SpdyStream spdyStream : streamsCopy) {
+        if (spdyStream.getId() > lastGoodStreamId && spdyStream.isLocallyInitiated()) {
+          spdyStream.receiveRstStream(ErrorCode.REFUSED_STREAM);
+          removeStream(spdyStream.getId());
+        }
+      }
+    }
+
+    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
+      if (streamId == 0) {
+        synchronized (SpdyConnection.this) {
+          bytesLeftInWriteWindow += windowSizeIncrement;
+          SpdyConnection.this.notifyAll();
+        }
+      } else {
+        SpdyStream stream = getStream(streamId);
+        if (stream != null) {
+          synchronized (stream) {
+            stream.addBytesToWriteWindow(windowSizeIncrement);
+          }
+        }
+      }
+    }
+
+    @Override public void priority(int streamId, int streamDependency, int weight,
+        boolean exclusive) {
+      // TODO: honor priority.
+    }
+
+    @Override
+    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders) {
+      pushRequestLater(promisedStreamId, requestHeaders);
+    }
+
+    @Override public void alternateService(int streamId, String origin, ByteString protocol,
+        String host, int port, long maxAge) {
+      // TODO: register alternate service.
+    }
+  }
+
+  /** Even, positive numbered streams are pushed streams in HTTP/2. */
+  private boolean pushedStream(int streamId) {
+    return protocol == Protocol.HTTP_2 && streamId != 0 && (streamId & 1) == 0;
+  }
+
+  // Guarded by this.
+  private final Set<Integer> currentPushRequests = new LinkedHashSet<>();
+
+  private void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
+    synchronized (this) {
+      if (currentPushRequests.contains(streamId)) {
+        writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
+        return;
+      }
+      currentPushRequests.add(streamId);
+    }
+    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
+      @Override public void execute() {
+        boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
+        try {
+          if (cancel) {
+            frameWriter.rstStream(streamId, ErrorCode.CANCEL);
+            synchronized (SpdyConnection.this) {
+              currentPushRequests.remove(streamId);
+            }
+          }
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
+      final boolean inFinished) {
+    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
+      @Override public void execute() {
+        boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
+        try {
+          if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
+          if (cancel || inFinished) {
+            synchronized (SpdyConnection.this) {
+              currentPushRequests.remove(streamId);
+            }
+          }
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  /**
+   * Eagerly reads {@code byteCount} bytes from the source before launching a background task to
+   * process the data.  This avoids corrupting the stream.
+   */
+  private void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
+      final boolean inFinished) throws IOException {
+    final Buffer buffer = new Buffer();
+    source.require(byteCount); // Eagerly read the frame before firing client thread.
+    source.read(buffer, byteCount);
+    if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
+    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
+      @Override public void execute() {
+        try {
+          boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
+          if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
+          if (cancel || inFinished) {
+            synchronized (SpdyConnection.this) {
+              currentPushRequests.remove(streamId);
+            }
+          }
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  private void pushResetLater(final int streamId, final ErrorCode errorCode) {
+    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
+      @Override public void execute() {
+        pushObserver.onReset(streamId, errorCode);
+        synchronized (SpdyConnection.this) {
+          currentPushRequests.remove(streamId);
+        }
+      }
+    });
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
new file mode 100644
index 0000000000..331536d376
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -0,0 +1,576 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.util.ArrayList;
+import java.util.List;
+import okio.AsyncTimeout;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
+
+import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+
+/** A logical bidirectional stream. */
+public final class SpdyStream {
+  // Internal state is guarded by this. No long-running or potentially
+  // blocking operations are performed while the lock is held.
+
+  /**
+   * The total number of bytes consumed by the application (with {@link
+   * SpdyDataSource#read}), but not yet acknowledged by sending a {@code
+   * WINDOW_UPDATE} frame on this stream.
+   */
+  // Visible for testing
+  long unacknowledgedBytesRead = 0;
+
+  /**
+   * Count of bytes that can be written on the stream before receiving a
+   * window update. Even if this is positive, writes will block until there
+   * available bytes in {@code connection.bytesLeftInWriteWindow}.
+   */
+  // guarded by this
+  long bytesLeftInWriteWindow;
+
+  private final int id;
+  private final SpdyConnection connection;
+  private long readTimeoutMillis = 0;
+
+  /** Headers sent by the stream initiator. Immutable and non null. */
+  private final List<Header> requestHeaders;
+
+  /** Headers sent in the stream reply. Null if reply is either not sent or not sent yet. */
+  private List<Header> responseHeaders;
+
+  private final SpdyDataSource source;
+  final SpdyDataSink sink;
+  private final SpdyTimeout readTimeout = new SpdyTimeout();
+  private final SpdyTimeout writeTimeout = new SpdyTimeout();
+
+  /**
+   * The reason why this stream was abnormally closed. If there are multiple
+   * reasons to abnormally close this stream (such as both peers closing it
+   * near-simultaneously) then this is the first reason known to this peer.
+   */
+  private ErrorCode errorCode = null;
+
+  SpdyStream(int id, SpdyConnection connection, boolean outFinished, boolean inFinished,
+      List<Header> requestHeaders) {
+    if (connection == null) throw new NullPointerException("connection == null");
+    if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
+    this.id = id;
+    this.connection = connection;
+    this.bytesLeftInWriteWindow =
+        connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+    this.source = new SpdyDataSource(
+        connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
+    this.sink = new SpdyDataSink();
+    this.source.finished = inFinished;
+    this.sink.finished = outFinished;
+    this.requestHeaders = requestHeaders;
+  }
+
+  public int getId() {
+    return id;
+  }
+
+  /**
+   * Returns true if this stream is open. A stream is open until either:
+   * <ul>
+   * <li>A {@code SYN_RESET} frame abnormally terminates the stream.
+   * <li>Both input and output streams have transmitted all data and
+   * headers.
+   * </ul>
+   * Note that the input stream may continue to yield data even after a stream
+   * reports itself as not open. This is because input data is buffered.
+   */
+  public synchronized boolean isOpen() {
+    if (errorCode != null) {
+      return false;
+    }
+    if ((source.finished || source.closed)
+        && (sink.finished || sink.closed)
+        && responseHeaders != null) {
+      return false;
+    }
+    return true;
+  }
+
+  /** Returns true if this stream was created by this peer. */
+  public boolean isLocallyInitiated() {
+    boolean streamIsClient = ((id & 1) == 1);
+    return connection.client == streamIsClient;
+  }
+
+  public SpdyConnection getConnection() {
+    return connection;
+  }
+
+  public List<Header> getRequestHeaders() {
+    return requestHeaders;
+  }
+
+  /**
+   * Returns the stream's response headers, blocking if necessary if they
+   * have not been received yet.
+   */
+  public synchronized List<Header> getResponseHeaders() throws IOException {
+    readTimeout.enter();
+    try {
+      while (responseHeaders == null && errorCode == null) {
+        waitForIo();
+      }
+    } finally {
+      readTimeout.exitAndThrowIfTimedOut();
+    }
+    if (responseHeaders != null) return responseHeaders;
+    throw new IOException("stream was reset: " + errorCode);
+  }
+
+  /**
+   * Returns the reason why this stream was closed, or null if it closed
+   * normally or has not yet been closed.
+   */
+  public synchronized ErrorCode getErrorCode() {
+    return errorCode;
+  }
+
+  /**
+   * Sends a reply to an incoming stream.
+   *
+   * @param out true to create an output stream that we can use to send data
+   * to the remote peer. Corresponds to {@code FLAG_FIN}.
+   */
+  public void reply(List<Header> responseHeaders, boolean out) throws IOException {
+    assert (!Thread.holdsLock(SpdyStream.this));
+    boolean outFinished = false;
+    synchronized (this) {
+      if (responseHeaders == null) {
+        throw new NullPointerException("responseHeaders == null");
+      }
+      if (this.responseHeaders != null) {
+        throw new IllegalStateException("reply already sent");
+      }
+      this.responseHeaders = responseHeaders;
+      if (!out) {
+        this.sink.finished = true;
+        outFinished = true;
+      }
+    }
+    connection.writeSynReply(id, outFinished, responseHeaders);
+
+    if (outFinished) {
+      connection.flush();
+    }
+  }
+
+  public Timeout readTimeout() {
+    return readTimeout;
+  }
+
+  public Timeout writeTimeout() {
+    return writeTimeout;
+  }
+
+  /** Returns a source that reads data from the peer. */
+  public Source getSource() {
+    return source;
+  }
+
+  /**
+   * Returns a sink that can be used to write data to the peer.
+   *
+   * @throws IllegalStateException if this stream was initiated by the peer
+   *     and a {@link #reply} has not yet been sent.
+   */
+  public Sink getSink() {
+    synchronized (this) {
+      if (responseHeaders == null && !isLocallyInitiated()) {
+        throw new IllegalStateException("reply before requesting the sink");
+      }
+    }
+    return sink;
+  }
+
+  /**
+   * Abnormally terminate this stream. This blocks until the {@code RST_STREAM}
+   * frame has been transmitted.
+   */
+  public void close(ErrorCode rstStatusCode) throws IOException {
+    if (!closeInternal(rstStatusCode)) {
+      return; // Already closed.
+    }
+    connection.writeSynReset(id, rstStatusCode);
+  }
+
+  /**
+   * Abnormally terminate this stream. This enqueues a {@code RST_STREAM}
+   * frame and returns immediately.
+   */
+  public void closeLater(ErrorCode errorCode) {
+    if (!closeInternal(errorCode)) {
+      return; // Already closed.
+    }
+    connection.writeSynResetLater(id, errorCode);
+  }
+
+  /** Returns true if this stream was closed. */
+  private boolean closeInternal(ErrorCode errorCode) {
+    assert (!Thread.holdsLock(this));
+    synchronized (this) {
+      if (this.errorCode != null) {
+        return false;
+      }
+      if (source.finished && sink.finished) {
+        return false;
+      }
+      this.errorCode = errorCode;
+      notifyAll();
+    }
+    connection.removeStream(id);
+    return true;
+  }
+
+  void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
+    assert (!Thread.holdsLock(SpdyStream.this));
+    ErrorCode errorCode = null;
+    boolean open = true;
+    synchronized (this) {
+      if (responseHeaders == null) {
+        if (headersMode.failIfHeadersAbsent()) {
+          errorCode = ErrorCode.PROTOCOL_ERROR;
+        } else {
+          responseHeaders = headers;
+          open = isOpen();
+          notifyAll();
+        }
+      } else {
+        if (headersMode.failIfHeadersPresent()) {
+          errorCode = ErrorCode.STREAM_IN_USE;
+        } else {
+          List<Header> newHeaders = new ArrayList<>();
+          newHeaders.addAll(responseHeaders);
+          newHeaders.addAll(headers);
+          this.responseHeaders = newHeaders;
+        }
+      }
+    }
+    if (errorCode != null) {
+      closeLater(errorCode);
+    } else if (!open) {
+      connection.removeStream(id);
+    }
+  }
+
+  void receiveData(BufferedSource in, int length) throws IOException {
+    assert (!Thread.holdsLock(SpdyStream.this));
+    this.source.receive(in, length);
+  }
+
+  void receiveFin() {
+    assert (!Thread.holdsLock(SpdyStream.this));
+    boolean open;
+    synchronized (this) {
+      this.source.finished = true;
+      open = isOpen();
+      notifyAll();
+    }
+    if (!open) {
+      connection.removeStream(id);
+    }
+  }
+
+  synchronized void receiveRstStream(ErrorCode errorCode) {
+    if (this.errorCode == null) {
+      this.errorCode = errorCode;
+      notifyAll();
+    }
+  }
+
+  /**
+   * A source that reads the incoming data frames of a stream. Although this
+   * class uses synchronization to safely receive incoming data frames, it is
+   * not intended for use by multiple readers.
+   */
+  private final class SpdyDataSource implements Source {
+    /** Buffer to receive data from the network into. Only accessed by the reader thread. */
+    private final Buffer receiveBuffer = new Buffer();
+
+    /** Buffer with readable data. Guarded by SpdyStream.this. */
+    private final Buffer readBuffer = new Buffer();
+
+    /** Maximum number of bytes to buffer before reporting a flow control error. */
+    private final long maxByteCount;
+
+    /** True if the caller has closed this stream. */
+    private boolean closed;
+
+    /**
+     * True if either side has cleanly shut down this stream. We will
+     * receive no more bytes beyond those already in the buffer.
+     */
+    private boolean finished;
+
+    private SpdyDataSource(long maxByteCount) {
+      this.maxByteCount = maxByteCount;
+    }
+
+    @Override public long read(Buffer sink, long byteCount)
+        throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+
+      long read;
+      synchronized (SpdyStream.this) {
+        waitUntilReadable();
+        checkNotClosed();
+        if (readBuffer.size() == 0) return -1; // This source is exhausted.
+
+        // Move bytes from the read buffer into the caller's buffer.
+        read = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
+
+        // Flow control: notify the peer that we're ready for more data!
+        unacknowledgedBytesRead += read;
+        if (unacknowledgedBytesRead
+            >= connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
+          connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
+          unacknowledgedBytesRead = 0;
+        }
+      }
+
+      // Update connection.unacknowledgedBytesRead outside the stream lock.
+      synchronized (connection) { // Multiple application threads may hit this section.
+        connection.unacknowledgedBytesRead += read;
+        if (connection.unacknowledgedBytesRead
+            >= connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
+          connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
+          connection.unacknowledgedBytesRead = 0;
+        }
+      }
+
+      return read;
+    }
+
+    /** Returns once the source is either readable or finished. */
+    private void waitUntilReadable() throws IOException {
+      readTimeout.enter();
+      try {
+        while (readBuffer.size() == 0 && !finished && !closed && errorCode == null) {
+          waitForIo();
+        }
+      } finally {
+        readTimeout.exitAndThrowIfTimedOut();
+      }
+    }
+
+    void receive(BufferedSource in, long byteCount) throws IOException {
+      assert (!Thread.holdsLock(SpdyStream.this));
+
+      while (byteCount > 0) {
+        boolean finished;
+        boolean flowControlError;
+        synchronized (SpdyStream.this) {
+          finished = this.finished;
+          flowControlError = byteCount + readBuffer.size() > maxByteCount;
+        }
+
+        // If the peer sends more data than we can handle, discard it and close the connection.
+        if (flowControlError) {
+          in.skip(byteCount);
+          closeLater(ErrorCode.FLOW_CONTROL_ERROR);
+          return;
+        }
+
+        // Discard data received after the stream is finished. It's probably a benign race.
+        if (finished) {
+          in.skip(byteCount);
+          return;
+        }
+
+        // Fill the receive buffer without holding any locks.
+        long read = in.read(receiveBuffer, byteCount);
+        if (read == -1) throw new EOFException();
+        byteCount -= read;
+
+        // Move the received data to the read buffer to the reader can read it.
+        synchronized (SpdyStream.this) {
+          boolean wasEmpty = readBuffer.size() == 0;
+          readBuffer.writeAll(receiveBuffer);
+          if (wasEmpty) {
+            SpdyStream.this.notifyAll();
+          }
+        }
+      }
+    }
+
+    @Override public Timeout timeout() {
+      return readTimeout;
+    }
+
+    @Override public void close() throws IOException {
+      synchronized (SpdyStream.this) {
+        closed = true;
+        readBuffer.clear();
+        SpdyStream.this.notifyAll();
+      }
+      cancelStreamIfNecessary();
+    }
+
+    private void checkNotClosed() throws IOException {
+      if (closed) {
+        throw new IOException("stream closed");
+      }
+      if (errorCode != null) {
+        throw new IOException("stream was reset: " + errorCode);
+      }
+    }
+  }
+
+  private void cancelStreamIfNecessary() throws IOException {
+    assert (!Thread.holdsLock(SpdyStream.this));
+    boolean open;
+    boolean cancel;
+    synchronized (this) {
+      cancel = !source.finished && source.closed && (sink.finished || sink.closed);
+      open = isOpen();
+    }
+    if (cancel) {
+      // RST this stream to prevent additional data from being sent. This
+      // is safe because the input stream is closed (we won't use any
+      // further bytes) and the output stream is either finished or closed
+      // (so RSTing both streams doesn't cause harm).
+      SpdyStream.this.close(ErrorCode.CANCEL);
+    } else if (!open) {
+      connection.removeStream(id);
+    }
+  }
+
+  /**
+   * A sink that writes outgoing data frames of a stream. This class is not
+   * thread safe.
+   */
+  final class SpdyDataSink implements Sink {
+    private boolean closed;
+
+    /**
+     * True if either side has cleanly shut down this stream. We shall send
+     * no more bytes.
+     */
+    private boolean finished;
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      assert (!Thread.holdsLock(SpdyStream.this));
+      while (byteCount > 0) {
+        long toWrite;
+        synchronized (SpdyStream.this) {
+          writeTimeout.enter();
+          try {
+            while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
+              waitForIo(); // Wait until we receive a WINDOW_UPDATE.
+            }
+          } finally {
+            writeTimeout.exitAndThrowIfTimedOut();
+          }
+
+          checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
+          toWrite = Math.min(bytesLeftInWriteWindow, byteCount);
+          bytesLeftInWriteWindow -= toWrite;
+        }
+
+        byteCount -= toWrite;
+        connection.writeData(id, false, source, toWrite);
+      }
+    }
+
+    @Override public void flush() throws IOException {
+      assert (!Thread.holdsLock(SpdyStream.this));
+      synchronized (SpdyStream.this) {
+        checkOutNotClosed();
+      }
+      connection.flush();
+    }
+
+    @Override public Timeout timeout() {
+      return writeTimeout;
+    }
+
+    @Override public void close() throws IOException {
+      assert (!Thread.holdsLock(SpdyStream.this));
+      synchronized (SpdyStream.this) {
+        if (closed) return;
+      }
+      if (!sink.finished) {
+        connection.writeData(id, true, null, 0);
+      }
+      synchronized (SpdyStream.this) {
+        closed = true;
+      }
+      connection.flush();
+      cancelStreamIfNecessary();
+    }
+  }
+
+  /**
+   * {@code delta} will be negative if a settings frame initial window is
+   * smaller than the last.
+   */
+  void addBytesToWriteWindow(long delta) {
+    bytesLeftInWriteWindow += delta;
+    if (delta > 0) SpdyStream.this.notifyAll();
+  }
+
+  private void checkOutNotClosed() throws IOException {
+    if (sink.closed) {
+      throw new IOException("stream closed");
+    } else if (sink.finished) {
+      throw new IOException("stream finished");
+    } else if (errorCode != null) {
+      throw new IOException("stream was reset: " + errorCode);
+    }
+  }
+
+  /**
+   * Like {@link #wait}, but throws an {@code InterruptedIOException} when
+   * interrupted instead of the more awkward {@link InterruptedException}.
+   */
+  private void waitForIo() throws InterruptedIOException {
+    try {
+      wait();
+    } catch (InterruptedException e) {
+      throw new InterruptedIOException();
+    }
+  }
+
+  /**
+   * The Okio timeout watchdog will call {@link #timedOut} if the timeout is
+   * reached. In that case we close the stream (asynchronously) which will
+   * notify the waiting thread.
+   */
+  class SpdyTimeout extends AsyncTimeout {
+    @Override protected void timedOut() {
+      closeLater(ErrorCode.CANCEL);
+    }
+
+    public void exitAndThrowIfTimedOut() throws InterruptedIOException {
+      if (exit()) throw new InterruptedIOException("timeout");
+    }
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
similarity index 69%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
index 06de317852..c4b082d706 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
@@ -15,23 +15,23 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import java.io.InputStream;
-import java.io.OutputStream;
+import com.squareup.okhttp.Protocol;
+import okio.BufferedSink;
+import okio.BufferedSource;
 
 /** A version and dialect of the framed socket protocol. */
-interface Variant {
-  Variant SPDY3 = new Spdy3();
-  Variant HTTP_20_DRAFT_04 = new Http20Draft04();
+public interface Variant {
+
+  /** The protocol as selected using ALPN. */
+  Protocol getProtocol();
 
   /**
-   * @param client true if this is the HTTP client's reader, reading frames from
-   *     a peer SPDY or HTTP/2 server.
+   * @param client true if this is the HTTP client's reader, reading frames from a server.
    */
-  FrameReader newReader(InputStream in, boolean client);
+  FrameReader newReader(BufferedSource source, boolean client);
 
   /**
-   * @param client true if this is the HTTP client's writer, writing frames to a
-   *     peer SPDY or HTTP/2 server.
+   * @param client true if this is the HTTP client's writer, writing frames to a server.
    */
-  FrameWriter newWriter(OutputStream out, boolean client);
+  FrameWriter newWriter(BufferedSink sink, boolean client);
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
index a08773f6f6..740de1bcdf 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
@@ -58,6 +58,7 @@
   private OkHostnameVerifier() {
   }
 
+  @Override
   public boolean verify(String host, SSLSession session) {
     try {
       Certificate[] certificates = session.getPeerCertificates();
@@ -81,8 +82,9 @@ static boolean verifyAsIpAddress(String host) {
    * Returns true if {@code certificate} matches {@code ipAddress}.
    */
   private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
-    for (String altName : getSubjectAltNames(certificate, ALT_IPA_NAME)) {
-      if (ipAddress.equalsIgnoreCase(altName)) {
+    List<String> altNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
+    for (int i = 0, size = altNames.size(); i < size; i++) {
+      if (ipAddress.equalsIgnoreCase(altNames.get(i))) {
         return true;
       }
     }
@@ -95,9 +97,10 @@ private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
   private boolean verifyHostName(String hostName, X509Certificate certificate) {
     hostName = hostName.toLowerCase(Locale.US);
     boolean hasDns = false;
-    for (String altName : getSubjectAltNames(certificate, ALT_DNS_NAME)) {
+    List<String> altNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
+    for (int i = 0, size = altNames.size(); i < size; i++) {
       hasDns = true;
-      if (verifyHostName(hostName, altName)) {
+      if (verifyHostName(hostName, altNames.get(i))) {
         return true;
       }
     }
@@ -114,8 +117,17 @@ private boolean verifyHostName(String hostName, X509Certificate certificate) {
     return false;
   }
 
-  private List<String> getSubjectAltNames(X509Certificate certificate, int type) {
-    List<String> result = new ArrayList<String>();
+  public static List<String> allSubjectAltNames(X509Certificate certificate) {
+    List<String> altIpaNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
+    List<String> altDnsNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
+    List<String> result = new ArrayList<>(altIpaNames.size() + altDnsNames.size());
+    result.addAll(altIpaNames);
+    result.addAll(altDnsNames);
+    return result;
+  }
+
+  private static List<String> getSubjectAltNames(X509Certificate certificate, int type) {
+    List<String> result = new ArrayList<>();
     try {
       Collection<?> subjectAltNames = certificate.getSubjectAlternativeNames();
       if (subjectAltNames == null) {
@@ -144,51 +156,97 @@ private boolean verifyHostName(String hostName, X509Certificate certificate) {
   }
 
   /**
-   * Returns true if {@code hostName} matches the name or pattern {@code cn}.
+   * Returns {@code true} iff {@code hostName} matches the domain name {@code pattern}.
    *
-   * @param hostName lowercase host name.
-   * @param cn certificate host name. May include wildcards like
-   *     {@code *.android.com}.
+   * @param hostName lower-case host name.
+   * @param pattern domain name pattern from certificate. May be a wildcard pattern such as
+   *        {@code *.android.com}.
    */
-  public boolean verifyHostName(String hostName, String cn) {
+  private boolean verifyHostName(String hostName, String pattern) {
+    // Basic sanity checks
     // Check length == 0 instead of .isEmpty() to support Java 5.
-    if (hostName == null || hostName.length() == 0 || cn == null || cn.length() == 0) {
+    if ((hostName == null) || (hostName.length() == 0) || (hostName.startsWith("."))
+        || (hostName.endsWith(".."))) {
+      // Invalid domain name
+      return false;
+    }
+    if ((pattern == null) || (pattern.length() == 0) || (pattern.startsWith("."))
+        || (pattern.endsWith(".."))) {
+      // Invalid pattern/domain name
       return false;
     }
 
-    cn = cn.toLowerCase(Locale.US);
-
-    if (!cn.contains("*")) {
-      return hostName.equals(cn);
+    // Normalize hostName and pattern by turning them into absolute domain names if they are not
+    // yet absolute. This is needed because server certificates do not normally contain absolute
+    // names or patterns, but they should be treated as absolute. At the same time, any hostName
+    // presented to this method should also be treated as absolute for the purposes of matching
+    // to the server certificate.
+    //   www.android.com  matches www.android.com
+    //   www.android.com  matches www.android.com.
+    //   www.android.com. matches www.android.com.
+    //   www.android.com. matches www.android.com
+    if (!hostName.endsWith(".")) {
+      hostName += '.';
+    }
+    if (!pattern.endsWith(".")) {
+      pattern += '.';
     }
+    // hostName and pattern are now absolute domain names.
+
+    pattern = pattern.toLowerCase(Locale.US);
+    // hostName and pattern are now in lower case -- domain names are case-insensitive.
 
-    if (cn.startsWith("*.") && hostName.regionMatches(0, cn, 2, cn.length() - 2)) {
-      return true; // "*.foo.com" matches "foo.com"
+    if (!pattern.contains("*")) {
+      // Not a wildcard pattern -- hostName and pattern must match exactly.
+      return hostName.equals(pattern);
+    }
+    // Wildcard pattern
+
+    // WILDCARD PATTERN RULES:
+    // 1. Asterisk (*) is only permitted in the left-most domain name label and must be the
+    //    only character in that label (i.e., must match the whole left-most label).
+    //    For example, *.example.com is permitted, while *a.example.com, a*.example.com,
+    //    a*b.example.com, a.*.example.com are not permitted.
+    // 2. Asterisk (*) cannot match across domain name labels.
+    //    For example, *.example.com matches test.example.com but does not match
+    //    sub.test.example.com.
+    // 3. Wildcard patterns for single-label domain names are not permitted.
+
+    if ((!pattern.startsWith("*.")) || (pattern.indexOf('*', 1) != -1)) {
+      // Asterisk (*) is only permitted in the left-most domain name label and must be the only
+      // character in that label
+      return false;
     }
 
-    int asterisk = cn.indexOf('*');
-    int dot = cn.indexOf('.');
-    if (asterisk > dot) {
-      return false; // malformed; wildcard must be in the first part of the cn
+    // Optimization: check whether hostName is too short to match the pattern. hostName must be at
+    // least as long as the pattern because asterisk must match the whole left-most label and
+    // hostName starts with a non-empty label. Thus, asterisk has to match one or more characters.
+    if (hostName.length() < pattern.length()) {
+      // hostName too short to match the pattern.
+      return false;
     }
 
-    if (!hostName.regionMatches(0, cn, 0, asterisk)) {
-      return false; // prefix before '*' doesn't match
+    if ("*.".equals(pattern)) {
+      // Wildcard pattern for single-label domain name -- not permitted.
+      return false;
     }
 
-    int suffixLength = cn.length() - (asterisk + 1);
-    int suffixStart = hostName.length() - suffixLength;
-    if (hostName.indexOf('.', asterisk) < suffixStart) {
-      // TODO: remove workaround for *.clients.google.com http://b/5426333
-      if (!hostName.endsWith(".clients.google.com")) {
-        return false; // wildcard '*' can't match a '.'
-      }
+    // hostName must end with the region of pattern following the asterisk.
+    String suffix = pattern.substring(1);
+    if (!hostName.endsWith(suffix)) {
+      // hostName does not end with the suffix
+      return false;
     }
 
-    if (!hostName.regionMatches(suffixStart, cn, asterisk + 1, suffixLength)) {
-      return false; // suffix after '*' doesn't match
+    // Check that asterisk did not match across domain name labels.
+    int suffixStartIndexInHostName = hostName.length() - suffix.length();
+    if ((suffixStartIndexInHostName > 0)
+        && (hostName.lastIndexOf('.', suffixStartIndexInHostName - 1) != -1)) {
+      // Asterisk is matching across domain name labels -- not permitted.
+      return false;
     }
 
+    // hostName matches pattern
     return true;
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/Protocol.java
new file mode 100644
index 0000000000..86f6e18b6a
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/Protocol.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.ws;
+
+final class Protocol {
+  /*
+  Each frame starts with two bytes of data.
+
+   0 1 2 3 4 5 6 7    0 1 2 3 4 5 6 7
+  +-+-+-+-+-------+  +-+-------------+
+  |F|R|R|R| OP    |  |M| LENGTH      |
+  |I|S|S|S| CODE  |  |A|             |
+  |N|V|V|V|       |  |S|             |
+  | |1|2|3|       |  |K|             |
+  +-+-+-+-+-------+  +-+-------------+
+  */
+
+  /** Byte 0 flag for whether this is the final fragment in a message. */
+  static final int B0_FLAG_FIN = 0b10000000;
+  /** Byte 0 reserved flag 1. Must be 0 unless negotiated otherwise. */
+  static final int B0_FLAG_RSV1 = 0b01000000;
+  /** Byte 0 reserved flag 2. Must be 0 unless negotiated otherwise. */
+  static final int B0_FLAG_RSV2 = 0b00100000;
+  /** Byte 0 reserved flag 3. Must be 0 unless negotiated otherwise. */
+  static final int B0_FLAG_RSV3 = 0b00010000;
+  /** Byte 0 mask for the frame opcode. */
+  static final int B0_MASK_OPCODE = 0b00001111;
+  /** Flag in the opcode which indicates a control frame. */
+  static final int OPCODE_FLAG_CONTROL = 0b00001000;
+
+  /**
+   * Byte 1 flag for whether the payload data is masked.
+   * <p>
+   * If this flag is set, the next four bytes represent the mask key. These bytes appear after
+   * any additional bytes specified by {@link #B1_MASK_LENGTH}.
+   */
+  static final int B1_FLAG_MASK = 0b10000000;
+  /**
+   * Byte 1 mask for the payload length.
+   * <p>
+   * If this value is {@link #PAYLOAD_SHORT}, the next two bytes represent the length.
+   * If this value is {@link #PAYLOAD_LONG}, the next eight bytes represent the length.
+   */
+  static final int B1_MASK_LENGTH = 0b01111111;
+
+  static final int OPCODE_CONTINUATION = 0x0;
+  static final int OPCODE_TEXT = 0x1;
+  static final int OPCODE_BINARY = 0x2;
+
+  static final int OPCODE_CONTROL_CLOSE = 0x8;
+  static final int OPCODE_CONTROL_PING = 0x9;
+  static final int OPCODE_CONTROL_PONG = 0xa;
+
+  /**
+   * Maximum length of frame payload. Larger payloads, if supported, can use the special values
+   * {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
+   */
+  static final int PAYLOAD_MAX = 125;
+  /** Value for {@link #B1_MASK_LENGTH} which indicates the next two bytes are the length. */
+  static final int PAYLOAD_SHORT = 126;
+  /** Value for {@link #B1_MASK_LENGTH} which indicates the next eight bytes are the length. */
+  static final int PAYLOAD_LONG = 127;
+
+  static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameBytesRead) {
+    int keyLength = key.length;
+    for (int i = 0; i < byteCount; i++, frameBytesRead++) {
+      int keyIndex = (int) (frameBytesRead % keyLength);
+      buffer[i] = (byte) (buffer[i] ^ key[keyIndex]);
+    }
+  }
+
+  private Protocol() {
+    throw new AssertionError("No instances.");
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
new file mode 100644
index 0000000000..20a285a25c
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/RealWebSocket.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.ws;
+
+import com.squareup.okhttp.internal.NamedRunnable;
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.concurrent.LinkedBlockingDeque;
+import java.util.concurrent.ThreadPoolExecutor;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+
+import static com.squareup.okhttp.internal.ws.WebSocketReader.FrameCallback;
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+public abstract class RealWebSocket implements WebSocket {
+  /** A close code which indicates that the peer encountered a protocol exception. */
+  private static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
+
+  private final WebSocketWriter writer;
+  private final WebSocketReader reader;
+  private final WebSocketListener listener;
+
+  /** True after calling {@link #close(int, String)}. No writes are allowed afterward. */
+  private volatile boolean writerSentClose;
+  /** True after a close frame was read by the reader. No frames will follow it. */
+  private volatile boolean readerSentClose;
+  /** Lock required to negotiate closing the connection. */
+  private final Object closeLock = new Object();
+
+  public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random,
+      final WebSocketListener listener, final String url) {
+    this.listener = listener;
+
+    // Pings come in on the reader thread. This executor contends with callers for writing pongs.
+    final ThreadPoolExecutor pongExecutor = new ThreadPoolExecutor(1, 1, 1, SECONDS,
+        new LinkedBlockingDeque<Runnable>(),
+        Util.threadFactory(String.format("OkHttp %s WebSocket", url), true));
+    pongExecutor.allowCoreThreadTimeOut(true);
+
+    writer = new WebSocketWriter(isClient, sink, random);
+    reader = new WebSocketReader(isClient, source, new FrameCallback() {
+      @Override public void onMessage(BufferedSource source, PayloadType type) throws IOException {
+        listener.onMessage(source, type);
+      }
+
+      @Override public void onPing(final Buffer buffer) {
+        pongExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Pong", url) {
+          @Override protected void execute() {
+            try {
+              writer.writePong(buffer);
+            } catch (IOException ignored) {
+            }
+          }
+        });
+      }
+
+      @Override public void onPong(Buffer buffer) {
+        listener.onPong(buffer);
+      }
+
+      @Override public void onClose(int code, String reason) throws IOException {
+        peerClose(code, reason);
+      }
+    });
+  }
+
+  /**
+   * Read a single message from the web socket and deliver it to the listener. This method should
+   * be called in a loop with the return value indicating whether looping should continue.
+   */
+  boolean readMessage() {
+    try {
+      reader.processNextFrame();
+      return !readerSentClose;
+    } catch (IOException e) {
+      readerErrorClose(e);
+      return false;
+    }
+  }
+
+  @Override public BufferedSink newMessageSink(PayloadType type) {
+    if (writerSentClose) throw new IllegalStateException("Closed");
+    return writer.newMessageSink(type);
+  }
+
+  @Override public void sendMessage(PayloadType type, Buffer payload) throws IOException {
+    if (writerSentClose) throw new IllegalStateException("Closed");
+    writer.sendMessage(type, payload);
+  }
+
+  @Override public void sendPing(Buffer payload) throws IOException {
+    if (writerSentClose) throw new IllegalStateException("Closed");
+    writer.writePing(payload);
+  }
+
+  /** Send an unsolicited pong with the specified payload. */
+  public void sendPong(Buffer payload) throws IOException {
+    if (writerSentClose) throw new IllegalStateException("Closed");
+    writer.writePong(payload);
+  }
+
+  @Override public void close(int code, String reason) throws IOException {
+    if (writerSentClose) throw new IllegalStateException("Closed");
+
+    boolean closeConnection;
+    synchronized (closeLock) {
+      writerSentClose = true;
+
+      // If the reader has also indicated a desire to close we will close the connection.
+      closeConnection = readerSentClose;
+    }
+
+    writer.writeClose(code, reason);
+
+    if (closeConnection) {
+      closeConnection();
+    }
+  }
+
+  /** Called on the reader thread when a close frame is encountered. */
+  private void peerClose(int code, String reason) throws IOException {
+    boolean writeCloseResponse;
+    synchronized (closeLock) {
+      readerSentClose = true;
+
+      // If the writer has not indicated a desire to close we will write a close response.
+      writeCloseResponse = !writerSentClose;
+    }
+
+    if (writeCloseResponse) {
+      // The reader thread will read no more frames so use it to send the response.
+      writer.writeClose(code, reason);
+    }
+
+    closeConnection();
+
+    listener.onClose(code, reason);
+  }
+
+  /** Called on the reader thread when an error occurs. */
+  private void readerErrorClose(IOException e) {
+    boolean writeCloseResponse;
+    synchronized (closeLock) {
+      readerSentClose = true;
+
+      // If the writer has not closed we will close the connection.
+      writeCloseResponse = !writerSentClose;
+    }
+
+    if (writeCloseResponse) {
+      if (e instanceof ProtocolException) {
+        // For protocol exceptions, try to inform the server of such.
+        try {
+          writer.writeClose(CLOSE_PROTOCOL_EXCEPTION, null);
+        } catch (IOException ignored) {
+        }
+      }
+    }
+
+    try {
+      closeConnection();
+    } catch (IOException ignored) {
+    }
+
+    listener.onFailure(e);
+  }
+
+  /** Perform any tear-down work on the connection (close the socket, recycle, etc.). */
+  protected abstract void closeConnection() throws IOException;
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocket.java b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocket.java
new file mode 100644
index 0000000000..3be790d010
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocket.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.ws;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSink;
+
+// TODO move to public API!
+/** Blocking interface to connect and write to a web socket. */
+public interface WebSocket {
+  /** The format of a message payload. */
+  enum PayloadType {
+    /** UTF8-encoded text data. */
+    TEXT,
+    /** Arbitrary binary data. */
+    BINARY
+  }
+
+  /**
+   * Stream a message payload to the server of the specified {code type}.
+   * <p>
+   * You must call {@link BufferedSink#close() close()} to complete the message. Calls to
+   * {@link BufferedSink#flush() flush()} write a frame fragment. The message may be empty.
+   *
+   * @throws IllegalStateException if not connected, already closed, or another writer is active.
+   */
+  BufferedSink newMessageSink(WebSocket.PayloadType type);
+
+  /**
+   * Send a message payload to the server of the specified {@code type}.
+   *
+   * @throws IllegalStateException if not connected, already closed, or another writer is active.
+   */
+  void sendMessage(WebSocket.PayloadType type, Buffer payload) throws IOException;
+
+  /**
+   * Send a ping to the server with optional payload.
+   *
+   * @throws IllegalStateException if already closed.
+   */
+  void sendPing(Buffer payload) throws IOException;
+
+  /**
+   * Send a close frame to the server.
+   * <p>
+   * The corresponding {@link WebSocketListener} will continue to get messages until its
+   * {@link WebSocketListener#onClose onClose()} method is called.
+   * <p>
+   * It is an error to call this method before calling close on an active writer. Calling this
+   * method more than once has no effect.
+   *
+   * @throws IllegalStateException if already closed.
+   */
+  void close(int code, String reason) throws IOException;
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketCall.java b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketCall.java
new file mode 100644
index 0000000000..adffa77bb6
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketCall.java
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.ws;
+
+import com.squareup.okhttp.Call;
+import com.squareup.okhttp.Callback;
+import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.NamedRunnable;
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.net.Socket;
+import java.security.SecureRandom;
+import java.util.Collections;
+import java.util.Random;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+
+// TODO move to public API!
+public class WebSocketCall {
+  /** Magic value which must be appended to the {@link #key} in a response header. */
+  private static final String ACCEPT_MAGIC = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
+
+  /**
+   * Prepares the {@code request} to create a web socket at some point in the future.
+   * <p>
+   * TODO Move to OkHttpClient as non-static once web sockets are finalized!
+   */
+  public static WebSocketCall newWebSocketCall(OkHttpClient client, Request request) {
+    return new WebSocketCall(client, request);
+  }
+
+  private final Request request;
+  private final Call call;
+  private final Random random;
+  private final String key;
+
+  protected WebSocketCall(OkHttpClient client, Request request) {
+    this(client, request, new SecureRandom());
+  }
+
+  WebSocketCall(OkHttpClient client, Request request, Random random) {
+    if (!"GET".equals(request.method())) {
+      throw new IllegalArgumentException("Request must be GET: " + request.method());
+    }
+    String url = request.urlString();
+    String httpUrl;
+    if (url.startsWith("ws://")) {
+      httpUrl = "http://" + url.substring(5);
+    } else if (url.startsWith("wss://")) {
+      httpUrl = "https://" + url.substring(6);
+    } else if (url.startsWith("http://") || url.startsWith("https://")) {
+      httpUrl = url;
+    } else {
+      throw new IllegalArgumentException(
+          "Request url must use 'ws', 'wss', 'http', or 'https' scheme: " + url);
+    }
+
+    this.random = random;
+
+    byte[] nonce = new byte[16];
+    random.nextBytes(nonce);
+    key = ByteString.of(nonce).base64();
+
+    // Copy the client. Otherwise changes (socket factory, redirect policy,
+    // etc.) may incorrectly be reflected in the request when it is executed.
+    client = client.clone();
+    // Force HTTP/1.1 until the WebSocket over HTTP/2 version is finalized.
+    client.setProtocols(Collections.singletonList(com.squareup.okhttp.Protocol.HTTP_1_1));
+
+    request = request.newBuilder()
+        .url(httpUrl)
+        .header("Upgrade", "websocket")
+        .header("Connection", "Upgrade")
+        .header("Sec-WebSocket-Key", key)
+        .header("Sec-WebSocket-Version", "13")
+        .build();
+    this.request = request;
+
+    call = client.newCall(request);
+  }
+
+  /**
+   * Schedules the request to be executed at some point in the future.
+   *
+   * <p>The {@link OkHttpClient#getDispatcher dispatcher} defines when the request will run:
+   * usually immediately unless there are several other requests currently being executed.
+   *
+   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
+   * failure exception. If you {@link #cancel} a request before it completes the callback will not
+   * be invoked.
+   *
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  public void enqueue(final WebSocketListener listener) {
+    Callback responseCallback = new Callback() {
+      @Override public void onResponse(Response response) throws IOException {
+        try {
+          createWebSocket(response, listener);
+        } catch (IOException e) {
+          listener.onFailure(e);
+        }
+      }
+
+      @Override public void onFailure(Request request, IOException e) {
+        listener.onFailure(e);
+      }
+    };
+    // TODO call.enqueue(responseCallback, true);
+    Internal.instance.callEnqueue(call, responseCallback, true);
+  }
+
+  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
+  public void cancel() {
+    call.cancel();
+  }
+
+  private void createWebSocket(Response response, WebSocketListener listener)
+      throws IOException {
+    if (response.code() != 101) {
+      // TODO call.engine.releaseConnection();
+      Internal.instance.callEngineReleaseConnection(call);
+      throw new ProtocolException("Expected HTTP 101 response but was '"
+          + response.code()
+          + " "
+          + response.message()
+          + "'");
+    }
+
+    String headerConnection = response.header("Connection");
+    if (!"Upgrade".equalsIgnoreCase(headerConnection)) {
+      throw new ProtocolException(
+          "Expected 'Connection' header value 'Upgrade' but was '" + headerConnection + "'");
+    }
+    String headerUpgrade = response.header("Upgrade");
+    if (!"websocket".equalsIgnoreCase(headerUpgrade)) {
+      throw new ProtocolException(
+          "Expected 'Upgrade' header value 'websocket' but was '" + headerUpgrade + "'");
+    }
+    String headerAccept = response.header("Sec-WebSocket-Accept");
+    String acceptExpected = Util.shaBase64(key + ACCEPT_MAGIC);
+    if (!acceptExpected.equals(headerAccept)) {
+      throw new ProtocolException("Expected 'Sec-WebSocket-Accept' header value '"
+          + acceptExpected
+          + "' but was '"
+          + headerAccept
+          + "'");
+    }
+
+    // TODO connection = call.engine.getConnection();
+    Connection connection = Internal.instance.callEngineGetConnection(call);
+    // TODO if (!connection.clearOwner()) {
+    if (!Internal.instance.clearOwner(connection)) {
+      throw new IllegalStateException("Unable to take ownership of connection.");
+    }
+
+    Socket socket = connection.getSocket();
+    BufferedSource source = Okio.buffer(Okio.source(socket));
+    BufferedSink sink = Okio.buffer(Okio.sink(socket));
+
+    final RealWebSocket webSocket =
+        new ConnectionWebSocket(response, connection, source, sink, random, listener);
+
+    // Start a dedicated thread for reading the web socket.
+    new Thread(new NamedRunnable("OkHttp WebSocket reader %s", request.urlString()) {
+      @Override protected void execute() {
+        while (webSocket.readMessage()) {
+        }
+      }
+    }).start();
+
+    // TODO connection.setOwner(webSocket);
+    Internal.instance.connectionSetOwner(connection, webSocket);
+
+    listener.onOpen(webSocket, request, response);
+  }
+
+  // Keep static so that the WebSocketCall instance can be garbage collected.
+  private static class ConnectionWebSocket extends RealWebSocket {
+    private final Connection connection;
+
+    public ConnectionWebSocket(Response response, Connection connection, BufferedSource source,
+        BufferedSink sink, Random random, WebSocketListener listener) {
+      super(true /* is client */, source, sink, random, listener, response.request().urlString());
+      this.connection = connection;
+    }
+
+    @Override protected void closeConnection() throws IOException {
+      // TODO connection.closeIfOwnedBy(this);
+      Internal.instance.closeIfOwnedBy(connection, this);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketListener.java b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketListener.java
new file mode 100644
index 0000000000..84f7cc0d78
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketListener.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.ws;
+
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+
+import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
+
+// TODO move to public API!
+/** Listener for server-initiated messages on a connected {@link WebSocket}. */
+public interface WebSocketListener {
+  void onOpen(WebSocket webSocket, Request request, Response response) throws IOException;
+
+  /**
+   * Called when a server message is received. The {@code type} indicates whether the
+   * {@code payload} should be interpreted as UTF-8 text or binary data.
+   */
+  void onMessage(BufferedSource payload, PayloadType type) throws IOException;
+
+  /**
+   * Called when a server pong is received. This is usually a result of calling {@link
+   * WebSocket#sendPing(Buffer)} but might also be unsolicited.
+   */
+  void onPong(Buffer payload);
+
+  /**
+   * Called when the server sends a close message. This may have been initiated
+   * from a call to {@link WebSocket#close(int, String) close()} or as an unprompted
+   * message from the server.
+   *
+   * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1>RFC-compliant</a>
+   * status code.
+   * @param reason Reason for close or an empty string.
+   */
+  void onClose(int code, String reason);
+
+  /** Called when the transport or protocol layer of this web socket errors during communication. */
+  void onFailure(IOException e);
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
new file mode 100644
index 0000000000..b9fb2a86ad
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketReader.java
@@ -0,0 +1,283 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.ws;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.net.ProtocolException;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Source;
+import okio.Timeout;
+
+import static com.squareup.okhttp.internal.ws.Protocol.B0_FLAG_FIN;
+import static com.squareup.okhttp.internal.ws.Protocol.B0_FLAG_RSV1;
+import static com.squareup.okhttp.internal.ws.Protocol.B0_FLAG_RSV2;
+import static com.squareup.okhttp.internal.ws.Protocol.B0_FLAG_RSV3;
+import static com.squareup.okhttp.internal.ws.Protocol.B0_MASK_OPCODE;
+import static com.squareup.okhttp.internal.ws.Protocol.B1_FLAG_MASK;
+import static com.squareup.okhttp.internal.ws.Protocol.B1_MASK_LENGTH;
+import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_BINARY;
+import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_CONTINUATION;
+import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_CONTROL_CLOSE;
+import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_CONTROL_PING;
+import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_CONTROL_PONG;
+import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_FLAG_CONTROL;
+import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_TEXT;
+import static com.squareup.okhttp.internal.ws.Protocol.PAYLOAD_LONG;
+import static com.squareup.okhttp.internal.ws.Protocol.PAYLOAD_MAX;
+import static com.squareup.okhttp.internal.ws.Protocol.PAYLOAD_SHORT;
+import static com.squareup.okhttp.internal.ws.Protocol.toggleMask;
+import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
+import static java.lang.Integer.toHexString;
+
+/**
+ * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame reader.
+ */
+public final class WebSocketReader {
+  public interface FrameCallback {
+    void onMessage(BufferedSource source, PayloadType type) throws IOException;
+    void onPing(Buffer buffer);
+    void onPong(Buffer buffer);
+    void onClose(int code, String reason) throws IOException;
+  }
+
+  private final boolean isClient;
+  private final BufferedSource source;
+  private final FrameCallback frameCallback;
+
+  private final Source framedMessageSource = new FramedMessageSource();
+
+  private boolean closed;
+  private boolean messageClosed;
+
+  // Stateful data about the current frame.
+  private int opcode;
+  private long frameLength;
+  private long frameBytesRead;
+  private boolean isFinalFrame;
+  private boolean isControlFrame;
+  private boolean isMasked;
+
+  private final byte[] maskKey = new byte[4];
+  private final byte[] maskBuffer = new byte[2048];
+
+  public WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
+    if (source == null) throw new NullPointerException("source");
+    if (frameCallback == null) throw new NullPointerException("frameCallback");
+    this.isClient = isClient;
+    this.source = source;
+    this.frameCallback = frameCallback;
+  }
+
+  /**
+   * Process the next protocol frame.
+   * <ul>
+   * <li>If it is a control frame this will result in a single call to {@link FrameCallback}.</li>
+   * <li>If it is a message frame this will result in a single call to {@link
+   * WebSocketListener#onMessage}. If the message spans multiple frames, each interleaved control
+   * frame will result in a corresponding call to {@link FrameCallback}.
+   * </ul>
+   */
+  public void processNextFrame() throws IOException {
+    readHeader();
+    if (isControlFrame) {
+      readControlFrame();
+    } else {
+      readMessageFrame();
+    }
+  }
+
+  private void readHeader() throws IOException {
+    if (closed) throw new IOException("Closed");
+
+    int b0 = source.readByte() & 0xff;
+
+    opcode = b0 & B0_MASK_OPCODE;
+    isFinalFrame = (b0 & B0_FLAG_FIN) != 0;
+    isControlFrame = (b0 & OPCODE_FLAG_CONTROL) != 0;
+
+    // Control frames must be final frames (cannot contain continuations).
+    if (isControlFrame && !isFinalFrame) {
+      throw new ProtocolException("Control frames must be final.");
+    }
+
+    boolean reservedFlag1 = (b0 & B0_FLAG_RSV1) != 0;
+    boolean reservedFlag2 = (b0 & B0_FLAG_RSV2) != 0;
+    boolean reservedFlag3 = (b0 & B0_FLAG_RSV3) != 0;
+    if (reservedFlag1 || reservedFlag2 || reservedFlag3) {
+      // Reserved flags are for extensions which we currently do not support.
+      throw new ProtocolException("Reserved flags are unsupported.");
+    }
+
+    int b1 = source.readByte() & 0xff;
+
+    isMasked = (b1 & B1_FLAG_MASK) != 0;
+    if (isMasked == isClient) {
+      // Masked payloads must be read on the server. Unmasked payloads must be read on the client.
+      throw new ProtocolException("Client-sent frames must be masked. Server sent must not.");
+    }
+
+    // Get frame length, optionally reading from follow-up bytes if indicated by special values.
+    frameLength = b1 & B1_MASK_LENGTH;
+    if (frameLength == PAYLOAD_SHORT) {
+      frameLength = source.readShort();
+    } else if (frameLength == PAYLOAD_LONG) {
+      frameLength = source.readLong();
+    }
+    frameBytesRead = 0;
+
+    if (isControlFrame && frameLength > PAYLOAD_MAX) {
+      throw new ProtocolException("Control frame must be less than " + PAYLOAD_MAX + "B.");
+    }
+
+    if (isMasked) {
+      // Read the masking key as bytes so that they can be used directly for unmasking.
+      source.readFully(maskKey);
+    }
+  }
+
+  private void readControlFrame() throws IOException {
+    Buffer buffer = null;
+    if (frameBytesRead < frameLength) {
+      buffer = new Buffer();
+
+      if (isClient) {
+        source.readFully(buffer, frameLength);
+      } else {
+        while (frameBytesRead < frameLength) {
+          int toRead = (int) Math.min(frameLength - frameBytesRead, maskBuffer.length);
+          int read = source.read(maskBuffer, 0, toRead);
+          if (read == -1) throw new EOFException();
+          toggleMask(maskBuffer, read, maskKey, frameBytesRead);
+          buffer.write(maskBuffer, 0, read);
+          frameBytesRead += read;
+        }
+      }
+    }
+
+    switch (opcode) {
+      case OPCODE_CONTROL_PING:
+        frameCallback.onPing(buffer);
+        break;
+      case OPCODE_CONTROL_PONG:
+        frameCallback.onPong(buffer);
+        break;
+      case OPCODE_CONTROL_CLOSE:
+        int code = 0;
+        String reason = "";
+        if (buffer != null) {
+          code = buffer.readShort();
+          reason = buffer.readUtf8();
+        }
+        frameCallback.onClose(code, reason);
+        closed = true;
+        break;
+      default:
+        throw new IllegalStateException("Unknown control opcode: " + toHexString(opcode));
+    }
+  }
+
+  private void readMessageFrame() throws IOException {
+    PayloadType type;
+    switch (opcode) {
+      case OPCODE_TEXT:
+        type = PayloadType.TEXT;
+        break;
+      case OPCODE_BINARY:
+        type = PayloadType.BINARY;
+        break;
+      default:
+        throw new IllegalStateException("Unknown opcode: " + toHexString(opcode));
+    }
+
+    messageClosed = false;
+    frameCallback.onMessage(Okio.buffer(framedMessageSource), type);
+    if (!messageClosed) {
+      throw new IllegalStateException("Listener failed to call close on message payload.");
+    }
+  }
+
+  /** Read headers and process any control frames until we reach a non-control frame. */
+  private void readUntilNonControlFrame() throws IOException {
+    while (!closed) {
+      readHeader();
+      if (!isControlFrame) {
+        break;
+      }
+      readControlFrame();
+    }
+  }
+
+  /**
+   * A special source which knows how to read a message body across one or more frames. Control
+   * frames that occur between fragments will be processed. If the message payload is masked this
+   * will unmask as it's being processed.
+   */
+  private final class FramedMessageSource implements Source {
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      if (closed) throw new IOException("Closed");
+      if (messageClosed) throw new IllegalStateException("Closed");
+
+      if (frameBytesRead == frameLength) {
+        if (isFinalFrame) return -1; // We are exhausted and have no continuations.
+
+        readUntilNonControlFrame();
+        if (opcode != OPCODE_CONTINUATION) {
+          throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
+        }
+        if (isFinalFrame && frameLength == 0) {
+          return -1; // Fast-path for empty final frame.
+        }
+      }
+
+      long toRead = Math.min(byteCount, frameLength - frameBytesRead);
+
+      long read;
+      if (isMasked) {
+        toRead = Math.min(toRead, maskBuffer.length);
+        read = source.read(maskBuffer, 0, (int) toRead);
+        if (read == -1) throw new EOFException();
+        toggleMask(maskBuffer, read, maskKey, frameBytesRead);
+        sink.write(maskBuffer, 0, (int) read);
+      } else {
+        read = source.read(sink, toRead);
+        if (read == -1) throw new EOFException();
+      }
+
+      frameBytesRead += read;
+      return read;
+    }
+
+    @Override public Timeout timeout() {
+      return source.timeout();
+    }
+
+    @Override public void close() throws IOException {
+      if (messageClosed) return;
+      messageClosed = true;
+      if (closed) return;
+
+      // Exhaust the remainder of the message, if any.
+      source.skip(frameLength - frameBytesRead);
+      while (!isFinalFrame) {
+        readUntilNonControlFrame();
+        source.skip(frameLength);
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
new file mode 100644
index 0000000000..afaec046be
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/ws/WebSocketWriter.java
@@ -0,0 +1,294 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.ws;
+
+import java.io.IOException;
+import java.util.Random;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Timeout;
+
+import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
+import static com.squareup.okhttp.internal.ws.Protocol.B0_FLAG_FIN;
+import static com.squareup.okhttp.internal.ws.Protocol.B1_FLAG_MASK;
+import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_BINARY;
+import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_CONTINUATION;
+import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_CONTROL_CLOSE;
+import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_CONTROL_PING;
+import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_CONTROL_PONG;
+import static com.squareup.okhttp.internal.ws.Protocol.OPCODE_TEXT;
+import static com.squareup.okhttp.internal.ws.Protocol.PAYLOAD_LONG;
+import static com.squareup.okhttp.internal.ws.Protocol.PAYLOAD_MAX;
+import static com.squareup.okhttp.internal.ws.Protocol.PAYLOAD_SHORT;
+import static com.squareup.okhttp.internal.ws.Protocol.toggleMask;
+
+/**
+ * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
+ * <p>
+ * This class is partially thread safe. Only a single "main" thread should be sending messages via
+ * calls to {@link #newMessageSink} or {@link #sendMessage} as well as any calls to
+ * {@link #writePing} or {@link #writeClose}. Other threads may call {@link #writePing},
+ * {@link #writePong}, or {@link #writeClose} which will interleave on the wire with frames from
+ * the main thread.
+ */
+public final class WebSocketWriter {
+  private final boolean isClient;
+  /** Writes must be guarded by synchronizing on this instance! */
+  private final BufferedSink sink;
+  private final Random random;
+
+  private final FrameSink frameSink = new FrameSink();
+
+  private boolean closed;
+  private boolean activeWriter;
+
+  private final byte[] maskKey;
+  private final byte[] maskBuffer;
+
+  public WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
+    if (sink == null) throw new NullPointerException("sink");
+    if (random == null) throw new NullPointerException("random");
+    this.isClient = isClient;
+    this.sink = sink;
+    this.random = random;
+
+    // Masks are only a concern for client writers.
+    maskKey = isClient ? new byte[4] : null;
+    maskBuffer = isClient ? new byte[2048] : null;
+  }
+
+  /** Send a ping with the supplied {@code payload}. Payload may be {@code null} */
+  public void writePing(Buffer payload) throws IOException {
+    synchronized (sink) {
+      writeControlFrame(OPCODE_CONTROL_PING, payload);
+    }
+  }
+
+  /** Send a pong with the supplied {@code payload}. Payload may be {@code null} */
+  public void writePong(Buffer payload) throws IOException {
+    synchronized (sink) {
+      writeControlFrame(OPCODE_CONTROL_PONG, payload);
+    }
+  }
+
+  /**
+   * Send a close frame with optional code and reason.
+   *
+   * @param code Status code as defined by
+   * <a href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or
+   * {@code 0}.
+   * @param reason Reason for shutting down or {@code null}. {@code code} is required if set.
+   */
+  public void writeClose(int code, String reason) throws IOException {
+    Buffer payload = null;
+    if (code != 0) {
+      if (code < 1000 || code >= 5000) {
+        throw new IllegalArgumentException("Code must be in range [1000,5000).");
+      }
+      payload = new Buffer();
+      payload.writeShort(code);
+      if (reason != null) {
+        payload.writeUtf8(reason);
+      }
+    } else if (reason != null) {
+      throw new IllegalArgumentException("Code required to include reason.");
+    }
+
+    synchronized (sink) {
+      writeControlFrame(OPCODE_CONTROL_CLOSE, payload);
+      closed = true;
+    }
+  }
+
+  private void writeControlFrame(int opcode, Buffer payload) throws IOException {
+    if (closed) throw new IOException("Closed");
+
+    int length = 0;
+    if (payload != null) {
+      length = (int) payload.size();
+      if (length > PAYLOAD_MAX) {
+        throw new IllegalArgumentException(
+            "Payload size must be less than or equal to " + PAYLOAD_MAX);
+      }
+    }
+
+    int b0 = B0_FLAG_FIN | opcode;
+    sink.writeByte(b0);
+
+    int b1 = length;
+    if (isClient) {
+      b1 |= B1_FLAG_MASK;
+      sink.writeByte(b1);
+
+      random.nextBytes(maskKey);
+      sink.write(maskKey);
+
+      if (payload != null) {
+        writeAllMasked(payload, length);
+      }
+    } else {
+      sink.writeByte(b1);
+
+      if (payload != null) {
+        sink.writeAll(payload);
+      }
+    }
+
+    sink.flush();
+  }
+
+  /**
+   * Stream a message payload as a series of frames. This allows control frames to be interleaved
+   * between parts of the message.
+   */
+  public BufferedSink newMessageSink(PayloadType type) {
+    if (type == null) throw new NullPointerException("type == null");
+    if (activeWriter) {
+      throw new IllegalStateException("Another message writer is active. Did you call close()?");
+    }
+    activeWriter = true;
+
+    frameSink.payloadType = type;
+    frameSink.isFirstFrame = true;
+    return Okio.buffer(frameSink);
+  }
+
+  /**
+   * Send a message payload as a single frame. This will block any control frames that need sent
+   * until it is completed.
+   */
+  public void sendMessage(PayloadType type, Buffer payload) throws IOException {
+    if (type == null) throw new NullPointerException("type == null");
+    if (payload == null) throw new NullPointerException("payload == null");
+    if (activeWriter) {
+      throw new IllegalStateException("A message writer is active. Did you call close()?");
+    }
+    writeFrame(type, payload, payload.size(), true /* first frame */, true /* final */);
+  }
+
+  private void writeFrame(PayloadType payloadType, Buffer source, long byteCount,
+      boolean isFirstFrame, boolean isFinal) throws IOException {
+    if (closed) throw new IOException("Closed");
+
+    int opcode = OPCODE_CONTINUATION;
+    if (isFirstFrame) {
+      switch (payloadType) {
+        case TEXT:
+          opcode = OPCODE_TEXT;
+          break;
+        case BINARY:
+          opcode = OPCODE_BINARY;
+          break;
+        default:
+          throw new IllegalStateException("Unknown payload type: " + payloadType);
+      }
+    }
+
+    synchronized (sink) {
+      int b0 = opcode;
+      if (isFinal) {
+        b0 |= B0_FLAG_FIN;
+      }
+      sink.writeByte(b0);
+
+      int b1 = 0;
+      if (isClient) {
+        b1 |= B1_FLAG_MASK;
+        random.nextBytes(maskKey);
+      }
+      if (byteCount <= PAYLOAD_MAX) {
+        b1 |= (int) byteCount;
+        sink.writeByte(b1);
+      } else if (byteCount <= Short.MAX_VALUE) {
+        b1 |= PAYLOAD_SHORT;
+        sink.writeByte(b1);
+        sink.writeShort((int) byteCount);
+      } else {
+        b1 |= PAYLOAD_LONG;
+        sink.writeByte(b1);
+        sink.writeLong(byteCount);
+      }
+
+      if (isClient) {
+        sink.write(maskKey);
+        writeAllMasked(source, byteCount);
+      } else {
+        sink.write(source, byteCount);
+      }
+
+      sink.flush();
+    }
+  }
+
+  private void writeAllMasked(BufferedSource source, long byteCount) throws IOException {
+    long written = 0;
+    while (written < byteCount) {
+      int toRead = (int) Math.min(byteCount, maskBuffer.length);
+      int read = source.read(maskBuffer, 0, toRead);
+      if (read == -1) throw new AssertionError();
+      toggleMask(maskBuffer, read, maskKey, written);
+      sink.write(maskBuffer, 0, read);
+      written += read;
+    }
+  }
+
+  private final class FrameSink implements Sink {
+    private PayloadType payloadType;
+    private boolean isFirstFrame;
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      writeFrame(payloadType, source, byteCount, isFirstFrame, false /* final */);
+      isFirstFrame = false;
+    }
+
+    @Override public void flush() throws IOException {
+      if (closed) throw new IOException("Closed");
+
+      synchronized (sink) {
+        sink.flush();
+      }
+    }
+
+    @Override public Timeout timeout() {
+      return sink.timeout();
+    }
+
+    @SuppressWarnings("PointlessBitwiseExpression")
+    @Override public void close() throws IOException {
+      if (closed) throw new IOException("Closed");
+
+      int length = 0;
+
+      synchronized (sink) {
+        sink.writeByte(B0_FLAG_FIN | OPCODE_CONTINUATION);
+
+        if (isClient) {
+          sink.writeByte(B1_FLAG_MASK | length);
+          random.nextBytes(maskKey);
+          sink.write(maskKey);
+        } else {
+          sink.writeByte(length);
+        }
+        sink.flush();
+      }
+
+      activeWriter = false;
+    }
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java b/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
deleted file mode 100644
index 6636ca7cc6..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import org.junit.After;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
-public final class AsyncApiTest {
-  private MockWebServer server = new MockWebServer();
-  private OkHttpClient client = new OkHttpClient();
-  private RecordingReceiver receiver = new RecordingReceiver();
-
-  @After public void tearDown() throws Exception {
-    server.shutdown();
-  }
-
-  @Test public void get() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-    server.play();
-
-    Request request = new Request.Builder(server.getUrl("/"))
-        .header("User-Agent", "AsyncApiTest")
-        .build();
-    client.enqueue(request, receiver);
-
-    receiver.await(request)
-        .assertCode(200)
-        .assertContainsHeaders("Content-Type: text/plain")
-        .assertBody("abc");
-
-    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: AsyncApiTest"));
-  }
-
-  @Test public void post() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.play();
-
-    Request request = new Request.Builder(server.getUrl("/"))
-        .post(Request.Body.create(MediaType.parse("text/plain"), "def"))
-        .build();
-    client.enqueue(request, receiver);
-
-    receiver.await(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("def", recordedRequest.getUtf8Body());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
deleted file mode 100644
index e243857333..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
+++ /dev/null
@@ -1,409 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.RecordingHostnameVerifier;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HttpAuthenticator;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
-import java.util.Arrays;
-import javax.net.ssl.SSLContext;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-
-public final class ConnectionPoolTest {
-  private static final int KEEP_ALIVE_DURATION_MS = 5000;
-  private static final SSLContext sslContext;
-
-  static {
-    try {
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  private final MockWebServer spdyServer = new MockWebServer();
-  private InetSocketAddress spdySocketAddress;
-  private Address spdyAddress;
-
-  private final MockWebServer httpServer = new MockWebServer();
-  private Address httpAddress;
-  private InetSocketAddress httpSocketAddress;
-
-  private Connection httpA;
-  private Connection httpB;
-  private Connection httpC;
-  private Connection httpD;
-  private Connection httpE;
-  private Connection spdyA;
-  private Connection spdyB;
-
-  @Before public void setUp() throws Exception {
-    spdyServer.useHttps(sslContext.getSocketFactory(), false);
-
-    httpServer.play();
-    httpAddress = new Address(httpServer.getHostName(), httpServer.getPort(), null, null,
-        HttpAuthenticator.SYSTEM_DEFAULT, null, Arrays.asList("spdy/3", "http/1.1"));
-    httpSocketAddress = new InetSocketAddress(InetAddress.getByName(httpServer.getHostName()),
-        httpServer.getPort());
-
-    spdyServer.play();
-    spdyAddress = new Address(spdyServer.getHostName(), spdyServer.getPort(),
-        sslContext.getSocketFactory(), new RecordingHostnameVerifier(),
-        HttpAuthenticator.SYSTEM_DEFAULT, null, Arrays.asList("spdy/3", "http/1.1"));
-    spdySocketAddress = new InetSocketAddress(InetAddress.getByName(spdyServer.getHostName()),
-        spdyServer.getPort());
-
-    Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true);
-    Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress, true);
-    httpA = new Connection(httpRoute);
-    httpA.connect(100, 100, null);
-    httpB = new Connection(httpRoute);
-    httpB.connect(100, 100, null);
-    httpC = new Connection(httpRoute);
-    httpC.connect(100, 100, null);
-    httpD = new Connection(httpRoute);
-    httpD.connect(100, 100, null);
-    httpE = new Connection(httpRoute);
-    httpE.connect(100, 100, null);
-    spdyA = new Connection(spdyRoute);
-    spdyA.connect(100, 100, null);
-    spdyB = new Connection(spdyRoute);
-    spdyB.connect(100, 100, null);
-  }
-
-  @After public void tearDown() throws Exception {
-    httpServer.shutdown();
-    spdyServer.shutdown();
-
-    Util.closeQuietly(httpA);
-    Util.closeQuietly(httpB);
-    Util.closeQuietly(httpC);
-    Util.closeQuietly(httpD);
-    Util.closeQuietly(httpE);
-    Util.closeQuietly(spdyA);
-    Util.closeQuietly(spdyB);
-  }
-
-  @Test public void poolSingleHttpConnection() throws IOException {
-    ConnectionPool pool = new ConnectionPool(1, KEEP_ALIVE_DURATION_MS);
-    Connection connection = pool.get(httpAddress);
-    assertNull(connection);
-
-    connection = new Connection(new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true));
-    connection.connect(100, 100, null);
-    assertEquals(0, pool.getConnectionCount());
-    pool.recycle(connection);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getSpdyConnectionCount());
-
-    Connection recycledConnection = pool.get(httpAddress);
-    assertEquals(connection, recycledConnection);
-    assertTrue(recycledConnection.isAlive());
-
-    recycledConnection = pool.get(httpAddress);
-    assertNull(recycledConnection);
-  }
-
-  @Test public void poolPrefersMostRecentlyRecycled() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    pool.recycle(httpC);
-    assertPooled(pool, httpC, httpB);
-  }
-
-  @Test public void getSpdyConnection() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(spdyA);
-    assertSame(spdyA, pool.get(spdyAddress));
-    assertPooled(pool, spdyA);
-  }
-
-  @Test public void getHttpConnection() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    assertSame(httpA, pool.get(httpAddress));
-    assertPooled(pool);
-  }
-
-  @Test public void idleConnectionNotReturned() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    Thread.sleep(KEEP_ALIVE_DURATION_MS * 2);
-    assertNull(pool.get(httpAddress));
-    assertPooled(pool);
-  }
-
-  @Test public void maxIdleConnectionLimitIsEnforced() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    pool.recycle(httpC);
-    pool.recycle(httpD);
-    assertPooled(pool, httpD, httpC);
-  }
-
-  @Test public void expiredConnectionsAreEvicted() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    Thread.sleep(2 * KEEP_ALIVE_DURATION_MS);
-    pool.get(spdyAddress); // Force the cleanup callable to run.
-    assertPooled(pool);
-  }
-
-  @Test public void nonAliveConnectionNotReturned() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    httpA.close();
-    assertNull(pool.get(httpAddress));
-    assertPooled(pool);
-  }
-
-  @Test public void differentAddressConnectionNotReturned() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    assertNull(pool.get(spdyAddress));
-    assertPooled(pool, httpA);
-  }
-
-  @Test public void gettingSpdyConnectionPromotesItToFrontOfQueue() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(spdyA);
-    pool.recycle(httpA);
-    assertPooled(pool, httpA, spdyA);
-    assertSame(spdyA, pool.get(spdyAddress));
-    assertPooled(pool, spdyA, httpA);
-  }
-
-  @Test public void gettingConnectionReturnsOldestFirst() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    assertSame(httpA, pool.get(httpAddress));
-  }
-
-  @Test public void recyclingNonAliveConnectionClosesThatConnection() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    httpA.getSocket().shutdownInput();
-    pool.recycle(httpA); // Should close httpA.
-    assertTrue(httpA.getSocket().isClosed());
-  }
-
-  @Test public void shareHttpConnectionDoesNothing() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(httpA);
-    assertPooled(pool);
-  }
-
-  @Test public void recycleSpdyConnectionDoesNothing() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(spdyA);
-    assertPooled(pool);
-  }
-
-  @Test public void validateIdleSpdyConnectionTimeout() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(spdyA);
-    Thread.sleep((int) (KEEP_ALIVE_DURATION_MS * 0.7));
-    assertNull(pool.get(httpAddress));
-    assertPooled(pool, spdyA); // Connection should still be in the pool.
-    Thread.sleep((int) (KEEP_ALIVE_DURATION_MS * 0.4));
-    assertNull(pool.get(httpAddress));
-    assertPooled(pool);
-  }
-
-  @Test public void validateIdleHttpConnectionTimeout() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    Thread.sleep((int) (KEEP_ALIVE_DURATION_MS * 0.7));
-    assertNull(pool.get(spdyAddress));
-    assertPooled(pool, httpA); // Connection should still be in the pool.
-    Thread.sleep((int) (KEEP_ALIVE_DURATION_MS * 0.4));
-    assertNull(pool.get(spdyAddress));
-    assertPooled(pool);
-  }
-
-  @Test public void maxConnections() throws IOException, InterruptedException {
-    ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-
-    // Pool should be empty.
-    assertEquals(0, pool.getConnectionCount());
-
-    // http A should be added to the pool.
-    pool.recycle(httpA);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getSpdyConnectionCount());
-
-    // http B should be added to the pool.
-    pool.recycle(httpB);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getSpdyConnectionCount());
-
-    // http C should be added and http A should be removed.
-    pool.recycle(httpC);
-    Thread.sleep(50);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getSpdyConnectionCount());
-
-    // spdy A should be added and http B should be removed.
-    pool.maybeShare(spdyA);
-    Thread.sleep(50);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // http C should be removed from the pool.
-    Connection recycledHttpConnection = pool.get(httpAddress);
-    assertNotNull(recycledHttpConnection);
-    assertTrue(recycledHttpConnection.isAlive());
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // spdy A will be returned and kept in the pool.
-    Connection sharedSpdyConnection = pool.get(spdyAddress);
-    assertNotNull(sharedSpdyConnection);
-    assertEquals(spdyA, sharedSpdyConnection);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // Nothing should change.
-    pool.recycle(httpC);
-    Thread.sleep(50);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // Nothing should change.
-    pool.maybeShare(spdyB);
-    Thread.sleep(50);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // An http connection should be removed from the pool.
-    recycledHttpConnection = pool.get(httpAddress);
-    assertNotNull(recycledHttpConnection);
-    assertTrue(recycledHttpConnection.isAlive());
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // Shouldn't change numbers because spdyConnections A and B user the same server address.
-    pool.maybeShare(spdyB);
-    Thread.sleep(50);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // spdy A will be returned and kept in the pool. Pool shouldn't change.
-    sharedSpdyConnection = pool.get(spdyAddress);
-    assertEquals(spdyA, sharedSpdyConnection);
-    assertNotNull(sharedSpdyConnection);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // http D should be added to the pool.
-    pool.recycle(httpD);
-    Thread.sleep(50);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // http E should be added to the pool. spdy A should be removed from the pool.
-    pool.recycle(httpE);
-    Thread.sleep(50);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getSpdyConnectionCount());
-  }
-
-  @Test public void connectionCleanup() throws IOException, InterruptedException {
-    ConnectionPool pool = new ConnectionPool(10, KEEP_ALIVE_DURATION_MS);
-
-    // Add 3 connections to the pool.
-    pool.recycle(httpA);
-    pool.recycle(httpB);
-    pool.maybeShare(spdyA);
-    assertEquals(3, pool.getConnectionCount());
-    assertEquals(2, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    // Kill http A.
-    Util.closeQuietly(httpA);
-
-    // Force pool to run a clean up.
-    assertNotNull(pool.get(spdyAddress));
-    Thread.sleep(50);
-
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
-    Thread.sleep(KEEP_ALIVE_DURATION_MS);
-    // Force pool to run a clean up.
-    assertNull(pool.get(httpAddress));
-    assertNull(pool.get(spdyAddress));
-
-    Thread.sleep(50);
-
-    assertEquals(0, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(0, pool.getSpdyConnectionCount());
-  }
-
-  @Test public void evictAllConnections() {
-    ConnectionPool pool = new ConnectionPool(10, KEEP_ALIVE_DURATION_MS);
-    pool.recycle(httpA);
-    Util.closeQuietly(httpA); // Include a closed connection in the pool.
-    pool.recycle(httpB);
-    pool.maybeShare(spdyA);
-    int connectionCount = pool.getConnectionCount();
-    assertTrue(connectionCount == 2 || connectionCount == 3);
-
-    pool.evictAll();
-    assertEquals(0, pool.getConnectionCount());
-  }
-
-  private void assertPooled(ConnectionPool pool, Connection... connections) throws Exception {
-    assertEquals(Arrays.asList(connections), pool.getConnections());
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java b/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java
deleted file mode 100644
index f30ae98573..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-/**
- * A received response or failure recorded by the response recorder.
- */
-public class RecordedResponse {
-  public final Request request;
-  public final Response response;
-  public final String body;
-  public final Failure failure;
-
-  RecordedResponse(Request request, Response response, String body, Failure failure) {
-    this.request = request;
-    this.response = response;
-    this.body = body;
-    this.failure = failure;
-  }
-
-  public RecordedResponse assertCode(int expectedCode) {
-    assertEquals(expectedCode, response.code());
-    return this;
-  }
-
-  public RecordedResponse assertContainsHeaders(String... expectedHeaders) {
-    List<String> actualHeaders = new ArrayList<String>();
-    for (int i = 0; i < response.headerCount(); i++) {
-      actualHeaders.add(response.headerName(i) + ": " + response.headerValue(i));
-    }
-    if (!actualHeaders.containsAll(Arrays.asList(expectedHeaders))) {
-      fail("Expected: " + actualHeaders + "\nto contain: " + Arrays.toString(expectedHeaders));
-    }
-    return this;
-  }
-
-  public RecordedResponse assertBody(String expectedBody) {
-    assertEquals(expectedBody, body);
-    return this;
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RequestTest.java b/okhttp/src/test/java/com/squareup/okhttp/RequestTest.java
deleted file mode 100644
index ed43e194a7..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/RequestTest.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-public final class RequestTest {
-  @Test public void string() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain; charset=utf-8");
-    Request.Body body = Request.Body.create(contentType, "abc".getBytes(Util.UTF_8));
-    assertEquals(contentType, body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("616263", bodyToHex(body));
-    assertEquals("Retransmit body", "616263", bodyToHex(body));
-  }
-
-  @Test public void stringWithDefaultCharsetAdded() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain");
-    Request.Body body = Request.Body.create(contentType, "\u0800");
-    assertEquals(MediaType.parse("text/plain; charset=utf-8"), body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("e0a080", bodyToHex(body));
-  }
-
-  @Test public void stringWithNonDefaultCharsetSpecified() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain; charset=utf-16be");
-    Request.Body body = Request.Body.create(contentType, "\u0800");
-    assertEquals(contentType, body.contentType());
-    assertEquals(2, body.contentLength());
-    assertEquals("0800", bodyToHex(body));
-  }
-
-  @Test public void byteArray() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain");
-    Request.Body body = Request.Body.create(contentType, "abc".getBytes(Util.UTF_8));
-    assertEquals(contentType, body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("616263", bodyToHex(body));
-    assertEquals("Retransmit body", "616263", bodyToHex(body));
-  }
-
-  @Test public void file() throws Exception {
-    File file = File.createTempFile("RequestTest", "tmp");
-    FileWriter writer = new FileWriter(file);
-    writer.write("abc");
-    writer.close();
-
-    MediaType contentType = MediaType.parse("text/plain");
-    Request.Body body = Request.Body.create(contentType, file);
-    assertEquals(contentType, body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("616263", bodyToHex(body));
-    assertEquals("Retransmit body", "616263", bodyToHex(body));
-  }
-
-  private String bodyToHex(Request.Body body) throws IOException {
-    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    body.writeTo(bytes);
-    return bytesToHex(bytes.toByteArray());
-  }
-
-  private String bytesToHex(byte[] bytes) {
-    StringBuilder hex = new StringBuilder();
-    for (byte b : bytes) {
-      if ((b & 0xff) < 0x10) hex.append('0');
-      hex.append(Integer.toHexString(b & 0xff));
-    }
-    return hex.toString();
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/FaultRecoveringOutputStreamTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/FaultRecoveringOutputStreamTest.java
deleted file mode 100644
index e933c177c3..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/FaultRecoveringOutputStreamTest.java
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Deque;
-import java.util.List;
-import org.junit.Test;
-
-import static com.squareup.okhttp.internal.Util.UTF_8;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class FaultRecoveringOutputStreamTest {
-  @Test public void noRecoveryWithoutReplacement() throws Exception {
-    FaultingOutputStream faulting = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting);
-
-    recovering.write('a');
-    faulting.nextFault = "system on fire";
-    try {
-      recovering.write('b');
-      fail();
-    } catch (IOException e) {
-      assertEquals(Arrays.asList("system on fire"), recovering.exceptionMessages);
-      assertEquals("ab", faulting.receivedUtf8);
-      assertFalse(faulting.closed);
-    }
-  }
-
-  @Test public void successfulRecoveryOnWriteFault() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-
-    recovering.write('a');
-    assertEquals("a", faulting1.receivedUtf8);
-    assertEquals("", faulting2.receivedUtf8);
-    faulting1.nextFault = "system under water";
-    recovering.write('b');
-    assertEquals(Arrays.asList("system under water"), recovering.exceptionMessages);
-    assertEquals("ab", faulting1.receivedUtf8);
-    assertEquals("ab", faulting2.receivedUtf8);
-    assertTrue(faulting1.closed);
-    assertFalse(faulting2.closed);
-
-    // Confirm that new data goes to the new stream.
-    recovering.write('c');
-    assertEquals("ab", faulting1.receivedUtf8);
-    assertEquals("abc", faulting2.receivedUtf8);
-  }
-
-  @Test public void successfulRecoveryOnFlushFault() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-
-    recovering.write('a');
-    faulting1.nextFault = "bad weather";
-    recovering.flush();
-    assertEquals(Arrays.asList("bad weather"), recovering.exceptionMessages);
-    assertEquals("a", faulting1.receivedUtf8);
-    assertEquals("a", faulting2.receivedUtf8);
-    assertTrue(faulting1.closed);
-    assertFalse(faulting2.closed);
-    assertEquals("a", faulting2.flushedUtf8);
-
-    // Confirm that new data goes to the new stream.
-    recovering.write('b');
-    assertEquals("a", faulting1.receivedUtf8);
-    assertEquals("ab", faulting2.receivedUtf8);
-    assertEquals("a", faulting2.flushedUtf8);
-  }
-
-  @Test public void successfulRecoveryOnCloseFault() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-
-    recovering.write('a');
-    faulting1.nextFault = "termites";
-    recovering.close();
-    assertEquals(Arrays.asList("termites"), recovering.exceptionMessages);
-    assertEquals("a", faulting1.receivedUtf8);
-    assertEquals("a", faulting2.receivedUtf8);
-    assertTrue(faulting1.closed);
-    assertTrue(faulting2.closed);
-  }
-
-  @Test public void replacementStreamFaultsImmediately() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    FaultingOutputStream faulting3 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-    recovering.replacements.addLast(faulting3);
-
-    recovering.write('a');
-    assertEquals("a", faulting1.receivedUtf8);
-    assertEquals("", faulting2.receivedUtf8);
-    assertEquals("", faulting3.receivedUtf8);
-    faulting1.nextFault = "offline";
-    faulting2.nextFault = "slow";
-    recovering.write('b');
-    assertEquals(Arrays.asList("offline", "slow"), recovering.exceptionMessages);
-    assertEquals("ab", faulting1.receivedUtf8);
-    assertEquals("a", faulting2.receivedUtf8);
-    assertEquals("ab", faulting3.receivedUtf8);
-    assertTrue(faulting1.closed);
-    assertTrue(faulting2.closed);
-    assertFalse(faulting3.closed);
-
-    // Confirm that new data goes to the new stream.
-    recovering.write('c');
-    assertEquals("ab", faulting1.receivedUtf8);
-    assertEquals("a", faulting2.receivedUtf8);
-    assertEquals("abc", faulting3.receivedUtf8);
-  }
-
-  @Test public void recoverWithFullBuffer() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-
-    recovering.write("abcdefghij".getBytes(UTF_8)); // 10 bytes.
-    faulting1.nextFault = "unlucky";
-    recovering.write('k');
-    assertEquals("abcdefghijk", faulting1.receivedUtf8);
-    assertEquals("abcdefghijk", faulting2.receivedUtf8);
-    assertEquals(Arrays.asList("unlucky"), recovering.exceptionMessages);
-    assertTrue(faulting1.closed);
-    assertFalse(faulting2.closed);
-
-    // Confirm that new data goes to the new stream.
-    recovering.write('l');
-    assertEquals("abcdefghijk", faulting1.receivedUtf8);
-    assertEquals("abcdefghijkl", faulting2.receivedUtf8);
-  }
-
-  @Test public void noRecoveryWithOverfullBuffer() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-
-    recovering.write("abcdefghijk".getBytes(UTF_8)); // 11 bytes.
-    faulting1.nextFault = "out to lunch";
-    try {
-      recovering.write('l');
-      fail();
-    } catch (IOException expected) {
-      assertEquals("out to lunch", expected.getMessage());
-    }
-
-    assertEquals(Arrays.<String>asList(), recovering.exceptionMessages);
-    assertEquals("abcdefghijkl", faulting1.receivedUtf8);
-    assertEquals("", faulting2.receivedUtf8);
-    assertFalse(faulting1.closed);
-    assertFalse(faulting2.closed);
-  }
-
-  static class FaultingOutputStream extends OutputStream {
-    String receivedUtf8 = "";
-    String flushedUtf8 = null;
-    String nextFault;
-    boolean closed;
-
-    @Override public final void write(int data) throws IOException {
-      write(new byte[] { (byte) data });
-    }
-
-    @Override public void write(byte[] buffer, int offset, int count) throws IOException {
-      receivedUtf8 += new String(buffer, offset, count, UTF_8);
-      if (nextFault != null) throw new IOException(nextFault);
-    }
-
-    @Override public void flush() throws IOException {
-      flushedUtf8 = receivedUtf8;
-      if (nextFault != null) throw new IOException(nextFault);
-    }
-
-    @Override public void close() throws IOException {
-      closed = true;
-      if (nextFault != null) throw new IOException(nextFault);
-    }
-  }
-
-  static class TestFaultRecoveringOutputStream extends FaultRecoveringOutputStream {
-    final List<String> exceptionMessages = new ArrayList<String>();
-    final Deque<OutputStream> replacements = new ArrayDeque<OutputStream>();
-
-    TestFaultRecoveringOutputStream(int maxReplayBufferLength, OutputStream first) {
-      super(maxReplayBufferLength, first);
-    }
-
-    @Override protected OutputStream replacementStream(IOException e) {
-      exceptionMessages.add(e.getMessage());
-      return replacements.poll();
-    }
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java b/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
deleted file mode 100644
index 636acbde11..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import com.squareup.okhttp.OkAuthenticator;
-import java.io.IOException;
-import java.net.Proxy;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-
-public final class RecordingOkAuthenticator implements OkAuthenticator {
-  public final List<String> calls = new ArrayList<String>();
-  public final Credential credential;
-
-  public RecordingOkAuthenticator(Credential credential) {
-    this.credential = credential;
-  }
-
-  @Override public Credential authenticate(Proxy proxy, URL url, List<Challenge> challenges)
-      throws IOException {
-    calls.add("authenticate"
-        + " proxy=" + proxy.type()
-        + " url=" + url
-        + " challenges=" + challenges);
-    return credential;
-  }
-
-  @Override public Credential authenticateProxy(Proxy proxy, URL url, List<Challenge> challenges)
-      throws IOException {
-    calls.add("authenticateProxy"
-        + " proxy=" + proxy.type()
-        + " url=" + url
-        + " challenges=" + challenges);
-    return credential;
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/StrictLineReaderTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/StrictLineReaderTest.java
deleted file mode 100644
index 252f6ac85c..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/StrictLineReaderTest.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal;
-
-import java.io.ByteArrayInputStream;
-import java.io.EOFException;
-import java.io.InputStream;
-import org.junit.Test;
-
-import static com.squareup.okhttp.internal.Util.US_ASCII;
-import static org.junit.Assert.fail;
-
-public final class StrictLineReaderTest {
-  @Test public void lineReaderConsistencyWithReadAsciiLine() throws Exception {
-    // Testing with LineReader buffer capacity 32 to check some corner cases.
-    StrictLineReader lineReader = new StrictLineReader(createTestInputStream(), 32, US_ASCII);
-    InputStream refStream = createTestInputStream();
-    while (true) {
-      try {
-        String refLine = Util.readAsciiLine(refStream);
-        try {
-          String line = lineReader.readLine();
-          if (!refLine.equals(line)) {
-            fail("line (\"" + line + "\") differs from expected (\"" + refLine + "\").");
-          }
-        } catch (EOFException eof) {
-          fail("line reader threw EOFException too early.");
-        }
-      } catch (EOFException refEof) {
-        try {
-          lineReader.readLine();
-          fail("line reader didn't throw the expected EOFException.");
-        } catch (EOFException eof) {
-          // OK
-          break;
-        }
-      }
-    }
-    refStream.close();
-    lineReader.close();
-  }
-
-  private InputStream createTestInputStream() {
-    return new ByteArrayInputStream((
-                /* each source lines below should represent 32 bytes, until the next comment */
-        "12 byte line\n18 byte line......\n" +
-            "pad\nline spanning two 32-byte bu" +
-            "ffers\npad......................\n" +
-            "pad\nline spanning three 32-byte " +
-            "buffers and ending with LF at th" +
-            "e end of a 32 byte buffer......\n" +
-            "pad\nLine ending with CRLF split" +
-            " at the end of a 32-byte buffer\r" +
-            "\npad...........................\n" +
-                        /* end of 32-byte lines */
-            "line ending with CRLF\r\n" +
-            "this is a long line with embedded CR \r ending with CRLF and having more than " +
-            "32 characters\r\n" +
-            "unterminated line - should be dropped").getBytes());
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
deleted file mode 100644
index ca240f1311..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.HttpResponseCache;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.internal.RecordingAuthenticator;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.Authenticator;
-import java.net.CookieManager;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.URL;
-import java.net.URLConnection;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.UUID;
-import java.util.zip.GZIPOutputStream;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSession;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-/** Test how SPDY interacts with HTTP features. */
-public final class HttpOverSpdyTest {
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    public boolean verify(String hostname, SSLSession session) {
-      return true;
-    }
-  };
-
-  private static final SSLContext sslContext;
-  static {
-    try {
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-  private final MockWebServer server = new MockWebServer();
-  private final String hostName = server.getHostName();
-  private final OkHttpClient client = new OkHttpClient();
-  private HttpResponseCache cache;
-
-  @Before public void setUp() throws Exception {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    String systemTmpDir = System.getProperty("java.io.tmpdir");
-    File cacheDir = new File(systemTmpDir, "HttpCache-" + UUID.randomUUID());
-    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
-  }
-
-  @After public void tearDown() throws Exception {
-    Authenticator.setDefault(null);
-    server.shutdown();
-  }
-
-  @Test public void get() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet");
-    server.enqueue(response);
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Sweet", connection.getResponseMessage());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertContains(request.getHeaders(), ":scheme: https");
-    assertContains(request.getHeaders(), ":host: " + hostName + ":" + server.getPort());
-  }
-
-  @Test public void emptyResponse() throws IOException {
-    server.enqueue(new MockResponse());
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
-    assertEquals(-1, connection.getInputStream().read());
-  }
-
-  @Test public void post() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDE");
-    server.enqueue(response);
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("FGHIJ".getBytes(Util.UTF_8));
-    assertContent("ABCDE", connection, Integer.MAX_VALUE);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("FGHIJ", request.getUtf8Body());
-  }
-
-  @Test public void spdyConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDEF"));
-    server.enqueue(new MockResponse().setBody("GHIJKL"));
-    server.play();
-
-    HttpURLConnection connection1 = client.open(server.getUrl("/r1"));
-    HttpURLConnection connection2 = client.open(server.getUrl("/r2"));
-    assertEquals("ABC", readAscii(connection1.getInputStream(), 3));
-    assertEquals("GHI", readAscii(connection2.getInputStream(), 3));
-    assertEquals("DEF", readAscii(connection1.getInputStream(), 3));
-    assertEquals("JKL", readAscii(connection2.getInputStream(), 3));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void gzippedResponseBody() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Encoding: gzip")
-        .setBody(gzip("ABCABCABC".getBytes(Util.UTF_8))));
-    server.play();
-    assertContent("ABCABCABC", client.open(server.getUrl("/r1")), Integer.MAX_VALUE);
-  }
-
-  @Test public void authenticate() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
-        .addHeader("www-authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-    server.play();
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest denied = server.takeRequest();
-    assertContainsNoneMatching(denied.getHeaders(), "authorization: Basic .*");
-    RecordedRequest accepted = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", accepted.getRequestLine());
-    assertContains(accepted.getHeaders(),
-        "authorization: Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS);
-  }
-
-  @Test public void redirect() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    assertContent("This is the new location!", connection, Integer.MAX_VALUE);
-
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("/", request1.getPath());
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("/foo", request2.getPath());
-  }
-
-  @Test public void readAfterLastByte() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.play();
-
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    InputStream in = connection.getInputStream();
-    assertEquals("ABC", readAscii(in, 3));
-    assertEquals(-1, in.read());
-    assertEquals(-1, in.read());
-  }
-
-  @Test public void responsesAreCached() throws IOException {
-    client.setResponseCache(cache);
-
-    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("A"));
-    server.play();
-
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
-  }
-
-  @Test public void conditionalCache() throws IOException {
-    client.setResponseCache(cache);
-
-    server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.play();
-
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-    assertContent("A", client.open(server.getUrl("/")), Integer.MAX_VALUE);
-    assertEquals(2, cache.getRequestCount());
-    assertEquals(2, cache.getNetworkCount());
-    assertEquals(1, cache.getHitCount());
-  }
-
-  @Test public void acceptAndTransmitCookies() throws Exception {
-    CookieManager cookieManager = new CookieManager();
-    client.setCookieHandler(cookieManager);
-    server.enqueue(
-        new MockResponse().addHeader("set-cookie: c=oreo; domain=" + server.getCookieDomain())
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.play();
-
-    URL url = server.getUrl("/");
-    assertContent("A", client.open(url), Integer.MAX_VALUE);
-    Map<String, List<String>> requestHeaders = Collections.emptyMap();
-    assertEquals(Collections.singletonMap("Cookie", Arrays.asList("c=oreo")),
-        cookieManager.get(url.toURI(), requestHeaders));
-
-    assertContent("B", client.open(url), Integer.MAX_VALUE);
-    RecordedRequest requestA = server.takeRequest();
-    assertContainsNoneMatching(requestA.getHeaders(), "Cookie.*");
-    RecordedRequest requestB = server.takeRequest();
-    assertContains(requestB.getHeaders(), "cookie: c=oreo");
-  }
-
-  private <T> void assertContains(Collection<T> collection, T value) {
-    assertTrue(collection.toString(), collection.contains(value));
-  }
-
-  private void assertContent(String expected, URLConnection connection, int limit)
-      throws IOException {
-    connection.connect();
-    assertEquals(expected, readAscii(connection.getInputStream(), limit));
-    ((HttpURLConnection) connection).disconnect();
-  }
-
-  private void assertContainsNoneMatching(List<String> headers, String pattern) {
-    for (String header : headers) {
-      if (header.matches(pattern)) {
-        fail("Header " + header + " matches " + pattern);
-      }
-    }
-  }
-
-  private String readAscii(InputStream in, int count) throws IOException {
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  public byte[] gzip(byte[] bytes) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
-    gzippedOut.write(bytes);
-    gzippedOut.close();
-    return bytesOut.toByteArray();
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RawHeadersTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/RawHeadersTest.java
deleted file mode 100644
index 4ce80a5ebb..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RawHeadersTest.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import org.junit.Test;
-
-import static junit.framework.Assert.assertNull;
-import static org.junit.Assert.assertEquals;
-
-public final class RawHeadersTest {
-  @Test public void parseNameValueBlock() throws IOException {
-    List<String> nameValueBlock = Arrays.asList(
-        "cache-control", "no-cache, no-store",
-        "set-cookie", "Cookie1\u0000Cookie2",
-        ":status", "200 OK",
-        ":version", "HTTP/1.1");
-    RawHeaders rawHeaders = RawHeaders.fromNameValueBlock(nameValueBlock);
-    assertEquals(3, rawHeaders.length());
-    assertEquals("HTTP/1.1 200 OK", rawHeaders.getStatusLine());
-    assertEquals("no-cache, no-store", rawHeaders.get("cache-control"));
-    assertEquals("Cookie2", rawHeaders.get("set-cookie"));
-    assertEquals("cache-control", rawHeaders.getFieldName(0));
-    assertEquals("no-cache, no-store", rawHeaders.getValue(0));
-    assertEquals("set-cookie", rawHeaders.getFieldName(1));
-    assertEquals("Cookie1", rawHeaders.getValue(1));
-    assertEquals("set-cookie", rawHeaders.getFieldName(2));
-    assertEquals("Cookie2", rawHeaders.getValue(2));
-    assertNull(rawHeaders.get(":status"));
-    assertNull(rawHeaders.get(":version"));
-  }
-
-  @Test public void toNameValueBlock() {
-    RawHeaders rawHeaders = new RawHeaders();
-    rawHeaders.add("cache-control", "no-cache, no-store");
-    rawHeaders.add("set-cookie", "Cookie1");
-    rawHeaders.add("set-cookie", "Cookie2");
-    rawHeaders.add(":status", "200 OK");
-    // TODO: fromNameValueBlock should take the status line headers
-    List<String> nameValueBlock = rawHeaders.toNameValueBlock();
-    List<String> expected =
-        Arrays.asList("cache-control", "no-cache, no-store", "set-cookie", "Cookie1\u0000Cookie2",
-            ":status", "200 OK");
-    assertEquals(expected, nameValueBlock);
-  }
-
-  @Test public void toNameValueBlockDropsForbiddenHeaders() {
-    RawHeaders rawHeaders = new RawHeaders();
-    rawHeaders.add("Connection", "close");
-    rawHeaders.add("Transfer-Encoding", "chunked");
-    assertEquals(Arrays.<String>asList(), rawHeaders.toNameValueBlock());
-  }
-
-  @Test public void statusMessage() throws IOException {
-    RawHeaders rawHeaders = new RawHeaders();
-    final String message = "Temporary Redirect";
-    final int version = 1;
-    final int code = 200;
-    rawHeaders.setStatusLine("HTTP/1." + version + " " + code + " " + message);
-    assertEquals(message, rawHeaders.getResponseMessage());
-    assertEquals(version, rawHeaders.getHttpMinorVersion());
-    assertEquals(code, rawHeaders.getResponseCode());
-  }
-
-  @Test public void statusMessageWithEmptyMessage() throws IOException {
-    RawHeaders rawHeaders = new RawHeaders();
-    final int version = 1;
-    final int code = 503;
-    rawHeaders.setStatusLine("HTTP/1." + version + " " + code + " ");
-    assertEquals("", rawHeaders.getResponseMessage());
-    assertEquals(version, rawHeaders.getHttpMinorVersion());
-    assertEquals(code, rawHeaders.getResponseCode());
-  }
-
-  /**
-   * This is not defined in the protocol but some servers won't add the leading
-   * empty space when the message is empty.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
-   */
-  @Test public void statusMessageWithEmptyMessageAndNoLeadingSpace() throws IOException {
-    RawHeaders rawHeaders = new RawHeaders();
-    final int version = 1;
-    final int code = 503;
-    rawHeaders.setStatusLine("HTTP/1." + version + " " + code);
-    assertEquals("", rawHeaders.getResponseMessage());
-    assertEquals(version, rawHeaders.getHttpMinorVersion());
-    assertEquals(code, rawHeaders.getResponseCode());
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
deleted file mode 100644
index a92db9ee14..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
+++ /dev/null
@@ -1,451 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Address;
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.OkAuthenticator;
-import com.squareup.okhttp.RouteDatabase;
-import com.squareup.okhttp.internal.Dns;
-import com.squareup.okhttp.internal.SslContextBuilder;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.NoSuchElementException;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSocketFactory;
-import org.junit.Test;
-
-import static java.net.Proxy.NO_PROXY;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class RouteSelectorTest {
-  private static final int proxyAPort = 1001;
-  private static final String proxyAHost = "proxyA";
-  private static final Proxy proxyA =
-      new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyAHost, proxyAPort));
-  private static final int proxyBPort = 1002;
-  private static final String proxyBHost = "proxyB";
-  private static final Proxy proxyB =
-      new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyBHost, proxyBPort));
-  private static final URI uri;
-  private static final String uriHost = "hostA";
-  private static final int uriPort = 80;
-
-  private static final SSLContext sslContext;
-  private static final SSLSocketFactory socketFactory;
-  private static final HostnameVerifier hostnameVerifier;
-  private static final ConnectionPool pool;
-
-  static {
-    try {
-      uri = new URI("http://" + uriHost + ":" + uriPort + "/path");
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-      socketFactory = sslContext.getSocketFactory();
-      pool = ConnectionPool.getDefault();
-      hostnameVerifier = HttpsURLConnectionImpl.getDefaultHostnameVerifier();
-    } catch (Exception e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  private final OkAuthenticator authenticator = HttpAuthenticator.SYSTEM_DEFAULT;
-  private final List<String> transports = Arrays.asList("http/1.1");
-  private final FakeDns dns = new FakeDns();
-  private final FakeProxySelector proxySelector = new FakeProxySelector();
-
-  @Test public void singleRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    dns.assertRequests(uriHost);
-
-    assertFalse(routeSelector.hasNext());
-    try {
-      routeSelector.next("GET");
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void singleRouteReturnsFailedRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    Connection connection = routeSelector.next("GET");
-    RouteDatabase routeDatabase = new RouteDatabase();
-    routeDatabase.failed(connection.getRoute(), new IOException());
-    routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns, routeDatabase);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    assertFalse(routeSelector.hasNext());
-    try {
-      routeSelector.next("GET");
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void explicitProxyTriesThatProxiesAddressesOnly() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, proxyA, transports);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        false);
-
-    assertFalse(routeSelector.hasNext());
-    dns.assertRequests(proxyAHost);
-    proxySelector.assertRequests(); // No proxy selector requests!
-  }
-
-  @Test public void explicitDirectProxy() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, NO_PROXY,
-        transports);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[1], uriPort,
-        false);
-
-    assertFalse(routeSelector.hasNext());
-    dns.assertRequests(uri.getHost());
-    proxySelector.assertRequests(); // No proxy selector requests!
-  }
-
-  @Test public void proxySelectorReturnsNull() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
-
-    proxySelector.proxies = null;
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-    proxySelector.assertRequests(uri);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    dns.assertRequests(uriHost);
-
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void proxySelectorReturnsNoProxies() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[1], uriPort,
-        false);
-
-    assertFalse(routeSelector.hasNext());
-    dns.assertRequests(uri.getHost());
-    proxySelector.assertRequests(uri);
-  }
-
-  @Test public void proxySelectorReturnsMultipleProxies() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
-
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-    proxySelector.assertRequests(uri);
-
-    // First try the IP addresses of the first proxy, in sequence.
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        false);
-    dns.assertRequests(proxyAHost);
-
-    // Next try the IP address of the second proxy.
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[0], proxyBPort,
-        false);
-    dns.assertRequests(proxyBHost);
-
-    // Finally try the only IP address of the origin server.
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(253, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    dns.assertRequests(uriHost);
-
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void proxySelectorDirectConnectionsAreSkipped() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
-
-    proxySelector.proxies.add(NO_PROXY);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-    proxySelector.assertRequests(uri);
-
-    // Only the origin server will be attempted.
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    dns.assertRequests(uriHost);
-
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void proxyDnsFailureContinuesToNextProxy() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
-
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    proxySelector.proxies.add(proxyA);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-    proxySelector.assertRequests(uri);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        false);
-    dns.assertRequests(proxyAHost);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = null;
-    try {
-      routeSelector.next("GET");
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-    dns.assertRequests(proxyBHost);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        false);
-    dns.assertRequests(proxyAHost);
-
-    assertTrue(routeSelector.hasNext());
-    dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    dns.assertRequests(uriHost);
-
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void nonSslErrorAddsAllTlsModesToFailedRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        Proxy.NO_PROXY, transports);
-    RouteDatabase routeDatabase = new RouteDatabase();
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        routeDatabase);
-
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    Connection connection = routeSelector.next("GET");
-    routeSelector.connectFailed(connection, new IOException("Non SSL exception"));
-    assertTrue(routeDatabase.failedRoutesCount() == 2);
-  }
-
-  @Test public void sslErrorAddsOnlyFailedTlsModeToFailedRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        Proxy.NO_PROXY, transports);
-    RouteDatabase routeDatabase = new RouteDatabase();
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        routeDatabase);
-
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-    Connection connection = routeSelector.next("GET");
-    routeSelector.connectFailed(connection, new SSLHandshakeException("SSL exception"));
-    assertTrue(routeDatabase.failedRoutesCount() == 1);
-  }
-
-  @Test public void multipleProxiesMultipleInetAddressesMultipleTlsModes() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        null, transports);
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-
-    // Proxy A
-    dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        true);
-    dns.assertRequests(proxyAHost);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        true);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        false);
-
-    // Proxy B
-    dns.inetAddresses = makeFakeAddresses(254, 2);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[0], proxyBPort,
-        true);
-    dns.assertRequests(proxyBHost);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[0], proxyBPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[1], proxyBPort,
-        true);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[1], proxyBPort,
-        false);
-
-    // Origin
-    dns.inetAddresses = makeFakeAddresses(253, 2);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        true);
-    dns.assertRequests(uriHost);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        false);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[1], uriPort,
-        true);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[1], uriPort,
-        false);
-
-    assertFalse(routeSelector.hasNext());
-  }
-
-  @Test public void failedRoutesAreLast() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        Proxy.NO_PROXY, transports);
-
-    RouteDatabase routeDatabase = new RouteDatabase();
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        routeDatabase);
-    dns.inetAddresses = makeFakeAddresses(255, 1);
-
-    // Extract the regular sequence of routes from selector.
-    List<Connection> regularRoutes = new ArrayList<Connection>();
-    while (routeSelector.hasNext()) {
-      regularRoutes.add(routeSelector.next("GET"));
-    }
-
-    // Check that we do indeed have more than one route.
-    assertTrue(regularRoutes.size() > 1);
-    // Add first regular route as failed.
-    routeDatabase.failed(regularRoutes.get(0).getRoute(), new SSLHandshakeException("none"));
-    // Reset selector
-    routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns, routeDatabase);
-
-    List<Connection> routesWithFailedRoute = new ArrayList<Connection>();
-    while (routeSelector.hasNext()) {
-      routesWithFailedRoute.add(routeSelector.next("GET"));
-    }
-
-    assertEquals(regularRoutes.get(0).getRoute(),
-        routesWithFailedRoute.get(routesWithFailedRoute.size() - 1).getRoute());
-    assertEquals(regularRoutes.size(), routesWithFailedRoute.size());
-  }
-
-  private void assertConnection(Connection connection, Address address, Proxy proxy,
-      InetAddress socketAddress, int socketPort, boolean modernTls) {
-    assertEquals(address, connection.getRoute().getAddress());
-    assertEquals(proxy, connection.getRoute().getProxy());
-    assertEquals(socketAddress, connection.getRoute().getSocketAddress().getAddress());
-    assertEquals(socketPort, connection.getRoute().getSocketAddress().getPort());
-    assertEquals(modernTls, connection.getRoute().isModernTls());
-  }
-
-  private static InetAddress[] makeFakeAddresses(int prefix, int count) {
-    try {
-      InetAddress[] result = new InetAddress[count];
-      for (int i = 0; i < count; i++) {
-        result[i] =
-            InetAddress.getByAddress(new byte[] { (byte) prefix, (byte) 0, (byte) 0, (byte) i });
-      }
-      return result;
-    } catch (UnknownHostException e) {
-      throw new AssertionError();
-    }
-  }
-
-  private static class FakeDns implements Dns {
-    List<String> requestedHosts = new ArrayList<String>();
-    InetAddress[] inetAddresses;
-
-    @Override public InetAddress[] getAllByName(String host) throws UnknownHostException {
-      requestedHosts.add(host);
-      if (inetAddresses == null) throw new UnknownHostException();
-      return inetAddresses;
-    }
-
-    public void assertRequests(String... expectedHosts) {
-      assertEquals(Arrays.asList(expectedHosts), requestedHosts);
-      requestedHosts.clear();
-    }
-  }
-
-  private static class FakeProxySelector extends ProxySelector {
-    List<URI> requestedUris = new ArrayList<URI>();
-    List<Proxy> proxies = new ArrayList<Proxy>();
-    List<String> failures = new ArrayList<String>();
-
-    @Override public List<Proxy> select(URI uri) {
-      requestedUris.add(uri);
-      return proxies;
-    }
-
-    public void assertRequests(URI... expectedUris) {
-      assertEquals(Arrays.asList(expectedUris), requestedUris);
-      requestedUris.clear();
-    }
-
-    @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-      InetSocketAddress socketAddress = (InetSocketAddress) sa;
-      failures.add(
-          String.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
-              ioe.getMessage()));
-    }
-  }
-}
diff --git a/pom.xml b/pom.xml
index a24a0efedc..bfc0d9c4e2 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp</groupId>
   <artifactId>parent</artifactId>
-  <version>1.2.2-SNAPSHOT</version>
+  <version>2.3.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
@@ -21,23 +21,32 @@
   <modules>
     <module>okhttp</module>
     <module>okhttp-apache</module>
-    <module>okhttp-protocols</module>
+    <module>okhttp-tests</module>
+    <module>okhttp-urlconnection</module>
+    <module>okcurl</module>
     <module>mockwebserver</module>
     <module>samples</module>
+    <module>benchmarks</module>
   </modules>
 
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 
     <!-- Compilation -->
-    <java.version>1.6</java.version>
-    <npn.version>8.1.2.v20120308</npn.version>
-    <bouncycastle.version>1.48</bouncycastle.version>
+    <java.version>1.7</java.version>
+    <okio.version>1.2.0</okio.version>
+    <!-- ALPN library targeted to Java 7 -->
+    <alpn.jdk7.version>7.1.2.v20141202</alpn.jdk7.version>
+    <!-- ALPN library targeted to Java 8 update 25. -->
+    <alpn.jdk8.version>8.1.2.v20141202</alpn.jdk8.version>
+    <bouncycastle.version>1.50</bouncycastle.version>
     <gson.version>2.2.3</gson.version>
     <apache.http.version>4.2.2</apache.http.version>
+    <airlift.version>0.6</airlift.version>
+    <guava.version>16.0</guava.version>
 
     <!-- Test Dependencies -->
-    <junit.version>4.10</junit.version>
+    <junit.version>4.11</junit.version>
   </properties>
 
   <scm>
@@ -62,14 +71,24 @@
   <dependencyManagement>
     <dependencies>
       <dependency>
-        <groupId>org.mortbay.jetty.npn</groupId>
-        <artifactId>npn-boot</artifactId>
-        <version>${npn.version}</version>
+        <groupId>com.squareup.okio</groupId>
+        <artifactId>okio</artifactId>
+        <version>${okio.version}</version>
       </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
         <version>${junit.version}</version>
+      </dependency>
+       <dependency>
+        <groupId>org.mortbay.jetty.alpn</groupId>
+        <artifactId>alpn-jdk7-boot</artifactId>
+        <version>${alpn.jdk7.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.mortbay.jetty.alpn</groupId>
+        <artifactId>alpn-jdk8-boot</artifactId>
+        <version>${alpn.jdk8.version}</version>
       </dependency>
       <dependency>
         <groupId>org.bouncycastle</groupId>
@@ -86,6 +105,16 @@
         <artifactId>httpclient</artifactId>
         <version>${apache.http.version}</version>
       </dependency>
+      <dependency>
+        <groupId>io.airlift</groupId>
+        <artifactId>airline</artifactId>
+        <version>${airlift.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava</artifactId>
+        <version>${guava.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
@@ -105,10 +134,14 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-surefire-plugin</artifactId>
-          <version>2.9</version>
-          <configuration>
-            <argLine>-Xbootclasspath/p:${settings.localRepository}/org/mortbay/jetty/npn/npn-boot/${npn.version}/npn-boot-${npn.version}.jar</argLine>
-          </configuration>
+          <version>2.17</version>
+          <dependencies>
+            <dependency>
+              <groupId>org.apache.maven.surefire</groupId>
+              <artifactId>surefire-junit47</artifactId>
+              <version>2.17</version>
+            </dependency>
+          </dependencies>
         </plugin>
 
         <plugin>
@@ -116,19 +149,26 @@
           <artifactId>maven-javadoc-plugin</artifactId>
           <version>2.9</version>
         </plugin>
-
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-release-plugin</artifactId>
-          <version>2.3.2</version>
-          <configuration>
-            <autoVersionSubmodules>true</autoVersionSubmodules>
-          </configuration>
-        </plugin>
       </plugins>
     </pluginManagement>
 
     <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-release-plugin</artifactId>
+        <version>2.4.2</version>
+        <dependencies>
+          <dependency>
+            <groupId>org.apache.maven.scm</groupId>
+            <artifactId>maven-scm-provider-gitexe</artifactId>
+            <version>1.9</version>
+          </dependency>
+        </dependencies>
+        <configuration>
+          <autoVersionSubmodules>true</autoVersionSubmodules>
+        </configuration>
+      </plugin>
+
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
@@ -137,6 +177,7 @@
           <failsOnError>true</failsOnError>
           <configLocation>checkstyle.xml</configLocation>
           <consoleOutput>true</consoleOutput>
+          <excludes>**/CipherSuite.java</excludes>
         </configuration>
         <executions>
           <execution>
@@ -150,7 +191,7 @@
       <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <version>1.9</version>
+        <version>1.11</version>
         <executions>
           <execution>
             <phase>test</phase>
@@ -162,12 +203,73 @@
         <configuration>
           <signature>
             <groupId>org.codehaus.mojo.signature</groupId>
-            <artifactId>java15</artifactId>
-            <version>1.0</version>
+            <artifactId>java16</artifactId>
+            <version>1.1</version>
           </signature>
         </configuration>
       </plugin>
     </plugins>
   </build>
+
+  <profiles>
+    <profile>
+      <id>alpn-when-jdk7</id>
+      <activation>
+        <jdk>1.7</jdk>
+      </activation>
+      <properties>
+        <bootclasspathPrefix>${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk7.version}/alpn-boot-${alpn.jdk7.version}.jar</bootclasspathPrefix>
+      </properties>
+      <build>
+        <pluginManagement>
+          <plugins>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-surefire-plugin</artifactId>
+              <configuration>
+                <argLine>-Xbootclasspath/p:${bootclasspathPrefix}</argLine>
+              </configuration>
+              <dependencies>
+                <dependency>
+                  <groupId>org.mortbay.jetty.alpn</groupId>
+                  <artifactId>alpn-boot</artifactId>
+                  <version>${alpn.jdk7.version}</version>
+                </dependency>
+              </dependencies>
+            </plugin>
+          </plugins>
+        </pluginManagement>
+      </build>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8</id>
+      <activation>
+        <jdk>1.8</jdk>
+      </activation>
+      <properties>
+        <bootclasspathPrefix>${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk8.version}/alpn-boot-${alpn.jdk8.version}.jar</bootclasspathPrefix>
+      </properties>
+      <build>
+        <pluginManagement>
+          <plugins>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-surefire-plugin</artifactId>
+              <configuration>
+                <argLine>-Xbootclasspath/p:${bootclasspathPrefix}</argLine>
+              </configuration>
+              <dependencies>
+                <dependency>
+                  <groupId>org.mortbay.jetty.alpn</groupId>
+                  <artifactId>alpn-boot</artifactId>
+                  <version>${alpn.jdk8.version}</version>
+                </dependency>
+              </dependencies>
+            </plugin>
+          </plugins>
+        </pluginManagement>
+      </build>
+    </profile>
+  </profiles>
 </project>
 
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
new file mode 100644
index 0000000000..2be2bab302
--- /dev/null
+++ b/samples/crawler/pom.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp.sample</groupId>
+    <artifactId>sample-parent</artifactId>
+    <version>2.3.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>crawler</artifactId>
+  <name>Sample: Crawler</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.jsoup</groupId>
+      <artifactId>jsoup</artifactId>
+      <version>1.7.3</version>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java b/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
new file mode 100644
index 0000000000..24383fe47e
--- /dev/null
+++ b/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.sample;
+
+import com.squareup.okhttp.Cache;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.File;
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import org.jsoup.Jsoup;
+import org.jsoup.nodes.Document;
+import org.jsoup.nodes.Element;
+
+/**
+ * Fetches HTML from a requested URL, follows the links, and repeats.
+ */
+public final class Crawler {
+  private final OkHttpClient client;
+  private final Set<URL> fetchedUrls = Collections.synchronizedSet(new LinkedHashSet<URL>());
+  private final LinkedBlockingQueue<URL> queue = new LinkedBlockingQueue<>();
+
+  public Crawler(OkHttpClient client) {
+    this.client = client;
+  }
+
+  private void parallelDrainQueue(int threadCount) {
+    ExecutorService executor = Executors.newFixedThreadPool(threadCount);
+    for (int i = 0; i < threadCount; i++) {
+      executor.execute(new Runnable() {
+        @Override public void run() {
+          try {
+            drainQueue();
+          } catch (Exception e) {
+            e.printStackTrace();
+          }
+        }
+      });
+    }
+    executor.shutdown();
+  }
+
+  private void drainQueue() throws Exception {
+    for (URL url; (url = queue.take()) != null; ) {
+      if (!fetchedUrls.add(url)) {
+        continue;
+      }
+
+      try {
+        fetch(url);
+      } catch (IOException e) {
+        System.out.printf("XXX: %s %s%n", url, e);
+      }
+    }
+  }
+
+  public void fetch(URL url) throws IOException {
+    Request request = new Request.Builder()
+        .url(url)
+        .build();
+    Response response = client.newCall(request).execute();
+    String responseSource = response.networkResponse() != null
+        ? ("(network: " + response.networkResponse().code() + ")")
+        : "(cache)";
+    int responseCode = response.code();
+
+    System.out.printf("%03d: %s %s%n", responseCode, url, responseSource);
+
+    String contentType = response.header("Content-Type");
+    if (responseCode != 200 || contentType == null) {
+      response.body().close();
+      return;
+    }
+
+    Document document = Jsoup.parse(response.body().string(), url.toString());
+    for (Element element : document.select("a[href]")) {
+      String href = element.attr("href");
+      URL link = parseUrl(url, href);
+      if (link != null) queue.add(link);
+    }
+  }
+
+  private URL parseUrl(URL url, String href) {
+    try {
+      URL result = new URL(url, href);
+      return result.getProtocol().equals("http") || result.getProtocol().equals("https")
+          ? result
+          : null;
+    } catch (MalformedURLException e) {
+      return null;
+    }
+  }
+
+  public static void main(String[] args) throws IOException {
+    if (args.length != 2) {
+      System.out.println("Usage: Crawler <cache dir> <root>");
+      return;
+    }
+
+    int threadCount = 20;
+    long cacheByteCount = 1024L * 1024L * 100L;
+
+    OkHttpClient client = new OkHttpClient();
+    Cache cache = new Cache(new File(args[0]), cacheByteCount);
+    client.setCache(cache);
+
+    Crawler crawler = new Crawler(client);
+    crawler.queue.add(new URL(args[1]));
+    crawler.parallelDrainQueue(threadCount);
+  }
+}
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index dc0633c751..1cc1b6a5ee 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
@@ -18,5 +18,9 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+    </dependency>
   </dependencies>
 </project>
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java b/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java
index b5427c5806..aa2f200e40 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java
+++ b/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java
@@ -1,43 +1,25 @@
 package com.squareup.okhttp.guide;
 
 import com.squareup.okhttp.OkHttpClient;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
 
 public class GetExample {
   OkHttpClient client = new OkHttpClient();
 
-  void run() throws IOException {
-    String result = get(new URL("https://raw.github.com/square/okhttp/master/README.md"));
-    System.out.println(result);
-  }
-
-  String get(URL url) throws IOException {
-    HttpURLConnection connection = client.open(url);
-    InputStream in = null;
-    try {
-      // Read the response.
-      in = connection.getInputStream();
-      byte[] response = readFully(in);
-      return new String(response, "UTF-8");
-    } finally {
-      if (in != null) in.close();
-    }
-  }
+  String run(String url) throws IOException {
+    Request request = new Request.Builder()
+        .url(url)
+        .build();
 
-  byte[] readFully(InputStream in) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    byte[] buffer = new byte[1024];
-    for (int count; (count = in.read(buffer)) != -1; ) {
-      out.write(buffer, 0, count);
-    }
-    return out.toByteArray();
+    Response response = client.newCall(request).execute();
+    return response.body().string();
   }
 
   public static void main(String[] args) throws IOException {
-    new GetExample().run();
+    GetExample example = new GetExample();
+    String response = example.run("https://raw.github.com/square/okhttp/master/README.md");
+    System.out.println(response);
   }
 }
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java b/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java
index 309ab70211..5de644c7d7 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java
+++ b/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java
@@ -1,51 +1,26 @@
 package com.squareup.okhttp.guide;
 
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
-import java.io.BufferedReader;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
 
 public class PostExample {
-  OkHttpClient client = new OkHttpClient();
-
-  void run() throws IOException {
-    byte[] body = bowlingJson("Jesse", "Jake").getBytes("UTF-8");
-    String result = post(new URL("http://www.roundsapp.com/post"), body);
-    System.out.println(result);
-  }
+  public static final MediaType JSON
+      = MediaType.parse("application/json; charset=utf-8");
 
-  String post(URL url, byte[] body) throws IOException {
-    HttpURLConnection connection = client.open(url);
-    OutputStream out = null;
-    InputStream in = null;
-    try {
-      // Write the request.
-      connection.setRequestMethod("POST");
-      out = connection.getOutputStream();
-      out.write(body);
-      out.close();
-
-      // Read the response.
-      if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {
-        throw new IOException("Unexpected HTTP response: "
-            + connection.getResponseCode() + " " + connection.getResponseMessage());
-      }
-      in = connection.getInputStream();
-      return readFirstLine(in);
-    } finally {
-      // Clean up.
-      if (out != null) out.close();
-      if (in != null) in.close();
-    }
-  }
+  OkHttpClient client = new OkHttpClient();
 
-  String readFirstLine(InputStream in) throws IOException {
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in, "UTF-8"));
-    return reader.readLine();
+  String post(String url, String json) throws IOException {
+    RequestBody body = RequestBody.create(JSON, json);
+    Request request = new Request.Builder()
+        .url(url)
+        .post(body)
+        .build();
+    Response response = client.newCall(request).execute();
+    return response.body().string();
   }
 
   String bowlingJson(String player1, String player2) {
@@ -61,6 +36,9 @@ String bowlingJson(String player1, String player2) {
   }
 
   public static void main(String[] args) throws IOException {
-    new PostExample().run();
+    PostExample example = new PostExample();
+    String json = example.bowlingJson("Jesse", "Jake");
+    String response = example.post("http://www.roundsapp.com/post", json);
+    System.out.println(response);
   }
 }
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/AccessHeaders.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/AccessHeaders.java
new file mode 100644
index 0000000000..9fe9d1ab67
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/AccessHeaders.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+
+public final class AccessHeaders {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://api.github.com/repos/square/okhttp/issues")
+        .header("User-Agent", "OkHttp Headers.java")
+        .addHeader("Accept", "application/json; q=0.5")
+        .addHeader("Accept", "application/vnd.github.v3+json")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println("Server: " + response.header("Server"));
+    System.out.println("Date: " + response.header("Date"));
+    System.out.println("Vary: " + response.headers("Vary"));
+  }
+
+  public static void main(String... args) throws Exception {
+    new AccessHeaders().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/AsynchronousGet.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/AsynchronousGet.java
new file mode 100644
index 0000000000..34cfc584ce
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/AsynchronousGet.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Callback;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+
+public final class AsynchronousGet {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build();
+
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        e.printStackTrace();
+      }
+
+      @Override public void onResponse(Response response) throws IOException {
+        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+        Headers responseHeaders = response.headers();
+        for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+          System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+        }
+
+        System.out.println(response.body().string());
+      }
+    });
+  }
+
+  public static void main(String... args) throws Exception {
+    new AsynchronousGet().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/Authenticate.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/Authenticate.java
new file mode 100644
index 0000000000..44581aed33
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/Authenticate.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Authenticator;
+import com.squareup.okhttp.Credentials;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.net.Proxy;
+
+public final class Authenticate {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    client.setAuthenticator(new Authenticator() {
+      @Override public Request authenticate(Proxy proxy, Response response) {
+        System.out.println("Authenticating for response: " + response);
+        System.out.println("Challenges: " + response.challenges());
+        String credential = Credentials.basic("jesse", "password1");
+        return response.request().newBuilder()
+            .header("Authorization", credential)
+            .build();
+      }
+
+      @Override public Request authenticateProxy(Proxy proxy, Response response) {
+        return null; // Null indicates no attempt to authenticate.
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/secrets/hellosecret.txt")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new Authenticate().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java
new file mode 100644
index 0000000000..3335ebe668
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Cache;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.File;
+import java.io.IOException;
+
+public final class CacheResponse {
+  private final OkHttpClient client;
+
+  public CacheResponse(File cacheDirectory) throws Exception {
+    int cacheSize = 10 * 1024 * 1024; // 10 MiB
+    Cache cache = new Cache(cacheDirectory, cacheSize);
+
+    client = new OkHttpClient();
+    client.setCache(cache);
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build();
+
+    Response response1 = client.newCall(request).execute();
+    if (!response1.isSuccessful()) throw new IOException("Unexpected code " + response1);
+
+    String response1Body = response1.body().string();
+    System.out.println("Response 1 response:          " + response1);
+    System.out.println("Response 1 cache response:    " + response1.cacheResponse());
+    System.out.println("Response 1 network response:  " + response1.networkResponse());
+
+    Response response2 = client.newCall(request).execute();
+    if (!response2.isSuccessful()) throw new IOException("Unexpected code " + response2);
+
+    String response2Body = response2.body().string();
+    System.out.println("Response 2 response:          " + response2);
+    System.out.println("Response 2 cache response:    " + response2.cacheResponse());
+    System.out.println("Response 2 network response:  " + response2.networkResponse());
+
+    System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
+  }
+
+  public static void main(String... args) throws Exception {
+    new CacheResponse(new File("CacheResponse.tmp")).run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CancelCall.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CancelCall.java
new file mode 100644
index 0000000000..9f8d37305c
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CancelCall.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Call;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+
+public class CancelCall {
+  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build();
+
+    final long startNanos = System.nanoTime();
+    final Call call = client.newCall(request);
+
+    // Schedule a job to cancel the call in 1 second.
+    executor.schedule(new Runnable() {
+      @Override public void run() {
+        System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f);
+        call.cancel();
+        System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f);
+      }
+    }, 1, TimeUnit.SECONDS);
+
+    try {
+      System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f);
+      Response response = call.execute();
+      System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
+          (System.nanoTime() - startNanos) / 1e9f, response);
+    } catch (IOException e) {
+      System.out.printf("%.2f Call failed as expected: %s%n",
+          (System.nanoTime() - startNanos) / 1e9f, e);
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CancelCall().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CertificatePinning.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CertificatePinning.java
new file mode 100644
index 0000000000..b643d52d03
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CertificatePinning.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.CertificatePinner;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.security.cert.Certificate;
+
+public final class CertificatePinning {
+  private final OkHttpClient client;
+
+  public CertificatePinning() {
+    client = new OkHttpClient();
+    client.setCertificatePinner(
+        new CertificatePinner.Builder()
+            .add("publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+            .add("publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
+            .add("publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
+            .add("publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+            .build());
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/robots.txt")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    for (Certificate certificate : response.handshake().peerCertificates()) {
+      System.out.println(CertificatePinner.pin(certificate));
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CertificatePinning().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CheckHandshake.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CheckHandshake.java
new file mode 100644
index 0000000000..0a2e86e7d2
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CheckHandshake.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.CertificatePinner;
+import com.squareup.okhttp.Interceptor;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.security.cert.Certificate;
+import java.util.Collections;
+import java.util.Set;
+
+public final class CheckHandshake {
+  /** Rejects otherwise-trusted certificates. */
+  private static final Interceptor CHECK_HANDSHAKE_INTERCEPTOR = new Interceptor() {
+    Set<String> blacklist = Collections.singleton("sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
+
+    @Override public Response intercept(Chain chain) throws IOException {
+      for (Certificate certificate : chain.connection().getHandshake().peerCertificates()) {
+        String pin = CertificatePinner.pin(certificate);
+        if (blacklist.contains(pin)) {
+          throw new IOException("Blacklisted peer certificate: " + pin);
+        }
+      }
+      return chain.proceed(chain.request());
+    }
+  };
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public CheckHandshake() {
+    client.networkInterceptors().add(CHECK_HANDSHAKE_INTERCEPTOR);
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new CheckHandshake().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/ConfigureTimeouts.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/ConfigureTimeouts.java
new file mode 100644
index 0000000000..f358a4564f
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/ConfigureTimeouts.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.util.concurrent.TimeUnit;
+
+public final class ConfigureTimeouts {
+  private final OkHttpClient client;
+
+  public ConfigureTimeouts() throws Exception {
+    client = new OkHttpClient();
+    client.setConnectTimeout(10, TimeUnit.SECONDS);
+    client.setWriteTimeout(10, TimeUnit.SECONDS);
+    client.setReadTimeout(30, TimeUnit.SECONDS);
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build();
+
+    Response response = client.newCall(request).execute();
+    System.out.println("Response completed: " + response);
+  }
+
+  public static void main(String... args) throws Exception {
+    new ConfigureTimeouts().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/LoggingInterceptors.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/LoggingInterceptors.java
new file mode 100644
index 0000000000..d70f1070a2
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/LoggingInterceptors.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Interceptor;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.util.logging.Logger;
+
+public final class LoggingInterceptors {
+  private static final Logger logger = Logger.getLogger(LoggingInterceptors.class.getName());
+  private final OkHttpClient client = new OkHttpClient();
+
+  public LoggingInterceptors() {
+    client.networkInterceptors().add(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        long t1 = System.nanoTime();
+        Request request = chain.request();
+        logger.info(String.format("Sending request %s on %s%n%s",
+            request.url(), chain.connection(), request.headers()));
+        Response response = chain.proceed(request);
+
+        long t2 = System.nanoTime();
+        logger.info(String.format("Received response for %s in %.1fms%n%s",
+            request.url(), (t2 - t1) / 1e6d, response.headers()));
+        return response;
+      }
+    });
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    response.body().close();
+  }
+
+  public static void main(String... args) throws Exception {
+    new LoggingInterceptors().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/ParseResponseWithGson.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/ParseResponseWithGson.java
new file mode 100644
index 0000000000..cf63f0d4b1
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/ParseResponseWithGson.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.google.gson.Gson;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.util.Map;
+
+public final class ParseResponseWithGson {
+  private final OkHttpClient client = new OkHttpClient();
+  private final Gson gson = new Gson();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://api.github.com/gists/c2a7c39532239ff261be")
+        .build();
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    Gist gist = gson.fromJson(response.body().charStream(), Gist.class);
+    for (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {
+      System.out.println(entry.getKey());
+      System.out.println(entry.getValue().content);
+    }
+  }
+
+  static class Gist {
+    Map<String, GistFile> files;
+  }
+
+  static class GistFile {
+    String content;
+  }
+
+  public static void main(String... args) throws Exception {
+    new ParseResponseWithGson().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PerCallSettings.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PerCallSettings.java
new file mode 100644
index 0000000000..af4956e17f
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PerCallSettings.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+public final class PerCallSettings {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
+        .build();
+
+    try {
+      OkHttpClient cloned = client.clone(); // Clone to make a customized OkHttp for this request.
+      cloned.setReadTimeout(500, TimeUnit.MILLISECONDS);
+
+      Response response = cloned.newCall(request).execute();
+      System.out.println("Response 1 succeeded: " + response);
+    } catch (IOException e) {
+      System.out.println("Response 1 failed: " + e);
+    }
+
+    try {
+      OkHttpClient cloned = client.clone(); // Clone to make a customized OkHttp for this request.
+      cloned.setReadTimeout(3000, TimeUnit.MILLISECONDS);
+
+      Response response = cloned.newCall(request).execute();
+      System.out.println("Response 2 succeeded: " + response);
+    } catch (IOException e) {
+      System.out.println("Response 2 failed: " + e);
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PerCallSettings().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostFile.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostFile.java
new file mode 100644
index 0000000000..a0d98df45f
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostFile.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import java.io.File;
+import java.io.IOException;
+
+public final class PostFile {
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    File file = new File("README.md");
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostFile().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java
new file mode 100644
index 0000000000..30054f1905
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.FormEncodingBuilder;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+
+public final class PostForm {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    RequestBody formBody = new FormEncodingBuilder()
+        .add("search", "Jurassic Park")
+        .build();
+    Request request = new Request.Builder()
+        .url("https://en.wikipedia.org/w/index.php")
+        .post(formBody)
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostForm().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostMultipart.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostMultipart.java
new file mode 100644
index 0000000000..8e5334aa39
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostMultipart.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.MultipartBuilder;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import java.io.File;
+import java.io.IOException;
+
+public final class PostMultipart {
+  /**
+   * The imgur client ID for OkHttp recipes. If you're using imgur for anything
+   * other than running these examples, please request your own client ID!
+   *   https://api.imgur.com/oauth2
+   */
+  private static final String IMGUR_CLIENT_ID = "9199fdef135c122";
+  private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
+    RequestBody requestBody = new MultipartBuilder()
+        .type(MultipartBuilder.FORM)
+        .addFormDataPart("title", "Square Logo")
+        .addFormDataPart("image", null,
+            RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png")))
+        .build();
+
+    Request request = new Request.Builder()
+        .header("Authorization", "Client-ID " + IMGUR_CLIENT_ID)
+        .url("https://api.imgur.com/3/image")
+        .post(requestBody)
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostMultipart().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostStreaming.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostStreaming.java
new file mode 100644
index 0000000000..500344c7e9
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostStreaming.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import okio.BufferedSink;
+
+public final class PostStreaming {
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MEDIA_TYPE_MARKDOWN;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Numbers\n");
+        sink.writeUtf8("-------\n");
+        for (int i = 2; i <= 997; i++) {
+          sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i)));
+        }
+      }
+
+      private String factor(int n) {
+        for (int i = 2; i < n; i++) {
+          int x = n / i;
+          if (x * i == n) return factor(x) + " × " + i;
+        }
+        return Integer.toString(n);
+      }
+    };
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(requestBody)
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostStreaming().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostString.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostString.java
new file mode 100644
index 0000000000..943636abb5
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostString.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+
+public final class PostString {
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    String postBody = ""
+        + "Releases\n"
+        + "--------\n"
+        + "\n"
+        + " * _1.0_ May 6, 2013\n"
+        + " * _1.1_ June 15, 2013\n"
+        + " * _1.2_ August 11, 2013\n";
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostString().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/RequestBodyCompression.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/RequestBodyCompression.java
new file mode 100644
index 0000000000..c4805bdeb3
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/RequestBodyCompression.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.google.gson.Gson;
+import com.squareup.okhttp.Interceptor;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import okio.BufferedSink;
+import okio.GzipSink;
+import okio.Okio;
+
+public final class RequestBodyCompression {
+  /**
+   * The Google API KEY for OkHttp recipes. If you're using Google APIs for anything other than
+   * running these examples, please request your own client ID!
+   *   https://console.developers.google.com/project
+   */
+  public static final String GOOGLE_API_KEY = "AIzaSyAx2WZYe0My0i-uGurpvraYJxO7XNbwiGs";
+  public static final MediaType MEDIA_TYPE_JSON = MediaType.parse("application/json");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public RequestBodyCompression() {
+    client.interceptors().add(new GzipRequestInterceptor());
+  }
+
+  public void run() throws Exception {
+    Map<String, String> requestBody = new LinkedHashMap<>();
+    requestBody.put("longUrl", "https://publicobject.com/2014/12/04/html-formatting-javadocs/");
+    RequestBody jsonRequestBody = RequestBody.create(
+        MEDIA_TYPE_JSON, new Gson().toJson(requestBody));
+    Request request = new Request.Builder()
+        .url("https://www.googleapis.com/urlshortener/v1/url?key=" + GOOGLE_API_KEY)
+        .post(jsonRequestBody)
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new RequestBodyCompression().run();
+  }
+
+  /** This interceptor compresses the HTTP request body. Many webservers can't handle this! */
+  static class GzipRequestInterceptor implements Interceptor {
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request originalRequest = chain.request();
+      if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
+        return chain.proceed(originalRequest);
+      }
+
+      Request compressedRequest = originalRequest.newBuilder()
+          .header("Content-Encoding", "gzip")
+          .method(originalRequest.method(), gzip(originalRequest.body()))
+          .build();
+      return chain.proceed(compressedRequest);
+    }
+
+    private RequestBody gzip(final RequestBody body) {
+      return new RequestBody() {
+        @Override public MediaType contentType() {
+          return body.contentType();
+        }
+
+        @Override public long contentLength() {
+          return -1; // We don't know the compressed length in advance!
+        }
+
+        @Override public void writeTo(BufferedSink sink) throws IOException {
+          BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
+          body.writeTo(gzipSink);
+          gzipSink.close();
+        }
+      };
+    }
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/RewriteResponseCacheControl.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/RewriteResponseCacheControl.java
new file mode 100644
index 0000000000..63f819e5e5
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/RewriteResponseCacheControl.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Cache;
+import com.squareup.okhttp.Interceptor;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.File;
+import java.io.IOException;
+
+public final class RewriteResponseCacheControl {
+  /** Dangerous interceptor that rewrites the server's cache-control header. */
+  private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() {
+    @Override public Response intercept(Chain chain) throws IOException {
+      Response originalResponse = chain.proceed(chain.request());
+      return originalResponse.newBuilder()
+          .header("Cache-Control", "max-age=60")
+          .build();
+    }
+  };
+
+  private final OkHttpClient client;
+
+  public RewriteResponseCacheControl(File cacheDirectory) throws Exception {
+    Cache cache = new Cache(cacheDirectory, 1024 * 1024);
+    cache.evictAll();
+
+    client = new OkHttpClient();
+    client.setCache(cache);
+  }
+
+  public void run() throws Exception {
+    for (int i = 0; i < 5; i++) {
+      System.out.println("    Request: " + i);
+
+      Request request = new Request.Builder()
+          .url("https://api.github.com/search/repositories?q=http")
+          .build();
+
+      if (i == 2) {
+        // Force this request's response to be written to the cache. This way, subsequent responses
+        // can be read from the cache.
+        System.out.println("Force cache: true");
+        client.networkInterceptors().add(REWRITE_CACHE_CONTROL_INTERCEPTOR);
+      } else {
+        System.out.println("Force cache: false");
+        client.networkInterceptors().clear();
+      }
+
+      Response response = client.newCall(request).execute();
+      response.body().close();
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println("    Network: " + (response.networkResponse() != null));
+      System.out.println();
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new RewriteResponseCacheControl(new File("RewriteResponseCacheControl.tmp")).run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/SynchronousGet.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/SynchronousGet.java
new file mode 100644
index 0000000000..6b4cecbe13
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/SynchronousGet.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+
+public final class SynchronousGet {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    Headers responseHeaders = response.headers();
+    for (int i = 0; i < responseHeaders.size(); i++) {
+      System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+    }
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new SynchronousGet().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java
new file mode 100644
index 0000000000..738191a9be
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/WebSocketEcho.java
@@ -0,0 +1,70 @@
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.ws.WebSocket;
+import com.squareup.okhttp.internal.ws.WebSocketCall;
+import com.squareup.okhttp.internal.ws.WebSocketListener;
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+
+import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType;
+import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.BINARY;
+import static com.squareup.okhttp.internal.ws.WebSocket.PayloadType.TEXT;
+
+/**
+ * WARNING: This recipe is for an API that is not final and subject to change at any time!
+ */
+public final class WebSocketEcho implements WebSocketListener {
+  private void run() throws IOException {
+    OkHttpClient client = new OkHttpClient();
+
+    Request request = new Request.Builder()
+        .url("ws://echo.websocket.org")
+        .build();
+    WebSocketCall.newWebSocketCall(client, request).enqueue(this);
+
+    // Trigger shutdown of the dispatcher's executor so this process can exit cleanly.
+    client.getDispatcher().getExecutorService().shutdown();
+  }
+
+  @Override public void onOpen(WebSocket webSocket, Request request, Response response)
+      throws IOException {
+    webSocket.sendMessage(TEXT, new Buffer().writeUtf8("Hello..."));
+    webSocket.sendMessage(TEXT, new Buffer().writeUtf8("...World!"));
+    webSocket.sendMessage(BINARY, new Buffer().writeInt(0xdeadbeef));
+    webSocket.close(1000, "Goodbye, World!");
+  }
+
+  @Override public void onMessage(BufferedSource payload, PayloadType type) throws IOException {
+    switch (type) {
+      case TEXT:
+        System.out.println(payload.readUtf8());
+        break;
+      case BINARY:
+        System.out.println(payload.readByteString().hex());
+        break;
+      default:
+        throw new IllegalStateException("Unknown payload type: " + type);
+    }
+    payload.close();
+  }
+
+  @Override public void onPong(Buffer payload) {
+    System.out.println("PONG: " + payload.readUtf8());
+  }
+
+  @Override public void onClose(int code, String reason) {
+    System.out.println("CLOSE: " + code + " " + reason);
+  }
+
+  @Override public void onFailure(IOException e) {
+    e.printStackTrace();
+  }
+
+  public static void main(String... args) throws IOException {
+    new WebSocketEcho().run();
+  }
+}
diff --git a/samples/pom.xml b/samples/pom.xml
index 2462fd09d7..6991fa9165 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp.sample</groupId>
@@ -16,6 +16,7 @@
 
   <modules>
     <module>guide</module>
+    <module>crawler</module>
     <module>simple-client</module>
     <module>static-server</module>
   </modules>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index 990152b227..3ebf058230 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
index 8969f47236..e616d41d51 100644
--- a/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
+++ b/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
@@ -3,10 +3,9 @@
 import com.google.gson.Gson;
 import com.google.gson.reflect.TypeToken;
 import com.squareup.okhttp.OkHttpClient;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.net.HttpURLConnection;
-import java.net.URL;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.Reader;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
@@ -18,7 +17,7 @@
       new TypeToken<List<Contributor>>() {
       };
 
-  class Contributor {
+  static class Contributor {
     String login;
     int contributions;
   }
@@ -27,12 +26,16 @@ public static void main(String... args) throws Exception {
     OkHttpClient client = new OkHttpClient();
 
     // Create request for remote resource.
-    HttpURLConnection connection = client.open(new URL(ENDPOINT));
-    InputStream is = connection.getInputStream();
-    InputStreamReader isr = new InputStreamReader(is);
+    Request request = new Request.Builder()
+        .url(ENDPOINT)
+        .build();
+
+    // Execute the request and retrieve the response.
+    Response response = client.newCall(request).execute();
 
     // Deserialize HTTP response to concrete type.
-    List<Contributor> contributors = GSON.fromJson(isr, CONTRIBUTORS.getType());
+    Reader body = response.body().charStream();
+    List<Contributor> contributors = GSON.fromJson(body, CONTRIBUTORS.getType());
 
     // Sort list by the most contributions.
     Collections.sort(contributors, new Comparator<Contributor>() {
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index f98e5b5b78..e3dc358364 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
diff --git a/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java b/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
index 274bf9dd48..c7a479ec18 100644
--- a/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
+++ b/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
@@ -9,12 +9,15 @@
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.io.InputStream;
 import java.security.GeneralSecurityException;
 import java.security.KeyStore;
 import java.security.SecureRandom;
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManagerFactory;
+import okio.Buffer;
+import okio.Okio;
 
 public class SampleServer extends Dispatcher {
   private final SSLContext sslContext;
@@ -81,9 +84,9 @@ private MockResponse fileToResponse(String path, File file) throws IOException {
         .addHeader("content-type: " + contentType(path));
   }
 
-  private byte[] fileToBytes(File file) throws IOException {
-    byte[] result = new byte[(int) file.length()];
-    Util.readFully(new FileInputStream(file), result);
+  private Buffer fileToBytes(File file) throws IOException {
+    Buffer result = new Buffer();
+    result.writeAll(Okio.source(file));
     return result;
   }
 
@@ -116,8 +119,12 @@ public static void main(String[] args) throws Exception {
   private static SSLContext sslContext(String keystoreFile, String password)
       throws GeneralSecurityException, IOException {
     KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
-    keystore.load(new FileInputStream(keystoreFile), password.toCharArray());
-
+    InputStream in = new FileInputStream(keystoreFile);
+    try {
+      keystore.load(in, password.toCharArray());
+    } finally {
+      Util.closeQuietly(in);
+    }
     KeyManagerFactory keyManagerFactory =
         KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
     keyManagerFactory.init(keystore, password.toCharArray());
diff --git a/website/index.html b/website/index.html
index e6821d69b6..57c412f767 100644
--- a/website/index.html
+++ b/website/index.html
@@ -43,12 +43,12 @@ <h2>An <strong>HTTP &amp; SPDY</strong> client for Android and Java applications
         <div class="row">
           <div class="span9">
             <h3 id="overview">Overview</h3>
-            <p>HTTP is the way modern applications network. It’s how we exchange data & media.
+            <p>HTTP is the way modern applications network. It’s how we exchange data &amp; media.
                 Doing HTTP efficiently makes your stuff load faster and saves bandwidth.</p>
 
             <p>OkHttp is an HTTP client that’s efficient by default:</p>
             <ul>
-                <li>SPDY support allows all requests to the same host to share a socket.</li>
+                <li>HTTP/2 and SPDY support allows all requests to the same host to share a socket.</li>
                 <li>Connection pooling reduces request latency (if SPDY isn’t available).</li>
                 <li>Transparent GZIP shrinks download sizes.</li>
                 <li>Response caching avoids the network completely for repeat requests.</li>
@@ -57,78 +57,62 @@ <h3 id="overview">Overview</h3>
             <p>OkHttp perseveres when the network is troublesome: it will silently recover from
                 common connection problems. If your service has multiple IP addresses OkHttp will
                 attempt alternate addresses if the first connect fails. This is necessary for IPv4+IPv6
-                and for services hosted in redundant data centers. OkHttp also recovers from problematic
-                proxy servers and failed SSL handshakes.</p>
+                and for services hosted in redundant data centers. OkHttp initiates new connections
+                with modern TLS features (SNI, ALPN), and falls back to TLS 1.0 if the handshake
+                fails.</p>
 
-            <p>You can try OkHttp without rewriting your network code. The core module implements
-                the familiar <code>java.net.HttpURLConnection</code> API. And the optional
-                okhttp-apache module implements the Apache <code>HttpClient</code> API.</p>
+            <p>Using OkHttp is easy. Its 2.0 API is designed with fluent builders and
+                immutability. It supports both synchronous blocking calls and async calls with
+                callbacks.</p>
 
-            <p>OkHttp supports Android 2.2 and above. For Java, the minimum requirement is 1.5.</p>
+            <p>You can try out OkHttp without rewriting your network code. The
+                <code>okhttp-urlconnection</code> module implements the familiar
+                <code>java.net.HttpURLConnection</code> API and the <code>okhttp-apache</code>
+                module implements the Apache <code>HttpClient</code> API.</p>
+
+            <p>OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.</p>
 
             <h3 id="examples">Examples</h3>
             <h4>Get a URL</h4>
             <p>This program downloads a URL and print its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java">Full source</a>.
 <pre class="prettyprint">
-    OkHttpClient client = new OkHttpClient();
-
-    String get(URL url) throws IOException {
-      HttpURLConnection connection = client.open(url);
-      InputStream in = null;
-      try {
-        // Read the response.
-        in = connection.getInputStream();
-        byte[] response = readFully(in);
-        return new String(response, "UTF-8");
-      } finally {
-        if (in != null) in.close();
-      }
-    }
+OkHttpClient client = new OkHttpClient();
+
+String run(String url) throws IOException {
+  Request request = new Request.Builder()
+      .url(url)
+      .build();
+
+  Response response = client.newCall(request).execute();
+  return response.body().string();
+}
 </pre>
             <h4>Post to a Server</h4>
             <p>This program posts data to a service. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java">Full source</a>.
 
 <pre class="prettyprint">
-    OkHttpClient client = new OkHttpClient();
-
-    String post(URL url, byte[] body) throws IOException {
-      HttpURLConnection connection = client.open(url);
-      OutputStream out = null;
-      InputStream in = null;
-      try {
-        // Write the request.
-        connection.setRequestMethod("POST");
-        out = connection.getOutputStream();
-        out.write(body);
-        out.close();
-
-        // Read the response.
-        if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {
-          throw new IOException("Unexpected HTTP response: "
-              + connection.getResponseCode() + " " + connection.getResponseMessage());
-        }
-        in = connection.getInputStream();
-        return readFirstLine(in);
-      } finally {
-        // Clean up.
-        if (out != null) out.close();
-        if (in != null) in.close();
-      }
-    }
+public static final MediaType JSON
+    = MediaType.parse("application/json; charset=utf-8");
+
+OkHttpClient client = new OkHttpClient();
+
+String post(String url, String json) throws IOException {
+  RequestBody body = RequestBody.create(JSON, json);
+  Request request = new Request.Builder()
+      .url(url)
+      .post(body)
+      .build();
+  Response response = client.newCall(request).execute();
+  return response.body().string();
+}
 </pre>
 
-                <!--
-                TODO
-                Error Handling
-                Authentication
-                Cookies
-                Response Caching
-                Captive Gateways
-                -->
-
             <h3 id="download">Download</h3>
-            <p><a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=okhttp&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
-            <p>The source code to the OkHttp, its samples, and this website is <a href="http://github.com/square/okhttp">available on GitHub</a>.</p>
+            <p><a href="https://search.maven.org/remote_content?g=com.squareup.okhttp&a=okhttp&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
+            <p>You'll also need <a href="http://github.com/square/okio">Okio</a>, which OkHttp
+                uses for fast I/O and resizable buffers. Download the
+                <a href="https://search.maven.org/remote_content?g=com.squareup.okio&a=okio&v=LATEST">latest JAR</a>.
+            <p>The source code to OkHttp, its samples, and this website is <a href="http://github.com/square/okhttp">available on GitHub</a>.</p>
 
             <h4>Maven</h4>
             <pre class="prettyprint">&lt;dependency>
@@ -143,7 +127,7 @@ <h3 id="contributing">Contributing</h3>
             <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
 
             <h3 id="license">License</h3>
-            <pre>Copyright 2013 Square, Inc.
+            <pre>Copyright 2014 Square, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -167,8 +151,9 @@ <h3 id="license">License</h3>
                 <li><a href="#license">License</a></li>
               </ul>
               <ul class="nav nav-pills nav-stacked secondary">
+                <li><a href="https://github.com/square/okhttp/wiki">Wiki</a></li>
                 <li><a href="javadoc/index.html">Javadoc</a></li>
-                <li><a href="https://plus.google.com/communities/109244258569782858265/stream/b6d99838-775f-45a6-a259-af04d42d8639">Google+ Community</a></li>
+                <li><a href="http://stackoverflow.com/questions/tagged/okhttp?sort=active">StackOverflow</a></li>
               </ul>
             </div>
           </div>
@@ -208,7 +193,10 @@ <h3 id="license">License</h3>
         });
 
         // Look up the latest version of the library.
-        $.fn.artifactVersion('com.squareup.okhttp', 'okhttp', function(version, url) {
+        $.fn.artifactVersion({
+          'groupId': 'com.squareup.okhttp',
+          'artifactId': 'okhttp'
+        }, function(version, url) {
           $('.version').text(version);
           $('.version-tag').text('v' + version);
           $('.version-href').attr('href', url);
diff --git a/website/static/jquery-maven-artifact.min.js b/website/static/jquery-maven-artifact.min.js
index 08a0304fe7..4b78fe23ac 100644
--- a/website/static/jquery-maven-artifact.min.js
+++ b/website/static/jquery-maven-artifact.min.js
@@ -1,8 +1,7 @@
 /**
  * jQuery Maven Artifact Plugin
  *
- * Version: 1.0.1
+ * Version: 2.0.0
  * Author: Jake Wharton
  * License: Apache 2.0
- */
-(function($){function downloadUrl(groupId,artifactId,version,type){var groupPath=groupId.replace(/\./g,"/");return"http://repo1.maven.org/maven2/"+groupPath+"/"+artifactId+"/"+version+"/"+artifactId+"-"+version+type}$.fn.artifactVersion=function(groupId,artifactId,callback){if(typeof groupId!=="string"||typeof artifactId!=="string"){console.log("Error: groupId and artifactId are required.");return}if(typeof callback==="undefined"){console.log("Error: callback function required.");return}var url='http://search.maven.org/solrsearch/select/?q=g:"'+groupId+'"+AND+a:"'+artifactId+'"&wt=json&json.wrf=?';$.getJSON(url,function(response){var versions=response.response.docs;if(versions.length==0){return}var version=versions[0].latestVersion;var versionUrl=downloadUrl(groupId,artifactId,version,".jar");callback(version,versionUrl)})};$.fn.artifactVersions=function(groupId,artifactId,callback){if(typeof groupId!=="string"||typeof artifactId!=="string"){console.log("Error: groupId and artifactId are required.");return}if(typeof callback==="undefined"){console.log("Error: callback function required.");return}var url='http://search.maven.org/solrsearch/select/?q=g:"'+groupId+'"+AND+a:"'+artifactId+'"&wt=json&rows=10&core=gav&json.wrf=?';$.getJSON(url,function(response){var versions=response.response.docs;if(versions.length==0){return}versions.sort(function(o1,o2){return o1.v>o2.v?-1:1});var newVersions=[];for(var i=0;i<versions.length;i++){var version=versions[i].v;newVersions.push({name:version,url:downloadUrl(groupId,artifactId,version,".jar")})}callback(newVersions)})}})(jQuery);
\ No newline at end of file
+ */(function(e){function n(e,t){var n=e.groupId.replace(/\./g,"/"),r="http://repo1.maven.org/maven2/"+n+"/"+e.artifactId+"/"+t+"/"+e.artifactId+"-"+t;return typeof e.classifier!="undefined"&&(r+="-"+e.classifier),r+="."+e.packaging,r}function r(e){var t={groupId:"g",artifactId:"a",packaging:"p",classifier:"l"},n="";for(var r in t)t.hasOwnProperty(r)&&e.hasOwnProperty(r)&&(n!==""&&(n+="+AND+"),n+=t[r]+':"'+e[r]+'"');return n}var t={packaging:"jar"};e.fn.artifactVersion=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="http://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;var r=t[0].latestVersion||t[0].v,o=n(i,r);s(r,o)})},e.fn.artifactVersions=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="http://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&rows=10&core=gav&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;t.sort(function(e,t){return e.v>t.v?-1:1});var r=[];for(var o=0;o<t.length;o++){var u=t[o].v;r.push({name:u,url:n(i,u)})}s(r)})}})(jQuery);
\ No newline at end of file
