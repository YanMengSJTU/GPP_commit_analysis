diff --git a/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt b/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt
index 69229bf3fa..cdc41ab2e3 100644
--- a/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt
+++ b/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt
@@ -222,7 +222,7 @@ class OkHttpTest {
       moshi.adapter(HowsMySslResults::class.java).fromJson(response.body!!.string())!!
     }
 
-    Platform.get().log(Platform.WARN, "results $results", null)
+    Platform.get().log("results $results", Platform.WARN)
 
     assertTrue(results.session_ticket_supported)
     assertEquals("Probably Okay", results.rating)
diff --git a/build.gradle b/build.gradle
index 80227a3154..02466bc312 100644
--- a/build.gradle
+++ b/build.gradle
@@ -37,6 +37,7 @@ buildscript {
       'junit': "junit:junit:${versions.junit}",
       'kotlinStdlib': "org.jetbrains.kotlin:kotlin-stdlib:${versions.kotlin}",
       'moshi': "com.squareup.moshi:moshi:${versions.moshi}",
+      'moshiKotlin': "com.squareup.moshi:moshi-kotlin-codegen:${versions.moshi}",
       'okio': "com.squareup.okio:okio:${versions.okio}",
       'openjsse': "org.openjsse:openjsse:${versions.openjsse}"
   ]
diff --git a/deploy_website.sh b/deploy_website.sh
index 202321d658..3f5d077f2c 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -30,6 +30,26 @@ cd $DIR
   :okhttp-urlconnection:dokka \
   :okhttp:dokka
 
+# Dokka filenames like `-http-url/index.md` don't work well with MkDocs <title> tags.
+# Assign metadata to the file's first Markdown heading.
+# https://www.mkdocs.org/user-guide/writing-your-docs/#meta-data
+title_markdown_file() {
+  TITLE_PATTERN="s/^[#]+ *(.*)/title: \1 - OkHttp/"
+  echo "---"                                                     > "$1.fixed"
+  cat $1 | sed -E "$TITLE_PATTERN" | grep "title: " | head -n 1 >> "$1.fixed"
+  echo "---"                                                    >> "$1.fixed"
+  echo                                                          >> "$1.fixed"
+  cat $1                                                        >> "$1.fixed"
+  mv "$1.fixed" "$1"
+}
+
+set +x
+for MARKDOWN_FILE in $(find docs/4.x/ -name '*.md'); do
+  echo $MARKDOWN_FILE
+  title_markdown_file $MARKDOWN_FILE
+done
+set -x
+
 # Copy in special files that GitHub wants in the project root.
 cat README.md | grep -v 'project website' > docs/index.md
 cp CHANGELOG.md docs/changelog.md
diff --git a/docs/changelog_3x.md b/docs/changelog_3x.md
index 96602564af..a54dc7d4f7 100644
--- a/docs/changelog_3x.md
+++ b/docs/changelog_3x.md
@@ -1,6 +1,19 @@
 OkHttp 3.x Change Log
 =====================
 
+## Version 3.14.4
+
+_2019-09-29_
+
+ *  Fix: Cancel calls that fail due to unexpected exceptions. We had a bug where an enqueued call
+    would never call back if it crashed with an unchecked throwable, such as a
+    `NullPointerException` or `OutOfMemoryError`. We now call `Callback.onFailure()` with an
+    `IOException` that reports the call as canceled. The triggering exception is still delivered to
+    the thread's `UncaughtExceptionHandler`.
+ *  Fix: Don't evict incomplete entries when iterating the cache. We had a bug where iterating
+    `Cache.urls()` would prevent in-flight entries from being written.
+
+
 ## Version 3.14.3
 
 _2019-09-10_
@@ -163,6 +176,19 @@ _2019-02-04_
  *  New: Log the TLS handshake in `LoggingEventListener`.
 
 
+## Version 3.12.6
+
+_2019-09-29_
+
+ *  Fix: Cancel calls that fail due to unexpected exceptions. We had a bug where an enqueued call
+    would never call back if it crashed with an unchecked throwable, such as a
+    `NullPointerException` or `OutOfMemoryError`. We now call `Callback.onFailure()` with an
+    `IOException` that reports the call as canceled. The triggering exception is still delivered to
+    the thread's `UncaughtExceptionHandler`.
+ *  Fix: Don't evict incomplete entries when iterating the cache. We had a bug where iterating
+    `Cache.urls()` would prevent in-flight entries from being written.
+
+
 ## Version 3.12.5
 
 _2019-09-10_
diff --git a/docs/connections.md b/docs/connections.md
index 5c2f525883..37bba50de4 100644
--- a/docs/connections.md
+++ b/docs/connections.md
@@ -3,7 +3,7 @@ Connections
 
 Although you provide only the URL, OkHttp plans its connection to your webserver using three types: URL, Address, and Route.
 
-#### [URLs](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-http-url/)
+### [URLs](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-http-url/)
 
 URLs (like `https://github.com/square/okhttp`) are fundamental to HTTP and the Internet. In addition to being a universal, decentralized naming scheme for everything on the web, they also specify how to access web resources.
 
@@ -14,7 +14,7 @@ URLs are abstract:
 
 They're also concrete: each URL identifies a specific path (like `/square/okhttp`) and query (like `?q=sharks&lang=en`). Each webserver hosts many URLs.
 
-#### [Addresses](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-address/)
+### [Addresses](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-address/)
 
 Addresses specify a webserver (like `github.com`) and all of the **static** configuration necessary to connect to that server: the port number, HTTPS settings, and preferred network protocols (like HTTP/2 or SPDY).
 
@@ -22,13 +22,13 @@ URLs that share the same address may also share the same underlying TCP socket c
 
 In OkHttp some fields of the address come from the URL (scheme, hostname, port) and the rest come from the [OkHttpClient](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-ok-http-client/).
 
-#### [Routes](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-route/)
+### [Routes](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-route/)
 
 Routes supply the **dynamic** information necessary to actually connect to a webserver. This is the specific IP address to attempt (as discovered by a DNS query), the exact proxy server to use (if a [ProxySelector](http://developer.android.com/reference/java/net/ProxySelector.html) is in use), and which version of TLS to negotiate (for HTTPS connections).
 
 There may be many routes for a single address. For example, a webserver that is hosted in multiple datacenters may yield multiple IP addresses in its DNS response.
 
-#### [Connections](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-connection/)
+### [Connections](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-connection/)
 
 When you request a URL with OkHttp, here's what it does:
 
diff --git a/docs/https.md b/docs/https.md
index 142b7c3d9c..a4c8a0301b 100644
--- a/docs/https.md
+++ b/docs/https.md
@@ -43,46 +43,123 @@ OkHttpClient client = new OkHttpClient.Builder()
     .build();
 ```
 
-#### [Certificate Pinning](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java)
+### Certificate Pinning ([.kt][CertificatePinningKotlin], [.java][CertificatePinningJava]) 
 
 By default, OkHttp trusts the certificate authorities of the host platform. This strategy maximizes connectivity, but it is subject to certificate authority attacks such as the [2011 DigiNotar attack](http://www.computerworld.com/article/2510951/cybercrime-hacking/hackers-spied-on-300-000-iranians-using-fake-google-certificate.html). It also assumes your HTTPS servers’ certificates are signed by a certificate authority.
 
 Use [CertificatePinner](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-certificate-pinner/) to restrict which certificates and certificate authorities are trusted. Certificate pinning increases security, but limits your server team’s abilities to update their TLS certificates. **Do not use certificate pinning without the blessing of your server’s TLS administrator!**
 
-```java
-  public CertificatePinning() {
-    client = new OkHttpClient.Builder()
-        .certificatePinner(new CertificatePinner.Builder()
-            .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
-            .build())
-        .build();
+```Kotlin tab=
+  private val client = OkHttpClient.Builder()
+      .certificatePinner(
+          CertificatePinner.Builder()
+              .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+              .build())
+      .build()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://publicobject.com/robots.txt")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      for (certificate in response.handshake!!.peerCertificates) {
+        println(CertificatePinner.pin(certificate))
+      }
+    }
   }
+```
+
+```Java tab=
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .certificatePinner(
+          new CertificatePinner.Builder()
+              .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+              .build())
+      .build();
 
   public void run() throws Exception {
     Request request = new Request.Builder()
         .url("https://publicobject.com/robots.txt")
         .build();
 
-    Response response = client.newCall(request).execute();
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
 
-    for (Certificate certificate : response.handshake().peerCertificates()) {
-      System.out.println(CertificatePinner.pin(certificate));
+      for (Certificate certificate : response.handshake().peerCertificates()) {
+        System.out.println(CertificatePinner.pin(certificate));
+      }
     }
   }
 ```
 
-#### [Customizing Trusted Certificates](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java)
+### Customizing Trusted Certificates ([.kt][CustomTrustKotlin], [.java][CustomTrustJava])
 
 The full code sample shows how to replace the host platform’s certificate authorities with your own set. As above, **do not use custom certificates without the blessing of your server’s TLS administrator!**
 
-```java
+```Kotlin tab=
+  private val client: OkHttpClient
+
+  init {
+    val trustManager = trustManagerForCertificates(trustedCertificatesInputStream())
+    val sslContext = SSLContext.getInstance("TLS")
+    sslContext.init(null, arrayOf<TrustManager>(trustManager), null)
+    val sslSocketFactory = sslContext.socketFactory
+
+    client = OkHttpClient.Builder()
+        .sslSocketFactory(sslSocketFactory, trustManager)
+        .build()
+  }
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      for ((name, value) in response.headers) {
+        println("$name: $value")
+      }
+
+      println(response.body!!.string())
+    }
+  }
+
+  /**
+   * Returns an input stream containing one or more certificate PEM files. This implementation just
+   * embeds the PEM files in Java strings; most applications will instead read this from a resource
+   * file that gets bundled with the application.
+   */
+  private fun trustedCertificatesInputStream(): InputStream {
+    ... // Full source omitted. See sample.
+  }
+
+  private fun trustManagerForCertificates(inputStream: InputStream): X509TrustManager {
+    ... // Full source omitted. See sample.
+  }
+```
+
+```Java tab=
   private final OkHttpClient client;
 
   public CustomTrust() {
-    SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());
+    X509TrustManager trustManager;
+    SSLSocketFactory sslSocketFactory;
+    try {
+      trustManager = trustManagerForCertificates(trustedCertificatesInputStream());
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(null, new TrustManager[] { trustManager }, null);
+      sslSocketFactory = sslContext.getSocketFactory();
+    } catch (GeneralSecurityException e) {
+      throw new RuntimeException(e);
+    }
+
     client = new OkHttpClient.Builder()
-        .sslSocketFactory(sslContext.getSocketFactory())
+        .sslSocketFactory(sslSocketFactory, trustManager)
         .build();
   }
 
@@ -103,3 +180,8 @@ The full code sample shows how to replace the host platform’s certificate auth
     ... // Full source omitted. See sample.
   }
 ```
+
+ [CustomTrustJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java
+ [CustomTrustKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/CustomTrust.kt
+ [CertificatePinningJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
+ [CertificatePinningKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/CertificatePinning.kt
diff --git a/docs/interceptors.md b/docs/interceptors.md
index b3d759e9d0..e040b23f6c 100644
--- a/docs/interceptors.md
+++ b/docs/interceptors.md
@@ -29,7 +29,7 @@ Interceptors can be chained. Suppose you have both a compressing interceptor and
 
 ![Interceptors Diagram](images/interceptors@2x.png)
 
-#### Application Interceptors
+### Application Interceptors
 
 Interceptors are registered as either _application_ or _network_ interceptors. We'll use the `LoggingInterceptor` defined above to show the difference.
 
@@ -64,7 +64,7 @@ Connection: keep-alive
 
 We can see that we were redirected because `response.request().url()` is different from `request.url()`. The two log statements log two different URLs.
 
-#### Network Interceptors
+### Network Interceptors
 
 Registering a network interceptor is quite similar. Call `addNetworkInterceptor()` instead of `addInterceptor()`:
 
@@ -113,7 +113,7 @@ Connection: keep-alive
 
 The network requests also contain more data, such as the `Accept-Encoding: gzip` header added by OkHttp to advertise support for response compression. The network interceptor's `Chain` has a non-null `Connection` that can be used to interrogate the IP address and TLS configuration that were used to connect to the webserver.
 
-#### Choosing between application and network interceptors
+### Choosing between application and network interceptors
 
 Each interceptor chain has relative merits.
 
@@ -132,7 +132,7 @@ Each interceptor chain has relative merits.
  * Observe the data just as it will be transmitted over the network.
  * Access to the `Connection` that carries the request.
 
-#### Rewriting Requests
+### Rewriting Requests
 
 Interceptors can add, remove, or replace request headers. They can also transform the body of those requests that have one. For example, you can use an application interceptor to add request body compression if you're connecting to a webserver known to support it.
 
@@ -172,7 +172,7 @@ final class GzipRequestInterceptor implements Interceptor {
 }
 ```
 
-#### Rewriting Responses
+### Rewriting Responses
 
 Symmetrically, interceptors can rewrite response headers and transform the response body. This is generally more dangerous than rewriting request headers because it may violate the webserver's expectations!
 
diff --git a/docs/recipes.md b/docs/recipes.md
index c9bb42a6e3..fb153c3abf 100644
--- a/docs/recipes.md
+++ b/docs/recipes.md
@@ -2,14 +2,34 @@ Recipes
 =======
 
 We've written some recipes that demonstrate how to solve common problems with OkHttp. Read through them to learn about how everything works together. Cut-and-paste these examples freely; that's what they're for.
-
-#### [Synchronous Get](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java)
+ 
+### Synchronous Get ([.kt][SynchronousGetKotlin], [.java][SynchronousGetJava])
 
 Download a file, print its headers, and print its response body as a string.
 
 The `string()` method on response body is convenient and efficient for small documents. But if the response body is large (greater than 1 MiB), avoid `string()` because it will load the entire document into memory. In that case, prefer to process the body as a stream.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      for ((name, value) in response.headers) {
+        println("$name: $value")
+      }
+
+      println(response.body!!.string())
+    }
+  }
+```
+
+```Java tab=
   private final OkHttpClient client = new OkHttpClient();
 
   public void run() throws Exception {
@@ -29,12 +49,40 @@ The `string()` method on response body is convenient and efficient for small doc
     }
   }
 ```
-
-#### [Asynchronous Get](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java)
+ 
+### Asynchronous Get ([.kt][AsynchronousGetKotlin], [.java][AsynchronousGetJava])
 
 Download a file on a worker thread, and get called back when the response is readable. The callback is made after the response headers are ready. Reading the response body may still block. OkHttp doesn't currently offer asynchronous APIs to receive a response body in parts.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build()
+
+    client.newCall(request).enqueue(object : Callback {
+      override fun onFailure(call: Call, e: IOException) {
+        e.printStackTrace()
+      }
+
+      override fun onResponse(call: Call, response: Response) {
+        response.use {
+          if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+          for ((name, value) in response.headers) {
+            println("$name: $value")
+          }
+
+          println(response.body!!.string())
+        }
+      }
+    })
+  }
+```
+
+```Java tab=
   private final OkHttpClient client = new OkHttpClient();
 
   public void run() throws Exception {
@@ -62,8 +110,8 @@ Download a file on a worker thread, and get called back when the response is rea
     });
   }
 ```
-
-#### [Accessing Headers](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java)
+ 
+### Accessing Headers ([.kt][AccessHeadersKotlin], [.java][AccessHeadersJava])
 
 Typically HTTP headers work like a `Map<String, String>`: each field has one value or none. But some headers permit multiple values, like Guava's [Multimap](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html). For example, it's legal and common for an HTTP response to supply multiple `Vary` headers. OkHttp's APIs attempt to make both cases comfortable.
 
@@ -73,7 +121,28 @@ When reading response a header, use `header(name)` to return the _last_ occurren
 
 To visit all headers, use the `Headers` class which supports access by index.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://api.github.com/repos/square/okhttp/issues")
+        .header("User-Agent", "OkHttp Headers.java")
+        .addHeader("Accept", "application/json; q=0.5")
+        .addHeader("Accept", "application/vnd.github.v3+json")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println("Server: ${response.header("Server")}")
+      println("Date: ${response.header("Date")}")
+      println("Vary: ${response.headers("Vary")}")
+    }
+  }
+```
+
+```Java tab=
   private final OkHttpClient client = new OkHttpClient();
 
   public void run() throws Exception {
@@ -93,12 +162,42 @@ To visit all headers, use the `Headers` class which supports access by index.
     }
   }
 ```
-
-#### [Posting a String](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostString.java)
+ 
+### Posting a String ([.kt][PostStringKotlin], [.java][PostStringJava])
 
 Use an HTTP POST to send a request body to a service. This example posts a markdown document to a web service that renders markdown as HTML. Because the entire request body is in memory simultaneously, avoid posting large (greater than 1 MiB) documents using this API.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+
+  fun run() {
+    val postBody = """
+        |Releases
+        |--------
+        |
+        | * _1.0_ May 6, 2013
+        | * _1.1_ June 15, 2013
+        | * _1.2_ August 11, 2013
+        |""".trimMargin()
+
+    val request = Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(postBody.toRequestBody(MEDIA_TYPE_MARKDOWN))
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+
+  companion object {
+    val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
+  }
+```
+
+```Java tab=
   public static final MediaType MEDIA_TYPE_MARKDOWN
       = MediaType.parse("text/x-markdown; charset=utf-8");
 
@@ -125,12 +224,53 @@ Use an HTTP POST to send a request body to a service. This example posts a markd
     }
   }
 ```
+ 
+### Post Streaming ([.kt][PostStreamingKotlin], [.java][PostStreamingJava])
+ 
+Here we `POST` a request body as a stream. The content of this request body is being generated as it's being written. This example streams directly into the [Okio](https://github.com/square/okio) buffered sink. Your programs may prefer an `OutputStream`, which you can get from `BufferedSink.outputStream()`.
 
-#### [Post Streaming](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java)
+```Kotlin tab=
+  private val client = OkHttpClient()
 
-Here we `POST` a request body as a stream. The content of this request body is being generated as it's being written. This example streams directly into the [Okio](https://github.com/square/okio) buffered sink. Your programs may prefer an `OutputStream`, which you can get from `BufferedSink.outputStream()`.
+  fun run() {
+    val requestBody = object : RequestBody() {
+      override fun contentType() = MEDIA_TYPE_MARKDOWN
 
-```java
+      override fun writeTo(sink: BufferedSink) {
+        sink.writeUtf8("Numbers\n")
+        sink.writeUtf8("-------\n")
+        for (i in 2..997) {
+          sink.writeUtf8(String.format(" * $i = ${factor(i)}\n"))
+        }
+      }
+
+      private fun factor(n: Int): String {
+        for (i in 2 until n) {
+          val x = n / i
+          if (x * i == n) return "${factor(x)} × $i"
+        }
+        return n.toString()
+      }
+    }
+
+    val request = Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(requestBody)
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+
+  companion object {
+    val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
+  }
+```
+
+```Java tab=
   public static final MediaType MEDIA_TYPE_MARKDOWN
       = MediaType.parse("text/x-markdown; charset=utf-8");
 
@@ -171,12 +311,35 @@ Here we `POST` a request body as a stream. The content of this request body is b
     }
   }
 ```
-
-#### [Posting a File](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostFile.java)
+ 
+### Posting a File ([.kt][PostFileKotlin], [.java][PostFileJava])
 
 It's easy to use a file as a request body.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+
+  fun run() {
+    val file = File("README.md")
+
+    val request = Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(file.asRequestBody(MEDIA_TYPE_MARKDOWN))
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+
+  companion object {
+    val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
+  }
+```
+
+```Java tab=
   public static final MediaType MEDIA_TYPE_MARKDOWN
       = MediaType.parse("text/x-markdown; charset=utf-8");
 
@@ -197,12 +360,32 @@ It's easy to use a file as a request body.
     }
   }
 ```
-
-#### [Posting form parameters](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostForm.java)
+ 
+### Posting form parameters ([.kt][PostFormKotlin], [.java][PostFormJava])
 
 Use `FormBody.Builder` to build a request body that works like an HTML `<form>` tag. Names and values will be encoded using an HTML-compatible form URL encoding.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+
+  fun run() {
+    val formBody = FormBody.Builder()
+        .add("search", "Jurassic Park")
+        .build()
+    val request = Request.Builder()
+        .url("https://en.wikipedia.org/w/index.php")
+        .post(formBody)
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+```
+
+```Java tab=
   private final OkHttpClient client = new OkHttpClient();
 
   public void run() throws Exception {
@@ -221,12 +404,47 @@ Use `FormBody.Builder` to build a request body that works like an HTML `<form>`
     }
   }
 ```
-
-#### [Posting a multipart request](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java)
+ 
+### Posting a multipart request ([.kt][PostMultipartKotlin], [.java][PostMultipartJava])
 
 `MultipartBody.Builder` can build sophisticated request bodies compatible with HTML file upload forms. Each part of a multipart request body is itself a request body, and can define its own headers. If present, these headers should describe the part body, such as its `Content-Disposition`. The `Content-Length` and `Content-Type` headers are added automatically if they're available.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+
+  fun run() {
+    // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
+    val requestBody = MultipartBody.Builder()
+        .setType(MultipartBody.FORM)
+        .addFormDataPart("title", "Square Logo")
+        .addFormDataPart("image", "logo-square.png",
+            File("docs/images/logo-square.png").asRequestBody(MEDIA_TYPE_PNG))
+        .build()
+
+    val request = Request.Builder()
+        .header("Authorization", "Client-ID $IMGUR_CLIENT_ID")
+        .url("https://api.imgur.com/3/image")
+        .post(requestBody)
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+
+  companion object {
+    /**
+     * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
+     * these examples, please request your own client ID! https://api.imgur.com/oauth2
+     */
+    private val IMGUR_CLIENT_ID = "9199fdef135c122"
+    private val MEDIA_TYPE_PNG = "image/png".toMediaType()
+  }
+```
+
+```Java tab=
   /**
    * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
    * these examples, please request your own client ID! https://api.imgur.com/oauth2
@@ -258,14 +476,42 @@ Use `FormBody.Builder` to build a request body that works like an HTML `<form>`
     }
   }
 ```
-
-#### [Parse a JSON Response With Moshi](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java)
-
+ 
+### Parse a JSON Response With Moshi ([.kt][ParseResponseWithMoshiKotlin], [.java][ParseResponseWithMoshiJava])
+  
 [Moshi](https://github.com/square/moshi) is a handy API for converting between JSON and Java objects. Here we're using it to decode a JSON response from a GitHub API.
 
 Note that `ResponseBody.charStream()` uses the `Content-Type` response header to select which charset to use when decoding the response body. It defaults to `UTF-8` if no charset is specified.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+  private val moshi = Moshi.Builder().build()
+  private val gistJsonAdapter = moshi.adapter(Gist::class.java)
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://api.github.com/gists/c2a7c39532239ff261be")
+        .build()
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      val gist = gistJsonAdapter.fromJson(response.body!!.source())
+
+      for ((key, value) in gist!!.files!!) {
+        println(key)
+        println(value.content)
+      }
+    }
+  }
+
+  @JsonClass(generateAdapter = true)
+  data class Gist(var files: Map<String, GistFile>?)
+
+  @JsonClass(generateAdapter = true)
+  data class GistFile(var content: String?)
+```
+
+```Java tab=
   private final OkHttpClient client = new OkHttpClient();
   private final Moshi moshi = new Moshi.Builder().build();
   private final JsonAdapter<Gist> gistJsonAdapter = moshi.adapter(Gist.class);
@@ -294,8 +540,8 @@ Note that `ResponseBody.charStream()` uses the `Content-Type` response header to
     String content;
   }
 ```
-
-#### [Response Caching](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java)
+ 
+### Response Caching ([.kt][CacheResponseKotlin], [.java][CacheResponseJava])
 
 To cache responses, you'll need a cache directory that you can read and write to, and a limit on the cache's size. The cache directory should be private, and untrusted applications should not be able to read its contents!
 
@@ -303,7 +549,42 @@ It is an error to have multiple caches accessing the same cache directory simult
 
 Response caching uses HTTP headers for all configuration. You can add request headers like `Cache-Control: max-stale=3600` and OkHttp's cache will honor them. Your webserver configures how long responses are cached with its own response headers, like `Cache-Control: max-age=9600`. There are cache headers to force a cached response, force a network response, or force the network response to be validated with a conditional GET.
 
-```java
+```Kotlin tab=
+  private val client: OkHttpClient = OkHttpClient.Builder()
+      .cache(Cache(
+          directory = cacheDirectory,
+          maxSize = 10L * 1024L * 1024L // 1 MiB
+      ))
+      .build()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build()
+
+    val response1Body = client.newCall(request).execute().use {
+      if (!it.isSuccessful) throw IOException("Unexpected code $it")
+
+      println("Response 1 response:          $it")
+      println("Response 1 cache response:    ${it.cacheResponse}")
+      println("Response 1 network response:  ${it.networkResponse}")
+      return@use it.body!!.string()
+    }
+
+    val response2Body = client.newCall(request).execute().use {
+      if (!it.isSuccessful) throw IOException("Unexpected code $it")
+
+      println("Response 2 response:          $it")
+      println("Response 2 cache response:    ${it.cacheResponse}")
+      println("Response 2 network response:  ${it.networkResponse}")
+      return@use it.body!!.string()
+    }
+
+    println("Response 2 equals Response 1? " + (response1Body == response2Body))
+  }
+```
+
+```Java tab=
   private final OkHttpClient client;
 
   public CacheResponse(File cacheDirectory) throws Exception {
@@ -343,13 +624,46 @@ Response caching uses HTTP headers for all configuration. You can add request he
     System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
   }
 ```
-To prevent a response from using the cache, use [`CacheControl.FORCE_NETWORK`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-n-e-t-w-o-r-k/). To prevent it from using the network, use [`CacheControl.FORCE_CACHE`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-c-a-c-h-e/). Be warned: if you use `FORCE_CACHE` and the response requires the network, OkHttp will return a `504 Unsatisfiable Request` response.
 
-#### [Canceling a Call](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java)
+To prevent a response from using the cache, use [`CacheControl.FORCE_NETWORK`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-n-e-t-w-o-r-k/). To prevent it from using the network, use [`CacheControl.FORCE_CACHE`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-c-a-c-h-e/). Be warned: if you use `FORCE_CACHE` and the response requires the network, OkHttp will return a `504 Unsatisfiable Request` response.
+ 
+### Canceling a Call ([.kt][CancelCallKotlin], [.java][CancelCallJava])
 
 Use `Call.cancel()` to stop an ongoing call immediately. If a thread is currently writing a request or reading a response, it will receive an `IOException`. Use this to conserve the network when a call is no longer necessary; for example when your user navigates away from an application. Both synchronous and asynchronous calls can be canceled.
 
-```java
+```Kotlin tab=
+  private val executor = Executors.newScheduledThreadPool(1)
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build()
+
+    val startNanos = System.nanoTime()
+    val call = client.newCall(request)
+
+    // Schedule a job to cancel the call in 1 second.
+    executor.schedule({
+      System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f)
+      call.cancel()
+      System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f)
+    }, 1, TimeUnit.SECONDS)
+
+    System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f)
+    try {
+      call.execute().use { response ->
+        System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
+            (System.nanoTime() - startNanos) / 1e9f, response)
+      }
+    } catch (e: IOException) {
+      System.out.printf("%.2f Call failed as expected: %s%n",
+          (System.nanoTime() - startNanos) / 1e9f, e)
+    }
+  }
+```
+
+```Java tab=
   private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
   private final OkHttpClient client = new OkHttpClient();
 
@@ -380,12 +694,31 @@ Use `Call.cancel()` to stop an ongoing call immediately. If a thread is currentl
     }
   }
 ```
+ 
+### Timeouts ([.kt][ConfigureTimeoutsKotlin], [.java][ConfigureTimeoutsJava])
 
-#### [Timeouts](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java)
+Use timeouts to fail a call when its peer is unreachable. Network partitions can be due to client connectivity problems, server availability problems, or anything between. OkHttp supports connect, write, read, and full call timeouts.
 
-Use timeouts to fail a call when its peer is unreachable. Network partitions can be due to client connectivity problems, server availability problems, or anything between. OkHttp supports connect, read, and write timeouts.
+```Kotlin tab=
+  private val client: OkHttpClient = OkHttpClient.Builder()
+      .connectTimeout(5, TimeUnit.SECONDS)
+      .writeTimeout(5, TimeUnit.SECONDS)
+      .readTimeout(5, TimeUnit.SECONDS)
+      .callTimeout(10, TimeUnit.SECONDS)
+      .build()
 
-```java
+  fun run() {
+    val request = Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      println("Response completed: $response")
+    }
+  }
+```
+
+```Java tab=
   private final OkHttpClient client;
 
   public ConfigureTimeouts() throws Exception {
@@ -406,12 +739,46 @@ Use timeouts to fail a call when its peer is unreachable. Network partitions can
     }
   }
 ```
-
-#### [Per-call Configuration](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java)
+ 
+### Per-call Configuration ([.kt][PerCallSettingsKotlin], [.java][PerCallSettingsJava])
 
 All the HTTP client configuration lives in `OkHttpClient` including proxy settings, timeouts, and caches. When you need to change the configuration of a single call, call `OkHttpClient.newBuilder()`. This returns a builder that shares the same connection pool, dispatcher, and configuration with the original client. In the example below, we make one request with a 500 ms timeout and another with a 3000 ms timeout.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
+        .build()
+
+    // Copy to customize OkHttp for this request.
+    val client1 = client.newBuilder()
+        .readTimeout(500, TimeUnit.MILLISECONDS)
+        .build()
+    try {
+      client1.newCall(request).execute().use { response ->
+        println("Response 1 succeeded: $response")
+      }
+    } catch (e: IOException) {
+      println("Response 1 failed: $e")
+    }
+
+    // Copy to customize OkHttp for this request.
+    val client2 = client.newBuilder()
+        .readTimeout(3000, TimeUnit.MILLISECONDS)
+        .build()
+    try {
+      client2.newCall(request).execute().use { response ->
+        println("Response 2 succeeded: $response")
+      }
+    } catch (e: IOException) {
+      println("Response 2 failed: $e")
+    }
+  }
+```
+
+```Java tab=
   private final OkHttpClient client = new OkHttpClient();
 
   public void run() throws Exception {
@@ -440,14 +807,46 @@ All the HTTP client configuration lives in `OkHttpClient` including proxy settin
     }
   }
 ```
-
-#### [Handling authentication](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java)
+ 
+### Handling authentication ([.kt][AuthenticateKotlin], [.java][AuthenticateJava])
 
 OkHttp can automatically retry unauthenticated requests. When a response is `401 Not Authorized`, an `Authenticator` is asked to supply credentials. Implementations should build a new request that includes the missing credentials. If no credentials are available, return null to skip the retry.
 
 Use `Response.challenges()` to get the schemes and realms of any authentication challenges. When fulfilling a `Basic` challenge, use `Credentials.basic(username, password)` to encode the request header.
 
-```java
+```Kotlin tab=
+  private val client = OkHttpClient.Builder()
+      .authenticator(object : Authenticator {
+        @Throws(IOException::class)
+        override fun authenticate(route: Route?, response: Response): Request? {
+          if (response.request.header("Authorization") != null) {
+            return null // Give up, we've already attempted to authenticate.
+          }
+
+          println("Authenticating for response: $response")
+          println("Challenges: ${response.challenges()}")
+          val credential = Credentials.basic("jesse", "password1")
+          return response.request.newBuilder()
+              .header("Authorization", credential)
+              .build()
+        }
+      })
+      .build()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://publicobject.com/secrets/hellosecret.txt")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+```
+
+```Java tab=
   private final OkHttpClient client;
 
   public Authenticate() {
@@ -509,3 +908,32 @@ This above code relies on this `responseCount()` method:
     return result;
   }
 ```
+
+ [SynchronousGetJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java 
+ [SynchronousGetKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/SynchronousGet.kt
+ [AsynchronousGetJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java 
+ [AsynchronousGetKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/AsynchronousGet.kt
+ [AccessHeadersJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java 
+ [AccessHeadersKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/AccessHeaders.kt
+ [PostStringJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostString.java 
+ [PostStringKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/PostString.kt
+ [PostStreamingJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java 
+ [PostStreamingKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/PostStreaming.kt
+ [PostFileJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostFile.java 
+ [PostFileKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/PostFile.kt
+ [PostFormJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostForm.java 
+ [PostFormKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/PostForm.kt
+ [PostMultipartJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java 
+ [PostMultipartKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/PostMultipart.kt
+ [ParseResponseWithMoshiJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java 
+ [ParseResponseWithMoshiKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/ParseResponseWithMoshi.kt
+ [CacheResponseJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java 
+ [CacheResponseKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/CacheResponse.kt
+ [CancelCallJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java 
+ [CancelCallKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/CancelCall.kt
+ [ConfigureTimeoutsJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java 
+ [ConfigureTimeoutsKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/ConfigureTimeouts.kt
+ [PerCallSettingsJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java 
+ [PerCallSettingsKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/PerCallSettings.kt
+ [AuthenticateJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java 
+ [AuthenticateKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/Authenticate.kt
diff --git a/mkdocs.yml b/mkdocs.yml
index f54d97518b..4dc62ade3d 100644
--- a/mkdocs.yml
+++ b/mkdocs.yml
@@ -33,6 +33,7 @@ markdown_extensions:
   - pymdownx.magiclink
   - pymdownx.smartsymbols
   - pymdownx.superfences
+  - pymdownx.tilde
   - tables
 
 nav:
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
index a456b8fdf0..8371a81314 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
@@ -781,7 +781,13 @@ class MockWebServer : ExternalResource(), Closeable {
     val streams = object : RealWebSocket.Streams(false, source, sink) {
       override fun close() = connectionClose.countDown()
     }
-    val webSocket = RealWebSocket(fancyRequest, response.webSocketListener!!, SecureRandom(), 0)
+    val webSocket = RealWebSocket(
+        taskRunner = taskRunner,
+        originalRequest = fancyRequest,
+        listener = response.webSocketListener!!,
+        random = SecureRandom(),
+        pingIntervalMillis = 0
+    )
     response.webSocketListener!!.onOpen(webSocket, fancyResponse)
     val name = "MockWebServer WebSocket ${request.path!!}"
     webSocket.initReaderAndWriter(name, streams)
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
index 78a6b7994e..185dde5bfc 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
@@ -125,7 +125,7 @@ private SSLSocket doSsl(Socket socket) throws IOException {
         send404(stream, path);
       }
     } catch (IOException e) {
-      Platform.get().log(INFO, "Failure serving Http2Stream: " + e.getMessage(), null);
+      Platform.get().log("Failure serving Http2Stream: " + e.getMessage(), INFO, null);
     }
   }
 
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt
index bb4d37cfc2..e8a35ed0cf 100644
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt
@@ -204,7 +204,7 @@ class DnsOverHttps internal constructor(
   @Throws(Exception::class)
   private fun readResponse(hostname: String, response: Response): List<InetAddress> {
     if (response.cacheResponse == null && response.protocol !== Protocol.HTTP_2) {
-      Platform.get().log(Platform.WARN, "Incorrect protocol: ${response.protocol}", null)
+      Platform.get().log("Incorrect protocol: ${response.protocol}", Platform.WARN)
     }
 
     response.use {
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
index 745a860a9f..e346c74f70 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
@@ -21,7 +21,6 @@ import okhttp3.OkHttpClient
 import okhttp3.Response
 import okhttp3.internal.http.promisesBody
 import okhttp3.internal.platform.Platform
-import okhttp3.internal.platform.Platform.Companion.INFO
 import okio.Buffer
 import okio.GzipSource
 import java.io.IOException
@@ -113,7 +112,7 @@ class HttpLoggingInterceptor @JvmOverloads constructor(
       @JvmField
       val DEFAULT: Logger = object : Logger {
         override fun log(message: String) {
-          Platform.get().log(INFO, message, null)
+          Platform.get().log(message)
         }
       }
     }
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
index be0e5e69db..d96f38e84d 100644
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
@@ -24,7 +24,6 @@
 import okhttp3.sse.EventSource;
 import okhttp3.sse.EventSources;
 import org.junit.After;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -35,11 +34,7 @@
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   private final EventSourceRecorder listener = new EventSourceRecorder();
-  private OkHttpClient client;
-
-  @Before public void setUp() {
-    client = clientTestRule.newClient();
-  }
+  private OkHttpClient client = clientTestRule.newClient();
 
   @After public void after() {
     listener.assertExhausted();
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
index bc87c5a644..c96672d273 100644
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
@@ -31,24 +31,24 @@
   private final BlockingQueue<Object> events = new LinkedBlockingDeque<>();
 
   @Override public void onOpen(EventSource eventSource, Response response) {
-    Platform.get().log(Platform.INFO, "[ES] onOpen", null);
+    Platform.get().log("[ES] onOpen", Platform.INFO, null);
     events.add(new Open(eventSource, response));
   }
 
   @Override public void onEvent(EventSource eventSource, @Nullable String id, @Nullable String type,
       String data) {
-    Platform.get().log(Platform.INFO, "[ES] onEvent", null);
+    Platform.get().log("[ES] onEvent", Platform.INFO, null);
     events.add(new Event(id, type, data));
   }
 
   @Override public void onClosed(EventSource eventSource) {
-    Platform.get().log(Platform.INFO, "[ES] onClosed", null);
+    Platform.get().log("[ES] onClosed", Platform.INFO, null);
     events.add(new Closed());
   }
 
   @Override
   public void onFailure(EventSource eventSource, @Nullable Throwable t, @Nullable Response response) {
-    Platform.get().log(Platform.INFO, "[ES] onFailure", t);
+    Platform.get().log("[ES] onFailure", Platform.INFO, t);
     events.add(new Failure(t, response));
   }
 
diff --git a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
index 1315914a38..ed0ef26d7a 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
+++ b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
@@ -22,31 +22,36 @@ import org.junit.rules.TestRule
 import org.junit.runner.Description
 import org.junit.runners.model.Statement
 import java.net.InetAddress
-import java.util.concurrent.ConcurrentLinkedDeque
 import java.util.concurrent.TimeUnit
 
 /** Apply this rule to tests that need an OkHttpClient instance. */
 class OkHttpClientTestRule : TestRule {
   private val clientEventsList = mutableListOf<String>()
-  private var prototype: OkHttpClient? = null
+  private var testClient: OkHttpClient? = null
 
   /**
-   * Returns an OkHttpClient for all tests to use as a starting point.
+   * Returns an OkHttpClient for tests to use as a starting point.
    *
-   * The shared instance allows all tests to share a single connection pool, which prevents idle
-   * connections from consuming unnecessary resources while connections wait to be evicted.
+   * The returned client installs a default event listener that gathers debug information. This will
+   * be logged if the test fails.
    *
    * This client is also configured to be slightly more deterministic, returning a single IP
    * address for all hosts, regardless of the actual number of IP addresses reported by DNS.
    */
   fun newClient(): OkHttpClient {
-    return newClientBuilder().build()
+    var client = testClient
+    if (client == null) {
+      client = OkHttpClient.Builder()
+          .dns(SINGLE_INET_ADDRESS_DNS) // Prevent unexpected fallback addresses.
+          .eventListener(ClientRuleEventListener { addEvent(it) })
+          .build()
+      testClient = client
+    }
+    return client
   }
 
   fun newClientBuilder(): OkHttpClient.Builder {
-    return checkNotNull(prototype) { "don't create clients in test initialization!" }
-        .newBuilder()
-        .eventListener(ClientRuleEventListener { addEvent(it) })
+    return newClient().newBuilder()
   }
 
   @Synchronized private fun addEvent(it: String) {
@@ -54,7 +59,7 @@ class OkHttpClientTestRule : TestRule {
   }
 
   fun ensureAllConnectionsReleased() {
-    prototype?.let {
+    testClient?.let {
       val connectionPool = it.connectionPool
       connectionPool.evictAll()
       assertThat(connectionPool.connectionCount()).isEqualTo(0)
@@ -72,7 +77,6 @@ class OkHttpClientTestRule : TestRule {
   override fun apply(base: Statement, description: Description): Statement {
     return object : Statement() {
       override fun evaluate() {
-        acquireClient()
         try {
           base.evaluate()
           logEventsIfFlaky(description)
@@ -86,15 +90,8 @@ class OkHttpClientTestRule : TestRule {
         }
       }
 
-      private fun acquireClient() {
-        prototype = prototypes.poll() ?: freshClient()
-      }
-
       private fun releaseClient() {
-        prototype?.let {
-          prototypes.push(it)
-          prototype = null
-        }
+        testClient?.dispatcher?.executorService?.shutdown()
       }
     }
   }
@@ -119,40 +116,16 @@ class OkHttpClientTestRule : TestRule {
     }
   }
 
-  /**
-   * Called if a test is known to be leaky.
-   */
-  fun abandonClient() {
-    prototype?.let {
-      prototype = null
-      it.dispatcher.executorService.shutdownNow()
-      it.connectionPool.evictAll()
-    }
-  }
-
   companion object {
-    /**
-     * Quick and dirty pool of OkHttpClient instances. Each has its own independent dispatcher and
-     * connection pool. This way we can reuse expensive resources while preventing concurrent tests
-     * from interfering with each other.
-     */
-    internal val prototypes = ConcurrentLinkedDeque<OkHttpClient>()
-
     /**
      * A network that resolves only one IP address per host. Use this when testing route selection
      * fallbacks to prevent the host machine's various IP addresses from interfering.
      */
-    internal val SINGLE_INET_ADDRESS_DNS = object : Dns {
+    private val SINGLE_INET_ADDRESS_DNS = object : Dns {
       override fun lookup(hostname: String): List<InetAddress> {
         val addresses = Dns.SYSTEM.lookup(hostname)
         return listOf(addresses[0])
       }
     }
-
-    private fun freshClient(): OkHttpClient {
-      return OkHttpClient.Builder()
-          .dns(SINGLE_INET_ADDRESS_DNS) // Prevent unexpected fallback addresses.
-          .build()
-    }
   }
 }
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
index 0b3f7afa85..ea8b2fb1ba 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
@@ -37,7 +37,7 @@ class JavaNetCookieJar(private val cookieHandler: CookieHandler) : CookieJar {
     try {
       cookieHandler.put(url.toUri(), multimap)
     } catch (e: IOException) {
-      Platform.get().log(WARN, "Saving cookies failed for " + url.resolve("/...")!!, e)
+      Platform.get().log("Saving cookies failed for " + url.resolve("/...")!!, WARN, e)
     }
   }
 
@@ -46,7 +46,7 @@ class JavaNetCookieJar(private val cookieHandler: CookieHandler) : CookieJar {
       // The RI passes all headers. We don't have 'em, so we don't pass 'em!
       cookieHandler.get(url.toUri(), emptyMap<String, List<String>>())
     } catch (e: IOException) {
-      Platform.get().log(WARN, "Loading cookies failed for " + url.resolve("/...")!!, e)
+      Platform.get().log("Loading cookies failed for " + url.resolve("/...")!!, WARN, e)
       return emptyList()
     }
 
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.kt b/okhttp/src/main/java/okhttp3/OkHttpClient.kt
index 009f303cf9..ffc23c8013 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.kt
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.kt
@@ -19,6 +19,7 @@ import okhttp3.Protocol.HTTP_1_1
 import okhttp3.Protocol.HTTP_2
 import okhttp3.internal.asFactory
 import okhttp3.internal.checkDuration
+import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.immutableListOf
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.proxy.NullProxySelector
@@ -244,7 +245,13 @@ open class OkHttpClient internal constructor(
 
   /** Uses [request] to connect a new web socket. */
   override fun newWebSocket(request: Request, listener: WebSocketListener): WebSocket {
-    val webSocket = RealWebSocket(request, listener, Random(), pingIntervalMillis.toLong())
+    val webSocket = RealWebSocket(
+        TaskRunner.INSTANCE,
+        request,
+        listener,
+        Random(),
+        pingIntervalMillis.toLong()
+    )
     webSocket.connect(this)
     return webSocket
   }
diff --git a/okhttp/src/main/java/okhttp3/RealCall.kt b/okhttp/src/main/java/okhttp3/RealCall.kt
index 0e150e0be6..0442d6798b 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.kt
+++ b/okhttp/src/main/java/okhttp3/RealCall.kt
@@ -139,7 +139,7 @@ internal class RealCall private constructor(
         } catch (e: IOException) {
           if (signalledCallback) {
             // Do not signal the callback twice!
-            Platform.get().log(INFO, "Callback failure for ${toLoggableString()}", e)
+            Platform.get().log("Callback failure for ${toLoggableString()}", INFO, e)
           } else {
             responseCallback.onFailure(this@RealCall, e)
           }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
index 60086c6fe2..ea756eed0f 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
@@ -94,7 +94,7 @@ class DiskLruCache internal constructor(
   maxSize: Long,
 
   /** Used for asynchronous journal rebuilds. */
-  taskRunner: TaskRunner = TaskRunner.INSTANCE
+  taskRunner: TaskRunner
 ) : Closeable, Flushable {
   /** The maximum number of bytes that this cache should use to store its data. */
   @get:Synchronized @set:Synchronized var maxSize: Long = maxSize
@@ -231,8 +231,9 @@ class DiskLruCache internal constructor(
         initialized = true
         return
       } catch (journalIsCorrupt: IOException) {
-        Platform.get().log(WARN,
+        Platform.get().log(
             "DiskLruCache $directory is corrupt: ${journalIsCorrupt.message}, removing",
+            WARN,
             journalIsCorrupt)
       }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt
index b9cf66e682..f87da0117d 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt
@@ -64,7 +64,7 @@ fun Headers.parseChallenges(headerName: String): List<Challenge> {
       try {
         header.readChallengeHeader(result)
       } catch (e: EOFException) {
-        Platform.get().log(Platform.WARN, "Unable to parse challenge", e)
+        Platform.get().log("Unable to parse challenge", Platform.WARN, e)
       }
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
index 54cd7fae83..65d4c7d6e4 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
@@ -433,7 +433,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
 
   /**
    * Closes this connection. This cancels all open streams and unanswered pings. It closes the
-   * underlying input and output streams and shuts down internal executor services.
+   * underlying input and output streams and shuts down internal executor services and task queues.
    */
   override fun close() {
     close(ErrorCode.NO_ERROR, ErrorCode.CANCEL, null)
@@ -643,7 +643,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
             try {
               listener.onStream(newStream)
             } catch (e: IOException) {
-              Platform.get().log(INFO, "Http2Connection.Listener failure for $connectionName", e)
+              Platform.get().log("Http2Connection.Listener failure for $connectionName", INFO, e)
               ignoreIoExceptions {
                 newStream.close(ErrorCode.PROTOCOL_ERROR, e)
               }
@@ -687,7 +687,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
      *
      * Since we can't ACK settings on the current reader thread (the reader thread can't write) we
      * execute all peer settings logic on the writer thread. This relies on the fact that the
-     * writer executor won't reorder tasks; otherwise settings could be applied in the opposite
+     * writer task queue won't reorder tasks; otherwise settings could be applied in the opposite
      * order than received.
      */
     fun applyAndAckSettings(clearPrevious: Boolean, settings: Settings) {
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Android10Platform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Android10Platform.kt
index 501699d6f3..fda2a2c105 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Android10Platform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Android10Platform.kt
@@ -51,7 +51,7 @@ class Android10Platform : Platform() {
       // No TLS extensions if the socket class is custom.
       socketAdapters.find { it.matchesSocket(sslSocket) }?.getSelectedProtocol(sslSocket)
 
-  override fun log(level: Int, message: String, t: Throwable?) {
+  override fun log(message: String, level: Int, t: Throwable?) {
     androidLog(level, message, t)
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
index 80567048d0..a2fca8f481 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
@@ -83,7 +83,7 @@ class AndroidPlatform : Platform() {
       // No TLS extensions if the socket class is custom.
       socketAdapters.find { it.matchesSocket(sslSocket) }?.getSelectedProtocol(sslSocket)
 
-  override fun log(level: Int, message: String, t: Throwable?) {
+  override fun log(message: String, level: Int, t: Throwable?) {
     androidLog(level, message, t)
   }
 
@@ -93,7 +93,7 @@ class AndroidPlatform : Platform() {
     val reported = closeGuard.warnIfOpen(stackTrace)
     if (!reported) {
       // Unable to report via CloseGuard. As a last-ditch effort, send it to the logger.
-      log(WARN, message, null)
+      log(message, WARN)
     }
   }
 
@@ -194,22 +194,28 @@ class AndroidPlatform : Platform() {
     val isAndroid: Boolean = try {
       // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
       Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl")
+
+      // account for android-all, forces UnsatisfiedLinkError in Intellij
+      check(Build.VERSION.SDK_INT > 0)
+
       true
     } catch (_: ClassNotFoundException) {
+      // Running in a JVM
+      false
+    } catch (_: UnsatisfiedLinkError) {
+      // Running in a JVM/Intellij with android-all on the classpath
       false
     }
 
-    val isSupported: Boolean = try {
-      // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
-      Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl")
-
-      // Fail Fast
-      check(
-          Build.VERSION.SDK_INT >= 21) { "Expected Android API level 21+ but was ${Build.VERSION.SDK_INT}" }
+    val isSupported: Boolean = when {
+      !isAndroid -> false
+      else -> {
+        // Fail Fast
+        check(
+            Build.VERSION.SDK_INT >= 21) { "Expected Android API level 21+ but was ${Build.VERSION.SDK_INT}" }
 
-      true
-    } catch (_: ClassNotFoundException) {
-      false
+        true
+      }
     }
 
     fun buildIfSupported(): Platform? = if (isSupported) AndroidPlatform() else null
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt
index 602b736c5b..65ba5c3062 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt
@@ -61,9 +61,7 @@ class Jdk8WithJettyBootPlatform(
     try {
       val provider = Proxy.getInvocationHandler(getMethod.invoke(null, sslSocket)) as AlpnProvider
       if (!provider.unsupported && provider.selected == null) {
-        Platform.get().log(INFO,
-            "ALPN callback dropped: HTTP/2 is disabled. " + "Is alpn-boot on the boot class path?",
-            null)
+        log("ALPN callback dropped: HTTP/2 is disabled. " + "Is alpn-boot on the boot class path?")
         return null
       }
       return if (provider.unsupported) null else provider.selected
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
index 2102d5b308..aa625412a8 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
@@ -116,7 +116,7 @@ open class Platform {
     socket.connect(address, connectTimeout)
   }
 
-  open fun log(level: Int, message: String, t: Throwable?) {
+  open fun log(message: String, level: Int = INFO, t: Throwable? = null) {
     val logLevel = if (level == WARN) Level.WARNING else Level.INFO
     logger.log(logLevel, message, t)
   }
@@ -141,7 +141,7 @@ open class Platform {
       logMessage += " To see where this was allocated, set the OkHttpClient logger level to " +
           "FINE: Logger.getLogger(OkHttpClient.class.getName()).setLevel(Level.FINE);"
     }
-    log(WARN, logMessage, stackTrace as Throwable?)
+    log(logMessage, WARN, stackTrace as Throwable?)
   }
 
   open fun buildCertificateChainCleaner(trustManager: X509TrustManager): CertificateChainCleaner =
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt
index c3cef3dbea..b008e99c8a 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt
@@ -64,7 +64,7 @@ class DeferredSocketAdapter(private val socketPackage: String) : SocketAdapter {
         delegate = AndroidSocketAdapter(possibleClass)
       } catch (e: Exception) {
         Platform.get()
-            .log(Platform.WARN, "Failed to initialize DeferredSocketAdapter $socketPackage", e)
+            .log("Failed to initialize DeferredSocketAdapter $socketPackage", Platform.WARN, e)
       }
 
       initialized = true
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt
index 4a3bf12e42..71a701232e 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt
@@ -22,7 +22,10 @@ private const val MAX_LOG_LENGTH = 4000
 
 internal fun androidLog(level: Int, message: String, t: Throwable?) {
   var logMessage = message
-  val logLevel = if (level == Platform.WARN) Log.WARN else Log.DEBUG
+  val logLevel = when (level) {
+    Platform.WARN -> Log.WARN
+    else -> Log.DEBUG
+  }
   if (t != null) logMessage = logMessage + '\n'.toString() + Log.getStackTraceString(t)
 
   // Split by line, then ensure each line can fit into Log's maximum length.
diff --git a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.kt b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.kt
index 9021066066..8e4a4c367c 100644
--- a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.kt
+++ b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.kt
@@ -178,7 +178,7 @@ class PublicSuffixDatabase {
           Thread.interrupted() // Temporarily clear the interrupted state.
           interrupted = true
         } catch (e: IOException) {
-          Platform.get().log(Platform.WARN, "Failed to read public suffix list", e)
+          Platform.get().log("Failed to read public suffix list", Platform.WARN, e)
           return
         }
       }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt
index c7feccef49..4c29d5233d 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt
@@ -26,8 +26,9 @@ import okhttp3.Response
 import okhttp3.WebSocket
 import okhttp3.WebSocketListener
 import okhttp3.internal.closeQuietly
+import okhttp3.internal.concurrent.Task
+import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.connection.Exchange
-import okhttp3.internal.threadFactory
 import okhttp3.internal.ws.WebSocketProtocol.CLOSE_CLIENT_GOING_AWAY
 import okhttp3.internal.ws.WebSocketProtocol.CLOSE_MESSAGE_MAX
 import okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY
@@ -45,13 +46,11 @@ import java.net.ProtocolException
 import java.net.SocketTimeoutException
 import java.util.ArrayDeque
 import java.util.Random
-import java.util.concurrent.ScheduledExecutorService
-import java.util.concurrent.ScheduledFuture
-import java.util.concurrent.ScheduledThreadPoolExecutor
 import java.util.concurrent.TimeUnit
 import java.util.concurrent.TimeUnit.MILLISECONDS
 
 class RealWebSocket(
+  taskRunner: TaskRunner,
   /** The application's original request unadulterated by web socket headers. */
   private val originalRequest: Request,
   internal val listener: WebSocketListener,
@@ -63,8 +62,8 @@ class RealWebSocket(
   /** Non-null for client web sockets. These can be canceled. */
   private var call: Call? = null
 
-  /** This runnable processes the outgoing queues. Call [runWriter] to after enqueueing. */
-  private val writerRunnable: Runnable
+  /** This task processes the outgoing queues. Call [runWriter] to after enqueueing. */
+  private val writerTask: Task
 
   /** Null until this web socket is connected. Only accessed by the reader thread. */
   private var reader: WebSocketReader? = null
@@ -74,8 +73,8 @@ class RealWebSocket(
   /** Null until this web socket is connected. Note that messages may be enqueued before that. */
   private var writer: WebSocketWriter? = null
 
-  /** Null until this web socket is connected. Used for writes, pings, and close timeouts. */
-  private var executor: ScheduledExecutorService? = null
+  /** Used for writes, pings, and close timeouts. */
+  private var taskQueue = taskRunner.newQueue("OkHttp WebSocket ${originalRequest.url.redact()}")
 
   /**
    * The streams held by this web socket. This is non-null until all incoming messages have been
@@ -96,12 +95,6 @@ class RealWebSocket(
   /** True if we've enqueued a close frame. No further message frames will be enqueued. */
   private var enqueuedClose = false
 
-  /**
-   * When executed this will cancel this web socket. This future itself should be canceled if that
-   * is unnecessary because the web socket is already closed or canceled.
-   */
-  private var cancelFuture: ScheduledFuture<*>? = null
-
   /** The close code from the peer, or -1 if this web socket has not yet read a close frame. */
   private var receivedCloseCode = -1
 
@@ -129,13 +122,17 @@ class RealWebSocket(
     }
 
     this.key = ByteArray(16).apply { random.nextBytes(this) }.toByteString().base64()
-    this.writerRunnable = Runnable {
-      try {
-        while (writeOneFrame()) {
+    this.writerTask = object : Task("${taskQueue.owner} Writer") {
+      override fun runOnce(): Long {
+        try {
+          if (writeOneFrame()) return 0L
+        } catch (e: IOException) {
+          failWebSocket(e, null)
         }
-      } catch (e: IOException) {
-        failWebSocket(e, null)
+        return -1L
       }
+
+      override fun tryCancel() = true
     }
   }
 
@@ -226,10 +223,9 @@ class RealWebSocket(
     synchronized(this) {
       this.streams = streams
       this.writer = WebSocketWriter(streams.client, streams.sink, random)
-      this.executor = ScheduledThreadPoolExecutor(1, threadFactory(name, false))
       if (pingIntervalMillis != 0L) {
-        executor!!.scheduleAtFixedRate(
-            PingRunnable(), pingIntervalMillis, pingIntervalMillis, MILLISECONDS)
+        val pingIntervalNanos = MILLISECONDS.toNanos(pingIntervalMillis)
+        taskQueue.schedule(PingTask(pingIntervalNanos), pingIntervalNanos)
       }
       if (messageAndCloseQueue.isNotEmpty()) {
         runWriter() // Send messages that were enqueued before we were connected.
@@ -265,18 +261,15 @@ class RealWebSocket(
 
   /** For testing: wait until the web socket's executor has terminated. */
   @Throws(InterruptedException::class)
-  fun awaitTermination(timeout: Int, timeUnit: TimeUnit) {
-    executor!!.awaitTermination(timeout.toLong(), timeUnit)
+  fun awaitTermination(timeout: Long, timeUnit: TimeUnit) {
+    taskQueue.awaitIdle(timeUnit.toNanos(timeout))
   }
 
   /** For testing: force this web socket to release its threads. */
   @Throws(InterruptedException::class)
   fun tearDown() {
-    if (cancelFuture != null) {
-      cancelFuture!!.cancel(false)
-    }
-    executor!!.shutdown()
-    executor!!.awaitTermination(10, TimeUnit.SECONDS)
+    taskQueue.shutdown()
+    taskQueue.awaitIdle(TimeUnit.SECONDS.toNanos(10L))
   }
 
   @Synchronized fun sentPingCount(): Int = sentPingCount
@@ -321,8 +314,7 @@ class RealWebSocket(
       if (enqueuedClose && messageAndCloseQueue.isEmpty()) {
         toClose = this.streams
         this.streams = null
-        if (cancelFuture != null) cancelFuture!!.cancel(false)
-        this.executor!!.shutdown()
+        this.taskQueue.shutdown()
       }
     }
 
@@ -405,7 +397,7 @@ class RealWebSocket(
 
   private fun runWriter() {
     assert(Thread.holdsLock(this))
-    executor?.execute(writerRunnable)
+    taskQueue.trySchedule(writerTask)
   }
 
   /**
@@ -445,11 +437,12 @@ class RealWebSocket(
           if (receivedCloseCode != -1) {
             streamsToClose = this.streams
             this.streams = null
-            this.executor!!.shutdown()
+            this.taskQueue.shutdown()
           } else {
             // When we request a graceful close also schedule a cancel of the web socket.
-            cancelFuture = executor!!.schedule(CancelRunnable(),
-                (messageOrClose as Close).cancelAfterCloseMillis, MILLISECONDS)
+            val cancelAfterCloseNanos =
+                MILLISECONDS.toNanos((messageOrClose as Close).cancelAfterCloseMillis)
+            taskQueue.schedule(CancelRunnable(), cancelAfterCloseNanos)
           }
         } else if (messageOrClose == null) {
           return false // The queue is exhausted.
@@ -487,10 +480,13 @@ class RealWebSocket(
     }
   }
 
-  private inner class PingRunnable : Runnable {
-    override fun run() {
+  private inner class PingTask(val delayNanos: Long) : Task("${taskQueue.owner} Ping") {
+    override fun runOnce(): Long {
       writePingFrame()
+      return delayNanos
     }
+
+    override fun tryCancel() = true
   }
 
   internal fun writePingFrame() {
@@ -524,8 +520,7 @@ class RealWebSocket(
       failed = true
       streamsToClose = this.streams
       this.streams = null
-      cancelFuture?.cancel(false)
-      executor?.shutdown()
+      taskQueue.shutdown()
     }
 
     try {
@@ -552,10 +547,13 @@ class RealWebSocket(
     val sink: BufferedSink
   ) : Closeable
 
-  internal inner class CancelRunnable : Runnable {
-    override fun run() {
+  internal inner class CancelRunnable : Task("${taskQueue.owner} Cancel") {
+    override fun runOnce(): Long {
       cancel()
+      return -1L
     }
+
+    override fun tryCancel() = true
   }
 
   companion object {
diff --git a/okhttp/src/test/java/okhttp3/CallKotlinTest.kt b/okhttp/src/test/java/okhttp3/CallKotlinTest.kt
index df7e3f2f89..a1c1f970da 100644
--- a/okhttp/src/test/java/okhttp3/CallKotlinTest.kt
+++ b/okhttp/src/test/java/okhttp3/CallKotlinTest.kt
@@ -19,7 +19,6 @@ import okhttp3.mockwebserver.MockResponse
 import okhttp3.mockwebserver.MockWebServer
 import okhttp3.testing.PlatformRule
 import org.assertj.core.api.Assertions.assertThat
-import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TestRule
@@ -32,11 +31,7 @@ class CallKotlinTest {
   @JvmField @Rule val server = MockWebServer()
   @JvmField @Rule val clientTestRule = OkHttpClientTestRule()
 
-  private lateinit var client: OkHttpClient
-
-  @Before fun setUp() {
-    client = clientTestRule.newClient()
-  }
+  private var client = clientTestRule.newClient()
 
   @Test
   fun legalToExecuteTwiceCloning() {
diff --git a/okhttp/src/test/java/okhttp3/CallTest.java b/okhttp/src/test/java/okhttp3/CallTest.java
index 857bea310e..2a50b527b6 100644
--- a/okhttp/src/test/java/okhttp3/CallTest.java
+++ b/okhttp/src/test/java/okhttp3/CallTest.java
@@ -110,7 +110,9 @@
 
   private RecordingEventListener listener = new RecordingEventListener();
   private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client;
+  private OkHttpClient client = clientTestRule.newClientBuilder()
+      .eventListener(listener)
+      .build();
   private RecordingCallback callback = new RecordingCallback();
   private TestLogHandler logHandler = new TestLogHandler();
   private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
@@ -120,9 +122,6 @@
     platform.assumeNotOpenJSSE();
 
     logger.addHandler(logHandler);
-    client = clientTestRule.newClientBuilder()
-        .eventListener(listener)
-        .build();
   }
 
   @After public void tearDown() throws Exception {
diff --git a/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
index a3445d7813..ea1a635f9e 100644
--- a/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
+++ b/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
@@ -24,7 +24,6 @@
 import okhttp3.mockwebserver.SocketPolicy;
 import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
@@ -43,11 +42,7 @@
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client;
-
-  @Before public void setUp() {
-    client = clientTestRule.newClient();
-  }
+  private OkHttpClient client = clientTestRule.newClient();
 
   @Test public void connectionsAreReused() throws Exception {
     server.enqueue(new MockResponse().setBody("a"));
diff --git a/okhttp/src/test/java/okhttp3/ConscryptTest.kt b/okhttp/src/test/java/okhttp3/ConscryptTest.kt
index 47381de1d0..b2a53ef0b9 100644
--- a/okhttp/src/test/java/okhttp3/ConscryptTest.kt
+++ b/okhttp/src/test/java/okhttp3/ConscryptTest.kt
@@ -35,11 +35,10 @@ class ConscryptTest {
 
   @JvmField @Rule val clientTestRule = OkHttpClientTestRule()
 
-  private lateinit var client: OkHttpClient
+  private val client = clientTestRule.newClient()
 
   @Before fun setUp() {
     platform.assumeConscrypt()
-    client = clientTestRule.newClient()
   }
 
   @Test
diff --git a/okhttp/src/test/java/okhttp3/CookiesTest.java b/okhttp/src/test/java/okhttp3/CookiesTest.java
index 758a0936cc..44ac99fd12 100644
--- a/okhttp/src/test/java/okhttp3/CookiesTest.java
+++ b/okhttp/src/test/java/okhttp3/CookiesTest.java
@@ -30,7 +30,6 @@
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -45,11 +44,7 @@
   @Rule public final MockWebServer server = new MockWebServer();
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
-  private OkHttpClient client;
-
-  @Before public void setUp() {
-    client = clientTestRule.newClient();
-  }
+  private OkHttpClient client = clientTestRule.newClient();
 
   @Test
   public void testNetscapeResponse() throws Exception {
diff --git a/okhttp/src/test/java/okhttp3/DispatcherTest.java b/okhttp/src/test/java/okhttp3/DispatcherTest.java
index 2a7c9a06b6..edcd981c8a 100644
--- a/okhttp/src/test/java/okhttp3/DispatcherTest.java
+++ b/okhttp/src/test/java/okhttp3/DispatcherTest.java
@@ -20,16 +20,15 @@
   RecordingWebSocketListener webSocketListener = new RecordingWebSocketListener();
   Dispatcher dispatcher = new Dispatcher(executor);
   RecordingEventListener listener = new RecordingEventListener();
-  OkHttpClient client;
+  OkHttpClient client = clientTestRule.newClientBuilder()
+      .dispatcher(dispatcher)
+      .eventListener(listener)
+      .build();
 
   @Before public void setUp() throws Exception {
     dispatcher.setMaxRequests(20);
     dispatcher.setMaxRequestsPerHost(10);
     listener.forbidLock(dispatcher);
-    client = clientTestRule.newClientBuilder()
-        .dispatcher(dispatcher)
-        .eventListener(listener)
-        .build();
   }
 
   @Test public void maxRequestsZero() throws Exception {
diff --git a/okhttp/src/test/java/okhttp3/DuplexTest.java b/okhttp/src/test/java/okhttp3/DuplexTest.java
index 7453035a96..d33b3e8b61 100644
--- a/okhttp/src/test/java/okhttp3/DuplexTest.java
+++ b/okhttp/src/test/java/okhttp3/DuplexTest.java
@@ -51,14 +51,13 @@
 
   private RecordingEventListener listener = new RecordingEventListener();
   private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client;
+  private OkHttpClient client = clientTestRule.newClientBuilder()
+      .eventListener(listener)
+      .build();
 
   @Before public void setUp() {
     platform.assumeNotOpenJSSE();
     platform.assumeHttp2Support();
-    client = clientTestRule.newClientBuilder()
-        .eventListener(listener)
-        .build();
   }
 
   @Test public void http1DoesntSupportDuplex() throws IOException {
diff --git a/okhttp/src/test/java/okhttp3/EventListenerTest.java b/okhttp/src/test/java/okhttp3/EventListenerTest.java
index d5f23f6031..f5a8fb3ae9 100644
--- a/okhttp/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp/src/test/java/okhttp3/EventListenerTest.java
@@ -82,16 +82,14 @@
   private final RecordingEventListener listener = new RecordingEventListener();
   private final HandshakeCertificates handshakeCertificates = localhost();
 
-  private OkHttpClient client;
+  private OkHttpClient client = clientTestRule.newClientBuilder()
+      .eventListener(listener)
+      .build();
   private SocksProxy socksProxy;
 
   @Before public void setUp() {
     platform.assumeNotOpenJSSE();
 
-    client = clientTestRule.newClientBuilder()
-        .eventListener(listener)
-        .build();
-
     listener.forbidLock(RealConnectionPool.Companion.get(client.connectionPool()));
     listener.forbidLock(client.dispatcher());
   }
diff --git a/okhttp/src/test/java/okhttp3/InterceptorTest.java b/okhttp/src/test/java/okhttp3/InterceptorTest.java
index 3f0784d38f..b85efb6bd5 100644
--- a/okhttp/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp/src/test/java/okhttp3/InterceptorTest.java
@@ -39,7 +39,6 @@
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -50,13 +49,9 @@
   @Rule public MockWebServer server = new MockWebServer();
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
-  private OkHttpClient client;
+  private OkHttpClient client = clientTestRule.newClient();
   private RecordingCallback callback = new RecordingCallback();
 
-  @Before public void setUp() {
-    client = clientTestRule.newClient();
-  }
-
   @Test public void applicationInterceptorsCanShortCircuitResponses() throws Exception {
     server.shutdown(); // Accept no connections.
 
diff --git a/okhttp/src/test/java/okhttp3/OpenJSSETest.kt b/okhttp/src/test/java/okhttp3/OpenJSSETest.kt
index a992435760..8b4ac73922 100644
--- a/okhttp/src/test/java/okhttp3/OpenJSSETest.kt
+++ b/okhttp/src/test/java/okhttp3/OpenJSSETest.kt
@@ -36,13 +36,11 @@ class OpenJSSETest {
   @JvmField @Rule var platform = PlatformRule()
   @JvmField @Rule val clientTestRule = OkHttpClientTestRule()
   @JvmField @Rule val server = MockWebServer()
-  lateinit var client: OkHttpClient
+  var client = clientTestRule.newClient()
 
   @Before
   fun setUp() {
     platform.assumeOpenJSSE()
-
-    client = clientTestRule.newClient()
   }
 
   @Test
@@ -109,4 +107,4 @@ class OpenJSSETest {
         .build()
     server.useHttps(handshakeCertificates.sslSocketFactory(), false)
   }
-}
\ No newline at end of file
+}
diff --git a/okhttp/src/test/java/okhttp3/URLConnectionTest.java b/okhttp/src/test/java/okhttp3/URLConnectionTest.java
index 656122295c..230bf4495f 100644
--- a/okhttp/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp/src/test/java/okhttp3/URLConnectionTest.java
@@ -114,12 +114,11 @@
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client;
+  private OkHttpClient client = clientTestRule.newClient();
   private @Nullable Cache cache;
 
   @Before public void setUp() {
     server.setProtocolNegotiationEnabled(false);
-    client = clientTestRule.newClient();
   }
 
   @After public void tearDown() throws Exception {
diff --git a/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java b/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
index bf8b54343a..376642db16 100644
--- a/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
+++ b/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
@@ -25,7 +25,6 @@
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.testing.Flaky;
 import okio.BufferedSink;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -39,11 +38,7 @@
   @Rule public final MockWebServer server = new MockWebServer();
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
-  private OkHttpClient client;
-
-  @Before public void setUp() {
-    client = clientTestRule.newClient();
-  }
+  private final OkHttpClient client = clientTestRule.newClient();
 
   @Test public void defaultConfigIsNoTimeout() throws Exception {
     Request request = new Request.Builder()
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index 6fcf0f1da2..bbabd9ddae 100644
--- a/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -24,6 +24,7 @@
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.concurrent.TaskRunner;
 import okio.ByteString;
 import okio.Okio;
 import okio.Pipe;
@@ -372,7 +373,8 @@ public void initWebSocket(Random random, int pingIntervalMillis) throws IOExcept
           .request(new Request.Builder().url(url).build())
           .protocol(Protocol.HTTP_1_1)
           .build();
-      webSocket = new RealWebSocket(response.request(), listener, random, pingIntervalMillis);
+      webSocket = new RealWebSocket(
+          TaskRunner.INSTANCE, response.request(), listener, random, pingIntervalMillis);
       webSocket.initReaderAndWriter(name, this);
     }
 
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
index 2006f235e4..52ae73969f 100644
--- a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
@@ -36,6 +36,7 @@
 import okhttp3.TestLogHandler;
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
+import okhttp3.internal.concurrent.TaskRunner;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -72,28 +73,23 @@
   private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
   private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
   private final Random random = new Random(0);
-  private OkHttpClient client;
+  private OkHttpClient client = clientTestRule.newClientBuilder()
+      .writeTimeout(500, TimeUnit.MILLISECONDS)
+      .readTimeout(500, TimeUnit.MILLISECONDS)
+      .addInterceptor(chain -> {
+        Response response = chain.proceed(chain.request());
+        // Ensure application interceptors never see a null body.
+        assertThat(response.body()).isNotNull();
+        return response;
+      })
+      .build();
 
   @Before public void setUp() {
     platform.assumeNotOpenJSSE();
-
-    client = clientTestRule.newClientBuilder()
-        .writeTimeout(500, TimeUnit.MILLISECONDS)
-        .readTimeout(500, TimeUnit.MILLISECONDS)
-        .addInterceptor(chain -> {
-          Response response = chain.proceed(chain.request());
-          // Ensure application interceptors never see a null body.
-          assertThat(response.body()).isNotNull();
-          return response;
-        })
-        .build();
   }
 
   @After public void tearDown() {
     clientListener.assertExhausted();
-
-    // TODO: assert all connections are released once leaks are fixed
-    clientTestRule.abandonClient();
   }
 
   @Test public void textMessage() {
@@ -803,7 +799,7 @@ private RealWebSocket newWebSocket() {
 
   private RealWebSocket newWebSocket(Request request) {
     RealWebSocket webSocket = new RealWebSocket(
-        request, clientListener, random, client.pingIntervalMillis());
+        TaskRunner.INSTANCE, request, clientListener, random, client.pingIntervalMillis());
     webSocket.connect(client);
     return webSocket;
   }
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
index 0ab1d1857b..17a43c5fa7 100644
--- a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
@@ -44,7 +44,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
   }
 
   @Override public void onOpen(WebSocket webSocket, Response response) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onOpen", null);
+    Platform.get().log("[WS " + name + "] onOpen", Platform.INFO, null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
@@ -56,7 +56,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
   }
 
   @Override public void onMessage(WebSocket webSocket, ByteString bytes) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onMessage", null);
+    Platform.get().log("[WS " + name + "] onMessage", Platform.INFO, null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
@@ -69,7 +69,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
   }
 
   @Override public void onMessage(WebSocket webSocket, String text) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onMessage", null);
+    Platform.get().log("[WS " + name + "] onMessage", Platform.INFO, null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
@@ -82,7 +82,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
   }
 
   @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onClosing " + code, null);
+    Platform.get().log("[WS " + name + "] onClosing " + code, Platform.INFO, null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
@@ -94,7 +94,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
   }
 
   @Override public void onClosed(WebSocket webSocket, int code, String reason) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onClosed " + code, null);
+    Platform.get().log("[WS " + name + "] onClosed " + code, Platform.INFO, null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
@@ -106,7 +106,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
   }
 
   @Override public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response)  {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onFailure", t);
+    Platform.get().log("[WS " + name + "] onFailure", Platform.INFO, t);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
diff --git a/samples/guide/build.gradle b/samples/guide/build.gradle
index f7864f3c93..493dbe78bf 100644
--- a/samples/guide/build.gradle
+++ b/samples/guide/build.gradle
@@ -1,8 +1,11 @@
+apply plugin: 'kotlin-kapt'
+
 dependencies {
   implementation project(':okhttp')
   implementation project(':mockwebserver')
   implementation project(':okhttp-tls')
   implementation deps.moshi
+  kapt deps.moshiKotlin
 }
 
 tasks.withType(JavaCompile) {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
index 91c3fcc59f..87ea039730 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java
@@ -23,16 +23,12 @@
 import okhttp3.Response;
 
 public final class CertificatePinning {
-  private final OkHttpClient client;
-
-  public CertificatePinning() {
-    client = new OkHttpClient.Builder()
-        .certificatePinner(
-            new CertificatePinner.Builder()
-                .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
-                .build())
-        .build();
-  }
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .certificatePinner(
+          new CertificatePinner.Builder()
+              .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+              .build())
+      .build();
 
   public void run() throws Exception {
     Request request = new Request.Builder()
diff --git a/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java b/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
index a6d3000732..3c429bf23b 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java
@@ -25,9 +25,10 @@
 
   public ConfigureTimeouts() throws Exception {
     client = new OkHttpClient.Builder()
-        .connectTimeout(10, TimeUnit.SECONDS)
-        .writeTimeout(10, TimeUnit.SECONDS)
-        .readTimeout(30, TimeUnit.SECONDS)
+        .connectTimeout(5, TimeUnit.SECONDS)
+        .writeTimeout(5, TimeUnit.SECONDS)
+        .readTimeout(5, TimeUnit.SECONDS)
+        .callTimeout(10, TimeUnit.SECONDS)
         .build();
   }
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/AccessHeaders.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/AccessHeaders.kt
new file mode 100644
index 0000000000..ca9a946615
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/AccessHeaders.kt
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.io.IOException
+
+class AccessHeaders {
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://api.github.com/repos/square/okhttp/issues")
+        .header("User-Agent", "OkHttp Headers.java")
+        .addHeader("Accept", "application/json; q=0.5")
+        .addHeader("Accept", "application/vnd.github.v3+json")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println("Server: ${response.header("Server")}")
+      println("Date: ${response.header("Date")}")
+      println("Vary: ${response.headers("Vary")}")
+    }
+  }
+}
+
+fun main() {
+  AccessHeaders().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/AsynchronousGet.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/AsynchronousGet.kt
new file mode 100644
index 0000000000..ca35b3906c
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/AsynchronousGet.kt
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.Call
+import okhttp3.Callback
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.Response
+import java.io.IOException
+
+class AsynchronousGet {
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build()
+
+    client.newCall(request).enqueue(object : Callback {
+      override fun onFailure(call: Call, e: IOException) {
+        e.printStackTrace()
+      }
+
+      override fun onResponse(call: Call, response: Response) {
+        response.use {
+          if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+          for ((name, value) in response.headers) {
+            println("$name: $value")
+          }
+
+          println(response.body!!.string())
+        }
+      }
+    })
+  }
+}
+
+fun main() {
+  AsynchronousGet().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/Authenticate.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/Authenticate.kt
new file mode 100644
index 0000000000..7a56b425cd
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/Authenticate.kt
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.Authenticator
+import okhttp3.Credentials
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.Route
+import java.io.IOException
+
+class Authenticate {
+  private val client = OkHttpClient.Builder()
+      .authenticator(object : Authenticator {
+        @Throws(IOException::class)
+        override fun authenticate(route: Route?, response: Response): Request? {
+          if (response.request.header("Authorization") != null) {
+            return null // Give up, we've already attempted to authenticate.
+          }
+
+          println("Authenticating for response: $response")
+          println("Challenges: ${response.challenges()}")
+          val credential = Credentials.basic("jesse", "password1")
+          return response.request.newBuilder()
+              .header("Authorization", credential)
+              .build()
+        }
+      })
+      .build()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://publicobject.com/secrets/hellosecret.txt")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+}
+
+fun main() {
+  Authenticate().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/CacheResponse.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/CacheResponse.kt
new file mode 100644
index 0000000000..b700690f80
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/CacheResponse.kt
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.Cache
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.io.File
+import java.io.IOException
+
+class CacheResponse(cacheDirectory: File) {
+  private val client: OkHttpClient = OkHttpClient.Builder()
+      .cache(Cache(
+          directory = cacheDirectory,
+          maxSize = 10L * 1024L * 1024L // 1 MiB
+      ))
+      .build()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build()
+
+    val response1Body = client.newCall(request).execute().use {
+      if (!it.isSuccessful) throw IOException("Unexpected code $it")
+
+      println("Response 1 response:          $it")
+      println("Response 1 cache response:    ${it.cacheResponse}")
+      println("Response 1 network response:  ${it.networkResponse}")
+      return@use it.body!!.string()
+    }
+
+    val response2Body = client.newCall(request).execute().use {
+      if (!it.isSuccessful) throw IOException("Unexpected code $it")
+
+      println("Response 2 response:          $it")
+      println("Response 2 cache response:    ${it.cacheResponse}")
+      println("Response 2 network response:  ${it.networkResponse}")
+      return@use it.body!!.string()
+    }
+
+    println("Response 2 equals Response 1? " + (response1Body == response2Body))
+  }
+}
+
+fun main() {
+  CacheResponse(File("CacheResponse.tmp")).run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/CancelCall.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/CancelCall.kt
new file mode 100644
index 0000000000..b1932a3c30
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/CancelCall.kt
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.io.IOException
+import java.util.concurrent.Executors
+import java.util.concurrent.TimeUnit
+
+class CancelCall {
+  private val executor = Executors.newScheduledThreadPool(1)
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build()
+
+    val startNanos = System.nanoTime()
+    val call = client.newCall(request)
+
+    // Schedule a job to cancel the call in 1 second.
+    executor.schedule({
+      System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f)
+      call.cancel()
+      System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f)
+    }, 1, TimeUnit.SECONDS)
+
+    System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f)
+    try {
+      call.execute().use { response ->
+        System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
+            (System.nanoTime() - startNanos) / 1e9f, response)
+      }
+    } catch (e: IOException) {
+      System.out.printf("%.2f Call failed as expected: %s%n",
+          (System.nanoTime() - startNanos) / 1e9f, e)
+    }
+  }
+}
+
+fun main() {
+  CancelCall().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/CertificatePinning.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/CertificatePinning.kt
new file mode 100644
index 0000000000..ec3b79f452
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/CertificatePinning.kt
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.CertificatePinner
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.io.IOException
+
+class CertificatePinning {
+  private val client = OkHttpClient.Builder()
+      .certificatePinner(
+          CertificatePinner.Builder()
+              .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+              .build())
+      .build()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://publicobject.com/robots.txt")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      for (certificate in response.handshake!!.peerCertificates) {
+        println(CertificatePinner.pin(certificate))
+      }
+    }
+  }
+}
+
+fun main() {
+  CertificatePinning().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/ConfigureTimeouts.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/ConfigureTimeouts.kt
new file mode 100644
index 0000000000..4ffeeab97c
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/ConfigureTimeouts.kt
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.util.concurrent.TimeUnit
+
+class ConfigureTimeouts {
+  private val client: OkHttpClient = OkHttpClient.Builder()
+      .connectTimeout(5, TimeUnit.SECONDS)
+      .writeTimeout(5, TimeUnit.SECONDS)
+      .readTimeout(5, TimeUnit.SECONDS)
+      .callTimeout(10, TimeUnit.SECONDS)
+      .build()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      println("Response completed: $response")
+    }
+  }
+}
+
+fun main() {
+  ConfigureTimeouts().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/CustomTrust.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/CustomTrust.kt
new file mode 100644
index 0000000000..cae979e1a1
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/CustomTrust.kt
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.CertificatePinner
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okio.Buffer
+import java.io.IOException
+import java.io.InputStream
+import java.security.KeyStore
+import java.security.cert.CertificateFactory
+import java.util.Arrays
+import javax.net.ssl.KeyManagerFactory
+import javax.net.ssl.SSLContext
+import javax.net.ssl.TrustManager
+import javax.net.ssl.TrustManagerFactory
+import javax.net.ssl.X509TrustManager
+
+class CustomTrust {
+  private val client: OkHttpClient
+
+  init {
+    val trustManager = trustManagerForCertificates(trustedCertificatesInputStream())
+    val sslContext = SSLContext.getInstance("TLS")
+    sslContext.init(null, arrayOf<TrustManager>(trustManager), null)
+    val sslSocketFactory = sslContext.socketFactory
+
+    client = OkHttpClient.Builder()
+        .sslSocketFactory(sslSocketFactory, trustManager)
+        .build()
+  }
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      for ((name, value) in response.headers) {
+        println("$name: $value")
+      }
+
+      println(response.body!!.string())
+    }
+  }
+
+  /**
+   * Returns an input stream containing one or more certificate PEM files. This implementation just
+   * embeds the PEM files in Java strings; most applications will instead read this from a resource
+   * file that gets bundled with the application.
+   */
+  private fun trustedCertificatesInputStream(): InputStream {
+    // PEM files for root certificates of Comodo and Entrust. These two CAs are sufficient to view
+    // https://publicobject.com (Comodo) and https://squareup.com (Entrust). But they aren't
+    // sufficient to connect to most HTTPS sites including https://godaddy.com and https://visa.com.
+    // Typically developers will need to get a PEM file from their organization's TLS administrator.
+    val comodoRsaCertificationAuthority = """
+        |-----BEGIN CERTIFICATE-----
+        |MIIF2DCCA8CgAwIBAgIQTKr5yttjb+Af907YWwOGnTANBgkqhkiG9w0BAQwFADCB
+        |hTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4G
+        |A1UEBxMHU2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNV
+        |BAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAwMTE5
+        |MDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCBhTELMAkGA1UEBhMCR0IxGzAZBgNVBAgT
+        |EkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEaMBgGA1UEChMR
+        |Q09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBSU0EgQ2VydGlmaWNh
+        |dGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCR
+        |6FSS0gpWsawNJN3Fz0RndJkrN6N9I3AAcbxT38T6KhKPS38QVr2fcHK3YX/JSw8X
+        |pz3jsARh7v8Rl8f0hj4K+j5c+ZPmNHrZFGvnnLOFoIJ6dq9xkNfs/Q36nGz637CC
+        |9BR++b7Epi9Pf5l/tfxnQ3K9DADWietrLNPtj5gcFKt+5eNu/Nio5JIk2kNrYrhV
+        |/erBvGy2i/MOjZrkm2xpmfh4SDBF1a3hDTxFYPwyllEnvGfDyi62a+pGx8cgoLEf
+        |Zd5ICLqkTqnyg0Y3hOvozIFIQ2dOciqbXL1MGyiKXCJ7tKuY2e7gUYPDCUZObT6Z
+        |+pUX2nwzV0E8jVHtC7ZcryxjGt9XyD+86V3Em69FmeKjWiS0uqlWPc9vqv9JWL7w
+        |qP/0uK3pN/u6uPQLOvnoQ0IeidiEyxPx2bvhiWC4jChWrBQdnArncevPDt09qZah
+        |SL0896+1DSJMwBGB7FY79tOi4lu3sgQiUpWAk2nojkxl8ZEDLXB0AuqLZxUpaVIC
+        |u9ffUGpVRr+goyhhf3DQw6KqLCGqR84onAZFdr+CGCe01a60y1Dma/RMhnEw6abf
+        |Fobg2P9A3fvQQoh/ozM6LlweQRGBY84YcWsr7KaKtzFcOmpH4MN5WdYgGq/yapiq
+        |crxXStJLnbsQ/LBMQeXtHT1eKJ2czL+zUdqnR+WEUwIDAQABo0IwQDAdBgNVHQ4E
+        |FgQUu69+Aj36pvE8hI6t7jiY7NkyMtQwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB
+        |/wQFMAMBAf8wDQYJKoZIhvcNAQEMBQADggIBAArx1UaEt65Ru2yyTUEUAJNMnMvl
+        |wFTPoCWOAvn9sKIN9SCYPBMtrFaisNZ+EZLpLrqeLppysb0ZRGxhNaKatBYSaVqM
+        |4dc+pBroLwP0rmEdEBsqpIt6xf4FpuHA1sj+nq6PK7o9mfjYcwlYRm6mnPTXJ9OV
+        |2jeDchzTc+CiR5kDOF3VSXkAKRzH7JsgHAckaVd4sjn8OoSgtZx8jb8uk2Intzna
+        |FxiuvTwJaP+EmzzV1gsD41eeFPfR60/IvYcjt7ZJQ3mFXLrrkguhxuhoqEwWsRqZ
+        |CuhTLJK7oQkYdQxlqHvLI7cawiiFwxv/0Cti76R7CZGYZ4wUAc1oBmpjIXUDgIiK
+        |boHGhfKppC3n9KUkEEeDys30jXlYsQab5xoq2Z0B15R97QNKyvDb6KkBPvVWmcke
+        |jkk9u+UJueBPSZI9FoJAzMxZxuY67RIuaTxslbH9qh17f4a+Hg4yRvv7E491f0yL
+        |S0Zj/gA0QHDBw7mh3aZw4gSzQbzpgJHqZJx64SIDqZxubw5lT2yHh17zbqD5daWb
+        |QOhTsiedSrnAdyGN/4fy3ryM7xfft0kL0fJuMAsaDk527RH89elWsn2/x20Kk4yl
+        |0MC2Hb46TpSi125sC8KKfPog88Tk5c0NqMuRkrF8hey1FGlmDoLnzc7ILaZRfyHB
+        |NVOFBkpdn627G190
+        |-----END CERTIFICATE-----
+        |""".trimMargin()
+    val entrustRootCertificateAuthority = """
+        |-----BEGIN CERTIFICATE-----
+        |MIIEkTCCA3mgAwIBAgIERWtQVDANBgkqhkiG9w0BAQUFADCBsDELMAkGA1UEBhMC
+        |VVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xOTA3BgNVBAsTMHd3dy5lbnRydXN0
+        |Lm5ldC9DUFMgaXMgaW5jb3Jwb3JhdGVkIGJ5IHJlZmVyZW5jZTEfMB0GA1UECxMW
+        |KGMpIDIwMDYgRW50cnVzdCwgSW5jLjEtMCsGA1UEAxMkRW50cnVzdCBSb290IENl
+        |cnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTA2MTEyNzIwMjM0MloXDTI2MTEyNzIw
+        |NTM0MlowgbAxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMTkw
+        |NwYDVQQLEzB3d3cuZW50cnVzdC5uZXQvQ1BTIGlzIGluY29ycG9yYXRlZCBieSBy
+        |ZWZlcmVuY2UxHzAdBgNVBAsTFihjKSAyMDA2IEVudHJ1c3QsIEluYy4xLTArBgNV
+        |BAMTJEVudHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASIwDQYJ
+        |KoZIhvcNAQEBBQADggEPADCCAQoCggEBALaVtkNC+sZtKm9I35RMOVcF7sN5EUFo
+        |Nu3s/poBj6E4KPz3EEZmLk0eGrEaTsbRwJWIsMn/MYszA9u3g3s+IIRe7bJWKKf4
+        |4LlAcTfFy0cOlypowCKVYhXbR9n10Cv/gkvJrT7eTNuQgFA/CYqEAOwwCj0Yzfv9
+        |KlmaI5UXLEWeH25DeW0MXJj+SKfFI0dcXv1u5x609mhF0YaDW6KKjbHjKYD+JXGI
+        |rb68j6xSlkuqUY3kEzEZ6E5Nn9uss2rVvDlUccp6en+Q3X0dgNmBu1kmwhH+5pPi
+        |94DkZfs0Nw4pgHBNrziGLp5/V6+eF67rHMsoIV+2HNjnogQi+dPa2MsCAwEAAaOB
+        |sDCBrTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zArBgNVHRAEJDAi
+        |gA8yMDA2MTEyNzIwMjM0MlqBDzIwMjYxMTI3MjA1MzQyWjAfBgNVHSMEGDAWgBRo
+        |kORnpKZTgMeGZqTx90tD+4S9bTAdBgNVHQ4EFgQUaJDkZ6SmU4DHhmak8fdLQ/uE
+        |vW0wHQYJKoZIhvZ9B0EABBAwDhsIVjcuMTo0LjADAgSQMA0GCSqGSIb3DQEBBQUA
+        |A4IBAQCT1DCw1wMgKtD5Y+iRDAUgqV8ZyntyTtSx29CW+1RaGSwMCPeyvIWonX9t
+        |O1KzKtvn1ISMY/YPyyYBkVBs9F8U4pN0wBOeMDpQ47RgxRzwIkSNcUesyBrJ6Zua
+        |AGAT/3B+XxFNSRuzFVJ7yVTav52Vr2ua2J7p8eRDjeIRRDq/r72DQnNSi6q7pynP
+        |9WQcCk3RvKqsnyrQ/39/2n3qse0wJcGE2jTSW3iDVuycNsMm4hH2Z0kdkquM++v/
+        |eu6FSqdQgPCnXEqULl8FmTxSQeDNtGPPAUO6nIPcj2A781q0tHuu2guQOHXvgR1m
+        |0vdXcDazv/wor3ElhVsT/h5/WrQ8
+        |-----END CERTIFICATE-----
+        |""".trimMargin()
+    return Buffer()
+        .writeUtf8(comodoRsaCertificationAuthority)
+        .writeUtf8(entrustRootCertificateAuthority)
+        .inputStream()
+  }
+
+  /**
+   * Returns a trust manager that trusts `certificates` and none other. HTTPS services whose
+   * certificates have not been signed by these certificates will fail with a
+   * `SSLHandshakeException`.
+   *
+   * This can be used to replace the host platform's built-in trusted certificates with a custom
+   * set. This is useful in development where certificate authority-trusted certificates aren't
+   * available. Or in production, to avoid reliance on third-party certificate authorities.
+   *
+   * See also [CertificatePinner], which can limit trusted certificates while still using
+   * the host platform's built-in trust store.
+   *
+   * Warning: Customizing Trusted Certificates is Dangerous!
+   * -------------------------------------------------------
+   *
+   * Relying on your own trusted certificates limits your server team's ability to update their
+   * TLS certificates. By installing a specific set of trusted certificates, you take on additional
+   * operational complexity and limit your ability to migrate between certificate authorities. Do
+   * not use custom trusted certificates in production without the blessing of your server's TLS
+   * administrator.
+   */
+  private fun trustManagerForCertificates(inputStream: InputStream): X509TrustManager {
+    val certificateFactory = CertificateFactory.getInstance("X.509")
+    val certificates = certificateFactory.generateCertificates(inputStream)
+    require(!certificates.isEmpty()) { "expected non-empty set of trusted certificates" }
+
+    // Put the certificates a key store.
+    val password = "password".toCharArray() // Any password will work.
+    val keyStore = newEmptyKeyStore(password)
+    for ((index, certificate) in certificates.withIndex()) {
+      val certificateAlias = index.toString()
+      keyStore.setCertificateEntry(certificateAlias, certificate)
+    }
+
+    // Use it to build an X509 trust manager.
+    val keyManagerFactory = KeyManagerFactory.getInstance(
+        KeyManagerFactory.getDefaultAlgorithm()
+    )
+    keyManagerFactory.init(keyStore, password)
+    val trustManagerFactory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm()
+    )
+    trustManagerFactory.init(keyStore)
+    val trustManagers = trustManagerFactory.trustManagers
+    check(trustManagers.size == 1 && trustManagers[0] is X509TrustManager) {
+      "Unexpected default trust managers: ${Arrays.toString(trustManagers)}"
+    }
+    return trustManagers[0] as X509TrustManager
+  }
+
+  private fun newEmptyKeyStore(password: CharArray): KeyStore {
+    val keyStore = KeyStore.getInstance(KeyStore.getDefaultType())
+    val inputStream: InputStream? = null // By convention, 'null' creates an empty key store.
+    keyStore.load(inputStream, password)
+    return keyStore
+  }
+}
+
+fun main() {
+  CustomTrust().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/ParseResponseWithMoshi.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/ParseResponseWithMoshi.kt
new file mode 100644
index 0000000000..a5a8ac4633
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/ParseResponseWithMoshi.kt
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import com.squareup.moshi.JsonClass
+import com.squareup.moshi.Moshi
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.io.IOException
+
+class ParseResponseWithMoshi {
+  private val client = OkHttpClient()
+  private val moshi = Moshi.Builder().build()
+  private val gistJsonAdapter = moshi.adapter(Gist::class.java)
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://api.github.com/gists/c2a7c39532239ff261be")
+        .build()
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      val gist = gistJsonAdapter.fromJson(response.body!!.source())
+
+      for ((key, value) in gist!!.files!!) {
+        println(key)
+        println(value.content)
+      }
+    }
+  }
+
+  @JsonClass(generateAdapter = true)
+  data class Gist(var files: Map<String, GistFile>?)
+
+  @JsonClass(generateAdapter = true)
+  data class GistFile(var content: String?)
+}
+
+fun main() {
+  ParseResponseWithMoshi().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/PerCallSettings.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/PerCallSettings.kt
new file mode 100644
index 0000000000..4ff5f5a027
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/PerCallSettings.kt
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.io.IOException
+import java.util.concurrent.TimeUnit
+
+class PerCallSettings {
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
+        .build()
+
+    // Copy to customize OkHttp for this request.
+    val client1 = client.newBuilder()
+        .readTimeout(500, TimeUnit.MILLISECONDS)
+        .build()
+    try {
+      client1.newCall(request).execute().use { response ->
+        println("Response 1 succeeded: $response")
+      }
+    } catch (e: IOException) {
+      println("Response 1 failed: $e")
+    }
+
+    // Copy to customize OkHttp for this request.
+    val client2 = client.newBuilder()
+        .readTimeout(3000, TimeUnit.MILLISECONDS)
+        .build()
+    try {
+      client2.newCall(request).execute().use { response ->
+        println("Response 2 succeeded: $response")
+      }
+    } catch (e: IOException) {
+      println("Response 2 failed: $e")
+    }
+  }
+}
+
+fun main() {
+  PerCallSettings().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/PostFile.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/PostFile.kt
new file mode 100644
index 0000000000..cfb983a02d
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/PostFile.kt
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.MediaType.Companion.toMediaType
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.RequestBody.Companion.asRequestBody
+import java.io.File
+import java.io.IOException
+
+class PostFile {
+  private val client = OkHttpClient()
+
+  fun run() {
+    val file = File("README.md")
+
+    val request = Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(file.asRequestBody(MEDIA_TYPE_MARKDOWN))
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+
+  companion object {
+    val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
+  }
+}
+
+fun main() {
+  PostFile().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/PostForm.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/PostForm.kt
new file mode 100644
index 0000000000..189c6f1d7d
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/PostForm.kt
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.FormBody
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.io.IOException
+
+class PostForm {
+  private val client = OkHttpClient()
+
+  fun run() {
+    val formBody = FormBody.Builder()
+        .add("search", "Jurassic Park")
+        .build()
+    val request = Request.Builder()
+        .url("https://en.wikipedia.org/w/index.php")
+        .post(formBody)
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+}
+
+fun main() {
+  PostForm().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/PostMultipart.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/PostMultipart.kt
new file mode 100644
index 0000000000..7a56bd3a7f
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/PostMultipart.kt
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.MediaType.Companion.toMediaType
+import okhttp3.MultipartBody
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.RequestBody.Companion.asRequestBody
+import java.io.File
+import java.io.IOException
+
+class PostMultipart {
+  private val client = OkHttpClient()
+
+  fun run() {
+    // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
+    val requestBody = MultipartBody.Builder()
+        .setType(MultipartBody.FORM)
+        .addFormDataPart("title", "Square Logo")
+        .addFormDataPart("image", "logo-square.png",
+            File("docs/images/logo-square.png").asRequestBody(MEDIA_TYPE_PNG))
+        .build()
+
+    val request = Request.Builder()
+        .header("Authorization", "Client-ID $IMGUR_CLIENT_ID")
+        .url("https://api.imgur.com/3/image")
+        .post(requestBody)
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+
+  companion object {
+    /**
+     * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
+     * these examples, please request your own client ID! https://api.imgur.com/oauth2
+     */
+    private val IMGUR_CLIENT_ID = "9199fdef135c122"
+    private val MEDIA_TYPE_PNG = "image/png".toMediaType()
+  }
+}
+
+fun main() {
+  PostMultipart().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/PostStreaming.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/PostStreaming.kt
new file mode 100644
index 0000000000..5cfcd96a06
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/PostStreaming.kt
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.MediaType.Companion.toMediaType
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.RequestBody
+import okio.BufferedSink
+import java.io.IOException
+
+class PostStreaming {
+  private val client = OkHttpClient()
+
+  fun run() {
+    val requestBody = object : RequestBody() {
+      override fun contentType() = MEDIA_TYPE_MARKDOWN
+
+      override fun writeTo(sink: BufferedSink) {
+        sink.writeUtf8("Numbers\n")
+        sink.writeUtf8("-------\n")
+        for (i in 2..997) {
+          sink.writeUtf8(String.format(" * $i = ${factor(i)}\n"))
+        }
+      }
+
+      private fun factor(n: Int): String {
+        for (i in 2 until n) {
+          val x = n / i
+          if (x * i == n) return "${factor(x)} × $i"
+        }
+        return n.toString()
+      }
+    }
+
+    val request = Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(requestBody)
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+
+  companion object {
+    val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
+  }
+}
+
+fun main() {
+  PostStreaming().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/PostString.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/PostString.kt
new file mode 100644
index 0000000000..d77fda90f8
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/PostString.kt
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.MediaType.Companion.toMediaType
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.RequestBody.Companion.toRequestBody
+import java.io.IOException
+
+class PostString {
+  private val client = OkHttpClient()
+
+  fun run() {
+    val postBody = """
+        |Releases
+        |--------
+        |
+        | * _1.0_ May 6, 2013
+        | * _1.1_ June 15, 2013
+        | * _1.2_ August 11, 2013
+        |""".trimMargin()
+
+    val request = Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(postBody.toRequestBody(MEDIA_TYPE_MARKDOWN))
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      println(response.body!!.string())
+    }
+  }
+
+  companion object {
+    val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
+  }
+}
+
+fun main() {
+  PostString().run()
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/kt/SynchronousGet.kt b/samples/guide/src/main/java/okhttp3/recipes/kt/SynchronousGet.kt
new file mode 100644
index 0000000000..d5e0634d17
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/kt/SynchronousGet.kt
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes.kt
+
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import java.io.IOException
+
+class SynchronousGet {
+  private val client = OkHttpClient()
+
+  fun run() {
+    val request = Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build()
+
+    client.newCall(request).execute().use { response ->
+      if (!response.isSuccessful) throw IOException("Unexpected code $response")
+
+      for ((name, value) in response.headers) {
+        println("$name: $value")
+      }
+
+      println(response.body!!.string())
+    }
+  }
+}
+
+fun main() {
+  SynchronousGet().run()
+}
