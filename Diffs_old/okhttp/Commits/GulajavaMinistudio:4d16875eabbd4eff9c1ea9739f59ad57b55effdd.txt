diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
index 663b6f4038..9d45fdb14b 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
@@ -122,20 +122,21 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
     set(Settings.MAX_FRAME_SIZE, Http2.INITIAL_MAX_FRAME_SIZE)
   }
 
-  /**
-   * The total number of bytes consumed by the application, but not yet acknowledged by sending a
-   * `WINDOW_UPDATE` frame on this connection.
-   */
-  // Visible for testing
-  var unacknowledgedBytesRead = 0L
+  /** The total number of bytes consumed by the application. */
+  var readBytesTotal = 0L
     private set
 
-  /**
-   * Count of bytes that can be written on the connection before receiving a window update.
-   */
-  // Visible for testing
-  var bytesLeftInWriteWindow: Long = peerSettings.initialWindowSize.toLong()
-    internal set
+  /** The total number of bytes acknowledged by outgoing `WINDOW_UPDATE` frames. */
+  var readBytesAcknowledged = 0L
+    private set
+
+  /** The total number of bytes produced by the application. */
+  var writeBytesTotal = 0L
+    private set
+
+  /** The total number of bytes permitted to be produced according to `WINDOW_UPDATE` frames. */
+  var writeBytesMaximum: Long = peerSettings.initialWindowSize.toLong()
+    private set
 
   internal var receivedInitialPeerSettings = false
   internal val socket: Socket = builder.socket
@@ -177,10 +178,11 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
       peerSettings.getMaxConcurrentStreams(Integer.MAX_VALUE)
 
   @Synchronized internal fun updateConnectionFlowControl(read: Long) {
-    unacknowledgedBytesRead += read
-    if (unacknowledgedBytesRead >= okHttpSettings.initialWindowSize / 2) {
-      writeWindowUpdateLater(0, unacknowledgedBytesRead)
-      unacknowledgedBytesRead = 0
+    readBytesTotal += read
+    val readBytesToAcknowledge = (readBytesTotal - readBytesAcknowledged)
+    if (readBytesToAcknowledge >= okHttpSettings.initialWindowSize / 2) {
+      writeWindowUpdateLater(0, readBytesToAcknowledge)
+      readBytesAcknowledged += readBytesToAcknowledge
     }
   }
 
@@ -238,7 +240,9 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
         streamId = nextStreamId
         nextStreamId += 2
         stream = Http2Stream(streamId, this, outFinished, inFinished, null)
-        flushHeaders = (!out || bytesLeftInWriteWindow == 0L || stream.bytesLeftInWriteWindow == 0L)
+        flushHeaders = !out ||
+            writeBytesTotal >= writeBytesMaximum ||
+            stream.writeBytesTotal >= stream.writeBytesMaximum
         if (stream.isOpen) {
           streams[streamId] = stream
         }
@@ -298,7 +302,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
       var toWrite: Int
       synchronized(this@Http2Connection) {
         try {
-          while (bytesLeftInWriteWindow <= 0L) {
+          while (writeBytesTotal >= writeBytesMaximum) {
             // Before blocking, confirm that the stream we're writing is still open. It's possible
             // that the stream has since been closed (such as if this write timed out.)
             if (!streams.containsKey(streamId)) {
@@ -311,9 +315,9 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
           throw InterruptedIOException()
         }
 
-        toWrite = minOf(byteCount, bytesLeftInWriteWindow).toInt()
+        toWrite = minOf(byteCount, writeBytesMaximum - writeBytesTotal).toInt()
         toWrite = minOf(toWrite, writer.maxDataLength())
-        bytesLeftInWriteWindow -= toWrite.toLong()
+        writeBytesTotal += toWrite.toLong()
       }
 
       byteCount -= toWrite.toLong()
@@ -746,7 +750,7 @@ class Http2Connection internal constructor(builder: Builder) : Closeable {
     override fun windowUpdate(streamId: Int, windowSizeIncrement: Long) {
       if (streamId == 0) {
         synchronized(this@Http2Connection) {
-          bytesLeftInWriteWindow += windowSizeIncrement
+          writeBytesMaximum += windowSizeIncrement
           this@Http2Connection.notifyAll()
         }
       } else {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt
index 045150fed3..1f1b0142a2 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt
@@ -44,20 +44,20 @@ class Http2Stream internal constructor(
   // Internal state is guarded by this. No long-running or potentially blocking operations are
   // performed while the lock is held.
 
-  /**
-   * The total number of bytes consumed by the application (with [FramingSource.read]), but
-   * not yet acknowledged by sending a `WINDOW_UPDATE` frame on this stream.
-   */
-  var unacknowledgedBytesRead = 0L
+  /** The total number of bytes consumed by the application. */
+  var readBytesTotal = 0L
     internal set
 
-  /**
-   * Count of bytes that can be written on the stream before receiving a window update. Even if this
-   * is positive, writes will block until there available bytes in
-   * [Http2Connection.bytesLeftInWriteWindow].
-   */
-  // guarded by this
-  var bytesLeftInWriteWindow: Long = connection.peerSettings.initialWindowSize.toLong()
+  /** The total number of bytes acknowledged by outgoing `WINDOW_UPDATE` frames. */
+  var readBytesAcknowledged = 0L
+    internal set
+
+  /** The total number of bytes produced by the application. */
+  var writeBytesTotal = 0L
+    internal set
+
+  /** The total number of bytes permitted to be produced by incoming `WINDOW_UPDATE` frame. */
+  var writeBytesMaximum: Long = connection.peerSettings.initialWindowSize.toLong()
     internal set
 
   /** Received headers yet to be [taken][takeHeaders], or [read][FramingSource.read]. */
@@ -185,7 +185,7 @@ class Http2Stream internal constructor(
     // flow-control window is fully depleted.
     if (!flushHeaders) {
       synchronized(connection) {
-        flushHeaders = connection.bytesLeftInWriteWindow == 0L
+        flushHeaders = (connection.writeBytesTotal >= connection.writeBytesMaximum)
       }
     }
 
@@ -358,14 +358,15 @@ class Http2Stream internal constructor(
             } else if (readBuffer.size > 0L) {
               // Prepare to read bytes. Start by moving them to the caller's buffer.
               readBytesDelivered = readBuffer.read(sink, minOf(byteCount, readBuffer.size))
-              unacknowledgedBytesRead += readBytesDelivered
+              readBytesTotal += readBytesDelivered
 
+              val unacknowledgedBytesRead = (readBytesTotal - readBytesAcknowledged)
               if (errorExceptionToDeliver == null &&
                   unacknowledgedBytesRead >= connection.okHttpSettings.initialWindowSize / 2) {
                 // Flow control: notify the peer that we're ready for more data! Only send a
                 // WINDOW_UPDATE if the stream isn't in error.
                 connection.writeWindowUpdateLater(id, unacknowledgedBytesRead)
-                unacknowledgedBytesRead = 0
+                readBytesAcknowledged = readBytesTotal
               }
             } else if (!finished && errorExceptionToDeliver == null) {
               // Nothing to do. Wait until that changes then try again.
@@ -521,7 +522,10 @@ class Http2Stream internal constructor(
       synchronized(this@Http2Stream) {
         writeTimeout.enter()
         try {
-          while (bytesLeftInWriteWindow <= 0L && !finished && !closed && errorCode == null) {
+          while (writeBytesTotal >= writeBytesMaximum &&
+              !finished &&
+              !closed &&
+              errorCode == null) {
             waitForIo() // Wait until we receive a WINDOW_UPDATE for this stream.
           }
         } finally {
@@ -529,8 +533,8 @@ class Http2Stream internal constructor(
         }
 
         checkOutNotClosed() // Kick out if the stream was reset or closed while waiting.
-        toWrite = minOf(bytesLeftInWriteWindow, sendBuffer.size)
-        bytesLeftInWriteWindow -= toWrite
+        toWrite = minOf(writeBytesMaximum - writeBytesTotal, sendBuffer.size)
+        writeBytesTotal += toWrite
       }
 
       writeTimeout.enter()
@@ -601,7 +605,7 @@ class Http2Stream internal constructor(
 
   /** [delta] will be negative if a settings frame initial window is smaller than the last. */
   fun addBytesToWriteWindow(delta: Long) {
-    bytesLeftInWriteWindow += delta
+    writeBytesMaximum += delta
     if (delta > 0L) {
       this@Http2Stream.notifyAll()
     }
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index f8d5fb82ca..40b904edfb 100644
--- a/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -37,7 +37,6 @@
 import okio.Source;
 import okio.Utf8;
 import org.junit.After;
-import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
@@ -114,9 +113,10 @@
     // This stream was created *after* the connection settings were adjusted.
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
 
-    assertThat(connection.getPeerSettings().getInitialWindowSize()).isEqualTo(3368);
+    assertThat(connection.getPeerSettings().getInitialWindowSize()).isEqualTo(3368L);
     // New Stream is has the most recent initial window size.
-    assertThat(stream.getBytesLeftInWriteWindow()).isEqualTo(3368);
+    assertThat(stream.getWriteBytesTotal()).isEqualTo(0L);
+    assertThat(stream.getWriteBytesMaximum()).isEqualTo(3368L);
   }
 
   @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
@@ -229,7 +229,8 @@
     InFrame frame3 = peer.takeFrame();
     assertThat(frame3.type).isEqualTo(Http2.TYPE_RST_STREAM);
 
-    assertThat(connection.getUnacknowledgedBytesRead()).isEqualTo(2048);
+    assertThat(connection.getReadBytesAcknowledged()).isEqualTo(0L);
+    assertThat(connection.getReadBytesTotal()).isEqualTo(2048L);
   }
 
   @Test public void receiveGoAwayHttp2() throws Exception {
@@ -307,7 +308,8 @@
     Http2Connection connection = connect(peer);
     connection.getOkHttpSettings().set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(stream.getUnacknowledgedBytesRead()).isEqualTo(0);
+    assertThat(stream.getReadBytesAcknowledged()).isEqualTo(0L);
+    assertThat(stream.getReadBytesTotal()).isEqualTo(0L);
     assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
@@ -1637,7 +1639,8 @@
     Http2Connection connection = connect(peer);
     connection.getOkHttpSettings().set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(stream.getUnacknowledgedBytesRead()).isEqualTo(0);
+    assertThat(stream.getReadBytesAcknowledged()).isEqualTo(0L);
+    assertThat(stream.getReadBytesTotal()).isEqualTo(0L);
     assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
@@ -1749,14 +1752,18 @@
     out1.flush();
 
     // Check that we've filled the window for both the stream and also the connection.
-    assertThat(connection.getBytesLeftInWriteWindow()).isEqualTo(0);
-    assertThat(connection.getStream(3).getBytesLeftInWriteWindow()).isEqualTo(0);
+    assertThat(connection.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
+    assertThat(connection.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
+    assertThat(stream1.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
+    assertThat(stream1.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
 
     // receiving a window update on the connection will unblock new streams.
     connection.getReaderRunnable().windowUpdate(0, 3);
 
-    assertThat(connection.getBytesLeftInWriteWindow()).isEqualTo(3);
-    assertThat(connection.getStream(3).getBytesLeftInWriteWindow()).isEqualTo(0);
+    assertThat(connection.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
+    assertThat(connection.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE + 3);
+    assertThat(stream1.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
+    assertThat(stream1.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
 
     // Another stream should be able to send data even though 1 is blocked.
     Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
@@ -1764,10 +1771,12 @@
     out2.writeUtf8("foo");
     out2.flush();
 
-    assertThat(connection.getBytesLeftInWriteWindow()).isEqualTo(0);
-    assertThat(connection.getStream(3).getBytesLeftInWriteWindow()).isEqualTo(0);
-    assertThat(connection.getStream(5).getBytesLeftInWriteWindow()).isEqualTo(
-        (long) (DEFAULT_INITIAL_WINDOW_SIZE - 3));
+    assertThat(connection.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE + 3);
+    assertThat(connection.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE + 3);
+    assertThat(stream1.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
+    assertThat(stream1.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
+    assertThat(stream2.getWriteBytesTotal()).isEqualTo(3L);
+    assertThat(stream2.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
   }
 
   @Test public void remoteOmitsInitialSettings() throws Exception {
