diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
index 067726354f..253fcbda87 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
@@ -19,6 +19,8 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.math.BigInteger;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
 import java.security.KeyPair;
 import java.security.KeyPairGenerator;
@@ -48,6 +50,8 @@
   }
 
   private static final long ONE_DAY_MILLIS = 1000L * 60 * 60 * 24;
+  private static SSLContext localhost; // Lazily initialized.
+
   private final String hostName;
   private long notBefore = System.currentTimeMillis();
   private long notAfter = System.currentTimeMillis() + ONE_DAY_MILLIS;
@@ -60,6 +64,20 @@ public SslContextBuilder(String hostName) {
     this.hostName = hostName;
   }
 
+  /** Returns a new SSL context for this host's current localhost address. */
+  public static synchronized SSLContext localhost() {
+    if (localhost == null) {
+      try {
+        localhost = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
+      } catch (GeneralSecurityException e) {
+        throw new RuntimeException(e);
+      } catch (UnknownHostException e) {
+        throw new RuntimeException(e);
+      }
+    }
+    return localhost;
+  }
+
   public SSLContext build() throws GeneralSecurityException {
     char[] password = "password".toCharArray();
 
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
index 7371f2e3dc..7e7dbb9f4b 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
@@ -24,12 +24,10 @@
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
-import java.net.InetAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.Arrays;
 import java.util.List;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import org.eclipse.jetty.npn.NextProtoNego;
@@ -154,8 +152,7 @@ public static void main(String... args) throws Exception {
     }
 
     SpdyServer server = new SpdyServer(new File(args[0]));
-    SSLContext sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    server.useHttps(sslContext.getSocketFactory());
+    server.useHttps(SslContextBuilder.localhost().getSocketFactory());
     server.run();
   }
 }
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
index 22e6a95916..7b7e1125cc 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
@@ -15,8 +15,6 @@
  */
 package com.squareup.okhttp.mockwebserver;
 
-import junit.framework.TestCase;
-
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.net.URL;
@@ -24,6 +22,7 @@
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
+import junit.framework.TestCase;
 
 public class CustomDispatcherTest extends TestCase {
 
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
index 9c5b008a20..f2adbf58f2 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp.internal;
 
+import java.io.ByteArrayInputStream;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.File;
@@ -25,8 +26,8 @@
 import java.io.Reader;
 import java.io.StringWriter;
 import java.io.UnsupportedEncodingException;
-import java.net.Socket;
 import java.net.ServerSocket;
+import java.net.Socket;
 import java.net.URI;
 import java.net.URL;
 import java.nio.ByteOrder;
@@ -34,6 +35,7 @@
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.ThreadFactory;
@@ -43,9 +45,7 @@
 public final class Util {
   public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
   public static final String[] EMPTY_STRING_ARRAY = new String[0];
-
-  /** A cheap and type-safe constant for the ISO-8859-1 Charset. */
-  public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
+  public static final InputStream EMPTY_INPUT_STREAM = new ByteArrayInputStream(EMPTY_BYTE_ARRAY);
 
   /** A cheap and type-safe constant for the US-ASCII Charset. */
   public static final Charset US_ASCII = Charset.forName("US-ASCII");
@@ -72,14 +72,10 @@ private static int getEffectivePort(String scheme, int specifiedPort) {
     return specifiedPort != -1 ? specifiedPort : getDefaultPort(scheme);
   }
 
-  public static int getDefaultPort(String scheme) {
-    if ("http".equalsIgnoreCase(scheme)) {
-      return 80;
-    } else if ("https".equalsIgnoreCase(scheme)) {
-      return 443;
-    } else {
-      return -1;
-    }
+  public static int getDefaultPort(String protocol) {
+    if ("http".equals(protocol)) return 80;
+    if ("https".equals(protocol)) return 443;
+    return -1;
   }
 
   public static void checkOffsetAndCount(int arrayLength, int offset, int count) {
@@ -382,6 +378,11 @@ private static String bytesToHexString(byte[] bytes) {
     return Collections.unmodifiableList(new ArrayList<T>(list));
   }
 
+  /** Returns an immutable list containing {@code elements}. */
+  public static <T> List<T> immutableList(T[] elements) {
+    return Collections.unmodifiableList(Arrays.asList(elements.clone()));
+  }
+
   public static ThreadFactory daemonThreadFactory(final String name) {
     return new ThreadFactory() {
       @Override public Thread newThread(Runnable runnable) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index a6b798da9d..a9d41822a9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -20,7 +20,6 @@
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpTransport;
-import com.squareup.okhttp.internal.http.RawHeaders;
 import com.squareup.okhttp.internal.http.SpdyTransport;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import java.io.BufferedInputStream;
@@ -32,7 +31,6 @@
 import java.net.Proxy;
 import java.net.Socket;
 import java.net.SocketTimeoutException;
-import java.net.URL;
 import java.util.Arrays;
 import javax.net.ssl.SSLSocket;
 
@@ -86,6 +84,7 @@
   private SpdyConnection spdyConnection;
   private int httpMinorVersion = 1; // Assume HTTP/1.1
   private long idleStartTimeNs;
+  private Handshake handshake;
 
   public Connection(Route route) {
     this.route = route;
@@ -93,9 +92,8 @@ public Connection(Route route) {
 
   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)
       throws IOException {
-    if (connected) {
-      throw new IllegalStateException("already connected");
-    }
+    if (connected) throw new IllegalStateException("already connected");
+
     connected = true;
     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();
     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);
@@ -105,14 +103,9 @@ public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelReq
 
     if (route.address.sslSocketFactory != null) {
       upgradeToTls(tunnelRequest);
+    } else {
+      streamWrapper();
     }
-
-    // Use MTU-sized buffers to send fewer packets.
-    int mtu = Platform.get().getMtu(socket);
-    if (mtu < 1024) mtu = 1024;
-    if (mtu > 8192) mtu = 8192;
-    in = new BufferedInputStream(in, mtu);
-    out = new BufferedOutputStream(out, mtu);
   }
 
   /**
@@ -152,6 +145,8 @@ private void upgradeToTls(TunnelRequest tunnelRequest) throws IOException {
 
     out = sslSocket.getOutputStream();
     in = sslSocket.getInputStream();
+    handshake = Handshake.get(sslSocket.getSession());
+    streamWrapper();
 
     byte[] selectedProtocol;
     if (useNpn && (selectedProtocol = platform.getNpnSelectedProtocol(sslSocket)) != null) {
@@ -255,6 +250,10 @@ public long getIdleStartTimeNs() {
     return spdyConnection == null ? idleStartTimeNs : spdyConnection.getIdleStartTimeNs();
   }
 
+  public Handshake getHandshake() {
+    return handshake;
+  }
+
   /** Returns the transport appropriate for this connection. */
   public Object newTransport(HttpEngine httpEngine) throws IOException {
     return (spdyConnection != null)
@@ -270,10 +269,6 @@ public boolean isSpdy() {
     return spdyConnection != null;
   }
 
-  public SpdyConnection getSpdyConnection() {
-    return spdyConnection;
-  }
-
   /**
    * Returns the minor HTTP version that should be used for future requests on
    * this connection. Either 0 for HTTP/1.0, or 1 for HTTP/1.1. The default
@@ -307,29 +302,29 @@ public void updateReadTimeout(int newTimeout) throws IOException {
    * retried if the proxy requires authorization.
    */
   private void makeTunnel(TunnelRequest tunnelRequest) throws IOException {
-    RawHeaders requestHeaders = tunnelRequest.getRequestHeaders();
+    Request request = tunnelRequest.getRequest();
+    String requestLine = tunnelRequest.requestLine();
     while (true) {
-      out.write(requestHeaders.toBytes());
-      RawHeaders responseHeaders = RawHeaders.fromBytes(in);
+      HttpTransport.writeRequest(out, request.headers(), requestLine);
+      Response response = HttpTransport.readResponse(in).request(request).build();
 
-      switch (responseHeaders.getResponseCode()) {
+      switch (response.code()) {
         case HTTP_OK:
           return;
         case HTTP_PROXY_AUTH:
-          requestHeaders = new RawHeaders(requestHeaders);
-          URL url = new URL("https", tunnelRequest.host, tunnelRequest.port, "/");
-          boolean credentialsFound = HttpAuthenticator.processAuthHeader(
-              route.address.authenticator, HTTP_PROXY_AUTH, responseHeaders, requestHeaders,
-              route.proxy, url);
-          if (credentialsFound) {
-            continue;
-          } else {
-            throw new IOException("Failed to authenticate with proxy");
-          }
+          request = HttpAuthenticator.processAuthHeader(
+              route.address.authenticator, response, route.proxy);
+          if (request != null) continue;
+          throw new IOException("Failed to authenticate with proxy");
         default:
           throw new IOException(
-              "Unexpected response code for CONNECT: " + responseHeaders.getResponseCode());
+              "Unexpected response code for CONNECT: " + response.code());
       }
     }
   }
+
+  private void streamWrapper() throws IOException {
+    in = new BufferedInputStream(in, 4096);
+    out = new BufferedOutputStream(out, 256);
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index 6a6c273ad6..c5fa343f55 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -17,7 +17,6 @@
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.HttpURLConnection;
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -33,8 +32,8 @@
   private final Map<Object, List<Job>> enqueuedJobs = new LinkedHashMap<Object, List<Job>>();
 
   public synchronized void enqueue(
-      HttpURLConnection connection, Request request, Response.Receiver responseReceiver) {
-    Job job = new Job(this, connection, request, responseReceiver);
+      OkHttpClient client, Request request, Response.Receiver responseReceiver) {
+    Job job = new Job(this, client, request, responseReceiver);
     List<Job> jobsForTag = enqueuedJobs.get(request.tag());
     if (jobsForTag == null) {
       jobsForTag = new ArrayList<Job>(2);
@@ -53,28 +52,33 @@ public synchronized void cancel(Object tag) {
   }
 
   synchronized void finished(Job job) {
-    List<Job> jobs = enqueuedJobs.get(job.request.tag());
+    List<Job> jobs = enqueuedJobs.get(job.tag());
     if (jobs != null) jobs.remove(job);
   }
 
   static class RealResponseBody extends Response.Body {
-    private final HttpURLConnection connection;
+    private final Response response;
     private final InputStream in;
 
-    RealResponseBody(HttpURLConnection connection, InputStream in) {
-      this.connection = connection;
+    RealResponseBody(Response response, InputStream in) {
+      this.response = response;
       this.in = in;
     }
 
-    @Override public String contentType() {
-      return connection.getHeaderField("Content-Type");
+    @Override public boolean ready() throws IOException {
+      return true;
+    }
+
+    @Override public MediaType contentType() {
+      String contentType = response.getContentType();
+      return contentType != null ? MediaType.parse(contentType) : null;
     }
 
     @Override public long contentLength() {
-      return connection.getContentLength(); // TODO: getContentLengthLong
+      return response.getContentLength();
     }
 
-    @Override public InputStream byteStream() throws IOException {
+    @Override public InputStream byteStream() {
       return in;
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Failure.java b/okhttp/src/main/java/com/squareup/okhttp/Failure.java
index a3547003a5..b5c69c6e01 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Failure.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Failure.java
@@ -21,7 +21,7 @@
  * <h3>Warning: Experimental OkHttp 2.0 API</h3>
  * This class is in beta. APIs are subject to change!
  */
-/* OkHttp 2.0: public */ class Failure {
+public final class Failure {
   private final Request request;
   private final Throwable exception;
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Handshake.java b/okhttp/src/main/java/com/squareup/okhttp/Handshake.java
new file mode 100644
index 0000000000..d9f5366757
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Handshake.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.Collections;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+
+/**
+ * A record of a TLS handshake. For HTTPS clients, the client is <i>local</i>
+ * and the remote server is its <i>peer</i>.
+ *
+ * <p>This value object describes a completed handshake. Use {@link
+ * javax.net.ssl.SSLSocketFactory} to set policy for new handshakes.
+ */
+public final class Handshake {
+  private final String cipherSuite;
+  private final List<Certificate> peerCertificates;
+  private final List<Certificate> localCertificates;
+
+  private Handshake(
+      String cipherSuite, List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+    this.cipherSuite = cipherSuite;
+    this.peerCertificates = peerCertificates;
+    this.localCertificates = localCertificates;
+  }
+
+  public static Handshake get(SSLSession session) {
+    String cipherSuite = session.getCipherSuite();
+    if (cipherSuite == null) throw new IllegalStateException("cipherSuite == null");
+
+    Certificate[] peerCertificates;
+    try {
+      peerCertificates = session.getPeerCertificates();
+    } catch (SSLPeerUnverifiedException ignored) {
+      peerCertificates = null;
+    }
+    List<Certificate> peerCertificatesList = peerCertificates != null
+        ? Util.immutableList(peerCertificates)
+        : Collections.<Certificate>emptyList();
+
+    Certificate[] localCertificates = session.getLocalCertificates();
+    List<Certificate> localCertificatesList = localCertificates != null
+        ? Util.immutableList(localCertificates)
+        : Collections.<Certificate>emptyList();
+
+    return new Handshake(cipherSuite, peerCertificatesList, localCertificatesList);
+  }
+
+  public static Handshake get(
+      String cipherSuite, List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+    if (cipherSuite == null) throw new IllegalArgumentException("cipherSuite == null");
+    return new Handshake(cipherSuite, Util.immutableList(peerCertificates),
+        Util.immutableList(localCertificates));
+  }
+
+  /** Returns a cipher suite name like "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA". */
+  public String cipherSuite() {
+    return cipherSuite;
+  }
+
+  /** Returns a possibly-empty list of certificates that identify the remote peer. */
+  public List<Certificate> peerCertificates() {
+    return peerCertificates;
+  }
+
+  /** Returns the remote peer's principle, or null if that peer is anonymous. */
+  public Principal peerPrincipal() {
+    return !peerCertificates.isEmpty()
+        ? ((X509Certificate) peerCertificates.get(0)).getSubjectX500Principal()
+        : null;
+  }
+
+  /** Returns a possibly-empty list of certificates that identify this peer. */
+  public List<Certificate> localCertificates() {
+    return localCertificates;
+  }
+
+  /** Returns the local principle, or null if this peer is anonymous. */
+  public Principal localPrincipal() {
+    return !localCertificates.isEmpty()
+        ? ((X509Certificate) localCertificates.get(0)).getSubjectX500Principal()
+        : null;
+  }
+
+  @Override public boolean equals(Object other) {
+    if (!(other instanceof Handshake)) return false;
+    Handshake that = (Handshake) other;
+    return cipherSuite.equals(that.cipherSuite)
+        && peerCertificates.equals(that.peerCertificates)
+        && localCertificates.equals(that.localCertificates);
+  }
+
+  @Override public int hashCode() {
+    int result = 17;
+    result = 31 * result + cipherSuite.hashCode();
+    result = 31 * result + peerCertificates.hashCode();
+    result = 31 * result + localCertificates.hashCode();
+    return result;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java b/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
index 8210318276..7873fa444d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
@@ -20,12 +20,7 @@
 import com.squareup.okhttp.internal.DiskLruCache;
 import com.squareup.okhttp.internal.StrictLineReader;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
-import com.squareup.okhttp.internal.http.HttpsEngine;
-import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
-import com.squareup.okhttp.internal.http.RawHeaders;
-import com.squareup.okhttp.internal.http.ResponseHeaders;
+import com.squareup.okhttp.internal.http.Headers;
 import java.io.BufferedWriter;
 import java.io.ByteArrayInputStream;
 import java.io.File;
@@ -38,22 +33,17 @@
 import java.io.Writer;
 import java.net.CacheRequest;
 import java.net.CacheResponse;
-import java.net.HttpURLConnection;
 import java.net.ResponseCache;
-import java.net.SecureCacheResponse;
 import java.net.URI;
 import java.net.URLConnection;
-import java.security.Principal;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateEncodingException;
 import java.security.cert.CertificateException;
 import java.security.cert.CertificateFactory;
-import java.security.cert.X509Certificate;
-import java.util.Arrays;
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocket;
 
 import static com.squareup.okhttp.internal.Util.US_ASCII;
 import static com.squareup.okhttp.internal.Util.UTF_8;
@@ -115,7 +105,7 @@
  *         connection.addRequestProperty("Cache-Control", "max-stale=" + maxStale);
  * }</pre>
  */
-public final class HttpResponseCache extends ResponseCache {
+public final class HttpResponseCache extends ResponseCache implements OkResponseCache {
   // TODO: add APIs to iterate the cache?
   private static final int VERSION = 201105;
   private static final int ENTRY_METADATA = 0;
@@ -131,51 +121,25 @@
   private int hitCount;
   private int requestCount;
 
-  /**
-   * Although this class only exposes the limited ResponseCache API, it
-   * implements the full OkResponseCache interface. This field is used as a
-   * package private handle to the complete implementation. It delegates to
-   * public and private members of this type.
-   */
-  final OkResponseCache okResponseCache = new OkResponseCache() {
-    @Override public CacheResponse get(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) throws IOException {
-      return HttpResponseCache.this.get(uri, requestMethod, requestHeaders);
-    }
-
-    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-      return HttpResponseCache.this.put(uri, connection);
-    }
-
-    @Override public void maybeRemove(String requestMethod, URI uri) throws IOException {
-      HttpResponseCache.this.maybeRemove(requestMethod, uri);
-    }
-
-    @Override public void update(
-        CacheResponse conditionalCacheHit, HttpURLConnection connection) throws IOException {
-      HttpResponseCache.this.update(conditionalCacheHit, connection);
-    }
-
-    @Override public void trackConditionalCacheHit() {
-      HttpResponseCache.this.trackConditionalCacheHit();
-    }
-
-    @Override public void trackResponse(ResponseSource source) {
-      HttpResponseCache.this.trackResponse(source);
-    }
-  };
-
   public HttpResponseCache(File directory, long maxSize) throws IOException {
     cache = DiskLruCache.open(directory, VERSION, ENTRY_COUNT, maxSize);
   }
 
-  private String uriToKey(URI uri) {
-    return Util.hash(uri.toString());
+  @Override public CacheResponse get(URI uri, String s, Map<String, List<String>> stringListMap)
+      throws IOException {
+    throw new UnsupportedOperationException("This is not a general purpose response cache.");
   }
 
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) {
-    String key = uriToKey(uri);
+  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+    throw new UnsupportedOperationException("This is not a general purpose response cache.");
+  }
+
+  private static String urlToKey(Request requst) {
+    return Util.hash(requst.urlString());
+  }
+
+  @Override public Response get(Request request) {
+    String key = urlToKey(request);
     DiskLruCache.Snapshot snapshot;
     Entry entry;
     try {
@@ -189,24 +153,20 @@ private String uriToKey(URI uri) {
       return null;
     }
 
-    if (!entry.matches(uri, requestMethod, requestHeaders)) {
-      snapshot.close();
+    Response response = entry.response(request, snapshot);
+
+    if (!entry.matches(request, response)) {
+      Util.closeQuietly(response.body());
       return null;
     }
 
-    return entry.isHttps() ? new EntrySecureCacheResponse(entry, snapshot)
-        : new EntryCacheResponse(entry, snapshot);
+    return response;
   }
 
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    if (!(urlConnection instanceof HttpURLConnection)) {
-      return null;
-    }
+  @Override public CacheRequest put(Response response) throws IOException {
+    String requestMethod = response.request().method();
 
-    HttpURLConnection httpConnection = (HttpURLConnection) urlConnection;
-    String requestMethod = httpConnection.getRequestMethod();
-
-    if (maybeRemove(requestMethod, uri)) {
+    if (maybeRemove(response.request())) {
       return null;
     }
     if (!requestMethod.equals("GET")) {
@@ -216,23 +176,14 @@ private String uriToKey(URI uri) {
       return null;
     }
 
-    HttpEngine httpEngine = getHttpEngine(httpConnection);
-    if (httpEngine == null) {
-      // Don't cache unless the HTTP implementation is ours.
-      return null;
-    }
-
-    ResponseHeaders response = httpEngine.getResponseHeaders();
     if (response.hasVaryAll()) {
       return null;
     }
 
-    RawHeaders varyHeaders =
-        httpEngine.getRequestHeaders().getHeaders().getAll(response.getVaryFields());
-    Entry entry = new Entry(uri, varyHeaders, httpConnection);
+    Entry entry = new Entry(response);
     DiskLruCache.Editor editor = null;
     try {
-      editor = cache.edit(uriToKey(uri));
+      editor = cache.edit(urlToKey(response.request()));
       if (editor == null) {
         return null;
       }
@@ -244,15 +195,11 @@ private String uriToKey(URI uri) {
     }
   }
 
-  /**
-   * Returns true if the supplied {@code requestMethod} potentially invalidates an entry in the
-   * cache.
-   */
-  private boolean maybeRemove(String requestMethod, URI uri) {
-    if (requestMethod.equals("POST") || requestMethod.equals("PUT") || requestMethod.equals(
-        "DELETE")) {
+  @Override public boolean maybeRemove(Request request) {
+    String method = request.method();
+    if (method.equals("POST") || method.equals("PUT") || method.equals("DELETE")) {
       try {
-        cache.remove(uriToKey(uri));
+        cache.remove(urlToKey(request));
       } catch (IOException ignored) {
         // The cache cannot be written.
       }
@@ -261,20 +208,12 @@ private boolean maybeRemove(String requestMethod, URI uri) {
     return false;
   }
 
-  private void update(CacheResponse conditionalCacheHit, HttpURLConnection httpConnection)
-      throws IOException {
-    HttpEngine httpEngine = getHttpEngine(httpConnection);
-    URI uri = httpEngine.getUri();
-    ResponseHeaders response = httpEngine.getResponseHeaders();
-    RawHeaders varyHeaders =
-        httpEngine.getRequestHeaders().getHeaders().getAll(response.getVaryFields());
-    Entry entry = new Entry(uri, varyHeaders, httpConnection);
-    DiskLruCache.Snapshot snapshot = (conditionalCacheHit instanceof EntryCacheResponse)
-        ? ((EntryCacheResponse) conditionalCacheHit).snapshot
-        : ((EntrySecureCacheResponse) conditionalCacheHit).snapshot;
+  @Override public void update(Response cached, Response network) {
+    Entry entry = new Entry(network);
+    DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
     DiskLruCache.Editor editor = null;
     try {
-      editor = snapshot.edit(); // returns null if snapshot is not current
+      editor = snapshot.edit(); // Returns null if snapshot is not current.
       if (editor != null) {
         entry.writeTo(editor);
         editor.commit();
@@ -294,16 +233,6 @@ private void abortQuietly(DiskLruCache.Editor editor) {
     }
   }
 
-  private HttpEngine getHttpEngine(URLConnection httpConnection) {
-    if (httpConnection instanceof HttpURLConnectionImpl) {
-      return ((HttpURLConnectionImpl) httpConnection).getHttpEngine();
-    } else if (httpConnection instanceof HttpsURLConnectionImpl) {
-      return ((HttpsURLConnectionImpl) httpConnection).getHttpEngine();
-    } else {
-      return null;
-    }
-  }
-
   /**
    * Closes the cache and deletes all of its stored values. This will delete
    * all files in the cache directory including files that weren't created by
@@ -345,7 +274,7 @@ public boolean isClosed() {
     return cache.isClosed();
   }
 
-  private synchronized void trackResponse(ResponseSource source) {
+  @Override public synchronized void trackResponse(ResponseSource source) {
     requestCount++;
 
     switch (source) {
@@ -359,7 +288,7 @@ private synchronized void trackResponse(ResponseSource source) {
     }
   }
 
-  private synchronized void trackConditionalCacheHit() {
+  @Override public synchronized void trackConditionalCacheHit() {
     hitCount++;
   }
 
@@ -426,13 +355,12 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
   }
 
   private static final class Entry {
-    private final String uri;
-    private final RawHeaders varyHeaders;
+    private final String url;
+    private final Headers varyHeaders;
     private final String requestMethod;
-    private final RawHeaders responseHeaders;
-    private final String cipherSuite;
-    private final Certificate[] peerCertificates;
-    private final Certificate[] localCertificates;
+    private final String statusLine;
+    private final Headers responseHeaders;
+    private final Handshake handshake;
 
     /**
      * Reads an entry from an input stream. A typical entry looks like this:
@@ -486,121 +414,90 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
     public Entry(InputStream in) throws IOException {
       try {
         StrictLineReader reader = new StrictLineReader(in, US_ASCII);
-        uri = reader.readLine();
+        url = reader.readLine();
         requestMethod = reader.readLine();
-        varyHeaders = new RawHeaders();
+        Headers.Builder varyHeadersBuilder = new Headers.Builder();
         int varyRequestHeaderLineCount = reader.readInt();
         for (int i = 0; i < varyRequestHeaderLineCount; i++) {
-          varyHeaders.addLine(reader.readLine());
+          varyHeadersBuilder.addLine(reader.readLine());
         }
+        varyHeaders = varyHeadersBuilder.build();
 
-        responseHeaders = new RawHeaders();
-        responseHeaders.setStatusLine(reader.readLine());
+        statusLine = reader.readLine();
+        Headers.Builder responseHeadersBuilder = new Headers.Builder();
         int responseHeaderLineCount = reader.readInt();
         for (int i = 0; i < responseHeaderLineCount; i++) {
-          responseHeaders.addLine(reader.readLine());
+          responseHeadersBuilder.addLine(reader.readLine());
         }
+        responseHeaders = responseHeadersBuilder.build();
 
         if (isHttps()) {
           String blank = reader.readLine();
           if (blank.length() > 0) {
             throw new IOException("expected \"\" but was \"" + blank + "\"");
           }
-          cipherSuite = reader.readLine();
-          peerCertificates = readCertArray(reader);
-          localCertificates = readCertArray(reader);
+          String cipherSuite = reader.readLine();
+          List<Certificate> peerCertificates = readCertificateList(reader);
+          List<Certificate> localCertificates = readCertificateList(reader);
+          handshake = Handshake.get(cipherSuite, peerCertificates, localCertificates);
         } else {
-          cipherSuite = null;
-          peerCertificates = null;
-          localCertificates = null;
+          handshake = null;
         }
       } finally {
         in.close();
       }
     }
 
-    public Entry(URI uri, RawHeaders varyHeaders, HttpURLConnection httpConnection)
-        throws IOException {
-      this.uri = uri.toString();
-      this.varyHeaders = varyHeaders;
-      this.requestMethod = httpConnection.getRequestMethod();
-      this.responseHeaders = RawHeaders.fromMultimap(httpConnection.getHeaderFields(), true);
-
-      SSLSocket sslSocket = getSslSocket(httpConnection);
-      if (sslSocket != null) {
-        cipherSuite = sslSocket.getSession().getCipherSuite();
-        Certificate[] peerCertificatesNonFinal = null;
-        try {
-          peerCertificatesNonFinal = sslSocket.getSession().getPeerCertificates();
-        } catch (SSLPeerUnverifiedException ignored) {
-        }
-        peerCertificates = peerCertificatesNonFinal;
-        localCertificates = sslSocket.getSession().getLocalCertificates();
-      } else {
-        cipherSuite = null;
-        peerCertificates = null;
-        localCertificates = null;
-      }
-    }
-
-    /**
-     * Returns the SSL socket used by {@code httpConnection} for HTTPS, nor null
-     * if the connection isn't using HTTPS. Since we permit redirects across
-     * protocols (HTTP to HTTPS or vice versa), the implementation type of the
-     * connection doesn't necessarily match the implementation type of its HTTP
-     * engine.
-     */
-    private SSLSocket getSslSocket(HttpURLConnection httpConnection) {
-      HttpEngine engine = httpConnection instanceof HttpsURLConnectionImpl
-          ? ((HttpsURLConnectionImpl) httpConnection).getHttpEngine()
-          : ((HttpURLConnectionImpl) httpConnection).getHttpEngine();
-      return engine instanceof HttpsEngine
-          ? ((HttpsEngine) engine).getSslSocket()
-          : null;
+    public Entry(Response response) {
+      this.url = response.request().urlString();
+      this.varyHeaders = response.request().headers().getAll(response.getVaryFields());
+      this.requestMethod = response.request().method();
+      this.statusLine = response.statusLine();
+      this.responseHeaders = response.headers();
+      this.handshake = response.handshake();
     }
 
     public void writeTo(DiskLruCache.Editor editor) throws IOException {
       OutputStream out = editor.newOutputStream(ENTRY_METADATA);
       Writer writer = new BufferedWriter(new OutputStreamWriter(out, UTF_8));
 
-      writer.write(uri + '\n');
+      writer.write(url + '\n');
       writer.write(requestMethod + '\n');
-      writer.write(Integer.toString(varyHeaders.length()) + '\n');
-      for (int i = 0; i < varyHeaders.length(); i++) {
-        writer.write(varyHeaders.getFieldName(i) + ": " + varyHeaders.getValue(i) + '\n');
+      writer.write(Integer.toString(varyHeaders.size()) + '\n');
+      for (int i = 0; i < varyHeaders.size(); i++) {
+        writer.write(varyHeaders.name(i) + ": " + varyHeaders.value(i) + '\n');
       }
 
-      writer.write(responseHeaders.getStatusLine() + '\n');
-      writer.write(Integer.toString(responseHeaders.length()) + '\n');
-      for (int i = 0; i < responseHeaders.length(); i++) {
-        writer.write(responseHeaders.getFieldName(i) + ": " + responseHeaders.getValue(i) + '\n');
+      writer.write(statusLine + '\n');
+      writer.write(Integer.toString(responseHeaders.size()) + '\n');
+      for (int i = 0; i < responseHeaders.size(); i++) {
+        writer.write(responseHeaders.name(i) + ": " + responseHeaders.value(i) + '\n');
       }
 
       if (isHttps()) {
         writer.write('\n');
-        writer.write(cipherSuite + '\n');
-        writeCertArray(writer, peerCertificates);
-        writeCertArray(writer, localCertificates);
+        writer.write(handshake.cipherSuite() + '\n');
+        writeCertArray(writer, handshake.peerCertificates());
+        writeCertArray(writer, handshake.localCertificates());
       }
       writer.close();
     }
 
     private boolean isHttps() {
-      return uri.startsWith("https://");
+      return url.startsWith("https://");
     }
 
-    private Certificate[] readCertArray(StrictLineReader reader) throws IOException {
+    private List<Certificate> readCertificateList(StrictLineReader reader) throws IOException {
       int length = reader.readInt();
-      if (length == -1) {
-        return null;
-      }
+      if (length == -1) return Collections.emptyList(); // OkHttp v1.2 used -1 to indicate null.
+
       try {
         CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-        Certificate[] result = new Certificate[length];
-        for (int i = 0; i < result.length; i++) {
+        List<Certificate> result = new ArrayList<Certificate>(length);
+        for (int i = 0; i < length; i++) {
           String line = reader.readLine();
           byte[] bytes = Base64.decode(line.getBytes("US-ASCII"));
-          result[i] = certificateFactory.generateCertificate(new ByteArrayInputStream(bytes));
+          result.add(certificateFactory.generateCertificate(new ByteArrayInputStream(bytes)));
         }
         return result;
       } catch (CertificateException e) {
@@ -608,13 +505,9 @@ private boolean isHttps() {
       }
     }
 
-    private void writeCertArray(Writer writer, Certificate[] certificates) throws IOException {
-      if (certificates == null) {
-        writer.write("-1\n");
-        return;
-      }
+    private void writeCertArray(Writer writer, List<Certificate> certificates) throws IOException {
       try {
-        writer.write(Integer.toString(certificates.length) + '\n');
+        writer.write(Integer.toString(certificates.size()) + '\n');
         for (Certificate certificate : certificates) {
           byte[] bytes = certificate.getEncoded();
           String line = Base64.encode(bytes);
@@ -625,98 +518,64 @@ private void writeCertArray(Writer writer, Certificate[] certificates) throws IO
       }
     }
 
-    public boolean matches(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) {
-      return this.uri.equals(uri.toString())
-          && this.requestMethod.equals(requestMethod)
-          && new ResponseHeaders(uri, responseHeaders).varyMatches(varyHeaders.toMultimap(false),
-          requestHeaders);
-    }
-  }
-
-  /**
-   * Returns an input stream that reads the body of a snapshot, closing the
-   * snapshot when the stream is closed.
-   */
-  private static InputStream newBodyInputStream(final DiskLruCache.Snapshot snapshot) {
-    return new FilterInputStream(snapshot.getInputStream(ENTRY_BODY)) {
-      @Override public void close() throws IOException {
-        snapshot.close();
-        super.close();
-      }
-    };
-  }
-
-  static class EntryCacheResponse extends CacheResponse {
-    private final Entry entry;
-    private final DiskLruCache.Snapshot snapshot;
-    private final InputStream in;
-
-    public EntryCacheResponse(Entry entry, DiskLruCache.Snapshot snapshot) {
-      this.entry = entry;
-      this.snapshot = snapshot;
-      this.in = newBodyInputStream(snapshot);
+    public boolean matches(Request request, Response response) {
+      return url.equals(request.urlString())
+          && requestMethod.equals(request.method())
+          && response.varyMatches(varyHeaders, request);
     }
 
-    @Override public Map<String, List<String>> getHeaders() {
-      return entry.responseHeaders.toMultimap(true);
-    }
-
-    @Override public InputStream getBody() {
-      return in;
+    public Response response(Request request, DiskLruCache.Snapshot snapshot) {
+      String contentType = responseHeaders.get("Content-Type");
+      String contentLength = responseHeaders.get("Content-Length");
+      return new Response.Builder()
+          .request(request)
+          .statusLine(statusLine)
+          .headers(responseHeaders)
+          .body(new CacheResponseBody(snapshot, contentType, contentLength))
+          .handshake(handshake)
+          .build();
     }
   }
 
-  static class EntrySecureCacheResponse extends SecureCacheResponse {
-    private final Entry entry;
+  private static class CacheResponseBody extends Response.Body {
     private final DiskLruCache.Snapshot snapshot;
-    private final InputStream in;
+    private final InputStream bodyIn;
+    private final String contentType;
+    private final String contentLength;
 
-    public EntrySecureCacheResponse(Entry entry, DiskLruCache.Snapshot snapshot) {
-      this.entry = entry;
+    public CacheResponseBody(final DiskLruCache.Snapshot snapshot,
+        String contentType, String contentLength) {
       this.snapshot = snapshot;
-      this.in = newBodyInputStream(snapshot);
-    }
-
-    @Override public Map<String, List<String>> getHeaders() {
-      return entry.responseHeaders.toMultimap(true);
-    }
+      this.contentType = contentType;
+      this.contentLength = contentLength;
 
-    @Override public InputStream getBody() {
-      return in;
-    }
-
-    @Override public String getCipherSuite() {
-      return entry.cipherSuite;
+      // This input stream closes the snapshot when the stream is closed.
+      this.bodyIn = new FilterInputStream(snapshot.getInputStream(ENTRY_BODY)) {
+        @Override public void close() throws IOException {
+          snapshot.close();
+          super.close();
+        }
+      };
     }
 
-    @Override public List<Certificate> getServerCertificateChain()
-        throws SSLPeerUnverifiedException {
-      if (entry.peerCertificates == null || entry.peerCertificates.length == 0) {
-        throw new SSLPeerUnverifiedException(null);
-      }
-      return Arrays.asList(entry.peerCertificates.clone());
+    @Override public boolean ready() throws IOException {
+      return true;
     }
 
-    @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-      if (entry.peerCertificates == null || entry.peerCertificates.length == 0) {
-        throw new SSLPeerUnverifiedException(null);
-      }
-      return ((X509Certificate) entry.peerCertificates[0]).getSubjectX500Principal();
+    @Override public MediaType contentType() {
+      return contentType != null ? MediaType.parse(contentType) : null;
     }
 
-    @Override public List<Certificate> getLocalCertificateChain() {
-      if (entry.localCertificates == null || entry.localCertificates.length == 0) {
-        return null;
+    @Override public long contentLength() {
+      try {
+        return contentLength != null ? Long.parseLong(contentLength) : -1;
+      } catch (NumberFormatException e) {
+        return -1;
       }
-      return Arrays.asList(entry.localCertificates.clone());
     }
 
-    @Override public Principal getLocalPrincipal() {
-      if (entry.localCertificates == null || entry.localCertificates.length == 0) {
-        return null;
-      }
-      return ((X509Certificate) entry.localCertificates[0]).getSubjectX500Principal();
+    @Override public InputStream byteStream() {
+      return bodyIn;
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Job.java b/okhttp/src/main/java/com/squareup/okhttp/Job.java
index 3a453847a2..550caf95f0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Job.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Job.java
@@ -15,27 +15,45 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.http.HttpAuthenticator;
+import com.squareup.okhttp.internal.http.HttpEngine;
 import java.io.IOException;
-import java.net.HttpURLConnection;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.URL;
+
+import static com.squareup.okhttp.internal.Util.getEffectivePort;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_MOVED_PERM;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_MOVED_TEMP;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_MULT_CHOICE;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_PROXY_AUTH;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_SEE_OTHER;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_UNAUTHORIZED;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
 final class Job implements Runnable {
-  final HttpURLConnection connection;
-  final Request request;
-  final Response.Receiver responseReceiver;
-  final Dispatcher dispatcher;
+  private final Dispatcher dispatcher;
+  private final OkHttpClient client;
+  private final Response.Receiver responseReceiver;
+
+  /** The request; possibly a consequence of redirects or auth headers. */
+  private Request request;
 
-  public Job(Dispatcher dispatcher, HttpURLConnection connection, Request request,
+  public Job(Dispatcher dispatcher, OkHttpClient client, Request request,
       Response.Receiver responseReceiver) {
     this.dispatcher = dispatcher;
-    this.connection = connection;
+    this.client = client;
     this.request = request;
     this.responseReceiver = responseReceiver;
   }
 
+  Object tag() {
+    return request.tag();
+  }
+
   @Override public void run() {
     try {
-      sendRequest();
-      Response response = readResponse();
+      Response response = execute();
       responseReceiver.onResponse(response);
     } catch (IOException e) {
       responseReceiver.onFailure(new Failure.Builder()
@@ -43,43 +61,128 @@ public Job(Dispatcher dispatcher, HttpURLConnection connection, Request request,
           .exception(e)
           .build());
     } finally {
-      connection.disconnect();
+      // TODO: close the response body
+      // TODO: release the HTTP engine (potentially multiple!)
       dispatcher.finished(this);
     }
   }
 
-  private HttpURLConnection sendRequest() throws IOException {
-    for (int i = 0; i < request.headerCount(); i++) {
-      connection.addRequestProperty(request.headerName(i), request.headerValue(i));
-    }
-    Request.Body body = request.body();
-    if (body != null) {
-      connection.setDoOutput(true);
-      long contentLength = body.contentLength();
-      if (contentLength == -1 || contentLength > Integer.MAX_VALUE) {
-        connection.setChunkedStreamingMode(0);
-      } else {
-        // Don't call setFixedLengthStreamingMode(long); that's only available on Java 1.7+.
-        connection.setFixedLengthStreamingMode((int) contentLength);
+  private Response execute() throws IOException {
+    Connection connection = null;
+    Response redirectedBy = null;
+
+    while (true) {
+      Request.Body body = request.body();
+      if (body != null) {
+        MediaType contentType = body.contentType();
+        if (contentType == null) throw new IllegalStateException("contentType == null");
+
+        Request.Builder requestBuilder = request.newBuilder();
+        requestBuilder.header("Content-Type", contentType.toString());
+
+        long contentLength = body.contentLength();
+        if (contentLength != -1) {
+          requestBuilder.setContentLength(contentLength);
+          requestBuilder.removeHeader("Transfer-Encoding");
+        } else {
+          requestBuilder.header("Transfer-Encoding", "chunked");
+          requestBuilder.removeHeader("Content-Length");
+        }
+
+        request = requestBuilder.build();
       }
-      body.writeTo(connection.getOutputStream());
+
+      HttpEngine engine = newEngine(connection);
+      engine.sendRequest();
+
+      if (body != null) {
+        body.writeTo(engine.getRequestBody());
+      }
+
+      engine.readResponse();
+
+      Response engineResponse = engine.getResponse();
+      Response response = engineResponse.newBuilder()
+          .body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody()))
+          .redirectedBy(redirectedBy)
+          .build();
+
+      Request redirect = processResponse(engine, response);
+
+      if (redirect == null) {
+        engine.automaticallyReleaseConnectionToPool();
+        return response;
+      }
+
+      // TODO: fail if too many redirects
+      // TODO: fail if not following redirects
+      // TODO: release engine
+
+      connection = sameConnection(request, redirect) ? engine.getConnection() : null;
+      redirectedBy = response;
+      request = redirect;
     }
-    return connection;
   }
 
-  private Response readResponse() throws IOException {
-    int responseCode = connection.getResponseCode();
-    Response.Builder responseBuilder = new Response.Builder(request, responseCode);
+  HttpEngine newEngine(Connection connection) throws IOException {
+    return new HttpEngine(client, request, false, connection, null);
+  }
+
+  /**
+   * Figures out the HTTP request to make in response to receiving {@code
+   * response}. This will either add authentication headers or follow
+   * redirects. If a follow-up is either unnecessary or not applicable, this
+   * returns null.
+   */
+  private Request processResponse(HttpEngine engine, Response response) throws IOException {
+    Request request = response.request();
+    Proxy selectedProxy = engine.getRoute() != null
+        ? engine.getRoute().getProxy()
+        : client.getProxy();
+    int responseCode = response.code();
 
-    for (int i = 0; true; i++) {
-      String name = connection.getHeaderFieldKey(i);
-      if (name == null) break;
-      String value = connection.getHeaderField(i);
-      responseBuilder.addHeader(name, value);
+    switch (responseCode) {
+      case HTTP_PROXY_AUTH:
+        if (selectedProxy.type() != Proxy.Type.HTTP) {
+          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+        }
+        // fall-through
+      case HTTP_UNAUTHORIZED:
+        return HttpAuthenticator.processAuthHeader(
+            client.getAuthenticator(), response, selectedProxy);
+
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+      case HTTP_TEMP_REDIRECT:
+        String method = request.method();
+        if (responseCode == HTTP_TEMP_REDIRECT && !method.equals("GET") && !method.equals("HEAD")) {
+          // "If the 307 status code is received in response to a request other than GET or HEAD,
+          // the user agent MUST NOT automatically redirect the request"
+          return null;
+        }
+
+        String location = response.header("Location");
+        if (location == null) {
+          return null;
+        }
+
+        URL url = new URL(request.url(), location);
+        if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) {
+          return null; // Don't follow redirects to unsupported protocols.
+        }
+
+        return this.request.newBuilder().url(url).build();
+
+      default:
+        return null;
     }
+  }
 
-    responseBuilder.body(new Dispatcher.RealResponseBody(connection, connection.getInputStream()));
-    // TODO: set redirectedBy
-    return responseBuilder.build();
+  static boolean sameConnection(Request a, Request b) {
+    return a.url().getHost().equals(b.url().getHost())
+        && getEffectivePort(a.url()) == getEffectivePort(b.url())
+        && a.url().getProtocol().equals(b.url().getProtocol());
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index 945da1bfda..37f83f7dcd 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -19,7 +19,6 @@
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
 import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
-import com.squareup.okhttp.internal.http.OkResponseCacheAdapter;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.net.CookieHandler;
 import java.net.HttpURLConnection;
@@ -38,7 +37,7 @@
 import javax.net.ssl.SSLSocketFactory;
 
 /** Configures and creates HTTP connections. */
-public final class OkHttpClient implements URLStreamHandlerFactory {
+public final class OkHttpClient implements URLStreamHandlerFactory, Cloneable {
   private static final List<String> DEFAULT_TRANSPORTS
       = Util.immutableList(Arrays.asList("spdy/3", "http/1.1"));
 
@@ -48,7 +47,7 @@
   private List<String> transports;
   private ProxySelector proxySelector;
   private CookieHandler cookieHandler;
-  private ResponseCache responseCache;
+  private OkResponseCache responseCache;
   private SSLSocketFactory sslSocketFactory;
   private HostnameVerifier hostnameVerifier;
   private OkAuthenticator authenticator;
@@ -62,11 +61,6 @@ public OkHttpClient() {
     dispatcher = new Dispatcher();
   }
 
-  private OkHttpClient(OkHttpClient copyFrom) {
-    routeDatabase = copyFrom.routeDatabase;
-    dispatcher = copyFrom.dispatcher;
-  }
-
   /**
    * Sets the default connect timeout for new connections. A value of 0 means no timeout.
    *
@@ -169,24 +163,40 @@ public CookieHandler getCookieHandler() {
    *
    * <p>If unset, the {@link ResponseCache#getDefault() system-wide default}
    * response cache will be used.
+   *
+   * @deprecated OkHttp 2 dropped support for java.net.ResponseCache. That API
+   *     is broken for many reasons: URI instead of URL, no conditional updates,
+   *     no invalidation, and no mechanism for tracking hit rates. Use
+   *     {@link #setOkResponseCache} instead.
    */
+  @Deprecated
   public OkHttpClient setResponseCache(ResponseCache responseCache) {
-    this.responseCache = responseCache;
-    return this;
+    if (responseCache instanceof OkResponseCache) {
+      return setOkResponseCache((OkResponseCache) responseCache);
+    }
+    throw new UnsupportedOperationException("OkHttp 2 dropped support for java.net.ResponseCache. "
+        + "Use setOkResponseCache() instead.");
   }
 
+  /**
+   * @deprecated OkHttp 2 dropped support for java.net.ResponseCache. That API
+   *     is broken for many reasons: URI instead of URL, no conditional updates,
+   *     no invalidation, and no mechanism for tracking hit rates. Use
+   *     {@link #setOkResponseCache} instead.
+   */
+  @Deprecated
   public ResponseCache getResponseCache() {
-    return responseCache;
+    throw new UnsupportedOperationException("OkHttp 2 dropped support for java.net.ResponseCache. "
+        + "Use setOkResponseCache() instead.");
+  }
+
+  public OkHttpClient setOkResponseCache(OkResponseCache responseCache) {
+    this.responseCache = responseCache;
+    return this;
   }
 
   public OkResponseCache getOkResponseCache() {
-    if (responseCache instanceof HttpResponseCache) {
-      return ((HttpResponseCache) responseCache).okResponseCache;
-    } else if (responseCache != null) {
-      return new OkResponseCacheAdapter(responseCache);
-    } else {
-      return null;
-    }
+    return responseCache;
   }
 
   /**
@@ -319,19 +329,24 @@ public OkHttpClient setTransports(List<String> transports) {
 
   /**
    * Schedules {@code request} to be executed.
+   *
+   * <h3>Warning: Experimental OkHttp 2.0 API</h3>
+   * This method is in beta. APIs are subject to change!
    */
-  /* OkHttp 2.0: public */ void enqueue(Request request, Response.Receiver responseReceiver) {
-    // Create the HttpURLConnection immediately so the enqueued job gets the current settings of
-    // this client. Otherwise changes to this client (socket factory, redirect policy, etc.) may
-    // incorrectly be reflected in the request when it is dispatched later.
-    dispatcher.enqueue(open(request.url()), request, responseReceiver);
+  public void enqueue(Request request, Response.Receiver responseReceiver) {
+    // Copy this client. Otherwise changes (socket factory, redirect policy,
+    // etc.) may incorrectly be reflected in the request when it is dispatched.
+    dispatcher.enqueue(copyWithDefaults(), request, responseReceiver);
   }
 
   /**
    * Cancels all scheduled tasks tagged with {@code tag}. Requests that are already
    * in flight might not be canceled.
+   *
+   * <h3>Warning: Experimental OkHttp 2.0 API</h3>
+   * This method is in beta. APIs are subject to change!
    */
-  /* OkHttp 2.0: public */ void cancel(Object tag) {
+  public void cancel(Object tag) {
     dispatcher.cancel(tag);
   }
 
@@ -350,32 +365,51 @@ HttpURLConnection open(URL url, Proxy proxy) {
   }
 
   /**
-   * Returns a shallow copy of this OkHttpClient that uses the system-wide default for
-   * each field that hasn't been explicitly configured.
+   * Returns a shallow copy of this OkHttpClient that uses the system-wide
+   * default for each field that hasn't been explicitly configured.
    */
   private OkHttpClient copyWithDefaults() {
-    OkHttpClient result = new OkHttpClient(this);
-    result.proxy = proxy;
-    result.proxySelector = proxySelector != null ? proxySelector : ProxySelector.getDefault();
-    result.cookieHandler = cookieHandler != null ? cookieHandler : CookieHandler.getDefault();
-    result.responseCache = responseCache != null ? responseCache : ResponseCache.getDefault();
-    result.sslSocketFactory = sslSocketFactory != null
-        ? sslSocketFactory
-        : HttpsURLConnection.getDefaultSSLSocketFactory();
-    result.hostnameVerifier = hostnameVerifier != null
-        ? hostnameVerifier
-        : OkHostnameVerifier.INSTANCE;
-    result.authenticator = authenticator != null
-        ? authenticator
-        : HttpAuthenticator.SYSTEM_DEFAULT;
-    result.connectionPool = connectionPool != null ? connectionPool : ConnectionPool.getDefault();
-    result.followProtocolRedirects = followProtocolRedirects;
-    result.transports = transports != null ? transports : DEFAULT_TRANSPORTS;
-    result.connectTimeout = connectTimeout;
-    result.readTimeout = readTimeout;
+    OkHttpClient result = clone();
+    if (result.proxySelector == null) {
+      result.proxySelector = ProxySelector.getDefault();
+    }
+    if (result.cookieHandler == null) {
+      result.cookieHandler = CookieHandler.getDefault();
+    }
+    if (result.responseCache == null) {
+      result.responseCache = toOkResponseCacheOrNull(ResponseCache.getDefault());
+    }
+    if (result.sslSocketFactory == null) {
+      result.sslSocketFactory = HttpsURLConnection.getDefaultSSLSocketFactory();
+    }
+    if (result.hostnameVerifier == null) {
+      result.hostnameVerifier = OkHostnameVerifier.INSTANCE;
+    }
+    if (result.authenticator == null) {
+      result.authenticator = HttpAuthenticator.SYSTEM_DEFAULT;
+    }
+    if (result.connectionPool == null) {
+      result.connectionPool = ConnectionPool.getDefault();
+    }
+    if (result.transports == null) {
+      result.transports = DEFAULT_TRANSPORTS;
+    }
     return result;
   }
 
+  /** Returns a shallow copy of this OkHttpClient. */
+  @Override public OkHttpClient clone() {
+    try {
+      return (OkHttpClient) super.clone();
+    } catch (CloneNotSupportedException e) {
+      throw new AssertionError();
+    }
+  }
+
+  private OkResponseCache toOkResponseCacheOrNull(ResponseCache cache) {
+    return cache instanceof OkResponseCache ? ((OkResponseCache) cache) : null;
+  }
+
   /**
    * Creates a URLStreamHandler as a {@link URL#setURLStreamHandlerFactory}.
    *
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java b/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java
index ffe6f54b10..1ddeb9a53e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java
@@ -17,12 +17,6 @@
 
 import java.io.IOException;
 import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
 
 /**
  * An extended response cache API. Unlike {@link java.net.ResponseCache}, this
@@ -32,21 +26,25 @@
  * This class is in beta. APIs are subject to change!
  */
 public interface OkResponseCache {
-  CacheResponse get(URI uri, String requestMethod, Map<String, List<String>> requestHeaders)
-      throws IOException;
+  Response get(Request request) throws IOException;
 
-  CacheRequest put(URI uri, URLConnection urlConnection) throws IOException;
+  CacheRequest put(Response response) throws IOException;
 
-  /** Remove any cache entries for the supplied {@code uri} if the request method invalidates. */
-  void maybeRemove(String requestMethod, URI uri) throws IOException;
+  /**
+   * Remove any cache entries for the supplied {@code uri}. Returns true if the
+   * supplied {@code requestMethod} potentially invalidates an entry in the
+   * cache.
+   */
+  // TODO: this shouldn't return a boolean.
+  boolean maybeRemove(Request request) throws IOException;
 
   /**
    * Handles a conditional request hit by updating the stored cache response
-   * with the headers from {@code httpConnection}. The cached response body is
-   * not updated. If the stored response has changed since {@code
-   * conditionalCacheHit} was returned, this does nothing.
+   * with the headers from {@code network}. The cached response body is not
+   * updated. If the stored response has changed since {@code cached} was
+   * returned, this does nothing.
    */
-  void update(CacheResponse conditionalCacheHit, HttpURLConnection connection) throws IOException;
+  void update(Response cached, Response network) throws IOException;
 
   /** Track an conditional GET that was satisfied by this cache. */
   void trackConditionalCacheHit();
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index a4e83f4889..79f1ca8215 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -15,8 +15,11 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.RawHeaders;
+import com.squareup.okhttp.internal.http.HeaderParser;
+import com.squareup.okhttp.internal.http.Headers;
+import com.squareup.okhttp.internal.http.HttpDate;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -24,8 +27,12 @@
 import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
 import java.net.URL;
+import java.util.Date;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 /**
@@ -35,17 +42,20 @@
  * <h3>Warning: Experimental OkHttp 2.0 API</h3>
  * This class is in beta. APIs are subject to change!
  */
-/* OkHttp 2.0: public */ final class Request {
+public final class Request {
   private final URL url;
   private final String method;
-  private final RawHeaders headers;
+  private final Headers headers;
   private final Body body;
   private final Object tag;
 
+  private volatile ParsedHeaders parsedHeaders; // Lazily initialized.
+  private volatile URI uri; // Lazily initialized.
+
   private Request(Builder builder) {
     this.url = builder.url;
     this.method = builder.method;
-    this.headers = new RawHeaders(builder.headers);
+    this.headers = builder.headers.build();
     this.body = builder.body;
     this.tag = builder.tag != null ? builder.tag : this;
   }
@@ -54,6 +64,15 @@ public URL url() {
     return url;
   }
 
+  public URI uri() throws IOException {
+    try {
+      URI result = uri;
+      return result != null ? result : (uri = Platform.get().toUriLenient(url));
+    } catch (URISyntaxException e) {
+      throw new IOException(e.getMessage());
+    }
+  }
+
   public String urlString() {
     return url.toString();
   }
@@ -74,16 +93,20 @@ public String header(String name) {
     return headers.names();
   }
 
+  Headers headers() {
+    return headers;
+  }
+
   public int headerCount() {
-    return headers.length();
+    return headers.size();
   }
 
   public String headerName(int index) {
-    return headers.getFieldName(index);
+    return headers.name(index);
   }
 
   public String headerValue(int index) {
-    return headers.getValue(index);
+    return headers.value(index);
   }
 
   public Body body() {
@@ -94,16 +117,133 @@ public Object tag() {
     return tag;
   }
 
-  public abstract static class Body {
+  public Builder newBuilder() {
+    return new Builder(this);
+  }
+
+  public Headers getHeaders() {
+    return headers;
+  }
+
+  public boolean getNoCache() {
+    return parsedHeaders().noCache;
+  }
+
+  public int getMaxAgeSeconds() {
+    return parsedHeaders().maxAgeSeconds;
+  }
+
+  public int getMaxStaleSeconds() {
+    return parsedHeaders().maxStaleSeconds;
+  }
+
+  public int getMinFreshSeconds() {
+    return parsedHeaders().minFreshSeconds;
+  }
+
+  public boolean getOnlyIfCached() {
+    return parsedHeaders().onlyIfCached;
+  }
+
+  // TODO: Make non-public. This conflicts with the Body's content length!
+  public long getContentLength() {
+    return parsedHeaders().contentLength;
+  }
+
+  public String getUserAgent() {
+    return parsedHeaders().userAgent;
+  }
+
+  // TODO: Make non-public. This conflicts with the Body's content type!
+  public String getContentType() {
+    return parsedHeaders().contentType;
+  }
+
+  public String getProxyAuthorization() {
+    return parsedHeaders().proxyAuthorization;
+  }
+
+  private ParsedHeaders parsedHeaders() {
+    ParsedHeaders result = parsedHeaders;
+    return result != null ? result : (parsedHeaders = new ParsedHeaders(headers));
+  }
+
+  public boolean isHttps() {
+    return url().getProtocol().equals("https");
+  }
+
+  /** Parsed request headers, computed on-demand and cached. */
+  private static class ParsedHeaders {
+    /** Don't use a cache to satisfy this request. */
+    private boolean noCache;
+    private int maxAgeSeconds = -1;
+    private int maxStaleSeconds = -1;
+    private int minFreshSeconds = -1;
+
     /**
-     * Returns the Content-Type header for this body, or null if the content
-     * type is unknown.
+     * This field's name "only-if-cached" is misleading. It actually means "do
+     * not use the network". It is set by a client who only wants to make a
+     * request if it can be fully satisfied by the cache. Cached responses that
+     * would require validation (ie. conditional gets) are not permitted if this
+     * header is set.
      */
-    public MediaType contentType() {
-      return null;
+    private boolean onlyIfCached;
+
+    private long contentLength = -1;
+    private String userAgent;
+    private String contentType;
+    private String proxyAuthorization;
+
+    public ParsedHeaders(Headers headers) {
+      HeaderParser.CacheControlHandler handler = new HeaderParser.CacheControlHandler() {
+        @Override public void handle(String directive, String parameter) {
+          if ("no-cache".equalsIgnoreCase(directive)) {
+            noCache = true;
+          } else if ("max-age".equalsIgnoreCase(directive)) {
+            maxAgeSeconds = HeaderParser.parseSeconds(parameter);
+          } else if ("max-stale".equalsIgnoreCase(directive)) {
+            maxStaleSeconds = HeaderParser.parseSeconds(parameter);
+          } else if ("min-fresh".equalsIgnoreCase(directive)) {
+            minFreshSeconds = HeaderParser.parseSeconds(parameter);
+          } else if ("only-if-cached".equalsIgnoreCase(directive)) {
+            onlyIfCached = true;
+          }
+        }
+      };
+
+      for (int i = 0; i < headers.size(); i++) {
+        String fieldName = headers.name(i);
+        String value = headers.value(i);
+        if ("Cache-Control".equalsIgnoreCase(fieldName)) {
+          HeaderParser.parseCacheControl(value, handler);
+        } else if ("Pragma".equalsIgnoreCase(fieldName)) {
+          if ("no-cache".equalsIgnoreCase(value)) {
+            noCache = true;
+          }
+        } else if ("Content-Length".equalsIgnoreCase(fieldName)) {
+          try {
+            contentLength = Long.parseLong(value);
+          } catch (NumberFormatException ignored) {
+          }
+        } else if ("User-Agent".equalsIgnoreCase(fieldName)) {
+          userAgent = value;
+        } else if ("Content-Type".equalsIgnoreCase(fieldName)) {
+          contentType = value;
+        } else if ("Proxy-Authorization".equalsIgnoreCase(fieldName)) {
+          proxyAuthorization = value;
+        }
+      }
     }
+  }
+
+  public abstract static class Body {
+    /** Returns the Content-Type header for this body. */
+    public abstract MediaType contentType();
 
-    /** Returns the number of bytes in this body, or -1 if that count is unknown. */
+    /**
+     * Returns the number of bytes that will be written to {@code out} in a call
+     * to {@link #writeTo}, or -1 if that count is unknown.
+     */
     public long contentLength() {
       return -1;
     }
@@ -182,30 +322,34 @@ public static Body create(final MediaType contentType, final File file) {
 
   public static class Builder {
     private URL url;
-    private String method = "GET";
-    private final RawHeaders headers = new RawHeaders();
+    private String method;
+    private final Headers.Builder headers;
     private Body body;
     private Object tag;
 
-    public Builder(String url) {
-      url(url);
+    public Builder() {
+      this.method = "GET";
+      this.headers = new Headers.Builder();
     }
 
-    public Builder(URL url) {
-      url(url);
+    private Builder(Request request) {
+      this.url = request.url;
+      this.method = request.method;
+      this.body = request.body;
+      this.tag = request.tag;
+      this.headers = request.headers.newBuilder();
     }
 
     public Builder url(String url) {
       try {
-        this.url = new URL(url);
-        return this;
+        return url(new URL(url));
       } catch (MalformedURLException e) {
         throw new IllegalArgumentException("Malformed URL: " + url);
       }
     }
 
     public Builder url(URL url) {
-      if (url == null) throw new IllegalStateException("url == null");
+      if (url == null) throw new IllegalArgumentException("url == null");
       this.url = url;
       return this;
     }
@@ -228,6 +372,58 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
+    public Builder removeHeader(String name) {
+      headers.removeAll(name);
+      return this;
+    }
+
+    // TODO: conflict's with the body's content type.
+    public Builder setContentLength(long contentLength) {
+      headers.set("Content-Length", Long.toString(contentLength));
+      return this;
+    }
+
+    public void setUserAgent(String userAgent) {
+      headers.set("User-Agent", userAgent);
+    }
+
+    // TODO: conflict's with the body's content type.
+    public void setContentType(String contentType) {
+      headers.set("Content-Type", contentType);
+    }
+
+    public void setIfModifiedSince(Date date) {
+      headers.set("If-Modified-Since", HttpDate.format(date));
+    }
+
+    public void setIfNoneMatch(String ifNoneMatch) {
+      headers.set("If-None-Match", ifNoneMatch);
+    }
+
+    public void addCookies(Map<String, List<String>> cookieHeaders) {
+      for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
+        String key = entry.getKey();
+        if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
+            && !entry.getValue().isEmpty()) {
+          headers.add(key, buildCookieHeader(entry.getValue()));
+        }
+      }
+    }
+
+    /**
+     * Send all cookies in one big header, as recommended by
+     * <a href="http://tools.ietf.org/html/rfc6265#section-4.2.1">RFC 6265</a>.
+     */
+    private String buildCookieHeader(List<String> cookies) {
+      if (cookies.size() == 1) return cookies.get(0);
+      StringBuilder sb = new StringBuilder();
+      for (int i = 0; i < cookies.size(); i++) {
+        if (i > 0) sb.append("; ");
+        sb.append(cookies.get(i));
+      }
+      return sb.toString();
+    }
+
     public Builder get() {
       return method("GET", null);
     }
@@ -264,6 +460,7 @@ public Builder tag(Object tag) {
     }
 
     public Request build() {
+      if (url == null) throw new IllegalStateException("url == null");
       return new Request(this);
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index 4cef2cd5c8..bdbc8a9974 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -16,14 +16,27 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.RawHeaders;
+import com.squareup.okhttp.internal.http.HeaderParser;
+import com.squareup.okhttp.internal.http.Headers;
+import com.squareup.okhttp.internal.http.HttpDate;
+import com.squareup.okhttp.internal.http.StatusLine;
+import com.squareup.okhttp.internal.http.SyntheticHeaders;
 import java.io.ByteArrayOutputStream;
+import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
+import java.net.HttpURLConnection;
+import java.nio.charset.Charset;
+import java.util.Collections;
+import java.util.Date;
 import java.util.List;
 import java.util.Set;
+import java.util.TreeSet;
+
+import static com.squareup.okhttp.internal.Util.UTF_8;
+import static com.squareup.okhttp.internal.Util.equal;
 
 /**
  * An HTTP response. Instances of this class are not immutable: the response
@@ -33,17 +46,21 @@
  * <h3>Warning: Experimental OkHttp 2.0 API</h3>
  * This class is in beta. APIs are subject to change!
  */
-/* OkHttp 2.0: public */ final class Response {
+public final class Response {
   private final Request request;
-  private final int code;
-  private final RawHeaders headers;
+  private final StatusLine statusLine;
+  private final Handshake handshake;
+  private final Headers headers;
   private final Body body;
   private final Response redirectedBy;
 
+  private volatile ParsedHeaders parsedHeaders; // Lazily initialized.
+
   private Response(Builder builder) {
     this.request = builder.request;
-    this.code = builder.code;
-    this.headers = new RawHeaders(builder.headers);
+    this.statusLine = builder.statusLine;
+    this.handshake = builder.handshake;
+    this.headers = builder.headers.build();
     this.body = builder.body;
     this.redirectedBy = builder.redirectedBy;
   }
@@ -64,8 +81,28 @@ public Request request() {
     return request;
   }
 
+  public String statusLine() {
+    return statusLine.getStatusLine();
+  }
+
   public int code() {
-    return code;
+    return statusLine.code();
+  }
+
+  public String statusMessage() {
+    return statusLine.message();
+  }
+
+  public int httpMinorVersion() {
+    return statusLine.httpMinorVersion();
+  }
+
+  /**
+   * Returns the TLS handshake of the connection that carried this response, or
+   * null if the response was received without TLS.
+   */
+  public Handshake handshake() {
+    return handshake;
   }
 
   public String header(String name) {
@@ -86,21 +123,30 @@ public String header(String name, String defaultValue) {
   }
 
   public int headerCount() {
-    return headers.length();
+    return headers.size();
   }
 
   public String headerName(int index) {
-    return headers.getFieldName(index);
+    return headers.name(index);
+  }
+
+  // TODO: this shouldn't be public?
+  public Headers headers() {
+    return headers;
   }
 
   public String headerValue(int index) {
-    return headers.getValue(index);
+    return headers.value(index);
   }
 
   public Body body() {
     return body;
   }
 
+  public Builder newBuilder() {
+    return new Builder(this);
+  }
+
   /**
    * Returns the response for the HTTP redirect that triggered this response, or
    * null if this response wasn't triggered by an automatic redirect. The body
@@ -111,18 +157,144 @@ public Response redirectedBy() {
     return redirectedBy;
   }
 
-  public abstract static class Body {
-    public String contentType() {
-      return null;
+  public Date getServedDate() {
+    return parsedHeaders().servedDate;
+  }
+
+  public Date getLastModified() {
+    return parsedHeaders().lastModified;
+  }
+
+  public Date getExpires() {
+    return parsedHeaders().expires;
+  }
+
+  public boolean isNoCache() {
+    return parsedHeaders().noCache;
+  }
+
+  public boolean isNoStore() {
+    return parsedHeaders().noStore;
+  }
+
+  public int getMaxAgeSeconds() {
+    return parsedHeaders().maxAgeSeconds;
+  }
+
+  public int getSMaxAgeSeconds() {
+    return parsedHeaders().sMaxAgeSeconds;
+  }
+
+  public boolean isPublic() {
+    return parsedHeaders().isPublic;
+  }
+
+  public boolean isMustRevalidate() {
+    return parsedHeaders().mustRevalidate;
+  }
+
+  public String getEtag() {
+    return parsedHeaders().etag;
+  }
+
+  public Set<String> getVaryFields() {
+    return parsedHeaders().varyFields;
+  }
+
+  // TODO: this shouldn't be public.
+  public long getContentLength() {
+    return parsedHeaders().contentLength;
+  }
+
+  // TODO: this shouldn't be public.
+  public String getContentType() {
+    return parsedHeaders().contentType;
+  }
+
+  /**
+   * Returns true if a Vary header contains an asterisk. Such responses cannot
+   * be cached.
+   */
+  public boolean hasVaryAll() {
+    return parsedHeaders().varyFields.contains("*");
+  }
+
+  /**
+   * Returns true if none of the Vary headers on this response have changed
+   * between {@code cachedRequest} and {@code newRequest}.
+   */
+  public boolean varyMatches(Headers varyHeaders, Request newRequest) {
+    for (String field : parsedHeaders().varyFields) {
+      if (!equal(varyHeaders.values(field), newRequest.headers(field))) return false;
+    }
+    return true;
+  }
+
+  /**
+   * Returns true if this cached response should be used; false if the
+   * network response should be used.
+   */
+  public boolean validate(Response network) {
+    if (network.code() == HttpURLConnection.HTTP_NOT_MODIFIED) {
+      return true;
     }
 
-    public long contentLength() {
-      return -1;
+    // The HTTP spec says that if the network's response is older than our
+    // cached response, we may return the cache's response. Like Chrome (but
+    // unlike Firefox), this client prefers to return the newer response.
+    ParsedHeaders networkHeaders = network.parsedHeaders();
+    if (parsedHeaders().lastModified != null
+        && networkHeaders.lastModified != null
+        && networkHeaders.lastModified.getTime() < parsedHeaders().lastModified.getTime()) {
+      return true;
     }
 
-    public abstract InputStream byteStream() throws IOException;
+    return false;
+  }
+
+  // TODO: should not be public?
+  public long getReceivedResponseMillis() {
+    return parsedHeaders().receivedResponseMillis;
+  }
+
+  // TODO: should not be public?
+  public long getSentRequestMillis() {
+    return parsedHeaders.sentRequestMillis;
+  }
+
+  public long getAgeSeconds() {
+    return parsedHeaders().ageSeconds;
+  }
+
+  public abstract static class Body implements Closeable {
+    /** Multiple calls to {@link #charStream()} must return the same instance. */
+    private Reader reader;
+
+    /**
+     * Returns true if further data from this response body should be read at
+     * this time. For asynchronous transports like SPDY and HTTP/2.0, this will
+     * return false once all locally-available body bytes have been read.
+     *
+     * <p>Clients with many concurrent downloads can use this method to reduce
+     * the number of idle threads blocking on reads. See {@link
+     * Receiver#onResponse} for details.
+     */
+    // <h3>Body.ready() vs. InputStream.available()</h3>
+    // TODO: Can we fix response bodies to implement InputStream.available well?
+    // The deflater implementation is broken by default but we could do better.
+    public abstract boolean ready() throws IOException;
+
+    public abstract MediaType contentType();
+
+    /**
+     * Returns the number of bytes in that will returned by {@link #bytes}, or
+     * {@link #byteStream}, or -1 if unknown.
+     */
+    public abstract long contentLength();
 
-    public byte[] bytes() throws IOException {
+    public abstract InputStream byteStream();
+
+    public final byte[] bytes() throws IOException {
       long contentLength = contentLength();
       if (contentLength > Integer.MAX_VALUE) {
         throw new IOException("Cannot buffer entire body for content length: " + contentLength);
@@ -143,41 +315,255 @@ public long contentLength() {
     }
 
     /**
-     * Returns the response bytes as a UTF-8 character stream. Do not call this
-     * method if the response content is not a UTF-8 character stream.
+     * Returns the response as a character stream decoded with the charset
+     * of the Content-Type header. If that header is either absent or lacks a
+     * charset, this will attempt to decode the response body as UTF-8.
      */
-    public Reader charStream() throws IOException {
-      // TODO: parse content-type.
-      return new InputStreamReader(byteStream(), "UTF-8");
+    public final Reader charStream() {
+      if (reader == null) {
+        reader = new InputStreamReader(byteStream(), charset());
+      }
+      return reader;
     }
 
     /**
-     * Returns the response bytes as a UTF-8 string. Do not call this method if
-     * the response content is not a UTF-8 character stream.
+     * Returns the response as a string decoded with the charset of the
+     * Content-Type header. If that header is either absent or lacks a charset,
+     * this will attempt to decode the response body as UTF-8.
      */
-    public String string() throws IOException {
-      // TODO: parse content-type.
-      return new String(bytes(), "UTF-8");
+    public final String string() throws IOException {
+      return new String(bytes(), charset().name());
+    }
+
+    private Charset charset() {
+      MediaType contentType = contentType();
+      return contentType != null ? contentType.charset(UTF_8) : UTF_8;
+    }
+
+    @Override public void close() throws IOException {
+      byteStream().close();
+    }
+  }
+
+  private ParsedHeaders parsedHeaders() {
+    ParsedHeaders result = parsedHeaders;
+    return result != null ? result : (parsedHeaders = new ParsedHeaders(headers));
+  }
+
+  /** Parsed response headers, computed on-demand and cached. */
+  private static class ParsedHeaders {
+    /** The server's time when this response was served, if known. */
+    Date servedDate;
+
+    /** The last modified date of the response, if known. */
+    Date lastModified;
+
+    /**
+     * The expiration date of the response, if known. If both this field and the
+     * max age are set, the max age is preferred.
+     */
+    Date expires;
+
+    /**
+     * Extension header set by HttpURLConnectionImpl specifying the timestamp
+     * when the HTTP request was first initiated.
+     */
+    long sentRequestMillis;
+
+    /**
+     * Extension header set by HttpURLConnectionImpl specifying the timestamp
+     * when the HTTP response was first received.
+     */
+    long receivedResponseMillis;
+
+    /**
+     * In the response, this field's name "no-cache" is misleading. It doesn't
+     * prevent us from caching the response; it only means we have to validate
+     * the response with the origin server before returning it. We can do this
+     * with a conditional get.
+     */
+    boolean noCache;
+
+    /** If true, this response should not be cached. */
+    boolean noStore;
+
+    /**
+     * The duration past the response's served date that it can be served
+     * without validation.
+     */
+    int maxAgeSeconds = -1;
+
+    /**
+     * The "s-maxage" directive is the max age for shared caches. Not to be
+     * confused with "max-age" for non-shared caches, As in Firefox and Chrome,
+     * this directive is not honored by this cache.
+     */
+    int sMaxAgeSeconds = -1;
+
+    /**
+     * This request header field's name "only-if-cached" is misleading. It
+     * actually means "do not use the network". It is set by a client who only
+     * wants to make a request if it can be fully satisfied by the cache.
+     * Cached responses that would require validation (ie. conditional gets) are
+     * not permitted if this header is set.
+     */
+    boolean isPublic;
+    boolean mustRevalidate;
+    String etag;
+    int ageSeconds = -1;
+
+    /** Case-insensitive set of field names. */
+    private Set<String> varyFields = Collections.emptySet();
+
+    private long contentLength = -1;
+    private String contentType;
+
+    private ParsedHeaders(Headers headers) {
+      HeaderParser.CacheControlHandler handler = new HeaderParser.CacheControlHandler() {
+        @Override public void handle(String directive, String parameter) {
+          if ("no-cache".equalsIgnoreCase(directive)) {
+            noCache = true;
+          } else if ("no-store".equalsIgnoreCase(directive)) {
+            noStore = true;
+          } else if ("max-age".equalsIgnoreCase(directive)) {
+            maxAgeSeconds = HeaderParser.parseSeconds(parameter);
+          } else if ("s-maxage".equalsIgnoreCase(directive)) {
+            sMaxAgeSeconds = HeaderParser.parseSeconds(parameter);
+          } else if ("public".equalsIgnoreCase(directive)) {
+            isPublic = true;
+          } else if ("must-revalidate".equalsIgnoreCase(directive)) {
+            mustRevalidate = true;
+          }
+        }
+      };
+
+      for (int i = 0; i < headers.size(); i++) {
+        String fieldName = headers.name(i);
+        String value = headers.value(i);
+        if ("Cache-Control".equalsIgnoreCase(fieldName)) {
+          HeaderParser.parseCacheControl(value, handler);
+        } else if ("Date".equalsIgnoreCase(fieldName)) {
+          servedDate = HttpDate.parse(value);
+        } else if ("Expires".equalsIgnoreCase(fieldName)) {
+          expires = HttpDate.parse(value);
+        } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
+          lastModified = HttpDate.parse(value);
+        } else if ("ETag".equalsIgnoreCase(fieldName)) {
+          etag = value;
+        } else if ("Pragma".equalsIgnoreCase(fieldName)) {
+          if ("no-cache".equalsIgnoreCase(value)) {
+            noCache = true;
+          }
+        } else if ("Age".equalsIgnoreCase(fieldName)) {
+          ageSeconds = HeaderParser.parseSeconds(value);
+        } else if ("Vary".equalsIgnoreCase(fieldName)) {
+          // Replace the immutable empty set with something we can mutate.
+          if (varyFields.isEmpty()) {
+            varyFields = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
+          }
+          for (String varyField : value.split(",")) {
+            varyFields.add(varyField.trim());
+          }
+        } else if ("Content-Length".equalsIgnoreCase(fieldName)) {
+          try {
+            contentLength = Long.parseLong(value);
+          } catch (NumberFormatException ignored) {
+          }
+        } else if ("Content-Type".equalsIgnoreCase(fieldName)) {
+          contentType = value;
+        } else if (SyntheticHeaders.SENT_MILLIS.equalsIgnoreCase(fieldName)) {
+          sentRequestMillis = Long.parseLong(value);
+        } else if (SyntheticHeaders.RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
+          receivedResponseMillis = Long.parseLong(value);
+        }
+      }
     }
   }
 
   public interface Receiver {
+    /**
+     * Called when the request could not be executed due to a connectivity
+     * problem or timeout. Because networks can fail during an exchange, it is
+     * possible that the remote server accepted the request before the failure.
+     */
     void onFailure(Failure failure);
-    void onResponse(Response response) throws IOException;
+
+    /**
+     * Called when the HTTP response was successfully returned by the remote
+     * server. The receiver may proceed to read the response body with the
+     * response's {@link #body} method.
+     *
+     * <p>Note that transport-layer success (receiving a HTTP response code,
+     * headers and body) does not necessarily indicate application-layer
+     * success: {@code response} may still indicate an unhappy HTTP response
+     * code like 404 or 500.
+     *
+     * <h3>Non-blocking responses</h3>
+     *
+     * <p>Receivers do not need to block while waiting for the response body to
+     * download. Instead, they can get called back as data arrives. Use {@link
+     * Body#ready} to check if bytes should be read immediately. While there is
+     * data ready, read it. If there isn't, return false: receivers will be
+     * called back with {@code onResponse()} as additional data is downloaded.
+     *
+     * <p>Return true to indicate that the receiver has finished handling the
+     * response body. If the response body has unread data, it will be
+     * discarded.
+     *
+     * <p>When the response body has been fully consumed the returned value is
+     * undefined.
+     *
+     * <p>The current implementation of {@link Body#ready} always returns true
+     * when the underlying transport is HTTP/1. This results in blocking on that
+     * transport. For effective non-blocking your server must support SPDY or
+     * HTTP/2.
+     */
+    boolean onResponse(Response response) throws IOException;
   }
 
   public static class Builder {
-    private final Request request;
-    private final int code;
-    private final RawHeaders headers = new RawHeaders();
+    private Request request;
+    private StatusLine statusLine;
+    private Handshake handshake;
+    private Headers.Builder headers;
     private Body body;
     private Response redirectedBy;
 
-    public Builder(Request request, int code) {
-      if (request == null) throw new IllegalArgumentException("request == null");
-      if (code <= 0) throw new IllegalArgumentException("code <= 0");
+    public Builder() {
+      headers = new Headers.Builder();
+    }
+
+    private Builder(Response response) {
+      this.request = response.request;
+      this.statusLine = response.statusLine;
+      this.handshake = response.handshake;
+      this.headers = response.headers.newBuilder();
+      this.body = response.body;
+      this.redirectedBy = response.redirectedBy;
+    }
+
+    public Builder request(Request request) {
       this.request = request;
-      this.code = code;
+      return this;
+    }
+
+    public Builder statusLine(StatusLine statusLine) {
+      if (statusLine == null) throw new IllegalArgumentException("statusLine == null");
+      this.statusLine = statusLine;
+      return this;
+    }
+
+    public Builder statusLine(String statusLine) {
+      try {
+        return statusLine(new StatusLine(statusLine));
+      } catch (IOException e) {
+        throw new IllegalArgumentException(e);
+      }
+    }
+
+    public Builder handshake(Handshake handshake) {
+      this.handshake = handshake;
+      return this;
     }
 
     /**
@@ -198,19 +584,36 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
+    public Builder removeHeader(String name) {
+      headers.removeAll(name);
+      return this;
+    }
+
+    // TODO: this shouldn't be public?
+    public Builder headers(Headers headers) {
+      this.headers = headers.newBuilder();
+      return this;
+    }
+
     public Builder body(Body body) {
       this.body = body;
       return this;
     }
 
+    // TODO: this shouldn't be public.
+    public Builder setResponseSource(ResponseSource responseSource) {
+      headers.set(SyntheticHeaders.RESPONSE_SOURCE, responseSource + " " + statusLine.code());
+      return this;
+    }
+
     public Builder redirectedBy(Response redirectedBy) {
       this.redirectedBy = redirectedBy;
       return this;
     }
 
     public Response build() {
-      if (request == null) throw new IllegalStateException("Response has no request.");
-      if (code == -1) throw new IllegalStateException("Response has no code.");
+      if (request == null) throw new IllegalStateException("request == null");
+      if (statusLine == null) throw new IllegalStateException("statusLine == null");
       return new Response(this);
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java b/okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java
index 4eca172d35..915fa58e68 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java
@@ -29,9 +29,20 @@
   CONDITIONAL_CACHE,
 
   /** The response was returned from the network. */
-  NETWORK;
+  NETWORK,
+
+  /**
+   * The request demanded a cached response that the cache couldn't satisfy.
+   * This yields a 504 (Gateway Timeout) response as specified by
+   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.4.
+   */
+  NONE;
 
   public boolean requiresConnection() {
     return this == CONDITIONAL_CACHE || this == NETWORK;
   }
+
+  public boolean usesCache() {
+    return this == CACHE || this == CONDITIONAL_CACHE;
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/TunnelRequest.java b/okhttp/src/main/java/com/squareup/okhttp/TunnelRequest.java
index 5260b87c49..3bcff5a8a5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/TunnelRequest.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/TunnelRequest.java
@@ -15,7 +15,8 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.http.RawHeaders;
+import java.io.IOException;
+import java.net.URL;
 
 import static com.squareup.okhttp.internal.Util.getDefaultPort;
 
@@ -49,27 +50,31 @@ public TunnelRequest(String host, int port, String userAgent, String proxyAuthor
     this.proxyAuthorization = proxyAuthorization;
   }
 
+  String requestLine() {
+    return "CONNECT " + host + ":" + port + " HTTP/1.1";
+  }
+
   /**
    * If we're creating a TLS tunnel, send only the minimum set of headers.
    * This avoids sending potentially sensitive data like HTTP cookies to
    * the proxy unencrypted.
    */
-  RawHeaders getRequestHeaders() {
-    RawHeaders result = new RawHeaders();
-    result.setRequestLine("CONNECT " + host + ":" + port + " HTTP/1.1");
+  Request getRequest() throws IOException {
+    Request.Builder result = new Request.Builder()
+        .url(new URL("https", host, port, "/"));
 
     // Always set Host and User-Agent.
-    result.set("Host", port == getDefaultPort("https") ? host : (host + ":" + port));
-    result.set("User-Agent", userAgent);
+    result.header("Host", port == getDefaultPort("https") ? host : (host + ":" + port));
+    result.header("User-Agent", userAgent);
 
     // Copy over the Proxy-Authorization header if it exists.
     if (proxyAuthorization != null) {
-      result.set("Proxy-Authorization", proxyAuthorization);
+      result.header("Proxy-Authorization", proxyAuthorization);
     }
 
     // Always set the Proxy-Connection to Keep-Alive for the benefit of
     // HTTP/1.0 proxies like Squid.
-    result.set("Proxy-Connection", "Keep-Alive");
-    return result;
+    result.header("Proxy-Connection", "Keep-Alive");
+    return result.build();
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java
index a5d39b30a4..612693644a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java
@@ -46,7 +46,7 @@
 
     OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
 
-    // some apps return a null body; for compatibility we treat that like a null cache request
+    // Some apps return a null body; for compatibility we treat that like a null cache request.
     if (cacheBody == null) {
       cacheRequest = null;
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
new file mode 100644
index 0000000000..459f3ad7a8
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
@@ -0,0 +1,243 @@
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseSource;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.util.concurrent.TimeUnit;
+
+import static com.squareup.okhttp.internal.Util.EMPTY_INPUT_STREAM;
+
+/**
+ * Given a request and cached response, this figures out whether to use the
+ * network, the cache, or both.
+ *
+ * <p>Selecting the next action may have side effects. The request may gain
+ * conditions such as an "If-None-Match" or "If-Modified-Since" header. The
+ * response may gain a warning if it is potentially stale.
+ */
+public final class CacheStrategy {
+  private static final Response.Body EMPTY_BODY = new Response.Body() {
+    @Override public boolean ready() throws IOException {
+      return true;
+    }
+    @Override public MediaType contentType() {
+      return null;
+    }
+    @Override public long contentLength() {
+      return 0;
+    }
+    @Override public InputStream byteStream() {
+      return EMPTY_INPUT_STREAM;
+    }
+  };
+
+  private static final StatusLine GATEWAY_TIMEOUT_STATUS_LINE;
+  static {
+    try {
+      GATEWAY_TIMEOUT_STATUS_LINE = new StatusLine("HTTP/1.1 504 Gateway Timeout");
+    } catch (IOException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public final Request request;
+  public final Response response;
+  public final ResponseSource source;
+
+  private CacheStrategy(
+      Request request, Response response, ResponseSource source) {
+    this.request = request;
+    this.response = response;
+    this.source = source;
+  }
+
+  /**
+   * Returns the current age of the response, in milliseconds. The calculation
+   * is specified by RFC 2616, 13.2.3 Age Calculations.
+   */
+  private static long computeAge(Response response, long nowMillis) {
+    long apparentReceivedAge = response.getServedDate() != null
+        ? Math.max(0, response.getReceivedResponseMillis() - response.getServedDate().getTime())
+        : 0;
+    long receivedAge = response.getAgeSeconds() != -1
+        ? Math.max(apparentReceivedAge, TimeUnit.SECONDS.toMillis(response.getAgeSeconds()))
+        : apparentReceivedAge;
+    long responseDuration = response.getReceivedResponseMillis() - response.getSentRequestMillis();
+    long residentDuration = nowMillis - response.getReceivedResponseMillis();
+    return receivedAge + responseDuration + residentDuration;
+  }
+
+  /**
+   * Returns the number of milliseconds that the response was fresh for,
+   * starting from the served date.
+   */
+  private static long computeFreshnessLifetime(Response response) {
+    if (response.getMaxAgeSeconds() != -1) {
+      return TimeUnit.SECONDS.toMillis(response.getMaxAgeSeconds());
+    } else if (response.getExpires() != null) {
+      long servedMillis = response.getServedDate() != null
+          ? response.getServedDate().getTime()
+          : response.getReceivedResponseMillis();
+      long delta = response.getExpires().getTime() - servedMillis;
+      return delta > 0 ? delta : 0;
+    } else if (response.getLastModified() != null && response.request().url().getQuery() == null) {
+      // As recommended by the HTTP RFC and implemented in Firefox, the
+      // max age of a document should be defaulted to 10% of the
+      // document's age at the time it was served. Default expiration
+      // dates aren't used for URIs containing a query.
+      long servedMillis = response.getServedDate() != null
+          ? response.getServedDate().getTime()
+          : response.getSentRequestMillis();
+      long delta = servedMillis - response.getLastModified().getTime();
+      return delta > 0 ? (delta / 10) : 0;
+    }
+    return 0;
+  }
+
+  /**
+   * Returns true if computeFreshnessLifetime used a heuristic. If we used a
+   * heuristic to serve a cached response older than 24 hours, we are required
+   * to attach a warning.
+   */
+  private static boolean isFreshnessLifetimeHeuristic(Response response) {
+    return response.getMaxAgeSeconds() == -1 && response.getExpires() == null;
+  }
+
+  /**
+   * Returns true if this response can be stored to later serve another
+   * request.
+   */
+  public static boolean isCacheable(Response response, Request request) {
+    // Always go to network for uncacheable response codes (RFC 2616, 13.4),
+    // This implementation doesn't support caching partial content.
+    int responseCode = response.code();
+    if (responseCode != HttpURLConnection.HTTP_OK
+        && responseCode != HttpURLConnection.HTTP_NOT_AUTHORITATIVE
+        && responseCode != HttpURLConnection.HTTP_MULT_CHOICE
+        && responseCode != HttpURLConnection.HTTP_MOVED_PERM
+        && responseCode != HttpURLConnection.HTTP_GONE) {
+      return false;
+    }
+
+    // Responses to authorized requests aren't cacheable unless they include
+    // a 'public', 'must-revalidate' or 's-maxage' directive.
+    if (request.header("Authorization") != null
+        && !response.isPublic()
+        && !response.isMustRevalidate()
+        && response.getSMaxAgeSeconds() == -1) {
+      return false;
+    }
+
+    if (response.isNoStore()) {
+      return false;
+    }
+
+    return true;
+  }
+
+  /**
+   * Returns a strategy to satisfy {@code request} using the a cached response
+   * {@code response}.
+   */
+  public static CacheStrategy get(long nowMillis, Response response, Request request) {
+    CacheStrategy candidate = getCandidate(nowMillis, response, request);
+
+    if (candidate.source != ResponseSource.CACHE && request.getOnlyIfCached()) {
+      // We're forbidden from using the network, but the cache is insufficient.
+      Response noneResponse = new Response.Builder()
+          .request(candidate.request)
+          .statusLine(GATEWAY_TIMEOUT_STATUS_LINE)
+          .setResponseSource(ResponseSource.NONE)
+          .body(EMPTY_BODY)
+          .build();
+      return new CacheStrategy(candidate.request, noneResponse, ResponseSource.NONE);
+    }
+
+    return candidate;
+  }
+
+  /** Returns a strategy to use assuming the request can use the network. */
+  private static CacheStrategy getCandidate(long nowMillis, Response response, Request request) {
+    // No cached response.
+    if (response == null) {
+      return new CacheStrategy(request, response, ResponseSource.NETWORK);
+    }
+
+    // Drop the cached response if it's missing a required handshake.
+    if (request.isHttps() && response.handshake() == null) {
+      return new CacheStrategy(request, response, ResponseSource.NETWORK);
+    }
+
+    // If this response shouldn't have been stored, it should never be used
+    // as a response source. This check should be redundant as long as the
+    // persistence store is well-behaved and the rules are constant.
+    if (!isCacheable(response, request)) {
+      return new CacheStrategy(request, response, ResponseSource.NETWORK);
+    }
+
+    if (request.getNoCache() || hasConditions(request)) {
+      return new CacheStrategy(request, response, ResponseSource.NETWORK);
+    }
+
+    long ageMillis = computeAge(response, nowMillis);
+    long freshMillis = computeFreshnessLifetime(response);
+
+    if (request.getMaxAgeSeconds() != -1) {
+      freshMillis = Math.min(freshMillis, TimeUnit.SECONDS.toMillis(request.getMaxAgeSeconds()));
+    }
+
+    long minFreshMillis = 0;
+    if (request.getMinFreshSeconds() != -1) {
+      minFreshMillis = TimeUnit.SECONDS.toMillis(request.getMinFreshSeconds());
+    }
+
+    long maxStaleMillis = 0;
+    if (!response.isMustRevalidate() && request.getMaxStaleSeconds() != -1) {
+      maxStaleMillis = TimeUnit.SECONDS.toMillis(request.getMaxStaleSeconds());
+    }
+
+    if (!response.isNoCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
+      Response.Builder builder = response.newBuilder()
+          .setResponseSource(ResponseSource.CACHE); // Overwrite any stored response source.
+      if (ageMillis + minFreshMillis >= freshMillis) {
+        builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
+      }
+      long oneDayMillis = 24 * 60 * 60 * 1000L;
+      if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic(response)) {
+        builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
+      }
+      return new CacheStrategy(request, builder.build(), ResponseSource.CACHE);
+    }
+
+    Request.Builder conditionalRequestBuilder = request.newBuilder();
+
+    if (response.getLastModified() != null) {
+      conditionalRequestBuilder.setIfModifiedSince(response.getLastModified());
+    } else if (response.getServedDate() != null) {
+      conditionalRequestBuilder.setIfModifiedSince(response.getServedDate());
+    }
+
+    if (response.getEtag() != null) {
+      conditionalRequestBuilder.setIfNoneMatch(response.getEtag());
+    }
+
+    Request conditionalRequest = conditionalRequestBuilder.build();
+    ResponseSource responseSource = hasConditions(conditionalRequest)
+        ? ResponseSource.CONDITIONAL_CACHE
+        : ResponseSource.NETWORK;
+    return new CacheStrategy(conditionalRequest, response, responseSource);
+  }
+
+  /**
+   * Returns true if the request contains conditions that save the server from
+   * sending a response that the client has locally. When a request is enqueued
+   * with its own conditions, the built-in response cache won't be used.
+   */
+  private static boolean hasConditions(Request request) {
+    return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
index d5f0f4f9b8..c8a7119ae9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
@@ -16,7 +16,7 @@
 
 package com.squareup.okhttp.internal.http;
 
-final class HeaderParser {
+public final class HeaderParser {
 
   public interface CacheControlHandler {
     void handle(String directive, String parameter);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Headers.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Headers.java
new file mode 100644
index 0000000000..d2a2eefccf
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Headers.java
@@ -0,0 +1,251 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.TreeSet;
+
+/**
+ * The HTTP status and unparsed header fields of a single HTTP message. Values
+ * are represented as uninterpreted strings; use {@code Request} and
+ * {@code Response} for interpreted headers. This class maintains the
+ * order of the header fields within the HTTP message.
+ *
+ * <p>This class tracks fields line-by-line. A field with multiple comma-
+ * separated values on the same line will be treated as a field with a single
+ * value by this class. It is the caller's responsibility to detect and split
+ * on commas if their field permits multiple values. This simplifies use of
+ * single-valued fields whose values routinely contain commas, such as cookies
+ * or dates.
+ *
+ * <p>This class trims whitespace from values. It never returns values with
+ * leading or trailing whitespace.
+ */
+public final class Headers {
+  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
+    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
+    @Override public int compare(String a, String b) {
+      if (a == b) {
+        return 0;
+      } else if (a == null) {
+        return -1;
+      } else if (b == null) {
+        return 1;
+      } else {
+        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
+      }
+    }
+  };
+
+  private final List<String> namesAndValues;
+
+  private Headers(Builder builder) {
+    this.namesAndValues = Util.immutableList(builder.namesAndValues);
+  }
+
+  /** Returns the number of field values. */
+  public int size() {
+    return namesAndValues.size() / 2;
+  }
+
+  /** Returns the field at {@code position} or null if that is out of range. */
+  public String name(int index) {
+    int fieldNameIndex = index * 2;
+    if (fieldNameIndex < 0 || fieldNameIndex >= namesAndValues.size()) {
+      return null;
+    }
+    return namesAndValues.get(fieldNameIndex);
+  }
+
+  /** Returns an immutable case-insensitive set of header names. */
+  public Set<String> names() {
+    TreeSet<String> result = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
+    for (int i = 0; i < size(); i++) {
+      result.add(name(i));
+    }
+    return Collections.unmodifiableSet(result);
+  }
+
+  /** Returns the value at {@code index} or null if that is out of range. */
+  public String value(int index) {
+    int valueIndex = index * 2 + 1;
+    if (valueIndex < 0 || valueIndex >= namesAndValues.size()) {
+      return null;
+    }
+    return namesAndValues.get(valueIndex);
+  }
+
+  /** Returns the last value corresponding to the specified field, or null. */
+  public String get(String fieldName) {
+    return get(namesAndValues, fieldName);
+  }
+
+  /** Returns an immutable list of the header values for {@code name}. */
+  public List<String> values(String name) {
+    List<String> result = null;
+    for (int i = 0; i < size(); i++) {
+      if (name.equalsIgnoreCase(name(i))) {
+        if (result == null) result = new ArrayList<String>(2);
+        result.add(value(i));
+      }
+    }
+    return result != null
+        ? Collections.unmodifiableList(result)
+        : Collections.<String>emptyList();
+  }
+
+  /** @param fieldNames a case-insensitive set of HTTP header field names. */
+  public Headers getAll(Set<String> fieldNames) {
+    Builder result = new Builder();
+    for (int i = 0; i < namesAndValues.size(); i += 2) {
+      String fieldName = namesAndValues.get(i);
+      if (fieldNames.contains(fieldName)) {
+        result.add(fieldName, namesAndValues.get(i + 1));
+      }
+    }
+    return result.build();
+  }
+
+  /**
+   * Returns an immutable map containing each field to its list of values.
+   *
+   * @param valueForNullKey the request line for requests, or the status line
+   *     for responses. If non-null, this value is mapped to the null key.
+   */
+  public Map<String, List<String>> toMultimap(String valueForNullKey) {
+    Map<String, List<String>> result = new TreeMap<String, List<String>>(FIELD_NAME_COMPARATOR);
+    for (int i = 0; i < namesAndValues.size(); i += 2) {
+      String fieldName = namesAndValues.get(i);
+      String value = namesAndValues.get(i + 1);
+
+      List<String> allValues = new ArrayList<String>();
+      List<String> otherValues = result.get(fieldName);
+      if (otherValues != null) {
+        allValues.addAll(otherValues);
+      }
+      allValues.add(value);
+      result.put(fieldName, Collections.unmodifiableList(allValues));
+    }
+    if (valueForNullKey != null) {
+      result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));
+    }
+    return Collections.unmodifiableMap(result);
+  }
+
+  public Builder newBuilder() {
+    Builder result = new Builder();
+    result.namesAndValues.addAll(namesAndValues);
+    return result;
+  }
+
+  private static String get(List<String> namesAndValues, String fieldName) {
+    for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
+      if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
+        return namesAndValues.get(i + 1);
+      }
+    }
+    return null;
+  }
+
+  public static class Builder {
+    private final List<String> namesAndValues = new ArrayList<String>(20);
+
+    /** Equivalent to {@code build().get(fieldName)}, but potentially faster. */
+    public String get(String fieldName) {
+      return Headers.get(namesAndValues, fieldName);
+    }
+
+    /**
+     * Add an HTTP header line containing a field name, a literal colon, and a
+     * value. This works around empty header names and header names that start
+     * with a colon (created by old broken SPDY versions of the response cache).
+     */
+    public Builder addLine(String line) {
+      int index = line.indexOf(":", 1);
+      if (index != -1) {
+        return addLenient(line.substring(0, index), line.substring(index + 1));
+      } else if (line.startsWith(":")) {
+        return addLenient("", line.substring(1)); // Empty header name.
+      } else {
+        return addLenient("", line); // No header name.
+      }
+    }
+
+    /** Add a field with the specified value. */
+    public Builder add(String fieldName, String value) {
+      if (fieldName == null) throw new IllegalArgumentException("fieldname == null");
+      if (value == null) throw new IllegalArgumentException("value == null");
+      if (fieldName.length() == 0 || fieldName.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+        throw new IllegalArgumentException("Unexpected header: " + fieldName + ": " + value);
+      }
+      return addLenient(fieldName, value);
+    }
+
+    /**
+     * Add a field with the specified value without any validation. Only
+     * appropriate for headers from the remote peer.
+     */
+    private Builder addLenient(String fieldName, String value) {
+      namesAndValues.add(fieldName);
+      namesAndValues.add(value.trim());
+      return this;
+    }
+
+    public Builder removeAll(String fieldName) {
+      for (int i = 0; i < namesAndValues.size(); i += 2) {
+        if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
+          namesAndValues.remove(i); // field name
+          namesAndValues.remove(i); // value
+        }
+      }
+      return this;
+    }
+
+    /**
+     * Set a field with the specified value. If the field is not found, it is
+     * added. If the field is found, the existing values are replaced.
+     */
+    public Builder set(String fieldName, String value) {
+      removeAll(fieldName);
+      add(fieldName, value);
+      return this;
+    }
+
+    /** Reads headers or trailers into {@code out}. */
+    public Builder readHeaders(InputStream in) throws IOException {
+      // parse the result headers until the first blank line
+      for (String line; (line = Util.readAsciiLine(in)).length() != 0; ) {
+        addLine(line);
+      }
+      return this;
+    }
+
+    public Headers build() {
+      return new Headers(this);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java
index 1ad36898e8..14fe3c8ff1 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java
@@ -18,6 +18,8 @@
 
 import com.squareup.okhttp.OkAuthenticator;
 import com.squareup.okhttp.OkAuthenticator.Challenge;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.net.Authenticator;
 import java.net.InetAddress;
@@ -84,44 +86,40 @@ private HttpAuthenticator() {
 
   /**
    * React to a failed authorization response by looking up new credentials.
-   *
-   * @return true if credentials have been added to successorRequestHeaders
-   *         and another request should be attempted.
+   * Returns a request for a subsequent attempt, or null if no further attempts
+   * should be made.
    */
-  public static boolean processAuthHeader(OkAuthenticator authenticator, int responseCode,
-      RawHeaders responseHeaders, RawHeaders successorRequestHeaders, Proxy proxy, URL url)
-      throws IOException {
+  public static Request processAuthHeader(
+      OkAuthenticator authenticator, Response response, Proxy proxy) throws IOException {
     String responseField;
     String requestField;
-    if (responseCode == HTTP_UNAUTHORIZED) {
+    if (response.code() == HTTP_UNAUTHORIZED) {
       responseField = "WWW-Authenticate";
       requestField = "Authorization";
-    } else if (responseCode == HTTP_PROXY_AUTH) {
+    } else if (response.code() == HTTP_PROXY_AUTH) {
       responseField = "Proxy-Authenticate";
       requestField = "Proxy-Authorization";
     } else {
       throw new IllegalArgumentException(); // TODO: ProtocolException?
     }
-    List<Challenge> challenges = parseChallenges(responseHeaders, responseField);
-    if (challenges.isEmpty()) {
-      return false; // Could not find a challenge so end the request cycle.
-    }
-    Credential credential = responseHeaders.getResponseCode() == HTTP_PROXY_AUTH
-        ? authenticator.authenticateProxy(proxy, url, challenges)
-        : authenticator.authenticate(proxy, url, challenges);
-    if (credential == null) {
-      return false; // Could not satisfy the challenge so end the request cycle.
-    }
+    List<Challenge> challenges = parseChallenges(response.headers(), responseField);
+    if (challenges.isEmpty()) return null; // Could not find a challenge so end the request cycle.
+
+    Request request = response.request();
+    Credential credential = response.code() == HTTP_PROXY_AUTH
+        ? authenticator.authenticateProxy(proxy, request.url(), challenges)
+        : authenticator.authenticate(proxy, request.url(), challenges);
+    if (credential == null) return null; // Couldn't satisfy the challenge so end the request cycle.
+
     // Add authorization credentials, bypassing the already-connected check.
-    successorRequestHeaders.set(requestField, credential.getHeaderValue());
-    return true;
+    return request.newBuilder().header(requestField, credential.getHeaderValue()).build();
   }
 
   /**
    * Parse RFC 2617 challenges. This API is only interested in the scheme
    * name and realm.
    */
-  private static List<Challenge> parseChallenges(RawHeaders responseHeaders,
+  private static List<Challenge> parseChallenges(Headers responseHeaders,
       String challengeHeader) {
     // auth-scheme = token
     // auth-param  = token "=" ( token | quoted-string )
@@ -129,11 +127,11 @@ public static boolean processAuthHeader(OkAuthenticator authenticator, int respo
     // realm       = "realm" "=" realm-value
     // realm-value = quoted-string
     List<Challenge> result = new ArrayList<Challenge>();
-    for (int h = 0; h < responseHeaders.length(); h++) {
-      if (!challengeHeader.equalsIgnoreCase(responseHeaders.getFieldName(h))) {
+    for (int h = 0; h < responseHeaders.size(); h++) {
+      if (!challengeHeader.equalsIgnoreCase(responseHeaders.name(h))) {
         continue;
       }
-      String value = responseHeaders.getValue(h);
+      String value = responseHeaders.value(h);
       int pos = 0;
       while (pos < value.length()) {
         int tokenStart = pos;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
index b4d2c7c07d..bc8407e572 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
@@ -26,7 +26,7 @@
 /**
  * Best-effort parser for HTTP dates.
  */
-final class HttpDate {
+public final class HttpDate {
 
   /**
    * Most websites serve cookies in the blessed format. Eagerly create the parser to ensure such
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 9c80f1bea3..da14c39d7e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -19,38 +19,32 @@
 
 import com.squareup.okhttp.Address;
 import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.OkResponseCache;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseSource;
+import com.squareup.okhttp.Route;
 import com.squareup.okhttp.TunnelRequest;
 import com.squareup.okhttp.internal.Dns;
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.CacheRequest;
-import java.net.CacheResponse;
 import java.net.CookieHandler;
-import java.net.HttpURLConnection;
-import java.net.Proxy;
-import java.net.URI;
-import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.UnknownHostException;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
 import java.util.zip.GZIPInputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
 
-import static com.squareup.okhttp.internal.Util.EMPTY_BYTE_ARRAY;
+import static com.squareup.okhttp.internal.Util.closeQuietly;
 import static com.squareup.okhttp.internal.Util.getDefaultPort;
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
+import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
 
 /**
  * Handles a single HTTP request/response pair. Each HTTP engine follows this
@@ -76,62 +70,51 @@
  * required, use {@link #automaticallyReleaseConnectionToPool()}.
  */
 public class HttpEngine {
-  private static final CacheResponse GATEWAY_TIMEOUT_RESPONSE = new CacheResponse() {
-    @Override public Map<String, List<String>> getHeaders() throws IOException {
-      Map<String, List<String>> result = new HashMap<String, List<String>>();
-      result.put(null, Collections.singletonList("HTTP/1.1 504 Gateway Timeout"));
-      return result;
-    }
-    @Override public InputStream getBody() throws IOException {
-      return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);
-    }
-  };
-  public static final int HTTP_CONTINUE = 100;
-
-  protected final Policy policy;
-  protected final OkHttpClient client;
+  final OkHttpClient client;
 
-  protected final String method;
-
-  private ResponseSource responseSource;
-
-  protected Connection connection;
-  protected RouteSelector routeSelector;
-  private OutputStream requestBodyOut;
+  Connection connection;
+  RouteSelector routeSelector;
+  private Route route;
 
   private Transport transport;
 
-  private InputStream responseTransferIn;
-  private InputStream responseBodyIn;
-
-  private CacheResponse cacheResponse;
-  private CacheRequest cacheRequest;
-
   /** The time when the request headers were written, or -1 if they haven't been written yet. */
   long sentRequestMillis = -1;
 
-  /** Whether the connection has been established. */
-  boolean connected;
-
   /**
    * True if this client added an "Accept-Encoding: gzip" header field and is
    * therefore responsible for also decompressing the transfer stream.
    */
   private boolean transparentGzip;
 
-  final URI uri;
+  /**
+   * True if the request body must be completely buffered before transmission;
+   * false if it can be streamed. Buffering has two advantages: we don't need
+   * the content-length in advance and we can retransmit if necessary. The
+   * upside of streaming is that we can save memory.
+   */
+  public final boolean bufferRequestBody;
+
+  private Request request;
+  private OutputStream requestBodyOut;
 
-  final RequestHeaders requestHeaders;
+  private ResponseSource responseSource;
 
   /** Null until a response is received from the network or the cache. */
-  ResponseHeaders responseHeaders;
+  private Response response;
+  private InputStream responseTransferIn;
+  private InputStream responseBodyIn;
 
-  // The cache response currently being validated on a conditional get. Null
-  // if the cached response doesn't exist or doesn't need validation. If the
-  // conditional get succeeds, these will be used for the response headers and
-  // body. If it fails, these be closed and set to null.
-  private ResponseHeaders cachedResponseHeaders;
-  private InputStream cachedResponseBody;
+  /**
+   * The cache response currently being validated on a conditional get. Null
+   * if the cached response doesn't exist or doesn't need validation. If the
+   * conditional get succeeds, these will be used for the response. If it fails,
+   * it will be set to null.
+   */
+  private Response validatingResponse;
+
+  /** The cache request currently being populated from a network response. */
+  private CacheRequest cacheRequest;
 
   /**
    * True if the socket connection should be released to the connection pool
@@ -143,32 +126,21 @@
   private boolean connectionReleased;
 
   /**
-   * @param requestHeaders the client's supplied request headers. This class
-   *     creates a private copy that it can mutate.
+   * @param request the HTTP request without a body. The body must be
+   *     written via the engine's request body stream.
    * @param connection the connection used for an intermediate response
    *     immediately prior to this request/response pair, such as a same-host
    *     redirect. This engine assumes ownership of the connection and must
    *     release it when it is unneeded.
    */
-  public HttpEngine(OkHttpClient client, Policy policy, String method, RawHeaders requestHeaders,
+  public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
       Connection connection, RetryableOutputStream requestBodyOut) throws IOException {
     this.client = client;
-    this.policy = policy;
-    this.method = method;
+    this.request = request;
+    this.bufferRequestBody = bufferRequestBody;
     this.connection = connection;
+    this.route = connection != null ? connection.getRoute() : null;
     this.requestBodyOut = requestBodyOut;
-
-    try {
-      uri = Platform.get().toUriLenient(policy.getURL());
-    } catch (URISyntaxException e) {
-      throw new IOException(e.getMessage());
-    }
-
-    this.requestHeaders = new RequestHeaders(uri, new RawHeaders(requestHeaders));
-  }
-
-  public URI getUri() {
-    return uri;
   }
 
   /**
@@ -177,119 +149,92 @@ public URI getUri() {
    * writing the request body if it exists.
    */
   public final void sendRequest() throws IOException {
-    if (responseSource != null) {
-      return;
-    }
+    if (responseSource != null) return; // Already sent.
+    if (transport != null) throw new IllegalStateException();
 
     prepareRawRequestHeaders();
-    initResponseSource();
     OkResponseCache responseCache = client.getOkResponseCache();
+
+    Response cacheResponse = responseCache != null
+        ? responseCache.get(request)
+        : null;
+    long now = System.currentTimeMillis();
+    CacheStrategy cacheStrategy = CacheStrategy.get(now, cacheResponse, request);
+    responseSource = cacheStrategy.source;
+    request = cacheStrategy.request;
+
     if (responseCache != null) {
       responseCache.trackResponse(responseSource);
     }
 
-    // The raw response source may require the network, but the request
-    // headers may forbid network use. In that case, dispose of the network
-    // response and use a GATEWAY_TIMEOUT response instead, as specified
-    // by http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.4.
-    if (requestHeaders.isOnlyIfCached() && responseSource.requiresConnection()) {
-      if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-        Util.closeQuietly(cachedResponseBody);
-      }
-      this.responseSource = ResponseSource.CACHE;
-      this.cacheResponse = GATEWAY_TIMEOUT_RESPONSE;
-      RawHeaders rawResponseHeaders = RawHeaders.fromMultimap(cacheResponse.getHeaders(), true);
-      setResponse(new ResponseHeaders(uri, rawResponseHeaders), cacheResponse.getBody());
+    if (responseSource != ResponseSource.NETWORK) {
+      validatingResponse = cacheStrategy.response;
     }
 
-    if (responseSource.requiresConnection()) {
-      sendSocketRequest();
-    } else if (connection != null) {
-      client.getConnectionPool().recycle(connection);
-      connection = null;
+    if (cacheResponse != null && !responseSource.usesCache()) {
+      closeQuietly(cacheResponse.body()); // We don't need this cached response. Close it.
     }
-  }
-
-  /**
-   * Initialize the source for this response. It may be corrected later if the
-   * request headers forbids network use.
-   */
-  private void initResponseSource() throws IOException {
-    responseSource = ResponseSource.NETWORK;
-    if (!policy.getUseCaches()) return;
 
-    OkResponseCache responseCache = client.getOkResponseCache();
-    if (responseCache == null) return;
+    if (responseSource.requiresConnection()) {
+      // Open a connection unless we inherited one from a redirect.
+      if (connection == null) {
+        connect();
+      }
 
-    CacheResponse candidate = responseCache.get(
-        uri, method, requestHeaders.getHeaders().toMultimap(false));
-    if (candidate == null) return;
+      transport = (Transport) connection.newTransport(this);
 
-    Map<String, List<String>> responseHeadersMap = candidate.getHeaders();
-    cachedResponseBody = candidate.getBody();
-    if (!acceptCacheResponseType(candidate)
-        || responseHeadersMap == null
-        || cachedResponseBody == null) {
-      Util.closeQuietly(cachedResponseBody);
-      return;
-    }
+      // Create a request body if we don't have one already. We'll already have
+      // one if we're retrying a failed POST.
+      if (hasRequestBody() && requestBodyOut == null) {
+        requestBodyOut = transport.createRequestBody(request);
+      }
 
-    RawHeaders rawResponseHeaders = RawHeaders.fromMultimap(responseHeadersMap, true);
-    cachedResponseHeaders = new ResponseHeaders(uri, rawResponseHeaders);
-    long now = System.currentTimeMillis();
-    this.responseSource = cachedResponseHeaders.chooseResponseSource(now, requestHeaders);
-    if (responseSource == ResponseSource.CACHE) {
-      this.cacheResponse = candidate;
-      setResponse(cachedResponseHeaders, cachedResponseBody);
-    } else if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-      this.cacheResponse = candidate;
-    } else if (responseSource == ResponseSource.NETWORK) {
-      Util.closeQuietly(cachedResponseBody);
     } else {
-      throw new AssertionError();
-    }
-  }
-
-  private void sendSocketRequest() throws IOException {
-    if (connection == null) {
-      connect();
-    }
+      // We're using a cached response. Close the connection we may have inherited from a redirect.
+      if (connection != null) {
+        disconnect();
+      }
 
-    if (transport != null) {
-      throw new IllegalStateException();
+      // No need for the network! Promote the cached response immediately.
+      this.response = validatingResponse;
+      if (validatingResponse.body() != null) {
+        initContentStream(validatingResponse.body().byteStream());
+      }
     }
+  }
 
-    transport = (Transport) connection.newTransport(this);
-
-    if (hasRequestBody() && requestBodyOut == null) {
-      // Create a request body if we don't have one already. We'll already
-      // have one if we're retrying a failed POST.
-      requestBodyOut = transport.createRequestBody();
-    }
+  private Response cacheableResponse() {
+    // Use an unreadable response body when offering the response to the cache.
+    // The cache isn't allowed to consume the response body bytes!
+    return response.newBuilder()
+        .body(new UnreadableResponseBody(response.getContentType(),
+            response.getContentLength()))
+        .build();
   }
 
   /** Connect to the origin server either directly or via a proxy. */
-  protected final void connect() throws IOException {
-    if (connection != null) {
-      return;
-    }
+  private void connect() throws IOException {
+    if (connection != null) throw new IllegalStateException();
+
     if (routeSelector == null) {
-      String uriHost = uri.getHost();
-      if (uriHost == null) {
-        throw new UnknownHostException(uri.toString());
+      String uriHost = request.url().getHost();
+      if (uriHost == null || uriHost.length() == 0) {
+        throw new UnknownHostException(request.url().toString());
       }
       SSLSocketFactory sslSocketFactory = null;
       HostnameVerifier hostnameVerifier = null;
-      if (uri.getScheme().equalsIgnoreCase("https")) {
+      if (request.isHttps()) {
         sslSocketFactory = client.getSslSocketFactory();
         hostnameVerifier = client.getHostnameVerifier();
       }
-      Address address = new Address(uriHost, getEffectivePort(uri), sslSocketFactory,
+      Address address = new Address(uriHost, getEffectivePort(request.url()), sslSocketFactory,
           hostnameVerifier, client.getAuthenticator(), client.getProxy(), client.getTransports());
-      routeSelector = new RouteSelector(address, uri, client.getProxySelector(),
+      routeSelector = new RouteSelector(address, request.uri(), client.getProxySelector(),
           client.getConnectionPool(), Dns.getDefault(), client.getRoutesDatabase());
     }
-    connection = routeSelector.next(method);
+
+    connection = routeSelector.next(request.method());
+
     if (!connection.isConnected()) {
       connection.connect(client.getConnectTimeout(), client.getReadTimeout(), getTunnelConfig());
       client.getConnectionPool().maybeShare(connection);
@@ -297,20 +242,17 @@ protected final void connect() throws IOException {
     } else {
       connection.updateReadTimeout(client.getReadTimeout());
     }
-    connected(connection);
-    if (connection.getRoute().getProxy() != client.getProxy()) {
-      // Update the request line if the proxy changed; it may need a host name.
-      requestHeaders.getHeaders().setRequestLine(getRequestLine());
-    }
+
+    route = connection.getRoute();
   }
 
   /**
-   * Called after a socket connection has been created or retrieved from the
-   * pool. Subclasses use this hook to get a reference to the TLS data.
+   * Recycle the connection to the origin server. It is an error to call this
+   * with a request in flight.
    */
-  protected void connected(Connection connection) {
-    policy.setSelectedProxy(connection.getRoute().getProxy());
-    connected = true;
+  private void disconnect() {
+    client.getConnectionPool().recycle(connection);
+    connection = null;
   }
 
   /**
@@ -318,100 +260,65 @@ protected void connected(Connection connection) {
    * This is used to observe the sent time should the request be cached.
    */
   public void writingRequestHeaders() {
-    if (sentRequestMillis != -1) {
-      throw new IllegalStateException();
-    }
+    if (sentRequestMillis != -1) throw new IllegalStateException();
     sentRequestMillis = System.currentTimeMillis();
   }
 
-  /**
-   * @param body the response body, or null if it doesn't exist or isn't
-   * available.
-   */
-  private void setResponse(ResponseHeaders headers, InputStream body) throws IOException {
-    if (this.responseBodyIn != null) {
-      throw new IllegalStateException();
-    }
-    this.responseHeaders = headers;
-    if (body != null) {
-      initContentStream(body);
-    }
-  }
-
   boolean hasRequestBody() {
+    String method = request.method();
     return method.equals("POST") || method.equals("PUT") || method.equals("PATCH");
   }
 
   /** Returns the request body or null if this request doesn't have a body. */
   public final OutputStream getRequestBody() {
-    if (responseSource == null) {
-      throw new IllegalStateException();
-    }
+    if (responseSource == null) throw new IllegalStateException();
     return requestBodyOut;
   }
 
   public final boolean hasResponse() {
-    return responseHeaders != null;
+    return response != null;
   }
 
-  public final RequestHeaders getRequestHeaders() {
-    return requestHeaders;
+  public final Request getRequest() {
+    return request;
   }
 
-  public final ResponseHeaders getResponseHeaders() {
-    if (responseHeaders == null) {
-      throw new IllegalStateException();
-    }
-    return responseHeaders;
-  }
-
-  public final int getResponseCode() {
-    if (responseHeaders == null) {
-      throw new IllegalStateException();
-    }
-    return responseHeaders.getHeaders().getResponseCode();
+  /** Returns the engine's response. */
+  // TODO: the returned body will always be null.
+  public final Response getResponse() {
+    if (response == null) throw new IllegalStateException();
+    return response;
   }
 
   public final InputStream getResponseBody() {
-    if (responseHeaders == null) {
-      throw new IllegalStateException();
-    }
+    if (response == null) throw new IllegalStateException();
     return responseBodyIn;
   }
 
-  public final CacheResponse getCacheResponse() {
-    return cacheResponse;
-  }
-
   public final Connection getConnection() {
     return connection;
   }
 
   /**
-   * Returns true if {@code cacheResponse} is of the right type. This
-   * condition is necessary but not sufficient for the cached response to
-   * be used.
+   * Returns the route used to retrieve the response. Null if we haven't
+   * connected yet, or if no connection was necessary.
    */
-  protected boolean acceptCacheResponseType(CacheResponse cacheResponse) {
-    return true;
+  public Route getRoute() {
+    return route;
   }
 
   private void maybeCache() throws IOException {
-    // Are we caching at all?
-    if (!policy.getUseCaches()) return;
     OkResponseCache responseCache = client.getOkResponseCache();
     if (responseCache == null) return;
 
-    HttpURLConnection connectionToCache = policy.getHttpConnectionToCache();
-
     // Should we cache this response for this request?
-    if (!responseHeaders.isCacheable(requestHeaders)) {
-      responseCache.maybeRemove(connectionToCache.getRequestMethod(), uri);
+    if (!CacheStrategy.isCacheable(response, request)) {
+      responseCache.maybeRemove(request);
       return;
     }
 
     // Offer this request to the cache.
-    cacheRequest = responseCache.put(uri, connectionToCache);
+    cacheRequest = responseCache.put(cacheableResponse());
   }
 
   /**
@@ -423,8 +330,7 @@ private void maybeCache() throws IOException {
   public final void automaticallyReleaseConnectionToPool() {
     automaticallyReleaseConnectionToPool = true;
     if (connection != null && connectionReleased) {
-      client.getConnectionPool().recycle(connection);
-      connection = null;
+      disconnect();
     }
   }
 
@@ -435,36 +341,39 @@ public final void automaticallyReleaseConnectionToPool() {
    */
   public final void release(boolean streamCanceled) {
     // If the response body comes from the cache, close it.
-    if (responseBodyIn == cachedResponseBody) {
-      Util.closeQuietly(responseBodyIn);
+    if (validatingResponse != null
+        && validatingResponse.body() != null
+        && responseBodyIn == validatingResponse.body().byteStream()) {
+      closeQuietly(responseBodyIn);
     }
 
-    if (!connectionReleased && connection != null) {
+    if (connection != null && !connectionReleased) {
       connectionReleased = true;
 
       if (transport == null
           || !transport.makeReusable(streamCanceled, requestBodyOut, responseTransferIn)) {
-        Util.closeQuietly(connection);
+        closeQuietly(connection);
         connection = null;
       } else if (automaticallyReleaseConnectionToPool) {
-        client.getConnectionPool().recycle(connection);
-        connection = null;
+        disconnect();
       }
     }
   }
 
   private void initContentStream(InputStream transferStream) throws IOException {
     responseTransferIn = transferStream;
-    if (transparentGzip && responseHeaders.isContentEncodingGzip()) {
+    if (transparentGzip && "gzip".equalsIgnoreCase(response.header("Content-Encoding"))) {
       // If the response was transparently gzipped, remove the gzip header field
       // so clients don't double decompress. http://b/3009828
       //
       // Also remove the Content-Length in this case because it contains the
-      // length 528 of the gzipped response. This isn't terribly useful and is
-      // dangerous because 529 clients can query the content length, but not
-      // the content encoding.
-      responseHeaders.stripContentEncoding();
-      responseHeaders.stripContentLength();
+      // length of the gzipped response. This isn't terribly useful and is
+      // dangerous because clients can query the content length, but not the
+      // content encoding.
+      response = response.newBuilder()
+          .removeHeader("Content-Encoding")
+          .removeHeader("Content-Length")
+          .build();
       responseBodyIn = new GZIPInputStream(transferStream);
     } else {
       responseBodyIn = transferStream;
@@ -476,23 +385,23 @@ private void initContentStream(InputStream transferStream) throws IOException {
    * See RFC 2616 section 4.3.
    */
   public final boolean hasResponseBody() {
-    int responseCode = responseHeaders.getHeaders().getResponseCode();
-
     // HEAD requests never yield a body regardless of the response headers.
-    if (method.equals("HEAD")) {
+    if (request.method().equals("HEAD")) {
       return false;
     }
 
+    int responseCode = response.code();
     if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
-        && responseCode != HttpURLConnectionImpl.HTTP_NO_CONTENT
-        && responseCode != HttpURLConnectionImpl.HTTP_NOT_MODIFIED) {
+        && responseCode != HTTP_NO_CONTENT
+        && responseCode != HTTP_NOT_MODIFIED) {
       return true;
     }
 
     // If the Content-Length or Transfer-Encoding headers disagree with the
     // response code, the response is malformed. For best compatibility, we
     // honor the headers.
-    if (responseHeaders.getContentLength() != -1 || responseHeaders.isChunked()) {
+    if (response.getContentLength() != -1
+        || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
       return true;
     }
 
@@ -500,96 +409,42 @@ public final boolean hasResponseBody() {
   }
 
   /**
-   * Populates requestHeaders with defaults and cookies.
+   * Populates request with defaults and cookies.
    *
    * <p>This client doesn't specify a default {@code Accept} header because it
    * doesn't know what content types the application is interested in.
    */
   private void prepareRawRequestHeaders() throws IOException {
-    requestHeaders.getHeaders().setRequestLine(getRequestLine());
+    Request.Builder result = request.newBuilder();
 
-    if (requestHeaders.getUserAgent() == null) {
-      requestHeaders.setUserAgent(getDefaultUserAgent());
+    if (request.getUserAgent() == null) {
+      result.setUserAgent(getDefaultUserAgent());
     }
 
-    if (requestHeaders.getHost() == null) {
-      requestHeaders.setHost(getOriginAddress(policy.getURL()));
+    if (request.header("Host") == null) {
+      result.header("Host", hostHeader(request.url()));
     }
 
     if ((connection == null || connection.getHttpMinorVersion() != 0)
-        && requestHeaders.getConnection() == null) {
-      requestHeaders.setConnection("Keep-Alive");
+        && request.header("Connection") == null) {
+      result.header("Connection", "Keep-Alive");
     }
 
-    if (requestHeaders.getAcceptEncoding() == null) {
+    if (request.header("Accept-Encoding") == null) {
       transparentGzip = true;
-      requestHeaders.setAcceptEncoding("gzip");
-    }
-
-    if (hasRequestBody() && requestHeaders.getContentType() == null) {
-      requestHeaders.setContentType("application/x-www-form-urlencoded");
+      result.header("Accept-Encoding", "gzip");
     }
 
-    long ifModifiedSince = policy.getIfModifiedSince();
-    if (ifModifiedSince != 0) {
-      requestHeaders.setIfModifiedSince(new Date(ifModifiedSince));
+    if (hasRequestBody() && request.getContentType() == null) {
+      result.setContentType("application/x-www-form-urlencoded");
     }
 
     CookieHandler cookieHandler = client.getCookieHandler();
     if (cookieHandler != null) {
-      requestHeaders.addCookies(
-          cookieHandler.get(uri, requestHeaders.getHeaders().toMultimap(false)));
+      result.addCookies(cookieHandler.get(request.uri(), request.getHeaders().toMultimap(null)));
     }
-  }
 
-  /**
-   * Returns the request status line, like "GET / HTTP/1.1". This is exposed
-   * to the application by {@link HttpURLConnectionImpl#getHeaderFields}, so
-   * it needs to be set even if the transport is SPDY.
-   */
-  String getRequestLine() {
-    String protocol =
-        (connection == null || connection.getHttpMinorVersion() != 0) ? "HTTP/1.1" : "HTTP/1.0";
-    return method + " " + requestString() + " " + protocol;
-  }
-
-  private String requestString() {
-    URL url = policy.getURL();
-    if (includeAuthorityInRequestLine()) {
-      return url.toString();
-    } else {
-      return requestPath(url);
-    }
-  }
-
-  /**
-   * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never
-   * empty, even if the request URL is. Includes the query component if it
-   * exists.
-   */
-  public static String requestPath(URL url) {
-    String fileOnly = url.getFile();
-    if (fileOnly == null) {
-      return "/";
-    } else if (!fileOnly.startsWith("/")) {
-      return "/" + fileOnly;
-    } else {
-      return fileOnly;
-    }
-  }
-
-  /**
-   * Returns true if the request line should contain the full URL with host
-   * and port (like "GET http://android.com/foo HTTP/1.1") or only the path
-   * (like "GET /foo HTTP/1.1").
-   *
-   * <p>This is non-final because for HTTPS it's never necessary to supply the
-   * full URL, even if a proxy is in use.
-   */
-  protected boolean includeAuthorityInRequestLine() {
-    return connection == null
-        ? policy.usingProxy() // A proxy was requested.
-        : connection.getRoute().getProxy().type() == Proxy.Type.HTTP; // A proxy was selected.
+    request = result.build();
   }
 
   public static String getDefaultUserAgent() {
@@ -597,13 +452,10 @@ public static String getDefaultUserAgent() {
     return agent != null ? agent : ("Java" + System.getProperty("java.version"));
   }
 
-  public static String getOriginAddress(URL url) {
-    int port = url.getPort();
-    String result = url.getHost();
-    if (port > 0 && port != getDefaultPort(url.getProtocol())) {
-      result = result + ":" + port;
-    }
-    return result;
+  public static String hostHeader(URL url) {
+    return getEffectivePort(url) != getDefaultPort(url.getProtocol())
+        ? url.getHost() + ":" + url.getPort()
+        : url.getHost();
   }
 
   /**
@@ -611,25 +463,18 @@ public static String getOriginAddress(URL url) {
    * headers and starts reading the HTTP response body if it exists.
    */
   public final void readResponse() throws IOException {
-    if (hasResponse()) {
-      responseHeaders.setResponseSource(responseSource);
-      return;
-    }
-
-    if (responseSource == null) {
-      throw new IllegalStateException("readResponse() without sendRequest()");
-    }
-
-    if (!responseSource.requiresConnection()) {
-      return;
-    }
+    if (response != null) return;
+    if (responseSource == null) throw new IllegalStateException("call sendRequest() first!");
+    if (!responseSource.requiresConnection()) return;
 
     if (sentRequestMillis == -1) {
-      if (requestBodyOut instanceof RetryableOutputStream) {
+      if (request.getContentLength() == -1
+          && requestBodyOut instanceof RetryableOutputStream) {
+        // We might not learn the Content-Length until the request body has been buffered.
         int contentLength = ((RetryableOutputStream) requestBodyOut).contentLength();
-        requestHeaders.setContentLength(contentLength);
+        request = request.newBuilder().setContentLength(contentLength).build();
       }
-      transport.writeRequestHeaders();
+      transport.writeRequestHeaders(request);
     }
 
     if (requestBodyOut != null) {
@@ -641,46 +486,127 @@ public final void readResponse() throws IOException {
 
     transport.flushRequest();
 
-    responseHeaders = transport.readResponseHeaders();
-    responseHeaders.setLocalTimestamps(sentRequestMillis, System.currentTimeMillis());
-    responseHeaders.setResponseSource(responseSource);
+    response = transport.readResponseHeaders()
+        .request(request)
+        .handshake(connection.getHandshake())
+        .header(SyntheticHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
+        .header(SyntheticHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
+        .setResponseSource(responseSource)
+        .build();
+    connection.setHttpMinorVersion(response.httpMinorVersion());
+    receiveHeaders(response.headers());
 
     if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-      if (cachedResponseHeaders.validate(responseHeaders)) {
+      if (validatingResponse.validate(response)) {
         release(false);
-        ResponseHeaders combinedHeaders = cachedResponseHeaders.combine(responseHeaders);
-        this.responseHeaders = combinedHeaders;
+        response = combine(validatingResponse, response);
 
-        // Update the cache after applying the combined headers but before initializing the content
-        // stream, otherwise the Content-Encoding header (if present) will be stripped from the
-        // combined headers and not end up in the cache file if transparent gzip compression is
-        // turned on.
+        // Update the cache after combining headers but before stripping the
+        // Content-Encoding header (as performed by initContentStream()).
         OkResponseCache responseCache = client.getOkResponseCache();
         responseCache.trackConditionalCacheHit();
-        responseCache.update(cacheResponse, policy.getHttpConnectionToCache());
+        responseCache.update(validatingResponse, cacheableResponse());
 
-        initContentStream(cachedResponseBody);
+        if (validatingResponse.body() != null) {
+          initContentStream(validatingResponse.body().byteStream());
+        }
         return;
       } else {
-        Util.closeQuietly(cachedResponseBody);
+        closeQuietly(validatingResponse.body());
       }
     }
 
     if (hasResponseBody()) {
-      maybeCache(); // reentrant. this calls into user code which may call back into this!
+      maybeCache();
     }
 
     initContentStream(transport.getTransferStream(cacheRequest));
   }
 
-  protected TunnelRequest getTunnelConfig() {
-    return null;
+  /**
+   * Combines cached headers with a network headers as defined by RFC 2616,
+   * 13.5.3.
+   */
+  private static Response combine(Response cached, Response network) throws IOException {
+    Headers.Builder result = new Headers.Builder();
+
+    for (int i = 0; i < cached.headerCount(); i++) {
+      String fieldName = cached.headerName(i);
+      String value = cached.headerValue(i);
+      if ("Warning".equals(fieldName) && value.startsWith("1")) {
+        continue; // drop 100-level freshness warnings
+      }
+      if (!isEndToEnd(fieldName) || network.header(fieldName) == null) {
+        result.add(fieldName, value);
+      }
+    }
+
+    for (int i = 0; i < network.headerCount(); i++) {
+      String fieldName = network.headerName(i);
+      if (isEndToEnd(fieldName)) {
+        result.add(fieldName, network.headerValue(i));
+      }
+    }
+
+    return cached.newBuilder().headers(result.build()).build();
   }
 
-  public void receiveHeaders(RawHeaders headers) throws IOException {
+  /**
+   * Returns true if {@code fieldName} is an end-to-end HTTP header, as
+   * defined by RFC 2616, 13.5.1.
+   */
+  private static boolean isEndToEnd(String fieldName) {
+    return !"Connection".equalsIgnoreCase(fieldName)
+        && !"Keep-Alive".equalsIgnoreCase(fieldName)
+        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
+        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
+        && !"TE".equalsIgnoreCase(fieldName)
+        && !"Trailers".equalsIgnoreCase(fieldName)
+        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
+        && !"Upgrade".equalsIgnoreCase(fieldName);
+  }
+
+  private TunnelRequest getTunnelConfig() {
+    if (!request.isHttps()) return null;
+
+    String userAgent = request.getUserAgent();
+    if (userAgent == null) userAgent = getDefaultUserAgent();
+
+    URL url = request.url();
+    return new TunnelRequest(url.getHost(), getEffectivePort(url), userAgent,
+        request.getProxyAuthorization());
+  }
+
+  public void receiveHeaders(Headers headers) throws IOException {
     CookieHandler cookieHandler = client.getCookieHandler();
     if (cookieHandler != null) {
-      cookieHandler.put(uri, headers.toMultimap(true));
+      cookieHandler.put(request.uri(), headers.toMultimap(null));
+    }
+  }
+
+  static class UnreadableResponseBody extends Response.Body {
+    private final String contentType;
+    private final long contentLength;
+
+    public UnreadableResponseBody(String contentType, long contentLength) {
+      this.contentType = contentType;
+      this.contentLength = contentLength;
+    }
+
+    @Override public boolean ready() throws IOException {
+      throw new IllegalStateException("It is an error to read this response body at this time.");
+    }
+
+    @Override public MediaType contentType() {
+      return contentType != null ? MediaType.parse(contentType) : null;
+    }
+
+    @Override public long contentLength() {
+      return contentLength;
+    }
+
+    @Override public InputStream byteStream() {
+      throw new IllegalStateException("It is an error to read this response body at this time.");
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
index f8f9f17266..ab9261f323 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
@@ -17,6 +17,8 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.AbstractOutputStream;
 import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayOutputStream;
@@ -28,6 +30,7 @@
 import java.net.Socket;
 
 import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
 
 public final class HttpTransport implements Transport {
   /**
@@ -58,49 +61,41 @@ public HttpTransport(HttpEngine httpEngine, OutputStream outputStream, InputStre
     this.socketIn = inputStream;
   }
 
-  @Override public OutputStream createRequestBody() throws IOException {
-    boolean chunked = httpEngine.requestHeaders.isChunked();
-    if (!chunked
-        && httpEngine.policy.getChunkLength() > 0
-        && httpEngine.connection.getHttpMinorVersion() != 0) {
-      httpEngine.requestHeaders.setChunked();
-      chunked = true;
-    }
+  @Override public OutputStream createRequestBody(Request request) throws IOException {
+    long contentLength = request.getContentLength();
 
-    // Stream a request body of unknown length.
-    if (chunked) {
-      int chunkLength = httpEngine.policy.getChunkLength();
-      if (chunkLength == -1) {
-        chunkLength = DEFAULT_CHUNK_LENGTH;
+    if (httpEngine.bufferRequestBody) {
+      if (contentLength > Integer.MAX_VALUE) {
+        throw new IllegalStateException("Use setFixedLengthStreamingMode() or "
+            + "setChunkedStreamingMode() for requests larger than 2 GiB.");
       }
-      writeRequestHeaders();
-      return new ChunkedOutputStream(requestOut, chunkLength);
-    }
 
-    // Stream a request body of a known length.
-    long fixedContentLength = httpEngine.policy.getFixedContentLength();
-    if (fixedContentLength != -1) {
-      httpEngine.requestHeaders.setContentLength(fixedContentLength);
-      writeRequestHeaders();
-      return new FixedLengthOutputStream(requestOut, fixedContentLength);
+      if (contentLength != -1) {
+        // Buffer a request body of a known length.
+        writeRequestHeaders(request);
+        return new RetryableOutputStream((int) contentLength);
+      } else {
+        // Buffer a request body of an unknown length. Don't write request
+        // headers until the entire body is ready; otherwise we can't set the
+        // Content-Length header correctly.
+        return new RetryableOutputStream();
+      }
     }
 
-    long contentLength = httpEngine.requestHeaders.getContentLength();
-    if (contentLength > Integer.MAX_VALUE) {
-      throw new IllegalArgumentException("Use setFixedLengthStreamingMode() or "
-          + "setChunkedStreamingMode() for requests larger than 2 GiB.");
+    if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
+      // Stream a request body of unknown length.
+      writeRequestHeaders(request);
+      return new ChunkedOutputStream(requestOut, DEFAULT_CHUNK_LENGTH);
     }
 
-    // Buffer a request body of a known length.
     if (contentLength != -1) {
-      writeRequestHeaders();
-      return new RetryableOutputStream((int) contentLength);
+      // Stream a request body of a known length.
+      writeRequestHeaders(request);
+      return new FixedLengthOutputStream(requestOut, contentLength);
     }
 
-    // Buffer a request body of an unknown length. Don't write request
-    // headers until the entire body is ready; otherwise we can't set the
-    // Content-Length header correctly.
-    return new RetryableOutputStream();
+    throw new IllegalStateException(
+        "Cannot stream a request body without chunked encoding or a known content length!");
   }
 
   @Override public void flushRequest() throws IOException {
@@ -124,21 +119,49 @@ public HttpTransport(HttpEngine httpEngine, OutputStream outputStream, InputStre
    * This ensures that the {@code Content-Length} header field receives the
    * proper value.
    */
-  public void writeRequestHeaders() throws IOException {
+  public void writeRequestHeaders(Request request) throws IOException {
     httpEngine.writingRequestHeaders();
-    RawHeaders headersToSend = httpEngine.requestHeaders.getHeaders();
-    byte[] bytes = headersToSend.toBytes();
-    requestOut.write(bytes);
+    String requestLine = RequestLine.get(request,
+        httpEngine.connection.getRoute().getProxy().type(),
+        httpEngine.connection.getHttpMinorVersion());
+    writeRequest(requestOut, request.getHeaders(), requestLine);
   }
 
-  @Override public ResponseHeaders readResponseHeaders() throws IOException {
-    RawHeaders rawHeaders = RawHeaders.fromBytes(socketIn);
-    httpEngine.connection.setHttpMinorVersion(rawHeaders.getHttpMinorVersion());
-    httpEngine.receiveHeaders(rawHeaders);
+  @Override public Response.Builder readResponseHeaders() throws IOException {
+    return readResponse(socketIn);
+  }
 
-    ResponseHeaders headers = new ResponseHeaders(httpEngine.uri, rawHeaders);
-    headers.setTransport("http/1.1");
-    return headers;
+  /** Returns bytes of a request header for sending on an HTTP transport. */
+  public static void writeRequest(OutputStream out, Headers headers, String requestLine)
+      throws IOException {
+    StringBuilder result = new StringBuilder(256);
+    result.append(requestLine).append("\r\n");
+    for (int i = 0; i < headers.size(); i ++) {
+      result.append(headers.name(i))
+          .append(": ")
+          .append(headers.value(i))
+          .append("\r\n");
+    }
+    result.append("\r\n");
+    out.write(result.toString().getBytes("ISO-8859-1"));
+  }
+
+  /** Parses bytes of a response header from an HTTP transport. */
+  public static Response.Builder readResponse(InputStream in) throws IOException {
+    while (true) {
+      String statusLineString = Util.readAsciiLine(in);
+      StatusLine statusLine = new StatusLine(statusLineString);
+
+      Response.Builder responseBuilder = new Response.Builder()
+          .statusLine(statusLine)
+          .header(SyntheticHeaders.SELECTED_TRANSPORT, "http/1.1");
+
+      Headers.Builder headersBuilder = new Headers.Builder();
+      headersBuilder.readHeaders(in);
+      responseBuilder.headers(headersBuilder.build());
+
+      if (statusLine.code() != HTTP_CONTINUE) return responseBuilder;
+    }
   }
 
   public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
@@ -153,12 +176,13 @@ public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
     }
 
     // If the request specified that the connection shouldn't be reused, don't reuse it.
-    if (httpEngine.requestHeaders.hasConnectionClose()) {
+    if ("close".equalsIgnoreCase(httpEngine.getRequest().header("Connection"))) {
       return false;
     }
 
     // If the response specified that the connection shouldn't be reused, don't reuse it.
-    if (httpEngine.responseHeaders != null && httpEngine.responseHeaders.hasConnectionClose()) {
+    if (httpEngine.getResponse() != null
+        && "close".equalsIgnoreCase(httpEngine.getResponse().header("Connection"))) {
       return false;
     }
 
@@ -206,13 +230,13 @@ private static boolean discardStream(HttpEngine httpEngine, InputStream response
       return new FixedLengthInputStream(socketIn, cacheRequest, httpEngine, 0);
     }
 
-    if (httpEngine.responseHeaders.isChunked()) {
+    if ("chunked".equalsIgnoreCase(httpEngine.getResponse().header("Transfer-Encoding"))) {
       return new ChunkedInputStream(socketIn, cacheRequest, this);
     }
 
-    if (httpEngine.responseHeaders.getContentLength() != -1) {
+    if (httpEngine.getResponse().getContentLength() != -1) {
       return new FixedLengthInputStream(socketIn, cacheRequest, httpEngine,
-          httpEngine.responseHeaders.getContentLength());
+          httpEngine.getResponse().getContentLength());
     }
 
     // Wrap the input stream from the connection (rather than just returning
@@ -370,10 +394,10 @@ private void writeBufferedChunkToSocket() throws IOException {
 
   /** An HTTP body with a fixed length specified in advance. */
   private static class FixedLengthInputStream extends AbstractHttpInputStream {
-    private int bytesRemaining;
+    private long bytesRemaining;
 
     public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEngine httpEngine,
-        int length) throws IOException {
+        long length) throws IOException {
       super(is, httpEngine, cacheRequest);
       bytesRemaining = length;
       if (bytesRemaining == 0) {
@@ -387,7 +411,7 @@ public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEng
       if (bytesRemaining == 0) {
         return -1;
       }
-      int read = in.read(buffer, offset, Math.min(count, bytesRemaining));
+      int read = in.read(buffer, offset, (int) Math.min(count, bytesRemaining));
       if (read == -1) {
         unexpectedEndOfInput(); // the server didn't supply the promised content length
         throw new ProtocolException("unexpected end of stream");
@@ -402,7 +426,7 @@ public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEng
 
     @Override public int available() throws IOException {
       checkNotClosed();
-      return bytesRemaining == 0 ? 0 : Math.min(in.available(), bytesRemaining);
+      return bytesRemaining == 0 ? 0 : (int) Math.min(in.available(), bytesRemaining);
     }
 
     @Override public void close() throws IOException {
@@ -469,9 +493,10 @@ private void readChunkSize() throws IOException {
       }
       if (bytesRemainingInChunk == 0) {
         hasMoreChunks = false;
-        RawHeaders rawResponseHeaders = httpEngine.responseHeaders.getHeaders();
-        RawHeaders.readHeaders(transport.socketIn, rawResponseHeaders);
-        httpEngine.receiveHeaders(rawResponseHeaders);
+        Headers trailers = new Headers.Builder()
+            .readHeaders(transport.socketIn)
+            .build();
+        httpEngine.receiveHeaders(trailers);
         endOfInput();
       }
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
index 0ba02281c7..1517ebaa73 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
@@ -19,6 +19,9 @@
 
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.Route;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
 import java.io.FileNotFoundException;
@@ -36,12 +39,14 @@
 import java.security.cert.CertificateException;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Date;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLHandshakeException;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
 /**
  * This implementation uses HttpEngine to send requests and receive responses.
@@ -53,14 +58,9 @@
  * is <strong>not</strong> used to indicate not whether this URLConnection is
  * currently connected. Instead, it indicates whether a connection has ever been
  * attempted. Once a connection has been attempted, certain properties (request
- * header fields, request method, etc.) are immutable. Test the {@code
- * connection} field on this class for null/non-null to determine of an instance
- * is currently connected to a server.
+ * header fields, request method, etc.) are immutable.
  */
-public class HttpURLConnectionImpl extends HttpURLConnection implements Policy {
-
-  /** Numeric status code, 307: Temporary Redirect. */
-  static final int HTTP_TEMP_REDIRECT = 307;
+public class HttpURLConnectionImpl extends HttpURLConnection {
 
   /**
    * How many redirects should we follow? Chrome follows 21; Firefox, curl,
@@ -70,13 +70,19 @@
 
   final OkHttpClient client;
 
-  private final RawHeaders rawRequestHeaders = new RawHeaders();
+  private Headers.Builder requestHeaders = new Headers.Builder();
+
   /** Like the superclass field of the same name, but a long and available on all platforms. */
   private long fixedContentLength = -1;
   private int redirectionCount;
   protected IOException httpEngineFailure;
   protected HttpEngine httpEngine;
-  private Proxy selectedProxy;
+
+  /**
+   * The most recently attempted route. This will be null if we haven't sent a
+   * request yet, or if the response comes from a cache.
+   */
+  private Route route;
 
   public HttpURLConnectionImpl(URL url, OkHttpClient client) {
     super(url);
@@ -113,7 +119,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
   @Override public final InputStream getErrorStream() {
     try {
       HttpEngine response = getResponse();
-      if (response.hasResponseBody() && response.getResponseCode() >= HTTP_BAD_REQUEST) {
+      if (response.hasResponseBody() && response.getResponse().code() >= HTTP_BAD_REQUEST) {
         return response.getResponseBody();
       }
       return null;
@@ -128,7 +134,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
    */
   @Override public final String getHeaderField(int position) {
     try {
-      return getResponse().getResponseHeaders().getHeaders().getValue(position);
+      return getResponse().getResponse().headers().value(position);
     } catch (IOException e) {
       return null;
     }
@@ -141,8 +147,8 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
    */
   @Override public final String getHeaderField(String fieldName) {
     try {
-      RawHeaders rawHeaders = getResponse().getResponseHeaders().getHeaders();
-      return fieldName == null ? rawHeaders.getStatusLine() : rawHeaders.get(fieldName);
+      Response response = getResponse().getResponse();
+      return fieldName == null ? response.statusLine() : response.headers().get(fieldName);
     } catch (IOException e) {
       return null;
     }
@@ -150,7 +156,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
 
   @Override public final String getHeaderFieldKey(int position) {
     try {
-      return getResponse().getResponseHeaders().getHeaders().getFieldName(position);
+      return getResponse().getResponse().headers().name(position);
     } catch (IOException e) {
       return null;
     }
@@ -158,7 +164,8 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
 
   @Override public final Map<String, List<String>> getHeaderFields() {
     try {
-      return getResponse().getResponseHeaders().getHeaders().toMultimap(true);
+      Response response = getResponse().getResponse();
+      return response.headers().toMultimap(response.statusLine());
     } catch (IOException e) {
       return Collections.emptyMap();
     }
@@ -169,7 +176,11 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
       throw new IllegalStateException(
           "Cannot access request header fields after connection is set");
     }
-    return rawRequestHeaders.toMultimap(false);
+
+    // For the request line property assigned to the null key, just use no proxy and HTTP 1.1.
+    Request request = new Request.Builder().url(getURL()).method(method, null).build();
+    String requestLine = RequestLine.get(request, null, 1);
+    return requestHeaders.build().toMultimap(requestLine);
   }
 
   @Override public final InputStream getInputStream() throws IOException {
@@ -219,10 +230,8 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
   }
 
   @Override public final String getRequestProperty(String field) {
-    if (field == null) {
-      return null;
-    }
-    return rawRequestHeaders.get(field);
+    if (field == null) return null;
+    return requestHeaders.get(field);
   }
 
   @Override public void setConnectTimeout(int timeoutMillis) {
@@ -259,26 +268,43 @@ private void initHttpEngine() throws IOException {
           throw new ProtocolException(method + " does not support writing");
         }
       }
-      httpEngine = newHttpEngine(method, rawRequestHeaders, null, null);
+      httpEngine = newHttpEngine(method, null, null);
     } catch (IOException e) {
       httpEngineFailure = e;
       throw e;
     }
   }
 
-  @Override public HttpURLConnection getHttpConnectionToCache() {
-    return this;
-  }
+  private HttpEngine newHttpEngine(String method, Connection connection,
+      RetryableOutputStream requestBody) throws IOException {
+    Request.Builder builder = new Request.Builder()
+        .url(getURL())
+        .method(method, null /* No body; that's passed separately. */);
+    Headers headers = requestHeaders.build();
+    for (int i = 0; i < headers.size(); i++) {
+      builder.addHeader(headers.name(i), headers.value(i));
+    }
 
-  private HttpEngine newHttpEngine(String method, RawHeaders requestHeaders,
-      Connection connection, RetryableOutputStream requestBody) throws IOException {
-    if (url.getProtocol().equals("http")) {
-      return new HttpEngine(client, this, method, requestHeaders, connection, requestBody);
-    } else if (url.getProtocol().equals("https")) {
-      return new HttpsEngine(client, this, method, requestHeaders, connection, requestBody);
+    boolean bufferRequestBody;
+    if (fixedContentLength != -1) {
+      bufferRequestBody = false;
+      builder.header("Content-Length", Long.toString(fixedContentLength));
+    } else if (chunkLength > 0) {
+      bufferRequestBody = false;
+      builder.header("Transfer-Encoding", "chunked");
     } else {
-      throw new AssertionError();
+      bufferRequestBody = true;
     }
+
+    Request request = builder.build();
+
+    // If we're currently not using caches, make sure the engine's client doesn't have one.
+    OkHttpClient engineClient = client;
+    if (engineClient.getOkResponseCache() != null && !getUseCaches()) {
+      engineClient = client.clone().setOkResponseCache(null);
+    }
+
+    return new HttpEngine(engineClient, request, bufferRequestBody, connection, requestBody);
   }
 
   /**
@@ -311,18 +337,18 @@ private HttpEngine getResponse() throws IOException {
       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM
       // redirect should keep the same method, Chrome, Firefox and the
       // RI all issue GETs when following any redirect.
-      int responseCode = getResponseCode();
+      int responseCode = httpEngine.getResponse().code();
       if (responseCode == HTTP_MULT_CHOICE
           || responseCode == HTTP_MOVED_PERM
           || responseCode == HTTP_MOVED_TEMP
           || responseCode == HTTP_SEE_OTHER) {
         retryMethod = "GET";
+        requestHeaders.removeAll("Content-Length");
         requestBody = null;
       }
 
       if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {
-        throw new HttpRetryException("Cannot retry streamed HTTP body",
-            httpEngine.getResponseCode());
+        throw new HttpRetryException("Cannot retry streamed HTTP body", responseCode);
       }
 
       if (retry == Retry.DIFFERENT_CONNECTION) {
@@ -330,14 +356,8 @@ private HttpEngine getResponse() throws IOException {
       }
 
       httpEngine.release(false);
-
-      httpEngine = newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),
+      httpEngine = newHttpEngine(retryMethod, httpEngine.getConnection(),
           (RetryableOutputStream) requestBody);
-
-      if (requestBody == null) {
-        // Drop the Content-Length header when redirected from POST to GET.
-        httpEngine.getRequestHeaders().removeContentLength();
-      }
     }
   }
 
@@ -349,6 +369,7 @@ private HttpEngine getResponse() throws IOException {
   private boolean execute(boolean readResponse) throws IOException {
     try {
       httpEngine.sendRequest();
+      route = httpEngine.getRoute();
       if (readResponse) {
         httpEngine.readResponse();
       }
@@ -387,7 +408,7 @@ private boolean handleFailure(IOException e) throws IOException {
 
     httpEngine.release(true);
     RetryableOutputStream retryableOutputStream = (RetryableOutputStream) requestBody;
-    httpEngine = newHttpEngine(method, rawRequestHeaders, null, retryableOutputStream);
+    httpEngine = newHttpEngine(method, null, retryableOutputStream);
     httpEngine.routeSelector = routeSelector; // Keep the same routeSelector.
     return true;
   }
@@ -401,10 +422,6 @@ private boolean isRecoverable(IOException e) {
     return !sslFailure && !protocolFailure;
   }
 
-  public HttpEngine getHttpEngine() {
-    return httpEngine;
-  }
-
   enum Retry {
     NONE,
     SAME_CONNECTION,
@@ -413,7 +430,7 @@ public HttpEngine getHttpEngine() {
 
   /**
    * Returns the retry action to take for the current response headers. The
-   * headers, proxy and target URL or this connection may be adjusted to
+   * headers, proxy and target URL for this connection may be adjusted to
    * prepare for a follow up request.
    */
   private Retry processResponseHeaders() throws IOException {
@@ -428,10 +445,11 @@ private Retry processResponseHeaders() throws IOException {
         }
         // fall-through
       case HTTP_UNAUTHORIZED:
-        boolean credentialsFound = HttpAuthenticator.processAuthHeader(client.getAuthenticator(),
-            getResponseCode(), httpEngine.getResponseHeaders().getHeaders(), rawRequestHeaders,
-            selectedProxy, url);
-        return credentialsFound ? Retry.SAME_CONNECTION : Retry.NONE;
+        Request successorRequest = HttpAuthenticator.processAuthHeader(client.getAuthenticator(),
+            httpEngine.getResponse(), selectedProxy);
+        if (successorRequest == null) return Retry.NONE;
+        requestHeaders = successorRequest.getHeaders().newBuilder();
+        return Retry.SAME_CONNECTION;
 
       case HTTP_MULT_CHOICE:
       case HTTP_MOVED_PERM:
@@ -475,38 +493,30 @@ private Retry processResponseHeaders() throws IOException {
     }
   }
 
-  /** @see java.net.HttpURLConnection#setFixedLengthStreamingMode(int) */
-  @Override public final long getFixedContentLength() {
-    return fixedContentLength;
-  }
-
-  @Override public final int getChunkLength() {
-    return chunkLength;
-  }
-
+  /**
+   * Returns true if either:
+   * <ul>
+   *   <li>A specific proxy was explicitly configured for this connection.
+   *   <li>The response has already been retrieved, and a proxy was {@link
+   *       java.net.ProxySelector selected} in order to get it.
+   * </ul>
+   *
+   * <p><strong>Warning:</strong> This method may return false before attempting
+   * to connect and true afterwards.
+   */
   @Override public final boolean usingProxy() {
-    if (selectedProxy != null) {
-      return isValidNonDirectProxy(selectedProxy);
-    }
-
-    // This behavior is a bit odd (but is probably justified by the
-    // oddness of the APIs involved). Before a connection is established,
-    // this method will return true only if this connection was explicitly
-    // opened with a Proxy. We don't attempt to query the ProxySelector
-    // at all.
-    return isValidNonDirectProxy(client.getProxy());
-  }
-
-  private static boolean isValidNonDirectProxy(Proxy proxy) {
+    Proxy proxy = route != null
+        ? route.getProxy()
+        : client.getProxy();
     return proxy != null && proxy.type() != Proxy.Type.DIRECT;
   }
 
   @Override public String getResponseMessage() throws IOException {
-    return getResponse().getResponseHeaders().getHeaders().getResponseMessage();
+    return getResponse().getResponse().statusMessage();
   }
 
   @Override public final int getResponseCode() throws IOException {
-    return getResponse().getResponseCode();
+    return getResponse().getResponse().code();
   }
 
   @Override public final void setRequestProperty(String field, String newValue) {
@@ -529,7 +539,16 @@ private static boolean isValidNonDirectProxy(Proxy proxy) {
     if ("X-Android-Transports".equals(field)) {
       setTransports(newValue, false /* append */);
     } else {
-      rawRequestHeaders.set(field, newValue);
+      requestHeaders.set(field, newValue);
+    }
+  }
+
+  @Override public void setIfModifiedSince(long newValue) {
+    super.setIfModifiedSince(newValue);
+    if (ifModifiedSince != 0) {
+      requestHeaders.set("If-Modified-Since", HttpDate.format(new Date(ifModifiedSince)));
+    } else {
+      requestHeaders.removeAll("If-Modified-Since");
     }
   }
 
@@ -553,7 +572,7 @@ private static boolean isValidNonDirectProxy(Proxy proxy) {
     if ("X-Android-Transports".equals(field)) {
       setTransports(value, true /* append */);
     } else {
-      rawRequestHeaders.add(field, value);
+      requestHeaders.add(field, value);
     }
   }
 
@@ -584,8 +603,4 @@ public void setFixedLengthStreamingMode(long contentLength) {
     this.fixedContentLength = contentLength;
     super.fixedContentLength = (int) Math.min(contentLength, Integer.MAX_VALUE);
   }
-
-  @Override public final void setSelectedProxy(Proxy proxy) {
-    this.selectedProxy = proxy;
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsEngine.java
deleted file mode 100644
index 2bc1d68e42..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsEngine.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.TunnelRequest;
-import java.io.IOException;
-import java.net.CacheResponse;
-import java.net.SecureCacheResponse;
-import java.net.URL;
-import javax.net.ssl.SSLSocket;
-
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
-
-public final class HttpsEngine extends HttpEngine {
-  /**
-   * Stash of HttpsEngine.connection.socket to implement requests like {@code
-   * HttpsURLConnection#getCipherSuite} even after the connection has been
-   * recycled.
-   */
-  private SSLSocket sslSocket;
-
-  public HttpsEngine(OkHttpClient client, Policy policy, String method, RawHeaders requestHeaders,
-      Connection connection, RetryableOutputStream requestBody) throws IOException {
-    super(client, policy, method, requestHeaders, connection, requestBody);
-    this.sslSocket = connection != null ? (SSLSocket) connection.getSocket() : null;
-  }
-
-  @Override protected void connected(Connection connection) {
-    this.sslSocket = (SSLSocket) connection.getSocket();
-    super.connected(connection);
-  }
-
-  @Override protected boolean acceptCacheResponseType(CacheResponse cacheResponse) {
-    return cacheResponse instanceof SecureCacheResponse;
-  }
-
-  @Override protected boolean includeAuthorityInRequestLine() {
-    // Even if there is a proxy, it isn't involved. Always request just the path.
-    return false;
-  }
-
-  public SSLSocket getSslSocket() {
-    return sslSocket;
-  }
-
-  @Override protected TunnelRequest getTunnelConfig() {
-    String userAgent = requestHeaders.getUserAgent();
-    if (userAgent == null) {
-      userAgent = getDefaultUserAgent();
-    }
-
-    URL url = policy.getURL();
-    return new TunnelRequest(url.getHost(), getEffectivePort(url), userAgent,
-        requestHeaders.getProxyAuthorization());
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
index e8c656a2a3..a4fbeb558f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
@@ -16,13 +16,12 @@
  */
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Handshake;
 import com.squareup.okhttp.OkHttpClient;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.net.HttpURLConnection;
 import java.net.ProtocolException;
-import java.net.SecureCacheResponse;
 import java.net.URL;
 import java.security.Permission;
 import java.security.Principal;
@@ -32,92 +31,52 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 
 public final class HttpsURLConnectionImpl extends HttpsURLConnection {
 
-  /** HttpUrlConnectionDelegate allows reuse of HttpURLConnectionImpl. */
-  private final HttpUrlConnectionDelegate delegate;
+  /** Reuse HttpURLConnectionImpl. */
+  private final HttpURLConnectionImpl delegate;
 
   public HttpsURLConnectionImpl(URL url, OkHttpClient client) {
     super(url);
-    delegate = new HttpUrlConnectionDelegate(url, client);
+    delegate = new HttpURLConnectionImpl(url, client);
   }
 
   @Override public String getCipherSuite() {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      return cacheResponse.getCipherSuite();
-    }
-    SSLSocket sslSocket = getSslSocket();
-    if (sslSocket != null) {
-      return sslSocket.getSession().getCipherSuite();
-    }
-    return null;
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.cipherSuite() : null;
   }
 
   @Override public Certificate[] getLocalCertificates() {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      List<Certificate> result = cacheResponse.getLocalCertificateChain();
-      return result != null ? result.toArray(new Certificate[result.size()]) : null;
-    }
-    SSLSocket sslSocket = getSslSocket();
-    if (sslSocket != null) {
-      return sslSocket.getSession().getLocalCertificates();
-    }
-    return null;
+    Handshake handshake = handshake();
+    if (handshake == null) return null;
+    List<Certificate> result = handshake.localCertificates();
+    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
   }
 
   @Override public Certificate[] getServerCertificates() throws SSLPeerUnverifiedException {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      List<Certificate> result = cacheResponse.getServerCertificateChain();
-      return result != null ? result.toArray(new Certificate[result.size()]) : null;
-    }
-    SSLSocket sslSocket = getSslSocket();
-    if (sslSocket != null) {
-      return sslSocket.getSession().getPeerCertificates();
-    }
-    return null;
+    Handshake handshake = handshake();
+    if (handshake == null) return null;
+    List<Certificate> result = handshake.peerCertificates();
+    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
   }
 
   @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      return cacheResponse.getPeerPrincipal();
-    }
-    SSLSocket sslSocket = getSslSocket();
-    if (sslSocket != null) {
-      return sslSocket.getSession().getPeerPrincipal();
-    }
-    return null;
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.peerPrincipal() : null;
   }
 
   @Override public Principal getLocalPrincipal() {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      return cacheResponse.getLocalPrincipal();
-    }
-    SSLSocket sslSocket = getSslSocket();
-    if (sslSocket != null) {
-      return sslSocket.getSession().getLocalPrincipal();
-    }
-    return null;
-  }
-
-  public HttpEngine getHttpEngine() {
-    return delegate.getHttpEngine();
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.localPrincipal() : null;
   }
 
-  private SSLSocket getSslSocket() {
-    if (delegate.httpEngine == null || !delegate.httpEngine.connected) {
+  private Handshake handshake() {
+    if (delegate.httpEngine == null) {
       throw new IllegalStateException("Connection has not yet been established");
     }
-    return delegate.httpEngine instanceof HttpsEngine
-        ? ((HttpsEngine) delegate.httpEngine).getSslSocket()
-        : null; // Not HTTPS! Probably an https:// to http:// redirect.
+    return delegate.httpEngine.getResponse().handshake();
   }
 
   @Override public void disconnect() {
@@ -342,19 +301,15 @@ private SSLSocket getSslSocket() {
     return delegate.client.getSslSocketFactory();
   }
 
-  private final class HttpUrlConnectionDelegate extends HttpURLConnectionImpl {
-    private HttpUrlConnectionDelegate(URL url, OkHttpClient client) {
-      super(url, client);
-    }
+  @Override public void setFixedLengthStreamingMode(long contentLength) {
+    delegate.setFixedLengthStreamingMode(contentLength);
+  }
 
-    @Override public HttpURLConnection getHttpConnectionToCache() {
-      return HttpsURLConnectionImpl.this;
-    }
+  @Override public long getContentLengthLong() {
+    return delegate.getContentLengthLong();
+  }
 
-    public SecureCacheResponse getSecureCacheResponse() {
-      return httpEngine instanceof HttpsEngine
-          ? (SecureCacheResponse) httpEngine.getCacheResponse()
-          : null;
-    }
+  @Override public long getHeaderFieldLong(String field, long defaultValue) {
+    return delegate.getHeaderFieldLong(field, defaultValue);
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkResponseCacheAdapter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkResponseCacheAdapter.java
deleted file mode 100644
index 5335c2bce8..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkResponseCacheAdapter.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.OkResponseCache;
-import com.squareup.okhttp.ResponseSource;
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-
-public final class OkResponseCacheAdapter implements OkResponseCache {
-  private final ResponseCache responseCache;
-  public OkResponseCacheAdapter(ResponseCache responseCache) {
-    this.responseCache = responseCache;
-  }
-
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) throws IOException {
-    return responseCache.get(uri, requestMethod, requestHeaders);
-  }
-
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    return responseCache.put(uri, urlConnection);
-  }
-
-  @Override public void maybeRemove(String requestMethod, URI uri) throws IOException {
-  }
-
-  @Override public void update(CacheResponse conditionalCacheHit, HttpURLConnection connection)
-      throws IOException {
-  }
-
-  @Override public void trackConditionalCacheHit() {
-  }
-
-  @Override public void trackResponse(ResponseSource source) {
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Policy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Policy.java
deleted file mode 100644
index 0a29d4b1ab..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Policy.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import java.net.HttpURLConnection;
-import java.net.Proxy;
-import java.net.URL;
-
-public interface Policy {
-  /** Returns true if HTTP response caches should be used. */
-  boolean getUseCaches();
-
-  /** Returns the HttpURLConnection instance to store in the cache. */
-  HttpURLConnection getHttpConnectionToCache();
-
-  /** Returns the current destination URL, possibly a redirect. */
-  URL getURL();
-
-  /** Returns the If-Modified-Since timestamp, or 0 if none is set. */
-  long getIfModifiedSince();
-
-  /** Returns true if a non-direct proxy is specified. */
-  boolean usingProxy();
-
-  /** @see java.net.HttpURLConnection#setChunkedStreamingMode(int) */
-  int getChunkLength();
-
-  /** @see java.net.HttpURLConnection#setFixedLengthStreamingMode(int) */
-  long getFixedContentLength();
-
-  /**
-   * Sets the current proxy that this connection is using.
-   * @see java.net.HttpURLConnection#usingProxy
-   */
-  void setSelectedProxy(Proxy proxy);
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RawHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RawHeaders.java
deleted file mode 100644
index 8b45320704..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RawHeaders.java
+++ /dev/null
@@ -1,447 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
-import java.net.ProtocolException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.TreeMap;
-import java.util.TreeSet;
-
-/**
- * The HTTP status and unparsed header fields of a single HTTP message. Values
- * are represented as uninterpreted strings; use {@link RequestHeaders} and
- * {@link ResponseHeaders} for interpreted headers. This class maintains the
- * order of the header fields within the HTTP message.
- *
- * <p>This class tracks fields line-by-line. A field with multiple comma-
- * separated values on the same line will be treated as a field with a single
- * value by this class. It is the caller's responsibility to detect and split
- * on commas if their field permits multiple values. This simplifies use of
- * single-valued fields whose values routinely contain commas, such as cookies
- * or dates.
- *
- * <p>This class trims whitespace from values. It never returns values with
- * leading or trailing whitespace.
- */
-public final class RawHeaders {
-  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
-    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
-    @Override public int compare(String a, String b) {
-      if (a == b) {
-        return 0;
-      } else if (a == null) {
-        return -1;
-      } else if (b == null) {
-        return 1;
-      } else {
-        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
-      }
-    }
-  };
-
-  private final List<String> namesAndValues = new ArrayList<String>(20);
-  private String requestLine;
-  private String statusLine;
-  private int httpMinorVersion = 1;
-  private int responseCode = -1;
-  private String responseMessage;
-
-  public RawHeaders() {
-  }
-
-  public RawHeaders(RawHeaders copyFrom) {
-    namesAndValues.addAll(copyFrom.namesAndValues);
-    requestLine = copyFrom.requestLine;
-    statusLine = copyFrom.statusLine;
-    httpMinorVersion = copyFrom.httpMinorVersion;
-    responseCode = copyFrom.responseCode;
-    responseMessage = copyFrom.responseMessage;
-  }
-
-  /** Sets the request line (like "GET / HTTP/1.1"). */
-  public void setRequestLine(String requestLine) {
-    requestLine = requestLine.trim();
-    this.requestLine = requestLine;
-  }
-
-  /** Sets the response status line (like "HTTP/1.0 200 OK"). */
-  public void setStatusLine(String statusLine) throws IOException {
-    // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
-    // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
-    if (this.responseMessage != null) {
-      throw new IllegalStateException("statusLine is already set");
-    }
-    // We allow empty message without leading white space since some servers
-    // do not send the white space when the message is empty.
-    boolean hasMessage = statusLine.length() > 13;
-    if (!statusLine.startsWith("HTTP/1.")
-        || statusLine.length() < 12
-        || statusLine.charAt(8) != ' '
-        || (hasMessage && statusLine.charAt(12) != ' ')) {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
-    int httpMinorVersion = statusLine.charAt(7) - '0';
-    if (httpMinorVersion < 0 || httpMinorVersion > 9) {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
-    int responseCode;
-    try {
-      responseCode = Integer.parseInt(statusLine.substring(9, 12));
-    } catch (NumberFormatException e) {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
-    this.responseMessage = hasMessage ? statusLine.substring(13) : "";
-    this.responseCode = responseCode;
-    this.statusLine = statusLine;
-    this.httpMinorVersion = httpMinorVersion;
-  }
-
-  /**
-   * @param method like "GET", "POST", "HEAD", etc.
-   * @param path like "/foo/bar.html"
-   * @param version like "HTTP/1.1"
-   * @param host like "www.android.com:1234"
-   * @param scheme like "https"
-   */
-  public void addSpdyRequestHeaders(String method, String path, String version, String host,
-      String scheme) {
-    // TODO: populate the statusLine for the client's benefit?
-    add(":method", method);
-    add(":scheme", scheme);
-    add(":path", path);
-    add(":version", version);
-    add(":host", host);
-  }
-
-  public String getStatusLine() {
-    return statusLine;
-  }
-
-  /**
-   * Returns the status line's HTTP minor version. This returns 0 for HTTP/1.0
-   * and 1 for HTTP/1.1. This returns 1 if the HTTP version is unknown.
-   */
-  public int getHttpMinorVersion() {
-    return httpMinorVersion != -1 ? httpMinorVersion : 1;
-  }
-
-  /** Returns the HTTP status code or -1 if it is unknown. */
-  public int getResponseCode() {
-    return responseCode;
-  }
-
-  /** Returns the HTTP status message or null if it is unknown. */
-  public String getResponseMessage() {
-    return responseMessage;
-  }
-
-  /**
-   * Add an HTTP header line containing a field name, a literal colon, and a
-   * value. This works around empty header names and header names that start
-   * with a colon (created by old broken SPDY versions of the response cache).
-   */
-  public void addLine(String line) {
-    int index = line.indexOf(":", 1);
-    if (index != -1) {
-      addLenient(line.substring(0, index), line.substring(index + 1));
-    } else if (line.startsWith(":")) {
-      addLenient("", line.substring(1)); // Empty header name.
-    } else {
-      addLenient("", line); // No header name.
-    }
-  }
-
-  /** Add a field with the specified value. */
-  public void add(String fieldName, String value) {
-    if (fieldName == null) throw new IllegalArgumentException("fieldname == null");
-    if (value == null) throw new IllegalArgumentException("value == null");
-    if (fieldName.length() == 0 || fieldName.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-      throw new IllegalArgumentException("Unexpected header: " + fieldName + ": " + value);
-    }
-    addLenient(fieldName, value);
-  }
-
-  /**
-   * Add a field with the specified value without any validation. Only
-   * appropriate for headers from the remote peer.
-   */
-  private void addLenient(String fieldName, String value) {
-    namesAndValues.add(fieldName);
-    namesAndValues.add(value.trim());
-  }
-
-  public void removeAll(String fieldName) {
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
-        namesAndValues.remove(i); // field name
-        namesAndValues.remove(i); // value
-      }
-    }
-  }
-
-  public void addAll(String fieldName, List<String> headerFields) {
-    for (String value : headerFields) {
-      add(fieldName, value);
-    }
-  }
-
-  /**
-   * Set a field with the specified value. If the field is not found, it is
-   * added. If the field is found, the existing values are replaced.
-   */
-  public void set(String fieldName, String value) {
-    removeAll(fieldName);
-    add(fieldName, value);
-  }
-
-  /** Returns the number of field values. */
-  public int length() {
-    return namesAndValues.size() / 2;
-  }
-
-  /** Returns the field at {@code position} or null if that is out of range. */
-  public String getFieldName(int index) {
-    int fieldNameIndex = index * 2;
-    if (fieldNameIndex < 0 || fieldNameIndex >= namesAndValues.size()) {
-      return null;
-    }
-    return namesAndValues.get(fieldNameIndex);
-  }
-
-  /** Returns an immutable case-insensitive set of header names. */
-  public Set<String> names() {
-    TreeSet<String> result = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
-    for (int i = 0; i < length(); i++) {
-      result.add(getFieldName(i));
-    }
-    return Collections.unmodifiableSet(result);
-  }
-
-  /** Returns the value at {@code index} or null if that is out of range. */
-  public String getValue(int index) {
-    int valueIndex = index * 2 + 1;
-    if (valueIndex < 0 || valueIndex >= namesAndValues.size()) {
-      return null;
-    }
-    return namesAndValues.get(valueIndex);
-  }
-
-  /** Returns the last value corresponding to the specified field, or null. */
-  public String get(String fieldName) {
-    for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
-      if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
-        return namesAndValues.get(i + 1);
-      }
-    }
-    return null;
-  }
-
-  /** Returns an immutable list of the header values for {@code name}. */
-  public List<String> values(String name) {
-    List<String> result = null;
-    for (int i = 0; i < length(); i++) {
-      if (name.equalsIgnoreCase(getFieldName(i))) {
-        if (result == null) result = new ArrayList<String>(2);
-        result.add(getValue(i));
-      }
-    }
-    return result != null
-        ? Collections.unmodifiableList(result)
-        : Collections.<String>emptyList();
-  }
-
-  /** @param fieldNames a case-insensitive set of HTTP header field names. */
-  public RawHeaders getAll(Set<String> fieldNames) {
-    RawHeaders result = new RawHeaders();
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      String fieldName = namesAndValues.get(i);
-      if (fieldNames.contains(fieldName)) {
-        result.add(fieldName, namesAndValues.get(i + 1));
-      }
-    }
-    return result;
-  }
-
-  /** Returns bytes of a request header for sending on an HTTP transport. */
-  public byte[] toBytes() throws UnsupportedEncodingException {
-    StringBuilder result = new StringBuilder(256);
-    result.append(requestLine).append("\r\n");
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      result.append(namesAndValues.get(i))
-          .append(": ")
-          .append(namesAndValues.get(i + 1))
-          .append("\r\n");
-    }
-    result.append("\r\n");
-    return result.toString().getBytes("ISO-8859-1");
-  }
-
-  /** Parses bytes of a response header from an HTTP transport. */
-  public static RawHeaders fromBytes(InputStream in) throws IOException {
-    RawHeaders headers;
-    do {
-      headers = new RawHeaders();
-      headers.setStatusLine(Util.readAsciiLine(in));
-      readHeaders(in, headers);
-    } while (headers.getResponseCode() == HttpEngine.HTTP_CONTINUE);
-    return headers;
-  }
-
-  /** Reads headers or trailers into {@code out}. */
-  public static void readHeaders(InputStream in, RawHeaders out) throws IOException {
-    // parse the result headers until the first blank line
-    String line;
-    while ((line = Util.readAsciiLine(in)).length() != 0) {
-      out.addLine(line);
-    }
-  }
-
-  /**
-   * Returns an immutable map containing each field to its list of values. The
-   * status line is mapped to null.
-   */
-  public Map<String, List<String>> toMultimap(boolean response) {
-    Map<String, List<String>> result = new TreeMap<String, List<String>>(FIELD_NAME_COMPARATOR);
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      String fieldName = namesAndValues.get(i);
-      String value = namesAndValues.get(i + 1);
-
-      List<String> allValues = new ArrayList<String>();
-      List<String> otherValues = result.get(fieldName);
-      if (otherValues != null) {
-        allValues.addAll(otherValues);
-      }
-      allValues.add(value);
-      result.put(fieldName, Collections.unmodifiableList(allValues));
-    }
-    if (response && statusLine != null) {
-      result.put(null, Collections.unmodifiableList(Collections.singletonList(statusLine)));
-    } else if (requestLine != null) {
-      result.put(null, Collections.unmodifiableList(Collections.singletonList(requestLine)));
-    }
-    return Collections.unmodifiableMap(result);
-  }
-
-  /**
-   * Creates a new instance from the given map of fields to values. If
-   * present, the null field's last element will be used to set the status
-   * line.
-   */
-  public static RawHeaders fromMultimap(Map<String, List<String>> map, boolean response)
-      throws IOException {
-    if (!response) throw new UnsupportedOperationException();
-    RawHeaders result = new RawHeaders();
-    for (Entry<String, List<String>> entry : map.entrySet()) {
-      String fieldName = entry.getKey();
-      List<String> values = entry.getValue();
-      if (fieldName != null) {
-        for (String value : values) {
-          result.addLenient(fieldName, value);
-        }
-      } else if (!values.isEmpty()) {
-        result.setStatusLine(values.get(values.size() - 1));
-      }
-    }
-    return result;
-  }
-
-  /**
-   * Returns a list of alternating names and values. Names are all lower case.
-   * No names are repeated. If any name has multiple values, they are
-   * concatenated using "\0" as a delimiter.
-   */
-  public List<String> toNameValueBlock() {
-    Set<String> names = new HashSet<String>();
-    List<String> result = new ArrayList<String>();
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      String name = namesAndValues.get(i).toLowerCase(Locale.US);
-      String value = namesAndValues.get(i + 1);
-
-      // Drop headers that are forbidden when layering HTTP over SPDY.
-      if (name.equals("connection")
-          || name.equals("host")
-          || name.equals("keep-alive")
-          || name.equals("proxy-connection")
-          || name.equals("transfer-encoding")) {
-        continue;
-      }
-
-      // If we haven't seen this name before, add the pair to the end of the list...
-      if (names.add(name)) {
-        result.add(name);
-        result.add(value);
-        continue;
-      }
-
-      // ...otherwise concatenate the existing values and this value.
-      for (int j = 0; j < result.size(); j += 2) {
-        if (name.equals(result.get(j))) {
-          result.set(j + 1, result.get(j + 1) + "\0" + value);
-          break;
-        }
-      }
-    }
-    return result;
-  }
-
-  /** Returns headers for a name value block containing a SPDY response. */
-  public static RawHeaders fromNameValueBlock(List<String> nameValueBlock) throws IOException {
-    if (nameValueBlock.size() % 2 != 0) {
-      throw new IllegalArgumentException("Unexpected name value block: " + nameValueBlock);
-    }
-    String status = null;
-    String version = null;
-    RawHeaders result = new RawHeaders();
-    for (int i = 0; i < nameValueBlock.size(); i += 2) {
-      String name = nameValueBlock.get(i);
-      String values = nameValueBlock.get(i + 1);
-      for (int start = 0; start < values.length(); ) {
-        int end = values.indexOf('\0', start);
-        if (end == -1) {
-          end = values.length();
-        }
-        String value = values.substring(start, end);
-        if (":status".equals(name)) {
-          status = value;
-        } else if (":version".equals(name)) {
-          version = value;
-        } else {
-          result.namesAndValues.add(name);
-          result.namesAndValues.add(value);
-        }
-        start = end + 1;
-      }
-    }
-    if (status == null) throw new ProtocolException("Expected ':status' header not present");
-    if (version == null) throw new ProtocolException("Expected ':version' header not present");
-    result.setStatusLine(version + " " + status);
-    return result;
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestHeaders.java
deleted file mode 100644
index 71c3cd0f21..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestHeaders.java
+++ /dev/null
@@ -1,317 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import java.net.URI;
-import java.util.Date;
-import java.util.List;
-import java.util.Map;
-
-/** Parsed HTTP request headers. */
-public final class RequestHeaders {
-  private final URI uri;
-  private final RawHeaders headers;
-
-  /** Don't use a cache to satisfy this request. */
-  private boolean noCache;
-  private int maxAgeSeconds = -1;
-  private int maxStaleSeconds = -1;
-  private int minFreshSeconds = -1;
-
-  /**
-   * This field's name "only-if-cached" is misleading. It actually means "do
-   * not use the network". It is set by a client who only wants to make a
-   * request if it can be fully satisfied by the cache. Cached responses that
-   * would require validation (ie. conditional gets) are not permitted if this
-   * header is set.
-   */
-  private boolean onlyIfCached;
-
-  /**
-   * True if the request contains an authorization field. Although this isn't
-   * necessarily a shared cache, it follows the spec's strict requirements for
-   * shared caches.
-   */
-  private boolean hasAuthorization;
-
-  private long contentLength = -1;
-  private String transferEncoding;
-  private String userAgent;
-  private String host;
-  private String connection;
-  private String acceptEncoding;
-  private String contentType;
-  private String ifModifiedSince;
-  private String ifNoneMatch;
-  private String proxyAuthorization;
-
-  public RequestHeaders(URI uri, RawHeaders headers) {
-    this.uri = uri;
-    this.headers = headers;
-
-    HeaderParser.CacheControlHandler handler = new HeaderParser.CacheControlHandler() {
-      @Override public void handle(String directive, String parameter) {
-        if ("no-cache".equalsIgnoreCase(directive)) {
-          noCache = true;
-        } else if ("max-age".equalsIgnoreCase(directive)) {
-          maxAgeSeconds = HeaderParser.parseSeconds(parameter);
-        } else if ("max-stale".equalsIgnoreCase(directive)) {
-          maxStaleSeconds = HeaderParser.parseSeconds(parameter);
-        } else if ("min-fresh".equalsIgnoreCase(directive)) {
-          minFreshSeconds = HeaderParser.parseSeconds(parameter);
-        } else if ("only-if-cached".equalsIgnoreCase(directive)) {
-          onlyIfCached = true;
-        }
-      }
-    };
-
-    for (int i = 0; i < headers.length(); i++) {
-      String fieldName = headers.getFieldName(i);
-      String value = headers.getValue(i);
-      if ("Cache-Control".equalsIgnoreCase(fieldName)) {
-        HeaderParser.parseCacheControl(value, handler);
-      } else if ("Pragma".equalsIgnoreCase(fieldName)) {
-        if ("no-cache".equalsIgnoreCase(value)) {
-          noCache = true;
-        }
-      } else if ("If-None-Match".equalsIgnoreCase(fieldName)) {
-        ifNoneMatch = value;
-      } else if ("If-Modified-Since".equalsIgnoreCase(fieldName)) {
-        ifModifiedSince = value;
-      } else if ("Authorization".equalsIgnoreCase(fieldName)) {
-        hasAuthorization = true;
-      } else if ("Content-Length".equalsIgnoreCase(fieldName)) {
-        try {
-          contentLength = Integer.parseInt(value);
-        } catch (NumberFormatException ignored) {
-        }
-      } else if ("Transfer-Encoding".equalsIgnoreCase(fieldName)) {
-        transferEncoding = value;
-      } else if ("User-Agent".equalsIgnoreCase(fieldName)) {
-        userAgent = value;
-      } else if ("Host".equalsIgnoreCase(fieldName)) {
-        host = value;
-      } else if ("Connection".equalsIgnoreCase(fieldName)) {
-        connection = value;
-      } else if ("Accept-Encoding".equalsIgnoreCase(fieldName)) {
-        acceptEncoding = value;
-      } else if ("Content-Type".equalsIgnoreCase(fieldName)) {
-        contentType = value;
-      } else if ("Proxy-Authorization".equalsIgnoreCase(fieldName)) {
-        proxyAuthorization = value;
-      }
-    }
-  }
-
-  public boolean isChunked() {
-    return "chunked".equalsIgnoreCase(transferEncoding);
-  }
-
-  public boolean hasConnectionClose() {
-    return "close".equalsIgnoreCase(connection);
-  }
-
-  public URI getUri() {
-    return uri;
-  }
-
-  public RawHeaders getHeaders() {
-    return headers;
-  }
-
-  public boolean isNoCache() {
-    return noCache;
-  }
-
-  public int getMaxAgeSeconds() {
-    return maxAgeSeconds;
-  }
-
-  public int getMaxStaleSeconds() {
-    return maxStaleSeconds;
-  }
-
-  public int getMinFreshSeconds() {
-    return minFreshSeconds;
-  }
-
-  public boolean isOnlyIfCached() {
-    return onlyIfCached;
-  }
-
-  public boolean hasAuthorization() {
-    return hasAuthorization;
-  }
-
-  public long getContentLength() {
-    return contentLength;
-  }
-
-  public String getTransferEncoding() {
-    return transferEncoding;
-  }
-
-  public String getUserAgent() {
-    return userAgent;
-  }
-
-  public String getHost() {
-    return host;
-  }
-
-  public String getConnection() {
-    return connection;
-  }
-
-  public String getAcceptEncoding() {
-    return acceptEncoding;
-  }
-
-  public String getContentType() {
-    return contentType;
-  }
-
-  public String getIfModifiedSince() {
-    return ifModifiedSince;
-  }
-
-  public String getIfNoneMatch() {
-    return ifNoneMatch;
-  }
-
-  public String getProxyAuthorization() {
-    return proxyAuthorization;
-  }
-
-  public void setChunked() {
-    if (this.transferEncoding != null) {
-      headers.removeAll("Transfer-Encoding");
-    }
-    headers.add("Transfer-Encoding", "chunked");
-    this.transferEncoding = "chunked";
-  }
-
-  public void setContentLength(long contentLength) {
-    if (this.contentLength != -1) {
-      headers.removeAll("Content-Length");
-    }
-    headers.add("Content-Length", Long.toString(contentLength));
-    this.contentLength = contentLength;
-  }
-
-  /**
-   * Remove the Content-Length headers. Call this when dropping the body on a
-   * request or response, such as when a redirect changes the method from POST
-   * to GET.
-   */
-  public void removeContentLength() {
-    if (contentLength != -1) {
-      headers.removeAll("Content-Length");
-      contentLength = -1;
-    }
-  }
-
-  public void setUserAgent(String userAgent) {
-    if (this.userAgent != null) {
-      headers.removeAll("User-Agent");
-    }
-    headers.add("User-Agent", userAgent);
-    this.userAgent = userAgent;
-  }
-
-  public void setHost(String host) {
-    if (this.host != null) {
-      headers.removeAll("Host");
-    }
-    headers.add("Host", host);
-    this.host = host;
-  }
-
-  public void setConnection(String connection) {
-    if (this.connection != null) {
-      headers.removeAll("Connection");
-    }
-    headers.add("Connection", connection);
-    this.connection = connection;
-  }
-
-  public void setAcceptEncoding(String acceptEncoding) {
-    if (this.acceptEncoding != null) {
-      headers.removeAll("Accept-Encoding");
-    }
-    headers.add("Accept-Encoding", acceptEncoding);
-    this.acceptEncoding = acceptEncoding;
-  }
-
-  public void setContentType(String contentType) {
-    if (this.contentType != null) {
-      headers.removeAll("Content-Type");
-    }
-    headers.add("Content-Type", contentType);
-    this.contentType = contentType;
-  }
-
-  public void setIfModifiedSince(Date date) {
-    if (ifModifiedSince != null) {
-      headers.removeAll("If-Modified-Since");
-    }
-    String formattedDate = HttpDate.format(date);
-    headers.add("If-Modified-Since", formattedDate);
-    ifModifiedSince = formattedDate;
-  }
-
-  public void setIfNoneMatch(String ifNoneMatch) {
-    if (this.ifNoneMatch != null) {
-      headers.removeAll("If-None-Match");
-    }
-    headers.add("If-None-Match", ifNoneMatch);
-    this.ifNoneMatch = ifNoneMatch;
-  }
-
-  /**
-   * Returns true if the request contains conditions that save the server from
-   * sending a response that the client has locally. When the caller adds
-   * conditions, this cache won't participate in the request.
-   */
-  public boolean hasConditions() {
-    return ifModifiedSince != null || ifNoneMatch != null;
-  }
-
-  public void addCookies(Map<String, List<String>> allCookieHeaders) {
-    for (Map.Entry<String, List<String>> entry : allCookieHeaders.entrySet()) {
-      String key = entry.getKey();
-      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
-          && !entry.getValue().isEmpty()) {
-        headers.add(key, buildCookieHeader(entry.getValue()));
-      }
-    }
-  }
-
-  /**
-   * Send all cookies in one big header, as recommended by
-   * <a href="http://tools.ietf.org/html/rfc6265#section-4.2.1">RFC 6265</a>.
-   */
-  private String buildCookieHeader(List<String> cookies) {
-    if (cookies.size() == 1) return cookies.get(0);
-    StringBuilder sb = new StringBuilder();
-    for (int i = 0; i < cookies.size(); i++) {
-      if (i > 0) sb.append("; ");
-      sb.append(cookies.get(i));
-    }
-    return sb.toString();
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
new file mode 100644
index 0000000000..c918df3c22
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
@@ -0,0 +1,55 @@
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Request;
+import java.net.Proxy;
+import java.net.URL;
+
+public final class RequestLine {
+  private RequestLine() {
+  }
+
+  /**
+   * Returns the request status line, like "GET / HTTP/1.1". This is exposed
+   * to the application by {@link HttpURLConnectionImpl#getHeaderFields}, so
+   * it needs to be set even if the transport is SPDY.
+   */
+  static String get(Request request, Proxy.Type proxyType, int httpMinorVersion) {
+    StringBuilder result = new StringBuilder();
+    result.append(request.method());
+    result.append(" ");
+
+    if (includeAuthorityInRequestLine(request, proxyType)) {
+      result.append(request.url());
+    } else {
+      result.append(requestPath(request.url()));
+    }
+
+    result.append(" ");
+    result.append(version(httpMinorVersion));
+    return result.toString();
+  }
+
+  /**
+   * Returns true if the request line should contain the full URL with host
+   * and port (like "GET http://android.com/foo HTTP/1.1") or only the path
+   * (like "GET /foo HTTP/1.1").
+   */
+  private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type proxyType) {
+    return !request.isHttps() && proxyType == Proxy.Type.HTTP;
+  }
+
+  /**
+   * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty,
+   * even if the request URL is. Includes the query component if it exists.
+   */
+  public static String requestPath(URL url) {
+    String pathAndQuery = url.getFile();
+    if (pathAndQuery == null) return "/";
+    if (!pathAndQuery.startsWith("/")) return "/" + pathAndQuery;
+    return pathAndQuery;
+  }
+
+  public static String version(int httpMinorVersion) {
+    return httpMinorVersion == 1 ? "HTTP/1.1" : "HTTP/1.0";
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseHeaders.java
deleted file mode 100644
index 461de8efb9..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseHeaders.java
+++ /dev/null
@@ -1,505 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.ResponseSource;
-import com.squareup.okhttp.internal.Platform;
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URI;
-import java.util.Collections;
-import java.util.Date;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeSet;
-import java.util.concurrent.TimeUnit;
-
-import static com.squareup.okhttp.internal.Util.equal;
-
-/** Parsed HTTP response headers. */
-public final class ResponseHeaders {
-
-  /** HTTP header name for the local time when the request was sent. */
-  private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
-
-  /** HTTP header name for the local time when the response was received. */
-  private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
-
-  /** HTTP synthetic header with the response source. */
-  static final String RESPONSE_SOURCE = Platform.get().getPrefix() + "-Response-Source";
-
-  /** HTTP synthetic header with the selected transport (spdy/3, http/1.1, etc). */
-  static final String SELECTED_TRANSPORT = Platform.get().getPrefix() + "-Selected-Transport";
-
-  private final URI uri;
-  private final RawHeaders headers;
-
-  /** The server's time when this response was served, if known. */
-  private Date servedDate;
-
-  /** The last modified date of the response, if known. */
-  private Date lastModified;
-
-  /**
-   * The expiration date of the response, if known. If both this field and the
-   * max age are set, the max age is preferred.
-   */
-  private Date expires;
-
-  /**
-   * Extension header set by HttpURLConnectionImpl specifying the timestamp
-   * when the HTTP request was first initiated.
-   */
-  private long sentRequestMillis;
-
-  /**
-   * Extension header set by HttpURLConnectionImpl specifying the timestamp
-   * when the HTTP response was first received.
-   */
-  private long receivedResponseMillis;
-
-  /**
-   * In the response, this field's name "no-cache" is misleading. It doesn't
-   * prevent us from caching the response; it only means we have to validate
-   * the response with the origin server before returning it. We can do this
-   * with a conditional get.
-   */
-  private boolean noCache;
-
-  /** If true, this response should not be cached. */
-  private boolean noStore;
-
-  /**
-   * The duration past the response's served date that it can be served
-   * without validation.
-   */
-  private int maxAgeSeconds = -1;
-
-  /**
-   * The "s-maxage" directive is the max age for shared caches. Not to be
-   * confused with "max-age" for non-shared caches, As in Firefox and Chrome,
-   * this directive is not honored by this cache.
-   */
-  private int sMaxAgeSeconds = -1;
-
-  /**
-   * This request header field's name "only-if-cached" is misleading. It
-   * actually means "do not use the network". It is set by a client who only
-   * wants to make a request if it can be fully satisfied by the cache.
-   * Cached responses that would require validation (ie. conditional gets) are
-   * not permitted if this header is set.
-   */
-  private boolean isPublic;
-  private boolean mustRevalidate;
-  private String etag;
-  private int ageSeconds = -1;
-
-  /** Case-insensitive set of field names. */
-  private Set<String> varyFields = Collections.emptySet();
-
-  private String contentEncoding;
-  private String transferEncoding;
-  private int contentLength = -1;
-  private String connection;
-
-  public ResponseHeaders(URI uri, RawHeaders headers) {
-    this.uri = uri;
-    this.headers = headers;
-
-    HeaderParser.CacheControlHandler handler = new HeaderParser.CacheControlHandler() {
-      @Override public void handle(String directive, String parameter) {
-        if ("no-cache".equalsIgnoreCase(directive)) {
-          noCache = true;
-        } else if ("no-store".equalsIgnoreCase(directive)) {
-          noStore = true;
-        } else if ("max-age".equalsIgnoreCase(directive)) {
-          maxAgeSeconds = HeaderParser.parseSeconds(parameter);
-        } else if ("s-maxage".equalsIgnoreCase(directive)) {
-          sMaxAgeSeconds = HeaderParser.parseSeconds(parameter);
-        } else if ("public".equalsIgnoreCase(directive)) {
-          isPublic = true;
-        } else if ("must-revalidate".equalsIgnoreCase(directive)) {
-          mustRevalidate = true;
-        }
-      }
-    };
-
-    for (int i = 0; i < headers.length(); i++) {
-      String fieldName = headers.getFieldName(i);
-      String value = headers.getValue(i);
-      if ("Cache-Control".equalsIgnoreCase(fieldName)) {
-        HeaderParser.parseCacheControl(value, handler);
-      } else if ("Date".equalsIgnoreCase(fieldName)) {
-        servedDate = HttpDate.parse(value);
-      } else if ("Expires".equalsIgnoreCase(fieldName)) {
-        expires = HttpDate.parse(value);
-      } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
-        lastModified = HttpDate.parse(value);
-      } else if ("ETag".equalsIgnoreCase(fieldName)) {
-        etag = value;
-      } else if ("Pragma".equalsIgnoreCase(fieldName)) {
-        if ("no-cache".equalsIgnoreCase(value)) {
-          noCache = true;
-        }
-      } else if ("Age".equalsIgnoreCase(fieldName)) {
-        ageSeconds = HeaderParser.parseSeconds(value);
-      } else if ("Vary".equalsIgnoreCase(fieldName)) {
-        // Replace the immutable empty set with something we can mutate.
-        if (varyFields.isEmpty()) {
-          varyFields = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
-        }
-        for (String varyField : value.split(",")) {
-          varyFields.add(varyField.trim());
-        }
-      } else if ("Content-Encoding".equalsIgnoreCase(fieldName)) {
-        contentEncoding = value;
-      } else if ("Transfer-Encoding".equalsIgnoreCase(fieldName)) {
-        transferEncoding = value;
-      } else if ("Content-Length".equalsIgnoreCase(fieldName)) {
-        try {
-          contentLength = Integer.parseInt(value);
-        } catch (NumberFormatException ignored) {
-        }
-      } else if ("Connection".equalsIgnoreCase(fieldName)) {
-        connection = value;
-      } else if (SENT_MILLIS.equalsIgnoreCase(fieldName)) {
-        sentRequestMillis = Long.parseLong(value);
-      } else if (RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
-        receivedResponseMillis = Long.parseLong(value);
-      }
-    }
-  }
-
-  public boolean isContentEncodingGzip() {
-    return "gzip".equalsIgnoreCase(contentEncoding);
-  }
-
-  public void stripContentEncoding() {
-    contentEncoding = null;
-    headers.removeAll("Content-Encoding");
-  }
-
-  public void stripContentLength() {
-    contentLength = -1;
-    headers.removeAll("Content-Length");
-  }
-
-  public boolean isChunked() {
-    return "chunked".equalsIgnoreCase(transferEncoding);
-  }
-
-  public boolean hasConnectionClose() {
-    return "close".equalsIgnoreCase(connection);
-  }
-
-  public URI getUri() {
-    return uri;
-  }
-
-  public RawHeaders getHeaders() {
-    return headers;
-  }
-
-  public Date getServedDate() {
-    return servedDate;
-  }
-
-  public Date getLastModified() {
-    return lastModified;
-  }
-
-  public Date getExpires() {
-    return expires;
-  }
-
-  public boolean isNoCache() {
-    return noCache;
-  }
-
-  public boolean isNoStore() {
-    return noStore;
-  }
-
-  public int getMaxAgeSeconds() {
-    return maxAgeSeconds;
-  }
-
-  public int getSMaxAgeSeconds() {
-    return sMaxAgeSeconds;
-  }
-
-  public boolean isPublic() {
-    return isPublic;
-  }
-
-  public boolean isMustRevalidate() {
-    return mustRevalidate;
-  }
-
-  public String getEtag() {
-    return etag;
-  }
-
-  public Set<String> getVaryFields() {
-    return varyFields;
-  }
-
-  public String getContentEncoding() {
-    return contentEncoding;
-  }
-
-  public int getContentLength() {
-    return contentLength;
-  }
-
-  public String getConnection() {
-    return connection;
-  }
-
-  public void setLocalTimestamps(long sentRequestMillis, long receivedResponseMillis) {
-    this.sentRequestMillis = sentRequestMillis;
-    headers.add(SENT_MILLIS, Long.toString(sentRequestMillis));
-    this.receivedResponseMillis = receivedResponseMillis;
-    headers.add(RECEIVED_MILLIS, Long.toString(receivedResponseMillis));
-  }
-
-  public void setResponseSource(ResponseSource responseSource) {
-    headers.set(RESPONSE_SOURCE, responseSource.toString() + " " + headers.getResponseCode());
-  }
-
-  public void setTransport(String transport) {
-    headers.set(SELECTED_TRANSPORT, transport);
-  }
-
-  /**
-   * Returns the current age of the response, in milliseconds. The calculation
-   * is specified by RFC 2616, 13.2.3 Age Calculations.
-   */
-  private long computeAge(long nowMillis) {
-    long apparentReceivedAge =
-        servedDate != null ? Math.max(0, receivedResponseMillis - servedDate.getTime()) : 0;
-    long receivedAge =
-        ageSeconds != -1 ? Math.max(apparentReceivedAge, TimeUnit.SECONDS.toMillis(ageSeconds))
-            : apparentReceivedAge;
-    long responseDuration = receivedResponseMillis - sentRequestMillis;
-    long residentDuration = nowMillis - receivedResponseMillis;
-    return receivedAge + responseDuration + residentDuration;
-  }
-
-  /**
-   * Returns the number of milliseconds that the response was fresh for,
-   * starting from the served date.
-   */
-  private long computeFreshnessLifetime() {
-    if (maxAgeSeconds != -1) {
-      return TimeUnit.SECONDS.toMillis(maxAgeSeconds);
-    } else if (expires != null) {
-      long servedMillis = servedDate != null ? servedDate.getTime() : receivedResponseMillis;
-      long delta = expires.getTime() - servedMillis;
-      return delta > 0 ? delta : 0;
-    } else if (lastModified != null && uri.getRawQuery() == null) {
-      // As recommended by the HTTP RFC and implemented in Firefox, the
-      // max age of a document should be defaulted to 10% of the
-      // document's age at the time it was served. Default expiration
-      // dates aren't used for URIs containing a query.
-      long servedMillis = servedDate != null ? servedDate.getTime() : sentRequestMillis;
-      long delta = servedMillis - lastModified.getTime();
-      return delta > 0 ? (delta / 10) : 0;
-    }
-    return 0;
-  }
-
-  /**
-   * Returns true if computeFreshnessLifetime used a heuristic. If we used a
-   * heuristic to serve a cached response older than 24 hours, we are required
-   * to attach a warning.
-   */
-  private boolean isFreshnessLifetimeHeuristic() {
-    return maxAgeSeconds == -1 && expires == null;
-  }
-
-  /**
-   * Returns true if this response can be stored to later serve another
-   * request.
-   */
-  public boolean isCacheable(RequestHeaders request) {
-    // Always go to network for uncacheable response codes (RFC 2616, 13.4),
-    // This implementation doesn't support caching partial content.
-    int responseCode = headers.getResponseCode();
-    if (responseCode != HttpURLConnection.HTTP_OK
-        && responseCode != HttpURLConnection.HTTP_NOT_AUTHORITATIVE
-        && responseCode != HttpURLConnection.HTTP_MULT_CHOICE
-        && responseCode != HttpURLConnection.HTTP_MOVED_PERM
-        && responseCode != HttpURLConnection.HTTP_GONE) {
-      return false;
-    }
-
-    // Responses to authorized requests aren't cacheable unless they include
-    // a 'public', 'must-revalidate' or 's-maxage' directive.
-    if (request.hasAuthorization() && !isPublic && !mustRevalidate && sMaxAgeSeconds == -1) {
-      return false;
-    }
-
-    if (noStore) {
-      return false;
-    }
-
-    return true;
-  }
-
-  /**
-   * Returns true if a Vary header contains an asterisk. Such responses cannot
-   * be cached.
-   */
-  public boolean hasVaryAll() {
-    return varyFields.contains("*");
-  }
-
-  /**
-   * Returns true if none of the Vary headers on this response have changed
-   * between {@code cachedRequest} and {@code newRequest}.
-   */
-  public boolean varyMatches(Map<String, List<String>> cachedRequest,
-      Map<String, List<String>> newRequest) {
-    for (String field : varyFields) {
-      if (!equal(cachedRequest.get(field), newRequest.get(field))) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  /** Returns the source to satisfy {@code request} given this cached response. */
-  public ResponseSource chooseResponseSource(long nowMillis, RequestHeaders request) {
-    // If this response shouldn't have been stored, it should never be used
-    // as a response source. This check should be redundant as long as the
-    // persistence store is well-behaved and the rules are constant.
-    if (!isCacheable(request)) {
-      return ResponseSource.NETWORK;
-    }
-
-    if (request.isNoCache() || request.hasConditions()) {
-      return ResponseSource.NETWORK;
-    }
-
-    long ageMillis = computeAge(nowMillis);
-    long freshMillis = computeFreshnessLifetime();
-
-    if (request.getMaxAgeSeconds() != -1) {
-      freshMillis = Math.min(freshMillis, TimeUnit.SECONDS.toMillis(request.getMaxAgeSeconds()));
-    }
-
-    long minFreshMillis = 0;
-    if (request.getMinFreshSeconds() != -1) {
-      minFreshMillis = TimeUnit.SECONDS.toMillis(request.getMinFreshSeconds());
-    }
-
-    long maxStaleMillis = 0;
-    if (!mustRevalidate && request.getMaxStaleSeconds() != -1) {
-      maxStaleMillis = TimeUnit.SECONDS.toMillis(request.getMaxStaleSeconds());
-    }
-
-    if (!noCache && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
-      if (ageMillis + minFreshMillis >= freshMillis) {
-        headers.add("Warning", "110 HttpURLConnection \"Response is stale\"");
-      }
-      long oneDayMillis = 24 * 60 * 60 * 1000L;
-      if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
-        headers.add("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
-      }
-      return ResponseSource.CACHE;
-    }
-
-    if (lastModified != null) {
-      request.setIfModifiedSince(lastModified);
-    } else if (servedDate != null) {
-      request.setIfModifiedSince(servedDate);
-    }
-
-    if (etag != null) {
-      request.setIfNoneMatch(etag);
-    }
-
-    return request.hasConditions() ? ResponseSource.CONDITIONAL_CACHE : ResponseSource.NETWORK;
-  }
-
-  /**
-   * Returns true if this cached response should be used; false if the
-   * network response should be used.
-   */
-  public boolean validate(ResponseHeaders networkResponse) {
-    if (networkResponse.headers.getResponseCode() == HttpURLConnection.HTTP_NOT_MODIFIED) {
-      return true;
-    }
-
-    // The HTTP spec says that if the network's response is older than our
-    // cached response, we may return the cache's response. Like Chrome (but
-    // unlike Firefox), this client prefers to return the newer response.
-    if (lastModified != null
-        && networkResponse.lastModified != null
-        && networkResponse.lastModified.getTime() < lastModified.getTime()) {
-      return true;
-    }
-
-    return false;
-  }
-
-  /**
-   * Combines this cached header with a network header as defined by RFC 2616,
-   * 13.5.3.
-   */
-  public ResponseHeaders combine(ResponseHeaders network) throws IOException {
-    RawHeaders result = new RawHeaders();
-    result.setStatusLine(headers.getStatusLine());
-
-    for (int i = 0; i < headers.length(); i++) {
-      String fieldName = headers.getFieldName(i);
-      String value = headers.getValue(i);
-      if ("Warning".equals(fieldName) && value.startsWith("1")) {
-        continue; // drop 100-level freshness warnings
-      }
-      if (!isEndToEnd(fieldName) || network.headers.get(fieldName) == null) {
-        result.add(fieldName, value);
-      }
-    }
-
-    for (int i = 0; i < network.headers.length(); i++) {
-      String fieldName = network.headers.getFieldName(i);
-      if (isEndToEnd(fieldName)) {
-        result.add(fieldName, network.headers.getValue(i));
-      }
-    }
-
-    return new ResponseHeaders(uri, result);
-  }
-
-  /**
-   * Returns true if {@code fieldName} is an end-to-end HTTP header, as
-   * defined by RFC 2616, 13.5.1.
-   */
-  private static boolean isEndToEnd(String fieldName) {
-    return !"Connection".equalsIgnoreCase(fieldName)
-        && !"Keep-Alive".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
-        && !"TE".equalsIgnoreCase(fieldName)
-        && !"Trailers".equalsIgnoreCase(fieldName)
-        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
-        && !"Upgrade".equalsIgnoreCase(fieldName);
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 471539a467..2665125586 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -16,6 +16,8 @@
 
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.spdy.ErrorCode;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
@@ -23,8 +25,12 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.CacheRequest;
-import java.net.URL;
+import java.net.ProtocolException;
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Locale;
+import java.util.Set;
 
 public final class SpdyTransport implements Transport {
   private final HttpEngine httpEngine;
@@ -36,30 +42,21 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     this.spdyConnection = spdyConnection;
   }
 
-  @Override public OutputStream createRequestBody() throws IOException {
-    long fixedContentLength = httpEngine.policy.getFixedContentLength();
-    if (fixedContentLength != -1) {
-      httpEngine.requestHeaders.setContentLength(fixedContentLength);
-    }
-    // TODO: if we aren't streaming up to the server, we should buffer the whole request
-    writeRequestHeaders();
+  @Override public OutputStream createRequestBody(Request request) throws IOException {
+    // TODO: if bufferRequestBody is set, we must buffer the whole request
+    writeRequestHeaders(request);
     return stream.getOutputStream();
   }
 
-  @Override public void writeRequestHeaders() throws IOException {
-    if (stream != null) {
-      return;
-    }
+  @Override public void writeRequestHeaders(Request request) throws IOException {
+    if (stream != null) return;
+
     httpEngine.writingRequestHeaders();
-    RawHeaders requestHeaders = httpEngine.requestHeaders.getHeaders();
-    String version = httpEngine.connection.getHttpMinorVersion() == 1 ? "HTTP/1.1" : "HTTP/1.0";
-    URL url = httpEngine.policy.getURL();
-    requestHeaders.addSpdyRequestHeaders(httpEngine.method, HttpEngine.requestPath(url), version,
-        HttpEngine.getOriginAddress(url), httpEngine.uri.getScheme());
     boolean hasRequestBody = httpEngine.hasRequestBody();
     boolean hasResponseBody = true;
-    stream = spdyConnection.newStream(requestHeaders.toNameValueBlock(), hasRequestBody,
-        hasResponseBody);
+    String version = RequestLine.version(httpEngine.connection.getHttpMinorVersion());
+    stream = spdyConnection.newStream(
+        writeNameValueBlock(request, version), hasRequestBody, hasResponseBody);
     stream.setReadTimeout(httpEngine.client.getReadTimeout());
   }
 
@@ -71,14 +68,105 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     stream.getOutputStream().close();
   }
 
-  @Override public ResponseHeaders readResponseHeaders() throws IOException {
-    List<String> nameValueBlock = stream.getResponseHeaders();
-    RawHeaders rawHeaders = RawHeaders.fromNameValueBlock(nameValueBlock);
-    httpEngine.receiveHeaders(rawHeaders);
+  @Override public Response.Builder readResponseHeaders() throws IOException {
+    return readNameValueBlock(stream.getResponseHeaders());
+  }
+
+  /**
+   * Returns a list of alternating names and values containing a SPDY request.
+   * Names are all lower case. No names are repeated. If any name has multiple
+   * values, they are concatenated using "\0" as a delimiter.
+   */
+  public static List<String> writeNameValueBlock(Request request, String version) {
+    List<String> result = new ArrayList<String>(request.headerCount() + 10);
+    result.add(":method");
+    result.add(request.method());
+    result.add(":path");
+    result.add(RequestLine.requestPath(request.url()));
+    result.add(":version");
+    result.add(version);
+    result.add(":host");
+    result.add(HttpEngine.hostHeader(request.url()));
+    result.add(":scheme");
+    result.add(request.url().getProtocol());
+
+    Set<String> names = new LinkedHashSet<String>();
+    for (int i = 0; i < request.headerCount(); i++) {
+      String name = request.headerName(i).toLowerCase(Locale.US);
+      String value = request.headerValue(i);
+
+      // Drop headers that are forbidden when layering HTTP over SPDY.
+      if (name.equals("connection")
+          || name.equals("host")
+          || name.equals("keep-alive")
+          || name.equals("proxy-connection")
+          || name.equals("transfer-encoding")) {
+        continue;
+      }
+
+      // They shouldn't be set, but if they are, drop them. We've already written them!
+      if (name.equals(":method")
+          || name.equals(":path")
+          || name.equals(":version")
+          || name.equals(":host")
+          || name.equals(":scheme")) {
+        continue;
+      }
+
+      // If we haven't seen this name before, add the pair to the end of the list...
+      if (names.add(name)) {
+        result.add(name);
+        result.add(value);
+        continue;
+      }
+
+      // ...otherwise concatenate the existing values and this value.
+      for (int j = 0; j < result.size(); j += 2) {
+        if (name.equals(result.get(j))) {
+          result.set(j + 1, result.get(j + 1) + "\0" + value);
+          break;
+        }
+      }
+    }
+    return result;
+  }
+
+  /** Returns headers for a name value block containing a SPDY response. */
+  public static Response.Builder readNameValueBlock(List<String> nameValueBlock)
+      throws IOException {
+    if (nameValueBlock.size() % 2 != 0) {
+      throw new IllegalArgumentException("Unexpected name value block: " + nameValueBlock);
+    }
+    String status = null;
+    String version = null;
+
+    Headers.Builder headersBuilder = new Headers.Builder();
+    headersBuilder.set(SyntheticHeaders.SELECTED_TRANSPORT, "spdy/3");
+    for (int i = 0; i < nameValueBlock.size(); i += 2) {
+      String name = nameValueBlock.get(i);
+      String values = nameValueBlock.get(i + 1);
+      for (int start = 0; start < values.length(); ) {
+        int end = values.indexOf('\0', start);
+        if (end == -1) {
+          end = values.length();
+        }
+        String value = values.substring(start, end);
+        if (":status".equals(name)) {
+          status = value;
+        } else if (":version".equals(name)) {
+          version = value;
+        } else {
+          headersBuilder.add(name, value);
+        }
+        start = end + 1;
+      }
+    }
+    if (status == null) throw new ProtocolException("Expected ':status' header not present");
+    if (version == null) throw new ProtocolException("Expected ':version' header not present");
 
-    ResponseHeaders headers = new ResponseHeaders(httpEngine.uri, rawHeaders);
-    headers.setTransport("spdy/3");
-    return headers;
+    return new Response.Builder()
+        .statusLine(new StatusLine(version + " " + status))
+        .headers(headersBuilder.build());
   }
 
   @Override public InputStream getTransferStream(CacheRequest cacheRequest) throws IOException {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
new file mode 100644
index 0000000000..e62f21836a
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
@@ -0,0 +1,68 @@
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+
+public final class StatusLine {
+  /** Numeric status code, 307: Temporary Redirect. */
+  public static final int HTTP_TEMP_REDIRECT = 307;
+  public static final int HTTP_CONTINUE = 100;
+
+  private final String statusLine;
+  private final int httpMinorVersion;
+  private final int responseCode;
+  private final String responseMessage;
+
+  /** Sets the response status line (like "HTTP/1.0 200 OK"). */
+  public StatusLine(String statusLine) throws IOException {
+    // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
+    // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
+
+    // We allow empty message without leading white space since some servers
+    // do not send the white space when the message is empty.
+    boolean hasMessage = statusLine.length() > 13;
+    if (!statusLine.startsWith("HTTP/1.")
+        || statusLine.length() < 12
+        || statusLine.charAt(8) != ' '
+        || (hasMessage && statusLine.charAt(12) != ' ')) {
+      throw new ProtocolException("Unexpected status line: " + statusLine);
+    }
+    int httpMinorVersion = statusLine.charAt(7) - '0';
+    if (httpMinorVersion < 0 || httpMinorVersion > 9) {
+      throw new ProtocolException("Unexpected status line: " + statusLine);
+    }
+    int responseCode;
+    try {
+      responseCode = Integer.parseInt(statusLine.substring(9, 12));
+    } catch (NumberFormatException e) {
+      throw new ProtocolException("Unexpected status line: " + statusLine);
+    }
+    this.responseMessage = hasMessage ? statusLine.substring(13) : "";
+    this.responseCode = responseCode;
+    this.statusLine = statusLine;
+    this.httpMinorVersion = httpMinorVersion;
+  }
+
+  public String getStatusLine() {
+    return statusLine;
+  }
+
+  /**
+   * Returns the status line's HTTP minor version. This returns 0 for HTTP/1.0
+   * and 1 for HTTP/1.1. This returns 1 if the HTTP version is unknown.
+   */
+  public int httpMinorVersion() {
+    return httpMinorVersion != -1 ? httpMinorVersion : 1;
+  }
+
+  /** Returns the HTTP status code or -1 if it is unknown. */
+  public int code() {
+    return responseCode;
+  }
+
+  /** Returns the HTTP status message or null if it is unknown. */
+  public String message() {
+    return responseMessage;
+  }
+
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SyntheticHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SyntheticHeaders.java
new file mode 100644
index 0000000000..fbb633d654
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SyntheticHeaders.java
@@ -0,0 +1,23 @@
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.internal.Platform;
+
+/** Headers added to the HTTP response for internal use by OkHttp. */
+public final class SyntheticHeaders {
+  static final String PREFIX = Platform.get().getPrefix();
+
+  /** The local time when the request was sent. */
+  public static final String SENT_MILLIS = PREFIX + "-Sent-Millis";
+
+  /** The local time when the response was received. */
+  public static final String RECEIVED_MILLIS = PREFIX + "-Received-Millis";
+
+  /** The response source. */
+  public static final String RESPONSE_SOURCE = PREFIX + "-Response-Source";
+
+  /** The selected transport (spdy/3, http/1.1, etc). */
+  public static final String SELECTED_TRANSPORT = PREFIX + "-Selected-Transport";
+
+  private SyntheticHeaders() {
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
index d408bfec03..59e986f1a0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
@@ -16,6 +16,8 @@
 
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -38,10 +40,10 @@
    */
   // TODO: don't bother retransmitting the request body? It's quite a corner
   // case and there's uncertainty whether Firefox or Chrome do this
-  OutputStream createRequestBody() throws IOException;
+  OutputStream createRequestBody(Request request) throws IOException;
 
   /** This should update the HTTP engine's sentRequestMillis field. */
-  void writeRequestHeaders() throws IOException;
+  void writeRequestHeaders(Request request) throws IOException;
 
   /**
    * Sends the request body returned by {@link #createRequestBody} to the
@@ -53,7 +55,7 @@
   void flushRequest() throws IOException;
 
   /** Read response headers and update the cookie manager. */
-  ResponseHeaders readResponseHeaders() throws IOException;
+  Response.Builder readResponseHeaders() throws IOException;
 
   // TODO: make this the content stream?
   InputStream getTransferStream(CacheRequest cacheRequest) throws IOException;
diff --git a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java b/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
index 6636ca7cc6..e21f93877b 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
@@ -15,13 +15,21 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.RecordingHostnameVerifier;
+import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.File;
+import java.net.HttpURLConnection;
+import java.util.UUID;
+import javax.net.ssl.SSLContext;
 import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
 public final class AsyncApiTest {
@@ -29,8 +37,18 @@
   private OkHttpClient client = new OkHttpClient();
   private RecordingReceiver receiver = new RecordingReceiver();
 
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+  private HttpResponseCache cache;
+
+  @Before public void setUp() throws Exception {
+    String tmp = System.getProperty("java.io.tmpdir");
+    File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
+    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
+  }
+
   @After public void tearDown() throws Exception {
     server.shutdown();
+    cache.delete();
   }
 
   @Test public void get() throws Exception {
@@ -39,12 +57,13 @@
         .addHeader("Content-Type: text/plain"));
     server.play();
 
-    Request request = new Request.Builder(server.getUrl("/"))
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
         .header("User-Agent", "AsyncApiTest")
         .build();
     client.enqueue(request, receiver);
 
-    receiver.await(request)
+    receiver.await(request.url())
         .assertCode(200)
         .assertContainsHeaders("Content-Type: text/plain")
         .assertBody("abc");
@@ -52,21 +71,63 @@
     assertTrue(server.takeRequest().getHeaders().contains("User-Agent: AsyncApiTest"));
   }
 
+  @Test public void tls() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.enqueue(request, receiver);
+
+    receiver.await(request.url()).assertHandshake();
+  }
+
   @Test public void post() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
     server.play();
 
-    Request request = new Request.Builder(server.getUrl("/"))
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
         .post(Request.Body.create(MediaType.parse("text/plain"), "def"))
         .build();
     client.enqueue(request, receiver);
 
-    receiver.await(request)
+    receiver.await(request.url())
         .assertCode(200)
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("def", recordedRequest.getUtf8Body());
     assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void cache() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    client.setOkResponseCache(cache);
+
+    Request request1 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.enqueue(request1, receiver);
+    receiver.await(request1.url()).assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    Request request2 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.enqueue(request2, receiver);
+    receiver.await(request2.url()).assertCode(200).assertBody("A");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
   }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
index e243857333..bebe7220ba 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
@@ -24,8 +24,6 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
 import java.util.Arrays;
 import javax.net.ssl.SSLContext;
 import org.junit.After;
@@ -40,17 +38,7 @@
 
 public final class ConnectionPoolTest {
   private static final int KEEP_ALIVE_DURATION_MS = 5000;
-  private static final SSLContext sslContext;
-
-  static {
-    try {
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
 
   private final MockWebServer spdyServer = new MockWebServer();
   private InetSocketAddress spdySocketAddress;
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java b/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java
index f30ae98573..cf18e4f4f3 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java
@@ -20,6 +20,8 @@
 import java.util.List;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
 /**
@@ -58,4 +60,14 @@ public RecordedResponse assertBody(String expectedBody) {
     assertEquals(expectedBody, body);
     return this;
   }
+
+  public RecordedResponse assertHandshake() {
+    Handshake handshake = response.handshake();
+    assertNotNull(handshake.cipherSuite());
+    assertNotNull(handshake.peerPrincipal());
+    assertEquals(1, handshake.peerCertificates().size());
+    assertNull(handshake.localPrincipal());
+    assertEquals(0, handshake.localCertificates().size());
+    return this;
+  }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java b/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java
index ee0db124a9..5d36c8d6c9 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java
@@ -15,9 +15,13 @@
  */
 package com.squareup.okhttp;
 
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.net.URL;
 import java.util.ArrayList;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -26,6 +30,8 @@
 public class RecordingReceiver implements Response.Receiver {
   public static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10);
 
+  private final Map<Response, ByteArrayOutputStream> inFlightResponses
+      = new LinkedHashMap<Response, ByteArrayOutputStream>();
   private final List<RecordedResponse> responses = new ArrayList<RecordedResponse>();
 
   @Override public synchronized void onFailure(Failure failure) {
@@ -33,21 +39,42 @@
     notifyAll();
   }
 
-  @Override public synchronized void onResponse(Response response) throws IOException {
-    responses.add(new RecordedResponse(
-        response.request(), response, response.body().string(), null));
-    notifyAll();
+  @Override public synchronized boolean onResponse(Response response) throws IOException {
+    ByteArrayOutputStream out = inFlightResponses.get(response);
+    if (out == null) {
+      out = new ByteArrayOutputStream();
+      inFlightResponses.put(response, out);
+    }
+
+    byte[] buffer = new byte[1024];
+    Response.Body body = response.body();
+
+    while (body.ready()) {
+      int c = body.byteStream().read(buffer);
+
+      if (c == -1) {
+        inFlightResponses.remove(response);
+        responses.add(new RecordedResponse(
+            response.request(), response, out.toString("UTF-8"), null));
+        notifyAll();
+        return true;
+      }
+
+      out.write(buffer, 0, c);
+    }
+
+    return false;
   }
 
   /**
    * Returns the recorded response triggered by {@code request}. Throws if the
    * response isn't enqueued before the timeout.
    */
-  public synchronized RecordedResponse await(Request request) throws Exception {
+  public synchronized RecordedResponse await(URL url) throws Exception {
     long timeoutMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime()) + TIMEOUT_MILLIS;
     while (true) {
       for (RecordedResponse recordedResponse : responses) {
-        if (recordedResponse.request == request) {
+        if (recordedResponse.request.url().equals(url)) {
           return recordedResponse;
         }
       }
@@ -57,6 +84,6 @@ public synchronized RecordedResponse await(Request request) throws Exception {
       wait(timeoutMillis - nowMillis);
     }
 
-    throw new AssertionError("Timed out waiting for response to " + request);
+    throw new AssertionError("Timed out waiting for response to " + url);
   }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
new file mode 100644
index 0000000000..3b4dfcf091
--- /dev/null
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Test;
+
+import static junit.framework.Assert.assertNull;
+import static org.junit.Assert.assertEquals;
+
+public final class HeadersTest {
+  @Test public void parseNameValueBlock() throws IOException {
+    List<String> nameValueBlock = Arrays.asList(
+        "cache-control", "no-cache, no-store",
+        "set-cookie", "Cookie1\u0000Cookie2",
+        ":status", "200 OK",
+        ":version", "HTTP/1.1");
+    Request request = new Request.Builder().url("http://square.com/").build();
+    Response response = SpdyTransport.readNameValueBlock(nameValueBlock).request(request).build();
+    Headers headers = response.headers();
+    assertEquals(4, headers.size());
+    assertEquals("HTTP/1.1 200 OK", response.statusLine());
+    assertEquals("no-cache, no-store", headers.get("cache-control"));
+    assertEquals("Cookie2", headers.get("set-cookie"));
+    assertEquals("spdy/3", headers.get(SyntheticHeaders.SELECTED_TRANSPORT));
+    assertEquals(SyntheticHeaders.SELECTED_TRANSPORT, headers.name(0));
+    assertEquals("spdy/3", headers.value(0));
+    assertEquals("cache-control", headers.name(1));
+    assertEquals("no-cache, no-store", headers.value(1));
+    assertEquals("set-cookie", headers.name(2));
+    assertEquals("Cookie1", headers.value(2));
+    assertEquals("set-cookie", headers.name(3));
+    assertEquals("Cookie2", headers.value(3));
+    assertNull(headers.get(":status"));
+    assertNull(headers.get(":version"));
+  }
+
+  @Test public void toNameValueBlock() {
+    Request request = new Request.Builder()
+        .url("http://square.com/")
+        .header("cache-control", "no-cache, no-store")
+        .addHeader("set-cookie", "Cookie1")
+        .addHeader("set-cookie", "Cookie2")
+        .header(":status", "200 OK")
+        .build();
+    List<String> nameValueBlock = SpdyTransport.writeNameValueBlock(request, "HTTP/1.1");
+    List<String> expected = Arrays.asList(
+        ":method", "GET",
+        ":path", "/",
+        ":version", "HTTP/1.1",
+        ":host", "square.com",
+        ":scheme", "http",
+        "cache-control", "no-cache, no-store",
+        "set-cookie", "Cookie1\u0000Cookie2",
+        ":status", "200 OK");
+    assertEquals(expected, nameValueBlock);
+  }
+
+  @Test public void toNameValueBlockDropsForbiddenHeaders() {
+    Request request = new Request.Builder()
+        .url("http://square.com/")
+        .header("Connection", "close")
+        .header("Transfer-Encoding", "chunked")
+        .build();
+    List<String> expected = Arrays.asList(
+        ":method", "GET",
+        ":path", "/",
+        ":version", "HTTP/1.1",
+        ":host", "square.com",
+        ":scheme", "http");
+    assertEquals(expected, SpdyTransport.writeNameValueBlock(request, "HTTP/1.1"));
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index 822412a067..035d5d21c0 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -31,11 +31,8 @@
 import java.net.Authenticator;
 import java.net.CookieManager;
 import java.net.HttpURLConnection;
-import java.net.InetAddress;
 import java.net.URL;
 import java.net.URLConnection;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
@@ -64,16 +61,7 @@ public boolean verify(String hostname, SSLSession session) {
     }
   };
 
-  private static final SSLContext sslContext;
-  static {
-    try {
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
   private final MockWebServer server = new MockWebServer();
   private final String hostName = server.getHostName();
   private final OkHttpClient client = new OkHttpClient();
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
index 89f31da204..946c4084e3 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
@@ -18,6 +18,9 @@
 
 import com.squareup.okhttp.HttpResponseCache;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkResponseCache;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseSource;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
@@ -39,22 +42,18 @@
 import java.net.CookieManager;
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
-import java.net.InetAddress;
 import java.net.ResponseCache;
 import java.net.SecureCacheResponse;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.URLConnection;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
@@ -63,6 +62,7 @@
 import java.util.TimeZone;
 import java.util.UUID;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.zip.GZIPOutputStream;
@@ -89,23 +89,15 @@
       return true;
     }
   };
+
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+
   private final OkHttpClient client = new OkHttpClient();
   private MockWebServer server = new MockWebServer();
   private MockWebServer server2 = new MockWebServer();
   private HttpResponseCache cache;
   private final CookieManager cookieManager = new CookieManager();
 
-  private static final SSLContext sslContext;
-  static {
-    try {
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
   @Before public void setUp() throws Exception {
     String tmp = System.getProperty("java.io.tmpdir");
     File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
@@ -212,11 +204,10 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
     // exhaust the content stream
     readAscii(conn);
 
-    CacheResponse cached =
-        cache.get(url.toURI(), "GET", Collections.<String, List<String>>emptyMap());
+    Response cached = cache.get(new Request.Builder().url(url).build());
     if (shouldPut) {
       assertNotNull(Integer.toString(responseCode), cached);
-      cached.getBody().close();
+      cached.body().close();
     } else {
       assertNull(Integer.toString(responseCode), cached);
     }
@@ -231,40 +222,25 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
     final String body = "ABCDE";
     final AtomicInteger cacheCount = new AtomicInteger();
 
-    server.enqueue(
-        new MockResponse().setStatus("HTTP/1.1 200 Fantastic").addHeader("fgh: ijk").setBody(body));
-    server.play();
-
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        return null;
-      }
-
-      @Override public CacheRequest put(URI uri, URLConnection conn) throws IOException {
-        HttpURLConnection httpConnection = (HttpURLConnection) conn;
-        try {
-          httpConnection.getRequestProperties();
-          fail();
-        } catch (IllegalStateException expected) {
-        }
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 200 Fantastic")
+        .addHeader("Content-Type: text/plain")
+        .addHeader("fgh: ijk")
+        .setBody(body));
+    server.play();
+
+    client.setOkResponseCache(new AbstractOkResponseCache() {
+      @Override public CacheRequest put(Response response) throws IOException {
+        assertEquals(server.getUrl("/"), response.request().url());
+        assertEquals(200, response.code());
+        assertEquals(body.length(), response.body().contentLength());
+        assertEquals("text/plain", response.body().contentType().toString());
+        assertEquals("ijk", response.header("fgh"));
         try {
-          httpConnection.addRequestProperty("K", "V");
+          response.body().byteStream(); // the RI doesn't forbid this, but it should
           fail();
         } catch (IllegalStateException expected) {
         }
-        assertEquals("HTTP/1.1 200 Fantastic", httpConnection.getHeaderField(null));
-        assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"),
-            httpConnection.getHeaderFields().get(null));
-        assertEquals(200, httpConnection.getResponseCode());
-        assertEquals("Fantastic", httpConnection.getResponseMessage());
-        assertEquals(body.length(), httpConnection.getContentLength());
-        assertEquals("ijk", httpConnection.getHeaderField("fgh"));
-        try {
-          httpConnection.getInputStream(); // the RI doesn't forbid this, but it should
-          fail();
-        } catch (IOException expected) {
-        }
         cacheCount.incrementAndGet();
         return null;
       }
@@ -276,6 +252,32 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
     assertEquals(1, cacheCount.get());
   }
 
+  /** Don't explode if the cache returns a null body. http://b/3373699 */
+  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
+    final AtomicBoolean aborted = new AtomicBoolean();
+    client.setOkResponseCache(new AbstractOkResponseCache() {
+      @Override public CacheRequest put(Response response) throws IOException {
+        return new CacheRequest() {
+          @Override public void abort() {
+            aborted.set(true);
+          }
+
+          @Override public OutputStream getBody() throws IOException {
+            return null;
+          }
+        };
+      }
+    });
+
+    server.enqueue(new MockResponse().setBody("abcdef"));
+    server.play();
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("abc", readAscii(connection, 3));
+    connection.getInputStream().close();
+    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
+  }
+
   @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
     testResponseCaching(TransferKind.FIXED_LENGTH);
   }
@@ -334,32 +336,32 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("ABC"));
     server.play();
 
-    HttpsURLConnection connection = (HttpsURLConnection) client.open(server.getUrl("/"));
-    connection.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(connection));
+    HttpsURLConnection c1 = (HttpsURLConnection) client.open(server.getUrl("/"));
+    c1.setSSLSocketFactory(sslContext.getSocketFactory());
+    c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("ABC", readAscii(c1));
 
     // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    String suite = connection.getCipherSuite();
-    List<Certificate> localCerts = toListOrNull(connection.getLocalCertificates());
-    List<Certificate> serverCerts = toListOrNull(connection.getServerCertificates());
-    Principal peerPrincipal = connection.getPeerPrincipal();
-    Principal localPrincipal = connection.getLocalPrincipal();
-
-    connection = (HttpsURLConnection) client.open(server.getUrl("/")); // cached!
-    connection.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(connection));
+    String suite = c1.getCipherSuite();
+    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
+    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
+    Principal peerPrincipal = c1.getPeerPrincipal();
+    Principal localPrincipal = c1.getLocalPrincipal();
+
+    HttpsURLConnection c2 = (HttpsURLConnection) client.open(server.getUrl("/")); // cached!
+    c2.setSSLSocketFactory(sslContext.getSocketFactory());
+    c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("ABC", readAscii(c2));
 
     assertEquals(2, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(1, cache.getHitCount());
 
-    assertEquals(suite, connection.getCipherSuite());
-    assertEquals(localCerts, toListOrNull(connection.getLocalCertificates()));
-    assertEquals(serverCerts, toListOrNull(connection.getServerCertificates()));
-    assertEquals(peerPrincipal, connection.getPeerPrincipal());
-    assertEquals(localPrincipal, connection.getLocalPrincipal());
+    assertEquals(suite, c2.getCipherSuite());
+    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
+    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
+    assertEquals(peerPrincipal, c2.getPeerPrincipal());
+    assertEquals(localPrincipal, c2.getLocalPrincipal());
   }
 
   @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
@@ -445,13 +447,16 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
     HttpsURLConnection connection1 = (HttpsURLConnection) client.open(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection1));
+    assertNotNull(connection1.getCipherSuite());
 
     // Cached!
     HttpsURLConnection connection2 = (HttpsURLConnection) client.open(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection2));
+    assertNotNull(connection2.getCipherSuite());
 
     assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
     assertEquals(2, cache.getHitCount());
+    assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
   }
 
   /**
@@ -494,15 +499,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setBody("ABC"));
     server.play();
 
-    final AtomicReference<Map<String, List<String>>> requestHeadersRef =
-        new AtomicReference<Map<String, List<String>>>();
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        requestHeadersRef.set(requestHeaders);
-        return null;
-      }
-      @Override public CacheRequest put(URI uri, URLConnection conn) throws IOException {
+    final AtomicReference<Request> requestRef = new AtomicReference<Request>();
+    client.setOkResponseCache(new AbstractOkResponseCache() {
+      @Override public Response get(Request request) throws IOException {
+        requestRef.set(request);
         return null;
       }
     });
@@ -511,7 +511,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     URLConnection urlConnection = openConnection(url);
     urlConnection.addRequestProperty("A", "android");
     readAscii(urlConnection);
-    assertEquals(Arrays.asList("android"), requestHeadersRef.get().get("A"));
+    assertEquals(Arrays.asList("android"), requestRef.get().headers("A"));
   }
 
   @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
@@ -774,7 +774,7 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
 
     URLConnection request2 = openConnection(url);
     if (expectCached) {
-      assertEquals("1", request1.getHeaderField("X-Response-ID"));
+      assertEquals("1", request2.getHeaderField("X-Response-ID"));
     } else {
       assertEquals("2", request2.getHeaderField("X-Response-ID"));
     }
@@ -1048,6 +1048,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
+    assertEquals(1, cache.getRequestCount());
+    assertEquals(0, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
   }
 
   @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
@@ -1060,6 +1063,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     URLConnection connection = openConnection(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(1, cache.getHitCount());
   }
 
   @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
@@ -1072,6 +1078,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
   }
 
   @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
@@ -1082,6 +1091,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
   }
 
   @Test public void requestCacheControlNoCache() throws Exception {
@@ -1684,8 +1696,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
 
-    String source = connection.getHeaderField(ResponseHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CACHE.toString() + " 200", source);
+    String source = connection.getHeaderField(SyntheticHeaders.RESPONSE_SOURCE);
+    assertEquals(ResponseSource.CACHE + " 200", source);
   }
 
   @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
@@ -1701,8 +1713,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("B", readAscii(connection));
 
-    String source = connection.getHeaderField(ResponseHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CONDITIONAL_CACHE.toString() + " 200", source);
+    String source = connection.getHeaderField(SyntheticHeaders.RESPONSE_SOURCE);
+    assertEquals(ResponseSource.CONDITIONAL_CACHE + " 200", source);
   }
 
   @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
@@ -1716,8 +1728,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
 
-    String source = connection.getHeaderField(ResponseHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CONDITIONAL_CACHE.toString() + " 304", source);
+    String source = connection.getHeaderField(SyntheticHeaders.RESPONSE_SOURCE);
+    assertEquals(ResponseSource.CONDITIONAL_CACHE + " 304", source);
   }
 
   @Test public void responseSourceHeaderFetched() throws IOException {
@@ -1727,8 +1739,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     URLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
 
-    String source = connection.getHeaderField(ResponseHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.NETWORK.toString() + " 200", source);
+    String source = connection.getHeaderField(SyntheticHeaders.RESPONSE_SOURCE);
+    assertEquals(ResponseSource.NETWORK + " 200", source);
   }
 
   @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
@@ -1911,7 +1923,8 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
   private String readAscii(URLConnection connection, int count) throws IOException {
     HttpURLConnection httpConnection = (HttpURLConnection) connection;
     InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
-        ? connection.getInputStream() : httpConnection.getErrorStream();
+        ? connection.getInputStream()
+        : httpConnection.getErrorStream();
     StringBuilder result = new StringBuilder();
     for (int i = 0; i < count; i++) {
       int value = in.read();
@@ -1942,6 +1955,8 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
     }
     assertEquals(504, connection.getResponseCode());
     assertEquals(-1, connection.getErrorStream().read());
+    assertEquals(ResponseSource.NONE + " 504",
+        connection.getHeaderField(SyntheticHeaders.RESPONSE_SOURCE));
   }
 
   enum TransferKind {
@@ -2010,4 +2025,27 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
       return response;
     }
   }
+
+  static abstract class AbstractOkResponseCache implements OkResponseCache {
+    @Override public Response get(Request request) throws IOException {
+      return null;
+    }
+
+    @Override public CacheRequest put(Response response) throws IOException {
+      return null;
+    }
+
+    @Override public boolean maybeRemove(Request request) throws IOException {
+      return false;
+    }
+
+    @Override public void update(Response cached, Response network) throws IOException {
+    }
+
+    @Override public void trackConditionalCacheHit() {
+    }
+
+    @Override public void trackResponse(ResponseSource source) {
+    }
+  }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RawHeadersTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/RawHeadersTest.java
deleted file mode 100644
index 4ce80a5ebb..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RawHeadersTest.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import org.junit.Test;
-
-import static junit.framework.Assert.assertNull;
-import static org.junit.Assert.assertEquals;
-
-public final class RawHeadersTest {
-  @Test public void parseNameValueBlock() throws IOException {
-    List<String> nameValueBlock = Arrays.asList(
-        "cache-control", "no-cache, no-store",
-        "set-cookie", "Cookie1\u0000Cookie2",
-        ":status", "200 OK",
-        ":version", "HTTP/1.1");
-    RawHeaders rawHeaders = RawHeaders.fromNameValueBlock(nameValueBlock);
-    assertEquals(3, rawHeaders.length());
-    assertEquals("HTTP/1.1 200 OK", rawHeaders.getStatusLine());
-    assertEquals("no-cache, no-store", rawHeaders.get("cache-control"));
-    assertEquals("Cookie2", rawHeaders.get("set-cookie"));
-    assertEquals("cache-control", rawHeaders.getFieldName(0));
-    assertEquals("no-cache, no-store", rawHeaders.getValue(0));
-    assertEquals("set-cookie", rawHeaders.getFieldName(1));
-    assertEquals("Cookie1", rawHeaders.getValue(1));
-    assertEquals("set-cookie", rawHeaders.getFieldName(2));
-    assertEquals("Cookie2", rawHeaders.getValue(2));
-    assertNull(rawHeaders.get(":status"));
-    assertNull(rawHeaders.get(":version"));
-  }
-
-  @Test public void toNameValueBlock() {
-    RawHeaders rawHeaders = new RawHeaders();
-    rawHeaders.add("cache-control", "no-cache, no-store");
-    rawHeaders.add("set-cookie", "Cookie1");
-    rawHeaders.add("set-cookie", "Cookie2");
-    rawHeaders.add(":status", "200 OK");
-    // TODO: fromNameValueBlock should take the status line headers
-    List<String> nameValueBlock = rawHeaders.toNameValueBlock();
-    List<String> expected =
-        Arrays.asList("cache-control", "no-cache, no-store", "set-cookie", "Cookie1\u0000Cookie2",
-            ":status", "200 OK");
-    assertEquals(expected, nameValueBlock);
-  }
-
-  @Test public void toNameValueBlockDropsForbiddenHeaders() {
-    RawHeaders rawHeaders = new RawHeaders();
-    rawHeaders.add("Connection", "close");
-    rawHeaders.add("Transfer-Encoding", "chunked");
-    assertEquals(Arrays.<String>asList(), rawHeaders.toNameValueBlock());
-  }
-
-  @Test public void statusMessage() throws IOException {
-    RawHeaders rawHeaders = new RawHeaders();
-    final String message = "Temporary Redirect";
-    final int version = 1;
-    final int code = 200;
-    rawHeaders.setStatusLine("HTTP/1." + version + " " + code + " " + message);
-    assertEquals(message, rawHeaders.getResponseMessage());
-    assertEquals(version, rawHeaders.getHttpMinorVersion());
-    assertEquals(code, rawHeaders.getResponseCode());
-  }
-
-  @Test public void statusMessageWithEmptyMessage() throws IOException {
-    RawHeaders rawHeaders = new RawHeaders();
-    final int version = 1;
-    final int code = 503;
-    rawHeaders.setStatusLine("HTTP/1." + version + " " + code + " ");
-    assertEquals("", rawHeaders.getResponseMessage());
-    assertEquals(version, rawHeaders.getHttpMinorVersion());
-    assertEquals(code, rawHeaders.getResponseCode());
-  }
-
-  /**
-   * This is not defined in the protocol but some servers won't add the leading
-   * empty space when the message is empty.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
-   */
-  @Test public void statusMessageWithEmptyMessageAndNoLeadingSpace() throws IOException {
-    RawHeaders rawHeaders = new RawHeaders();
-    final int version = 1;
-    final int code = 503;
-    rawHeaders.setStatusLine("HTTP/1." + version + " " + code);
-    assertEquals("", rawHeaders.getResponseMessage());
-    assertEquals(version, rawHeaders.getHttpMinorVersion());
-    assertEquals(code, rawHeaders.getResponseCode());
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
index 7e0bdd81a9..c88edcefba 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
@@ -59,16 +59,14 @@
   private static final String uriHost = "hostA";
   private static final int uriPort = 80;
 
-  private static final SSLContext sslContext;
-  private static final SSLSocketFactory socketFactory;
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+  private static final SSLSocketFactory socketFactory = sslContext.getSocketFactory();
   private static final HostnameVerifier hostnameVerifier;
   private static final ConnectionPool pool;
 
   static {
     try {
       uri = new URI("http://" + uriHost + ":" + uriPort + "/path");
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-      socketFactory = sslContext.getSocketFactory();
       pool = ConnectionPool.getDefault();
       hostnameVerifier = HttpsURLConnectionImpl.getDefaultHostnameVerifier();
     } catch (Exception e) {
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
new file mode 100644
index 0000000000..bc92397e64
--- /dev/null
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public final class StatusLineTest {
+  @Test public void parse() throws IOException {
+    String message = "Temporary Redirect";
+    int version = 1;
+    int code = 200;
+    StatusLine statusLine = new StatusLine("HTTP/1." + version + " " + code + " " + message);
+    assertEquals(message, statusLine.message());
+    assertEquals(version, statusLine.httpMinorVersion());
+    assertEquals(code, statusLine.code());
+  }
+
+  @Test public void emptyMessage() throws IOException {
+    int version = 1;
+    int code = 503;
+    StatusLine statusLine = new StatusLine("HTTP/1." + version + " " + code + " ");
+    assertEquals("", statusLine.message());
+    assertEquals(version, statusLine.httpMinorVersion());
+    assertEquals(code, statusLine.code());
+  }
+
+  /**
+   * This is not defined in the protocol but some servers won't add the leading
+   * empty space when the message is empty.
+   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
+   */
+  @Test public void emptyMessageAndNoLeadingSpace() throws IOException {
+    int version = 1;
+    int code = 503;
+    StatusLine statusLine = new StatusLine("HTTP/1." + version + " " + code);
+    assertEquals("", statusLine.message());
+    assertEquals(version, statusLine.httpMinorVersion());
+    assertEquals(code, statusLine.code());
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 7725f3d155..125c34cd03 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -48,7 +48,6 @@
 import java.net.URL;
 import java.net.URLConnection;
 import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
@@ -61,7 +60,6 @@
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.zip.GZIPInputStream;
 import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.HttpsURLConnection;
@@ -77,6 +75,7 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.OkAuthenticator.Credential;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
@@ -89,6 +88,8 @@
 
 /** Android's URLConnectionTest. */
 public final class URLConnectionTest {
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+
   private MockWebServer server = new MockWebServer();
   private MockWebServer server2 = new MockWebServer();
 
@@ -96,17 +97,6 @@
   private HttpResponseCache cache;
   private String hostName;
 
-  private static final SSLContext sslContext;
-  static {
-    try {
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
   @Before public void setUp() throws Exception {
     hostName = server.getHostName();
     server.setNpnEnabled(false);
@@ -623,6 +613,7 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
     URL url = new URL("http://android.com/foo");
     HttpURLConnection connection = proxyConfig.connect(server, client, url);
     assertContent("this response comes via a proxy", connection);
+    assertTrue(connection.usingProxy());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET http://android.com/foo HTTP/1.1", request.getRequestLine());
@@ -1139,26 +1130,21 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection is pooled!
   }
 
-  /**
-   * Obnoxiously test that the chunk sizes transmitted exactly equal the
-   * requested data+chunk header size. Although setChunkedStreamingMode()
-   * isn't specific about whether the size applies to the data or the
-   * complete chunk, the RI interprets it as a complete chunk.
-   */
   @Test public void setChunkedStreamingMode() throws IOException, InterruptedException {
     server.enqueue(new MockResponse());
     server.play();
 
+    String body = "ABCDEFGHIJKLMNOPQ";
     HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.setChunkedStreamingMode(8);
+    urlConnection.setChunkedStreamingMode(0); // OkHttp does not honor specific chunk sizes.
     urlConnection.setDoOutput(true);
     OutputStream outputStream = urlConnection.getOutputStream();
-    outputStream.write("ABCDEFGHIJKLMNOPQ".getBytes("US-ASCII"));
+    outputStream.write(body.getBytes("US-ASCII"));
     assertEquals(200, urlConnection.getResponseCode());
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("ABCDEFGHIJKLMNOPQ", new String(request.getBody(), "US-ASCII"));
-    assertEquals(Arrays.asList(3, 3, 3, 3, 3, 2), request.getChunkSizes());
+    assertEquals(body, new String(request.getBody(), "US-ASCII"));
+    assertEquals(Arrays.asList(body.length()), request.getChunkSizes());
   }
 
   @Test public void authenticateWithFixedLengthStreaming() throws Exception {
@@ -1789,7 +1775,7 @@ private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
 
   private void test307Redirect(String method) throws Exception {
     MockResponse response1 = new MockResponse()
-        .setResponseCode(HttpURLConnectionImpl.HTTP_TEMP_REDIRECT)
+        .setResponseCode(HTTP_TEMP_REDIRECT)
         .addHeader("Location: /page2");
     if (!method.equals("HEAD")) {
       response1.setBody("This page has moved!");
@@ -2123,35 +2109,22 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   /** Don't explode if the cache returns a null body. http://b/3373699 */
-  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
-    final AtomicBoolean aborted = new AtomicBoolean();
-    client.setResponseCache(new ResponseCache() {
+  @Test public void installDeprecatedJavaNetResponseCache() throws Exception {
+    ResponseCache cache = new ResponseCache() {
       @Override public CacheResponse get(URI uri, String requestMethod,
           Map<String, List<String>> requestHeaders) throws IOException {
         return null;
       }
-
       @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        return new CacheRequest() {
-          @Override public void abort() {
-            aborted.set(true);
-          }
-
-          @Override public OutputStream getBody() throws IOException {
-            return null;
-          }
-        };
+        return null;
       }
-    });
-
-    server.enqueue(new MockResponse().setBody("abcdef"));
-    server.play();
+    };
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    InputStream in = connection.getInputStream();
-    assertEquals("abc", readAscii(in, 3));
-    in.close();
-    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
+    try {
+      client.setResponseCache(cache);
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
   }
 
   /** http://code.google.com/p/android/issues/detail?id=14562 */
