diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index 21c4f2d8cf..183f50e223 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -25,6 +25,7 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.ProtocolException;
+import java.net.Proxy;
 import java.net.ServerSocket;
 import java.net.UnknownServiceException;
 import java.security.cert.Certificate;
@@ -55,6 +56,7 @@
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
 import okhttp3.internal.http.FakeDns;
+import okhttp3.internal.http.RecordingProxySelector;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
@@ -98,6 +100,7 @@
 
   @Before public void setUp() throws Exception {
     logger.addHandler(logHandler);
+    client.setDns(new SingleInetAddressDns()); // Prevent unexpected fallback addresses.
   }
 
   @After public void tearDown() throws Exception {
@@ -755,13 +758,13 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   /** https://github.com/square/okhttp/issues/442 */
-  @Test public void timeoutsNotRetried() throws Exception {
+  @Test public void tlsTimeoutsNotRetried() throws Exception {
+    enableTls();
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.NO_RESPONSE));
     server.enqueue(new MockResponse()
         .setBody("unreachable!"));
 
-    client.setDns(new DoubleInetAddressDns());
     client.setReadTimeout(100, TimeUnit.MILLISECONDS);
 
     Request request = new Request.Builder().url(server.url("/")).build();
@@ -773,6 +776,29 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
   }
 
+  /**
+   * Make a request with two routes. The first route will time out because it's connecting via a
+   * null proxy server. The second will succeed.
+   */
+  @Test public void connectTimeoutsAttemptsAlternateRoute() throws Exception {
+    InetSocketAddress nullServerAddress = startNullServer();
+
+    RecordingProxySelector proxySelector = new RecordingProxySelector();
+    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, nullServerAddress));
+    proxySelector.proxies.add(server.toProxyAddress());
+
+    server.enqueue(new MockResponse()
+        .setBody("success!"));
+
+    client.setProxySelector(proxySelector);
+    client.setReadTimeout(100, TimeUnit.MILLISECONDS);
+
+    Request request = new Request.Builder().url("http://android.com/").build();
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("success!");
+  }
+
   /** https://github.com/square/okhttp/issues/1801 */
   @Test public void asyncCallEngineInitialized() throws Exception {
     OkHttpClient c = new OkHttpClient();
@@ -2144,7 +2170,8 @@ private void makeFailingCall() {
         throw new IOException("write body fail!");
       }
     };
-    Call call = client.newCall(new Request.Builder()
+    OkHttpClient nonRetryingClient = client.clone().setRetryOnConnectionFailure(false);
+    Call call = nonRetryingClient.newCall(new Request.Builder()
         .url(server.url("/"))
         .post(requestBody)
         .build());
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index 494f09fd92..0328317d4a 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -2344,11 +2344,13 @@ protected Socket configureSocket(Socket socket) throws IOException {
   }
 
   @Test public void connectionCloseWithRedirect() throws IOException, InterruptedException {
-    MockResponse response = new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+    MockResponse response = new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /foo")
         .addHeader("Connection: close");
     server.enqueue(response);
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
+    server.enqueue(new MockResponse()
+        .setBody("This is the new location!"));
 
     URLConnection connection = client.open(server.url("/").url());
     assertEquals("This is the new location!",
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
index 94b9f2fcd7..5b4b630d32 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
@@ -28,9 +28,9 @@
 import static org.junit.Assert.assertEquals;
 
 public final class RecordingProxySelector extends ProxySelector {
-  final List<URI> requestedUris = new ArrayList<>();
-  List<Proxy> proxies = new ArrayList<>();
-  final List<String> failures = new ArrayList<>();
+  public final List<Proxy> proxies = new ArrayList<>();
+  public final List<URI> requestedUris = new ArrayList<>();
+  public final List<String> failures = new ArrayList<>();
 
   @Override public List<Proxy> select(URI uri) {
     requestedUris.add(uri);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
index adc7f17043..ef6ca0eb47 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RouteSelectorTest.java
@@ -15,6 +15,10 @@
  */
 package okhttp3.internal.http;
 
+import java.io.IOException;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
 import okhttp3.Address;
 import okhttp3.Authenticator;
 import okhttp3.ConnectionSpec;
@@ -144,12 +148,21 @@
   }
 
   @Test public void proxySelectorReturnsNull() throws Exception {
-    Address address = httpAddress();
+    ProxySelector nullProxySelector = new ProxySelector() {
+      @Override public List<Proxy> select(URI uri) {
+        assertEquals(uriHost, uri.getHost());
+        return null;
+      }
 
-    proxySelector.proxies = null;
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
-    proxySelector.assertRequests(address.url().uri());
+      @Override public void connectFailed(
+          URI uri, SocketAddress socketAddress, IOException e) {
+        throw new AssertionError();
+      }
+    };
 
+    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
+        authenticator, null, protocols, connectionSpecs, nullProxySelector);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
     assertTrue(routeSelector.hasNext());
     dns.addresses(makeFakeAddresses(255, 1));
     assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
index 668661f618..2aa26117c5 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/HttpURLConnectionImpl.java
@@ -469,7 +469,7 @@ private boolean execute(boolean readResponse) throws IOException {
       throw toThrow;
     } catch (RouteException e) {
       // The attempt to connect via a route failed. The request will not have been sent.
-      HttpEngine retryEngine = httpEngine.recover(e);
+      HttpEngine retryEngine = httpEngine.recover(e.getLastConnectException());
       if (retryEngine != null) {
         releaseConnection = false;
         httpEngine = retryEngine;
diff --git a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
index a36a3cd57a..64eb30109d 100644
--- a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
+++ b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
@@ -182,7 +182,7 @@ private StreamWebSocket(StreamAllocation streamAllocation,
     @Override protected void close() throws IOException {
       replyExecutor.shutdown();
       streamAllocation.noNewStreams();
-      streamAllocation.streamFinished(streamAllocation.stream());
+      streamAllocation.streamFinished(true, streamAllocation.stream());
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index 78804a9f5b..f5c2cb9ed6 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -291,7 +291,7 @@ Response getResponse(Request request, boolean forWebSocket) throws IOException {
         throw e.getCause();
       } catch (RouteException e) {
         // The attempt to connect via a route failed. The request will not have been sent.
-        HttpEngine retryEngine = engine.recover(e);
+        HttpEngine retryEngine = engine.recover(e.getLastConnectException(), null);
         if (retryEngine != null) {
           releaseConnection = false;
           engine = retryEngine;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
index 98e2ab3dfc..1af3079b07 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http1xStream.java
@@ -16,6 +16,9 @@
 
 package okhttp3.internal.http;
 
+import java.io.EOFException;
+import java.io.IOException;
+import java.net.ProtocolException;
 import okhttp3.Headers;
 import okhttp3.Request;
 import okhttp3.Response;
@@ -23,9 +26,6 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.io.RealConnection;
-import java.io.EOFException;
-import java.io.IOException;
-import java.net.ProtocolException;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -352,24 +352,15 @@ private FixedLengthSink(long bytesRemaining) {
      * Closes the cache entry and makes the socket available for reuse. This
      * should be invoked when the end of the body has been reached.
      */
-    protected final void endOfInput() throws IOException {
+    protected final void endOfInput(boolean reuseConnection) throws IOException {
+      if (state == STATE_CLOSED) return;
       if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
 
       detachTimeout(timeout);
 
       state = STATE_CLOSED;
       if (streamAllocation != null) {
-        streamAllocation.streamFinished(Http1xStream.this);
-      }
-    }
-
-    protected final void unexpectedEndOfInput() {
-      if (state == STATE_CLOSED) return;
-
-      state = STATE_CLOSED;
-      if (streamAllocation != null) {
-        streamAllocation.noNewStreams();
-        streamAllocation.streamFinished(Http1xStream.this);
+        streamAllocation.streamFinished(!reuseConnection, Http1xStream.this);
       }
     }
   }
@@ -381,7 +372,7 @@ protected final void unexpectedEndOfInput() {
     public FixedLengthSource(long length) throws IOException {
       bytesRemaining = length;
       if (bytesRemaining == 0) {
-        endOfInput();
+        endOfInput(true);
       }
     }
 
@@ -392,13 +383,13 @@ public FixedLengthSource(long length) throws IOException {
 
       long read = source.read(sink, Math.min(bytesRemaining, byteCount));
       if (read == -1) {
-        unexpectedEndOfInput(); // The server didn't supply the promised content length.
+        endOfInput(false); // The server didn't supply the promised content length.
         throw new ProtocolException("unexpected end of stream");
       }
 
       bytesRemaining -= read;
       if (bytesRemaining == 0) {
-        endOfInput();
+        endOfInput(true);
       }
       return read;
     }
@@ -406,9 +397,8 @@ public FixedLengthSource(long length) throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
 
-      if (bytesRemaining != 0
-          && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        unexpectedEndOfInput();
+      if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+        endOfInput(false);
       }
 
       closed = true;
@@ -438,7 +428,7 @@ public FixedLengthSource(long length) throws IOException {
 
       long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
       if (read == -1) {
-        unexpectedEndOfInput(); // The server didn't supply the promised chunk length.
+        endOfInput(false); // The server didn't supply the promised chunk length.
         throw new ProtocolException("unexpected end of stream");
       }
       bytesRemainingInChunk -= read;
@@ -463,14 +453,14 @@ private void readChunkSize() throws IOException {
       if (bytesRemainingInChunk == 0L) {
         hasMoreChunks = false;
         httpEngine.receiveHeaders(readHeaders());
-        endOfInput();
+        endOfInput(true);
       }
     }
 
     @Override public void close() throws IOException {
       if (closed) return;
       if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        unexpectedEndOfInput();
+        endOfInput(false);
       }
       closed = true;
     }
@@ -489,7 +479,7 @@ private void readChunkSize() throws IOException {
       long read = source.read(sink, byteCount);
       if (read == -1) {
         inputExhausted = true;
-        endOfInput();
+        endOfInput(true);
         return -1;
       }
       return read;
@@ -498,7 +488,7 @@ private void readChunkSize() throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
       if (!inputExhausted) {
-        unexpectedEndOfInput();
+        endOfInput(false);
       }
       closed = true;
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
index 4dbd4ecabc..a6c272414e 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/Http2xStream.java
@@ -289,7 +289,7 @@ public StreamFinishingSource(Source delegate) {
     }
 
     @Override public void close() throws IOException {
-      streamAllocation.streamFinished(Http2xStream.this);
+      streamAllocation.streamFinished(false, Http2xStream.this);
       super.close();
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
index cdd6722cbb..3dde593394 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpEngine.java
@@ -192,7 +192,7 @@ public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBod
    *
    * @throws RequestException if there was a problem with request setup. Unrecoverable.
    * @throws RouteException if the was a problem during connection via a specific route. Sometimes
-   *     recoverable. See {@link #recover(RouteException)}.
+   *     recoverable. See {@link #recover}.
    * @throws IOException if there was a problem while making a request. Sometimes recoverable. See
    *     {@link #recover(IOException)}.
    *
@@ -340,32 +340,10 @@ public Connection getConnection() {
     return streamAllocation.connection();
   }
 
-  /**
-   * Attempt to recover from failure to connect via a route. Returns a new HTTP engine
-   * that should be used for the retry if there are other routes to try, or null if
-   * there are no more routes to try.
-   */
-  public HttpEngine recover(RouteException e) {
-    if (!streamAllocation.recover(e)) {
-      return null;
-    }
-
-    if (!client.getRetryOnConnectionFailure()) {
-      return null;
-    }
-
-    StreamAllocation streamAllocation = close();
-
-    // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, userRequest, bufferRequestBody, callerWritesRequestBody,
-        forWebSocket, streamAllocation, (RetryableSink) requestBodyOut, priorResponse);
-  }
-
   /**
    * Report and attempt to recover from a failure to communicate with a server. Returns a new
    * HTTP engine that should be used for the retry if {@code e} is recoverable, or null if
-   * the failure is permanent. Requests with a body can only be recovered if the
-   * body is buffered.
+   * the failure is permanent. Requests with a body can only be recovered if the body is buffered.
    */
   public HttpEngine recover(IOException e, Sink requestBodyOut) {
     if (!streamAllocation.recover(e, requestBodyOut)) {
@@ -445,7 +423,7 @@ public StreamAllocation close() {
       closeQuietly(userResponse.body());
     } else {
       // If this engine never achieved a response body, its stream allocation is dead.
-      streamAllocation.connectionFailed();
+      streamAllocation.connectionFailed(null);
     }
 
     return streamAllocation;
diff --git a/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
index 7ac6c613ec..b3853c32f8 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/StreamAllocation.java
@@ -15,13 +15,6 @@
  */
 package okhttp3.internal.http;
 
-import okhttp3.Address;
-import okhttp3.ConnectionPool;
-import okhttp3.Route;
-import okhttp3.internal.Internal;
-import okhttp3.internal.RouteDatabase;
-import okhttp3.internal.Util;
-import okhttp3.internal.io.RealConnection;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.lang.ref.Reference;
@@ -31,6 +24,13 @@
 import java.security.cert.CertificateException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.Address;
+import okhttp3.ConnectionPool;
+import okhttp3.Route;
+import okhttp3.internal.Internal;
+import okhttp3.internal.RouteDatabase;
+import okhttp3.internal.Util;
+import okhttp3.internal.io.RealConnection;
 import okio.Sink;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -74,6 +74,7 @@
  */
 public final class StreamAllocation {
   public final Address address;
+  private Route route;
   private final ConnectionPool connectionPool;
 
   // State guarded by connectionPool.
@@ -86,6 +87,7 @@
   public StreamAllocation(ConnectionPool connectionPool, Address address) {
     this.connectionPool = connectionPool;
     this.address = address;
+    this.routeSelector = new RouteSelector(address, routeDatabase());
   }
 
   public HttpStream newStream(int connectTimeout, int readTimeout, int writeTimeout,
@@ -106,7 +108,6 @@ public HttpStream newStream(int connectTimeout, int readTimeout, int writeTimeou
       }
 
       synchronized (connectionPool) {
-        resultConnection.streamCount++;
         stream = resultStream;
         return resultStream;
       }
@@ -128,7 +129,7 @@ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout
       if (connection.isHealthy(doExtensiveHealthChecks)) {
         return candidate;
       }
-      connectionFailed();
+      connectionFailed(new IOException());
     }
   }
 
@@ -138,6 +139,7 @@ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout
    */
   private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
       boolean connectionRetryEnabled) throws IOException, RouteException {
+    Route selectedRoute;
     synchronized (connectionPool) {
       if (released) throw new IllegalStateException("released");
       if (stream != null) throw new IllegalStateException("stream != null");
@@ -155,14 +157,16 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
         return pooledConnection;
       }
 
-      // Attempt to create a connection.
-      if (routeSelector == null) {
-        routeSelector = new RouteSelector(address, routeDatabase());
-      }
+      selectedRoute = route;
     }
 
-    Route route = routeSelector.next();
-    RealConnection newConnection = new RealConnection(route);
+    if (selectedRoute == null) {
+      selectedRoute = routeSelector.next();
+      synchronized (connectionPool) {
+        route = selectedRoute;
+      }
+    }
+    RealConnection newConnection = new RealConnection(selectedRoute);
     acquire(newConnection);
 
     synchronized (connectionPool) {
@@ -178,13 +182,16 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
     return newConnection;
   }
 
-  public void streamFinished(HttpStream stream) {
+  public void streamFinished(boolean noNewStreams, HttpStream stream) {
     synchronized (connectionPool) {
       if (stream == null || stream != this.stream) {
         throw new IllegalStateException("expected " + this.stream + " but was " + stream);
       }
+      if (!noNewStreams) {
+        connection.successCount++;
+      }
     }
-    deallocate(false, false, true);
+    deallocate(noNewStreams, false, true);
   }
 
   public HttpStream stream() {
@@ -229,9 +236,6 @@ private void deallocate(boolean noNewStreams, boolean released, boolean streamFi
         }
         if (this.stream == null && (this.released || connection.noNewStreams)) {
           release(connection);
-          if (connection.streamCount > 0) {
-            routeSelector = null;
-          }
           if (connection.allocations.isEmpty()) {
             connection.idleAtNanos = System.nanoTime();
             if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
@@ -262,24 +266,16 @@ public void cancel() {
     }
   }
 
-  private void connectionFailed(IOException e) {
+  public void connectionFailed(IOException e) {
     synchronized (connectionPool) {
-      if (routeSelector != null) {
-        if (connection.streamCount == 0) {
-          // Record the failure on a fresh route.
-          Route failedRoute = connection.getRoute();
-          routeSelector.connectFailed(failedRoute, e);
-        } else {
-          // We saw a failure on a recycled connection, reset this allocation with a fresh route.
-          routeSelector = null;
+      // Avoid this route if it's never seen a successful call.
+      if (connection != null && connection.successCount == 0) {
+        if (route != null && e != null) {
+          routeSelector.connectFailed(route, e);
         }
+        route = null;
       }
     }
-    connectionFailed();
-  }
-
-  /** Finish the current stream and prevent new streams from being created. */
-  public void connectionFailed() {
     deallocate(true, false, true);
   }
 
@@ -303,29 +299,9 @@ private void release(RealConnection connection) {
     throw new IllegalStateException();
   }
 
-  public boolean recover(RouteException e) {
-    if (connection != null) {
-      connectionFailed(e.getLastConnectException());
-    }
-
-    if ((routeSelector != null && !routeSelector.hasNext()) // No more routes to attempt.
-        || !isRecoverable(e)) {
-      return false;
-    }
-
-    return true;
-  }
-
   public boolean recover(IOException e, Sink requestBodyOut) {
     if (connection != null) {
-      int streamCount = connection.streamCount;
       connectionFailed(e);
-
-      if (streamCount == 1) {
-        // This isn't a recycled connection.
-        // TODO(jwilson): find a better way for this.
-        return false;
-      }
     }
 
     boolean canRetryRequestBody = requestBodyOut == null || requestBodyOut instanceof RetryableSink;
@@ -344,42 +320,22 @@ private boolean isRecoverable(IOException e) {
       return false;
     }
 
-    // If there was an interruption or timeout, don't recover.
-    if (e instanceof InterruptedIOException) {
-      return false;
-    }
-
-    return true;
-  }
-
-  private boolean isRecoverable(RouteException e) {
-    // Problems with a route may mean the connection can be retried with a new route, or may
-    // indicate a client-side or server-side issue that should not be retried. To tell, we must look
-    // at the cause.
-
-    IOException ioe = e.getLastConnectException();
-
-    // If there was a protocol problem, don't recover.
-    if (ioe instanceof ProtocolException) {
-      return false;
-    }
-
     // If there was an interruption don't recover, but if there was a timeout
     // we should try the next route (if there is one).
-    if (ioe instanceof InterruptedIOException) {
-      return ioe instanceof SocketTimeoutException;
+    if (e instanceof InterruptedIOException) {
+      return e instanceof SocketTimeoutException;
     }
 
     // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
     // again with a different route.
-    if (ioe instanceof SSLHandshakeException) {
+    if (e instanceof SSLHandshakeException) {
       // If the problem was a CertificateException from the X509TrustManager,
       // do not retry.
-      if (ioe.getCause() instanceof CertificateException) {
+      if (e.getCause() instanceof CertificateException) {
         return false;
       }
     }
-    if (ioe instanceof SSLPeerUnverifiedException) {
+    if (e instanceof SSLPeerUnverifiedException) {
       // e.g. a certificate pinning error.
       return false;
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
index 59a1c5b4b4..f4fa537e9a 100644
--- a/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/io/RealConnection.java
@@ -74,7 +74,7 @@
   private Handshake handshake;
   private Protocol protocol;
   public volatile FramedConnection framedConnection;
-  public int streamCount;
+  public int successCount;
   public BufferedSource source;
   public BufferedSink sink;
   public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();
