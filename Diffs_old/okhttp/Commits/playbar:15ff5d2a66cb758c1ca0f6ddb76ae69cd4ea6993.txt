diff --git a/README.md b/README.md
index 298b139f42..1f1f83f7d9 100644
--- a/README.md
+++ b/README.md
@@ -45,7 +45,13 @@ or Gradle:
 testCompile 'com.squareup.okhttp3:mockwebserver:3.5.0'
 ```
 
+ProGuard
+--------
 
+If you are using ProGuard you might need to add the following option:
+```
+-dontwarn okhttp3.**
+```
 
 License
 -------
diff --git a/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java b/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
index 9823d01343..c9a2da9a39 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
@@ -126,7 +126,7 @@ private void send404(Http2Stream stream, String path) throws IOException {
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", "text/plain")
     );
-    stream.reply(responseHeaders, true);
+    stream.sendResponseHeaders(responseHeaders, true);
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("Not found: " + path);
     out.close();
@@ -138,7 +138,7 @@ private void serveDirectory(Http2Stream stream, File[] files) throws IOException
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", "text/html; charset=UTF-8")
     );
-    stream.reply(responseHeaders, true);
+    stream.sendResponseHeaders(responseHeaders, true);
     BufferedSink out = Okio.buffer(stream.getSink());
     for (File file : files) {
       String target = file.isDirectory() ? (file.getName() + "/") : file.getName();
@@ -153,7 +153,7 @@ private void serveFile(Http2Stream stream, File file) throws IOException {
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", contentType(file))
     );
-    stream.reply(responseHeaders, true);
+    stream.sendResponseHeaders(responseHeaders, true);
     Source source = Okio.source(file);
     try {
       BufferedSink out = Okio.buffer(stream.getSink());
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 76ee2fbec0..17ea30300d 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -86,6 +86,7 @@
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_REQUEST_BODY;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
+import static okhttp3.mockwebserver.SocketPolicy.EXPECT_CONTINUE;
 import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
 import static okhttp3.mockwebserver.SocketPolicy.NO_RESPONSE;
 import static okhttp3.mockwebserver.SocketPolicy.RESET_STREAM_AT_START;
@@ -590,7 +591,7 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
     Headers.Builder headers = new Headers.Builder();
     long contentLength = -1;
     boolean chunked = false;
-    boolean expectContinue = false;
+    boolean readBody = true;
     String header;
     while ((header = source.readUtf8LineStrict()).length() != 0) {
       Internal.instance.addLenient(headers, header);
@@ -603,23 +604,26 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
         chunked = true;
       }
       if (lowercaseHeader.startsWith("expect:")
-          && lowercaseHeader.substring(7).trim().equals("100-continue")) {
-        expectContinue = true;
+          && lowercaseHeader.substring(7).trim().equalsIgnoreCase("100-continue")) {
+        readBody = false;
       }
     }
 
-    if (expectContinue) {
+    if (!readBody && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {
       sink.writeUtf8("HTTP/1.1 100 Continue\r\n");
       sink.writeUtf8("Content-Length: 0\r\n");
       sink.writeUtf8("\r\n");
       sink.flush();
+      readBody = true;
     }
 
     boolean hasBody = false;
     TruncatingBuffer requestBody = new TruncatingBuffer(bodyLimit);
     List<Integer> chunkSizes = new ArrayList<>();
     MockResponse policy = dispatcher.peek();
-    if (contentLength != -1) {
+    if (!readBody) {
+      // Don't read the body unless we've invited the client to send it.
+    } else if (contentLength != -1) {
       hasBody = contentLength > 0;
       throttledTransfer(policy, socket, source, Okio.buffer(requestBody), contentLength, true);
     } else if (chunked) {
@@ -858,12 +862,17 @@ private FramedSocketHandler(Socket socket, Protocol protocol) {
       RecordedRequest request = readRequest(stream);
       requestCount.incrementAndGet();
       requestQueue.add(request);
+
       MockResponse response;
       try {
         response = dispatcher.dispatch(request);
       } catch (InterruptedException e) {
         throw new AssertionError(e);
       }
+      if (response.getSocketPolicy() == DISCONNECT_AFTER_REQUEST) {
+        socket.close();
+        return;
+      }
       writeResponse(stream, response);
       if (logger.isLoggable(Level.INFO)) {
         logger.info(MockWebServer.this + " received request: " + request
@@ -881,6 +890,7 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
       Headers.Builder httpHeaders = new Headers.Builder();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
+      boolean readBody = true;
       for (int i = 0, size = streamHeaders.size(); i < size; i++) {
         ByteString name = streamHeaders.get(i).name;
         String value = streamHeaders.get(i).value.utf8();
@@ -893,11 +903,23 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
         } else {
           throw new IllegalStateException();
         }
+        if (name.utf8().equals("expect") && value.equalsIgnoreCase("100-continue")) {
+          // Don't read the body unless we've invited the client to send it.
+          readBody = false;
+        }
+      }
+
+      if (!readBody && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {
+        stream.sendResponseHeaders(Collections.singletonList(
+            new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue"))), true);
+        stream.getConnection().flush();
+        readBody = true;
       }
 
       Buffer body = new Buffer();
-      body.writeAll(stream.getSource());
-      body.close();
+      if (readBody) {
+        body.writeAll(stream.getSource());
+      }
 
       String requestLine = method + ' ' + path + " HTTP/1.1";
       List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for HTTP/2.
@@ -928,7 +950,7 @@ private void writeResponse(Http2Stream stream, MockResponse response) throws IOE
 
       Buffer body = response.getBody();
       boolean closeStreamAfterHeaders = body != null || !response.getPushPromises().isEmpty();
-      stream.reply(http2Headers, closeStreamAfterHeaders);
+      stream.sendResponseHeaders(http2Headers, closeStreamAfterHeaders);
       pushPromises(stream, response.getPushPromises());
       if (body != null) {
         BufferedSink sink = Okio.buffer(stream.getSink());
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
index 153d3fd129..521c5a0e58 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
@@ -97,5 +97,12 @@
    * Fail HTTP/2 requests without processing them by sending an {@linkplain
    * MockResponse#getHttp2ErrorCode() HTTP/2 error code}.
    */
-  RESET_STREAM_AT_START
+  RESET_STREAM_AT_START,
+
+  /**
+   * Transmit a {@code HTTP/1.1 100 Continue} response before reading the HTTP request body.
+   * Typically this response is sent when a client makes a request with the header {@code
+   * Expect: 100-continue}.
+   */
+  EXPECT_CONTINUE
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index 9f508842b3..6ecdcb421a 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -94,7 +94,7 @@
 import static org.junit.Assert.fail;
 
 public final class CallTest {
-  @Rule public final TestRule timeout = new Timeout(30_000);
+  @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
   @Rule public final MockWebServer server = new MockWebServer();
   @Rule public final MockWebServer server2 = new MockWebServer();
   @Rule public final InMemoryFileSystem fileSystem = new InMemoryFileSystem();
@@ -1000,6 +1000,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously("/").assertBody("retry success");
   }
 
+  @Test public void recoverWhenRetryOnConnectionFailureIsTrue_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    recoverWhenRetryOnConnectionFailureIsTrue();
+  }
+
   @Test public void noRecoverWhenRetryOnConnectionFailureIsFalse() throws Exception {
     server.enqueue(new MockResponse().setBody("seed connection pool"));
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
@@ -1015,8 +1020,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     // If this succeeds, too many requests were made.
     executeSynchronously("/")
         .assertFailure(IOException.class)
-        .assertFailureMatches("unexpected end of stream on Connection.*"
-            + server.getHostName() + ":" + server.getPort() + ".*");
+        .assertFailureMatches("stream was reset: CANCEL",
+            "unexpected end of stream on Connection.*"
+                + server.getHostName() + ":" + server.getPort() + ".*");
+  }
+
+  @Test public void recoverWhenRetryOnConnectionFailureIsFalse_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    noRecoverWhenRetryOnConnectionFailureIsFalse();
   }
 
   @Test public void recoverFromTlsHandshakeFailure() throws Exception {
@@ -1233,6 +1244,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     assertEquals(0, post2.getSequenceNumber());
   }
 
+  @Test public void postBodyRetransmittedOnFailureRecovery_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedOnFailureRecovery();
+  }
+
   @Test public void cacheHit() throws Exception {
     server.enqueue(new MockResponse()
         .addHeader("ETag: v1")
@@ -2185,7 +2201,8 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void expect100ContinueNonEmptyRequestBody() throws Exception {
-    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -2214,6 +2231,88 @@ private InetSocketAddress startNullServer() throws IOException {
         .assertSuccessful();
   }
 
+  @Test public void expect100ContinueEmptyRequestBody_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    expect100ContinueEmptyRequestBody();
+  }
+
+  @Test public void expect100ContinueTimesOutWithoutContinue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+    client = client.newBuilder()
+        .readTimeout(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("", recordedRequest.getBody().readUtf8());
+  }
+
+  @Test public void expect100ContinueTimesOutWithoutContinue_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    expect100ContinueTimesOutWithoutContinue();
+  }
+
+  @Test public void serverRespondsWithUnsolicited100Continue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 100 Continue"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .build();
+
+    Call call = client.newCall(request);
+    Response response = call.execute();
+    assertEquals(100, response.code());
+    assertEquals("Continue", response.message());
+    assertEquals("", response.body().string());
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("abc", recordedRequest.getBody().readUtf8());
+  }
+
+  @Test public void serverRespondsWithUnsolicited100Continue_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    serverRespondsWithUnsolicited100Continue();
+  }
+
+  @Test public void successfulExpectContinueAndConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
+    server.enqueue(new MockResponse());
+
+    executeSynchronously("/", "Expect", "100-continue");
+    executeSynchronously("/");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void unsuccessfulExpectContinueAndConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    executeSynchronously("/", "Expect", "100-continue");
+    executeSynchronously("/");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
   /** We forbid non-ASCII characters in outgoing request headers, but accept UTF-8. */
   @Test public void responseHeaderParsingIsLenient() throws Exception {
     Headers headers = new Headers.Builder()
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
index 64d741193d..3c5267bcc9 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -26,6 +26,7 @@
 import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.HeldCertificate;
+import okhttp3.internal.tls.SslClient;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -45,9 +46,8 @@
   }
 
   @Test public void equalsFromTrustManager() throws Exception {
-    Platform platform = Platform.get();
-    X509TrustManager x509TrustManager = platform.trustManager(
-        (SSLSocketFactory) SSLSocketFactory.getDefault());
+    SslClient client = new SslClient.Builder().build();
+    X509TrustManager x509TrustManager = client.trustManager;
     assertEquals(
         CertificateChainCleaner.get(x509TrustManager),
         CertificateChainCleaner.get(x509TrustManager));
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
index 80346ba443..0d07c26b2d 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
@@ -54,27 +54,27 @@
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
     assertEquals(100L, pool.cleanup(50L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
 
     // Running at time 60, the pool returns that nothing can be evicted until time 150.
     assertEquals(90L, pool.cleanup(60L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
 
     // Running at time 149, the pool returns that nothing can be evicted until time 150.
     assertEquals(1L, pool.cleanup(149L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
 
     // Running at time 150, the pool evicts.
     assertEquals(0, pool.cleanup(150L));
     assertEquals(0, pool.connectionCount());
-    assertTrue(c1.socket.isClosed());
+    assertTrue(c1.socket().isClosed());
 
     // Running again, the pool reports that no further runs are necessary.
     assertEquals(-1, pool.cleanup(150L));
     assertEquals(0, pool.connectionCount());
-    assertTrue(c1.socket.isClosed());
+    assertTrue(c1.socket().isClosed());
   }
 
   @Test public void inUseConnectionsNotEvicted() throws Exception {
@@ -90,17 +90,17 @@
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
     assertEquals(100L, pool.cleanup(50L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
 
     // Running at time 60, the pool returns that nothing can be evicted until time 160.
     assertEquals(100L, pool.cleanup(60L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
 
     // Running at time 160, the pool returns that nothing can be evicted until time 260.
     assertEquals(100L, pool.cleanup(160L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
   }
 
   @Test public void cleanupPrioritizesEarliestEviction() throws Exception {
@@ -121,8 +121,8 @@
     // Running at time 150, the pool evicts c2.
     assertEquals(0L, pool.cleanup(150L));
     assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
-    assertTrue(c2.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
+    assertTrue(c2.socket().isClosed());
 
     // Running at time 150, the pool returns that nothing can be evicted until time 175.
     assertEquals(25L, pool.cleanup(150L));
@@ -131,8 +131,8 @@
     // Running at time 175, the pool evicts c1.
     assertEquals(0L, pool.cleanup(175L));
     assertEquals(0, pool.connectionCount());
-    assertTrue(c1.socket.isClosed());
-    assertTrue(c2.socket.isClosed());
+    assertTrue(c1.socket().isClosed());
+    assertTrue(c2.socket().isClosed());
   }
 
   @Test public void oldestConnectionsEvictedIfIdleLimitExceeded() throws Exception {
@@ -145,8 +145,8 @@
     // With 2 connections, there's no need to evict until the connections time out.
     assertEquals(50L, pool.cleanup(100L));
     assertEquals(2, pool.connectionCount());
-    assertFalse(c1.socket.isClosed());
-    assertFalse(c2.socket.isClosed());
+    assertFalse(c1.socket().isClosed());
+    assertFalse(c2.socket().isClosed());
 
     // Add a third connection
     RealConnection c3 = newConnection(pool, routeC1, 75L);
@@ -154,9 +154,9 @@
     // The third connection bounces the first.
     assertEquals(0L, pool.cleanup(100L));
     assertEquals(2, pool.connectionCount());
-    assertTrue(c1.socket.isClosed());
-    assertFalse(c2.socket.isClosed());
-    assertFalse(c3.socket.isClosed());
+    assertTrue(c1.socket().isClosed());
+    assertFalse(c2.socket().isClosed());
+    assertFalse(c3.socket().isClosed());
   }
 
   @Test public void leakedAllocation() throws Exception {
@@ -182,13 +182,11 @@ private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection conne
   }
 
   private RealConnection newConnection(ConnectionPool pool, Route route, long idleAtNanos) {
-    RealConnection connection = new RealConnection(route);
-    connection.idleAtNanos = idleAtNanos;
-    connection.socket = new Socket();
+    RealConnection result = RealConnection.testConnection(pool, route, new Socket(), idleAtNanos);
     synchronized (pool) {
-      pool.put(connection);
+      pool.put(result);
     }
-    return connection;
+    return result;
   }
 
   private Address newAddress(String name) {
diff --git a/okhttp-tests/src/test/java/okhttp3/CookieTest.java b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
index bee549dc7d..e36fc0c820 100644
--- a/okhttp-tests/src/test/java/okhttp3/CookieTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
@@ -50,6 +50,14 @@
     assertNull(Cookie.parse(url, "\r\t \n=b"));
   }
 
+  @Test public void spaceInName() throws Exception {
+    assertEquals("a b", Cookie.parse(url, "a b=cd").name());
+  }
+
+  @Test public void spaceInValue() throws Exception {
+    assertEquals("c d", Cookie.parse(url, "ab=c d").value());
+  }
+
   @Test public void trimLeadingAndTrailingWhitespaceFromName() throws Exception {
     assertEquals("a", Cookie.parse(url, " a=b").name());
     assertEquals("a", Cookie.parse(url, "a =b").name());
@@ -69,6 +77,23 @@
     assertEquals("b", Cookie.parse(url, "a=\r\t \nb\n\t \n").value());
   }
 
+  @Test public void invalidCharacters() throws Exception {
+    assertEquals(null, Cookie.parse(url, "a\u0000b=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u0000d"));
+    assertEquals(null, Cookie.parse(url, "a\u0001b=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u0001d"));
+    assertEquals(null, Cookie.parse(url, "a\u0009b=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u0009d"));
+    assertEquals(null, Cookie.parse(url, "a\u001fb=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u001fd"));
+    assertEquals(null, Cookie.parse(url, "a\u007fb=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u007fd"));
+    assertEquals(null, Cookie.parse(url, "a\u0080b=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u0080d"));
+    assertEquals(null, Cookie.parse(url, "a\u00ffb=cd"));
+    assertEquals(null, Cookie.parse(url, "ab=c\u00ffd"));
+  }
+
   @Test public void maxAge() throws Exception {
     assertEquals(51000L,
         Cookie.parse(50000L, url, "a=b; Max-Age=1").expiresAt());
diff --git a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
index 535dfcadd5..16ef3bef7d 100644
--- a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
@@ -56,6 +56,7 @@
         .url("http://square.com/")
         .header("Connection", "upgrade")
         .header("Upgrade", "websocket")
+        .header("Host", "square.com")
         .build();
     List<Header> expected = headerEntries(
         ":method", "GET",
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
index 3d5eb7cfd8..e068e4df52 100644
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -160,6 +160,58 @@
     assertEquals(HttpUrl.parse("http://a/ht.tp//b/"), base.resolve("ht.tp//b/"));
   }
 
+  /** https://tools.ietf.org/html/rfc3986#section-5.4.1 */
+  @Test public void rfc3886NormalExamples() {
+    HttpUrl url = HttpUrl.parse("http://a/b/c/d;p?q");
+    assertEquals(null, url.resolve("g:h")); // No 'g:' scheme in HttpUrl.
+    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("./g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g/"), url.resolve("g/"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/g"));
+    assertEquals(HttpUrl.parse("http://g"), url.resolve("//g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/d;p?y"), url.resolve("?y"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g?y"), url.resolve("g?y"));
+    assertEquals(HttpUrl.parse("http://a/b/c/d;p?q#s"), url.resolve("#s"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g#s"), url.resolve("g#s"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g?y#s"), url.resolve("g?y#s"));
+    assertEquals(HttpUrl.parse("http://a/b/c/;x"), url.resolve(";x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g;x"), url.resolve("g;x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g;x?y#s"), url.resolve("g;x?y#s"));
+    assertEquals(HttpUrl.parse("http://a/b/c/d;p?q"), url.resolve(""));
+    assertEquals(HttpUrl.parse("http://a/b/c/"), url.resolve("."));
+    assertEquals(HttpUrl.parse("http://a/b/c/"), url.resolve("./"));
+    assertEquals(HttpUrl.parse("http://a/b/"), url.resolve(".."));
+    assertEquals(HttpUrl.parse("http://a/b/"), url.resolve("../"));
+    assertEquals(HttpUrl.parse("http://a/b/g"), url.resolve("../g"));
+    assertEquals(HttpUrl.parse("http://a/"), url.resolve("../.."));
+    assertEquals(HttpUrl.parse("http://a/"), url.resolve("../../"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../g"));
+  }
+
+  /** https://tools.ietf.org/html/rfc3986#section-5.4.2 */
+  @Test public void rfc3886AbnormalExamples() {
+    HttpUrl url = HttpUrl.parse("http://a/b/c/d;p?q");
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../../g"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../../../g"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/./g"));
+    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/../g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g."), url.resolve("g."));
+    assertEquals(HttpUrl.parse("http://a/b/c/.g"), url.resolve(".g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g.."), url.resolve("g.."));
+    assertEquals(HttpUrl.parse("http://a/b/c/..g"), url.resolve("..g"));
+    assertEquals(HttpUrl.parse("http://a/b/g"), url.resolve("./../g"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g/"), url.resolve("./g/."));
+    assertEquals(HttpUrl.parse("http://a/b/c/g/h"), url.resolve("g/./h"));
+    assertEquals(HttpUrl.parse("http://a/b/c/h"), url.resolve("g/../h"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g;x=1/y"), url.resolve("g;x=1/./y"));
+    assertEquals(HttpUrl.parse("http://a/b/c/y"), url.resolve("g;x=1/../y"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g?y/./x"), url.resolve("g?y/./x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g?y/../x"), url.resolve("g?y/../x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g#s/./x"), url.resolve("g#s/./x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g#s/../x"), url.resolve("g#s/../x"));
+    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("http:g")); // "http:g" also okay.
+  }
+
   @Test public void parseAuthoritySlashCountDoesntMatter() throws Exception {
     assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:host/path"));
     assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/host/path"));
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
index 460ab66846..b11854a277 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
@@ -154,10 +154,12 @@ public RecordedResponse assertFailure(String... messages) {
     return this;
   }
 
-  public RecordedResponse assertFailureMatches(String pattern) {
+  public RecordedResponse assertFailureMatches(String... patterns) {
     assertNotNull(failure);
-    assertTrue(failure.getMessage(), failure.getMessage().matches(pattern));
-    return this;
+    for (String pattern : patterns) {
+      if (failure.getMessage().matches(pattern)) return this;
+    }
+    throw new AssertionError(failure.getMessage());
   }
 
   public RecordedResponse assertSentRequestAtMillis(long minimum, long maximum) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java
new file mode 100644
index 0000000000..ba3b84f91e
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.Socket;
+import java.util.Deque;
+import java.util.concurrent.LinkedBlockingDeque;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.DelegatingSSLSocket;
+import okhttp3.DelegatingSSLSocketFactory;
+import okio.Buffer;
+import okio.ByteString;
+
+/** Records all bytes written and read from a socket and makes them available for inspection. */
+public final class SocketRecorder {
+  private final Deque<RecordedSocket> recordedSockets = new LinkedBlockingDeque<>();
+
+  /** Returns an SSLSocketFactory whose sockets will record all transmitted bytes. */
+  public SSLSocketFactory sslSocketFactory(SSLSocketFactory delegate) {
+    return new DelegatingSSLSocketFactory(delegate) {
+      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
+        RecordedSocket recordedSocket = new RecordedSocket();
+        recordedSockets.add(recordedSocket);
+        return new RecordingSSLSocket(sslSocket, recordedSocket);
+      }
+    };
+  }
+
+  public RecordedSocket takeSocket() {
+    return recordedSockets.remove();
+  }
+
+  /** A bidirectional transfer of unadulterated bytes over a socket. */
+  public static final class RecordedSocket {
+    private final Buffer bytesWritten = new Buffer();
+    private final Buffer bytesRead = new Buffer();
+
+    synchronized void byteWritten(int b) {
+      bytesWritten.writeByte(b);
+    }
+
+    synchronized void byteRead(int b) {
+      bytesRead.writeByte(b);
+    }
+
+    synchronized void bytesWritten(byte[] bytes, int offset, int length) {
+      bytesWritten.write(bytes, offset, length);
+    }
+
+    synchronized void bytesRead(byte[] bytes, int offset, int length) {
+      bytesRead.write(bytes, offset, length);
+    }
+
+    /** Returns all bytes that have been written to this socket. */
+    public synchronized ByteString bytesWritten() {
+      return bytesWritten.readByteString();
+    }
+
+    /** Returns all bytes that have been read from this socket. */
+    public synchronized ByteString bytesRead() {
+      return bytesRead.readByteString();
+    }
+  }
+
+  static final class RecordingInputStream extends InputStream {
+    private final Socket socket;
+    private final RecordedSocket recordedSocket;
+
+    RecordingInputStream(Socket socket, RecordedSocket recordedSocket) {
+      this.socket = socket;
+      this.recordedSocket = recordedSocket;
+    }
+
+    @Override public int read() throws IOException {
+      int b = socket.getInputStream().read();
+      if (b == -1) return -1;
+      recordedSocket.byteRead(b);
+      return b;
+    }
+
+    @Override public int read(byte[] b, int off, int len) throws IOException {
+      int read = socket.getInputStream().read(b, off, len);
+      if (read == -1) return -1;
+      recordedSocket.bytesRead(b, off, read);
+      return read;
+    }
+
+    @Override public void close() throws IOException {
+      socket.getInputStream().close();
+    }
+  }
+
+  static final class RecordingOutputStream extends OutputStream {
+    private final Socket socket;
+    private final RecordedSocket recordedSocket;
+
+    RecordingOutputStream(Socket socket, RecordedSocket recordedSocket) {
+      this.socket = socket;
+      this.recordedSocket = recordedSocket;
+    }
+
+    @Override public void write(int b) throws IOException {
+      socket.getOutputStream().write(b);
+      recordedSocket.byteWritten(b);
+    }
+
+    @Override public void write(byte[] b, int off, int len) throws IOException {
+      socket.getOutputStream().write(b, off, len);
+      recordedSocket.bytesWritten(b, off, len);
+    }
+
+    @Override public void close() throws IOException {
+      socket.getOutputStream().close();
+    }
+
+    @Override public void flush() throws IOException {
+      socket.getOutputStream().flush();
+    }
+  }
+
+  static final class RecordingSSLSocket extends DelegatingSSLSocket {
+    private final InputStream inputStream;
+    private final OutputStream outputStream;
+
+    RecordingSSLSocket(SSLSocket delegate, RecordedSocket recordedSocket) {
+      super(delegate);
+      inputStream = new RecordingInputStream(delegate, recordedSocket);
+      outputStream = new RecordingOutputStream(delegate, recordedSocket);
+    }
+
+    @Override public void startHandshake() throws IOException {
+      // Intercept the handshake to properly configure TLS extensions with Jetty ALPN. Jetty ALPN
+      // expects the real SSLSocket to be placed in the global map. Because we are wrapping the real
+      // SSLSocket, it confuses Jetty ALPN. This patches that up so things work as expected.
+      Class<?> alpn = null;
+      Class<?> provider = null;
+      try {
+        alpn = Class.forName("org.eclipse.jetty.alpn.ALPN");
+        provider = Class.forName("org.eclipse.jetty.alpn.ALPN$Provider");
+      } catch (ClassNotFoundException ignored) {
+      }
+
+      if (alpn == null || provider == null) {
+        // No Jetty, so nothing to worry about.
+        super.startHandshake();
+        return;
+      }
+
+      Object providerInstance = null;
+      Method putMethod = null;
+      try {
+        Method getMethod = alpn.getMethod("get", SSLSocket.class);
+        putMethod = alpn.getMethod("put", SSLSocket.class, provider);
+        providerInstance = getMethod.invoke(null, this);
+        if (providerInstance == null) {
+          // Jetty's on the classpath but TLS extensions weren't used.
+          super.startHandshake();
+          return;
+        }
+
+        // TLS extensions were used; replace with the real SSLSocket to make Jetty ALPN happy.
+        putMethod.invoke(null, delegate, providerInstance);
+        super.startHandshake();
+      } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
+        throw new AssertionError();
+      } finally {
+        // If we replaced the SSLSocket in the global map, we must put the original back for
+        // everything to work inside OkHttp.
+        if (providerInstance != null) {
+          try {
+            putMethod.invoke(null, this, providerInstance);
+          } catch (IllegalAccessException | InvocationTargetException e) {
+            throw new AssertionError();
+          }
+        }
+      }
+    }
+
+    @Override public InputStream getInputStream() throws IOException {
+      return inputStream;
+    }
+
+    @Override public OutputStream getOutputStream() throws IOException {
+      return outputStream;
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
index d4ae88b84a..6475cf8da3 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
@@ -33,6 +33,7 @@
 import okio.Source;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
@@ -93,6 +94,38 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertJournalEquals();
   }
 
+  @Test
+  @Ignore
+  public void recoverFromInitializationFailure() throws IOException {
+    // Add an uncommitted entry. This will get detected on initialization, and the cache will
+    // attempt to delete the file. Do not explicitly close the cache here so the entry is left as
+    // incomplete.
+    DiskLruCache.Editor creator = cache.edit("k1");
+    BufferedSink sink = Okio.buffer(creator.newSink(0));
+    sink.writeUtf8("Hello");
+    sink.close();
+
+    // Simulate a filesystem failure on the first initialization.
+    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), true);
+    fileSystem.setFaultyDelete(cacheDir, true);
+
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    toClose.add(cache);
+
+    try {
+      cache.get("k1");
+      fail();
+    } catch (Exception expected) {
+    }
+
+    // Now let it operate normally.
+    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), false);
+    fileSystem.setFaultyDelete(cacheDir, false);
+
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertNull(snapshot);
+  }
+
   @Test public void validateKey() throws Exception {
     String key = null;
     try {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index 37bec5e529..18fcab5a12 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -291,7 +291,7 @@
     connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
     buffer.writeAll(in);
@@ -513,7 +513,7 @@
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("c3po");
     out.close();
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
     assertStreamData("robot", stream.getSource());
     connection.ping().roundTripTime();
     assertEquals(0, connection.openStreamCount());
@@ -914,7 +914,7 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("c", "cola"), false);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
 
     // verify the peer received what was expected
@@ -940,7 +940,7 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
     assertStreamData("robot", stream.getSource());
 
     // verify the peer received what was expected
@@ -973,7 +973,7 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
+    assertEquals(headerEntries("b", "banana"), stream.takeResponseHeaders());
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
@@ -997,7 +997,7 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     try {
-      stream.getResponseHeaders();
+      stream.takeResponseHeaders();
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
@@ -1189,7 +1189,7 @@
     stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
     long startNanos = System.nanoTime();
     try {
-      stream.getResponseHeaders();
+      stream.takeResponseHeaders();
       fail();
     } catch (InterruptedIOException expected) {
     }
@@ -1362,7 +1362,8 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
-    assertEquals(headerEntries("a", "android", "c", "c3po"), stream.getResponseHeaders());
+    assertEquals(Arrays.asList(new Header("a", "android"), null, new Header("c", "c3po")),
+        stream.takeResponseHeaders());
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
@@ -1371,6 +1372,30 @@
     assertEquals(Http2.TYPE_PING, ping.type);
   }
 
+  @Test public void readMultipleSetsOfResponseHeaders() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PING
+    peer.sendFrame().synReply(true, 3, headerEntries("c", "cola"));
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    stream.getConnection().flush();
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    connection.ping().roundTripTime();
+    assertEquals(headerEntries("c", "cola"), stream.takeResponseHeaders());
+
+    // verify the peer received what was expected
+    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+  }
+
   @Test public void readSendsWindowUpdate() throws Exception {
     int windowSize = 100;
     int windowUpdateThreshold = 50;
@@ -1396,7 +1421,7 @@
     connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
     buffer.writeAll(in);
@@ -1474,7 +1499,7 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
     Source in = stream.getSource();
     try {
       Okio.buffer(in).readByteString(101);
@@ -1540,7 +1565,7 @@
 
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     try {
-      stream.getResponseHeaders();
+      stream.takeResponseHeaders();
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 4c2e05844b..a6f59493aa 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -20,7 +20,10 @@
 import java.net.Authenticator;
 import java.net.HttpURLConnection;
 import java.net.SocketTimeoutException;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -39,19 +42,24 @@
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
+import okhttp3.TestUtil;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
 import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.internal.SocketRecorder;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.PushPromise;
+import okhttp3.mockwebserver.QueueDispatcher;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
 import okio.Buffer;
 import okio.BufferedSink;
+import okio.BufferedSource;
 import okio.GzipSink;
 import okio.Okio;
 import org.junit.After;
@@ -67,6 +75,7 @@
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /** Test how SPDY interacts with HTTP/2 features. */
@@ -331,8 +340,7 @@
     in.close();
   }
 
-  @Ignore // See https://github.com/square/okhttp/issues/578
-  @Test(timeout = 3000) public void readResponseHeaderTimeout() throws Exception {
+  @Test public void readResponseHeaderTimeout() throws Exception {
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
     server.enqueue(new MockResponse().setBody("A"));
 
@@ -340,11 +348,27 @@
         .readTimeout(1000, MILLISECONDS)
         .build();
 
-    Call call = client.newCall(new Request.Builder()
+    // Make a call expecting a timeout reading the response headers.
+    Call call1 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
-    Response response = call.execute();
-    assertEquals("A", response.body().string());
+    try {
+      call1.execute();
+      fail("Should have timed out!");
+    } catch (SocketTimeoutException expected) {
+      assertEquals("timeout", expected.getMessage());
+    }
+
+    // Confirm that a subsequent request on the same connection is not impacted.
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("A", response2.body().string());
+
+    // Confirm that the connection was reused.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
   /**
@@ -377,27 +401,39 @@
    * time.
    */
   @Test public void readTimeoutOnSlowConnection() throws Exception {
-    char[] body = new char[2048]; // 2KiB to read.
-    Arrays.fill(body, 'y');
+    String body = TestUtil.repeat('y', 2048);
     server.enqueue(new MockResponse()
-        .setBody(new String(body))
+        .setBody(body)
         .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
+    server.enqueue(new MockResponse()
+        .setBody(body));
 
     client = client.newBuilder()
         .readTimeout(500, MILLISECONDS) // Half a second to read something.
         .build();
 
-    Call call = client.newCall(new Request.Builder()
+    // Make a call expecting a timeout reading the response body.
+    Call call1 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
-    Response response = call.execute();
-
+    Response response1 = call1.execute();
     try {
-      response.body().string();
+      response1.body().string();
       fail("Should have timed out!");
     } catch (SocketTimeoutException expected) {
       assertEquals("timeout", expected.getMessage());
     }
+
+    // Confirm that a subsequent request on the same connection is not impacted.
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(body, response2.body().string());
+
+    // Confirm that the connection was reused.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
   @Test public void connectionTimeout() throws Exception {
@@ -429,6 +465,10 @@
       fail();
     } catch (IOException expected) {
     }
+
+    // Confirm that the connection was reused.
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
   @Test public void responsesAreCached() throws IOException {
@@ -760,6 +800,70 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     assertEquals("bar", pushedRequest.getHeader("foo"));
   }
 
+  @Test public void noDataFramesSentWithNullRequestBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    SocketRecorder socketRecorder = new SocketRecorder();
+    client = client.newBuilder()
+        .sslSocketFactory(socketRecorder.sslSocketFactory(sslClient.socketFactory),
+            sslClient.trustManager)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .method("DELETE", null)
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    // Replay the bytes written by the client to confirm no data frames were sent.
+    SocketRecorder.RecordedSocket recordedSocket = socketRecorder.takeSocket();
+    Buffer buffer = new Buffer();
+    buffer.write(recordedSocket.bytesWritten());
+
+    RecordingHandler handler = new RecordingHandler();
+    Http2Reader reader = new Http2Reader(buffer, false);
+    reader.readConnectionPreface(null);
+    while (reader.nextFrame(false, handler)) {
+    }
+
+    assertEquals(1, handler.headerFrameCount);
+    assertTrue(handler.dataFrames.isEmpty());
+  }
+
+  @Test public void emptyDataFrameSentWithEmptyBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    SocketRecorder socketRecorder = new SocketRecorder();
+    client = client.newBuilder()
+        .sslSocketFactory(socketRecorder.sslSocketFactory(sslClient.socketFactory),
+            sslClient.trustManager)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .method("DELETE", Util.EMPTY_REQUEST)
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    // Replay the bytes written by the client to confirm an empty data frame was sent.
+    SocketRecorder.RecordedSocket recordedSocket = socketRecorder.takeSocket();
+    Buffer buffer = new Buffer();
+    buffer.write(recordedSocket.bytesWritten());
+
+    RecordingHandler handler = new RecordingHandler();
+    Http2Reader reader = new Http2Reader(buffer, false);
+    reader.readConnectionPreface(null);
+    while (reader.nextFrame(false, handler)) {
+    }
+
+    assertEquals(1, handler.headerFrameCount);
+    assertEquals(Collections.singletonList(0), handler.dataFrames);
+  }
+
   /**
    * Push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests and
    * confirm that the third concurrent request prepared a new connection.
@@ -874,6 +978,121 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     assertEquals(0, server.takeRequest().getSequenceNumber());
   }
 
+  /**
+   * We don't know if the connection will support HTTP/2 until after we've connected. When multiple
+   * connections are requested concurrently OkHttp will pessimistically connect multiple times, then
+   * close any unnecessary connections. This test confirms that behavior works as intended.
+   *
+   * <p>This test uses proxy tunnels to get a hook while a connection is being established.
+   */
+  @Test public void concurrentHttp2ConnectionsDeduplicated() throws Exception {
+    server.useHttps(sslClient.socketFactory, true);
+
+    // Force a fresh connection pool for the test.
+    client.connectionPool().evictAll();
+
+    final QueueDispatcher queueDispatcher = new QueueDispatcher();
+    queueDispatcher.enqueueResponse(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    queueDispatcher.enqueueResponse(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    queueDispatcher.enqueueResponse(new MockResponse()
+        .setBody("call2 response"));
+    queueDispatcher.enqueueResponse(new MockResponse()
+        .setBody("call1 response"));
+
+    // We use a re-entrant dispatcher to initiate one HTTPS connection while the other is in flight.
+    server.setDispatcher(new Dispatcher() {
+      int requestCount;
+
+      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        MockResponse result = queueDispatcher.dispatch(request);
+
+        requestCount++;
+        if (requestCount == 1) {
+          // Before handling call1's CONNECT we do all of call2. This part re-entrant!
+          try {
+            Call call2 = client.newCall(new Request.Builder()
+                .url("https://android.com/call2")
+                .build());
+            Response response2 = call2.execute();
+            assertEquals("call2 response", response2.body().string());
+          } catch (IOException e) {
+            throw new RuntimeException(e);
+          }
+        }
+
+        return result;
+      }
+
+      @Override public MockResponse peek() {
+        return queueDispatcher.peek();
+      }
+
+      @Override public void shutdown() {
+        queueDispatcher.shutdown();
+      }
+    });
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url("https://android.com/call1")
+        .build());
+    Response response2 = call1.execute();
+    assertEquals("call1 response", response2.body().string());
+
+    RecordedRequest call1Connect = server.takeRequest();
+    assertEquals("CONNECT", call1Connect.getMethod());
+    assertEquals(0, call1Connect.getSequenceNumber());
+
+    RecordedRequest call2Connect = server.takeRequest();
+    assertEquals("CONNECT", call2Connect.getMethod());
+    assertEquals(0, call2Connect.getSequenceNumber());
+
+    RecordedRequest call2Get = server.takeRequest();
+    assertEquals("GET", call2Get.getMethod());
+    assertEquals("/call2", call2Get.getPath());
+    assertEquals(0, call2Get.getSequenceNumber());
+
+    RecordedRequest call1Get = server.takeRequest();
+    assertEquals("GET", call1Get.getMethod());
+    assertEquals("/call1", call1Get.getPath());
+    assertEquals(1, call1Get.getSequenceNumber());
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** https://github.com/square/okhttp/issues/3103 */
+  @Test public void domainFronting() throws Exception {
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            Request request = chain.request().newBuilder()
+                .header("Host", "privateobject.com")
+                .build();
+            return chain.proceed(request);
+          }
+        })
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("privateobject.com", recordedRequest.getHeader(":authority"));
+  }
+
   public Buffer gzip(String bytes) throws IOException {
     Buffer bytesOut = new Buffer();
     BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
@@ -904,4 +1123,28 @@ public AsyncRequest(String path, CountDownLatch countDownLatch) {
       }
     }
   }
+
+  static final class RecordingHandler extends BaseTestHandler {
+    int headerFrameCount;
+    final List<Integer> dataFrames = new ArrayList<>();
+
+    @Override public void settings(boolean clearPrevious, Settings settings) {
+    }
+
+    @Override public void ackSettings() {
+    }
+
+    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
+    }
+
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
+        throws IOException {
+      dataFrames.add(length);
+    }
+
+    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
+        List<Header> headerBlock) {
+      headerFrameCount++;
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java b/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
index 40aca93adb..bc0263d830 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
@@ -90,6 +90,7 @@ public void setFaultyRename(File file, boolean faulty) {
   }
 
   @Override public void deleteContents(File directory) throws IOException {
+    if (deleteFaults.contains(directory)) throw new IOException("boom!");
     delegate.deleteContents(directory);
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
index 3de1adba1d..2ec0d6494d 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
@@ -16,6 +16,7 @@
 package okhttp3.internal.tls;
 
 import java.io.IOException;
+import java.net.SocketException;
 import java.security.GeneralSecurityException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocket;
@@ -162,6 +163,8 @@ public void setUp() throws GeneralSecurityException {
       call.execute();
       fail();
     } catch (SSLHandshakeException expected) {
+    } catch (SocketException expected) {
+      // JDK 9
     }
   }
 
@@ -183,6 +186,8 @@ public void setUp() throws GeneralSecurityException {
       call.execute();
       fail();
     } catch (SSLHandshakeException expected) {
+    } catch (SocketException expected) {
+      // JDK 9
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
index 3463690f7b..6b0c4fe72b 100644
--- a/okhttp/src/main/java/okhttp3/Authenticator.java
+++ b/okhttp/src/main/java/okhttp3/Authenticator.java
@@ -23,10 +23,18 @@
  * an authorization header, or they may refuse the challenge by returning null. In this case the
  * unauthenticated response will be returned to the caller that triggered it.
  *
+ * <p>Implementations should check if the initial request already included an attempt to
+ * authenticate. If so it is likely that further attempts will not be useful and the authenticator
+ * should give up.
+ *
  * <p>When authentication is requested by an origin server, the response code is 401 and the
  * implementation should respond with a new request that sets the "Authorization" header.
  * <pre>   {@code
  *
+ *    if (response.request().header("Authorization") != null) {
+ *      return null; // Give up, we've already failed to authenticate.
+ *    }
+ *
  *    String credential = Credentials.basic(...)
  *    return response.request().newBuilder()
  *        .header("Authorization", credential)
@@ -37,6 +45,10 @@
  * implementation should respond with a new request that sets the "Proxy-Authorization" header.
  * <pre>   {@code
  *
+ *    if (response.request().header("Proxy-Authorization") != null) {
+ *      return null; // Give up, we've already failed to authenticate.
+ *    }
+ *
  *    String credential = Credentials.basic(...)
  *    return response.request().newBuilder()
  *        .header("Proxy-Authorization", credential)
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index fccf857c13..5b4669ad21 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -29,8 +29,21 @@
    * Invokes the request immediately, and blocks until the response can be processed or is in
    * error.
    *
+   * <p>To avoid leaking resources callers should close the {@link Response} which in turn will
+   * close the underlying {@link ResponseBody}.
+   *
+   * <pre>@{code
+   *
+   *   // ensure the response (and underlying response body) is closed
+   *   try (Response response = client.newCall(request).execute()) {
+   *     ...
+   *   }
+   *
+   * }</pre>
+   *
    * <p>The caller may read the response body with the response's {@link Response#body} method. To
-   * avoid leaking resources callers must {@linkplain ResponseBody close the response body}.
+   * avoid leaking resources callers must {@linkplain ResponseBody close the response body} or the
+   * Response.
    *
    * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
    * not necessarily indicate application-layer success: {@code response} may still indicate an
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index dcbc0b441e..a589e3ad1d 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -17,6 +17,7 @@
 package okhttp3;
 
 import java.lang.ref.Reference;
+import java.net.Socket;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Deque;
@@ -117,9 +118,7 @@ public synchronized int connectionCount() {
   RealConnection get(Address address, StreamAllocation streamAllocation) {
     assert (Thread.holdsLock(this));
     for (RealConnection connection : connections) {
-      if (connection.allocations.size() < connection.allocationLimit
-          && address.equals(connection.route().address)
-          && !connection.noNewStreams) {
+      if (connection.isEligible(address)) {
         streamAllocation.acquire(connection);
         return connection;
       }
@@ -127,6 +126,22 @@ RealConnection get(Address address, StreamAllocation streamAllocation) {
     return null;
   }
 
+  /**
+   * Replaces the connection held by {@code streamAllocation} with a shared connection if possible.
+   * This recovers when multiple multiplexed connections are created concurrently.
+   */
+  Socket deduplicate(Address address, StreamAllocation streamAllocation) {
+    assert (Thread.holdsLock(this));
+    for (RealConnection connection : connections) {
+      if (connection.isEligible(address)
+          && connection.isMultiplexed()
+          && connection != streamAllocation.connection()) {
+        return streamAllocation.releaseAndAcquire(connection);
+      }
+    }
+    return null;
+  }
+
   void put(RealConnection connection) {
     assert (Thread.holdsLock(this));
     if (!cleanupRunning) {
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
index 066c6e1471..5b760b5191 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -30,6 +30,7 @@
 import static okhttp3.internal.Util.UTC;
 import static okhttp3.internal.Util.delimiterOffset;
 import static okhttp3.internal.Util.domainToAscii;
+import static okhttp3.internal.Util.indexOfControlOrNonAscii;
 import static okhttp3.internal.Util.trimSubstring;
 import static okhttp3.internal.Util.verifyAsIpAddress;
 
@@ -227,9 +228,10 @@ static Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
     if (pairEqualsSign == cookiePairEnd) return null;
 
     String cookieName = trimSubstring(setCookie, pos, pairEqualsSign);
-    if (cookieName.isEmpty()) return null;
+    if (cookieName.isEmpty() || indexOfControlOrNonAscii(cookieName) != -1) return null;
 
     String cookieValue = trimSubstring(setCookie, pairEqualsSign + 1, cookiePairEnd);
+    if (indexOfControlOrNonAscii(cookieValue) != -1) return null;
 
     long expiresAt = HttpDate.MAX_DATE;
     long deltaSeconds = -1L;
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index 5bdacfbd45..fb007a0a19 100644
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -316,7 +316,7 @@ private void checkNameAndValue(String name, String value) {
       if (value == null) throw new NullPointerException("value == null");
       for (int i = 0, length = value.length(); i < length; i++) {
         char c = value.charAt(i);
-        if ((c <= '\u001f' && c != '\u0009' /* htab */) || c >= '\u007f') {
+        if ((c <= '\u001f' && c != '\t') || c >= '\u007f') {
           throw new IllegalArgumentException(Util.format(
               "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
         }
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index d55351e841..e9a636d179 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -18,6 +18,7 @@
 import java.net.MalformedURLException;
 import java.net.Proxy;
 import java.net.ProxySelector;
+import java.net.Socket;
 import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
 import java.security.KeyStore;
@@ -148,6 +149,11 @@
         return pool.get(address, streamAllocation);
       }
 
+      @Override public Socket deduplicate(
+          ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
+        return pool.deduplicate(address, streamAllocation);
+      }
+
       @Override public void put(ConnectionPool pool, RealConnection connection) {
         pool.put(connection);
       }
@@ -156,6 +162,10 @@
         return connectionPool.routeDatabase;
       }
 
+      @Override public int code(Response.Builder responseBuilder) {
+        return responseBuilder.code;
+      }
+
       @Override
       public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
         tlsConfiguration.apply(sslSocket, isFallback);
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index 2610a44516..a72f71e4d4 100644
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -16,6 +16,7 @@
 package okhttp3.internal;
 
 import java.net.MalformedURLException;
+import java.net.Socket;
 import java.net.UnknownHostException;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Address;
@@ -26,6 +27,7 @@
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
+import okhttp3.Response;
 import okhttp3.internal.cache.InternalCache;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
@@ -53,12 +55,17 @@ public static void initializeInstanceForTests() {
   public abstract RealConnection get(
       ConnectionPool pool, Address address, StreamAllocation streamAllocation);
 
+  public abstract Socket deduplicate(
+      ConnectionPool pool, Address address, StreamAllocation streamAllocation);
+
   public abstract void put(ConnectionPool pool, RealConnection connection);
 
   public abstract boolean connectionBecameIdle(ConnectionPool pool, RealConnection connection);
 
   public abstract RouteDatabase routeDatabase(ConnectionPool connectionPool);
 
+  public abstract int code(Response.Builder responseBuilder);
+
   public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
       boolean isFallback);
 
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 28c0b79388..5a88c88998 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -383,6 +383,21 @@ private static boolean containsInvalidHostnameAsciiCodes(String hostnameAscii) {
     return false;
   }
 
+  /**
+   * Returns the index of the first character in {@code input} that is either a control character
+   * (like {@code \u0000 or \n}) or a non-ASCII character. Returns -1 if {@code input} has no such
+   * characters.
+   */
+  public static int indexOfControlOrNonAscii(String input) {
+    for (int i = 0, length = input.length(); i < length; i++) {
+      char c = input.charAt(i);
+      if (c <= '\u001f' || c >= '\u007f') {
+        return i;
+      }
+    }
+    return -1;
+  }
+
   /** Returns true if {@code host} is not a host name and might be an IP address. */
   public static boolean verifyAsIpAddress(String host) {
     return VERIFY_AS_IP_ADDRESS.matcher(host).matches();
@@ -416,11 +431,4 @@ public static Charset bomAwareCharset(BufferedSource source, Charset charset) th
     }
     return charset;
   }
-
-  /** Re-throws {@code t} if it is a fatal exception which should not be handled. */
-  public static void throwIfFatal(Throwable t) {
-    if (t instanceof VirtualMachineError) throw (VirtualMachineError) t;
-    if (t instanceof ThreadDeath) throw (ThreadDeath) t;
-    if (t instanceof LinkageError) throw (LinkageError) t;
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index 547781d26f..6ed7806c45 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -22,6 +22,7 @@
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.Socket;
+import java.net.SocketException;
 import java.net.SocketTimeoutException;
 import java.net.UnknownServiceException;
 import java.security.cert.X509Certificate;
@@ -34,22 +35,27 @@
 import okhttp3.Address;
 import okhttp3.CertificatePinner;
 import okhttp3.Connection;
+import okhttp3.ConnectionPool;
 import okhttp3.ConnectionSpec;
 import okhttp3.Handshake;
 import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.Route;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
+import okhttp3.internal.http.HttpCodec;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http1.Http1Codec;
 import okhttp3.internal.http2.ErrorCode;
+import okhttp3.internal.http2.Http2Codec;
 import okhttp3.internal.http2.Http2Connection;
 import okhttp3.internal.http2.Http2Stream;
 import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.OkHostnameVerifier;
+import okhttp3.internal.ws.RealWebSocket;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.Okio;
@@ -61,8 +67,11 @@
 import static okhttp3.internal.Util.closeQuietly;
 
 public final class RealConnection extends Http2Connection.Listener implements Connection {
+  private final ConnectionPool connectionPool;
   private final Route route;
 
+  // The fields below are initialized by connect() and never reassigned.
+
   /** The low-level TCP socket. */
   private Socket rawSocket;
 
@@ -70,27 +79,51 @@
    * The application layer socket. Either an {@link SSLSocket} layered over {@link #rawSocket}, or
    * {@link #rawSocket} itself if this connection does not use SSL.
    */
-  public Socket socket;
+  private Socket socket;
   private Handshake handshake;
   private Protocol protocol;
-  public volatile Http2Connection http2Connection;
+  private Http2Connection http2Connection;
+  private BufferedSource source;
+  private BufferedSink sink;
+
+  // The fields below track connection state and are guarded by connectionPool.
+
+  /** If true, no new streams can be created on this connection. Once true this is always true. */
+  public boolean noNewStreams;
+
   public int successCount;
-  public BufferedSource source;
-  public BufferedSink sink;
-  public int allocationLimit;
+
+  /**
+   * The maximum number of concurrent streams that can be carried by this connection. If {@code
+   * allocations.size() < allocationLimit} then new streams can be created on this connection.
+   */
+  public int allocationLimit = 1;
+
+  /** Current streams carried by this connection. */
   public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();
-  public boolean noNewStreams;
+
+  /** Nanotime timestamp when {@code allocations.size()} reached zero. */
   public long idleAtNanos = Long.MAX_VALUE;
 
-  public RealConnection(Route route) {
+  public RealConnection(ConnectionPool connectionPool, Route route) {
+    this.connectionPool = connectionPool;
     this.route = route;
   }
 
-  public void connect(int connectTimeout, int readTimeout, int writeTimeout,
-      List<ConnectionSpec> connectionSpecs, boolean connectionRetryEnabled) {
+  public static RealConnection testConnection(
+      ConnectionPool connectionPool, Route route, Socket socket, long idleAtNanos) {
+    RealConnection result = new RealConnection(connectionPool, route);
+    result.socket = socket;
+    result.idleAtNanos = idleAtNanos;
+    return result;
+  }
+
+  public void connect(
+      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {
     if (protocol != null) throw new IllegalStateException("already connected");
 
     RouteException routeException = null;
+    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();
     ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
 
     if (route.address().sslSocketFactory() == null) {
@@ -105,14 +138,15 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
       }
     }
 
-    while (protocol == null) {
+    while (true) {
       try {
         if (route.requiresTunnel()) {
-          buildTunneledConnection(connectTimeout, readTimeout, writeTimeout,
-              connectionSpecSelector);
+          connectTunnel(connectTimeout, readTimeout, writeTimeout);
         } else {
-          buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
+          connectSocket(connectTimeout, readTimeout);
         }
+        establishProtocol(connectionSpecSelector);
+        break;
       } catch (IOException e) {
         closeQuietly(socket);
         closeQuietly(rawSocket);
@@ -122,6 +156,7 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
         sink = null;
         handshake = null;
         protocol = null;
+        http2Connection = null;
 
         if (routeException == null) {
           routeException = new RouteException(e);
@@ -134,14 +169,20 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
         }
       }
     }
+
+    if (http2Connection != null) {
+      synchronized (connectionPool) {
+        allocationLimit = http2Connection.maxConcurrentStreams();
+      }
+    }
   }
 
   /**
    * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
    * proxy server can issue an auth challenge and then close the connection.
    */
-  private void buildTunneledConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+  private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout)
+      throws IOException {
     Request tunnelRequest = createTunnelRequest();
     HttpUrl url = tunnelRequest.url();
     int attemptedConnections = 0;
@@ -163,17 +204,9 @@ private void buildTunneledConnection(int connectTimeout, int readTimeout, int wr
       sink = null;
       source = null;
     }
-
-    establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);
   }
 
   /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
-  private void buildConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      ConnectionSpecSelector connectionSpecSelector) throws IOException {
-    connectSocket(connectTimeout, readTimeout);
-    establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);
-  }
-
   private void connectSocket(int connectTimeout, int readTimeout) throws IOException {
     Proxy proxy = route.proxy();
     Address address = route.address();
@@ -194,34 +227,26 @@ private void connectSocket(int connectTimeout, int readTimeout) throws IOExcepti
     sink = Okio.buffer(Okio.sink(rawSocket));
   }
 
-  private void establishProtocol(int readTimeout, int writeTimeout,
-      ConnectionSpecSelector connectionSpecSelector) throws IOException {
-    if (route.address().sslSocketFactory() != null) {
-      connectTls(readTimeout, writeTimeout, connectionSpecSelector);
-    } else {
+  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector) throws IOException {
+    if (route.address().sslSocketFactory() == null) {
       protocol = Protocol.HTTP_1_1;
       socket = rawSocket;
+      return;
     }
 
+    connectTls(connectionSpecSelector);
+
     if (protocol == Protocol.HTTP_2) {
       socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.
-
-      Http2Connection http2Connection = new Http2Connection.Builder(true)
+      http2Connection = new Http2Connection.Builder(true)
           .socket(socket, route.address().url().host(), source, sink)
           .listener(this)
           .build();
       http2Connection.start();
-
-      // Only assign the framed connection once the preface has been sent successfully.
-      this.allocationLimit = http2Connection.maxConcurrentStreams();
-      this.http2Connection = http2Connection;
-    } else {
-      this.allocationLimit = 1;
     }
   }
 
-  private void connectTls(int readTimeout, int writeTimeout,
-      ConnectionSpecSelector connectionSpecSelector) throws IOException {
+  private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException {
     Address address = route.address();
     SSLSocketFactory sslSocketFactory = address.sslSocketFactory();
     boolean success = false;
@@ -294,7 +319,9 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
       sink.timeout().timeout(writeTimeout, MILLISECONDS);
       tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
       tunnelConnection.finishRequest();
-      Response response = tunnelConnection.readResponse().request(tunnelRequest).build();
+      Response response = tunnelConnection.readResponseHeaders(false)
+          .request(tunnelRequest)
+          .build();
       // The response body from a CONNECT should be empty, but if it is not then we should consume
       // it before proceeding.
       long contentLength = HttpHeaders.contentLength(response);
@@ -341,11 +368,38 @@ private Request createTunnelRequest() {
     return new Request.Builder()
         .url(route.address().url())
         .header("Host", Util.hostHeader(route.address().url(), true))
-        .header("Proxy-Connection", "Keep-Alive")
-        .header("User-Agent", Version.userAgent()) // For HTTP/1.0 proxies like Squid.
+        .header("Proxy-Connection", "Keep-Alive") // For HTTP/1.0 proxies like Squid.
+        .header("User-Agent", Version.userAgent())
         .build();
   }
 
+  /** Returns true if this connection can carry a stream allocation to {@code address}. */
+  public boolean isEligible(Address address) {
+    return allocations.size() < allocationLimit
+        && address.equals(route().address())
+        && !noNewStreams;
+  }
+
+  public HttpCodec newCodec(
+      OkHttpClient client, StreamAllocation streamAllocation) throws SocketException {
+    if (http2Connection != null) {
+      return new Http2Codec(client, streamAllocation, http2Connection);
+    } else {
+      socket.setSoTimeout(client.readTimeoutMillis());
+      source.timeout().timeout(client.readTimeoutMillis(), MILLISECONDS);
+      sink.timeout().timeout(client.writeTimeoutMillis(), MILLISECONDS);
+      return new Http1Codec(client, streamAllocation, source, sink);
+    }
+  }
+
+  public RealWebSocket.Streams newWebSocketStreams(final StreamAllocation streamAllocation) {
+    return new RealWebSocket.Streams(true, source, sink) {
+      @Override public void close() throws IOException {
+        streamAllocation.streamFinished(true, streamAllocation.codec());
+      }
+    };
+  }
+
   @Override public Route route() {
     return route;
   }
@@ -398,7 +452,9 @@ public boolean isHealthy(boolean doExtensiveChecks) {
 
   /** When settings are received, adjust the allocation limit. */
   @Override public void onSettings(Http2Connection connection) {
-    allocationLimit = connection.maxConcurrentStreams();
+    synchronized (connectionPool) {
+      allocationLimit = connection.maxConcurrentStreams();
+    }
   }
 
   @Override public Handshake handshake() {
@@ -414,11 +470,7 @@ public boolean isMultiplexed() {
   }
 
   @Override public Protocol protocol() {
-    if (http2Connection == null) {
-      return protocol != null ? protocol : Protocol.HTTP_1_1;
-    } else {
-      return Protocol.HTTP_2;
-    }
+    return protocol;
   }
 
   @Override public String toString() {
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index a2213dfc9b..fbe83067ab 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
+import java.net.Socket;
 import okhttp3.Address;
 import okhttp3.ConnectionPool;
 import okhttp3.OkHttpClient;
@@ -25,13 +26,11 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpCodec;
-import okhttp3.internal.http1.Http1Codec;
 import okhttp3.internal.http2.ConnectionShutdownException;
 import okhttp3.internal.http2.ErrorCode;
-import okhttp3.internal.http2.Http2Codec;
 import okhttp3.internal.http2.StreamResetException;
 
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.closeQuietly;
 
 /**
  * This class coordinates the relationship between three entities:
@@ -100,17 +99,7 @@ public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks)
     try {
       RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
           writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
-
-      HttpCodec resultCodec;
-      if (resultConnection.http2Connection != null) {
-        resultCodec = new Http2Codec(client, this, resultConnection.http2Connection);
-      } else {
-        resultConnection.socket().setSoTimeout(readTimeout);
-        resultConnection.source.timeout().timeout(readTimeout, MILLISECONDS);
-        resultConnection.sink.timeout().timeout(writeTimeout, MILLISECONDS);
-        resultCodec = new Http1Codec(
-            client, this, resultConnection.source, resultConnection.sink);
-      }
+      HttpCodec resultCodec = resultConnection.newCodec(client, this);
 
       synchronized (connectionPool) {
         codec = resultCodec;
@@ -162,45 +151,60 @@ private RealConnection findConnection(int connectTimeout, int readTimeout, int w
       if (codec != null) throw new IllegalStateException("codec != null");
       if (canceled) throw new IOException("Canceled");
 
+      // Attempt to use an already-allocated connection.
       RealConnection allocatedConnection = this.connection;
       if (allocatedConnection != null && !allocatedConnection.noNewStreams) {
         return allocatedConnection;
       }
 
       // Attempt to get a connection from the pool.
-      RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);
-      if (pooledConnection != null) {
-        this.connection = pooledConnection;
-        return pooledConnection;
+      Internal.instance.get(connectionPool, address, this);
+      if (connection != null) {
+        return connection;
       }
 
       selectedRoute = route;
     }
 
+    // If we need a route, make one. This is a blocking operation.
     if (selectedRoute == null) {
       selectedRoute = routeSelector.next();
-      synchronized (connectionPool) {
-        route = selectedRoute;
-        refusedStreamCount = 0;
-      }
     }
-    RealConnection newConnection = new RealConnection(selectedRoute);
 
+    // Create a connection and assign it to this allocation immediately. This makes it possible for
+    // an asynchronous cancel() to interrupt the handshake we're about to do.
+    RealConnection result;
     synchronized (connectionPool) {
-      acquire(newConnection);
-      Internal.instance.put(connectionPool, newConnection);
-      this.connection = newConnection;
+      route = selectedRoute;
+      refusedStreamCount = 0;
+      result = new RealConnection(connectionPool, selectedRoute);
+      acquire(result);
       if (canceled) throw new IOException("Canceled");
     }
 
-    newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),
-        connectionRetryEnabled);
-    routeDatabase().connected(newConnection.route());
+    // Do TCP + TLS handshakes. This is a blocking operation.
+    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);
+    routeDatabase().connected(result.route());
+
+    Socket socket = null;
+    synchronized (connectionPool) {
+      // Pool the connection.
+      Internal.instance.put(connectionPool, result);
+
+      // If another multiplexed connection to the same address was created concurrently, then
+      // release this connection and acquire that one.
+      if (result.isMultiplexed()) {
+        socket = Internal.instance.deduplicate(connectionPool, address, this);
+        result = connection;
+      }
+    }
+    closeQuietly(socket);
 
-    return newConnection;
+    return result;
   }
 
   public void streamFinished(boolean noNewStreams, HttpCodec codec) {
+    Socket socket;
     synchronized (connectionPool) {
       if (codec == null || codec != this.codec) {
         throw new IllegalStateException("expected " + this.codec + " but was " + codec);
@@ -208,8 +212,9 @@ public void streamFinished(boolean noNewStreams, HttpCodec codec) {
       if (!noNewStreams) {
         connection.successCount++;
       }
+      socket = deallocate(noNewStreams, false, true);
     }
-    deallocate(noNewStreams, false, true);
+    closeQuietly(socket);
   }
 
   public HttpCodec codec() {
@@ -227,46 +232,55 @@ public synchronized RealConnection connection() {
   }
 
   public void release() {
-    deallocate(false, true, false);
+    Socket socket;
+    synchronized (connectionPool) {
+      socket = deallocate(false, true, false);
+    }
+    closeQuietly(socket);
   }
 
   /** Forbid new streams from being created on the connection that hosts this allocation. */
   public void noNewStreams() {
-    deallocate(true, false, false);
+    Socket socket;
+    synchronized (connectionPool) {
+      socket = deallocate(true, false, false);
+    }
+    closeQuietly(socket);
   }
 
   /**
    * Releases resources held by this allocation. If sufficient resources are allocated, the
-   * connection will be detached or closed.
+   * connection will be detached or closed. Callers must be synchronized on the connection pool.
+   *
+   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
+   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
    */
-  private void deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
-    RealConnection connectionToClose = null;
-    synchronized (connectionPool) {
-      if (streamFinished) {
-        this.codec = null;
-      }
-      if (released) {
-        this.released = true;
+  private Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
+    assert (Thread.holdsLock(connectionPool));
+
+    if (streamFinished) {
+      this.codec = null;
+    }
+    if (released) {
+      this.released = true;
+    }
+    Socket socket = null;
+    if (connection != null) {
+      if (noNewStreams) {
+        connection.noNewStreams = true;
       }
-      if (connection != null) {
-        if (noNewStreams) {
-          connection.noNewStreams = true;
-        }
-        if (this.codec == null && (this.released || connection.noNewStreams)) {
-          release(connection);
-          if (connection.allocations.isEmpty()) {
-            connection.idleAtNanos = System.nanoTime();
-            if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
-              connectionToClose = connection;
-            }
+      if (this.codec == null && (this.released || connection.noNewStreams)) {
+        release(connection);
+        if (connection.allocations.isEmpty()) {
+          connection.idleAtNanos = System.nanoTime();
+          if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
+            socket = connection.socket();
           }
-          connection = null;
         }
+        connection = null;
       }
     }
-    if (connectionToClose != null) {
-      Util.closeQuietly(connectionToClose.socket());
-    }
+    return socket;
   }
 
   public void cancel() {
@@ -285,6 +299,7 @@ public void cancel() {
   }
 
   public void streamFailed(IOException e) {
+    Socket socket;
     boolean noNewStreams = false;
 
     synchronized (connectionPool) {
@@ -299,8 +314,8 @@ public void streamFailed(IOException e) {
           noNewStreams = true;
           route = null;
         }
-      } else if (connection != null && !connection.isMultiplexed()
-          || e instanceof ConnectionShutdownException) {
+      } else if (connection != null
+          && (!connection.isMultiplexed() || e instanceof ConnectionShutdownException)) {
         noNewStreams = true;
 
         // If this route hasn't completed a call, avoid it for new connections.
@@ -311,9 +326,10 @@ public void streamFailed(IOException e) {
           route = null;
         }
       }
+      socket = deallocate(noNewStreams, false, true);
     }
 
-    deallocate(noNewStreams, false, true);
+    closeQuietly(socket);
   }
 
   /**
@@ -322,6 +338,9 @@ public void streamFailed(IOException e) {
    */
   public void acquire(RealConnection connection) {
     assert (Thread.holdsLock(connectionPool));
+    if (this.connection != null) throw new IllegalStateException();
+
+    this.connection = connection;
     connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
   }
 
@@ -337,6 +356,29 @@ private void release(RealConnection connection) {
     throw new IllegalStateException();
   }
 
+  /**
+   * Release the connection held by this connection and acquire {@code newConnection} instead. It is
+   * only safe to call this if the held connection is newly connected but duplicated by {@code
+   * newConnection}. Typically this occurs when concurrently connecting to an HTTP/2 webserver.
+   *
+   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
+   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
+   */
+  public Socket releaseAndAcquire(RealConnection newConnection) {
+    assert (Thread.holdsLock(connectionPool));
+    if (codec != null || connection.allocations.size() != 1) throw new IllegalStateException();
+
+    // Release the old connection.
+    Reference<StreamAllocation> onlyAllocation = connection.allocations.get(0);
+    Socket socket = deallocate(true, false, false);
+
+    // Acquire the new connection.
+    this.connection = newConnection;
+    newConnection.allocations.add(onlyAllocation);
+
+    return socket;
+  }
+
   public boolean hasMoreRoutes() {
     return route != null || routeSelector.hasNext();
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index 6adbc28b56..f7c0e5a561 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -42,16 +42,32 @@ public CallServerInterceptor(boolean forWebSocket) {
     long sentRequestMillis = System.currentTimeMillis();
     httpCodec.writeRequestHeaders(request);
 
+    Response.Builder responseBuilder = null;
     if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
-      Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());
-      BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
-      request.body().writeTo(bufferedRequestBody);
-      bufferedRequestBody.close();
+      // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
+      // Continue" response before transmitting the request body. If we don't get that, return what
+      // we did get (such as a 4xx response) without ever transmitting the request body.
+      if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
+        httpCodec.flushRequest();
+        responseBuilder = httpCodec.readResponseHeaders(true);
+      }
+
+      // Write the request body, unless an "Expect: 100-continue" expectation failed.
+      if (responseBuilder == null) {
+        Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());
+        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+        request.body().writeTo(bufferedRequestBody);
+        bufferedRequestBody.close();
+      }
     }
 
     httpCodec.finishRequest();
 
-    Response response = httpCodec.readResponseHeaders()
+    if (responseBuilder == null) {
+      responseBuilder = httpCodec.readResponseHeaders(false);
+    }
+
+    Response response = responseBuilder
         .request(request)
         .handshake(streamAllocation.connection().handshake())
         .sentRequestAtMillis(sentRequestMillis)
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
index b227399e91..ad9759acce 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
@@ -37,10 +37,18 @@
   void writeRequestHeaders(Request request) throws IOException;
 
   /** Flush the request to the underlying socket. */
+  void flushRequest() throws IOException;
+
+  /** Flush the request to the underlying socket and signal no more bytes will be transmitted. */
   void finishRequest() throws IOException;
 
-  /** Read and return response headers. */
-  Response.Builder readResponseHeaders() throws IOException;
+  /**
+   * Parses bytes of a response header from an HTTP transport.
+   *
+   * @param expectContinue true to return null if this is an intermediate response with a "100"
+   *     response code. Otherwise this method never returns null.
+   */
+  Response.Builder readResponseHeaders(boolean expectContinue) throws IOException;
 
   /** Returns a stream that reads the response body. */
   ResponseBody openResponseBody(Response response) throws IOException;
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index dc2dd1791e..625c173bf3 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -55,7 +55,7 @@
  *     <li>Open a sink to write the request body. Either {@linkplain #newFixedLengthSink
  *         fixed-length} or {@link #newChunkedSink chunked}.
  *     <li>Write to and then close that sink.
- *     <li>{@linkplain #readResponse Read response headers}.
+ *     <li>{@linkplain #readResponseHeaders Read response headers}.
  *     <li>Open a source to read the response body. Either {@linkplain #newFixedLengthSource
  *         fixed-length}, {@linkplain #newChunkedSource chunked} or {@linkplain
  *         #newUnknownLengthSource unknown length}.
@@ -128,10 +128,6 @@ public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, Buffer
     writeRequest(request.headers(), requestLine);
   }
 
-  @Override public Response.Builder readResponseHeaders() throws IOException {
-    return readResponse();
-  }
-
   @Override public ResponseBody openResponseBody(Response response) throws IOException {
     Source source = getTransferStream(response);
     return new RealResponseBody(response.headers(), Okio.buffer(source));
@@ -162,6 +158,10 @@ public boolean isClosed() {
     return state == STATE_CLOSED;
   }
 
+  @Override public void flushRequest() throws IOException {
+    sink.flush();
+  }
+
   @Override public void finishRequest() throws IOException {
     sink.flush();
   }
@@ -180,27 +180,26 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
     state = STATE_OPEN_REQUEST_BODY;
   }
 
-  /** Parses bytes of a response header from an HTTP transport. */
-  public Response.Builder readResponse() throws IOException {
+  @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
     if (state != STATE_OPEN_REQUEST_BODY && state != STATE_READ_RESPONSE_HEADERS) {
       throw new IllegalStateException("state: " + state);
     }
 
     try {
-      while (true) {
-        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
-
-        Response.Builder responseBuilder = new Response.Builder()
-            .protocol(statusLine.protocol)
-            .code(statusLine.code)
-            .message(statusLine.message)
-            .headers(readHeaders());
-
-        if (statusLine.code != HTTP_CONTINUE) {
-          state = STATE_OPEN_RESPONSE_BODY;
-          return responseBuilder;
-        }
+      StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+
+      Response.Builder responseBuilder = new Response.Builder()
+          .protocol(statusLine.protocol)
+          .code(statusLine.code)
+          .message(statusLine.message)
+          .headers(readHeaders());
+
+      if (expectContinue && statusLine.code == HTTP_CONTINUE) {
+        return null;
       }
+
+      state = STATE_OPEN_RESPONSE_BODY;
+      return responseBuilder;
     } catch (EOFException e) {
       // Provide more context if the server ends the stream before sending a response.
       IOException exception = new IOException("unexpected end of stream on " + streamAllocation);
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
index abd4b5ef3c..61680d565e 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -40,6 +40,7 @@
 import okio.Sink;
 import okio.Source;
 
+import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
 import static okhttp3.internal.http2.Header.RESPONSE_STATUS;
 import static okhttp3.internal.http2.Header.TARGET_AUTHORITY;
 import static okhttp3.internal.http2.Header.TARGET_METHOD;
@@ -107,12 +108,21 @@ public Http2Codec(
     stream.writeTimeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
   }
 
+  @Override public void flushRequest() throws IOException {
+    connection.flush();
+  }
+
   @Override public void finishRequest() throws IOException {
     stream.getSink().close();
   }
 
-  @Override public Response.Builder readResponseHeaders() throws IOException {
-    return readHttp2HeadersList(stream.getResponseHeaders());
+  @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
+    List<Header> headers = stream.takeResponseHeaders();
+    Response.Builder responseBuilder = readHttp2HeadersList(headers);
+    if (expectContinue && Internal.instance.code(responseBuilder) == HTTP_CONTINUE) {
+      return null;
+    }
+    return responseBuilder;
   }
 
   public static List<Header> http2HeadersList(Request request) {
@@ -120,7 +130,10 @@ public Http2Codec(
     List<Header> result = new ArrayList<>(headers.size() + 4);
     result.add(new Header(TARGET_METHOD, request.method()));
     result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
-    result.add(new Header(TARGET_AUTHORITY, Util.hostHeader(request.url(), false))); // Optional.
+    String host = request.header("Host");
+    if (host != null) {
+      result.add(new Header(TARGET_AUTHORITY, host)); // Optional.
+    }
     result.add(new Header(TARGET_SCHEME, request.url().scheme()));
 
     for (int i = 0, size = headers.size(); i < size; i++) {
@@ -135,22 +148,31 @@ public Http2Codec(
 
   /** Returns headers for a name value block containing an HTTP/2 response. */
   public static Response.Builder readHttp2HeadersList(List<Header> headerBlock) throws IOException {
-    String status = null;
-
+    StatusLine statusLine = null;
     Headers.Builder headersBuilder = new Headers.Builder();
     for (int i = 0, size = headerBlock.size(); i < size; i++) {
-      ByteString name = headerBlock.get(i).name;
+      Header header = headerBlock.get(i);
+
+      // If there were multiple header blocks they will be delimited by nulls. Discard existing
+      // header blocks if the existing header block is a '100 Continue' intermediate response.
+      if (header == null) {
+        if (statusLine != null && statusLine.code == HTTP_CONTINUE) {
+          statusLine = null;
+          headersBuilder = new Headers.Builder();
+        }
+        continue;
+      }
 
-      String value = headerBlock.get(i).value.utf8();
+      ByteString name = header.name;
+      String value = header.value.utf8();
       if (name.equals(RESPONSE_STATUS)) {
-        status = value;
+        statusLine = StatusLine.parse("HTTP/1.1 " + value);
       } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
         Internal.instance.addLenient(headersBuilder, name.utf8(), value);
       }
     }
-    if (status == null) throw new ProtocolException("Expected ':status' header not present");
+    if (statusLine == null) throw new ProtocolException("Expected ':status' header not present");
 
-    StatusLine statusLine = StatusLine.parse("HTTP/1.1 " + status);
     return new Response.Builder()
         .protocol(Protocol.HTTP_2)
         .code(statusLine.code)
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index d79c1b3b28..2548705eed 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -865,8 +865,8 @@ void pushResetLater(final int streamId, final ErrorCode errorCode) {
 
     /**
      * Handle a new stream from this connection's peer. Implementations should respond by either
-     * {@linkplain Http2Stream#reply replying to the stream} or {@linkplain Http2Stream#close
-     * closing it}. This response does not need to be synchronous.
+     * {@linkplain Http2Stream#sendResponseHeaders replying to the stream} or {@linkplain
+     * Http2Stream#close closing it}. This response does not need to be synchronous.
      */
     public abstract void onStream(Http2Stream stream) throws IOException;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
index 3d036860a2..8659fd6a01 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -51,12 +51,15 @@
   final int id;
   final Http2Connection connection;
 
-  /** Headers sent by the stream initiator. Immutable and non null. */
+  /** Request headers. Immutable and non null. */
   private final List<Header> requestHeaders;
 
-  /** Headers sent in the stream reply. Null if reply is either not sent or not sent yet. */
+  /** Response headers yet to be {@linkplain #takeResponseHeaders taken}. */
   private List<Header> responseHeaders;
 
+  /** True if response headers have been sent or received. */
+  private boolean hasResponseHeaders;
+
   private final FramedDataSource source;
   final FramedDataSink sink;
   final StreamTimeout readTimeout = new StreamTimeout();
@@ -106,7 +109,7 @@ public synchronized boolean isOpen() {
     }
     if ((source.finished || source.closed)
         && (sink.finished || sink.closed)
-        && responseHeaders != null) {
+        && hasResponseHeaders) {
       return false;
     }
     return true;
@@ -127,10 +130,14 @@ public Http2Connection getConnection() {
   }
 
   /**
-   * Returns the stream's response headers, blocking if necessary if they have not been received
-   * yet.
+   * Removes and returns the stream's received response headers, blocking if necessary until headers
+   * have been received. If the returned list contains multiple blocks of headers the blocks will be
+   * delimited by 'null'.
    */
-  public synchronized List<Header> getResponseHeaders() throws IOException {
+  public synchronized List<Header> takeResponseHeaders() throws IOException {
+    if (!isLocallyInitiated()) {
+      throw new IllegalStateException("servers cannot read response headers");
+    }
     readTimeout.enter();
     try {
       while (responseHeaders == null && errorCode == null) {
@@ -139,7 +146,11 @@ public Http2Connection getConnection() {
     } finally {
       readTimeout.exitAndThrowIfTimedOut();
     }
-    if (responseHeaders != null) return responseHeaders;
+    List<Header> result = responseHeaders;
+    if (result != null) {
+      responseHeaders = null;
+      return result;
+    }
     throw new StreamResetException(errorCode);
   }
 
@@ -157,17 +168,14 @@ public synchronized ErrorCode getErrorCode() {
    * @param out true to create an output stream that we can use to send data to the remote peer.
    * Corresponds to {@code FLAG_FIN}.
    */
-  public void reply(List<Header> responseHeaders, boolean out) throws IOException {
+  public void sendResponseHeaders(List<Header> responseHeaders, boolean out) throws IOException {
     assert (!Thread.holdsLock(Http2Stream.this));
+    if (responseHeaders == null) {
+      throw new NullPointerException("responseHeaders == null");
+    }
     boolean outFinished = false;
     synchronized (this) {
-      if (responseHeaders == null) {
-        throw new NullPointerException("responseHeaders == null");
-      }
-      if (this.responseHeaders != null) {
-        throw new IllegalStateException("reply already sent");
-      }
-      this.responseHeaders = responseHeaders;
+      this.hasResponseHeaders = true;
       if (!out) {
         this.sink.finished = true;
         outFinished = true;
@@ -196,12 +204,12 @@ public Source getSource() {
   /**
    * Returns a sink that can be used to write data to the peer.
    *
-   * @throws IllegalStateException if this stream was initiated by the peer and a {@link #reply} has
-   * not yet been sent.
+   * @throws IllegalStateException if this stream was initiated by the peer and a {@link
+   * #sendResponseHeaders} has not yet been sent.
    */
   public Sink getSink() {
     synchronized (this) {
-      if (responseHeaders == null && !isLocallyInitiated()) {
+      if (!hasResponseHeaders && !isLocallyInitiated()) {
         throw new IllegalStateException("reply before requesting the sink");
       }
     }
@@ -251,6 +259,7 @@ void receiveHeaders(List<Header> headers) {
     assert (!Thread.holdsLock(Http2Stream.this));
     boolean open = true;
     synchronized (this) {
+      hasResponseHeaders = true;
       if (responseHeaders == null) {
         responseHeaders = headers;
         open = isOpen();
@@ -258,6 +267,7 @@ void receiveHeaders(List<Header> headers) {
       } else {
         List<Header> newHeaders = new ArrayList<>();
         newHeaders.addAll(responseHeaders);
+        newHeaders.add(null); // Delimit separate blocks of headers with null.
         newHeaders.addAll(headers);
         this.responseHeaders = newHeaders;
       }
@@ -320,8 +330,7 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
       this.maxByteCount = maxByteCount;
     }
 
-    @Override public long read(Buffer sink, long byteCount)
-        throws IOException {
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
 
       long read;
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
index 9ac84f0e29..4be0381202 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -190,7 +190,7 @@ public void connect(OkHttpClient client) {
         // Promote the HTTP streams into web socket streams.
         StreamAllocation streamAllocation = Internal.instance.streamAllocation(call);
         streamAllocation.noNewStreams(); // Prevent connection pooling!
-        Streams streams = new ClientStreams(streamAllocation);
+        Streams streams = streamAllocation.connection().newWebSocketStreams(streamAllocation);
 
         // Process all web socket messages.
         try {
@@ -495,12 +495,15 @@ boolean writeOneFrame() throws IOException {
   }
 
   private final class PingRunnable implements Runnable {
+    PingRunnable() {
+    }
+
     @Override public void run() {
       writePingFrame();
     }
   }
 
-  private void writePingFrame() {
+  void writePingFrame() {
     WebSocketWriter writer;
     synchronized (this) {
       if (failed) return;
@@ -566,19 +569,6 @@ public Streams(boolean client, BufferedSource source, BufferedSink sink) {
     }
   }
 
-  static final class ClientStreams extends Streams {
-    private final StreamAllocation streamAllocation;
-
-    ClientStreams(StreamAllocation streamAllocation) {
-      super(true, streamAllocation.connection().source, streamAllocation.connection().sink);
-      this.streamAllocation = streamAllocation;
-    }
-
-    @Override public void close() {
-      streamAllocation.streamFinished(true, streamAllocation.codec());
-    }
-  }
-
   final class CancelRunnable implements Runnable {
     @Override public void run() {
       cancel();
diff --git a/pom.xml b/pom.xml
index bda83e1ade..3b2b33b774 100644
--- a/pom.xml
+++ b/pom.xml
@@ -44,7 +44,7 @@
     <!-- ALPN library targeted to Java 7 -->
     <alpn.jdk7.version>7.1.2.v20141202</alpn.jdk7.version>
     <android.version>4.1.1.4</android.version>
-    <animal.sniffer.version>1.11</animal.sniffer.version>
+    <animal.sniffer.version>1.15</animal.sniffer.version>
     <apache.http.version>4.2.2</apache.http.version>
     <bouncycastle.version>1.50</bouncycastle.version>
     <guava.version>16.0</guava.version>
@@ -498,6 +498,23 @@
         <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
       </properties>
     </profile>
+    <profile>
+      <id>alpn-when-jdk8_112</id>
+      <activation>
+        <jdk>1.8.0_112</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_121</id>
+      <activation>
+        <jdk>1.8.0_121</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
   </profiles>
 </project>
-
diff --git a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
index c0964fdf8a..0818961703 100644
--- a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
+++ b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
@@ -72,10 +72,15 @@ private void drainQueue() throws Exception {
         continue;
       }
 
+      Thread currentThread = Thread.currentThread();
+      String originalName = currentThread.getName();
+      currentThread.setName("Crawler " + url.toString());
       try {
         fetch(url);
       } catch (IOException e) {
         System.out.printf("XXX: %s %s%n", url, e);
+      } finally {
+        currentThread.setName(originalName);
       }
     }
   }
@@ -114,7 +119,8 @@ public void fetch(HttpUrl url) throws IOException {
     for (Element element : document.select("a[href]")) {
       String href = element.attr("href");
       HttpUrl link = response.request().url().resolve(href);
-      if (link != null) queue.add(link);
+      if (link == null) continue; // URL is either invalid or its scheme isn't http/https.
+      queue.add(link.newBuilder().fragment(null).build());
     }
   }
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
index 61eb27f2b1..4eb09d8f11 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java
@@ -30,6 +30,10 @@ public Authenticate() {
     client = new OkHttpClient.Builder()
         .authenticator(new Authenticator() {
           @Override public Request authenticate(Route route, Response response) throws IOException {
+            if (response.request().header("Authorization") != null) {
+              return null; // Give up, we've already attempted to authenticate.
+            }
+
             System.out.println("Authenticating for response: " + response);
             System.out.println("Challenges: " + response.challenges());
             String credential = Credentials.basic("jesse", "password1");
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
index 164e879079..befd80983c 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CheckHandshake.java
@@ -28,7 +28,8 @@
 public final class CheckHandshake {
   /** Rejects otherwise-trusted certificates. */
   private static final Interceptor CHECK_HANDSHAKE_INTERCEPTOR = new Interceptor() {
-    Set<String> blacklist = Collections.singleton("sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
+    Set<String> blacklist = Collections.singleton(
+        "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=");
 
     @Override public Response intercept(Chain chain) throws IOException {
       for (Certificate certificate : chain.connection().handshake().peerCertificates()) {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java b/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
new file mode 100644
index 0000000000..a3ea23cf39
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.security.GeneralSecurityException;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.CipherSuite;
+import okhttp3.ConnectionSpec;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class CustomCipherSuites {
+  private final OkHttpClient client;
+
+  public CustomCipherSuites() throws GeneralSecurityException {
+    // Configure cipher suites to demonstrate how to customize which cipher suites will be used for
+    // an OkHttp request. In order to be selected a cipher suite must be included in both OkHttp's
+    // connection spec and in the SSLSocket's enabled cipher suites array. Most applications should
+    // not customize the cipher suites list.
+    List<CipherSuite> customCipherSuites = Arrays.asList(
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384);
+    final ConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .cipherSuites(customCipherSuites.toArray(new CipherSuite[0]))
+        .build();
+
+    X509TrustManager trustManager = defaultTrustManager();
+    SSLSocketFactory sslSocketFactory = defaultSslSocketFactory(trustManager);
+    SSLSocketFactory customSslSocketFactory = new DelegatingSSLSocketFactory(sslSocketFactory) {
+      @Override protected SSLSocket configureSocket(SSLSocket socket) throws IOException {
+        socket.setEnabledCipherSuites(javaNames(spec.cipherSuites()));
+        return socket;
+      }
+    };
+
+    client = new OkHttpClient.Builder()
+        .connectionSpecs(Collections.singletonList(spec))
+        .sslSocketFactory(customSslSocketFactory, trustManager)
+        .build();
+  }
+
+  /**
+   * Returns the VM's default SSL socket factory, using {@code trustManager} for trusted root
+   * certificates.
+   */
+  private SSLSocketFactory defaultSslSocketFactory(X509TrustManager trustManager)
+      throws NoSuchAlgorithmException, KeyManagementException {
+    SSLContext sslContext = SSLContext.getInstance("TLS");
+    sslContext.init(null, new TrustManager[] { trustManager }, null);
+
+    return sslContext.getSocketFactory();
+  }
+
+  /** Returns a trust manager that trusts the VM's default certificate authorities. */
+  private X509TrustManager defaultTrustManager() throws GeneralSecurityException {
+    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    trustManagerFactory.init((KeyStore) null);
+    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+    if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+      throw new IllegalStateException("Unexpected default trust managers:"
+          + Arrays.toString(trustManagers));
+    }
+    return (X509TrustManager) trustManagers[0];
+  }
+
+  private String[] javaNames(List<CipherSuite> cipherSuites) {
+    String[] result = new String[cipherSuites.size()];
+    for (int i = 0; i < result.length; i++) {
+      result[i] = cipherSuites.get(i).javaName();
+    }
+    return result;
+  }
+
+  /**
+   * An SSL socket factory that forwards all calls to a delegate. Override {@link #configureSocket}
+   * to customize a created socket before it is returned.
+   */
+  static class DelegatingSSLSocketFactory extends SSLSocketFactory {
+    protected final SSLSocketFactory delegate;
+
+    public DelegatingSSLSocketFactory(SSLSocketFactory delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public String[] getDefaultCipherSuites() {
+      return delegate.getDefaultCipherSuites();
+    }
+
+    @Override public String[] getSupportedCipherSuites() {
+      return delegate.getSupportedCipherSuites();
+    }
+
+    @Override public Socket createSocket(
+        Socket socket, String host, int port, boolean autoClose) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(socket, host, port, autoClose));
+    }
+
+    @Override public Socket createSocket(String host, int port) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(host, port));
+    }
+
+    @Override public Socket createSocket(
+        String host, int port, InetAddress localHost, int localPort) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(host, port, localHost, localPort));
+    }
+
+    @Override public Socket createSocket(InetAddress host, int port) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(host, port));
+    }
+
+    @Override public Socket createSocket(
+        InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
+      return configureSocket((SSLSocket) delegate.createSocket(
+          address, port, localAddress, localPort));
+    }
+
+    protected SSLSocket configureSocket(SSLSocket socket) throws IOException {
+      return socket;
+    }
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.handshake().cipherSuite());
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CustomCipherSuites().run();
+  }
+}
diff --git a/website/index.html b/website/index.html
index ff9ec474b3..6f0df48a03 100644
--- a/website/index.html
+++ b/website/index.html
@@ -78,8 +78,9 @@ <h4>Get a URL</h4>
       .url(url)
       .build();
 
-  Response response = client.newCall(request).execute();
-  return response.body().string();
+  try (Response response = client.newCall(request).execute()) {
+    return response.body().string();
+  }
 }
 </pre>
             <h4>Post to a Server</h4>
@@ -97,8 +98,9 @@ <h4>Post to a Server</h4>
       .url(url)
       .post(body)
       .build();
-  Response response = client.newCall(request).execute();
-  return response.body().string();
+  try (Response response = client.newCall(request).execute()) {
+    return response.body().string();
+  }
 }
 </pre>
 
