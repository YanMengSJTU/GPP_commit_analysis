diff --git a/.circleci/config.yml b/.circleci/config.yml
index d994242b28..afe75ce9d5 100644
--- a/.circleci/config.yml
+++ b/.circleci/config.yml
@@ -51,7 +51,7 @@ commands:
 jobs:
   compile:
     docker:
-      - image: circleci/openjdk:8u171-jdk
+      - image: circleci/openjdk:8u222-jdk-stretch
 
     environment:
       JVM_OPTS: -Xmx1g
@@ -81,7 +81,7 @@ jobs:
 
   checkjdk8:
     docker:
-      - image: circleci/openjdk:8u171-jdk
+      - image: circleci/openjdk:8u222-jdk-stretch
 
     environment:
       JVM_OPTS: -Xmx1g
@@ -114,7 +114,7 @@ jobs:
 
   testjdk8:
     docker:
-      - image: circleci/openjdk:8u171-jdk
+      - image: circleci/openjdk:8u222-jdk-stretch
 
     environment:
       JVM_OPTS: -Xmx1g
@@ -128,7 +128,7 @@ jobs:
 
   testjdk8alpn:
     docker:
-      - image: circleci/openjdk:8u171-jdk
+      - image: circleci/openjdk:8u222-jdk-stretch
 
     environment:
       JVM_OPTS: -Xmx1g
@@ -140,9 +140,38 @@ jobs:
       - runtests:
           platform: jdk8alpn
 
+  testopenjsse:
+    docker:
+      - image: circleci/openjdk:8u222-jdk-stretch
+
+    environment:
+      JVM_OPTS: -Xmx1g
+      TERM: dumb
+
+    steps:
+      - checkout
+
+      - runtests:
+          platform: openjsse
+
   testjdk11:
     docker:
-      - image: circleci/openjdk:11.0.3-jdk-stretch
+      - image: circleci/openjdk:11.0.4-jdk-stretch
+
+    environment:
+      JVM_OPTS: -Xmx1g
+      TERM: dumb
+
+    steps:
+      - checkout
+
+      - runtests:
+          platform: jdk9
+
+  testjdk12:
+    docker:
+      # best source of JDK 12 for now
+      - image: circleci/dynamodb:12.0.2-jdk
 
     environment:
       JVM_OPTS: -Xmx1g
@@ -156,7 +185,7 @@ jobs:
 
   testconscrypt:
     docker:
-      - image: circleci/openjdk:11.0.3-jdk-stretch
+      - image: circleci/openjdk:11.0.4-jdk-stretch
 
     environment:
       JVM_OPTS: -Xmx1g
@@ -179,13 +208,27 @@ workflows:
       - checkjdk8:
           filters:
             branches:
-              ignore: master
+              ignore:
+                - master
+                - gh-pages
       - testjdk8:
           filters:
             branches:
               only: master
-      - testjdk8alpn
+      - testjdk8alpn:
+          filters:
+            branches:
+              only: master
+      - testopenjsse:
+          filters:
+            branches:
+              only: master
       - testjdk11:
+          filters:
+            branches:
+              ignore:
+                - gh-pages
+      - testjdk12:
           filters:
             branches:
               only: master
@@ -211,9 +254,15 @@ workflows:
       - testjdk8alpn:
           requires:
             - compile
+      - testopenjsse:
+          requires:
+            - compile
       - testjdk11:
           requires:
             - compile
+      - testjdk12:
+          requires:
+            - compile
       - testconscrypt:
           requires:
             - compile
diff --git a/.gitignore b/.gitignore
index d2b9133572..b541aaa994 100644
--- a/.gitignore
+++ b/.gitignore
@@ -25,3 +25,9 @@ classes
 obj
 
 .DS_Store
+
+# Special Mkdocs files
+docs/4.x
+docs/changelog.md
+docs/contributing.md
+docs/index.md
diff --git a/.travis.yml b/.travis.yml
index 8913943d77..143348a630 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,10 +1,16 @@
 language: java
 
+dist: trusty
+
 jdk:
   - oraclejdk8
 
+# avoid ./gradlew assemble default which builds docs
+install:
+ - ./gradlew jar --parallel
+
 script:
- - ./gradlew check
+ - ./gradlew test --parallel
 
 after_success:
   - .buildscript/deploy_snapshot.sh
@@ -15,8 +21,8 @@ env:
     - secure: "WMkcWrsvzJNf48w7DJwipUNbhAoggCkC+NM31esq9/GDceGtVWj4hssQETynG4+ckxr0wGqUxsTRTz0uGhX6Fi58haG8yKp+g/HVClqI5EYjI44ptPcwlqlbYjuGbk65k1OGGZLctA6fQA3uT0zee05/yBjJx/jOqrN+PD1tW38="
 
 branches:
-  except:
-    - gh-pages
+  only:
+    - master
 
 notifications:
   email: false
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 7c59ffefae..887bbc5e04 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,1760 +1,99 @@
 Change Log
 ==========
 
-## Version 3.14.1
+## Version 4.1.1
 
-_2019-04-10_
+_2019-09-05_
 
- *  Fix: Don't crash when an interceptor retries when there are no more routes. This was an
-    edge-case regression introduced with the events cleanup in 3.14.0.
+ *  Fix: Don't drop repeated headers when validating cached responses. In our Kotlin upgrade we
+    introduced a regression where we iterated the number of unique header names rather than then
+    number of unique headers. If you're using OkHttp's response cache this may impact you.
 
- *  Fix: Provide actionable advice when the exchange is non-null. Prior to 3.14, OkHttp would
-    silently leak connections when an interceptor retries without closing the response body. With
-    3.14 we detect this problem but the exception was not helpful.
 
-## Version 3.14.0
+## Version 4.1.0
 
-_2019-03-14_
+_2019-08-12_
 
- *  **This release deletes the long-deprecated `OkUrlFactory` and `OkApacheClient` APIs.** These
-    facades hide OkHttp's implementation behind another client's API. If you still need this please
-    copy and paste [ObsoleteUrlFactory.java][obsolete_url_factory] or
-    [ObsoleteApacheClient.java][obsolete_apache_client] into your project.
+ [brotli]: https://github.com/google/brotli
 
- *  **OkHttp now supports duplex calls over HTTP/2.** With normal HTTP calls the request must finish
-    before the response starts. With duplex, request and response bodies are transmitted
-    simultaneously. This can be used to implement interactive conversations within a single HTTP
-    call.
+ *  **OkHttp's new okhttp-brotli module implements Brotli compression.** Install the interceptor to
+    enable [Brotli compression][brotli], which compresses 5-20% smaller than gzip.
 
-    Create duplex calls by overriding the new `RequestBody.isDuplex()` method to return true.
-    This simple option dramatically changes the behavior of the request body and of the entire
-    call.
-
-    The `RequestBody.writeTo()` method may now retain a reference to the provided sink and
-    hand it off to another thread to write to it after `writeTo` returns.
-
-    The `EventListener` may now see requests and responses interleaved in ways not previously
-    permitted. For example, a listener may receive `responseHeadersStart()` followed by
-    `requestBodyEnd()`, both on the same call. Such events may be triggered by different threads
-    even for a single call.
-
-    Interceptors that rewrite or replace the request body may now inadvertently interfere with
-    duplex request bodies. Such interceptors should check `RequestBody.isDuplex()` and avoid
-    accessing the request body when it is.
-
-    Duplex calls require HTTP/2. If HTTP/1 is established instead the duplex call will fail. The
-    most common use of duplex calls is [gRPC][grpc_http2].
-
- *  New: Prevent OkHttp from retransmitting a request body by overriding `RequestBody.isOneShot()`.
-    This is most useful when writing the request body is destructive.
-
- *  New: We've added `requestFailed()` and `responseFailed()` methods to `EventListener`. These
-    are called instead of `requestBodyEnd()` and `responseBodyEnd()` in some failure situations.
-    They may also be fired in cases where no event was published previously. In this release we did
-    an internal rewrite of our event code to fix problems where events were lost or unbalanced.
-
- *  Fix: Don't leak a connection when a call is canceled immediately preceding the `onFailure()`
-    callback.
-
- *  Fix: Apply call timeouts when connecting duplex calls, web sockets, and server-sent events.
-    Once the streams are established no further timeout is enforced.
-
- *  Fix: Retain the `Route` when a connection is reused on a redirect or other follow-up. This was
-    causing some `Authenticator` calls to see a null route when non-null was expected.
-
- *  Fix: Use the correct key size in the name of `TLS_AES_128_CCM_8_SHA256` which is a TLS 1.3
-    cipher suite. We accidentally specified a key size of 256, preventing that cipher suite from
-    being selected for any TLS handshakes. We didn't notice because this cipher suite isn't
-    supported on Android, Java, or Conscrypt.
-
-    We removed this cipher suite and `TLS_AES_128_CCM_SHA256` from the restricted, modern, and
-    compatible sets of cipher suites. These two cipher suites aren't enabled by default in either
-    Firefox or Chrome.
-
-    See our [TLS Configuration History][tls_configuration_history] tracker for a log of all changes
-    to OkHttp's default TLS options.
-
- *  New: Upgrade to Conscrypt 2.0.0. OkHttp works with other versions of Conscrypt but this is the
-    version we're testing against.
-
-    ```kotlin
-    implementation("org.conscrypt:conscrypt-openjdk-uber:2.0.0")
-    ```
-
- *  New: Update the embedded public suffixes list.
-
-
-## Version 3.12.2
-
-_2019-03-14_
-
- *  Fix: Don't crash if the HTTPS server returns no certificates in the TLS handshake.
- *  Fix: Don't leak a connection when a call is canceled immediately preceding the `onFailure()`
-    callback.
-
-
-## Version 3.13.1
-
-_2019-02-05_
-
- *  Fix: Don't crash when using a custom `X509TrustManager` or `SSLSocket` on Android. When we
-    removed obsolete code for Android 4.4 we inadvertently also removed support for custom
-    subclasses. We've restored that support!
-
-
-## Version 3.13.0
-
-_2019-02-04_
-
- *  **This release bumps our minimum requirements to Java 8+ or Android 5+.** Cutting off old
-    devices is a serious change and we don't do it lightly! [This post][require_android_5] explains
-    why we're doing this and how to upgrade.
-
-    The OkHttp 3.12.x branch will be our long-term branch for Android 2.3+ (API level 9+) and Java
-    7+. These platforms lack support for TLS 1.2 and should not be used. But because upgrading is
-    difficult we will backport critical fixes to the 3.12.x branch through December 31, 2020.
-
- *  **TLSv1 and TLSv1.1 are no longer enabled by default.** Major web browsers are working towards
-    removing these versions altogether in early 2020. If your servers aren't ready yet you can
-    configure OkHttp 3.13 to allow TLSv1 and TLSv1.1 connections:
-
-    ```
-    OkHttpClient client = new OkHttpClient.Builder()
-        .connectionSpecs(Arrays.asList(ConnectionSpec.COMPATIBLE_TLS))
-        .build();
-    ```
-
- *  New: You can now access HTTP trailers with `Response.trailers()`. This method may only be called
-    after the entire HTTP response body has been read.
-
- *  New: Upgrade to Okio 1.17.3. If you're on Kotlin-friendly Okio 2.x this release requires 2.2.2
-    or newer.
-
-    ```kotlin
-    implementation("com.squareup.okio:okio:1.17.3")
-    ```
-
- *  Fix: Don't miss cancels when sending HTTP/2 request headers.
- *  Fix: Don't miss whole operation timeouts when calls redirect.
- *  Fix: Don't leak connections if web sockets have malformed responses or if `onOpen()` throws.
- *  Fix: Don't retry when request bodies fail due to `FileNotFoundException`.
- *  Fix: Don't crash when URLs have IPv4-mapped IPv6 addresses.
- *  Fix: Don't crash when building `HandshakeCertificates` on Android API 28.
- *  Fix: Permit multipart file names to contain non-ASCII characters.
- *  New: API to get MockWebServer's dispatcher.
- *  New: API to access headers as `java.time.Instant`.
- *  New: Fail fast if a `SSLSocketFactory` is used as a `SocketFactory`.
- *  New: Log the TLS handshake in `LoggingEventListener`.
-
-
-## Version 3.12.1
-
-_2018-12-23_
-
- *  Fix: Remove overlapping `package-info.java`. This caused issues with some build tools.
-
-
-## Version 3.12.0
-
-_2018-11-16_
-
- *  **OkHttp now supports TLS 1.3.** This requires either Conscrypt or Java 11+.
-
- *  **Proxy authenticators are now asked for preemptive authentication.** OkHttp will now request
-    authentication credentials before creating TLS tunnels through HTTP proxies (HTTP `CONNECT`).
-    Authenticators should identify preemptive authentications by the presence of a challenge whose
-    scheme is "OkHttp-Preemptive".
-
- *  **OkHttp now offers full-operation timeouts.** This sets a limit on how long the entire call may
-    take and covers resolving DNS, connecting, writing the request body, server processing, and
-    reading the full response body. If a call requires redirects or retries all must complete within
-    one timeout period.
-
-    Use `OkHttpClient.Builder.callTimeout()` to specify the default duration and `Call.timeout()` to
-    specify the timeout of an individual call.
-
- *  New: Return values and fields are now non-null unless otherwise annotated.
- *  New: `LoggingEventListener` makes it easy to get basic visibility into a call's performance.
-    This class is in the `logging-interceptor` artifact.
- *  New: `Headers.Builder.addUnsafeNonAscii()` allows non-ASCII values to be added without an
-    immediate exception.
- *  New: Headers can be redacted in `HttpLoggingInterceptor`.
- *  New: `Headers.Builder` now accepts dates.
- *  New: OkHttp now accepts `java.time.Duration` for timeouts on Java 8+ and Android 26+.
- *  New: `Challenge` includes all authentication parameters.
- *  New: Upgrade to BouncyCastle 1.60, Conscrypt 1.4.0, and Okio 1.15.0. We don't yet require
-    Kotlin-friendly Okio 2.x but OkHttp works fine with that series.
-
-    ```kotlin
-    implementation("org.bouncycastle:bcprov-jdk15on:1.60")
-    implementation("org.conscrypt:conscrypt-openjdk-uber:1.4.0")
-    implementation("com.squareup.okio:okio:1.15.0")
     ```
-
- *  Fix: Handle dispatcher executor shutdowns gracefully. When there aren't any threads to carry a
-    call its callback now gets a `RejectedExecutionException`.
- *  Fix: Don't permanently cache responses with `Cache-Control: immutable`. We misunderstood the
-    original `immutable` proposal!
- *  Fix: Change `Authenticator`'s `Route` parameter to be nullable. This was marked as non-null but
-    could be called with null in some cases.
- *  Fix: Don't create malformed URLs when `MockWebServer` is reached via an IPv6 address.
- *  Fix: Don't crash if the system default authenticator is null.
- *  Fix: Don't crash generating elliptic curve certificates on Android.
- *  Fix: Don't crash doing platform detection on RoboVM.
- *  Fix: Don't leak socket connections when web socket upgrades fail.
-
-
-## Version 3.11.0
-
-_2018-07-12_
-
- *  **OkHttp's new okhttp-tls submodule tames HTTPS and TLS.**
-
-    `HeldCertificate` is a TLS certificate and its private key. Generate a certificate with its
-    builder then use it to sign another certificate or perform a TLS handshake. The
-    `certificatePem()` method encodes the certificate in the familiar PEM format
-    (`--- BEGIN CERTIFICATE ---`); the `privateKeyPkcs8Pem()` does likewise for the private key.
-
-    `HandshakeCertificates` holds the TLS certificates required for a TLS handshake. On the server
-    it keeps your `HeldCertificate` and its chain. On the client it keeps the root certificates
-    that are trusted to sign a server's certificate chain. `HandshakeCertificates` also works with
-    mutual TLS where these roles are reversed.
-
-    These classes make it possible to enable HTTPS in MockWebServer in [just a few lines of
-    code][https_server_sample].
-
- *  **OkHttp now supports prior knowledge cleartext HTTP/2.** Enable this by setting
-    `Protocol.H2_PRIOR_KNOWLEDGE` as the lone protocol on an `OkHttpClient.Builder`. This mode
-    only supports `http:` URLs and is best suited in closed environments where HTTPS is
-    inappropriate.
-
- *  New: `HttpUrl.get(String)` is an alternative to `HttpUrl.parse(String)` that throws an exception
-    when the URL is malformed instead of returning null. Use this to avoid checking for null in
-    situations where the input is known to be well-formed. We've also added `MediaType.get(String)`
-    which is an exception-throwing alternative to `MediaType.parse(String)`.
- *  New: The `EventListener` API previewed in OkHttp 3.9 has graduated to a stable API. Use this
-    interface to track metrics and monitor HTTP requests' size and duration.
- *  New: `okhttp-dnsoverhttps` is an experimental API for doing DNS queries over HTTPS. Using HTTPS
-    for DNS offers better security and potentially better performance. This feature is a preview:
-    the API is subject to change.
- *  New: `okhttp-sse` is an early preview of Server-Sent Events (SSE). This feature is incomplete
-    and is only suitable for experimental use.
- *  New: MockWebServer now supports client authentication (mutual TLS). Call `requestClientAuth()`
-    to permit an optional client certificate or `requireClientAuth()` to require one.
- *  New: `RecordedRequest.getHandshake()` returns the HTTPS handshake of a request sent to
-    `MockWebServer`.
- *  Fix: Honor the `MockResponse` header delay in MockWebServer.
- *  Fix: Don't release HTTP/2 connections that have multiple canceled calls. We had a bug where
-    canceling calls would cause the shared HTTP/2 connection to be unnecessarily released. This
-    harmed connection reuse.
- *  Fix: Ensure canceled and discarded HTTP/2 data is not permanently counted against the limited
-    flow control window. We had a few bugs where window size accounting was broken when streams
-    were canceled or reset.
- *  Fix: Recover gracefully if the TLS session returns an unexpected version (`NONE`) or cipher
-    suite (`SSL_NULL_WITH_NULL_NULL`).
- *  Fix: Don't change Conscrypt configuration globally. We migrated from a process-wide setting to
-    configuring only OkHttp's TLS sockets.
- *  Fix: Prefer TLSv1.2 where it is available. On certain older platforms it is necessary to opt-in
-    to TLSv1.2.
- *  New: `Request.tag()` permits multiple tags. Use a `Class<?>` as a key to identify tags. Note
-    that `tag()` now returns null if the request has no tag. Previously this would return the
-    request itself.
- *  New: `Headers.Builder.addAll(Headers)`.
- *  New: `ResponseBody.create(MediaType, ByteString)`.
- *  New: Embed R8/ProGuard rules in the jar. These will be applied automatically by R8.
- *  Fix: Release the connection if `Authenticator` throws an exception.
- *  Fix: Change the declaration of `OkHttpClient.cache()` to return a `@Nullable Cache`. The return
-    value has always been nullable but it wasn't declared properly.
- *  Fix: Reverse suppression of connect exceptions. When both a call and its retry fail, we now
-    throw the initial exception which is most likely to be actionable.
- *  Fix: Retain interrupted state when throwing `InterruptedIOException`. A single interrupt should
-    now be sufficient to break out an in-flight OkHttp call.
- *  Fix: Don't drop a call to `EventListener.callEnd()` when the response body is consumed inside an
-    interceptor.
-
-
-## Version 3.10.0
-
-_2018-02-24_
-
- *  **The pingInterval() feature now aggressively checks connectivity for web
-    sockets and HTTP/2 connections.**
-
-    Previously if you configured a ping interval that would cause OkHttp to send
-    pings, but it did not track whether the reply pongs were received. With this
-    update OkHttp requires that every ping receive a response: if it does not
-    the connection will be closed and the listener's `onFailure()` method will
-    be called.
-
-    Web sockets have always been had pings, but pings on HTTP/2 connections is
-    new in this release. Pings are used for connections that are busy carrying
-    calls and for idle connections in the connection pool. (Pings do not impact
-    when pooled connections are evicted).
-
-    If you have a configured ping interval, you should confirm that it is long
-    enough for a roundtrip from client to server. If your ping interval is too
-    short, slow connections may be misinterpreted as failed connections. A ping
-    interval of 30 seconds is reasonable for most use cases.
-
- *  **OkHttp now supports [Conscrypt][conscrypt].** Conscrypt is a Java Security
-    Provider that integrates BoringSSL into the Java platform. Conscrypt
-    supports more cipher suites than the JVM’s default provider and may also
-    execute more efficiently.
-
-    To use it, first register a [Conscrypt dependency][conscrypt_dependency] in
-    your build system.
-
-    OkHttp will use Conscrypt if you set the `okhttp.platform` system property
-    to `conscrypt`.
-
-    Alternatively, OkHttp will also use Conscrypt if you install it as your
-    preferred security provider. To do so, add the following code to execute
-    before you create your `OkHttpClient`.
-
-    ```
-    Security.insertProviderAt(
-        new org.conscrypt.OpenSSLProvider(), 1);
+    val client = OkHttpClient.Builder()
+        .addInterceptor(BrotliInterceptor)
+        .build()
     ```
 
-    Conscrypt is the bundled security provider on Android so it is not necessary
-    to configure it on that platform.
-
- *  New: `HttpUrl.addQueryParameter()` percent-escapes more characters.
-    Previously several ASCII punctuation characters were not percent-escaped
-    when used with this method. This does not impact already-encoded query
-    parameters in APIs like `HttpUrl.parse()` and
-    `HttpUrl.Builder.addEncodedQueryParameter()`.
- *  New: CBC-mode ECDSA cipher suites have been removed from OkHttp's default
-    configuration: `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA` and
-    `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA`. This tracks a [Chromium
-    change][remove_cbc_ecdsa] to remove these cipher suites because they are
-    fragile and rarely-used.
- *  New: Don't fall back to common name (CN) verification for hostnames. This
-    behavior was deprecated with RFC 2818 in May 2000 and was recently dropped
-    from major web browsers.
- *  New: Honor the `Retry-After` response header. HTTP 503 (Unavailable)
-    responses are retried automatically if this header is present and its delay
-    is 0 seconds. HTTP 408 (Client Timeout) responses are retried automatically
-    if the header is absent or its delay is 0 seconds.
- *  New: Allow request bodies for all HTTP methods except GET and HEAD.
- *  New: Automatic module name of `okhttp3` for use with the Java Platform
-    Module System.
- *  New: Log gzipped bodies when `HttpLoggingInterceptor` is used as a network
-    interceptor.
- *  New: `Protocol.QUIC` constant. This protocol is not supported but this
-    constant is included for completeness.
- *  New: Upgrade to Okio 1.14.0.
-
-     ```xml
-     <dependency>
-       <groupId>com.squareup.okio</groupId>
-       <artifactId>okio</artifactId>
-       <version>1.14.0</version>
-     </dependency>
-
-     com.squareup.okio:okio:1.14.0
-     ```
-
- *  Fix: Handle `HTTP/1.1 100 Continue` status lines, even on requests that did
-    not send the `Expect: continue` request header.
- *  Fix: Do not count web sockets toward the dispatcher's per-host connection
-    limit.
- *  Fix: Avoid using invalid HTTPS sessions. This prevents OkHttp from crashing
-    with the error, `Unexpected TLS version: NONE`.
- *  Fix: Don't corrupt the response cache when a 304 (Not Modified) response
-    overrides the stored "Content-Encoding" header.
- *  Fix: Gracefully shut down the HTTP/2 connection before it exhausts the
-    namespace of stream IDs (~536 million streams).
- *  Fix: Never pass a null `Route` to `Authenticator`. There was a bug where
-    routes were omitted for eagerly-closed connections.
-
-## Version 3.9.1
-
-_2017-11-18_
-
- *  New: Recover gracefully when Android's DNS crashes with an unexpected
-    `NullPointerException`.
- *  New: Recover gracefully when Android's socket connections crash with an
-    unexpected `ClassCastException`.
- *  Fix: Don't include the URL's fragment in `encodedQuery()` when the query
-    itself is empty.
-
-## Version 3.9.0
-
-_2017-09-03_
-
- *  **Interceptors are more capable.** The `Chain` interface now offers access
-    to the call and can adjust all call timeouts. Note that this change is
-    source-incompatible for code that implements the `Chain` interface.
-    We don't expect this to be a problem in practice!
-
- *  **OkHttp has an experimental new API for tracking metrics.** The new
-    `EventListener` API is designed to help developers monitor HTTP requests'
-    size and duration. This feature is an unstable preview: the API is subject
-    to change, and the implementation is incomplete. This is a big new API we
-    are eager for feedback.
-
- *  New: Support ALPN via Google Play Services' Dynamic Security Provider. This
-    expands HTTP/2 support to older Android devices that have Google Play
-    Services.
- *  New: Consider all routes when looking for candidate coalesced connections.
-    This increases the likelihood that HTTP/2 connections will be shared.
- *  New: Authentication challenges and credentials now use a charset. Use this in
-    your authenticator to support user names and passwords with non-ASCII
-    characters.
- *  New: Accept a charset in `FormBody.Builder`. Previously form bodies were
-    always UTF-8.
- *  New: Support the `immutable` cache-control directive.
- *  Fix: Don't crash when an HTTP/2 call is redirected while the connection is
-    being shut down.
- *  Fix: Don't drop headers of healthy streams that raced with `GOAWAY` frames.
-    This bug would cause HTTP/2 streams to occasional hang when the connection
-    was shutting down.
- *  Fix: Honor `OkHttpClient.retryOnConnectionFailure()` when the response is a
-    HTTP 408 Request Timeout. If retries are enabled, OkHttp will retry exactly
-    once in response to a 408.
- *  Fix: Don't crash when reading the empty `HEAD` response body if it specifies
-    a `Content-Length`.
- *  Fix: Don't crash if the thread is interrupted while reading the public
-    suffix database.
- *  Fix: Use relative resource path when loading the public suffix database.
-    Loading the resource using a path relative to the class prevents conflicts
-    when the OkHttp classes are relocated (shaded) by allowing multiple private
-    copies of the database.
- *  Fix: Accept cookies for URLs that have an IPv6 address for a host.
- *  Fix: Don't log the protocol (HTTP/1.1, h2) in HttpLoggingInterceptor if the
-    protocol isn't negotiated yet! Previously we'd log HTTP/1.1 by default, and
-    this was confusing.
- *  Fix: Omit the message from MockWebServer's HTTP/2 `:status` header.
- *  Fix: Handle 'Expect: 100 Continue' properly in MockWebServer.
-
-
-## Version 3.8.1
-
-_2017-06-18_
-
- *  Fix: Recover gracefully from stale coalesced connections. We had a bug where
-    connection coalescing (introduced in OkHttp 3.7.0) and stale connection
-    recovery could interact to cause a `NoSuchElementException` crash in the
-    `RouteSelector`.
-
-
-## Version 3.8.0
-
-_2017-05-13_
-
-
- *  **OkHttp now uses `@Nullable` to annotate all possibly-null values.** We've
-    added a compile-time dependency on the JSR 305 annotations. This is a
-    [provided][maven_provided] dependency and does not need to be included in
-    your build configuration, `.jar` file, or `.apk`. We use
-    `@ParametersAreNonnullByDefault` and all parameters and return types are
-    never null unless explicitly annotated `@Nullable`.
-
- *  **Warning: this release is source-incompatible for Kotlin users.**
-    Nullability was previously ambiguous and lenient but now the compiler will
-    enforce strict null checks.
-
- *  New: The response message is now non-null. This is the "Not Found" in the
-    status line "HTTP 404 Not Found". If you are building responses
-    programmatically (with `new Response.Builder()`) you must now always supply
-    a message. An empty string `""` is permitted. This value was never null on
-    responses returned by OkHttp itself, and it was an old mistake to permit
-    application code to omit a message.
-
- *  The challenge's scheme and realm are now non-null. If you are calling
-    `new Challenge(scheme, realm)` you must provide non-null values. These were
-    never null in challenges created by OkHttp, but could have been null in
-    application code that creates challenges.
-
- *  New: The `TlsVersion` of a `Handshake` is now non-null. If you are calling
-    `Handshake.get()` with a null TLS version, you must instead now provide a
-    non-null `TlsVersion`. Cache responses persisted prior to OkHttp 3.0 did not
-    store a TLS version; for these unknown values the handshake is defaulted to
-    `TlsVersion.SSL_3_0`.
-
- *  New: Upgrade to Okio 1.13.0.
-
-     ```xml
-     <dependency>
-       <groupId>com.squareup.okio</groupId>
-       <artifactId>okio</artifactId>
-       <version>1.13.0</version>
-     </dependency>
-
-     com.squareup.okio:okio:1.13.0
-     ```
-
- *  Fix: gracefully recover when Android 7.0's sockets throw an unexpected
-    `NullPointerException`.
-
-## Version 3.7.0
-
-_2017-04-15_
-
- *  **OkHttp no longer recovers from TLS handshake failures by attempting a TLSv1 connection.**
-    The fallback was necessary for servers that implemented version negotiation incorrectly. Now
-    that 99.99% of servers do it right this fallback is obsolete.
- *  Fix: Do not honor cookies set on a public domain. Previously a malicious site could inject
-    cookies on top-level domains like `co.uk` because our cookie parser didn't honor the [public
-    suffix][public_suffix] list. Alongside this fix is a new API, `HttpUrl.topPrivateDomain()`,
-    which returns the privately domain name if the URL has one.
- *  Fix: Change `MediaType.charset()` to return null for unexpected charsets.
- *  Fix: Don't skip cache invalidation if the invalidating response has no body.
- *  Fix: Don't use a cryptographic random number generator for web sockets. Some Android devices
-    implement `SecureRandom` incorrectly!
- *  Fix: Correctly canonicalize IPv6 addresses in `HttpUrl`. This prevented OkHttp from trusting
-    HTTPS certificates issued to certain IPv6 addresses.
- *  Fix: Don't reuse connections after an unsuccessful `Expect: 100-continue`.
- *  Fix: Handle either `TLS_` or `SSL_` prefixes for cipher suite names. This is necessary for
-    IBM JVMs that use the `SSL_` prefix exclusively.
- *  Fix: Reject HTTP/2 data frames if the stream ID is 0.
- *  New: Upgrade to Okio 1.12.0.
-
-     ```xml
-     <dependency>
-       <groupId>com.squareup.okio</groupId>
-       <artifactId>okio</artifactId>
-       <version>1.12.0</version>
-     </dependency>
-
-     com.squareup.okio:okio:1.12.0
-     ```
-
- *  New: Connection coalescing. OkHttp may reuse HTTP/2 connections across calls that share an IP
-    address and HTTPS certificate, even if their domain names are different.
- *  New: MockWebServer's `RecordedRequest` exposes the requested `HttpUrl` with `getRequestUrl()`.
-
-
-## Version 3.6.0
-
-_2017-01-29_
-
- *  Fix: Don't crash with a "cache is closed" error when there is an error initializing the cache.
- *  Fix: Calling `disconnect()` on a connecting `HttpUrlConnection` could cause it to retry in an
-    infinite loop! This regression was introduced in OkHttp 2.7.0.
- *  Fix: Drop cookies that contain ASCII NULL and other bad characters. Previously such cookies
-    would cause OkHttp to crash when they were included in a request.
- *  Fix: Release duplicated multiplexed connections. If we concurrently establish connections to an
-    HTTP/2 server, close all but the first connection.
- *  Fix: Fail the HTTP/2 connection if first frame isn't `SETTINGS`.
- *  Fix: Forbid spaces in header names.
- *  Fix: Don't offer to do gzip if the request is partial.
- *  Fix: MockWebServer is now usable with JUnit 5. That update [broke the rules][junit_5_rules].
- *  New: Support `Expect: 100-continue` as a request header. Callers can use this header to
-    pessimistically hold off on transmitting a request body until a server gives the go-ahead.
- *  New: Permit network interceptors to rewrite the host header for HTTP/2. This makes it possible
-    to do domain fronting.
- *  New: charset support for `Credentials.basic()`.
-
-
-## Version 3.5.0
-
-_2016-11-30_
-
- *  **Web Sockets are now a stable feature of OkHttp.** Since being introduced as a beta feature in
-    OkHttp 2.3 our web socket client has matured. Connect to a server's web socket with
-    `OkHttpClient.newWebSocket()`, send messages with `send()`, and receive messages with the
-    `WebSocketListener`.
-
-    The `okhttp-ws` submodule is no longer available and `okhttp-ws` artifacts from previous
-    releases of OkHttp are not compatible with OkHttp 3.5. When upgrading to the new package
-    please note that the `WebSocket` and `WebSocketCall` classes have been merged. Sending messages
-    is now asynchronous and they may be enqueued before the web socket is connected.
-
- *  **OkHttp no longer attempts a direct connection if the system's HTTP proxy fails.** This
-    behavior was surprising because OkHttp was disregarding the user's specified configuration. If
-    you need to customize proxy fallback behavior, implement your own `java.net.ProxySelector`.
-
- *  Fix: Support TLSv1.3 on devices that support it.
-
- *  Fix: Share pooled connections across equivalent `OkHttpClient` instances. Previous releases had
-    a bug where a shared connection pool did not guarantee shared connections in some cases.
- *  Fix: Prefer the server's response body on all conditional cache misses. Previously we would
-    return the cached response's body if it had a newer `Last-Modified` date.
- *  Fix: Update the stored timestamp on conditional cache hits.
- *  New: Optimized HTTP/2 request header encoding. More headers are HPACK-encoded and string
-    literals are now Huffman-encoded.
- *  New: Expose `Part` headers and body in `Multipart`.
- *  New: Make `ResponseBody.string()` and `ResponseBody.charStream()` BOM-aware. If your HTTP
-    response body begins with a [byte order mark][bom] it will be consumed and used to select a
-    charset for the remaining bytes. Most applications should not need a byte order mark.
-
- *  New: Upgrade to Okio 1.11.0.
-
-     ```xml
-     <dependency>
-       <groupId>com.squareup.okio</groupId>
-       <artifactId>okio</artifactId>
-       <version>1.11.0</version>
-     </dependency>
-
-     com.squareup.okio:okio:1.11.0
-     ```
-
- *  Fix: Avoid sending empty HTTP/2 data frames when there is no request body.
- *  Fix: Add a leading `.` for better domain matching in `JavaNetCookieJar`.
- *  Fix: Gracefully recover from HTTP/2 connection shutdowns at start of request.
- *  Fix: Be lenient if a `MediaType`'s character set is `'single-quoted'`.
- *  Fix: Allow horizontal tab characters in header values.
- *  Fix: When parsing HTTP authentication headers permit challenge parameters in any order.
-
-
-## Version 3.4.2
-
-_2016-11-03_
-
- *  Fix: Recover gracefully when an HTTP/2 connection is shutdown. We had a
-    bug where shutdown HTTP/2 connections were considered usable. This caused
-    infinite loops when calls attempted to recover.
-
-
-## Version 3.4.1
-
-_2016-07-10_
-
- *  **Fix a major bug in encoding HTTP headers.** In 3.4.0 and 3.4.0-RC1 OkHttp
-    had an off-by-one bug in our HPACK encoder. This bug could have caused the
-    wrong headers to be emitted after a sequence of HTTP/2 requests! Everyone
-    who is using OkHttp 3.4.0 or 3.4.0-RC1 should upgrade for this bug fix.
-
-
-## Version 3.4.0
-
-_2016-07-08_
-
- *  New: Support dynamic table size changes to HPACK Encoder.
- *  Fix: Use `TreeMap` in `Headers.toMultimap()`. This makes string lookups on
-    the returned map case-insensitive.
- *  Fix: Don't share the OkHttpClient's `Dispatcher` in `HttpURLConnection`.
-
-
-## Version 3.4.0-RC1
-
-_2016-07-02_
-
- *  **We’ve rewritten HttpURLConnection and HttpsURLConnection.** Previously we
-    shared a single HTTP engine between two frontend APIs: `HttpURLConnection`
-    and `Call`. With this release we’ve rearranged things so that the
-    `HttpURLConnection` frontend now delegates to the `Call` APIs internally.
-    This has enabled substantial simplifications and optimizations in the OkHttp
-    core for both frontends.
-
-    For most HTTP requests the consequences of this change will be negligible.
-    If your application uses `HttpURLConnection.connect()`,
-    `setFixedLengthStreamingMode()`, or `setChunkedStreamingMode()`, OkHttp will
-    now use a async dispatcher thread to establish the HTTP connection.
-
-    We don’t expect this change to have any behavior or performance
-    consequences. Regardless, please exercise your `OkUrlFactory` and
-    `HttpURLConnection` code when applying this update.
-
- *  **Cipher suites may now have arbitrary names.** Previously `CipherSuite` was
-    a Java enum and it was impossible to define new cipher suites without first
-    upgrading OkHttp. With this change it is now a regular Java class with
-    enum-like constants. Application code that uses enum methods on cipher
-    suites (`ordinal()`, `name()`, etc.) will break with this change.
-
- *  Fix: `CertificatePinner` now matches canonicalized hostnames. Previously
-    this was case sensitive. This change should also make it easier to configure
-    certificate pinning for internationalized domain names.
- *  Fix: Don’t crash on non-ASCII `ETag` headers. Previously OkHttp would reject
-    these headers when validating a cached response.
- *  Fix: Don’t allow remote peer to arbitrarily size the HPACK decoder dynamic
-    table.
- *  Fix: Honor per-host configuration in Android’s network security config.
-    Previously disabling cleartext for any host would disable cleartext for all
-    hosts. Note that this setting is only available on Android 24+.
- *  New: HPACK compression is now dynamic. This should improve performance when
-    transmitting request headers over HTTP/2.
- *  New: `Dispatcher.setIdleCallback()` can be used to signal when there are no
-    calls in flight. This is useful for [testing with
-    Espresso][okhttp_idling_resource].
- *  New: Upgrade to Okio 1.9.0.
-
-     ```xml
-     <dependency>
-       <groupId>com.squareup.okio</groupId>
-       <artifactId>okio</artifactId>
-       <version>1.9.0</version>
-     </dependency>
-     ```
-
-
-## Version 3.3.1
-
-_2016-05-28_
-
- *  Fix: The plaintext check in HttpLoggingInterceptor incorrectly classified
-    newline characters as control characters. This is fixed.
- *  Fix: Don't crash reading non-ASCII characters in HTTP/2 headers or in cached
-    HTTP headers.
- *  Fix: Retain the response body when an attempt to open a web socket returns a
-    non-101 response code.
-
-
-## Version 3.3.0
-
-_2016-05-24_
-
- *  New: `Response.sentRequestAtMillis()` and `receivedResponseAtMillis()`
-    methods track the system's local time when network calls are made. These
-    replace the `OkHttp-Sent-Millis` and `OkHttp-Received-Millis` headers that were
-    present in earlier versions of OkHttp.
- *  New: Accept user-provided trust managers in `OkHttpClient.Builder`. This
-    allows OkHttp to satisfy its TLS requirements directly. Otherwise OkHttp
-    will use reflection to extract the `TrustManager` from the
-    `SSLSocketFactory`.
- *  New: Support prerelease Java 9. This gets ALPN from the platform rather than
-    relying on the alpn-boot bootclasspath override.
- *  New: `HttpLoggingInterceptor` now logs connection failures.
- *  New: Upgrade to Okio 1.8.0.
-
-     ```xml
-     <dependency>
-       <groupId>com.squareup.okio</groupId>
-       <artifactId>okio</artifactId>
-       <version>1.8.0</version>
-     </dependency>
-     ```
-
- *  Fix: Gracefully recover from a failure to rebuild the cache journal.
- *  Fix: Don't corrupt cache entries when a cache entry is evicted while it is
-    being updated.
- *  Fix: Make logging more consistent throughout OkHttp.
- *  Fix: Log plaintext bodies only. This uses simple heuristics to differentiate
-    text from other data.
- *  Fix: Recover from `REFUSED_STREAM` errors in HTTP/2. This should improve
-    interoperability with Nginx 1.10.0, which [refuses][nginx_959] streams
-    created before HTTP/2 settings have been acknowledged.
- *  Fix: Improve recovery from failed routes.
- *  Fix: Accommodate tunneling proxies that close the connection after an auth
-    challenge.
- *  Fix: Use the proxy authenticator when authenticating HTTP proxies. This
-    regression was introduced in OkHttp 3.0.
- *  Fix: Fail fast if network interceptors transform the response body such that
-    closing it doesn't also close the underlying stream. We had a bug where
-    OkHttp would attempt to reuse a connection but couldn't because it was still
-    held by a prior request.
- *  Fix: Ensure network interceptors always have access to the underlying
-    connection.
- *  Fix: Use `X509TrustManagerExtensions` on Android 17+.
- *  Fix: Unblock waiting dispatchers on MockWebServer shutdown.
-
-
-## Version 3.2.0
-
-_2016-02-25_
-
- *  Fix: Change the certificate pinner to always build full chains. This
-    prevents a potential crash when using certificate pinning with the Google
-    Play Services security provider.
- *  Fix: Make IPv6 request lines consistent with Firefox and Chrome.
- *  Fix: Recover gracefully when trimming the response cache fails.
- *  New: Add multiple path segments using a single string in `HttpUrl.Builder`.
- *  New: Support SHA-256 pins in certificate pinner.
-
-
-## Version 3.1.2
-
-_2016-02-10_
-
- *  Fix: Don’t crash when finding the trust manager on Robolectric. We attempted
-    to detect the host platform and got confused because Robolectric looks like
-    Android but isn’t!
- *  Fix: Change `CertificatePinner` to skip sanitizing the certificate chain
-    when no certificates were pinned. This avoids an SSL failure in insecure
-    “trust everyone” configurations, such as when talking to a development
-    HTTPS server that has a self-signed certificate.
-
-
-## Version 3.1.1
-
-_2016-02-07_
-
- *  Fix: Don't crash when finding the trust manager if the Play Services (GMS)
-    security provider is installed.
- *  Fix: The previous release introduced a performance regression on Android,
-    caused by looking up CA certificates. This is now fixed.
-
-
-## Version 3.1.0
-
-_2016-02-06_
-
- *  New: WebSockets now defer some writes. This should improve performance for
-    some applications.
- *  New: Override `equals()` and `hashCode()` in our new cookie class. This
-    class now defines equality by value rather than by reference.
- *  New: Handle 408 responses by retrying the request. This allows servers to
-    direct clients to retry rather than failing permanently.
- *  New: Expose the framed protocol in `Connection`. Previously this would
-    return the application-layer protocol (HTTP/1.1 or HTTP/1.0); now it always
-    returns the wire-layer protocol (HTTP/2, SPDY/3.1, or HTTP/1.1).
- *  Fix: Permit the trusted CA root to be pinned by `CertificatePinner`.
- *  Fix: Silently ignore unknown HTTP/2 settings. Previously this would cause
-    the entire connection to fail.
- *  Fix: Don’t crash on unexpected charsets in the logging interceptor.
- *  Fix: `OkHttpClient` is now non-final for the benefit of mocking frameworks.
-    Mocking sophisticated classes like `OkHttpClient` is fragile and you
-    shouldn’t do it. But if that’s how you want to live your life we won’t stand
-    in your way!
-
-
-## Version 3.0.1
-
-_2016-01-14_
-
- *  Rollback OSGi support. This was causing library jars to include more classes
-    than expected, which interfered with Gradle builds.
-
-
-## Version 3.0.0
-
-_2016-01-13_
-
-This release commits to a stable 3.0 API. Read the 3.0.0-RC1 changes for advice
-on upgrading from 2.x to 3.x.
-
- *  **The `Callback` interface now takes a `Call`**. This makes it easier to
-    check if the call was canceled from within the callback. When migrating
-    async calls to this new API, `Call` is now the first parameter for both
-    `onResponse()` and `onFailure()`.
- *  Fix: handle multiple cookies in `JavaNetCookieJar` on Android.
- *  Fix: improve the default HTTP message in MockWebServer responses.
- *  Fix: don't leak file handles when a conditional GET throws.
- *  Fix: Use charset specified by the request body content type in OkHttp's
-    logging interceptor.
- *  Fix: Don't eagerly release pools on cache hits.
- *  New: Make OkHttp OSGi ready.
- *  New: Add already-implemented interfaces Closeable and Flushable to the cache.
-
-## Version 3.0.0-RC1
-
-_2016-01-02_
-
-OkHttp 3 is a major release focused on API simplicity and consistency. The API
-changes are numerous but most are cosmetic. Applications should be able to
-upgrade from the 2.x API to the 3.x API mechanically and without risk.
-
-Because the release includes breaking API changes, we're changing the project's
-package name from `com.squareup.okhttp` to `okhttp3`. This should make it
-possible for large applications to migrate incrementally. The Maven group ID
-is now `com.squareup.okhttp3`. For an explanation of this strategy, see Jake
-Wharton's post, [Java Interoperability Policy for Major Version
-Updates][major_versions].
-
-This release obsoletes OkHttp 2.x, and all code that uses OkHttp's
-`com.squareup.okhttp` package should upgrade to the `okhttp3` package. Libraries
-that depend on OkHttp should upgrade quickly to prevent applications from being
-stuck on the old version.
-
- *  **There is no longer a global singleton connection pool.** In OkHttp 2.x,
-    all `OkHttpClient` instances shared a common connection pool by default.
-    In OkHttp 3.x, each new `OkHttpClient` gets its own private connection pool.
-    Applications should avoid creating many connection pools as doing so
-    prevents connection reuse. Each connection pool holds its own set of
-    connections alive so applications that have many pools also risk exhausting
-    memory!
+    This artifact has a dependency on Google's Brotli decoder (95 KiB).
 
-    The best practice in OkHttp 3 is to create a single OkHttpClient instance
-    and share it throughout the application. Requests that needs a customized
-    client should call `OkHttpClient.newBuilder()` on that shared instance.
-    This allows customization without the drawbacks of separate connection
-    pools.
+ *  New: `EventListener.proxySelectStart()`, `proxySelectEnd()` events give visibility into the
+    proxy selection process.
+ *  New: `Response.byteString()` reads the entire response into memory as a byte string.
+ *  New: `OkHttpClient.x509TrustManager` accessor.
+ *  New: Permit [new WebSocket response codes][iana_websocket]: 1012 (Service Restart), 1013 (Try
+    Again Later), and 1014 (invalid response from the upstream).
+ *  New: Build with Kotlin 1.3.41, BouncyCastle 1.62, and Conscrypt 2.2.1.
+ *  Fix: Recover gracefully when a a coalesced connection immediately goes unhealthy.
+ *  Fix: Defer the `SecurityException` when looking up the default proxy selector.
+ *  Fix: Don't use brackets formatting IPv6 host names in MockWebServer.
+ *  Fix: Don't permit cache iterators to remove entries that are being written.
 
- *  **OkHttpClient is now stateless.** In the 2.x API `OkHttpClient` had getters
-    and setters. Internally each request was forced to make its own complete
-    snapshot of the `OkHttpClient` instance to defend against racy configuration
-    changes. In 3.x, `OkHttpClient` is now stateless and has a builder. Note
-    that this class is not strictly immutable as it has stateful members like
-    the connection pool and cache.
 
- *  **Get and Set prefixes are now avoided.** With ubiquitous builders
-    throughout OkHttp these accessor prefixes aren't necessary. Previously
-    OkHttp used _get_ and _set_ prefixes sporadically which make the API
-    inconsistent and awkward to explore.
+## Version 4.0.1
 
- *  **OkHttpClient now implements the new `Call.Factory` interface.** This
-    interface will make your code easier to test. When you test code that makes
-    HTTP requests, you can use this interface to replace the real `OkHttpClient`
-    with your own mocks or fakes.
+_2019-07-10_
 
-    The interface will also let you use OkHttp's API with another HTTP client's
-    implementation. This is useful in sandboxed environments like Google App
-    Engine.
+ *  Fix: Tolerate null-hostile lists in public API. Lists created with `List.of(...)` don't like it
+    when you call `contains(null)` on them!
+ *  Fix: Retain binary-compatibility in `okhttp3.internal.HttpHeaders.hasBody()`. Some unscrupulous
+    coders call this and we don't want their users to suffer.
 
- *  **OkHttp now does cookies.** We've replaced `java.net.CookieHandler` with
-    a new interface, `CookieJar` and added our own `Cookie` model class. This
-    new cookie follows the latest RFC and supports the same cookie attributes
-    as modern web browsers.
-
- *  **Form and Multipart bodies are now modeled.** We've replaced the opaque
-    `FormEncodingBuilder` with the more powerful `FormBody` and
-    `FormBody.Builder` combo. Similarly we've upgraded `MultipartBuilder` into
-    `MultipartBody`, `MultipartBody.Part`, and `MultipartBody.Builder`.
-
- *  **The Apache HTTP client and HttpURLConnection APIs are deprecated.** They
-    continue to work as they always have, but we're moving everything to the new
-    OkHttp 3 API. The `okhttp-apache` and `okhttp-urlconnection` modules should
-    be only be used to accelerate a transition to OkHttp's request/response API.
-    These deprecated modules will be dropped in an upcoming OkHttp 3.x release.
-
- *  **Canceling batches of calls is now the application's responsibility.**
-    The API to cancel calls by tag has been removed and replaced with a more
-    general mechanism. The dispatcher now exposes all in-flight calls via its
-    `runningCalls()` and `queuedCalls()` methods. You can write code that
-    selects calls by tag, host, or whatever, and invokes `Call.cancel()` on the
-    ones that are no longer necessary.
-
- *  **OkHttp no longer uses the global `java.net.Authenticator` by default.**
-    We've changed our `Authenticator` interface to authenticate web and proxy
-    authentication failures through a single method. An adapter for the old
-    authenticator is available in the `okhttp-urlconnection` module.
-
- *  Fix: Don't throw `IOException` on `ResponseBody.contentLength()` or `close()`.
- *  Fix: Never throw converting an `HttpUrl` to a `java.net.URI`. This changes
-    the `uri()` method to handle malformed percent-escapes and characters
-    forbidden by `URI`.
- *  Fix: When a connect times out, attempt an alternate route. Previously route
-    selection was less efficient when differentiating failures.
- *  New: `Response.peekBody()` lets you access the response body without
-    consuming it. This may be handy for interceptors!
- *  New: `HttpUrl.newBuilder()` resolves a link to a builder.
- *  New: Add the TLS version to the `Handshake`.
- *  New: Drop `Request.uri()` and `Request#urlString()`. Just use
-    `Request.url().uri()` and `Request.url().toString()`.
- *  New: Add URL to HTTP response logging.
- *  New: Make `HttpUrl` the blessed URL method of `Request`.
-
-
-## Version 2.7.5
-
-_2016-02-25_
-
- *  Fix: Change the certificate pinner to always build full chains. This
-    prevents a potential crash when using certificate pinning with the Google
-    Play Services security provider.
-
-
-## Version 2.7.4
-
-_2016-02-07_
-
- *  Fix: Don't crash when finding the trust manager if the Play Services (GMS)
-    security provider is installed.
- *  Fix: The previous release introduced a performance regression on Android,
-    caused by looking up CA certificates. This is now fixed.
-
-
-## Version 2.7.3
-
-_2016-02-06_
-
- *  Fix: Permit the trusted CA root to be pinned by `CertificatePinner`.
-
-
-## Version 2.7.2
-
-_2016-01-07_
-
- *  Fix: Don't eagerly release stream allocations on cache hits. We might still
-    need them to handle redirects.
-
-
-## Version 2.7.1
-
-_2016-01-01_
-
- *  Fix: Don't do a health check on newly-created connections. This is
-    unnecessary work that could put the client in an inconsistent state if the
-    health check fails.
-
-
-## Version 2.7.0
-
-_2015-12-13_
-
- *  **Rewritten connection management.** Previously OkHttp's connection pool
-    managed both idle and active connections for HTTP/2, but only idle
-    connections for HTTP/1.x. With this update the connection pool manages both
-    idle and active connections for everything. OkHttp now detects and warns on
-    connections that were allocated but never released, and will enforce HTTP/2
-    stream limits. This update also fixes `Call.cancel()` to not do I/O on the
-    calling thread.
- *  Fix: Don't log gzipped data in the logging interceptor.
- *  Fix: Don't resolve DNS addresses when connecting through a SOCKS proxy.
- *  Fix: Drop the synthetic `OkHttp-Selected-Protocol` response header.
- *  Fix: Support 204 and 205 'No Content' replies in the logging interceptor.
- *  New: Add `Call.isExecuted()`.
-
-
-## Version 2.6.0
-
-_2015-11-22_
-
- *  **New Logging Interceptor.** The `logging-interceptor` subproject offers
-    simple request and response logging. It may be configured to log headers and
-    bodies for debugging. It requires this Maven dependency:
-
-     ```xml
-     <dependency>
-       <groupId>com.squareup.okhttp</groupId>
-       <artifactId>logging-interceptor</artifactId>
-       <version>2.6.0</version>
-     </dependency>
-     ```
-
-    Configure basic logging like this:
-
-    ```java
-    HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor();
-    loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BASIC);
-    client.networkInterceptors().add(loggingInterceptor);
-    ```
-
-    **Warning:** Avoid `Level.HEADERS` and `Level.BODY` in production because
-    they could leak passwords and other authentication credentials to insecure
-    logs.
-
- *  **WebSocket API now uses `RequestBody` and `ResponseBody` for messages.**
-    This is a backwards-incompatible API change.
-
- *  **The DNS service is now pluggable.** In some situations this may be useful
-    to manually prioritize specific IP addresses.
-
- *  Fix: Don't throw when converting an `HttpUrl` to a `java.net.URI`.
-    Previously URLs with special characters like `|` and `[` would break when
-    subjected to URI’s overly-strict validation.
- *  Fix: Don't re-encode `+` as `%20` in encoded URL query strings. OkHttp
-    prefers `%20` when doing its own encoding, but will retain `+` when that is
-    provided.
- *  Fix: Enforce that callers call `WebSocket.close()` on IO errors. Error
-    handling in WebSockets is significantly improved.
- *  Fix: Don't use SPDY/3 style header concatenation for HTTP/2 request headers.
-    This could have corrupted requests where multiple headers had the same name,
-    as in cookies.
- *  Fix: Reject bad characters in the URL hostname. Previously characters like
-    `\0` would cause a late crash when building the request.
- *  Fix: Allow interceptors to change the request method.
- *  Fix: Don’t use the request's `User-Agent` or `Proxy-Authorization` when
-    connecting to an HTTPS server via an HTTP tunnel. The `Proxy-Authorization`
-    header was being leaked to the origin server.
- *  Fix: Digits may be used in a URL scheme.
- *  Fix: Improve connection timeout recovery.
- *  Fix: Recover from `getsockname` crashes impacting Android releases prior to
-    4.2.2.
- *  Fix: Drop partial support for HTTP/1.0. Previously OkHttp would send
-    `HTTP/1.0` on connections after seeing a response with `HTTP/1.0`. The fixed
-    behavior is consistent with Firefox and Chrome.
- *  Fix: Allow a body in `OPTIONS` requests.
- *  Fix: Don't percent-encode non-ASCII characters in URL fragments.
- *  Fix: Handle null fragments.
- *  Fix: Don’t crash on interceptors that throw `IOException` before a
-    connection is attempted.
- *  New: Support [WebDAV][webdav] HTTP methods.
- *  New: Buffer WebSocket frames for better performance.
- *  New: Drop support for `TLS_DHE_DSS_WITH_AES_128_CBC_SHA`, our only remaining
-    DSS cipher suite. This is consistent with Firefox and Chrome which have also
-    dropped these cipher suite.
-
-## Version 2.5.0
-
-_2015-08-25_
-
- *  **Timeouts now default to 10 seconds.** Previously we defaulted to never
-    timing out, and that was a lousy policy. If establishing a connection,
-    reading the next byte from a connection, or writing the next byte to a
-    connection takes more than 10 seconds to complete, you’ll need to adjust
-    the timeouts manually.
-
- *  **OkHttp now rejects request headers that contain invalid characters.** This
-    includes potential security problems (newline characters) as well as simple
-    non-ASCII characters (including international characters and emoji).
-
- *  **Call canceling is more reliable.**  We had a bug where a socket being
-     connected wasn't being closed when the application used `Call.cancel()`.
-
- *  **Changing a HttpUrl’s scheme now tracks the default port.** We had a bug
-    where changing a URL from `http` to `https` would leave it on port 80.
-
- *  **Okio has been updated to 1.6.0.**
-     ```xml
-     <dependency>
-       <groupId>com.squareup.okio</groupId>
-       <artifactId>okio</artifactId>
-       <version>1.6.0</version>
-     </dependency>
-     ```
-
- *  New: `Cache.initialize()`. Call this on a background thread to eagerly
-    initialize the response cache.
- *  New: Fold `MockWebServerRule` into `MockWebServer`. This makes it easier to
-    write JUnit tests with `MockWebServer`. The `MockWebServer` library now
-    depends on JUnit, though it continues to work with all testing frameworks.
- *  Fix: `FormEncodingBuilder` is now consistent with browsers in which
-    characters it escapes. Previously we weren’t percent-encoding commas,
-    parens, and other characters.
- *  Fix: Relax `FormEncodingBuilder` to support building empty forms.
- *  Fix: Timeouts throw `SocketTimeoutException`, not `InterruptedIOException`.
- *  Fix: Change `MockWebServer` to use the same logic as OkHttp when determining
-    whether an HTTP request permits a body.
- *  Fix: `HttpUrl` now uses the canonical form for IPv6 addresses.
- *  Fix: Use `HttpUrl` internally.
- *  Fix: Recover from Android 4.2.2 EBADF crashes.
- *  Fix: Don't crash with an `IllegalStateException` if an HTTP/2 or SPDY
-    write fails, leaving the connection in an inconsistent state.
- *  Fix: Make sure the default user agent is ASCII.
-
-
-## Version 2.4.0
-
-_2015-05-22_
-
- *  **Forbid response bodies on HTTP 204 and 205 responses.** Webservers that
-    return such malformed responses will now trigger a `ProtocolException` in
-    the client.
-
- *  **WebSocketListener has incompatible changes.** The `onOpen()` method is now
-    called on the reader thread, so implementations must return before further
-    websocket messages will be delivered. The `onFailure()` method now includes
-    an HTTP response if one was returned.
-
-## Version 2.4.0-RC1
-
-_2015-05-16_
-
- *  **New HttpUrl API.** It's like `java.net.URL` but good. Note that
-    `Request.Builder.url()` now throws `IllegalArgumentException` on malformed
-    URLs. (Previous releases would throw a `MalformedURLException` when calling
-    a malformed URL.)
-
- *  **We've improved connect failure recovery.** We now differentiate between
-    setup, connecting, and connected and implement appropriate recovery rules
-    for each. This changes `Address` to no longer use `ConnectionSpec`. (This is
-    an incompatible API change).
-
- *  **`FormEncodingBuilder` now uses `%20` instead of `+` for encoded spaces.**
-    Both are permitted-by-spec, but `%20` requires fewer special cases.
-
- *  **Okio has been updated to 1.4.0.**
-     ```xml
-     <dependency>
-       <groupId>com.squareup.okio</groupId>
-       <artifactId>okio</artifactId>
-       <version>1.4.0</version>
-     </dependency>
-     ```
-
- *  **`Request.Builder` no longer accepts null if a request body is required.**
-    Passing null will now fail for request methods that require a body. Instead
-    use an empty body such as this one:
-
-    ```java
-        RequestBody.create(null, new byte[0]);
-    ```
-
- * **`CertificatePinner` now supports wildcard hostnames.** As always with
-   certificate pinning, you must be very careful to avoid [bricking][brick]
-   your app. You'll need to pin both the top-level domain and the `*.` domain
-   for full coverage.
-
-    ```java
-     client.setCertificatePinner(new CertificatePinner.Builder()
-         .add("publicobject.com",   "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
-         .add("*.publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
-         .add("publicobject.com",   "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
-         .add("*.publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
-         .add("publicobject.com",   "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
-         .add("*.publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
-         .add("publicobject.com",   "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
-         .add("*.publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
-         .build());
-    ```
-
- *  **Interceptors lists are now deep-copied by `OkHttpClient.clone()`.**
-    Previously clones shared interceptors, which made it difficult to customize
-    the interceptors on a request-by-request basis.
-
- *  New: `Headers.toMultimap()`.
- *  New: `RequestBody.create(MediaType, ByteString)`.
- *  New: `ConnectionSpec.isCompatible(SSLSocket)`.
- *  New: `Dispatcher.getQueuedCallCount()` and
-    `Dispatcher.getRunningCallCount()`. These can be useful in diagnostics.
- *  Fix: OkHttp no longer shares timeouts between pooled connections. This was
-    causing some applications to crash when connections were reused.
- *  Fix: `OkApacheClient` now allows an empty `PUT` and `POST`.
- *  Fix: Websockets no longer rebuffer socket streams.
- *  Fix: Websockets are now better at handling close frames.
- *  Fix: Content type matching is now case insensitive.
- *  Fix: `Vary` headers are not lost with `android.net.http.HttpResponseCache`.
- *  Fix: HTTP/2 wasn't enforcing stream timeouts when writing the underlying
-    connection. Now it is.
- *  Fix: Never return null on `call.proceed()`. This was a bug in call
-    cancelation.
- *  Fix: When a network interceptor mutates a request, that change is now
-    reflected in `Response.networkResponse()`.
- *  Fix: Badly-behaving caches now throw a checked exception instead of a
-    `NullPointerException`.
- *  Fix: Better handling of uncaught exceptions in MockWebServer with HTTP/2.
-
-## Version 2.3.0
-
-_2015-03-16_
-
- *  **HTTP/2 support.** We've done interop testing and haven't seen any
-    problems. HTTP/2 support has been a big effort and we're particularly
-    thankful to Adrian Cole who has helped us to reach this milestone.
-
- *  **RC4 cipher suites are no longer supported by default.** To connect to
-    old, obsolete servers relying on these cipher suites, you must create a
-    custom `ConnectionSpec`.
-
- *  **Beta WebSockets support.**. The `okhttp-ws` subproject offers a new
-    websockets client. Please try it out! When it's ready we intend to include
-    it with the core OkHttp library.
-
- *  **Okio updated to 1.3.0.**
-
-    ```xml
-    <dependency>
-      <groupId>com.squareup.okio</groupId>
-      <artifactId>okio</artifactId>
-      <version>1.3.0</version>
-    </dependency>
-    ```
-
- *  **Fix: improve parallelism of async requests.** OkHttp's Dispatcher had a
-    misconfigured `ExecutorService` that limited the number of worker threads.
-    If you're using `Call.enqueue()` this update should significantly improve
-    request concurrency.
-
- *  **Fix: Lazily initialize the response cache.** This avoids strict mode
-    warnings when initializing OkHttp on Android‘s main thread.
-
- *  **Fix: Disable ALPN on Android 4.4.** That release of the feature was
-    unstable and prone to native crashes in the underlying OpenSSL code.
- *  Fix: Don't send both `If-None-Match` and `If-Modified-Since` cache headers
-    when both are applicable.
- *  Fix: Fail early when a port is out of range.
- *  Fix: Offer `Content-Length` headers for multipart request bodies.
- *  Fix: Throw `UnknownServiceException` if a cleartext connection is attempted
-    when explicitly forbidden.
- *  Fix: Throw a `SSLPeerUnverifiedException` when host verification fails.
- *  Fix: MockWebServer explicitly closes sockets. (On some Android releases,
-    closing the input stream and output stream of a socket is not sufficient.
- *  Fix: Buffer outgoing HTTP/2 frames to limit how many outgoing frames are
-    created.
- *  Fix: Avoid crashing when cache writing fails due to a full disk.
- *  Fix: Improve caching of private responses.
- *  Fix: Update cache-by-default response codes.
- *  Fix: Reused `Request.Builder` instances no longer hold stale URL fields.
- *  New: ConnectionSpec can now be configured to use the SSL socket's default
-    cipher suites. To use, set the cipher suites to `null`.
- *  New: Support `DELETE` with a request body.
- *  New: `Headers.of(Map)` creates headers from a Map.
-
-
-## Version 2.2.0
-
-_2014-12-30_
-
- *  **`RequestBody.contentLength()` now throws `IOException`.**
-    This is a source-incompatible change. If you have code that calls
-    `RequestBody.contentLength()`, your compile will break with this
-    update. The change is binary-compatible, however: code compiled
-    for OkHttp 2.0 and 2.1 will continue to work with this update.
-
- *  **`COMPATIBLE_TLS` no longer supports SSLv3.** In response to the
-    [POODLE](https://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html)
-    vulnerability, OkHttp no longer offers SSLv3 when negotiation an
-    HTTPS connection. If you continue to need to connect to webservers
-    running SSLv3, you must manually configure your own `ConnectionSpec`.
-
- *  **OkHttp now offers interceptors.** Interceptors are a powerful mechanism
-    that can monitor, rewrite, and retry calls. The [project
-    wiki](https://github.com/square/okhttp/wiki/Interceptors) has a full
-    introduction to this new API.
-
- *  New: APIs to iterate and selectively clear the response cache.
- *  New: Support for SOCKS proxies.
- *  New: Support for `TLS_FALLBACK_SCSV`.
- *  New: Update HTTP/2 support to `h2-16` and `hpack-10`.
- *  New: APIs to prevent retrying non-idempotent requests.
- *  Fix: Drop NPN support. Going forward we support ALPN only.
- *  Fix: The hostname verifier is now strict. This is consistent with the hostname
-    verifier in modern browsers.
- *  Fix: Improve `CONNECT` handling for misbehaving HTTP proxies.
- *  Fix: Don't retry requests that failed due to timeouts.
- *  Fix: Cache 302s and 308s that include appropriate response headers.
- *  Fix: Improve pooling of connections that use proxy selectors.
- *  Fix: Don't leak connections when using ALPN on the desktop.
- *  Fix: Update Jetty ALPN to `7.1.2.v20141202` (Java 7) and `8.1.2.v20141202` (Java 8).
-    This fixes a bug in resumed TLS sessions where the wrong protocol could be
-    selected.
- *  Fix: Don't crash in SPDY and HTTP/2 when disconnecting before connecting.
- *  Fix: Avoid a reverse DNS-lookup for a numeric proxy address
- *  Fix: Resurrect http/2 frame logging.
- *  Fix: Limit to 20 authorization attempts.
-
-## Version 2.1.0
-
-_2014-11-11_
-
- *  New: Typesafe APIs for interacting with cipher suites and TLS versions.
- *  Fix: Don't crash when mixing authorization challenges with upload retries.
-
-
-## Version 2.1.0-RC1
-
-_2014-11-04_
-
- *  **OkHttp now caches private responses**. We've changed from a shared cache
-    to a private cache, and will now store responses that use an `Authorization`
-    header. This means OkHttp's cache shouldn't be used on middleboxes that sit
-    between user agents and the origin server.
-
- *  **TLS configuration updated.** OkHttp now explicitly enables TLSv1.2,
-    TLSv1.1 and TLSv1.0 where they are supported. It will continue to perform
-    only one fallback, to SSLv3. Applications can now configure this with the
-    `ConnectionSpec` class.
-
-    To disable TLS fallback:
-
-    ```java
-    client.setConnectionSpecs(Arrays.asList(
-        ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT));
-    ```
-
-    To disable cleartext connections, permitting `https` URLs only:
-
-    ```java
-    client.setConnectionSpecs(Arrays.asList(
-        ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS));
-    ```
-
- *  **New cipher suites.** Please confirm that your webservers are reachable
-    with this limited set of cipher suites.
-
-    ```
-                                             Android
-    Name                                     Version
-
-    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256  5.0
-    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256    5.0
-    TLS_DHE_RSA_WITH_AES_128_GCM_SHA256      5.0
-    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA     4.0
-    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA     4.0
-    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA       4.0
-    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA       4.0
-    TLS_ECDHE_ECDSA_WITH_RC4_128_SHA         4.0
-    TLS_ECDHE_RSA_WITH_RC4_128_SHA           4.0
-    TLS_DHE_RSA_WITH_AES_128_CBC_SHA         2.3
-    TLS_DHE_DSS_WITH_AES_128_CBC_SHA         2.3
-    TLS_DHE_RSA_WITH_AES_256_CBC_SHA         2.3
-    TLS_RSA_WITH_AES_128_GCM_SHA256          5.0
-    TLS_RSA_WITH_AES_128_CBC_SHA             2.3
-    TLS_RSA_WITH_AES_256_CBC_SHA             2.3
-    SSL_RSA_WITH_3DES_EDE_CBC_SHA            2.3  (Deprecated in 5.0)
-    SSL_RSA_WITH_RC4_128_SHA                 2.3
-    SSL_RSA_WITH_RC4_128_MD5                 2.3  (Deprecated in 5.0)
-    ```
-
- *  **Okio updated to 1.0.1.**
-
-    ```xml
-    <dependency>
-      <groupId>com.squareup.okio</groupId>
-      <artifactId>okio</artifactId>
-      <version>1.0.1</version>
-    </dependency>
-    ```
-
- *  **New APIs to permit easy certificate pinning.** Be warned, certificate
-    pinning is dangerous and could prevent your application from trusting your
-    server!
-
- *  **Cache improvements.** This release fixes some severe cache problems
-    including a bug where the cache could be corrupted upon certain access
-    patterns. We also fixed a bug where the cache was being cleared due to a
-    corrupted journal. We've added APIs to configure a request's `Cache-Control`
-    headers, and to manually clear the cache.
-
- *  **Request cancellation fixes.** This update fixes a bug where synchronous
-    requests couldn't be canceled by tag. This update avoids crashing when
-    `onResponse()` throws an `IOException`. That failure will now be logged
-    instead of notifying the thread's uncaught exception handler. We've added a
-    new API, `Call.isCanceled()` to check if a call has been canceled.
-
- *  New: Update `MultipartBuilder` to support content length.
- *  New: Make it possible to mock `OkHttpClient` and `Call`.
- *  New: Update to h2-14 and hpack-9.
- *  New: OkHttp includes a user-agent by default, like `okhttp/2.1.0-RC1`.
- *  Fix: Handle response code `308 Permanent Redirect`.
- *  Fix: Don't skip the callback if a call is canceled.
- *  Fix: Permit hostnames with underscores.
- *  Fix: Permit overriding the content-type in `OkApacheClient`.
- *  Fix: Use the socket factory for direct connections.
- *  Fix: Honor `OkUrlFactory` APIs that disable redirects.
- *  Fix: Don't crash on concurrent modification of `SPDY` SPDY settings.
-
-## Version 2.0.0
-
-This release commits to a stable 2.0 API. Read the 2.0.0-RC1 changes for advice
-on upgrading from 1.x to 2.x.
-
-_2014-06-21_
-
- *  **API Change**: Use `IOException` in `Callback.onFailure()`. This is
-    a source-incompatible change, and is different from OkHttp 2.0.0-RC2 which
-    used `Throwable`.
- *  Fix: Fixed a caching bug where we weren't storing rewritten request headers
-    like `Accept-Encoding`.
- *  Fix: Fixed bugs in handling the SPDY window size. This was stalling certain
-    large downloads
- *  Update the language level to Java 7. (OkHttp requires Android 2.3+ or Java 7+.)
-
-## Version 2.0.0-RC2
-
-_2014-06-11_
-
-This update fixes problems in 2.0.0-RC1. Read the 2.0.0-RC1 changes for
-advice on upgrading from 1.x to 2.x.
-
- *  Fix: Don't leak connections! There was a regression in 2.0.0-RC1 where
-    connections were neither closed nor pooled.
- *  Fix: Revert builder-style return types from OkHttpClient's timeout methods
-    for binary compatibility with OkHttp 1.x.
- *  Fix: Don't skip client stream 1 on SPDY/3.1. This fixes SPDY connectivity to
-    `https://google.com`, which doesn't follow the SPDY/3.1 spec!
- *  Fix: Always configure NPN headers. This fixes connectivity to
-    `https://facebook.com` when SPDY and HTTP/2 are both disabled. Otherwise an
-    unexpected NPN response is received and OkHttp crashes.
- *  Fix: Write continuation frames when HPACK data is larger than 16383 bytes.
- *  Fix: Don't drop uncaught exceptions thrown in async calls.
- *  Fix: Throw an exception eagerly when a request body is not legal. Previously
-    we ignored the problem at request-building time, only to crash later with a
-    `NullPointerException`.
- *  Fix: Include a backwards-compatible `OkHttp-Response-Source` header with
-    `OkUrlFactory `responses.
- *  Fix: Don't include a default User-Agent header in requests made with the Call
-    API. Requests made with OkUrlFactory will continue to have a default user
-    agent.
- *  New: Guava-like API to create headers:
-
-    ```java
-    Headers headers = Headers.of(name1, value1, name2, value2, ...).
-    ```
-
- *  New: Make the content-type header optional for request bodies.
- *  New: `Response.isSuccessful()` is a convenient API to check response codes.
- *  New: The response body can now be read outside of the callback. Response
-    bodies must always be closed, otherwise they will leak connections!
- *  New: APIs to create multipart request bodies (`MultipartBuilder`) and form
-    encoding bodies (`FormEncodingBuilder`).
-
-## Version 2.0.0-RC1
-
-_2014-05-23_
-
-OkHttp 2 is designed around a new API that is true to HTTP, with classes for
-requests, responses, headers, and calls. It uses modern Java patterns like
-immutability and chained builders. The API now offers asynchronous callbacks
-in addition to synchronous blocking calls.
-
-#### API Changes
-
- *  **New Request and Response types,** each with their own builder. There's also
-    a `RequestBody` class to write the request body to the network and a
-    `ResponseBody` to read the response body from the network. The standalone
-    `Headers` class offers full access to the HTTP headers.
-
- *  **Okio dependency added.** OkHttp now depends on
-    [Okio](https://github.com/square/okio), an I/O library that makes it easier
-    to access, store and process data. Using this library internally makes OkHttp
-    faster while consuming less memory. You can write a `RequestBody` as an Okio
-    `BufferedSink` and a `ResponseBody` as an Okio `BufferedSource`. Standard
-    `InputStream` and `OutputStream` access is also available.
-
- *  **New Call and Callback types** execute requests and receive their
-    responses. Both types of calls can be canceled via the `Call` or the
-    `OkHttpClient`.
-
- *  **URLConnection support has moved to the okhttp-urlconnection module.**
-    If you're upgrading from 1.x, this change will impact you. You will need to
-    add the `okhttp-urlconnection` module to your project and use the
-    `OkUrlFactory` to create new instances of `HttpURLConnection`:
-
-    ```java
-    // OkHttp 1.x:
-    HttpURLConnection connection = client.open(url);
-
-    // OkHttp 2.x:
-    HttpURLConnection connection = new OkUrlFactory(client).open(url);
-    ```
-
- *  **Custom caches are no longer supported.** In OkHttp 1.x it was possible to
-    define your own response cache with the `java.net.ResponseCache` and OkHttp's
-    `OkResponseCache` interfaces. Both of these APIs have been dropped. In
-    OkHttp 2 the built-in disk cache is the only supported response cache.
-
- *  **HttpResponseCache has been renamed to Cache.** Install it with
-    `OkHttpClient.setCache(...)` instead of `OkHttpClient.setResponseCache(...)`.
-
- *  **OkAuthenticator has been replaced with Authenticator.** This new
-    authenticator has access to the full incoming response and can respond with
-    whichever followup request is appropriate. The `Challenge` class is now a
-    top-level class and `Credential` is replaced with a utility class called
-    `Credentials`.
-
- *  **OkHttpClient.getFollowProtocolRedirects() renamed to
-    getFollowSslRedirects()**. We reserve the word _protocol_ for the HTTP
-    version being used (HTTP/1.1, HTTP/2). The old name of this method was
-    misleading; it was always used to configure redirects between `https://` and
-    `http://` schemes.
-
- *  **RouteDatabase is no longer public API.** OkHttp continues to track which
-    routes have failed but this is no exposed in the API.
-
- *  **ResponseSource is gone.** This enum exposed whether a response came from
-    the cache, network, or both. OkHttp 2 offers more detail with raw access to
-    the cache and network responses in the new `Response` class.
-
- *  **TunnelRequest is gone.** It specified how to connect to an HTTP proxy.
-    OkHttp 2 uses the new `Request` class for this.
-
- *  **Dispatcher** is a new class that manages the queue of asynchronous calls. It
-    implements limits on total in-flight calls and in-flight calls per host.
-
-#### Implementation changes
-
- * Support Android `TrafficStats` socket tagging.
- * Drop authentication headers on redirect.
- * Added support for compressed data frames.
- * Process push promise callbacks in order.
- * Update to http/2 draft 12.
- * Update to HPACK draft 07.
- * Add ALPN support. Maven will use ALPN on OpenJDK 8.
- * Update NPN dependency to target `jdk7u60-b13` and `Oracle jdk7u55-b13`.
- * Ensure SPDY variants support zero-length DELETE and POST.
- * Prevent leaking a cache item's InputStreams when metadata read fails.
- * Use a string to identify TLS versions in routes.
- * Add frame logger for HTTP/2.
- * Replacing `httpMinorVersion` with `Protocol`. Expose HTTP/1.0 as a potential protocol.
- * Use `Protocol` to describe framing.
- * Implement write timeouts for HTTP/1.1 streams.
- * Avoid use of SPDY stream ID 1, as that's typically used for UPGRADE.
- * Support OAuth in `Authenticator`.
- * Permit a dangling semicolon in media type parsing.
-
-## Version 1.6.0
-
-_2014-05-23_
-
- * Offer bridges to make it easier to migrate from OkHttp 1.x to OkHttp 2.0.
-   This adds `OkUrlFactory`, `Cache`, and `@Deprecated` annotations for APIs
-   dropped in 2.0.
-
-## Version 1.5.4
-
-_2014-04-14_
-
- * Drop ALPN support in Android. There's a concurrency bug in all
-   currently-shipping versions.
- * Support asynchronous disconnects by breaking the socket only. This should
-   prevent flakiness from multiple threads concurrently accessing a stream.
-
-## Version 1.5.3
-
-_2014-03-29_
-
- * Fix bug where the Content-Length header was not always dropped when
-   following a redirect from a POST to a GET.
- * Implement basic support for `Thread.interrupt()`. OkHttp now checks
-   for an interruption before doing a blocking call. If it is interrupted,
-   it throws an `InterruptedIOException`.
-
-## Version 1.5.2
-
-_2014-03-17_
-
- * Fix bug where deleting a file that was absent from the `HttpResponseCache`
-   caused an IOException.
- * Fix bug in HTTP/2 where our HPACK decoder wasn't emitting entries in
-   certain eviction scenarios, leading to dropped response headers.
-
-## Version 1.5.1
-
-_2014-03-11_
-
- * Fix 1.5.0 regression where connections should not have been recycled.
- * Fix 1.5.0 regression where transparent Gzip was broken by attempting to
-   recover from another I/O failure.
- * Fix problems where spdy/3.1 headers may not have been compressed properly.
- * Fix problems with spdy/3.1 and http/2 where the wrong window size was being
-   used.
- * Fix 1.5.0 regression where conditional cache responses could corrupt the
-   connection pool.
-
-
-## Version 1.5.0
-
-_2014-03-07_
-
-
-##### OkHttp no longer uses the default SSL context.
-
-Applications that want to use the global SSL context with OkHttp should configure their
-OkHttpClient instances with the following:
-
-```java
-okHttpClient.setSslSocketFactory(HttpsURLConnection.getDefaultSSLSocketFactory());
-```
-
-A simpler solution is to avoid the shared default SSL socket factory. Instead, if you
-need to customize SSL, do so for your specific OkHttpClient instance only.
-
-##### Synthetic headers have changed
-
-Previously OkHttp added a synthetic response header, `OkHttp-Selected-Transport`. It
-has been replaced with a new synthetic header, `OkHttp-Selected-Protocol`.
-
-##### Changes
-
- * New: Support for `HTTP-draft-09/2.0`.
- * New: Support for `spdy/3.1`. Dropped support for `spdy/3`.
- * New: Use ALPN on Android platforms that support it (4.4+)
- * New: CacheControl model and parser.
- * New: Protocol selection in MockWebServer.
- * Fix: Route selection shouldn't use TLS modes that we know will fail.
- * Fix: Cache SPDY responses even if the response body is closed prematurely.
- * Fix: Use strict timeouts when aborting a download.
- * Fix: Support Shoutcast HTTP responses like `ICY 200 OK`.
- * Fix: Don't unzip if there isn't a response body.
- * Fix: Don't leak gzip streams on redirects.
- * Fix: Don't do DNS lookups on invalid hosts.
- * Fix: Exhaust the underlying stream when reading gzip streams.
- * Fix: Support the `PATCH` method.
- * Fix: Support request bodies on `DELETE` method.
- * Fix: Drop the `okhttp-protocols` module.
- * Internal: Replaced internal byte array buffers with pooled buffers ("OkBuffer").
-
-
-## Version 1.3.0
-
-_2014-01-11_
-
- * New: Support for "PATCH" HTTP method in client and MockWebServer.
- * Fix: Drop `Content-Length` header when redirected from POST to GET.
- * Fix: Correctly read cached header entries with malformed header names.
- * Fix: Do not directly support any authentication schemes other than "Basic".
- * Fix: Respect read timeouts on recycled connections.
- * Fix: Transmit multiple cookie values as a single header with delimiter.
- * Fix: Ensure `null` is never returned from a connection's `getHeaderFields()`.
- * Fix: Persist proper `Content-Encoding` header to cache for GZip responses.
- * Fix: Eliminate rare race condition in SPDY streams that would prevent connection reuse.
- * Fix: Change HTTP date formats to UTC to conform to RFC2616 section 3.3.
- * Fix: Support SPDY header blocks with trailing bytes.
- * Fix: Allow `;` as separator for `Cache-Control` header.
- * Fix: Correct bug where HTTPS POST requests were always automatically buffered.
- * Fix: Honor read timeout when parsing SPDY headers.
-
-
-## Version 1.2.1
-
-_2013-08-23_
-
- * Resolve issue with 'jar-with-dependencies' artifact creation.
- * Fix: Support empty SPDY header values.
-
-
-## Version 1.2.0
-
-_2013-08-11_
-
- *  New APIs on OkHttpClient to set default timeouts for connect and read.
- *  Fix bug when caching SPDY responses.
- *  Fix a bug with SPDY plus half-closed streams. (thanks kwuollett)
- *  Fix a bug in `Content-Length` reporting for gzipped streams in the Apache
-    HTTP client adapter. (thanks kwuollett)
- *  Work around the Alcatel `getByInetAddress` bug (thanks k.kocel)
- *  Be more aggressive about testing pooled sockets before reuse. (thanks
-    warpspin)
- *  Include `Content-Type` and `Content-Encoding` in the Apache HTTP client
-    adapter. (thanks kwuollett)
- *  Add a media type class to OkHttp.
- *  Change custom header prefix:
-
-    ```
-    X-Android-Sent-Millis is now OkHttp-Sent-Millis
-    X-Android-Received-Millis is now OkHttp-Received-Millis
-    X-Android-Response-Source is now OkHttp-Response-Source
-    X-Android-Selected-Transport is now OkHttp-Selected-Transport
-    ```
- *  Improve cache invalidation for POST-like requests.
- *  Bring MockWebServer into OkHttp and teach it SPDY.
 
+## Version 4.0.0
 
-## Version 1.1.1
+_2019-06-26_
 
-_2013-06-23_
+**This release upgrades OkHttp to Kotlin.** We tried our best to make fast and safe to upgrade
+from OkHttp 3.x. We wrote an [upgrade guide][upgrading_to_okhttp_4] to help with the migration and a
+[blog post][okhttp4_blog_post] to explain it.
 
- * Fix: ClassCastException when caching responses that were redirected from
-   HTTP to HTTPS.
+ *  Fix: Target Java 8 bytecode for Java and Kotlin.
 
 
-## Version 1.1.0
+## Version 4.0.0-RC3
 
-_2013-06-15_
+_2019-06-24_
 
- * Fix: Connection reuse was broken for most HTTPS connections due to a bug in
-   the way the hostname verifier was selected.
- * Fix: Locking bug in SpdyConnection.
- * Fix: Ignore null header values (for compatibility with HttpURLConnection).
- * Add URLStreamHandlerFactory support so that `URL.openConnection()` uses
-   OkHttp.
- * Expose the transport ("http/1.1", "spdy/3", etc.) via magic request headers.
-   Use `X-Android-Transports` to write the preferred transports and
-   `X-Android-Selected-Transport` to read the negotiated transport.
+ *  Fix: Retain binary-compatibility in `okhttp3.internal.HttpMethod`. Naughty third party SDKs
+    import this and we want to ease upgrades for their users.
 
 
-## Version 1.0.2
+## Version 4.0.0-RC2
 
-_2013-05-11_
+_2019-06-21_
 
- * Fix: Remove use of Java 6-only APIs.
- * Fix: Properly handle exceptions from `NetworkInterface` when querying MTU.
- * Fix: Ensure MTU has a reasonable default and upper-bound.
+ *  New: Require Kotlin 1.3.40.
+ *  New: Change the Kotlin API from `File.toRequestBody()` to `File.asRequestBody()` and
+    `BufferedSource.toResponseBody()` to `BufferedSource.asResponseBody()`. If the returned value
+    is a view of what created it, we use _as_.
+ *  Fix: Permit response codes of zero for compatibility with OkHttp 3.x.
+ *  Fix: Change the return type of `MockWebServer.takeRequest()` to be nullable.
+ *  Fix: Make `Call.clone()` public to Kotlin callers.
 
 
-## Version 1.0.1
+## Version 4.0.0-RC1
 
-_2013-05-06_
+_2019-06-03_
 
- * Correct casing of SSL in method names (`getSslSocketFactory`/`setSslSocketFactory`).
+ *  First stable preview of OkHttp 4.
 
 
-## Version 1.0.0
+## Version 3.x
 
-_2013-05-06_
+[Change log](http://square.github.io/okhttp/changelog_3x/)
 
-Initial release.
 
- [brick]: https://noncombatant.org/2015/05/01/about-http-public-key-pinning/
- [webdav]: https://tools.ietf.org/html/rfc4918
- [major_versions]: http://jakewharton.com/java-interoperability-policy-for-major-version-updates/
- [nginx_959]: https://trac.nginx.org/nginx/ticket/959
- [okhttp_idling_resource]: https://github.com/JakeWharton/okhttp-idling-resource
- [bom]: https://en.wikipedia.org/wiki/Byte_order_mark
- [junit_5_rules]: https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4-rulesupport
- [public_suffix]: https://publicsuffix.org/
- [maven_provided]: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html
- [remove_cbc_ecdsa]: https://developers.google.com/web/updates/2016/12/chrome-56-deprecations#remove_cbc-mode_ecdsa_ciphers_in_tls
- [conscrypt]: https://github.com/google/conscrypt/
- [conscrypt_dependency]: https://github.com/google/conscrypt/#download
- [https_server_sample]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
- [require_android_5]: https://medium.com/square-corner-blog/okhttp-3-13-requires-android-5-818bb78d07ce
- [obsolete_apache_client]: https://gist.github.com/swankjesse/09721f72039e3a46cf50f94323deb82d
- [obsolete_url_factory]: https://gist.github.com/swankjesse/dd91c0a8854e1559b00f5fc9c7bfae70
- [tls_configuration_history]: https://github.com/square/okhttp/wiki/TLS-Configuration-History
- [grpc_http2]: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md
+ [iana_websocket]: https://www.iana.org/assignments/websocket/websocket.txt
+ [okhttp4_blog_post]: https://cashapp.github.io/2019-06-26/okhttp-4-goes-kotlin
+ [upgrading_to_okhttp_4]: https://square.github.io/okhttp/upgrading_to_okhttp_4/
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 0000000000..e0e216ec47
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,45 @@
+Contributing
+============
+
+Keeping the project small and stable limits our ability to accept new contributors. We are not
+seeking new committers at this time, but some small contributions are welcome.
+
+If you've found a security problem, please follow our [bug bounty][security] program.
+
+If you've found a bug, please contribute a failing test case so we can study and fix it.
+
+If you have a new feature idea, please build it in an external library. There are
+[many libraries][works_with_okhttp] that sit on top or hook in via existing APIs. If you build
+something that integrates with OkHttp, tell us so that we can link it!
+
+Before code can be accepted all contributors must complete our
+[Individual Contributor License Agreement (CLA)][cla].
+
+
+Code Contributions
+------------------
+
+Get working code on a personal branch with tests passing before you submit a PR:
+
+```
+./gradlew clean check
+```
+
+Please make every effort to follow existing conventions and style in order to keep the code as
+readable as possible.
+
+Contribute code changes through GitHub by forking the repository and sending a pull request. We
+squash all pull requests on merge.
+
+
+Committer's Guides
+------------------
+
+ * [Concurrency][concurrency]
+ * [Releasing][releasing]
+
+ [cla]: https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1
+ [concurrency]: http://square.github.io/okhttp/concurrency/
+ [releasing]: http://square.github.io/okhttp/releasing/
+ [security]: http://square.github.io/okhttp/security/
+ [works_with_okhttp]: http://square.github.io/okhttp/works_with_okhttp/
diff --git a/README.md b/README.md
index b2a7a59ed3..4077be843d 100644
--- a/README.md
+++ b/README.md
@@ -1,8 +1,72 @@
 OkHttp
 ======
 
-An HTTP & HTTP/2 client for Android and Java applications. For more information see [the
-website][website] and [the wiki][wiki].
+See the [project website][okhttp] for documentation and APIs.
+
+HTTP is the way modern applications network. It’s how we exchange data & media. Doing HTTP
+efficiently makes your stuff load faster and saves bandwidth.
+
+OkHttp is an HTTP client that’s efficient by default:
+
+ * HTTP/2 support allows all requests to the same host to share a socket.
+ * Connection pooling reduces request latency (if HTTP/2 isn’t available).
+ * Transparent GZIP shrinks download sizes.
+ * Response caching avoids the network completely for repeat requests.
+
+OkHttp perseveres when the network is troublesome: it will silently recover from common connection
+problems. If your service has multiple IP addresses OkHttp will attempt alternate addresses if the
+first connect fails. This is necessary for IPv4+IPv6 and for services hosted in redundant data
+centers. OkHttp supports modern TLS features (TLS 1.3, ALPN, certificate pinning). It can be
+configured to fall back for broad connectivity.
+
+Using OkHttp is easy. Its request/response API is designed with fluent builders and immutability. It
+supports both synchronous blocking calls and async calls with callbacks.
+
+
+Get a URL
+---------
+
+This program downloads a URL and prints its contents as a string. [Full source][get_example].
+
+```java
+OkHttpClient client = new OkHttpClient();
+
+String run(String url) throws IOException {
+  Request request = new Request.Builder()
+      .url(url)
+      .build();
+
+  try (Response response = client.newCall(request).execute()) {
+    return response.body().string();
+  }
+}
+```
+
+
+Post to a Server
+----------------
+
+This program posts data to a service. [Full source][post_example].
+
+```java
+public static final MediaType JSON
+    = MediaType.get("application/json; charset=utf-8");
+
+OkHttpClient client = new OkHttpClient();
+
+String post(String url, String json) throws IOException {
+  RequestBody body = RequestBody.create(json, JSON);
+  Request request = new Request.Builder()
+      .url(url)
+      .post(body)
+      .build();
+  try (Response response = client.newCall(request).execute()) {
+    return response.body().string();
+  }
+}
+```
+
+Further examples are on the [OkHttp Recipes page][recipes].
 
 
 Requirements
@@ -10,8 +74,7 @@ Requirements
 
 OkHttp works on Android 5.0+ (API level 21+) and on Java 8+.
 
-OkHttp has one library dependency on [Okio][okio], a small library for high-performance I/O. It
-works with either Okio 1.x (implemented in Java) or Okio 2.x (upgraded to Kotlin).
+OkHttp depends on [Okio][okio] for high-performance I/O and the [Kotlin standard library][kotlin]. Both are small libraries with strong backwards-compatibility.
 
 We highly recommend you keep OkHttp up-to-date. As with auto-updating web browsers, staying current
 with HTTPS clients is an important defense against potential security problems. [We
@@ -30,63 +93,65 @@ The OkHttp 3.12.x branch supports Android 2.3+ (API level 9+) and Java 7+. These
 support for TLS 1.2 and should not be used. But because upgrading is difficult we will backport
 critical fixes to the [3.12.x branch][okhttp_312x] through December 31, 2020.
 
-Download
+
+Releases
 --------
 
-Download [the latest JAR][okhttp_latest_jar] or configure this dependency:
+Our [change log][changelog] has release history.
 
 ```kotlin
-implementation("com.squareup.okhttp3:okhttp:3.14.1")
+implementation("com.squareup.okhttp3:okhttp:4.1.1")
 ```
 
-Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
+Snapshot builds are [available][snap].
 
 
-MockWebServer
+R8 / ProGuard
 -------------
 
-A library for testing HTTP, HTTPS, and HTTP/2 clients.
-
-MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2 so that code can be shared.
+If you are using R8 or ProGuard add the options from [`okhttp3.pro`][okhttp3_pro].
 
-### Download
+You might also need rules for Okio which is a dependency of this library.
 
-Download [the latest JAR][mockwebserver_latest_jar] or configure this dependency:
-```xml
-testImplementation("com.squareup.okhttp3:mockwebserver:3.14.1")
-```
 
-R8 / ProGuard
+MockWebServer
 -------------
 
-If you are using R8 or ProGuard add the options from [`okhttp3.pro`][okhttp3_pro].
+OkHttp includes a library for testing HTTP, HTTPS, and HTTP/2 clients.
 
-You might also need rules for Okio which is a dependency of this library.
+```kotlin
+testImplementation("com.squareup.okhttp3:mockwebserver:4.1.1")
+```
 
 
 License
 -------
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+```
+Copyright 2019 Square, Inc.
 
-       http://www.apache.org/licenses/LICENSE-2.0
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
+   http://www.apache.org/licenses/LICENSE-2.0
 
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+```
 
+ [changelog]: http://square.github.io/okhttp/changelog/
  [conscrypt]: https://github.com/google/conscrypt/
- [mockwebserver_latest_jar]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=mockwebserver&v=LATEST
+ [get_example]: https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/GetExample.java
+ [kotlin]: https://kotlinlang.org/
+ [okhttp3_pro]: https://github.com/square/okhttp/blob/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
  [okhttp_312x]: https://github.com/square/okhttp/tree/okhttp_3.12.x
- [okhttp_latest_jar]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST
- [okio]: https://github.com/square/okio/
+ [okhttp]: https://square.github.io/okhttp/
+ [okio]: https://github.com/square/okio
+ [post_example]: https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/PostExample.java
+ [recipes]: http://square.github.io/okhttp/recipes/
  [snap]: https://oss.sonatype.org/content/repositories/snapshots/
- [tls_history]: https://github.com/square/okhttp/wiki/TLS-Configuration-History
- [website]: https://square.github.io/okhttp
- [wiki]: https://github.com/square/okhttp/wiki
- [okhttp3_pro]: https://github.com/square/okhttp/blob/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
+ [tls_history]: https://square.github.io/okhttp/tls_configuration_history/
diff --git a/android-test/build.gradle b/android-test/build.gradle
new file mode 100644
index 0000000000..d521be6791
--- /dev/null
+++ b/android-test/build.gradle
@@ -0,0 +1,42 @@
+apply plugin: 'com.android.library'
+apply plugin: 'org.jetbrains.kotlin.android'
+
+repositories {
+  jcenter {
+    // Required for a dependency of Android lint.
+    content {
+      includeGroup 'org.jetbrains.trove4j'
+    }
+  }
+}
+
+android {
+  compileOptions {
+    sourceCompatibility JavaVersion.VERSION_1_8
+    targetCompatibility JavaVersion.VERSION_1_8
+  }
+
+  compileSdkVersion 29
+
+  defaultConfig {
+    minSdkVersion 21
+    targetSdkVersion 29
+    versionCode 1
+    versionName "1.0"
+
+    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+  }
+}
+
+dependencies {
+  implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:${versions.kotlin}"
+  implementation project(':okhttp')
+  testImplementation 'junit:junit:4.12'
+  androidTestImplementation(project(':okhttp-testing-support')) {
+     exclude group: 'org.openjsse', module: 'openjsse'
+  }
+  androidTestImplementation project(':mockwebserver')
+  androidTestImplementation project(':okhttp-tls')
+  androidTestImplementation 'com.android.support.test:runner:1.0.2'
+  androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
+}
diff --git a/android-test/settings.gradle b/android-test/settings.gradle
new file mode 100644
index 0000000000..fa80fbee19
--- /dev/null
+++ b/android-test/settings.gradle
@@ -0,0 +1 @@
+project.name = 'android-test'
\ No newline at end of file
diff --git a/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt b/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt
new file mode 100644
index 0000000000..3aec4cab37
--- /dev/null
+++ b/android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt
@@ -0,0 +1,280 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp.android.test
+
+import android.os.Build
+import android.support.test.runner.AndroidJUnit4
+import okhttp3.Call
+import okhttp3.CertificatePinner
+import okhttp3.Connection
+import okhttp3.EventListener
+import okhttp3.OkHttpClient
+import okhttp3.Protocol
+import okhttp3.RecordingEventListener
+import okhttp3.Request
+import okhttp3.TlsVersion
+import okhttp3.mockwebserver.MockResponse
+import okhttp3.mockwebserver.MockWebServer
+import okhttp3.tls.internal.TlsUtil.localhost
+import okio.ByteString.Companion.toByteString
+import org.junit.After
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertTrue
+import org.junit.Assert.fail
+import org.junit.Assume.assumeNoException
+import org.junit.Assume.assumeTrue
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import java.net.InetAddress
+import java.net.UnknownHostException
+import javax.net.ssl.SSLPeerUnverifiedException
+import javax.net.ssl.SSLSocket
+
+/**
+ * Run with "./gradlew :android-test:connectedCheck" and make sure ANDROID_SDK_ROOT is set.
+ */
+@RunWith(AndroidJUnit4::class)
+class OkHttpTest {
+  private lateinit var client: OkHttpClient
+
+  @JvmField
+  @Rule
+  val server = MockWebServer()
+  private val handshakeCertificates = localhost()
+
+  @Before
+  fun createClient() {
+    client = OkHttpClient.Builder()
+        .build()
+  }
+
+  @After
+  fun cleanup() {
+    client.dispatcher.executorService.shutdownNow()
+  }
+
+  @Test
+  fun testRequest() {
+    assumeNetwork()
+
+    val request = Request.Builder().url("https://api.twitter.com/robots.txt").build()
+
+    val response = client.newCall(request).execute()
+
+    response.use {
+      assertEquals(200, response.code)
+    }
+  }
+
+  @Test
+  fun testRequestUsesAndroidConscrypt() {
+    assumeNetwork()
+
+    val request = Request.Builder().url("https://facebook.com/robots.txt").build()
+
+    var socketClass: String? = null
+
+    val client2 = client.newBuilder()
+        .eventListener(object : EventListener() {
+          override fun connectionAcquired(call: Call, connection: Connection) {
+            socketClass = connection.socket().javaClass.name
+          }
+        })
+        .build()
+
+    val response = client2.newCall(request).execute()
+
+    response.use {
+      assertEquals(Protocol.HTTP_2, response.protocol)
+      if (Build.VERSION.SDK_INT >= 29) {
+        assertEquals(TlsVersion.TLS_1_3, response.handshake?.tlsVersion)
+      } else {
+        assertEquals(TlsVersion.TLS_1_2, response.handshake?.tlsVersion)
+      }
+      assertEquals(200, response.code)
+      assertTrue(socketClass?.startsWith("com.android.org.conscrypt.") == true)
+    }
+  }
+
+  @Test
+  fun testHttpRequestNotBlockedOnLegacyAndroid() {
+    assumeTrue(Build.VERSION.SDK_INT < 23)
+
+    val request = Request.Builder().url("http://squareup.com/robots.txt").build()
+
+    val response = client.newCall(request).execute()
+
+    response.use {
+      assertEquals(200, response.code)
+    }
+  }
+
+  @Test
+  fun testHttpRequestBlocked() {
+    assumeTrue(Build.VERSION.SDK_INT >= 23)
+
+    val request = Request.Builder().url("http://squareup.com/robots.txt").build()
+
+    try {
+      client.newCall(request).execute()
+      fail("expected cleartext blocking")
+    } catch (_: java.net.UnknownServiceException) {
+    }
+  }
+
+  @Test
+  fun testMockWebserverRequest() {
+    enableTls()
+
+    server.enqueue(MockResponse().setBody("abc"))
+
+    val request = Request.Builder().url(server.url("/")).build()
+
+    val response = client.newCall(request).execute()
+
+    response.use {
+      assertEquals(200, response.code)
+    }
+  }
+
+  @Test
+  fun testCertificatePinningFailure() {
+    enableTls()
+
+    val certificatePinner = CertificatePinner.Builder()
+        .add(server.hostName, "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
+        .build()
+    client = client.newBuilder().certificatePinner(certificatePinner).build()
+
+    server.enqueue(MockResponse().setBody("abc"))
+
+    val request = Request.Builder().url(server.url("/")).build()
+
+    try {
+      client.newCall(request).execute()
+      fail()
+    } catch (_: SSLPeerUnverifiedException) {
+    }
+  }
+
+  @Test
+  fun testCertificatePinningSuccess() {
+    enableTls()
+
+    val certificatePinner = CertificatePinner.Builder()
+        .add(server.hostName,
+            CertificatePinner.pin(handshakeCertificates.trustManager.acceptedIssuers[0]))
+        .build()
+    client = client.newBuilder().certificatePinner(certificatePinner).build()
+
+    server.enqueue(MockResponse().setBody("abc"))
+
+    val request = Request.Builder().url(server.url("/")).build()
+
+    val response = client.newCall(request).execute()
+
+    response.use {
+      assertEquals(200, response.code)
+    }
+  }
+
+  @Test
+  fun testEventListener() {
+    val eventListener = RecordingEventListener()
+
+    client = client.newBuilder().eventListener(eventListener).build()
+
+    enableTls()
+
+    server.enqueue(MockResponse().setBody("abc1"))
+    server.enqueue(MockResponse().setBody("abc2"))
+
+    val request = Request.Builder().url(server.url("/")).build()
+
+    client.newCall(request).execute().use { response ->
+      assertEquals(200, response.code)
+    }
+
+    assertEquals(listOf("CallStart", "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
+        "ConnectStart", "SecureConnectStart", "SecureConnectEnd", "ConnectEnd",
+        "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
+        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
+        "CallEnd"), eventListener.recordedEventTypes())
+
+    eventListener.clearAllEvents()
+
+    client.newCall(request).execute().use { response ->
+      assertEquals(200, response.code)
+    }
+
+    assertEquals(listOf("CallStart", "ProxySelectStart", "ProxySelectEnd",
+        "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
+        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
+        "CallEnd"), eventListener.recordedEventTypes())
+  }
+
+  @Test
+  fun testSessionReuse() {
+    val sessionIds = mutableListOf<String>()
+
+    client = client.newBuilder().eventListener(object : EventListener() {
+      override fun connectionAcquired(call: Call, connection: Connection) {
+        val sslSocket = connection.socket() as SSLSocket
+
+        sessionIds.add(sslSocket.session.id.toByteString().hex())
+      }
+    }).build()
+
+    enableTls()
+
+    server.enqueue(MockResponse().setBody("abc1"))
+    server.enqueue(MockResponse().setBody("abc2"))
+
+    val request = Request.Builder().url(server.url("/")).build()
+
+    client.newCall(request).execute().use { response ->
+      assertEquals(200, response.code)
+    }
+
+    client.connectionPool.evictAll()
+    assertEquals(0, client.connectionPool.connectionCount())
+
+    client.newCall(request).execute().use { response ->
+      assertEquals(200, response.code)
+    }
+
+    assertEquals(2, sessionIds.size)
+    assertEquals(sessionIds[0], sessionIds[1])
+  }
+
+  private fun enableTls() {
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager)
+        .build()
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false)
+  }
+
+  private fun assumeNetwork() {
+    try {
+      InetAddress.getByName("www.google.com")
+    } catch (uhe: UnknownHostException) {
+      assumeNoException(uhe)
+    }
+  }
+}
diff --git a/android-test/src/main/AndroidManifest.xml b/android-test/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..b1a394fecc
--- /dev/null
+++ b/android-test/src/main/AndroidManifest.xml
@@ -0,0 +1,4 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="okhttp.android.test">
+  <uses-permission android:name="android.permission.INTERNET" />
+</manifest>
diff --git a/android-test/src/main/res/values/strings.xml b/android-test/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..3f2b0bb232
--- /dev/null
+++ b/android-test/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+  <string name="app_name">android-test</string>
+</resources>
diff --git a/android-test/src/main/res/xml/network_security_config.xml b/android-test/src/main/res/xml/network_security_config.xml
new file mode 100644
index 0000000000..786dddecc7
--- /dev/null
+++ b/android-test/src/main/res/xml/network_security_config.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<network-security-config>
+  <base-config cleartextTrafficPermitted="false">
+  </base-config>
+</network-security-config>
\ No newline at end of file
diff --git a/build.gradle b/build.gradle
index 53ac1c828e..b71f328cc7 100644
--- a/build.gradle
+++ b/build.gradle
@@ -2,31 +2,34 @@ import net.ltgt.gradle.errorprone.CheckSeverity
 
 buildscript {
   ext.versions = [
-      'airline': '0.8',
       'android': '4.1.1.4',
       'animalSniffer': '1.17',
       'assertj': '3.11.0',
-      'bouncycastle': '1.60',
+      'bouncycastle': '1.62',
+      'brotli': '0.1.2',
       'checkstyle': '8.15',
-      'conscrypt': '2.1.0',
+      'conscrypt': '2.2.1',
       'findbugs': '3.0.2',
       'guava': '27.0.1-jre',
       'java': '1.8',
       'jnrUnixsocket': '0.22',
       'jsoup': '1.11.3',
       'junit': '4.12',
-      'kotlin': '1.3.30',
+      'kotlin': '1.3.50',
       'moshi': '1.8.0',
       'okio': '2.2.2',
-      'ktlint': '0.31.0'
+      'ktlint': '0.31.0',
+      'picocli': '4.0.1',
+      'openjsse': '1.1.0'
   ]
 
   ext.deps = [
-      'airline': "io.airlift:airline:${versions.airline}",
+      'picocli': "info.picocli:picocli:${versions.picocli}",
       'android': "com.google.android:android:${versions.android}",
       'animalSniffer': "org.codehaus.mojo:animal-sniffer-annotations:${versions.animalSniffer}",
       'assertj': "org.assertj:assertj-core:${versions.assertj}",
       'bouncycastle': "org.bouncycastle:bcprov-jdk15on:${versions.bouncycastle}",
+      'brotli': "org.brotli:dec:${versions.brotli}",
       'conscrypt': "org.conscrypt:conscrypt-openjdk-uber:${versions.conscrypt}",
       'guava': "com.google.guava:guava:${versions.guava}",
       'jnrUnixsocket': "com.github.jnr:jnr-unixsocket:${versions.jnrUnixsocket}",
@@ -35,7 +38,8 @@ buildscript {
       'junit': "junit:junit:${versions.junit}",
       'kotlinStdlib': "org.jetbrains.kotlin:kotlin-stdlib:${versions.kotlin}",
       'moshi': "com.squareup.moshi:moshi:${versions.moshi}",
-      'okio': "com.squareup.okio:okio:${versions.okio}"
+      'okio': "com.squareup.okio:okio:${versions.okio}",
+      'openjsse': "org.openjsse:openjsse:${versions.openjsse}"
   ]
 
   dependencies {
@@ -45,11 +49,13 @@ buildscript {
     classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:${versions.kotlin}"
     classpath "org.jetbrains.dokka:dokka-gradle-plugin:0.9.18"
     classpath 'com.diffplug.spotless:spotless-plugin-gradle:3.21.1'
+    classpath 'com.android.tools.build:gradle:3.4.2'
   }
 
   repositories {
     mavenCentral()
     gradlePluginPortal()
+    google()
   }
 }
 
@@ -68,6 +74,7 @@ allprojects {
     maven {
       url 'https://dl.bintray.com/kotlin/dokka'
     }
+    google()
   }
 
   task downloadDependencies() {
@@ -79,6 +86,9 @@ allprojects {
 }
 
 subprojects { project ->
+  if (project.name == 'android-test')
+    return
+
   apply plugin: 'java'
   apply plugin: 'java-library'
   apply plugin: 'org.jetbrains.kotlin.platform.jvm'
@@ -107,11 +117,17 @@ subprojects { project ->
     signature 'net.sf.androidscents.signature:android-api-level-21:5.0.1_r2@signature'
     signature 'org.codehaus.mojo.signature:java18:1.0@signature'
   }
-  
+
   spotless {
     kotlin {
       target "**/*.kt"
-      ktlint(versions.ktlint).userData(['indent_size': '2', 'continuation_indent_size' : '2'])
+      ktlint(versions.ktlint).userData(['indent_size': '2', 'continuation_indent_size': '2'])
+    }
+  }
+
+  tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {
+    kotlinOptions {
+      jvmTarget = "1.8"
     }
   }
 
@@ -121,6 +137,7 @@ subprojects { project ->
     jvmArgs += "-Dlistener=okhttp3.testing.InstallUncaughtExceptionHandlerListener"
     jvmArgs += "-Dokhttp.platform=$platform"
 
+    maxParallelForks Runtime.runtime.availableProcessors() * 2
     testLogging {
       exceptionFormat = 'full'
     }
@@ -142,6 +159,10 @@ subprojects { project ->
     dependencies {
       testRuntime "org.conscrypt:conscrypt-openjdk-uber:${versions.conscrypt}"
     }
+  } else if (platform == "openjsse") {
+    dependencies {
+      testRuntime deps.openjsse
+    }
   }
 
   dependencies {
@@ -149,27 +170,34 @@ subprojects { project ->
     errorprone 'com.google.errorprone:error_prone_core:2.3.3'
   }
   tasks.withType(JavaCompile).configureEach {
+    sourceCompatibility = JavaVersion.VERSION_1_8
+    targetCompatibility = JavaVersion.VERSION_1_8
+
     options.errorprone {
       check("MissingFail", CheckSeverity.ERROR)
       check("MissingOverride", CheckSeverity.ERROR)
-      enabled = JavaVersion.current() < JavaVersion.VERSION_11
+      enabled = JavaVersion.current() < JavaVersion.VERSION_12
     }
   }
 
-  dokka {
-    reportUndocumented = false 
-    skipDeprecated = true
-    jdkVersion = 8
-    packageOptions {
-      prefix = "okhttp3.internal"
-      suppress = true
-    }
-    if (project.file('Module.md').exists()) {
-      includes = ['Module.md']
-    }
-    externalDocumentationLink {
-      url = new URL("https://square.github.io/okio/2.x/okio/jvm/index.html")
-      packageListUrl = new URL("https://square.github.io/okio/2.x/okio/jvm/package-list")
+  // We have to set the dokka configuration after evaluation since the com.vanniktech.maven.publish
+  // plugin overwrites our dokka configuration on projects where it's applied.
+  afterEvaluate { p ->
+    p.tasks.dokka {
+      reportUndocumented = false
+      skipDeprecated = true
+      jdkVersion = 8
+      packageOptions {
+        prefix = "okhttp3.internal"
+        suppress = true
+      }
+      if (project.file('Module.md').exists()) {
+        includes = ['Module.md']
+      }
+      externalDocumentationLink {
+        url = new URL("https://square.github.io/okio/2.x/okio/")
+        packageListUrl = new URL("https://square.github.io/okio/2.x/okio/package-list")
+      }
     }
   }
 }
@@ -216,7 +244,7 @@ def alpnBootVersionForPatchVersion(String javaVersion, int patchVersion) {
       return '8.1.11.v20170118'
     case 161..181:
       return '8.1.12.v20180117'
-    case 191..202:
+    case 191..222:
       return '8.1.13.v20181017'
     default:
       throw new IllegalStateException("Unexpected Java version: ${javaVersion}")
diff --git a/deploy_website.sh b/deploy_website.sh
index c9b7f156b0..202321d658 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -1,5 +1,11 @@
 #!/bin/bash
 
+# The website is built using MkDocs with the Material theme.
+# https://squidfunk.github.io/mkdocs-material/
+# It requires Python to run.
+# Install the packages with the following command:
+# pip install mkdocs mkdocs-material
+
 set -ex
 
 REPO="git@github.com:square/okhttp.git"
@@ -14,22 +20,29 @@ git clone $REPO $DIR
 # Move working directory into temp folder
 cd $DIR
 
-# Checkout and track the gh-pages branch
-git checkout -t origin/gh-pages
-
-# Delete everything that isn't versioned (1.x, 2.x)
-ls | grep -E -v '^\d+\.x$' | xargs rm -rf
-
-# Copy website files from real repo
-cp -R ../website/* .
-
-# Stage all files in git and create a commit
-git add .
-git add -u
-git commit -m "Website at $(date)"
-
-# Push the new files up to GitHub
-git push origin gh-pages
+# Generate the API docs
+./gradlew \
+  :mockwebserver:dokka \
+  :okhttp-dnsoverhttps:dokka \
+  :okhttp-logging-interceptor:dokka \
+  :okhttp-sse:dokka \
+  :okhttp-tls:dokka \
+  :okhttp-urlconnection:dokka \
+  :okhttp:dokka
+
+# Copy in special files that GitHub wants in the project root.
+cat README.md | grep -v 'project website' > docs/index.md
+cp CHANGELOG.md docs/changelog.md
+cp CONTRIBUTING.md docs/contributing.md
+
+# Build the site and push the new files up to GitHub
+mkdocs gh-deploy
+
+# Restore Javadocs from 1.x, 2.x, and 3.x.
+git checkout gh-pages
+git cherry-pick bb229b9dcc9a21a73edbf8d936bea88f52e0a3ff
+git cherry-pick c695732f1d4aea103b826876c077fbfea630e244
+git push
 
 # Delete our temp folder
 cd ..
diff --git a/docs/calls.md b/docs/calls.md
new file mode 100644
index 0000000000..38b7c25cd6
--- /dev/null
+++ b/docs/calls.md
@@ -0,0 +1,52 @@
+# Calls
+
+The HTTP client’s job is to accept your request and produce its response. This is simple in theory but it gets tricky in practice.
+
+## [Requests](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-request/)
+
+Each HTTP request contains a URL, a method (like `GET` or `POST`), and a list of headers. Requests may also contain a body: a data stream of a specific content type.
+
+## [Responses](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-response/)
+
+The response answers the request with a code (like 200 for success or 404 for not found), headers, and its own optional body.
+
+## Rewriting Requests
+
+When you provide OkHttp with an HTTP request, you’re describing the request at a high-level: _“fetch me this URL with these headers.”_ For correctness and efficiency, OkHttp rewrites your request before transmitting it.
+
+OkHttp may add headers that are absent from the original request, including `Content-Length`, `Transfer-Encoding`, `User-Agent`, `Host`, `Connection`, and `Content-Type`. It will add an `Accept-Encoding` header for transparent response compression unless the header is already present. If you’ve got cookies, OkHttp will add a `Cookie` header with them.
+
+Some requests will have a cached response. When this cached response isn’t fresh, OkHttp can do a _conditional GET_ to download an updated response if it’s newer than what’s cached. This requires headers like `If-Modified-Since` and `If-None-Match` to be added.
+
+## Rewriting Responses
+
+If transparent compression was used, OkHttp will drop the corresponding response headers `Content-Encoding` and `Content-Length` because they don’t apply to the decompressed response body.
+
+If a conditional GET was successful, responses from the network and cache are merged as directed by the spec.
+
+## Follow-up Requests
+
+When your requested URL has moved, the webserver will return a response code like `302` to indicate the document’s new URL. OkHttp will follow the redirect to retrieve a final response.
+
+If the response issues an authorization challenge, OkHttp will ask the [`Authenticator`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-authenticator/) (if one is configured) to satisfy the challenge. If the authenticator supplies a credential, the request is retried with that credential included.
+
+## Retrying Requests
+
+Sometimes connections fail: either a pooled connection was stale and disconnected, or the webserver itself couldn’t be reached. OkHttp will retry the request with a different route if one is available.
+
+## [Calls](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-call/)
+
+With rewrites, redirects, follow-ups and retries, your simple request may yield many requests and responses. OkHttp uses `Call` to model the task of satisfying your request through however many intermediate requests and responses are necessary. Typically this isn’t many! But it’s comforting to know that your code will continue to work if your URLs are redirected or if you failover to an alternate IP address.
+
+Calls are executed in one of two ways:
+
+ * **Synchronous:** your thread blocks until the response is readable.
+ * **Asynchronous:** you enqueue the request on any thread, and get [called back](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-callback/) on another thread when the response is readable.
+
+Calls can be canceled from any thread. This will fail the call if it hasn’t yet completed! Code that is writing the request body or reading the response body will suffer an `IOException` when its call is canceled.
+
+## Dispatch
+
+For synchronous calls, you bring your own thread and are responsible for managing how many simultaneous requests you make. Too many simultaneous connections wastes resources; too few harms latency.
+
+For asynchronous calls, [`Dispatcher`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-dispatcher/) implements policy for maximum simultaneous requests. You can set maximums per-webserver (default is 5), and overall (default is 64).
diff --git a/docs/changelog_1x.md b/docs/changelog_1x.md
new file mode 100644
index 0000000000..fba6c701f9
--- /dev/null
+++ b/docs/changelog_1x.md
@@ -0,0 +1,195 @@
+OkHttp 1.x Change Log
+=====================
+
+## Version 1.6.0
+
+_2014-05-23_
+
+ * Offer bridges to make it easier to migrate from OkHttp 1.x to OkHttp 2.0.
+   This adds `OkUrlFactory`, `Cache`, and `@Deprecated` annotations for APIs
+   dropped in 2.0.
+
+## Version 1.5.4
+
+_2014-04-14_
+
+ * Drop ALPN support in Android. There's a concurrency bug in all
+   currently-shipping versions.
+ * Support asynchronous disconnects by breaking the socket only. This should
+   prevent flakiness from multiple threads concurrently accessing a stream.
+
+## Version 1.5.3
+
+_2014-03-29_
+
+ * Fix bug where the Content-Length header was not always dropped when
+   following a redirect from a POST to a GET.
+ * Implement basic support for `Thread.interrupt()`. OkHttp now checks
+   for an interruption before doing a blocking call. If it is interrupted,
+   it throws an `InterruptedIOException`.
+
+## Version 1.5.2
+
+_2014-03-17_
+
+ * Fix bug where deleting a file that was absent from the `HttpResponseCache`
+   caused an IOException.
+ * Fix bug in HTTP/2 where our HPACK decoder wasn't emitting entries in
+   certain eviction scenarios, leading to dropped response headers.
+
+## Version 1.5.1
+
+_2014-03-11_
+
+ * Fix 1.5.0 regression where connections should not have been recycled.
+ * Fix 1.5.0 regression where transparent Gzip was broken by attempting to
+   recover from another I/O failure.
+ * Fix problems where spdy/3.1 headers may not have been compressed properly.
+ * Fix problems with spdy/3.1 and http/2 where the wrong window size was being
+   used.
+ * Fix 1.5.0 regression where conditional cache responses could corrupt the
+   connection pool.
+
+
+## Version 1.5.0
+
+_2014-03-07_
+
+
+##### OkHttp no longer uses the default SSL context.
+
+Applications that want to use the global SSL context with OkHttp should configure their
+OkHttpClient instances with the following:
+
+```java
+okHttpClient.setSslSocketFactory(HttpsURLConnection.getDefaultSSLSocketFactory());
+```
+
+A simpler solution is to avoid the shared default SSL socket factory. Instead, if you
+need to customize SSL, do so for your specific OkHttpClient instance only.
+
+##### Synthetic headers have changed
+
+Previously OkHttp added a synthetic response header, `OkHttp-Selected-Transport`. It
+has been replaced with a new synthetic header, `OkHttp-Selected-Protocol`.
+
+##### Changes
+
+ * New: Support for `HTTP-draft-09/2.0`.
+ * New: Support for `spdy/3.1`. Dropped support for `spdy/3`.
+ * New: Use ALPN on Android platforms that support it (4.4+)
+ * New: CacheControl model and parser.
+ * New: Protocol selection in MockWebServer.
+ * Fix: Route selection shouldn't use TLS modes that we know will fail.
+ * Fix: Cache SPDY responses even if the response body is closed prematurely.
+ * Fix: Use strict timeouts when aborting a download.
+ * Fix: Support Shoutcast HTTP responses like `ICY 200 OK`.
+ * Fix: Don't unzip if there isn't a response body.
+ * Fix: Don't leak gzip streams on redirects.
+ * Fix: Don't do DNS lookups on invalid hosts.
+ * Fix: Exhaust the underlying stream when reading gzip streams.
+ * Fix: Support the `PATCH` method.
+ * Fix: Support request bodies on `DELETE` method.
+ * Fix: Drop the `okhttp-protocols` module.
+ * Internal: Replaced internal byte array buffers with pooled buffers ("OkBuffer").
+
+
+## Version 1.3.0
+
+_2014-01-11_
+
+ * New: Support for "PATCH" HTTP method in client and MockWebServer.
+ * Fix: Drop `Content-Length` header when redirected from POST to GET.
+ * Fix: Correctly read cached header entries with malformed header names.
+ * Fix: Do not directly support any authentication schemes other than "Basic".
+ * Fix: Respect read timeouts on recycled connections.
+ * Fix: Transmit multiple cookie values as a single header with delimiter.
+ * Fix: Ensure `null` is never returned from a connection's `getHeaderFields()`.
+ * Fix: Persist proper `Content-Encoding` header to cache for GZip responses.
+ * Fix: Eliminate rare race condition in SPDY streams that would prevent connection reuse.
+ * Fix: Change HTTP date formats to UTC to conform to RFC2616 section 3.3.
+ * Fix: Support SPDY header blocks with trailing bytes.
+ * Fix: Allow `;` as separator for `Cache-Control` header.
+ * Fix: Correct bug where HTTPS POST requests were always automatically buffered.
+ * Fix: Honor read timeout when parsing SPDY headers.
+
+
+## Version 1.2.1
+
+_2013-08-23_
+
+ * Resolve issue with 'jar-with-dependencies' artifact creation.
+ * Fix: Support empty SPDY header values.
+
+
+## Version 1.2.0
+
+_2013-08-11_
+
+ *  New APIs on OkHttpClient to set default timeouts for connect and read.
+ *  Fix bug when caching SPDY responses.
+ *  Fix a bug with SPDY plus half-closed streams. (thanks kwuollett)
+ *  Fix a bug in `Content-Length` reporting for gzipped streams in the Apache
+    HTTP client adapter. (thanks kwuollett)
+ *  Work around the Alcatel `getByInetAddress` bug (thanks k.kocel)
+ *  Be more aggressive about testing pooled sockets before reuse. (thanks
+    warpspin)
+ *  Include `Content-Type` and `Content-Encoding` in the Apache HTTP client
+    adapter. (thanks kwuollett)
+ *  Add a media type class to OkHttp.
+ *  Change custom header prefix:
+
+    ```
+    X-Android-Sent-Millis is now OkHttp-Sent-Millis
+    X-Android-Received-Millis is now OkHttp-Received-Millis
+    X-Android-Response-Source is now OkHttp-Response-Source
+    X-Android-Selected-Transport is now OkHttp-Selected-Transport
+    ```
+ *  Improve cache invalidation for POST-like requests.
+ *  Bring MockWebServer into OkHttp and teach it SPDY.
+
+
+## Version 1.1.1
+
+_2013-06-23_
+
+ * Fix: ClassCastException when caching responses that were redirected from
+   HTTP to HTTPS.
+
+
+## Version 1.1.0
+
+_2013-06-15_
+
+ * Fix: Connection reuse was broken for most HTTPS connections due to a bug in
+   the way the hostname verifier was selected.
+ * Fix: Locking bug in SpdyConnection.
+ * Fix: Ignore null header values (for compatibility with HttpURLConnection).
+ * Add URLStreamHandlerFactory support so that `URL.openConnection()` uses
+   OkHttp.
+ * Expose the transport ("http/1.1", "spdy/3", etc.) via magic request headers.
+   Use `X-Android-Transports` to write the preferred transports and
+   `X-Android-Selected-Transport` to read the negotiated transport.
+
+
+## Version 1.0.2
+
+_2013-05-11_
+
+ * Fix: Remove use of Java 6-only APIs.
+ * Fix: Properly handle exceptions from `NetworkInterface` when querying MTU.
+ * Fix: Ensure MTU has a reasonable default and upper-bound.
+
+
+## Version 1.0.1
+
+_2013-05-06_
+
+ * Correct casing of SSL in method names (`getSslSocketFactory`/`setSslSocketFactory`).
+
+
+## Version 1.0.0
+
+_2013-05-06_
+
+Initial release.
diff --git a/docs/changelog_2x.md b/docs/changelog_2x.md
new file mode 100644
index 0000000000..b64593efab
--- /dev/null
+++ b/docs/changelog_2x.md
@@ -0,0 +1,630 @@
+OkHttp 2.x Change Log
+=====================
+
+## Version 2.7.5
+
+_2016-02-25_
+
+ *  Fix: Change the certificate pinner to always build full chains. This
+    prevents a potential crash when using certificate pinning with the Google
+    Play Services security provider.
+
+
+## Version 2.7.4
+
+_2016-02-07_
+
+ *  Fix: Don't crash when finding the trust manager if the Play Services (GMS)
+    security provider is installed.
+ *  Fix: The previous release introduced a performance regression on Android,
+    caused by looking up CA certificates. This is now fixed.
+
+
+## Version 2.7.3
+
+_2016-02-06_
+
+ *  Fix: Permit the trusted CA root to be pinned by `CertificatePinner`.
+
+
+## Version 2.7.2
+
+_2016-01-07_
+
+ *  Fix: Don't eagerly release stream allocations on cache hits. We might still
+    need them to handle redirects.
+
+
+## Version 2.7.1
+
+_2016-01-01_
+
+ *  Fix: Don't do a health check on newly-created connections. This is
+    unnecessary work that could put the client in an inconsistent state if the
+    health check fails.
+
+
+## Version 2.7.0
+
+_2015-12-13_
+
+ *  **Rewritten connection management.** Previously OkHttp's connection pool
+    managed both idle and active connections for HTTP/2, but only idle
+    connections for HTTP/1.x. With this update the connection pool manages both
+    idle and active connections for everything. OkHttp now detects and warns on
+    connections that were allocated but never released, and will enforce HTTP/2
+    stream limits. This update also fixes `Call.cancel()` to not do I/O on the
+    calling thread.
+ *  Fix: Don't log gzipped data in the logging interceptor.
+ *  Fix: Don't resolve DNS addresses when connecting through a SOCKS proxy.
+ *  Fix: Drop the synthetic `OkHttp-Selected-Protocol` response header.
+ *  Fix: Support 204 and 205 'No Content' replies in the logging interceptor.
+ *  New: Add `Call.isExecuted()`.
+
+
+## Version 2.6.0
+
+_2015-11-22_
+
+ *  **New Logging Interceptor.** The `logging-interceptor` subproject offers
+    simple request and response logging. It may be configured to log headers and
+    bodies for debugging. It requires this Maven dependency:
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okhttp</groupId>
+       <artifactId>logging-interceptor</artifactId>
+       <version>2.6.0</version>
+     </dependency>
+     ```
+
+    Configure basic logging like this:
+
+    ```java
+    HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor();
+    loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BASIC);
+    client.networkInterceptors().add(loggingInterceptor);
+    ```
+
+    **Warning:** Avoid `Level.HEADERS` and `Level.BODY` in production because
+    they could leak passwords and other authentication credentials to insecure
+    logs.
+
+ *  **WebSocket API now uses `RequestBody` and `ResponseBody` for messages.**
+    This is a backwards-incompatible API change.
+
+ *  **The DNS service is now pluggable.** In some situations this may be useful
+    to manually prioritize specific IP addresses.
+
+ *  Fix: Don't throw when converting an `HttpUrl` to a `java.net.URI`.
+    Previously URLs with special characters like `|` and `[` would break when
+    subjected to URI’s overly-strict validation.
+ *  Fix: Don't re-encode `+` as `%20` in encoded URL query strings. OkHttp
+    prefers `%20` when doing its own encoding, but will retain `+` when that is
+    provided.
+ *  Fix: Enforce that callers call `WebSocket.close()` on IO errors. Error
+    handling in WebSockets is significantly improved.
+ *  Fix: Don't use SPDY/3 style header concatenation for HTTP/2 request headers.
+    This could have corrupted requests where multiple headers had the same name,
+    as in cookies.
+ *  Fix: Reject bad characters in the URL hostname. Previously characters like
+    `\0` would cause a late crash when building the request.
+ *  Fix: Allow interceptors to change the request method.
+ *  Fix: Don’t use the request's `User-Agent` or `Proxy-Authorization` when
+    connecting to an HTTPS server via an HTTP tunnel. The `Proxy-Authorization`
+    header was being leaked to the origin server.
+ *  Fix: Digits may be used in a URL scheme.
+ *  Fix: Improve connection timeout recovery.
+ *  Fix: Recover from `getsockname` crashes impacting Android releases prior to
+    4.2.2.
+ *  Fix: Drop partial support for HTTP/1.0. Previously OkHttp would send
+    `HTTP/1.0` on connections after seeing a response with `HTTP/1.0`. The fixed
+    behavior is consistent with Firefox and Chrome.
+ *  Fix: Allow a body in `OPTIONS` requests.
+ *  Fix: Don't percent-encode non-ASCII characters in URL fragments.
+ *  Fix: Handle null fragments.
+ *  Fix: Don’t crash on interceptors that throw `IOException` before a
+    connection is attempted.
+ *  New: Support [WebDAV][webdav] HTTP methods.
+ *  New: Buffer WebSocket frames for better performance.
+ *  New: Drop support for `TLS_DHE_DSS_WITH_AES_128_CBC_SHA`, our only remaining
+    DSS cipher suite. This is consistent with Firefox and Chrome which have also
+    dropped these cipher suite.
+
+## Version 2.5.0
+
+_2015-08-25_
+
+ *  **Timeouts now default to 10 seconds.** Previously we defaulted to never
+    timing out, and that was a lousy policy. If establishing a connection,
+    reading the next byte from a connection, or writing the next byte to a
+    connection takes more than 10 seconds to complete, you’ll need to adjust
+    the timeouts manually.
+
+ *  **OkHttp now rejects request headers that contain invalid characters.** This
+    includes potential security problems (newline characters) as well as simple
+    non-ASCII characters (including international characters and emoji).
+
+ *  **Call canceling is more reliable.**  We had a bug where a socket being
+     connected wasn't being closed when the application used `Call.cancel()`.
+
+ *  **Changing a HttpUrl’s scheme now tracks the default port.** We had a bug
+    where changing a URL from `http` to `https` would leave it on port 80.
+
+ *  **Okio has been updated to 1.6.0.**
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.6.0</version>
+     </dependency>
+     ```
+
+ *  New: `Cache.initialize()`. Call this on a background thread to eagerly
+    initialize the response cache.
+ *  New: Fold `MockWebServerRule` into `MockWebServer`. This makes it easier to
+    write JUnit tests with `MockWebServer`. The `MockWebServer` library now
+    depends on JUnit, though it continues to work with all testing frameworks.
+ *  Fix: `FormEncodingBuilder` is now consistent with browsers in which
+    characters it escapes. Previously we weren’t percent-encoding commas,
+    parens, and other characters.
+ *  Fix: Relax `FormEncodingBuilder` to support building empty forms.
+ *  Fix: Timeouts throw `SocketTimeoutException`, not `InterruptedIOException`.
+ *  Fix: Change `MockWebServer` to use the same logic as OkHttp when determining
+    whether an HTTP request permits a body.
+ *  Fix: `HttpUrl` now uses the canonical form for IPv6 addresses.
+ *  Fix: Use `HttpUrl` internally.
+ *  Fix: Recover from Android 4.2.2 EBADF crashes.
+ *  Fix: Don't crash with an `IllegalStateException` if an HTTP/2 or SPDY
+    write fails, leaving the connection in an inconsistent state.
+ *  Fix: Make sure the default user agent is ASCII.
+
+
+## Version 2.4.0
+
+_2015-05-22_
+
+ *  **Forbid response bodies on HTTP 204 and 205 responses.** Webservers that
+    return such malformed responses will now trigger a `ProtocolException` in
+    the client.
+
+ *  **WebSocketListener has incompatible changes.** The `onOpen()` method is now
+    called on the reader thread, so implementations must return before further
+    websocket messages will be delivered. The `onFailure()` method now includes
+    an HTTP response if one was returned.
+
+## Version 2.4.0-RC1
+
+_2015-05-16_
+
+ *  **New HttpUrl API.** It's like `java.net.URL` but good. Note that
+    `Request.Builder.url()` now throws `IllegalArgumentException` on malformed
+    URLs. (Previous releases would throw a `MalformedURLException` when calling
+    a malformed URL.)
+
+ *  **We've improved connect failure recovery.** We now differentiate between
+    setup, connecting, and connected and implement appropriate recovery rules
+    for each. This changes `Address` to no longer use `ConnectionSpec`. (This is
+    an incompatible API change).
+
+ *  **`FormEncodingBuilder` now uses `%20` instead of `+` for encoded spaces.**
+    Both are permitted-by-spec, but `%20` requires fewer special cases.
+
+ *  **Okio has been updated to 1.4.0.**
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.4.0</version>
+     </dependency>
+     ```
+
+ *  **`Request.Builder` no longer accepts null if a request body is required.**
+    Passing null will now fail for request methods that require a body. Instead
+    use an empty body such as this one:
+
+    ```java
+        RequestBody.create(null, new byte[0]);
+    ```
+
+ * **`CertificatePinner` now supports wildcard hostnames.** As always with
+   certificate pinning, you must be very careful to avoid [bricking][brick]
+   your app. You'll need to pin both the top-level domain and the `*.` domain
+   for full coverage.
+
+    ```java
+     client.setCertificatePinner(new CertificatePinner.Builder()
+         .add("publicobject.com",   "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+         .add("*.publicobject.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
+         .add("publicobject.com",   "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
+         .add("*.publicobject.com", "sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=")
+         .add("publicobject.com",   "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
+         .add("*.publicobject.com", "sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=")
+         .add("publicobject.com",   "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+         .add("*.publicobject.com", "sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=")
+         .build());
+    ```
+
+ *  **Interceptors lists are now deep-copied by `OkHttpClient.clone()`.**
+    Previously clones shared interceptors, which made it difficult to customize
+    the interceptors on a request-by-request basis.
+
+ *  New: `Headers.toMultimap()`.
+ *  New: `RequestBody.create(MediaType, ByteString)`.
+ *  New: `ConnectionSpec.isCompatible(SSLSocket)`.
+ *  New: `Dispatcher.getQueuedCallCount()` and
+    `Dispatcher.getRunningCallCount()`. These can be useful in diagnostics.
+ *  Fix: OkHttp no longer shares timeouts between pooled connections. This was
+    causing some applications to crash when connections were reused.
+ *  Fix: `OkApacheClient` now allows an empty `PUT` and `POST`.
+ *  Fix: Websockets no longer rebuffer socket streams.
+ *  Fix: Websockets are now better at handling close frames.
+ *  Fix: Content type matching is now case insensitive.
+ *  Fix: `Vary` headers are not lost with `android.net.http.HttpResponseCache`.
+ *  Fix: HTTP/2 wasn't enforcing stream timeouts when writing the underlying
+    connection. Now it is.
+ *  Fix: Never return null on `call.proceed()`. This was a bug in call
+    cancelation.
+ *  Fix: When a network interceptor mutates a request, that change is now
+    reflected in `Response.networkResponse()`.
+ *  Fix: Badly-behaving caches now throw a checked exception instead of a
+    `NullPointerException`.
+ *  Fix: Better handling of uncaught exceptions in MockWebServer with HTTP/2.
+
+## Version 2.3.0
+
+_2015-03-16_
+
+ *  **HTTP/2 support.** We've done interop testing and haven't seen any
+    problems. HTTP/2 support has been a big effort and we're particularly
+    thankful to Adrian Cole who has helped us to reach this milestone.
+
+ *  **RC4 cipher suites are no longer supported by default.** To connect to
+    old, obsolete servers relying on these cipher suites, you must create a
+    custom `ConnectionSpec`.
+
+ *  **Beta WebSockets support.**. The `okhttp-ws` subproject offers a new
+    websockets client. Please try it out! When it's ready we intend to include
+    it with the core OkHttp library.
+
+ *  **Okio updated to 1.3.0.**
+
+    ```xml
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+      <version>1.3.0</version>
+    </dependency>
+    ```
+
+ *  **Fix: improve parallelism of async requests.** OkHttp's Dispatcher had a
+    misconfigured `ExecutorService` that limited the number of worker threads.
+    If you're using `Call.enqueue()` this update should significantly improve
+    request concurrency.
+
+ *  **Fix: Lazily initialize the response cache.** This avoids strict mode
+    warnings when initializing OkHttp on Android‘s main thread.
+
+ *  **Fix: Disable ALPN on Android 4.4.** That release of the feature was
+    unstable and prone to native crashes in the underlying OpenSSL code.
+ *  Fix: Don't send both `If-None-Match` and `If-Modified-Since` cache headers
+    when both are applicable.
+ *  Fix: Fail early when a port is out of range.
+ *  Fix: Offer `Content-Length` headers for multipart request bodies.
+ *  Fix: Throw `UnknownServiceException` if a cleartext connection is attempted
+    when explicitly forbidden.
+ *  Fix: Throw a `SSLPeerUnverifiedException` when host verification fails.
+ *  Fix: MockWebServer explicitly closes sockets. (On some Android releases,
+    closing the input stream and output stream of a socket is not sufficient.
+ *  Fix: Buffer outgoing HTTP/2 frames to limit how many outgoing frames are
+    created.
+ *  Fix: Avoid crashing when cache writing fails due to a full disk.
+ *  Fix: Improve caching of private responses.
+ *  Fix: Update cache-by-default response codes.
+ *  Fix: Reused `Request.Builder` instances no longer hold stale URL fields.
+ *  New: ConnectionSpec can now be configured to use the SSL socket's default
+    cipher suites. To use, set the cipher suites to `null`.
+ *  New: Support `DELETE` with a request body.
+ *  New: `Headers.of(Map)` creates headers from a Map.
+
+
+## Version 2.2.0
+
+_2014-12-30_
+
+ *  **`RequestBody.contentLength()` now throws `IOException`.**
+    This is a source-incompatible change. If you have code that calls
+    `RequestBody.contentLength()`, your compile will break with this
+    update. The change is binary-compatible, however: code compiled
+    for OkHttp 2.0 and 2.1 will continue to work with this update.
+
+ *  **`COMPATIBLE_TLS` no longer supports SSLv3.** In response to the
+    [POODLE](https://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html)
+    vulnerability, OkHttp no longer offers SSLv3 when negotiation an
+    HTTPS connection. If you continue to need to connect to webservers
+    running SSLv3, you must manually configure your own `ConnectionSpec`.
+
+ *  **OkHttp now offers interceptors.** Interceptors are a powerful mechanism
+    that can monitor, rewrite, and retry calls. The [interceptors doc][interceptors] is a full
+    introduction to this new API.
+
+ *  New: APIs to iterate and selectively clear the response cache.
+ *  New: Support for SOCKS proxies.
+ *  New: Support for `TLS_FALLBACK_SCSV`.
+ *  New: Update HTTP/2 support to `h2-16` and `hpack-10`.
+ *  New: APIs to prevent retrying non-idempotent requests.
+ *  Fix: Drop NPN support. Going forward we support ALPN only.
+ *  Fix: The hostname verifier is now strict. This is consistent with the hostname
+    verifier in modern browsers.
+ *  Fix: Improve `CONNECT` handling for misbehaving HTTP proxies.
+ *  Fix: Don't retry requests that failed due to timeouts.
+ *  Fix: Cache 302s and 308s that include appropriate response headers.
+ *  Fix: Improve pooling of connections that use proxy selectors.
+ *  Fix: Don't leak connections when using ALPN on the desktop.
+ *  Fix: Update Jetty ALPN to `7.1.2.v20141202` (Java 7) and `8.1.2.v20141202` (Java 8).
+    This fixes a bug in resumed TLS sessions where the wrong protocol could be
+    selected.
+ *  Fix: Don't crash in SPDY and HTTP/2 when disconnecting before connecting.
+ *  Fix: Avoid a reverse DNS-lookup for a numeric proxy address
+ *  Fix: Resurrect http/2 frame logging.
+ *  Fix: Limit to 20 authorization attempts.
+
+## Version 2.1.0
+
+_2014-11-11_
+
+ *  New: Typesafe APIs for interacting with cipher suites and TLS versions.
+ *  Fix: Don't crash when mixing authorization challenges with upload retries.
+
+
+## Version 2.1.0-RC1
+
+_2014-11-04_
+
+ *  **OkHttp now caches private responses**. We've changed from a shared cache
+    to a private cache, and will now store responses that use an `Authorization`
+    header. This means OkHttp's cache shouldn't be used on middleboxes that sit
+    between user agents and the origin server.
+
+ *  **TLS configuration updated.** OkHttp now explicitly enables TLSv1.2,
+    TLSv1.1 and TLSv1.0 where they are supported. It will continue to perform
+    only one fallback, to SSLv3. Applications can now configure this with the
+    `ConnectionSpec` class.
+
+    To disable TLS fallback:
+
+    ```java
+    client.setConnectionSpecs(Arrays.asList(
+        ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT));
+    ```
+
+    To disable cleartext connections, permitting `https` URLs only:
+
+    ```java
+    client.setConnectionSpecs(Arrays.asList(
+        ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS));
+    ```
+
+ *  **New cipher suites.** Please confirm that your webservers are reachable
+    with this limited set of cipher suites.
+
+    ```
+                                             Android
+    Name                                     Version
+
+    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256  5.0
+    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256    5.0
+    TLS_DHE_RSA_WITH_AES_128_GCM_SHA256      5.0
+    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA     4.0
+    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA     4.0
+    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA       4.0
+    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA       4.0
+    TLS_ECDHE_ECDSA_WITH_RC4_128_SHA         4.0
+    TLS_ECDHE_RSA_WITH_RC4_128_SHA           4.0
+    TLS_DHE_RSA_WITH_AES_128_CBC_SHA         2.3
+    TLS_DHE_DSS_WITH_AES_128_CBC_SHA         2.3
+    TLS_DHE_RSA_WITH_AES_256_CBC_SHA         2.3
+    TLS_RSA_WITH_AES_128_GCM_SHA256          5.0
+    TLS_RSA_WITH_AES_128_CBC_SHA             2.3
+    TLS_RSA_WITH_AES_256_CBC_SHA             2.3
+    SSL_RSA_WITH_3DES_EDE_CBC_SHA            2.3  (Deprecated in 5.0)
+    SSL_RSA_WITH_RC4_128_SHA                 2.3
+    SSL_RSA_WITH_RC4_128_MD5                 2.3  (Deprecated in 5.0)
+    ```
+
+ *  **Okio updated to 1.0.1.**
+
+    ```xml
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+      <version>1.0.1</version>
+    </dependency>
+    ```
+
+ *  **New APIs to permit easy certificate pinning.** Be warned, certificate
+    pinning is dangerous and could prevent your application from trusting your
+    server!
+
+ *  **Cache improvements.** This release fixes some severe cache problems
+    including a bug where the cache could be corrupted upon certain access
+    patterns. We also fixed a bug where the cache was being cleared due to a
+    corrupted journal. We've added APIs to configure a request's `Cache-Control`
+    headers, and to manually clear the cache.
+
+ *  **Request cancellation fixes.** This update fixes a bug where synchronous
+    requests couldn't be canceled by tag. This update avoids crashing when
+    `onResponse()` throws an `IOException`. That failure will now be logged
+    instead of notifying the thread's uncaught exception handler. We've added a
+    new API, `Call.isCanceled()` to check if a call has been canceled.
+
+ *  New: Update `MultipartBuilder` to support content length.
+ *  New: Make it possible to mock `OkHttpClient` and `Call`.
+ *  New: Update to h2-14 and hpack-9.
+ *  New: OkHttp includes a user-agent by default, like `okhttp/2.1.0-RC1`.
+ *  Fix: Handle response code `308 Permanent Redirect`.
+ *  Fix: Don't skip the callback if a call is canceled.
+ *  Fix: Permit hostnames with underscores.
+ *  Fix: Permit overriding the content-type in `OkApacheClient`.
+ *  Fix: Use the socket factory for direct connections.
+ *  Fix: Honor `OkUrlFactory` APIs that disable redirects.
+ *  Fix: Don't crash on concurrent modification of `SPDY` SPDY settings.
+
+## Version 2.0.0
+
+This release commits to a stable 2.0 API. Read the 2.0.0-RC1 changes for advice
+on upgrading from 1.x to 2.x.
+
+_2014-06-21_
+
+ *  **API Change**: Use `IOException` in `Callback.onFailure()`. This is
+    a source-incompatible change, and is different from OkHttp 2.0.0-RC2 which
+    used `Throwable`.
+ *  Fix: Fixed a caching bug where we weren't storing rewritten request headers
+    like `Accept-Encoding`.
+ *  Fix: Fixed bugs in handling the SPDY window size. This was stalling certain
+    large downloads
+ *  Update the language level to Java 7. (OkHttp requires Android 2.3+ or Java 7+.)
+
+## Version 2.0.0-RC2
+
+_2014-06-11_
+
+This update fixes problems in 2.0.0-RC1. Read the 2.0.0-RC1 changes for
+advice on upgrading from 1.x to 2.x.
+
+ *  Fix: Don't leak connections! There was a regression in 2.0.0-RC1 where
+    connections were neither closed nor pooled.
+ *  Fix: Revert builder-style return types from OkHttpClient's timeout methods
+    for binary compatibility with OkHttp 1.x.
+ *  Fix: Don't skip client stream 1 on SPDY/3.1. This fixes SPDY connectivity to
+    `https://google.com`, which doesn't follow the SPDY/3.1 spec!
+ *  Fix: Always configure NPN headers. This fixes connectivity to
+    `https://facebook.com` when SPDY and HTTP/2 are both disabled. Otherwise an
+    unexpected NPN response is received and OkHttp crashes.
+ *  Fix: Write continuation frames when HPACK data is larger than 16383 bytes.
+ *  Fix: Don't drop uncaught exceptions thrown in async calls.
+ *  Fix: Throw an exception eagerly when a request body is not legal. Previously
+    we ignored the problem at request-building time, only to crash later with a
+    `NullPointerException`.
+ *  Fix: Include a backwards-compatible `OkHttp-Response-Source` header with
+    `OkUrlFactory `responses.
+ *  Fix: Don't include a default User-Agent header in requests made with the Call
+    API. Requests made with OkUrlFactory will continue to have a default user
+    agent.
+ *  New: Guava-like API to create headers:
+
+    ```java
+    Headers headers = Headers.of(name1, value1, name2, value2, ...).
+    ```
+
+ *  New: Make the content-type header optional for request bodies.
+ *  New: `Response.isSuccessful()` is a convenient API to check response codes.
+ *  New: The response body can now be read outside of the callback. Response
+    bodies must always be closed, otherwise they will leak connections!
+ *  New: APIs to create multipart request bodies (`MultipartBuilder`) and form
+    encoding bodies (`FormEncodingBuilder`).
+
+## Version 2.0.0-RC1
+
+_2014-05-23_
+
+OkHttp 2 is designed around a new API that is true to HTTP, with classes for
+requests, responses, headers, and calls. It uses modern Java patterns like
+immutability and chained builders. The API now offers asynchronous callbacks
+in addition to synchronous blocking calls.
+
+#### API Changes
+
+ *  **New Request and Response types,** each with their own builder. There's also
+    a `RequestBody` class to write the request body to the network and a
+    `ResponseBody` to read the response body from the network. The standalone
+    `Headers` class offers full access to the HTTP headers.
+
+ *  **Okio dependency added.** OkHttp now depends on
+    [Okio](https://github.com/square/okio), an I/O library that makes it easier
+    to access, store and process data. Using this library internally makes OkHttp
+    faster while consuming less memory. You can write a `RequestBody` as an Okio
+    `BufferedSink` and a `ResponseBody` as an Okio `BufferedSource`. Standard
+    `InputStream` and `OutputStream` access is also available.
+
+ *  **New Call and Callback types** execute requests and receive their
+    responses. Both types of calls can be canceled via the `Call` or the
+    `OkHttpClient`.
+
+ *  **URLConnection support has moved to the okhttp-urlconnection module.**
+    If you're upgrading from 1.x, this change will impact you. You will need to
+    add the `okhttp-urlconnection` module to your project and use the
+    `OkUrlFactory` to create new instances of `HttpURLConnection`:
+
+    ```java
+    // OkHttp 1.x:
+    HttpURLConnection connection = client.open(url);
+
+    // OkHttp 2.x:
+    HttpURLConnection connection = new OkUrlFactory(client).open(url);
+    ```
+
+ *  **Custom caches are no longer supported.** In OkHttp 1.x it was possible to
+    define your own response cache with the `java.net.ResponseCache` and OkHttp's
+    `OkResponseCache` interfaces. Both of these APIs have been dropped. In
+    OkHttp 2 the built-in disk cache is the only supported response cache.
+
+ *  **HttpResponseCache has been renamed to Cache.** Install it with
+    `OkHttpClient.setCache(...)` instead of `OkHttpClient.setResponseCache(...)`.
+
+ *  **OkAuthenticator has been replaced with Authenticator.** This new
+    authenticator has access to the full incoming response and can respond with
+    whichever followup request is appropriate. The `Challenge` class is now a
+    top-level class and `Credential` is replaced with a utility class called
+    `Credentials`.
+
+ *  **OkHttpClient.getFollowProtocolRedirects() renamed to
+    getFollowSslRedirects()**. We reserve the word _protocol_ for the HTTP
+    version being used (HTTP/1.1, HTTP/2). The old name of this method was
+    misleading; it was always used to configure redirects between `https://` and
+    `http://` schemes.
+
+ *  **RouteDatabase is no longer public API.** OkHttp continues to track which
+    routes have failed but this is no exposed in the API.
+
+ *  **ResponseSource is gone.** This enum exposed whether a response came from
+    the cache, network, or both. OkHttp 2 offers more detail with raw access to
+    the cache and network responses in the new `Response` class.
+
+ *  **TunnelRequest is gone.** It specified how to connect to an HTTP proxy.
+    OkHttp 2 uses the new `Request` class for this.
+
+ *  **Dispatcher** is a new class that manages the queue of asynchronous calls. It
+    implements limits on total in-flight calls and in-flight calls per host.
+
+#### Implementation changes
+
+ * Support Android `TrafficStats` socket tagging.
+ * Drop authentication headers on redirect.
+ * Added support for compressed data frames.
+ * Process push promise callbacks in order.
+ * Update to http/2 draft 12.
+ * Update to HPACK draft 07.
+ * Add ALPN support. Maven will use ALPN on OpenJDK 8.
+ * Update NPN dependency to target `jdk7u60-b13` and `Oracle jdk7u55-b13`.
+ * Ensure SPDY variants support zero-length DELETE and POST.
+ * Prevent leaking a cache item's InputStreams when metadata read fails.
+ * Use a string to identify TLS versions in routes.
+ * Add frame logger for HTTP/2.
+ * Replacing `httpMinorVersion` with `Protocol`. Expose HTTP/1.0 as a potential protocol.
+ * Use `Protocol` to describe framing.
+ * Implement write timeouts for HTTP/1.1 streams.
+ * Avoid use of SPDY stream ID 1, as that's typically used for UPGRADE.
+ * Support OAuth in `Authenticator`.
+ * Permit a dangling semicolon in media type parsing.
+
+
+## Version 1.x
+
+[Change log](changelog_1x.md)
+
+
+ [brick]: https://noncombatant.org/2015/05/01/about-http-public-key-pinning/
+ [interceptors]: https://square.github.io/okhttp/interceptors/
+ [webdav]: https://tools.ietf.org/html/rfc4918
diff --git a/docs/changelog_3x.md b/docs/changelog_3x.md
new file mode 100644
index 0000000000..4da5a56fde
--- /dev/null
+++ b/docs/changelog_3x.md
@@ -0,0 +1,981 @@
+OkHttp 3.x Change Log
+=====================
+
+## Version 3.14.2
+
+_2019-05-19_
+
+ *  Fix: Lock in a route when recovering from an HTTP/2 connection error. We had a bug where two
+    calls that failed at the same time could cause OkHttp to crash with a `NoSuchElementException`
+    instead of the expected `IOException`.
+
+ *  Fix: Don't crash with a `NullPointerException` when formatting an error message describing a
+    truncated response from an HTTPS proxy.
+
+
+## Version 3.14.1
+
+_2019-04-10_
+
+ *  Fix: Don't crash when an interceptor retries when there are no more routes. This was an
+    edge-case regression introduced with the events cleanup in 3.14.0.
+
+ *  Fix: Provide actionable advice when the exchange is non-null. Prior to 3.14, OkHttp would
+    silently leak connections when an interceptor retries without closing the response body. With
+    3.14 we detect this problem but the exception was not helpful.
+
+## Version 3.14.0
+
+_2019-03-14_
+
+ *  **This release deletes the long-deprecated `OkUrlFactory` and `OkApacheClient` APIs.** These
+    facades hide OkHttp's implementation behind another client's API. If you still need this please
+    copy and paste [ObsoleteUrlFactory.java][obsolete_url_factory] or
+    [ObsoleteApacheClient.java][obsolete_apache_client] into your project.
+
+ *  **OkHttp now supports duplex calls over HTTP/2.** With normal HTTP calls the request must finish
+    before the response starts. With duplex, request and response bodies are transmitted
+    simultaneously. This can be used to implement interactive conversations within a single HTTP
+    call.
+
+    Create duplex calls by overriding the new `RequestBody.isDuplex()` method to return true.
+    This simple option dramatically changes the behavior of the request body and of the entire
+    call.
+
+    The `RequestBody.writeTo()` method may now retain a reference to the provided sink and
+    hand it off to another thread to write to it after `writeTo` returns.
+
+    The `EventListener` may now see requests and responses interleaved in ways not previously
+    permitted. For example, a listener may receive `responseHeadersStart()` followed by
+    `requestBodyEnd()`, both on the same call. Such events may be triggered by different threads
+    even for a single call.
+
+    Interceptors that rewrite or replace the request body may now inadvertently interfere with
+    duplex request bodies. Such interceptors should check `RequestBody.isDuplex()` and avoid
+    accessing the request body when it is.
+
+    Duplex calls require HTTP/2. If HTTP/1 is established instead the duplex call will fail. The
+    most common use of duplex calls is [gRPC][grpc_http2].
+
+ *  New: Prevent OkHttp from retransmitting a request body by overriding `RequestBody.isOneShot()`.
+    This is most useful when writing the request body is destructive.
+
+ *  New: We've added `requestFailed()` and `responseFailed()` methods to `EventListener`. These
+    are called instead of `requestBodyEnd()` and `responseBodyEnd()` in some failure situations.
+    They may also be fired in cases where no event was published previously. In this release we did
+    an internal rewrite of our event code to fix problems where events were lost or unbalanced.
+
+ *  Fix: Don't leak a connection when a call is canceled immediately preceding the `onFailure()`
+    callback.
+
+ *  Fix: Apply call timeouts when connecting duplex calls, web sockets, and server-sent events.
+    Once the streams are established no further timeout is enforced.
+
+ *  Fix: Retain the `Route` when a connection is reused on a redirect or other follow-up. This was
+    causing some `Authenticator` calls to see a null route when non-null was expected.
+
+ *  Fix: Use the correct key size in the name of `TLS_AES_128_CCM_8_SHA256` which is a TLS 1.3
+    cipher suite. We accidentally specified a key size of 256, preventing that cipher suite from
+    being selected for any TLS handshakes. We didn't notice because this cipher suite isn't
+    supported on Android, Java, or Conscrypt.
+
+    We removed this cipher suite and `TLS_AES_128_CCM_SHA256` from the restricted, modern, and
+    compatible sets of cipher suites. These two cipher suites aren't enabled by default in either
+    Firefox or Chrome.
+
+    See our [TLS Configuration History][tls_configuration_history] tracker for a log of all changes
+    to OkHttp's default TLS options.
+
+ *  New: Upgrade to Conscrypt 2.0.0. OkHttp works with other versions of Conscrypt but this is the
+    version we're testing against.
+
+    ```kotlin
+    implementation("org.conscrypt:conscrypt-openjdk-uber:2.0.0")
+    ```
+
+ *  New: Update the embedded public suffixes list.
+
+
+## Version 3.13.1
+
+_2019-02-05_
+
+ *  Fix: Don't crash when using a custom `X509TrustManager` or `SSLSocket` on Android. When we
+    removed obsolete code for Android 4.4 we inadvertently also removed support for custom
+    subclasses. We've restored that support!
+
+
+## Version 3.13.0
+
+_2019-02-04_
+
+ *  **This release bumps our minimum requirements to Java 8+ or Android 5+.** Cutting off old
+    devices is a serious change and we don't do it lightly! [This post][require_android_5] explains
+    why we're doing this and how to upgrade.
+
+    The OkHttp 3.12.x branch will be our long-term branch for Android 2.3+ (API level 9+) and Java
+    7+. These platforms lack support for TLS 1.2 and should not be used. But because upgrading is
+    difficult we will backport critical fixes to the 3.12.x branch through December 31, 2020.
+
+ *  **TLSv1 and TLSv1.1 are no longer enabled by default.** Major web browsers are working towards
+    removing these versions altogether in early 2020. If your servers aren't ready yet you can
+    configure OkHttp 3.13 to allow TLSv1 and TLSv1.1 connections:
+
+    ```
+    OkHttpClient client = new OkHttpClient.Builder()
+        .connectionSpecs(Arrays.asList(ConnectionSpec.COMPATIBLE_TLS))
+        .build();
+    ```
+
+ *  New: You can now access HTTP trailers with `Response.trailers()`. This method may only be called
+    after the entire HTTP response body has been read.
+
+ *  New: Upgrade to Okio 1.17.3. If you're on Kotlin-friendly Okio 2.x this release requires 2.2.2
+    or newer.
+
+    ```kotlin
+    implementation("com.squareup.okio:okio:1.17.3")
+    ```
+
+ *  Fix: Don't miss cancels when sending HTTP/2 request headers.
+ *  Fix: Don't miss whole operation timeouts when calls redirect.
+ *  Fix: Don't leak connections if web sockets have malformed responses or if `onOpen()` throws.
+ *  Fix: Don't retry when request bodies fail due to `FileNotFoundException`.
+ *  Fix: Don't crash when URLs have IPv4-mapped IPv6 addresses.
+ *  Fix: Don't crash when building `HandshakeCertificates` on Android API 28.
+ *  Fix: Permit multipart file names to contain non-ASCII characters.
+ *  New: API to get MockWebServer's dispatcher.
+ *  New: API to access headers as `java.time.Instant`.
+ *  New: Fail fast if a `SSLSocketFactory` is used as a `SocketFactory`.
+ *  New: Log the TLS handshake in `LoggingEventListener`.
+
+
+## Version 3.12.4
+
+_2019-09-04_
+
+ *  Fix: Don't crash looking up an absent class on certain buggy Android 4.x devices.
+
+
+## Version 3.12.3
+
+_2019-05-07_
+
+ *  Fix: Permit multipart file names to contain non-ASCII characters.
+ *  Fix: Retain the `Route` when a connection is reused on a redirect or other follow-up. This was
+    causing some `Authenticator` calls to see a null route when non-null was expected.
+
+
+## Version 3.12.2
+
+_2019-03-14_
+
+ *  Fix: Don't crash if the HTTPS server returns no certificates in the TLS handshake.
+ *  Fix: Don't leak a connection when a call is canceled immediately preceding the `onFailure()`
+    callback.
+
+
+## Version 3.12.1
+
+_2018-12-23_
+
+ *  Fix: Remove overlapping `package-info.java`. This caused issues with some build tools.
+
+
+## Version 3.12.0
+
+_2018-11-16_
+
+ *  **OkHttp now supports TLS 1.3.** This requires either Conscrypt or Java 11+.
+
+ *  **Proxy authenticators are now asked for preemptive authentication.** OkHttp will now request
+    authentication credentials before creating TLS tunnels through HTTP proxies (HTTP `CONNECT`).
+    Authenticators should identify preemptive authentications by the presence of a challenge whose
+    scheme is "OkHttp-Preemptive".
+
+ *  **OkHttp now offers full-operation timeouts.** This sets a limit on how long the entire call may
+    take and covers resolving DNS, connecting, writing the request body, server processing, and
+    reading the full response body. If a call requires redirects or retries all must complete within
+    one timeout period.
+
+    Use `OkHttpClient.Builder.callTimeout()` to specify the default duration and `Call.timeout()` to
+    specify the timeout of an individual call.
+
+ *  New: Return values and fields are now non-null unless otherwise annotated.
+ *  New: `LoggingEventListener` makes it easy to get basic visibility into a call's performance.
+    This class is in the `logging-interceptor` artifact.
+ *  New: `Headers.Builder.addUnsafeNonAscii()` allows non-ASCII values to be added without an
+    immediate exception.
+ *  New: Headers can be redacted in `HttpLoggingInterceptor`.
+ *  New: `Headers.Builder` now accepts dates.
+ *  New: OkHttp now accepts `java.time.Duration` for timeouts on Java 8+ and Android 26+.
+ *  New: `Challenge` includes all authentication parameters.
+ *  New: Upgrade to BouncyCastle 1.60, Conscrypt 1.4.0, and Okio 1.15.0. We don't yet require
+    Kotlin-friendly Okio 2.x but OkHttp works fine with that series.
+
+    ```kotlin
+    implementation("org.bouncycastle:bcprov-jdk15on:1.60")
+    implementation("org.conscrypt:conscrypt-openjdk-uber:1.4.0")
+    implementation("com.squareup.okio:okio:1.15.0")
+    ```
+
+ *  Fix: Handle dispatcher executor shutdowns gracefully. When there aren't any threads to carry a
+    call its callback now gets a `RejectedExecutionException`.
+ *  Fix: Don't permanently cache responses with `Cache-Control: immutable`. We misunderstood the
+    original `immutable` proposal!
+ *  Fix: Change `Authenticator`'s `Route` parameter to be nullable. This was marked as non-null but
+    could be called with null in some cases.
+ *  Fix: Don't create malformed URLs when `MockWebServer` is reached via an IPv6 address.
+ *  Fix: Don't crash if the system default authenticator is null.
+ *  Fix: Don't crash generating elliptic curve certificates on Android.
+ *  Fix: Don't crash doing platform detection on RoboVM.
+ *  Fix: Don't leak socket connections when web socket upgrades fail.
+
+
+## Version 3.11.0
+
+_2018-07-12_
+
+ *  **OkHttp's new okhttp-tls submodule tames HTTPS and TLS.**
+
+    `HeldCertificate` is a TLS certificate and its private key. Generate a certificate with its
+    builder then use it to sign another certificate or perform a TLS handshake. The
+    `certificatePem()` method encodes the certificate in the familiar PEM format
+    (`--- BEGIN CERTIFICATE ---`); the `privateKeyPkcs8Pem()` does likewise for the private key.
+
+    `HandshakeCertificates` holds the TLS certificates required for a TLS handshake. On the server
+    it keeps your `HeldCertificate` and its chain. On the client it keeps the root certificates
+    that are trusted to sign a server's certificate chain. `HandshakeCertificates` also works with
+    mutual TLS where these roles are reversed.
+
+    These classes make it possible to enable HTTPS in MockWebServer in [just a few lines of
+    code][https_server_sample].
+
+ *  **OkHttp now supports prior knowledge cleartext HTTP/2.** Enable this by setting
+    `Protocol.H2_PRIOR_KNOWLEDGE` as the lone protocol on an `OkHttpClient.Builder`. This mode
+    only supports `http:` URLs and is best suited in closed environments where HTTPS is
+    inappropriate.
+
+ *  New: `HttpUrl.get(String)` is an alternative to `HttpUrl.parse(String)` that throws an exception
+    when the URL is malformed instead of returning null. Use this to avoid checking for null in
+    situations where the input is known to be well-formed. We've also added `MediaType.get(String)`
+    which is an exception-throwing alternative to `MediaType.parse(String)`.
+ *  New: The `EventListener` API previewed in OkHttp 3.9 has graduated to a stable API. Use this
+    interface to track metrics and monitor HTTP requests' size and duration.
+ *  New: `okhttp-dnsoverhttps` is an experimental API for doing DNS queries over HTTPS. Using HTTPS
+    for DNS offers better security and potentially better performance. This feature is a preview:
+    the API is subject to change.
+ *  New: `okhttp-sse` is an early preview of Server-Sent Events (SSE). This feature is incomplete
+    and is only suitable for experimental use.
+ *  New: MockWebServer now supports client authentication (mutual TLS). Call `requestClientAuth()`
+    to permit an optional client certificate or `requireClientAuth()` to require one.
+ *  New: `RecordedRequest.getHandshake()` returns the HTTPS handshake of a request sent to
+    `MockWebServer`.
+ *  Fix: Honor the `MockResponse` header delay in MockWebServer.
+ *  Fix: Don't release HTTP/2 connections that have multiple canceled calls. We had a bug where
+    canceling calls would cause the shared HTTP/2 connection to be unnecessarily released. This
+    harmed connection reuse.
+ *  Fix: Ensure canceled and discarded HTTP/2 data is not permanently counted against the limited
+    flow control window. We had a few bugs where window size accounting was broken when streams
+    were canceled or reset.
+ *  Fix: Recover gracefully if the TLS session returns an unexpected version (`NONE`) or cipher
+    suite (`SSL_NULL_WITH_NULL_NULL`).
+ *  Fix: Don't change Conscrypt configuration globally. We migrated from a process-wide setting to
+    configuring only OkHttp's TLS sockets.
+ *  Fix: Prefer TLSv1.2 where it is available. On certain older platforms it is necessary to opt-in
+    to TLSv1.2.
+ *  New: `Request.tag()` permits multiple tags. Use a `Class<?>` as a key to identify tags. Note
+    that `tag()` now returns null if the request has no tag. Previously this would return the
+    request itself.
+ *  New: `Headers.Builder.addAll(Headers)`.
+ *  New: `ResponseBody.create(MediaType, ByteString)`.
+ *  New: Embed R8/ProGuard rules in the jar. These will be applied automatically by R8.
+ *  Fix: Release the connection if `Authenticator` throws an exception.
+ *  Fix: Change the declaration of `OkHttpClient.cache()` to return a `@Nullable Cache`. The return
+    value has always been nullable but it wasn't declared properly.
+ *  Fix: Reverse suppression of connect exceptions. When both a call and its retry fail, we now
+    throw the initial exception which is most likely to be actionable.
+ *  Fix: Retain interrupted state when throwing `InterruptedIOException`. A single interrupt should
+    now be sufficient to break out an in-flight OkHttp call.
+ *  Fix: Don't drop a call to `EventListener.callEnd()` when the response body is consumed inside an
+    interceptor.
+
+
+## Version 3.10.0
+
+_2018-02-24_
+
+ *  **The pingInterval() feature now aggressively checks connectivity for web
+    sockets and HTTP/2 connections.**
+
+    Previously if you configured a ping interval that would cause OkHttp to send
+    pings, but it did not track whether the reply pongs were received. With this
+    update OkHttp requires that every ping receive a response: if it does not
+    the connection will be closed and the listener's `onFailure()` method will
+    be called.
+
+    Web sockets have always been had pings, but pings on HTTP/2 connections is
+    new in this release. Pings are used for connections that are busy carrying
+    calls and for idle connections in the connection pool. (Pings do not impact
+    when pooled connections are evicted).
+
+    If you have a configured ping interval, you should confirm that it is long
+    enough for a roundtrip from client to server. If your ping interval is too
+    short, slow connections may be misinterpreted as failed connections. A ping
+    interval of 30 seconds is reasonable for most use cases.
+
+ *  **OkHttp now supports [Conscrypt][conscrypt].** Conscrypt is a Java Security
+    Provider that integrates BoringSSL into the Java platform. Conscrypt
+    supports more cipher suites than the JVM’s default provider and may also
+    execute more efficiently.
+
+    To use it, first register a [Conscrypt dependency][conscrypt_dependency] in
+    your build system.
+
+    OkHttp will use Conscrypt if you set the `okhttp.platform` system property
+    to `conscrypt`.
+
+    Alternatively, OkHttp will also use Conscrypt if you install it as your
+    preferred security provider. To do so, add the following code to execute
+    before you create your `OkHttpClient`.
+
+    ```
+    Security.insertProviderAt(
+        new org.conscrypt.OpenSSLProvider(), 1);
+    ```
+
+    Conscrypt is the bundled security provider on Android so it is not necessary
+    to configure it on that platform.
+
+ *  New: `HttpUrl.addQueryParameter()` percent-escapes more characters.
+    Previously several ASCII punctuation characters were not percent-escaped
+    when used with this method. This does not impact already-encoded query
+    parameters in APIs like `HttpUrl.parse()` and
+    `HttpUrl.Builder.addEncodedQueryParameter()`.
+ *  New: CBC-mode ECDSA cipher suites have been removed from OkHttp's default
+    configuration: `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA` and
+    `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA`. This tracks a [Chromium
+    change][remove_cbc_ecdsa] to remove these cipher suites because they are
+    fragile and rarely-used.
+ *  New: Don't fall back to common name (CN) verification for hostnames. This
+    behavior was deprecated with RFC 2818 in May 2000 and was recently dropped
+    from major web browsers.
+ *  New: Honor the `Retry-After` response header. HTTP 503 (Unavailable)
+    responses are retried automatically if this header is present and its delay
+    is 0 seconds. HTTP 408 (Client Timeout) responses are retried automatically
+    if the header is absent or its delay is 0 seconds.
+ *  New: Allow request bodies for all HTTP methods except GET and HEAD.
+ *  New: Automatic module name of `okhttp3` for use with the Java Platform
+    Module System.
+ *  New: Log gzipped bodies when `HttpLoggingInterceptor` is used as a network
+    interceptor.
+ *  New: `Protocol.QUIC` constant. This protocol is not supported but this
+    constant is included for completeness.
+ *  New: Upgrade to Okio 1.14.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.14.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.14.0
+     ```
+
+ *  Fix: Handle `HTTP/1.1 100 Continue` status lines, even on requests that did
+    not send the `Expect: continue` request header.
+ *  Fix: Do not count web sockets toward the dispatcher's per-host connection
+    limit.
+ *  Fix: Avoid using invalid HTTPS sessions. This prevents OkHttp from crashing
+    with the error, `Unexpected TLS version: NONE`.
+ *  Fix: Don't corrupt the response cache when a 304 (Not Modified) response
+    overrides the stored "Content-Encoding" header.
+ *  Fix: Gracefully shut down the HTTP/2 connection before it exhausts the
+    namespace of stream IDs (~536 million streams).
+ *  Fix: Never pass a null `Route` to `Authenticator`. There was a bug where
+    routes were omitted for eagerly-closed connections.
+
+## Version 3.9.1
+
+_2017-11-18_
+
+ *  New: Recover gracefully when Android's DNS crashes with an unexpected
+    `NullPointerException`.
+ *  New: Recover gracefully when Android's socket connections crash with an
+    unexpected `ClassCastException`.
+ *  Fix: Don't include the URL's fragment in `encodedQuery()` when the query
+    itself is empty.
+
+## Version 3.9.0
+
+_2017-09-03_
+
+ *  **Interceptors are more capable.** The `Chain` interface now offers access
+    to the call and can adjust all call timeouts. Note that this change is
+    source-incompatible for code that implements the `Chain` interface.
+    We don't expect this to be a problem in practice!
+
+ *  **OkHttp has an experimental new API for tracking metrics.** The new
+    `EventListener` API is designed to help developers monitor HTTP requests'
+    size and duration. This feature is an unstable preview: the API is subject
+    to change, and the implementation is incomplete. This is a big new API we
+    are eager for feedback.
+
+ *  New: Support ALPN via Google Play Services' Dynamic Security Provider. This
+    expands HTTP/2 support to older Android devices that have Google Play
+    Services.
+ *  New: Consider all routes when looking for candidate coalesced connections.
+    This increases the likelihood that HTTP/2 connections will be shared.
+ *  New: Authentication challenges and credentials now use a charset. Use this in
+    your authenticator to support user names and passwords with non-ASCII
+    characters.
+ *  New: Accept a charset in `FormBody.Builder`. Previously form bodies were
+    always UTF-8.
+ *  New: Support the `immutable` cache-control directive.
+ *  Fix: Don't crash when an HTTP/2 call is redirected while the connection is
+    being shut down.
+ *  Fix: Don't drop headers of healthy streams that raced with `GOAWAY` frames.
+    This bug would cause HTTP/2 streams to occasional hang when the connection
+    was shutting down.
+ *  Fix: Honor `OkHttpClient.retryOnConnectionFailure()` when the response is a
+    HTTP 408 Request Timeout. If retries are enabled, OkHttp will retry exactly
+    once in response to a 408.
+ *  Fix: Don't crash when reading the empty `HEAD` response body if it specifies
+    a `Content-Length`.
+ *  Fix: Don't crash if the thread is interrupted while reading the public
+    suffix database.
+ *  Fix: Use relative resource path when loading the public suffix database.
+    Loading the resource using a path relative to the class prevents conflicts
+    when the OkHttp classes are relocated (shaded) by allowing multiple private
+    copies of the database.
+ *  Fix: Accept cookies for URLs that have an IPv6 address for a host.
+ *  Fix: Don't log the protocol (HTTP/1.1, h2) in HttpLoggingInterceptor if the
+    protocol isn't negotiated yet! Previously we'd log HTTP/1.1 by default, and
+    this was confusing.
+ *  Fix: Omit the message from MockWebServer's HTTP/2 `:status` header.
+ *  Fix: Handle 'Expect: 100 Continue' properly in MockWebServer.
+
+
+## Version 3.8.1
+
+_2017-06-18_
+
+ *  Fix: Recover gracefully from stale coalesced connections. We had a bug where
+    connection coalescing (introduced in OkHttp 3.7.0) and stale connection
+    recovery could interact to cause a `NoSuchElementException` crash in the
+    `RouteSelector`.
+
+
+## Version 3.8.0
+
+_2017-05-13_
+
+
+ *  **OkHttp now uses `@Nullable` to annotate all possibly-null values.** We've
+    added a compile-time dependency on the JSR 305 annotations. This is a
+    [provided][maven_provided] dependency and does not need to be included in
+    your build configuration, `.jar` file, or `.apk`. We use
+    `@ParametersAreNonnullByDefault` and all parameters and return types are
+    never null unless explicitly annotated `@Nullable`.
+
+ *  **Warning: this release is source-incompatible for Kotlin users.**
+    Nullability was previously ambiguous and lenient but now the compiler will
+    enforce strict null checks.
+
+ *  New: The response message is now non-null. This is the "Not Found" in the
+    status line "HTTP 404 Not Found". If you are building responses
+    programmatically (with `new Response.Builder()`) you must now always supply
+    a message. An empty string `""` is permitted. This value was never null on
+    responses returned by OkHttp itself, and it was an old mistake to permit
+    application code to omit a message.
+
+ *  The challenge's scheme and realm are now non-null. If you are calling
+    `new Challenge(scheme, realm)` you must provide non-null values. These were
+    never null in challenges created by OkHttp, but could have been null in
+    application code that creates challenges.
+
+ *  New: The `TlsVersion` of a `Handshake` is now non-null. If you are calling
+    `Handshake.get()` with a null TLS version, you must instead now provide a
+    non-null `TlsVersion`. Cache responses persisted prior to OkHttp 3.0 did not
+    store a TLS version; for these unknown values the handshake is defaulted to
+    `TlsVersion.SSL_3_0`.
+
+ *  New: Upgrade to Okio 1.13.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.13.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.13.0
+     ```
+
+ *  Fix: gracefully recover when Android 7.0's sockets throw an unexpected
+    `NullPointerException`.
+
+## Version 3.7.0
+
+_2017-04-15_
+
+ *  **OkHttp no longer recovers from TLS handshake failures by attempting a TLSv1 connection.**
+    The fallback was necessary for servers that implemented version negotiation incorrectly. Now
+    that 99.99% of servers do it right this fallback is obsolete.
+ *  Fix: Do not honor cookies set on a public domain. Previously a malicious site could inject
+    cookies on top-level domains like `co.uk` because our cookie parser didn't honor the [public
+    suffix][public_suffix] list. Alongside this fix is a new API, `HttpUrl.topPrivateDomain()`,
+    which returns the privately domain name if the URL has one.
+ *  Fix: Change `MediaType.charset()` to return null for unexpected charsets.
+ *  Fix: Don't skip cache invalidation if the invalidating response has no body.
+ *  Fix: Don't use a cryptographic random number generator for web sockets. Some Android devices
+    implement `SecureRandom` incorrectly!
+ *  Fix: Correctly canonicalize IPv6 addresses in `HttpUrl`. This prevented OkHttp from trusting
+    HTTPS certificates issued to certain IPv6 addresses.
+ *  Fix: Don't reuse connections after an unsuccessful `Expect: 100-continue`.
+ *  Fix: Handle either `TLS_` or `SSL_` prefixes for cipher suite names. This is necessary for
+    IBM JVMs that use the `SSL_` prefix exclusively.
+ *  Fix: Reject HTTP/2 data frames if the stream ID is 0.
+ *  New: Upgrade to Okio 1.12.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.12.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.12.0
+     ```
+
+ *  New: Connection coalescing. OkHttp may reuse HTTP/2 connections across calls that share an IP
+    address and HTTPS certificate, even if their domain names are different.
+ *  New: MockWebServer's `RecordedRequest` exposes the requested `HttpUrl` with `getRequestUrl()`.
+
+
+## Version 3.6.0
+
+_2017-01-29_
+
+ *  Fix: Don't crash with a "cache is closed" error when there is an error initializing the cache.
+ *  Fix: Calling `disconnect()` on a connecting `HttpUrlConnection` could cause it to retry in an
+    infinite loop! This regression was introduced in OkHttp 2.7.0.
+ *  Fix: Drop cookies that contain ASCII NULL and other bad characters. Previously such cookies
+    would cause OkHttp to crash when they were included in a request.
+ *  Fix: Release duplicated multiplexed connections. If we concurrently establish connections to an
+    HTTP/2 server, close all but the first connection.
+ *  Fix: Fail the HTTP/2 connection if first frame isn't `SETTINGS`.
+ *  Fix: Forbid spaces in header names.
+ *  Fix: Don't offer to do gzip if the request is partial.
+ *  Fix: MockWebServer is now usable with JUnit 5. That update [broke the rules][junit_5_rules].
+ *  New: Support `Expect: 100-continue` as a request header. Callers can use this header to
+    pessimistically hold off on transmitting a request body until a server gives the go-ahead.
+ *  New: Permit network interceptors to rewrite the host header for HTTP/2. This makes it possible
+    to do domain fronting.
+ *  New: charset support for `Credentials.basic()`.
+
+
+## Version 3.5.0
+
+_2016-11-30_
+
+ *  **Web Sockets are now a stable feature of OkHttp.** Since being introduced as a beta feature in
+    OkHttp 2.3 our web socket client has matured. Connect to a server's web socket with
+    `OkHttpClient.newWebSocket()`, send messages with `send()`, and receive messages with the
+    `WebSocketListener`.
+
+    The `okhttp-ws` submodule is no longer available and `okhttp-ws` artifacts from previous
+    releases of OkHttp are not compatible with OkHttp 3.5. When upgrading to the new package
+    please note that the `WebSocket` and `WebSocketCall` classes have been merged. Sending messages
+    is now asynchronous and they may be enqueued before the web socket is connected.
+
+ *  **OkHttp no longer attempts a direct connection if the system's HTTP proxy fails.** This
+    behavior was surprising because OkHttp was disregarding the user's specified configuration. If
+    you need to customize proxy fallback behavior, implement your own `java.net.ProxySelector`.
+
+ *  Fix: Support TLSv1.3 on devices that support it.
+
+ *  Fix: Share pooled connections across equivalent `OkHttpClient` instances. Previous releases had
+    a bug where a shared connection pool did not guarantee shared connections in some cases.
+ *  Fix: Prefer the server's response body on all conditional cache misses. Previously we would
+    return the cached response's body if it had a newer `Last-Modified` date.
+ *  Fix: Update the stored timestamp on conditional cache hits.
+ *  New: Optimized HTTP/2 request header encoding. More headers are HPACK-encoded and string
+    literals are now Huffman-encoded.
+ *  New: Expose `Part` headers and body in `Multipart`.
+ *  New: Make `ResponseBody.string()` and `ResponseBody.charStream()` BOM-aware. If your HTTP
+    response body begins with a [byte order mark][bom] it will be consumed and used to select a
+    charset for the remaining bytes. Most applications should not need a byte order mark.
+
+ *  New: Upgrade to Okio 1.11.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.11.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.11.0
+     ```
+
+ *  Fix: Avoid sending empty HTTP/2 data frames when there is no request body.
+ *  Fix: Add a leading `.` for better domain matching in `JavaNetCookieJar`.
+ *  Fix: Gracefully recover from HTTP/2 connection shutdowns at start of request.
+ *  Fix: Be lenient if a `MediaType`'s character set is `'single-quoted'`.
+ *  Fix: Allow horizontal tab characters in header values.
+ *  Fix: When parsing HTTP authentication headers permit challenge parameters in any order.
+
+
+## Version 3.4.2
+
+_2016-11-03_
+
+ *  Fix: Recover gracefully when an HTTP/2 connection is shutdown. We had a
+    bug where shutdown HTTP/2 connections were considered usable. This caused
+    infinite loops when calls attempted to recover.
+
+
+## Version 3.4.1
+
+_2016-07-10_
+
+ *  **Fix a major bug in encoding HTTP headers.** In 3.4.0 and 3.4.0-RC1 OkHttp
+    had an off-by-one bug in our HPACK encoder. This bug could have caused the
+    wrong headers to be emitted after a sequence of HTTP/2 requests! Everyone
+    who is using OkHttp 3.4.0 or 3.4.0-RC1 should upgrade for this bug fix.
+
+
+## Version 3.4.0
+
+_2016-07-08_
+
+ *  New: Support dynamic table size changes to HPACK Encoder.
+ *  Fix: Use `TreeMap` in `Headers.toMultimap()`. This makes string lookups on
+    the returned map case-insensitive.
+ *  Fix: Don't share the OkHttpClient's `Dispatcher` in `HttpURLConnection`.
+
+
+## Version 3.4.0-RC1
+
+_2016-07-02_
+
+ *  **We’ve rewritten HttpURLConnection and HttpsURLConnection.** Previously we
+    shared a single HTTP engine between two frontend APIs: `HttpURLConnection`
+    and `Call`. With this release we’ve rearranged things so that the
+    `HttpURLConnection` frontend now delegates to the `Call` APIs internally.
+    This has enabled substantial simplifications and optimizations in the OkHttp
+    core for both frontends.
+
+    For most HTTP requests the consequences of this change will be negligible.
+    If your application uses `HttpURLConnection.connect()`,
+    `setFixedLengthStreamingMode()`, or `setChunkedStreamingMode()`, OkHttp will
+    now use a async dispatcher thread to establish the HTTP connection.
+
+    We don’t expect this change to have any behavior or performance
+    consequences. Regardless, please exercise your `OkUrlFactory` and
+    `HttpURLConnection` code when applying this update.
+
+ *  **Cipher suites may now have arbitrary names.** Previously `CipherSuite` was
+    a Java enum and it was impossible to define new cipher suites without first
+    upgrading OkHttp. With this change it is now a regular Java class with
+    enum-like constants. Application code that uses enum methods on cipher
+    suites (`ordinal()`, `name()`, etc.) will break with this change.
+
+ *  Fix: `CertificatePinner` now matches canonicalized hostnames. Previously
+    this was case sensitive. This change should also make it easier to configure
+    certificate pinning for internationalized domain names.
+ *  Fix: Don’t crash on non-ASCII `ETag` headers. Previously OkHttp would reject
+    these headers when validating a cached response.
+ *  Fix: Don’t allow remote peer to arbitrarily size the HPACK decoder dynamic
+    table.
+ *  Fix: Honor per-host configuration in Android’s network security config.
+    Previously disabling cleartext for any host would disable cleartext for all
+    hosts. Note that this setting is only available on Android 24+.
+ *  New: HPACK compression is now dynamic. This should improve performance when
+    transmitting request headers over HTTP/2.
+ *  New: `Dispatcher.setIdleCallback()` can be used to signal when there are no
+    calls in flight. This is useful for [testing with
+    Espresso][okhttp_idling_resource].
+ *  New: Upgrade to Okio 1.9.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.9.0</version>
+     </dependency>
+     ```
+
+
+## Version 3.3.1
+
+_2016-05-28_
+
+ *  Fix: The plaintext check in HttpLoggingInterceptor incorrectly classified
+    newline characters as control characters. This is fixed.
+ *  Fix: Don't crash reading non-ASCII characters in HTTP/2 headers or in cached
+    HTTP headers.
+ *  Fix: Retain the response body when an attempt to open a web socket returns a
+    non-101 response code.
+
+
+## Version 3.3.0
+
+_2016-05-24_
+
+ *  New: `Response.sentRequestAtMillis()` and `receivedResponseAtMillis()`
+    methods track the system's local time when network calls are made. These
+    replace the `OkHttp-Sent-Millis` and `OkHttp-Received-Millis` headers that were
+    present in earlier versions of OkHttp.
+ *  New: Accept user-provided trust managers in `OkHttpClient.Builder`. This
+    allows OkHttp to satisfy its TLS requirements directly. Otherwise OkHttp
+    will use reflection to extract the `TrustManager` from the
+    `SSLSocketFactory`.
+ *  New: Support prerelease Java 9. This gets ALPN from the platform rather than
+    relying on the alpn-boot bootclasspath override.
+ *  New: `HttpLoggingInterceptor` now logs connection failures.
+ *  New: Upgrade to Okio 1.8.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.8.0</version>
+     </dependency>
+     ```
+
+ *  Fix: Gracefully recover from a failure to rebuild the cache journal.
+ *  Fix: Don't corrupt cache entries when a cache entry is evicted while it is
+    being updated.
+ *  Fix: Make logging more consistent throughout OkHttp.
+ *  Fix: Log plaintext bodies only. This uses simple heuristics to differentiate
+    text from other data.
+ *  Fix: Recover from `REFUSED_STREAM` errors in HTTP/2. This should improve
+    interoperability with Nginx 1.10.0, which [refuses][nginx_959] streams
+    created before HTTP/2 settings have been acknowledged.
+ *  Fix: Improve recovery from failed routes.
+ *  Fix: Accommodate tunneling proxies that close the connection after an auth
+    challenge.
+ *  Fix: Use the proxy authenticator when authenticating HTTP proxies. This
+    regression was introduced in OkHttp 3.0.
+ *  Fix: Fail fast if network interceptors transform the response body such that
+    closing it doesn't also close the underlying stream. We had a bug where
+    OkHttp would attempt to reuse a connection but couldn't because it was still
+    held by a prior request.
+ *  Fix: Ensure network interceptors always have access to the underlying
+    connection.
+ *  Fix: Use `X509TrustManagerExtensions` on Android 17+.
+ *  Fix: Unblock waiting dispatchers on MockWebServer shutdown.
+
+
+## Version 3.2.0
+
+_2016-02-25_
+
+ *  Fix: Change the certificate pinner to always build full chains. This
+    prevents a potential crash when using certificate pinning with the Google
+    Play Services security provider.
+ *  Fix: Make IPv6 request lines consistent with Firefox and Chrome.
+ *  Fix: Recover gracefully when trimming the response cache fails.
+ *  New: Add multiple path segments using a single string in `HttpUrl.Builder`.
+ *  New: Support SHA-256 pins in certificate pinner.
+
+
+## Version 3.1.2
+
+_2016-02-10_
+
+ *  Fix: Don’t crash when finding the trust manager on Robolectric. We attempted
+    to detect the host platform and got confused because Robolectric looks like
+    Android but isn’t!
+ *  Fix: Change `CertificatePinner` to skip sanitizing the certificate chain
+    when no certificates were pinned. This avoids an SSL failure in insecure
+    “trust everyone” configurations, such as when talking to a development
+    HTTPS server that has a self-signed certificate.
+
+
+## Version 3.1.1
+
+_2016-02-07_
+
+ *  Fix: Don't crash when finding the trust manager if the Play Services (GMS)
+    security provider is installed.
+ *  Fix: The previous release introduced a performance regression on Android,
+    caused by looking up CA certificates. This is now fixed.
+
+
+## Version 3.1.0
+
+_2016-02-06_
+
+ *  New: WebSockets now defer some writes. This should improve performance for
+    some applications.
+ *  New: Override `equals()` and `hashCode()` in our new cookie class. This
+    class now defines equality by value rather than by reference.
+ *  New: Handle 408 responses by retrying the request. This allows servers to
+    direct clients to retry rather than failing permanently.
+ *  New: Expose the framed protocol in `Connection`. Previously this would
+    return the application-layer protocol (HTTP/1.1 or HTTP/1.0); now it always
+    returns the wire-layer protocol (HTTP/2, SPDY/3.1, or HTTP/1.1).
+ *  Fix: Permit the trusted CA root to be pinned by `CertificatePinner`.
+ *  Fix: Silently ignore unknown HTTP/2 settings. Previously this would cause
+    the entire connection to fail.
+ *  Fix: Don’t crash on unexpected charsets in the logging interceptor.
+ *  Fix: `OkHttpClient` is now non-final for the benefit of mocking frameworks.
+    Mocking sophisticated classes like `OkHttpClient` is fragile and you
+    shouldn’t do it. But if that’s how you want to live your life we won’t stand
+    in your way!
+
+
+## Version 3.0.1
+
+_2016-01-14_
+
+ *  Rollback OSGi support. This was causing library jars to include more classes
+    than expected, which interfered with Gradle builds.
+
+
+## Version 3.0.0
+
+_2016-01-13_
+
+This release commits to a stable 3.0 API. Read the 3.0.0-RC1 changes for advice
+on upgrading from 2.x to 3.x.
+
+ *  **The `Callback` interface now takes a `Call`**. This makes it easier to
+    check if the call was canceled from within the callback. When migrating
+    async calls to this new API, `Call` is now the first parameter for both
+    `onResponse()` and `onFailure()`.
+ *  Fix: handle multiple cookies in `JavaNetCookieJar` on Android.
+ *  Fix: improve the default HTTP message in MockWebServer responses.
+ *  Fix: don't leak file handles when a conditional GET throws.
+ *  Fix: Use charset specified by the request body content type in OkHttp's
+    logging interceptor.
+ *  Fix: Don't eagerly release pools on cache hits.
+ *  New: Make OkHttp OSGi ready.
+ *  New: Add already-implemented interfaces Closeable and Flushable to the cache.
+
+
+## Version 3.0.0-RC1
+
+_2016-01-02_
+
+OkHttp 3 is a major release focused on API simplicity and consistency. The API
+changes are numerous but most are cosmetic. Applications should be able to
+upgrade from the 2.x API to the 3.x API mechanically and without risk.
+
+Because the release includes breaking API changes, we're changing the project's
+package name from `com.squareup.okhttp` to `okhttp3`. This should make it
+possible for large applications to migrate incrementally. The Maven group ID
+is now `com.squareup.okhttp3`. For an explanation of this strategy, see Jake
+Wharton's post, [Java Interoperability Policy for Major Version
+Updates][major_versions].
+
+This release obsoletes OkHttp 2.x, and all code that uses OkHttp's
+`com.squareup.okhttp` package should upgrade to the `okhttp3` package. Libraries
+that depend on OkHttp should upgrade quickly to prevent applications from being
+stuck on the old version.
+
+ *  **There is no longer a global singleton connection pool.** In OkHttp 2.x,
+    all `OkHttpClient` instances shared a common connection pool by default.
+    In OkHttp 3.x, each new `OkHttpClient` gets its own private connection pool.
+    Applications should avoid creating many connection pools as doing so
+    prevents connection reuse. Each connection pool holds its own set of
+    connections alive so applications that have many pools also risk exhausting
+    memory!
+
+    The best practice in OkHttp 3 is to create a single OkHttpClient instance
+    and share it throughout the application. Requests that needs a customized
+    client should call `OkHttpClient.newBuilder()` on that shared instance.
+    This allows customization without the drawbacks of separate connection
+    pools.
+
+ *  **OkHttpClient is now stateless.** In the 2.x API `OkHttpClient` had getters
+    and setters. Internally each request was forced to make its own complete
+    snapshot of the `OkHttpClient` instance to defend against racy configuration
+    changes. In 3.x, `OkHttpClient` is now stateless and has a builder. Note
+    that this class is not strictly immutable as it has stateful members like
+    the connection pool and cache.
+
+ *  **Get and Set prefixes are now avoided.** With ubiquitous builders
+    throughout OkHttp these accessor prefixes aren't necessary. Previously
+    OkHttp used _get_ and _set_ prefixes sporadically which make the API
+    inconsistent and awkward to explore.
+
+ *  **OkHttpClient now implements the new `Call.Factory` interface.** This
+    interface will make your code easier to test. When you test code that makes
+    HTTP requests, you can use this interface to replace the real `OkHttpClient`
+    with your own mocks or fakes.
+
+    The interface will also let you use OkHttp's API with another HTTP client's
+    implementation. This is useful in sandboxed environments like Google App
+    Engine.
+
+ *  **OkHttp now does cookies.** We've replaced `java.net.CookieHandler` with
+    a new interface, `CookieJar` and added our own `Cookie` model class. This
+    new cookie follows the latest RFC and supports the same cookie attributes
+    as modern web browsers.
+
+ *  **Form and Multipart bodies are now modeled.** We've replaced the opaque
+    `FormEncodingBuilder` with the more powerful `FormBody` and
+    `FormBody.Builder` combo. Similarly we've upgraded `MultipartBuilder` into
+    `MultipartBody`, `MultipartBody.Part`, and `MultipartBody.Builder`.
+
+ *  **The Apache HTTP client and HttpURLConnection APIs are deprecated.** They
+    continue to work as they always have, but we're moving everything to the new
+    OkHttp 3 API. The `okhttp-apache` and `okhttp-urlconnection` modules should
+    be only be used to accelerate a transition to OkHttp's request/response API.
+    These deprecated modules will be dropped in an upcoming OkHttp 3.x release.
+
+ *  **Canceling batches of calls is now the application's responsibility.**
+    The API to cancel calls by tag has been removed and replaced with a more
+    general mechanism. The dispatcher now exposes all in-flight calls via its
+    `runningCalls()` and `queuedCalls()` methods. You can write code that
+    selects calls by tag, host, or whatever, and invokes `Call.cancel()` on the
+    ones that are no longer necessary.
+
+ *  **OkHttp no longer uses the global `java.net.Authenticator` by default.**
+    We've changed our `Authenticator` interface to authenticate web and proxy
+    authentication failures through a single method. An adapter for the old
+    authenticator is available in the `okhttp-urlconnection` module.
+
+ *  Fix: Don't throw `IOException` on `ResponseBody.contentLength()` or `close()`.
+ *  Fix: Never throw converting an `HttpUrl` to a `java.net.URI`. This changes
+    the `uri()` method to handle malformed percent-escapes and characters
+    forbidden by `URI`.
+ *  Fix: When a connect times out, attempt an alternate route. Previously route
+    selection was less efficient when differentiating failures.
+ *  New: `Response.peekBody()` lets you access the response body without
+    consuming it. This may be handy for interceptors!
+ *  New: `HttpUrl.newBuilder()` resolves a link to a builder.
+ *  New: Add the TLS version to the `Handshake`.
+ *  New: Drop `Request.uri()` and `Request#urlString()`. Just use
+    `Request.url().uri()` and `Request.url().toString()`.
+ *  New: Add URL to HTTP response logging.
+ *  New: Make `HttpUrl` the blessed URL method of `Request`.
+
+
+## Version 2.x
+
+[Change log](changelog_2x.md)
+
+
+ [bom]: https://en.wikipedia.org/wiki/Byte_order_mark
+ [conscrypt]: https://github.com/google/conscrypt/
+ [conscrypt_dependency]: https://github.com/google/conscrypt/#download
+ [grpc_http2]: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md
+ [https_server_sample]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
+ [junit_5_rules]: https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4-rulesupport
+ [major_versions]: https://jakewharton.com/java-interoperability-policy-for-major-version-updates/
+ [maven_provided]: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html
+ [nginx_959]: https://trac.nginx.org/nginx/ticket/959
+ [obsolete_apache_client]: https://gist.github.com/swankjesse/09721f72039e3a46cf50f94323deb82d
+ [obsolete_url_factory]: https://gist.github.com/swankjesse/dd91c0a8854e1559b00f5fc9c7bfae70
+ [okhttp_idling_resource]: https://github.com/JakeWharton/okhttp-idling-resource
+ [public_suffix]: https://publicsuffix.org/
+ [remove_cbc_ecdsa]: https://developers.google.com/web/updates/2016/12/chrome-56-deprecations#remove_cbc-mode_ecdsa_ciphers_in_tls
+ [require_android_5]: https://cashapp.github.io/2019-02-05/okhttp-3-13-requires-android-5
+ [tls_configuration_history]: https://square.github.io/okhttp/tls_configuration_history/
+ [upgrading_to_okhttp_4]: https://square.github.io/okhttp/upgrading_to_okhttp_4/
diff --git a/docs/code_of_conduct.md b/docs/code_of_conduct.md
new file mode 100644
index 0000000000..6a97690c5c
--- /dev/null
+++ b/docs/code_of_conduct.md
@@ -0,0 +1,102 @@
+Open Source Code of Conduct
+===========================
+
+At Square, we are committed to contributing to the open source community and simplifying the process
+of releasing and managing open source software. We’ve seen incredible support and enthusiasm from
+thousands of people who have already contributed to our projects — and we want to ensure our community
+continues to be truly open for everyone.
+
+This code of conduct outlines our expectations for participants, as well as steps to reporting
+unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and
+expect our code of conduct to be honored.
+
+Square’s open source community strives to:
+
+ * **Be open**: We invite anyone to participate in any aspect of our projects. Our community is
+   open, and any responsibility can be carried by a contributor who demonstrates the required
+   capacity and competence.
+
+ * **Be considerate**: People use our work, and we depend on the work of others. Consider users and
+   colleagues before taking action. For example, changes to code, infrastructure, policy, and
+   documentation may negatively impact others.
+
+ * **Be respectful**: We expect people to work together to resolve conflict, assume good intentions,
+   and act with empathy. Do not turn disagreements into personal attacks.
+
+ * **Be collaborative**: Collaboration reduces redundancy and improves the quality of our work. We
+   strive for transparency within our open source community, and we work closely with upstream
+   developers and others in the free software community to coordinate our efforts.
+
+ * **Be pragmatic**: Questions are encouraged and should be asked early in the process to avoid
+   problems later. Be thoughtful and considerate when seeking out the appropriate forum for your
+   questions. Those who are asked should be responsive and helpful.
+
+ * **Step down considerately**: Members of every project come and go. When somebody leaves or
+   disengages from the project, they should make it known and take the proper steps to ensure that
+   others can pick up where they left off.
+
+This code is not exhaustive or complete. It serves to distill our common understanding of a
+collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in
+the letter.
+
+Diversity Statement
+-------------------
+
+We encourage everyone to participate and are committed to building a community for all. Although we
+may not be able to satisfy everyone, we all agree that everyone is equal.
+
+Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone
+has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do
+our best to right the wrong.
+
+Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity,
+gender identity or expression, language, national origin, political beliefs, profession, race,
+religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate
+discrimination based on any of the protected characteristics above, including participants with
+disabilities.
+
+Reporting Issues
+----------------
+
+If you experience or witness unacceptable behavior — or have any other concerns — please report it by
+emailing [codeofconduct@squareup.com][codeofconduct_at]. For more details, please see our Reporting
+Guidelines below.
+
+Thanks
+------
+
+Some of the ideas and wording for the statements and guidelines above were based on work by the
+[Twitter][twitter_coc], [Ubuntu][ubuntu_coc], [GDC][gdc_coc], and [Django][django_coc] communities.
+We are thankful for their work.
+
+Reporting Guide
+---------------
+
+If you experience or witness unacceptable behavior — or have any other concerns — please report it by
+emailing [codeofconduct@squareup.com][codeofconduct_at]. All reports will be handled with
+discretion.
+
+In your report please include:
+
+ * Your contact information.
+ * Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional
+   witnesses, please include them as well.
+ * Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly
+   available record (e.g. a mailing list archive or a public IRC logger), please include a link.
+ * Any additional information that may be helpful.
+
+After filing a report, a representative from the Square Code of Conduct committee will contact you
+personally. The committee will then review the incident, follow up with any additional questions,
+and make a decision as to how to respond.
+
+Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual
+engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem
+appropriate, up to and including a permanent ban from all of Square spaces without warning.
+
+
+[codeofconduct_at]: mailto:codeofconduct@squareup.com
+[twitter_coc]: https://github.com/twitter/code-of-conduct/blob/master/code-of-conduct.md
+[ubuntu_coc]: https://ubuntu.com/community/code-of-conduct
+[gdc_coc]: https://www.gdconf.com/code-of-conduct
+[django_coc]: https://www.djangoproject.com/conduct/reporting/
+
diff --git a/docs/concurrency.md b/docs/concurrency.md
new file mode 100644
index 0000000000..eeb0fa219a
--- /dev/null
+++ b/docs/concurrency.md
@@ -0,0 +1,98 @@
+Concurrency
+===========
+
+This document describes the concurrency considerations for http/2 connections and the connection pool within OkHttp.
+
+## HTTP/2 Connections
+
+The HttpURLConnection API is a blocking API. You make a blocking write to send a request, and a blocking read to receive the response.
+
+#### Blocking APIs
+
+Blocking APIs are convenient because you get top-to-bottom procedural code without indirection. Network calls work like regular method calls: ask for data and it is returned. If the request fails, you get a stacktrace right were the call was made.
+
+Blocking APIs may be inefficient because you hold a thread idle while waiting on the network. Threads are expensive because they have both a memory overhead and a context-switching overhead.
+
+#### Framed protocols
+
+Framed protocols like http/2 don't lend themselves to blocking APIs. Each application-layer thread wants to do blocking I/O for a specific stream, but the streams are multiplexed on the socket. You can't just talk to the socket, you need to cooperate with the other application-layer threads that you're sharing it with.
+
+Framing rules make it impractical to implement http/2 correctly on a single blocking thread. The flow-control features introduce feedback between reads and writes, requiring writes to acknowledge reads and reads to throttle writes.
+
+In OkHttp we expose a blocking API over a framed protocol. This document explains the code and policy that makes that work.
+
+### Threads
+
+#### Application's calling thread
+
+The application-layer must block on writing I/O. We can't return from a write until we've pushed its bytes onto the socket. Otherwise, if the write fails we are unable to deliver its IOException to the application. We would have told the application layer that the write succeeded, but it didn't!
+
+The application-layer can also do blocking reads. If the application asks to read and there's nothing available, we need to hold that thread until either the bytes arrive, the stream is closed, or a timeout elapses. If we get bytes but there's nobody asking for them, we buffer them. We don't consider bytes as delivered for flow control until they're consumed by the application.
+
+Consider an application streaming a video over http/2. Perhaps the user pauses the video and the application stops reading bytes from this stream. The buffer will fill up, and flow control prevents the server from sending more data on this stream. When the user unpauses her video the buffer drains, the read is acknowledged, and the server proceeds to stream data.
+
+#### Shared reader thread
+
+We can't rely on application threads to read data from the socket. Application threads are transient: sometimes they're reading and writing and sometimes they're off doing application-layer things. But the socket is permanent, and it needs constant attention: we dispatch all incoming frames so the connection is good-to-go when the application layer needs it.
+
+So we have a dedicated thread for every socket that just reads frames and dispatches them.
+
+The reader thread must never run application-layer code. Otherwise one slow stream can hold up the entire connection.
+
+Similarly, the reader thread must never block on writing because this can deadlock the connection. Consider a client and server that both violate this rule. If you get unlucky, they could fill up their TCP buffers (so that writes block) and then use their reader threads to write a frame. Nobody is reading on either end, and the buffers are never drained.
+
+#### Do-stuff-later pool
+
+Sometimes there's an action required like calling the application layer or responding to a ping, and the thread discovering the action is not the thread that should do the work. We enqueue a runnable on this executor and it gets handled by one of the executor's threads.
+
+### Locks
+
+We have 3 different things that we synchronize on.
+
+#### Http2Connection
+
+This lock guards internal state of each connection. This lock is never held for blocking operations. That means that we acquire the lock, read or write a few fields and release the lock. No I/O and no application-layer callbacks.
+
+#### Http2Stream
+
+This lock guards the internal state of each stream. As above, it is never held for blocking operations. When we need to hold an application thread to block a read, we use wait/notify on this lock. This works because the lock is released while `wait()` is waiting.
+
+#### Http2Writer
+
+Socket writes are guarded by the Http2Writer. Only one stream can write at a time so that messages are not interleaved. Writes are either made by application-layer threads or the do-stuff-later pool.
+
+### Holding multiple locks
+
+You're allowed to take the Http2Connection lock while holding the Http2Writer lock. But not vice-versa. Because taking the Http2Writer lock can block.
+
+This is necessary for bookkeeping when creating new streams. Correct framing requires that stream IDs are sequential on the socket, so we need to bundle assigning the ID with sending the `SYN_STREAM` frame.
+
+## Connection Pool
+
+### Background
+
+A primary responsibility for any HTTP client is to efficiently manage network connections. Creating and establishing new connections require a fair amount of overhead and added latency. OkHttp will make every effort to reuse existing connections to avoid this overhead and added latency.
+
+Every OkHttpClient uses a connection pool. Its job is to maintain a reference to all open connections. When an HTTP request is started, OkHttp will attempt to reuse an existing connection from the pool. If there are no existing connections, a new one is created and put into the connection pool. For http/2, the connection can be reused immediately. For http/1, the request must be completed before it can be reused.
+
+Since HTTP requests frequently happen in parallel, the connection pool implementation must be thread-safe.
+
+### ConnectionPool, RealConnection, and StreamAllocation
+
+The primary classes involved with establishing, sharing and terminating connections are ConnectionPool, RealConnection and StreamAllocation.
+
+**ConnectionPool**: Manages reuse of HTTP and HTTP/2 connections for reduced latency. Every OkHttpClient has one, and its lifetime spans the lifetime of the OkHttpClient.
+
+**RealConnection**: The socket and streams of an HTTP and HTTP/2 connection. These are created on demand to fulfill HTTP requests. They may be reused for many HTTP request/response exchanges. Their lifetime is typically shorter than ConnectionPool.
+
+**StreamAllocation**: Coordinates the relationship between connections, streams and calls. These are created for a single HTTP request/response exchange. Their lifetime is typically shorter than RealConnection.
+
+### Locks
+
+A single lock is used to synchronize and guard the state of ConnectionPool, RealConnection and StreamAllocation.
+
+### ConnectionPool
+
+The fields in ConnectionPool, RealConnection and StreamAllocation are all guarded by the connection pool instance. This lock is never held while doing I/O (even closing a socket) to prevent contention.
+
+A single lock is preferred to avoid deadlock scenarios and the added overhead of aggregate lock/unlock that would occur if multiple locks were used.
\ No newline at end of file
diff --git a/docs/connections.md b/docs/connections.md
new file mode 100644
index 0000000000..5c2f525883
--- /dev/null
+++ b/docs/connections.md
@@ -0,0 +1,43 @@
+Connections
+===========
+
+Although you provide only the URL, OkHttp plans its connection to your webserver using three types: URL, Address, and Route.
+
+#### [URLs](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-http-url/)
+
+URLs (like `https://github.com/square/okhttp`) are fundamental to HTTP and the Internet. In addition to being a universal, decentralized naming scheme for everything on the web, they also specify how to access web resources.
+
+URLs are abstract:
+
+ * They specify that the call may be plaintext (`http`) or encrypted (`https`), but not which cryptographic algorithms should be used. Nor do they specify how to verify the peer's certificates (the [HostnameVerifier](http://developer.android.com/reference/javax/net/ssl/HostnameVerifier.html)) or which certificates can be trusted (the [SSLSocketFactory](http://developer.android.com/reference/org/apache/http/conn/ssl/SSLSocketFactory.html)).
+ * They don't specify whether a specific proxy server should be used or how to authenticate with that proxy server.
+
+They're also concrete: each URL identifies a specific path (like `/square/okhttp`) and query (like `?q=sharks&lang=en`). Each webserver hosts many URLs.
+
+#### [Addresses](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-address/)
+
+Addresses specify a webserver (like `github.com`) and all of the **static** configuration necessary to connect to that server: the port number, HTTPS settings, and preferred network protocols (like HTTP/2 or SPDY).
+
+URLs that share the same address may also share the same underlying TCP socket connection. Sharing a connection has substantial performance benefits: lower latency, higher throughput (due to [TCP slow start](http://www.igvita.com/2011/10/20/faster-web-vs-tcp-slow-start/)) and conserved battery. OkHttp uses a [ConnectionPool](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-connection-pool/) that automatically reuses HTTP/1.x connections and multiplexes HTTP/2 and SPDY connections.
+
+In OkHttp some fields of the address come from the URL (scheme, hostname, port) and the rest come from the [OkHttpClient](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-ok-http-client/).
+
+#### [Routes](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-route/)
+
+Routes supply the **dynamic** information necessary to actually connect to a webserver. This is the specific IP address to attempt (as discovered by a DNS query), the exact proxy server to use (if a [ProxySelector](http://developer.android.com/reference/java/net/ProxySelector.html) is in use), and which version of TLS to negotiate (for HTTPS connections).
+
+There may be many routes for a single address. For example, a webserver that is hosted in multiple datacenters may yield multiple IP addresses in its DNS response.
+
+#### [Connections](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-connection/)
+
+When you request a URL with OkHttp, here's what it does:
+
+ 1. It uses the URL and configured OkHttpClient to create an **address**. This address specifies how we'll connect to the webserver.
+ 2. It attempts to retrieve a connection with that address from the **connection pool**.
+ 3. If it doesn't find a connection in the pool, it selects a **route** to attempt. This usually means making a DNS request to get the server's IP addresses. It then selects a TLS version and proxy server if necessary.
+ 4. If it's a new route, it connects by building either a direct socket connection, a TLS tunnel (for HTTPS over an HTTP proxy), or a direct TLS connection. It does TLS handshakes as necessary.
+ 5. It sends the HTTP request and reads the response.
+
+If there's a problem with the connection, OkHttp will select another route and try again. This allows OkHttp to recover when a subset of a server's addresses are unreachable. It's also useful when a pooled connection is stale or if the attempted TLS version is unsupported.
+
+Once the response has been received, the connection will be returned to the pool so it can be reused for a future request. Connections are evicted from the pool after a period of inactivity.
diff --git a/docs/css/app.css b/docs/css/app.css
new file mode 100644
index 0000000000..48136b7efc
--- /dev/null
+++ b/docs/css/app.css
@@ -0,0 +1,48 @@
+@font-face {
+    font-family: cash-market;
+    src: url("https://cash-f.squarecdn.com/static/fonts/cash-market/v2/CashMarket-Regular.woff2") format("woff2");
+    font-weight: 400;
+    font-style: normal
+}
+
+@font-face {
+    font-family: cash-market;
+    src: url("https://cash-f.squarecdn.com/static/fonts/cash-market/v2/CashMarket-Medium.woff2") format("woff2");
+    font-weight: 500;
+    font-style: normal
+}
+
+@font-face {
+    font-family: cash-market;
+    src: url("https://cash-f.squarecdn.com/static/fonts/cash-market/v2/CashMarket-Bold.woff2") format("woff2");
+    font-weight: 700;
+    font-style: normal
+}
+
+body, input {
+    font-family: cash-market,"Helvetica Neue",helvetica,sans-serif;
+}
+
+.md-typeset h1, .md-typeset h2, .md-typeset h3, .md-typeset h4 {
+    font-family: cash-market,"Helvetica Neue",helvetica,sans-serif;
+    line-height: normal;
+    font-weight: bold;
+    color: #353535;
+}
+
+button.dl {
+  font-weight: 300;
+  font-size: 25px;
+  line-height: 40px;
+  padding: 3px 10px;
+  display: inline-block;
+  border-radius: 6px;
+  color: #f0f0f0;
+  margin: 5px 0;
+  width: auto;
+}
+
+.logo {
+  text-align: center;
+  margin-top: 150px;
+}
diff --git a/docs/events.md b/docs/events.md
new file mode 100644
index 0000000000..db8e346036
--- /dev/null
+++ b/docs/events.md
@@ -0,0 +1,239 @@
+Events
+======
+
+Events allow you to capture metrics on your application’s HTTP calls. Use events to monitor:
+
+ * The size and frequency of the HTTP calls your application makes. If you’re making too many calls, or your calls are too large, you should know about it!
+ * The performance of these calls on the underlying network. If the network’s performance isn’t sufficient, you need to either improve the network or use less of it.
+
+### EventListener
+
+Subclass [EventListener](https://square.github.io/okhttp/3.x/okhttp/okhttp3/EventListener.html) and override methods for the events you are interested in. In a successful HTTP call with no redirects or retries the sequence of events is described by this flow.
+
+![Events Diagram](images/events@2x.png)
+
+Here’s a [sample event listener](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java) that prints each event with a timestamp.
+
+```java
+class PrintingEventListener extends EventListener {
+  private long callStartNanos;
+
+  private void printEvent(String name) {
+    long nowNanos = System.nanoTime();
+    if (name.equals("callStart")) {
+      callStartNanos = nowNanos;
+    }
+    long elapsedNanos = nowNanos - callStartNanos;
+    System.out.printf("%.3f %s%n", elapsedNanos / 1000000000d, name);
+  }
+
+  @Override public void callStart(Call call) {
+    printEvent("callStart");
+  }
+
+  @Override public void callEnd(Call call) {
+    printEvent("callEnd");
+  }
+
+  @Override public void dnsStart(Call call, String domainName) {
+    printEvent("dnsStart");
+  }
+
+  @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+    printEvent("dnsEnd");
+  }
+
+  ...
+}
+```
+
+We make a couple calls:
+
+```java
+Request request = new Request.Builder()
+    .url("https://publicobject.com/helloworld.txt")
+    .build();
+
+System.out.println("REQUEST 1 (new connection)");
+try (Response response = client.newCall(request).execute()) {
+  // Consume and discard the response body.
+  response.body().source().readByteString();
+}
+
+System.out.println("REQUEST 2 (pooled connection)");
+try (Response response = client.newCall(request).execute()) {
+  // Consume and discard the response body.
+  response.body().source().readByteString();
+}
+```
+
+And the listener prints the corresponding events:
+
+```
+REQUEST 1 (new connection)
+0.000 callStart
+0.010 dnsStart
+0.017 dnsEnd
+0.025 connectStart
+0.117 secureConnectStart
+0.586 secureConnectEnd
+0.586 connectEnd
+0.587 connectionAcquired
+0.588 requestHeadersStart
+0.590 requestHeadersEnd
+0.591 responseHeadersStart
+0.675 responseHeadersEnd
+0.676 responseBodyStart
+0.679 responseBodyEnd
+0.679 connectionReleased
+0.680 callEnd
+REQUEST 2 (pooled connection)
+0.000 callStart
+0.001 connectionAcquired
+0.001 requestHeadersStart
+0.001 requestHeadersEnd
+0.002 responseHeadersStart
+0.082 responseHeadersEnd
+0.082 responseBodyStart
+0.082 responseBodyEnd
+0.083 connectionReleased
+0.083 callEnd
+```
+
+Notice how no connect events are fired for the second call. It reused the connection from the first request for dramatically better performance.
+
+### EventListener.Factory
+
+In the preceding example we used a field, `callStartNanos`, to track the elapsed time of each event. This is handy, but it won’t work if multiple calls are executing concurrently. To accommodate this, use a `Factory` to create a new `EventListener` instance for each `Call`. This allows each listener to keep call-specific state.
+
+This [sample factory](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java) creates a unique ID for each call and uses that ID to differentiate calls in log messages.
+
+```java
+class PrintingEventListener extends EventListener {
+  public static final Factory FACTORY = new Factory() {
+    final AtomicLong nextCallId = new AtomicLong(1L);
+
+    @Override public EventListener create(Call call) {
+      long callId = nextCallId.getAndIncrement();
+      System.out.printf("%04d %s%n", callId, call.request().url());
+      return new PrintingEventListener(callId, System.nanoTime());
+    }
+  };
+
+  final long callId;
+  final long callStartNanos;
+
+  public PrintingEventListener(long callId, long callStartNanos) {
+    this.callId = callId;
+    this.callStartNanos = callStartNanos;
+  }
+
+  private void printEvent(String name) {
+    long elapsedNanos = System.nanoTime() - callStartNanos;
+    System.out.printf("%04d %.3f %s%n", callId, elapsedNanos / 1000000000d, name);
+  }
+
+  @Override public void callStart(Call call) {
+    printEvent("callStart");
+  }
+
+  @Override public void callEnd(Call call) {
+    printEvent("callEnd");
+  }
+
+  ...
+}
+```
+
+We can use this listener to race a pair of concurrent HTTP requests:
+
+```java
+Request washingtonPostRequest = new Request.Builder()
+    .url("https://www.washingtonpost.com/")
+    .build();
+client.newCall(washingtonPostRequest).enqueue(new Callback() {
+  ...
+});
+
+Request newYorkTimesRequest = new Request.Builder()
+    .url("https://www.nytimes.com/")
+    .build();
+client.newCall(newYorkTimesRequest).enqueue(new Callback() {
+  ...
+});
+```
+
+Running this race over home WiFi shows the Times (`0002`) completes just slightly sooner than the Post (`0001`):
+
+```
+0001 https://www.washingtonpost.com/
+0001 0.000 callStart
+0002 https://www.nytimes.com/
+0002 0.000 callStart
+0002 0.010 dnsStart
+0001 0.013 dnsStart
+0001 0.022 dnsEnd
+0002 0.019 dnsEnd
+0001 0.028 connectStart
+0002 0.025 connectStart
+0002 0.072 secureConnectStart
+0001 0.075 secureConnectStart
+0001 0.386 secureConnectEnd
+0002 0.390 secureConnectEnd
+0002 0.400 connectEnd
+0001 0.403 connectEnd
+0002 0.401 connectionAcquired
+0001 0.404 connectionAcquired
+0001 0.406 requestHeadersStart
+0002 0.403 requestHeadersStart
+0001 0.414 requestHeadersEnd
+0002 0.411 requestHeadersEnd
+0002 0.412 responseHeadersStart
+0001 0.415 responseHeadersStart
+0002 0.474 responseHeadersEnd
+0002 0.475 responseBodyStart
+0001 0.554 responseHeadersEnd
+0001 0.555 responseBodyStart
+0002 0.554 responseBodyEnd
+0002 0.554 connectionReleased
+0002 0.554 callEnd
+0001 0.624 responseBodyEnd
+0001 0.624 connectionReleased
+0001 0.624 callEnd
+```
+
+The `EventListener.Factory` also makes it possible to limit metrics to a subset of calls. This one captures metrics on a random 10%:
+
+```java
+class MetricsEventListener extends EventListener {
+  private static final Factory FACTORY = new Factory() {
+    @Override public EventListener create(Call call) {
+      if (Math.random() < 0.10) {
+        return new MetricsEventListener(call);
+      } else {
+        return EventListener.NONE;
+      }
+    }
+  };
+
+  ...
+}
+```
+
+### Events with Failures
+
+When an operation fails, a failure method is called. This is `connectFailed()` for failures while building a connection to the server, and `callFailed()` when the HTTP call fails permanently. When a failure happens it is possible that a `start` event won’t have a corresponding `end` event.
+
+![Events Diagram](images/events_with_failures@2x.png)
+
+### Events with Retries and Follow-Ups
+
+OkHttp is resilient and can automatically recover from some connectivity failures. In this case, the `connectFailed()` event is not terminal and not followed by `callFailed()`. Event listeners will receive multiple events of the same type when retries are attempted.
+
+A single HTTP call may require follow-up requests to be made to handle authentication challenges, redirects, and HTTP-layer timeouts. In such cases multiple connections, requests, and responses may be attempted. Follow-ups are another reason a single call may trigger multiple events of the same type.
+
+![Events Diagram](images/events_with_failures_and_retries@2x.png)
+
+### Availability
+
+Events is available as a public API in OkHttp 3.11. Future releases may introduce new event types; you will need to override the corresponding methods to handle them.
diff --git a/docs/https.md b/docs/https.md
new file mode 100644
index 0000000000..142b7c3d9c
--- /dev/null
+++ b/docs/https.md
@@ -0,0 +1,105 @@
+HTTPS
+=====
+
+OkHttp attempts to balance two competing concerns:
+
+ * **Connectivity** to as many hosts as possible. That includes advanced hosts that run the latest versions of [boringssl](https://boringssl.googlesource.com/boringssl/) and less out of date hosts running older versions of [OpenSSL](https://www.openssl.org/).
+ * **Security** of the connection. This includes verification of the remote webserver with certificates and the privacy of data exchanged with strong ciphers.
+
+When negotiating a connection to an HTTPS server, OkHttp needs to know which [TLS versions](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-tls-version/) and [cipher suites](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-cipher-suite/) to offer. A client that wants to maximize connectivity would include obsolete TLS versions and weak-by-design cipher suites. A strict client that wants to maximize security would be limited to only the latest TLS version and strongest cipher suites.
+
+Specific security vs. connectivity decisions are implemented by [ConnectionSpec](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-connection-spec/). OkHttp includes four built-in connection specs:
+
+ * `RESTRICTED_TLS` is a secure configuration, intended to meet stricter compliance requirements.
+ * `MODERN_TLS` is a secure configuration that connects to modern HTTPS servers.
+ * `COMPATIBLE_TLS` is a secure configuration that connects to secure–but not current–HTTPS servers.
+ * `CLEARTEXT` is an insecure configuration that is used for `http://` URLs.
+
+These loosely follow the model set in [Google Cloud Policies](https://cloud.google.com/load-balancing/docs/ssl-policies-concepts). We [track changes](tls_configuration_history.md) to this policy.
+
+By default, OkHttp will attempt a `MODERN_TLS` connection.  However by configuring the client connectionSpecs you can allow a fall back to `COMPATIBLE_TLS` connection if the modern configuration fails.
+
+```java
+OkHttpClient client = new OkHttpClient.Builder()
+    .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+    .build();
+```
+
+The TLS versions and cipher suites in each spec can change with each release. For example, in OkHttp 2.2 we dropped support for SSL 3.0 in response to the [POODLE](http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html) attack. And in OkHttp 2.3 we dropped support for [RC4](http://en.wikipedia.org/wiki/RC4#Security). As with your desktop web browser, staying up-to-date with OkHttp is the best way to stay secure.
+
+You can build your own connection spec with a custom set of TLS versions and cipher suites. For example, this configuration is limited to three highly-regarded cipher suites. Its drawback is that it requires Android 5.0+ and a similarly current webserver.
+
+```java
+ConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+    .tlsVersions(TlsVersion.TLS_1_2)
+    .cipherSuites(
+          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256)
+    .build();
+
+OkHttpClient client = new OkHttpClient.Builder()
+    .connectionSpecs(Collections.singletonList(spec))
+    .build();
+```
+
+#### [Certificate Pinning](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CertificatePinning.java)
+
+By default, OkHttp trusts the certificate authorities of the host platform. This strategy maximizes connectivity, but it is subject to certificate authority attacks such as the [2011 DigiNotar attack](http://www.computerworld.com/article/2510951/cybercrime-hacking/hackers-spied-on-300-000-iranians-using-fake-google-certificate.html). It also assumes your HTTPS servers’ certificates are signed by a certificate authority.
+
+Use [CertificatePinner](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-certificate-pinner/) to restrict which certificates and certificate authorities are trusted. Certificate pinning increases security, but limits your server team’s abilities to update their TLS certificates. **Do not use certificate pinning without the blessing of your server’s TLS administrator!**
+
+```java
+  public CertificatePinning() {
+    client = new OkHttpClient.Builder()
+        .certificatePinner(new CertificatePinner.Builder()
+            .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+            .build())
+        .build();
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/robots.txt")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    for (Certificate certificate : response.handshake().peerCertificates()) {
+      System.out.println(CertificatePinner.pin(certificate));
+    }
+  }
+```
+
+#### [Customizing Trusted Certificates](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java)
+
+The full code sample shows how to replace the host platform’s certificate authorities with your own set. As above, **do not use custom certificates without the blessing of your server’s TLS administrator!**
+
+```java
+  private final OkHttpClient client;
+
+  public CustomTrust() {
+    SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());
+    client = new OkHttpClient.Builder()
+        .sslSocketFactory(sslContext.getSocketFactory())
+        .build();
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    System.out.println(response.body().string());
+  }
+
+  private InputStream trustedCertificatesInputStream() {
+    ... // Full source omitted. See sample.
+  }
+
+  public SSLContext sslContextForTrustedCertificates(InputStream in) {
+    ... // Full source omitted. See sample.
+  }
+```
diff --git a/docs/images/disable_advanced_profiling@2x.png b/docs/images/disable_advanced_profiling@2x.png
new file mode 100644
index 0000000000..672fb514b5
Binary files /dev/null and b/docs/images/disable_advanced_profiling@2x.png differ
diff --git a/docs/images/events@2x.png b/docs/images/events@2x.png
new file mode 100644
index 0000000000..24a2084772
Binary files /dev/null and b/docs/images/events@2x.png differ
diff --git a/docs/images/events_with_failures@2x.png b/docs/images/events_with_failures@2x.png
new file mode 100644
index 0000000000..7578c646fe
Binary files /dev/null and b/docs/images/events_with_failures@2x.png differ
diff --git a/docs/images/events_with_failures_and_retries@2x.png b/docs/images/events_with_failures_and_retries@2x.png
new file mode 100644
index 0000000000..55348a2681
Binary files /dev/null and b/docs/images/events_with_failures_and_retries@2x.png differ
diff --git a/website/static/icon-square.png b/docs/images/icon-square.png
similarity index 100%
rename from website/static/icon-square.png
rename to docs/images/icon-square.png
diff --git a/docs/images/interceptors@2x.png b/docs/images/interceptors@2x.png
new file mode 100644
index 0000000000..3a832cffd0
Binary files /dev/null and b/docs/images/interceptors@2x.png differ
diff --git a/website/static/logo-square.png b/docs/images/logo-square.png
similarity index 100%
rename from website/static/logo-square.png
rename to docs/images/logo-square.png
diff --git a/docs/interceptors.md b/docs/interceptors.md
new file mode 100644
index 0000000000..b3d759e9d0
--- /dev/null
+++ b/docs/interceptors.md
@@ -0,0 +1,193 @@
+Interceptors
+============
+
+Interceptors are a powerful mechanism that can monitor, rewrite, and retry calls. Here's a simple interceptor that logs the outgoing request and the incoming response.
+
+```java
+class LoggingInterceptor implements Interceptor {
+  @Override public Response intercept(Interceptor.Chain chain) throws IOException {
+    Request request = chain.request();
+
+    long t1 = System.nanoTime();
+    logger.info(String.format("Sending request %s on %s%n%s",
+        request.url(), chain.connection(), request.headers()));
+
+    Response response = chain.proceed(request);
+
+    long t2 = System.nanoTime();
+    logger.info(String.format("Received response for %s in %.1fms%n%s",
+        response.request().url(), (t2 - t1) / 1e6d, response.headers()));
+
+    return response;
+  }
+}
+```
+
+A call to `chain.proceed(request)` is a critical part of each interceptor’s implementation. This simple-looking method is where all the HTTP work happens, producing a response to satisfy the request. If `chain.proceed(request)` is being called more than once previous response bodies must be closed.
+
+Interceptors can be chained. Suppose you have both a compressing interceptor and a checksumming interceptor: you'll need to decide whether data is compressed and then checksummed, or checksummed and then compressed. OkHttp uses lists to track interceptors, and interceptors are called in order.
+
+![Interceptors Diagram](images/interceptors@2x.png)
+
+#### Application Interceptors
+
+Interceptors are registered as either _application_ or _network_ interceptors. We'll use the `LoggingInterceptor` defined above to show the difference.
+
+Register an _application_ interceptor by calling `addInterceptor()` on `OkHttpClient.Builder`:
+
+```java
+OkHttpClient client = new OkHttpClient.Builder()
+    .addInterceptor(new LoggingInterceptor())
+    .build();
+
+Request request = new Request.Builder()
+    .url("http://www.publicobject.com/helloworld.txt")
+    .header("User-Agent", "OkHttp Example")
+    .build();
+
+Response response = client.newCall(request).execute();
+response.body().close();
+```
+
+The URL `http://www.publicobject.com/helloworld.txt` redirects to `https://publicobject.com/helloworld.txt`, and OkHttp follows this redirect automatically. Our application interceptor is called **once** and the response returned from `chain.proceed()` has the redirected response:
+
+```
+INFO: Sending request http://www.publicobject.com/helloworld.txt on null
+User-Agent: OkHttp Example
+
+INFO: Received response for https://publicobject.com/helloworld.txt in 1179.7ms
+Server: nginx/1.4.6 (Ubuntu)
+Content-Type: text/plain
+Content-Length: 1759
+Connection: keep-alive
+```
+
+We can see that we were redirected because `response.request().url()` is different from `request.url()`. The two log statements log two different URLs.
+
+#### Network Interceptors
+
+Registering a network interceptor is quite similar. Call `addNetworkInterceptor()` instead of `addInterceptor()`:
+
+```java
+OkHttpClient client = new OkHttpClient.Builder()
+    .addNetworkInterceptor(new LoggingInterceptor())
+    .build();
+
+Request request = new Request.Builder()
+    .url("http://www.publicobject.com/helloworld.txt")
+    .header("User-Agent", "OkHttp Example")
+    .build();
+
+Response response = client.newCall(request).execute();
+response.body().close();
+```
+
+When we run this code, the interceptor runs twice. Once for the initial request to `http://www.publicobject.com/helloworld.txt`, and another for the redirect to `https://publicobject.com/helloworld.txt`.
+
+```
+INFO: Sending request http://www.publicobject.com/helloworld.txt on Connection{www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1}
+User-Agent: OkHttp Example
+Host: www.publicobject.com
+Connection: Keep-Alive
+Accept-Encoding: gzip
+
+INFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6ms
+Server: nginx/1.4.6 (Ubuntu)
+Content-Type: text/html
+Content-Length: 193
+Connection: keep-alive
+Location: https://publicobject.com/helloworld.txt
+
+INFO: Sending request https://publicobject.com/helloworld.txt on Connection{publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1}
+User-Agent: OkHttp Example
+Host: publicobject.com
+Connection: Keep-Alive
+Accept-Encoding: gzip
+
+INFO: Received response for https://publicobject.com/helloworld.txt in 80.9ms
+Server: nginx/1.4.6 (Ubuntu)
+Content-Type: text/plain
+Content-Length: 1759
+Connection: keep-alive
+```
+
+The network requests also contain more data, such as the `Accept-Encoding: gzip` header added by OkHttp to advertise support for response compression. The network interceptor's `Chain` has a non-null `Connection` that can be used to interrogate the IP address and TLS configuration that were used to connect to the webserver.
+
+#### Choosing between application and network interceptors
+
+Each interceptor chain has relative merits.
+
+**Application interceptors**
+
+ * Don't need to worry about intermediate responses like redirects and retries.
+ * Are always invoked once, even if the HTTP response is served from the cache.
+ * Observe the application's original intent. Unconcerned with OkHttp-injected headers like `If-None-Match`.
+ * Permitted to short-circuit and not call `Chain.proceed()`.
+ * Permitted to retry and make multiple calls to `Chain.proceed()`.
+
+**Network Interceptors**
+
+ * Able to operate on intermediate responses like redirects and retries.
+ * Not invoked for cached responses that short-circuit the network.
+ * Observe the data just as it will be transmitted over the network.
+ * Access to the `Connection` that carries the request.
+
+#### Rewriting Requests
+
+Interceptors can add, remove, or replace request headers. They can also transform the body of those requests that have one. For example, you can use an application interceptor to add request body compression if you're connecting to a webserver known to support it.
+
+```java
+/** This interceptor compresses the HTTP request body. Many webservers can't handle this! */
+final class GzipRequestInterceptor implements Interceptor {
+  @Override public Response intercept(Interceptor.Chain chain) throws IOException {
+    Request originalRequest = chain.request();
+    if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
+      return chain.proceed(originalRequest);
+    }
+
+    Request compressedRequest = originalRequest.newBuilder()
+        .header("Content-Encoding", "gzip")
+        .method(originalRequest.method(), gzip(originalRequest.body()))
+        .build();
+    return chain.proceed(compressedRequest);
+  }
+
+  private RequestBody gzip(final RequestBody body) {
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return body.contentType();
+      }
+
+      @Override public long contentLength() {
+        return -1; // We don't know the compressed length in advance!
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
+        body.writeTo(gzipSink);
+        gzipSink.close();
+      }
+    };
+  }
+}
+```
+
+#### Rewriting Responses
+
+Symmetrically, interceptors can rewrite response headers and transform the response body. This is generally more dangerous than rewriting request headers because it may violate the webserver's expectations!
+
+If you're in a tricky situation and prepared to deal with the consequences, rewriting response headers is a powerful way to work around problems. For example, you can fix a server's misconfigured `Cache-Control` response header to enable better response caching:
+
+```java
+/** Dangerous interceptor that rewrites the server's cache-control header. */
+private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() {
+  @Override public Response intercept(Interceptor.Chain chain) throws IOException {
+    Response originalResponse = chain.proceed(chain.request());
+    return originalResponse.newBuilder()
+        .header("Cache-Control", "max-age=60")
+        .build();
+  }
+};
+```
+
+Typically this approach works best when it complements a corresponding fix on the webserver!
diff --git a/docs/recipes.md b/docs/recipes.md
new file mode 100644
index 0000000000..c9bb42a6e3
--- /dev/null
+++ b/docs/recipes.md
@@ -0,0 +1,511 @@
+Recipes
+=======
+
+We've written some recipes that demonstrate how to solve common problems with OkHttp. Read through them to learn about how everything works together. Cut-and-paste these examples freely; that's what they're for.
+
+#### [Synchronous Get](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java)
+
+Download a file, print its headers, and print its response body as a string.
+
+The `string()` method on response body is convenient and efficient for small documents. But if the response body is large (greater than 1 MiB), avoid `string()` because it will load the entire document into memory. In that case, prefer to process the body as a stream.
+
+```java
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      Headers responseHeaders = response.headers();
+      for (int i = 0; i < responseHeaders.size(); i++) {
+        System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+      }
+
+      System.out.println(response.body().string());
+    }
+  }
+```
+
+#### [Asynchronous Get](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/AsynchronousGet.java)
+
+Download a file on a worker thread, and get called back when the response is readable. The callback is made after the response headers are ready. Reading the response body may still block. OkHttp doesn't currently offer asynchronous APIs to receive a response body in parts.
+
+```java
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build();
+
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        e.printStackTrace();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try (ResponseBody responseBody = response.body()) {
+          if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+          Headers responseHeaders = response.headers();
+          for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+            System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+          }
+
+          System.out.println(responseBody.string());
+        }
+      }
+    });
+  }
+```
+
+#### [Accessing Headers](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/AccessHeaders.java)
+
+Typically HTTP headers work like a `Map<String, String>`: each field has one value or none. But some headers permit multiple values, like Guava's [Multimap](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html). For example, it's legal and common for an HTTP response to supply multiple `Vary` headers. OkHttp's APIs attempt to make both cases comfortable.
+
+When writing request headers, use `header(name, value)` to set the only occurrence of `name` to `value`. If there are existing values, they will be removed before the new value is added. Use `addHeader(name, value)` to add a header without removing the headers already present.
+
+When reading response a header, use `header(name)` to return the _last_ occurrence of the named value. Usually this is also the only occurrence! If no value is present, `header(name)` will return null. To read all of a field's values as a list, use `headers(name)`.
+
+To visit all headers, use the `Headers` class which supports access by index.
+
+```java
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://api.github.com/repos/square/okhttp/issues")
+        .header("User-Agent", "OkHttp Headers.java")
+        .addHeader("Accept", "application/json; q=0.5")
+        .addHeader("Accept", "application/vnd.github.v3+json")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println("Server: " + response.header("Server"));
+      System.out.println("Date: " + response.header("Date"));
+      System.out.println("Vary: " + response.headers("Vary"));
+    }
+  }
+```
+
+#### [Posting a String](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostString.java)
+
+Use an HTTP POST to send a request body to a service. This example posts a markdown document to a web service that renders markdown as HTML. Because the entire request body is in memory simultaneously, avoid posting large (greater than 1 MiB) documents using this API.
+
+```java
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    String postBody = ""
+        + "Releases\n"
+        + "--------\n"
+        + "\n"
+        + " * _1.0_ May 6, 2013\n"
+        + " * _1.1_ June 15, 2013\n"
+        + " * _1.2_ August 11, 2013\n";
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+```
+
+#### [Post Streaming](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java)
+
+Here we `POST` a request body as a stream. The content of this request body is being generated as it's being written. This example streams directly into the [Okio](https://github.com/square/okio) buffered sink. Your programs may prefer an `OutputStream`, which you can get from `BufferedSink.outputStream()`.
+
+```java
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MEDIA_TYPE_MARKDOWN;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Numbers\n");
+        sink.writeUtf8("-------\n");
+        for (int i = 2; i <= 997; i++) {
+          sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i)));
+        }
+      }
+
+      private String factor(int n) {
+        for (int i = 2; i < n; i++) {
+          int x = n / i;
+          if (x * i == n) return factor(x) + " × " + i;
+        }
+        return Integer.toString(n);
+      }
+    };
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(requestBody)
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+```
+
+#### [Posting a File](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostFile.java)
+
+It's easy to use a file as a request body.
+
+```java
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    File file = new File("README.md");
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+```
+
+#### [Posting form parameters](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostForm.java)
+
+Use `FormBody.Builder` to build a request body that works like an HTML `<form>` tag. Names and values will be encoded using an HTML-compatible form URL encoding.
+
+```java
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    RequestBody formBody = new FormBody.Builder()
+        .add("search", "Jurassic Park")
+        .build();
+    Request request = new Request.Builder()
+        .url("https://en.wikipedia.org/w/index.php")
+        .post(formBody)
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+```
+
+#### [Posting a multipart request](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java)
+
+`MultipartBody.Builder` can build sophisticated request bodies compatible with HTML file upload forms. Each part of a multipart request body is itself a request body, and can define its own headers. If present, these headers should describe the part body, such as its `Content-Disposition`. The `Content-Length` and `Content-Type` headers are added automatically if they're available.
+
+```java
+  /**
+   * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
+   * these examples, please request your own client ID! https://api.imgur.com/oauth2
+   */
+  private static final String IMGUR_CLIENT_ID = "...";
+  private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
+    RequestBody requestBody = new MultipartBody.Builder()
+        .setType(MultipartBody.FORM)
+        .addFormDataPart("title", "Square Logo")
+        .addFormDataPart("image", "logo-square.png",
+            RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png")))
+        .build();
+
+    Request request = new Request.Builder()
+        .header("Authorization", "Client-ID " + IMGUR_CLIENT_ID)
+        .url("https://api.imgur.com/3/image")
+        .post(requestBody)
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+```
+
+#### [Parse a JSON Response With Moshi](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/ParseResponseWithMoshi.java)
+
+[Moshi](https://github.com/square/moshi) is a handy API for converting between JSON and Java objects. Here we're using it to decode a JSON response from a GitHub API.
+
+Note that `ResponseBody.charStream()` uses the `Content-Type` response header to select which charset to use when decoding the response body. It defaults to `UTF-8` if no charset is specified.
+
+```java
+  private final OkHttpClient client = new OkHttpClient();
+  private final Moshi moshi = new Moshi.Builder().build();
+  private final JsonAdapter<Gist> gistJsonAdapter = moshi.adapter(Gist.class);
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://api.github.com/gists/c2a7c39532239ff261be")
+        .build();
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      Gist gist = gistJsonAdapter.fromJson(response.body().source());
+
+      for (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {
+        System.out.println(entry.getKey());
+        System.out.println(entry.getValue().content);
+      }
+    }
+  }
+
+  static class Gist {
+    Map<String, GistFile> files;
+  }
+
+  static class GistFile {
+    String content;
+  }
+```
+
+#### [Response Caching](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java)
+
+To cache responses, you'll need a cache directory that you can read and write to, and a limit on the cache's size. The cache directory should be private, and untrusted applications should not be able to read its contents!
+
+It is an error to have multiple caches accessing the same cache directory simultaneously. Most applications should call `new OkHttpClient()` exactly once, configure it with their cache, and use that same instance everywhere. Otherwise the two cache instances will stomp on each other, corrupt the response cache, and possibly crash your program.
+
+Response caching uses HTTP headers for all configuration. You can add request headers like `Cache-Control: max-stale=3600` and OkHttp's cache will honor them. Your webserver configures how long responses are cached with its own response headers, like `Cache-Control: max-age=9600`. There are cache headers to force a cached response, force a network response, or force the network response to be validated with a conditional GET.
+
+```java
+  private final OkHttpClient client;
+
+  public CacheResponse(File cacheDirectory) throws Exception {
+    int cacheSize = 10 * 1024 * 1024; // 10 MiB
+    Cache cache = new Cache(cacheDirectory, cacheSize);
+
+    client = new OkHttpClient.Builder()
+        .cache(cache)
+        .build();
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build();
+
+    String response1Body;
+    try (Response response1 = client.newCall(request).execute()) {
+      if (!response1.isSuccessful()) throw new IOException("Unexpected code " + response1);
+
+      response1Body = response1.body().string();
+      System.out.println("Response 1 response:          " + response1);
+      System.out.println("Response 1 cache response:    " + response1.cacheResponse());
+      System.out.println("Response 1 network response:  " + response1.networkResponse());
+    }
+
+    String response2Body;
+    try (Response response2 = client.newCall(request).execute()) {
+      if (!response2.isSuccessful()) throw new IOException("Unexpected code " + response2);
+
+      response2Body = response2.body().string();
+      System.out.println("Response 2 response:          " + response2);
+      System.out.println("Response 2 cache response:    " + response2.cacheResponse());
+      System.out.println("Response 2 network response:  " + response2.networkResponse());
+    }
+
+    System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
+  }
+```
+To prevent a response from using the cache, use [`CacheControl.FORCE_NETWORK`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-n-e-t-w-o-r-k/). To prevent it from using the network, use [`CacheControl.FORCE_CACHE`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-c-a-c-h-e/). Be warned: if you use `FORCE_CACHE` and the response requires the network, OkHttp will return a `504 Unsatisfiable Request` response.
+
+#### [Canceling a Call](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java)
+
+Use `Call.cancel()` to stop an ongoing call immediately. If a thread is currently writing a request or reading a response, it will receive an `IOException`. Use this to conserve the network when a call is no longer necessary; for example when your user navigates away from an application. Both synchronous and asynchronous calls can be canceled.
+
+```java
+  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build();
+
+    final long startNanos = System.nanoTime();
+    final Call call = client.newCall(request);
+
+    // Schedule a job to cancel the call in 1 second.
+    executor.schedule(new Runnable() {
+      @Override public void run() {
+        System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f);
+        call.cancel();
+        System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f);
+      }
+    }, 1, TimeUnit.SECONDS);
+
+    System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f);
+    try (Response response = call.execute()) {
+      System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
+          (System.nanoTime() - startNanos) / 1e9f, response);
+    } catch (IOException e) {
+      System.out.printf("%.2f Call failed as expected: %s%n",
+          (System.nanoTime() - startNanos) / 1e9f, e);
+    }
+  }
+```
+
+#### [Timeouts](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/ConfigureTimeouts.java)
+
+Use timeouts to fail a call when its peer is unreachable. Network partitions can be due to client connectivity problems, server availability problems, or anything between. OkHttp supports connect, read, and write timeouts.
+
+```java
+  private final OkHttpClient client;
+
+  public ConfigureTimeouts() throws Exception {
+    client = new OkHttpClient.Builder()
+        .connectTimeout(10, TimeUnit.SECONDS)
+        .writeTimeout(10, TimeUnit.SECONDS)
+        .readTimeout(30, TimeUnit.SECONDS)
+        .build();
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      System.out.println("Response completed: " + response);
+    }
+  }
+```
+
+#### [Per-call Configuration](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PerCallSettings.java)
+
+All the HTTP client configuration lives in `OkHttpClient` including proxy settings, timeouts, and caches. When you need to change the configuration of a single call, call `OkHttpClient.newBuilder()`. This returns a builder that shares the same connection pool, dispatcher, and configuration with the original client. In the example below, we make one request with a 500 ms timeout and another with a 3000 ms timeout.
+
+```java
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
+        .build();
+
+    // Copy to customize OkHttp for this request.
+    OkHttpClient client1 = client.newBuilder()
+        .readTimeout(500, TimeUnit.MILLISECONDS)
+        .build();
+    try (Response response = client1.newCall(request).execute()) {
+      System.out.println("Response 1 succeeded: " + response);
+    } catch (IOException e) {
+      System.out.println("Response 1 failed: " + e);
+    }
+
+    // Copy to customize OkHttp for this request.
+    OkHttpClient client2 = client.newBuilder()
+        .readTimeout(3000, TimeUnit.MILLISECONDS)
+        .build();
+    try (Response response = client2.newCall(request).execute()) {
+      System.out.println("Response 2 succeeded: " + response);
+    } catch (IOException e) {
+      System.out.println("Response 2 failed: " + e);
+    }
+  }
+```
+
+#### [Handling authentication](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/Authenticate.java)
+
+OkHttp can automatically retry unauthenticated requests. When a response is `401 Not Authorized`, an `Authenticator` is asked to supply credentials. Implementations should build a new request that includes the missing credentials. If no credentials are available, return null to skip the retry.
+
+Use `Response.challenges()` to get the schemes and realms of any authentication challenges. When fulfilling a `Basic` challenge, use `Credentials.basic(username, password)` to encode the request header.
+
+```java
+  private final OkHttpClient client;
+
+  public Authenticate() {
+    client = new OkHttpClient.Builder()
+        .authenticator(new Authenticator() {
+          @Override public Request authenticate(Route route, Response response) throws IOException {
+            if (response.request().header("Authorization") != null) {
+              return null; // Give up, we've already attempted to authenticate.
+            }
+
+            System.out.println("Authenticating for response: " + response);
+            System.out.println("Challenges: " + response.challenges());
+            String credential = Credentials.basic("jesse", "password1");
+            return response.request().newBuilder()
+                .header("Authorization", credential)
+                .build();
+          }
+        })
+        .build();
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/secrets/hellosecret.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+```
+
+To avoid making many retries when authentication isn't working, you can return null to give up. For example, you may want to skip the retry when these exact credentials have already been attempted:
+
+```java
+  if (credential.equals(response.request().header("Authorization"))) {
+    return null; // If we already failed with these credentials, don't retry.
+   }
+```
+
+You may also skip the retry when you’ve hit an application-defined attempt limit:
+
+```java
+  if (responseCount(response) >= 3) {
+    return null; // If we've failed 3 times, give up.
+  }
+```
+
+This above code relies on this `responseCount()` method:
+
+```java
+  private int responseCount(Response response) {
+    int result = 1;
+    while ((response = response.priorResponse()) != null) {
+      result++;
+    }
+    return result;
+  }
+```
diff --git a/docs/releasing.md b/docs/releasing.md
new file mode 100644
index 0000000000..b19b2b8eaf
--- /dev/null
+++ b/docs/releasing.md
@@ -0,0 +1,105 @@
+Releasing
+=========
+
+### Prerequisite: Sonatype (Maven Central) Account
+
+Create an account on the [Sonatype issues site][sonatype_issues]. Ask an existing publisher to open
+an issue requesting publishing permissions for `com.squareup` projects.
+
+### Prerequisite: GPG Keys
+
+Generate a GPG key (RSA, 4096 bit, 3650 day) expiry, or use an existing one. You should leave the
+password empty for this key.
+
+```
+$ gpg --full-generate-key
+```
+
+Upload the GPG keys to public servers:
+
+```
+$ gpg --list-keys --keyid-format LONG
+/Users/johnbarber/.gnupg/pubring.kbx
+------------------------------
+pub   rsa4096/XXXXXXXXXXXXXXXX 2019-07-16 [SC] [expires: 2029-07-13]
+      YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
+uid           [ultimate] John Barber <jbarber@squareup.com>
+sub   rsa4096/ZZZZZZZZZZZZZZZZ 2019-07-16 [E] [expires: 2029-07-13]
+
+$ gpg --send-keys --keyserver keyserver.ubuntu.com XXXXXXXXXXXXXXXX
+```
+
+### Prerequisite: Gradle Properties
+
+Define publishing properties in `~/.gradle/gradle.properties`:
+
+```
+signing.keyId=1A2345F8
+signing.password=
+signing.secretKeyRingFile=/Users/jbarber/.gnupg/secring.gpg
+```
+
+`signing.keyId` is the GPG key's ID. Get it with this:
+
+   ```
+   $ gpg --list-keys --keyid-format SHORT
+   ```
+
+`signing.password` is the password for this key. This might be empty!
+
+`signing.secretKeyRingFile` is the absolute path for `secring.gpg`. You may need to export this
+file manually with the following command where `XXXXXXXX` is the `keyId` above:
+
+   ```
+   $ gpg --keyring secring.gpg --export-secret-key XXXXXXXX > ~/.gnupg/secring.gpg
+   ```
+
+
+Cutting a Release
+-----------------
+
+1. Update `CHANGELOG.md`.
+
+2. Set versions:
+
+    ```
+    export RELEASE_VERSION=X.Y.Z
+    export NEXT_VERSION=X.Y.Z-SNAPSHOT
+    ```
+
+3. Set environment variables with your [Sonatype credentials][sonatype_issues].
+
+    ```
+    export SONATYPE_NEXUS_USERNAME=johnbarber
+    export SONATYPE_NEXUS_PASSWORD=`pbpaste`
+    ```
+
+4. Update, build, and upload:
+
+    ```
+    sed -i "" \
+      "s/VERSION_NAME=.*/VERSION_NAME=$RELEASE_VERSION/g" \
+      gradle.properties
+    sed -i "" \
+      "s/\"com.squareup.okhttp3:\([^\:]*\):[^\"]*\"/\"com.squareup.okhttp3:\1:$RELEASE_VERSION\"/g" \
+      `find . -name "README.md"`
+    ./gradlew clean uploadArchives
+    ```
+
+5. Visit [Sonatype Nexus][sonatype_nexus] to promote (close then release) the artifact. Or drop it
+   if there is a problem!
+
+6. Tag the release, prepare for the next one, and push to GitHub.
+
+    ```
+    git commit -am "Prepare for release $RELEASE_VERSION."
+    git tag -a parent-$RELEASE_VERSION -m "Version $RELEASE_VERSION"
+    sed -i "" \
+      "s/VERSION_NAME=.*/VERSION_NAME=$NEXT_VERSION/g" \
+      gradle.properties
+    git commit -am "Prepare next development version."
+    git push && git push --tags
+    ```
+
+ [sonatype_issues]: https://issues.sonatype.org/
+ [sonatype_nexus]: https://oss.sonatype.org/
\ No newline at end of file
diff --git a/docs/security.md b/docs/security.md
new file mode 100644
index 0000000000..eb0bfcad27
--- /dev/null
+++ b/docs/security.md
@@ -0,0 +1,20 @@
+Security Policy
+===============
+
+## Supported Versions
+
+| Version | Supported  | Notes          |
+| ------- | ---------- | -------------- |
+| 4.x     | ✅         |                |
+| 3.14.x  | ✅         |                |
+| 3.12.x  | ✅         | Android 2.3+ (API level 9+) and Java 7+. Platforms may not support TLSv1.2. Until December 31, 2020  |
+
+
+## Reporting a Vulnerability
+
+Square recognizes the important contributions the security research community
+can make. We therefore encourage reporting security issues with the code
+contained in this repository.
+
+If you believe you have discovered a security vulnerability, please follow the
+guidelines at https://hackerone.com/square-open-source
diff --git a/docs/tls_configuration_history.md b/docs/tls_configuration_history.md
new file mode 100644
index 0000000000..7ed6e3f5c0
--- /dev/null
+++ b/docs/tls_configuration_history.md
@@ -0,0 +1,264 @@
+TLS Configuration History
+=========================
+
+OkHttp tracks the dynamic TLS ecosystem to balance connectivity and security. This page is a log of
+changes we've made over time to OkHttp's default TLS options.
+
+[OkHttp 3.14][OkHttp314]
+------------------------
+
+_2019-03-14_
+
+Remove 2 TLSv1.3 cipher suites that are neither available on OkHttp’s host platforms nor enabled in releases of Chrome and Firefox.
+
+##### RESTRICTED_TLS cipher suites
+
+ * TLS_AES_128_GCM_SHA256[¹][tlsv13_only]
+ * TLS_AES_256_GCM_SHA384[¹][tlsv13_only]
+ * TLS_CHACHA20_POLY1305_SHA256[¹][tlsv13_only]
+ * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
+ * TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
+ * TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
+ * TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
+ * TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
+ * TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
+ * **REMOVED:** ~~TLS_AES_128_CCM_SHA256[¹][tlsv13_only]~~
+ * **REMOVED:** ~~TLS_AES_128_CCM_8_SHA256[¹][tlsv13_only]~~
+
+##### MODERN_TLS / COMPATIBLE_TLS cipher suites
+
+ * TLS_AES_128_GCM_SHA256[¹][tlsv13_only]
+ * TLS_AES_256_GCM_SHA384[¹][tlsv13_only]
+ * TLS_CHACHA20_POLY1305_SHA256[¹][tlsv13_only]
+ * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
+ * TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
+ * TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
+ * TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
+ * TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
+ * TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
+ * TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA[²][http2_naughty]
+ * TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA[²][http2_naughty]
+ * TLS_RSA_WITH_AES_128_GCM_SHA256[²][http2_naughty]
+ * TLS_RSA_WITH_AES_256_GCM_SHA384[²][http2_naughty]
+ * TLS_RSA_WITH_AES_128_CBC_SHA[²][http2_naughty]
+ * TLS_RSA_WITH_AES_256_CBC_SHA[²][http2_naughty]
+ * TLS_RSA_WITH_3DES_EDE_CBC_SHA[²][http2_naughty]
+ * **REMOVED:** ~~TLS_AES_128_CCM_SHA256[¹][tlsv13_only]~~
+ * **REMOVED:** ~~TLS_AES_128_CCM_8_SHA256[¹][tlsv13_only]~~
+
+[OkHttp 3.13][OkHttp313]
+------------------------
+
+_2019-02-04_
+
+Remove TLSv1.1 and TLSv1 from MODERN_TLS. Change COMPATIBLE_TLS to support all TLS versions.
+
+##### RESTRICTED_TLS versions
+
+* TLSv1.3
+* TLSv1.2
+
+##### MODERN_TLS versions
+
+* TLSv1.3
+* TLSv1.2
+* **REMOVED:** ~~TLSv1.1~~
+* **REMOVED:** ~~TLSv1~~
+
+##### COMPATIBLE_TLS versions
+
+* **NEW:** TLSv1.3
+* **NEW:** TLSv1.2
+* **NEW:** TLSv1.1
+* TLSv1
+
+[OkHttp 3.12][OkHttp312]
+------------------------
+
+_2018-11-16_
+
+Added support for TLSv1.3.
+
+##### RESTRICTED_TLS cipher suites
+
+ * **NEW:** TLS_AES_128_GCM_SHA256[¹][tlsv13_only]
+ * **NEW:** TLS_AES_256_GCM_SHA384[¹][tlsv13_only]
+ * **NEW:** TLS_CHACHA20_POLY1305_SHA256[¹][tlsv13_only]
+ * **NEW:** TLS_AES_128_CCM_SHA256[¹][tlsv13_only]
+ * **NEW:** TLS_AES_128_CCM_8_SHA256[¹][tlsv13_only]
+ * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
+ * TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
+ * TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
+ * TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
+ * TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
+ * TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
+
+##### MODERN_TLS / COMPATIBLE_TLS cipher suites
+
+ * **NEW:** TLS_AES_128_GCM_SHA256[¹][tlsv13_only]
+ * **NEW:** TLS_AES_256_GCM_SHA384[¹][tlsv13_only]
+ * **NEW:** TLS_CHACHA20_POLY1305_SHA256[¹][tlsv13_only]
+ * **NEW:** TLS_AES_128_CCM_SHA256[¹][tlsv13_only]
+ * **NEW:** TLS_AES_128_CCM_8_SHA256[¹][tlsv13_only]
+ * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
+ * TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
+ * TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
+ * TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
+ * TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
+ * TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
+ * TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA[²][http2_naughty]
+ * TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA[²][http2_naughty]
+ * TLS_RSA_WITH_AES_128_GCM_SHA256[²][http2_naughty]
+ * TLS_RSA_WITH_AES_256_GCM_SHA384[²][http2_naughty]
+ * TLS_RSA_WITH_AES_128_CBC_SHA[²][http2_naughty]
+ * TLS_RSA_WITH_AES_256_CBC_SHA[²][http2_naughty]
+ * TLS_RSA_WITH_3DES_EDE_CBC_SHA[²][http2_naughty]
+
+##### RESTRICTED_TLS versions
+
+* **NEW:** TLSv1.3
+* TLSv1.2
+
+##### MODERN_TLS versions
+
+* **NEW:** TLSv1.3
+* TLSv1.2
+* TLSv1.1
+* TLSv1
+
+##### COMPATIBLE_TLS versions
+
+* TLSv1
+
+[OkHttp 3.11][OkHttp311]
+------------------------
+
+_2018-07-12_
+
+Added a new extra strict RESTRICTED_TLS configuration inspired by [Google Cloud’s similar policy][googlecloud_ssl_policy]. It is appropriate when both the host platform
+(JVM/Conscrypt/Android) and target webserver are current.
+
+##### RESTRICTED_TLS cipher suites
+
+ * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
+ * TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
+ * TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
+ * TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
+ * TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
+ * TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
+
+##### RESTRICTED_TLS versions
+
+ * TLSv1.2
+
+[OkHttp 3.10][OkHttp310]
+------------------------
+
+_2018-02-24_
+
+Remove two rarely-used cipher suites from the default set. This tracks a <a href="https://developers.google.com/web/updates/2016/12/chrome-56-deprecations#remove_cbc-mode_ecdsa_ciphers_in_tls">Chromium change</a> to remove these cipher suites because they are fragile and rarely-used.
+
+##### MODERN_TLS / COMPATIBLE_TLS cipher suites
+
+ * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
+ * TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
+ * TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
+ * TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
+ * TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
+ * TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
+ * TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA[²][http2_naughty]
+ * TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA[²][http2_naughty]
+ * TLS_RSA_WITH_AES_128_GCM_SHA256[²][http2_naughty]
+ * TLS_RSA_WITH_AES_256_GCM_SHA384[²][http2_naughty]
+ * TLS_RSA_WITH_AES_128_CBC_SHA[²][http2_naughty]
+ * TLS_RSA_WITH_AES_256_CBC_SHA[²][http2_naughty]
+ * TLS_RSA_WITH_3DES_EDE_CBC_SHA[²][http2_naughty]
+ * **REMOVED:** ~~TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA~~
+ * **REMOVED:** ~~TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA~~
+
+
+[OkHttp 3.5][OkHttp35]
+----------------------
+
+_2016-11-30_
+
+Remove three old cipher suites and add five new ones. This tracks changes in what's available on
+Android and Java, and also what cipher suites recent releases of Chrome and Firefox support by
+default.
+
+##### MODERN_TLS / COMPATIBLE_TLS cipher suites
+
+ * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
+ * TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
+ * **NEW:** TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
+ * **NEW:** TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
+ * **NEW:** TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
+ * **NEW:** TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
+ * TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA[²][http2_naughty]
+ * TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA[²][http2_naughty]
+ * TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA[²][http2_naughty]
+ * TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA[²][http2_naughty]
+ * TLS_RSA_WITH_AES_128_GCM_SHA256[²][http2_naughty]
+ * **NEW:** TLS_RSA_WITH_AES_256_GCM_SHA384[²][http2_naughty]
+ * TLS_RSA_WITH_AES_128_CBC_SHA[²][http2_naughty]
+ * TLS_RSA_WITH_AES_256_CBC_SHA[²][http2_naughty]
+ * TLS_RSA_WITH_3DES_EDE_CBC_SHA[²][http2_naughty]
+ * **REMOVED:** ~~TLS_DHE_RSA_WITH_AES_128_CBC_SHA~~
+ * **REMOVED:** ~~TLS_DHE_RSA_WITH_AES_128_GCM_SHA256~~
+ * **REMOVED:** ~~TLS_DHE_RSA_WITH_AES_256_CBC_SHA~~
+
+[OkHttp 3.0][OkHttp30]
+----------------------
+
+_2016-01-13_
+
+##### MODERN_TLS / COMPATIBLE_TLS cipher suites
+
+ * TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
+ * TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
+ * TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
+ * TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA[²][http2_naughty]
+ * TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA[²][http2_naughty]
+ * TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA[²][http2_naughty]
+ * TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA[²][http2_naughty]
+ * TLS_DHE_RSA_WITH_AES_128_CBC_SHA[²][http2_naughty]
+ * TLS_DHE_RSA_WITH_AES_256_CBC_SHA[²][http2_naughty]
+ * TLS_RSA_WITH_AES_128_GCM_SHA256[²][http2_naughty]
+ * TLS_RSA_WITH_AES_128_CBC_SHA[²][http2_naughty]
+ * TLS_RSA_WITH_AES_256_CBC_SHA[²][http2_naughty]
+ * TLS_RSA_WITH_3DES_EDE_CBC_SHA[²][http2_naughty]
+</dl>
+
+##### MODERN_TLS versions
+
+ * TLSv1.2
+ * TLSv1.1
+ * TLSv1
+
+##### COMPATIBLE_TLS versions
+
+ * TLSv1
+
+---
+
+<a name="tlsv13_only"></a>
+#### ¹ TLSv1.3 Only
+
+Cipher suites that are only available with TLSv1.3.
+
+<a name="http2_naughty"></a>
+#### ² HTTP/2 Cipher Suite Denylist
+
+Cipher suites that are [discouraged for use][http2_denylist] with HTTP/2. OkHttp includes them because better suites are not commonly available. For example, none of the better cipher suites listed above shipped with Android 4.4 or Java 7.
+
+ [OkHttp314]: https://github.com/square/okhttp/blob/master/CHANGELOG.md#version-3140
+ [OkHttp313]: https://github.com/square/okhttp/blob/master/CHANGELOG.md#version-3130
+ [OkHttp312]: https://github.com/square/okhttp/blob/master/CHANGELOG.md#version-3120
+ [OkHttp311]: https://github.com/square/okhttp/blob/master/CHANGELOG.md#version-3110
+ [OkHttp310]: https://github.com/square/okhttp/blob/master/CHANGELOG.md#version-3100
+ [OkHttp35]: https://github.com/square/okhttp/blob/master/CHANGELOG.md#version-350
+ [OkHttp30]: https://github.com/square/okhttp/blob/master/CHANGELOG.md#version-300
+ [googlecloud_ssl_policy]: https://cloud.google.com/load-balancing/docs/ssl-policies-concepts
+ [tlsv13_only]: #tlsv13_only
+ [http2_naughty]: #http2_naughty
+ [http2_denylist]: https://tools.ietf.org/html/rfc7540#appendix-A
diff --git a/docs/upgrading_to_okhttp_4.md b/docs/upgrading_to_okhttp_4.md
new file mode 100644
index 0000000000..0d3c53917e
--- /dev/null
+++ b/docs/upgrading_to_okhttp_4.md
@@ -0,0 +1,279 @@
+Upgrading to OkHttp 4
+=====================
+
+OkHttp 4.x upgrades our implementation language from Java to Kotlin and keeps everything else the
+same. We’ve chosen Kotlin because it gives us powerful new capabilities while integrating closely
+with Java.
+
+We spent a lot of time and energy on retaining strict compatibility with OkHttp 3.x. We’re even
+keeping the package name the same: `okhttp3`!
+
+There are three kinds of compatibility we’re tracking:
+
+ * **Binary compatibility** is the ability to compile a program against OkHttp 3.x, and then to run
+   it against OkHttp 4.x. We’re using the excellent [japicmp][japicmp] library via its
+   [Gradle plugin][japicmp_gradle] to enforce binary compatibility.
+
+ * **Java source compatibility** is the ability to upgrade Java uses of OkHttp 3.x to 4.x without
+   changing `.java` files.
+
+ * **Kotlin source compatibility** is the ability to upgrade Kotlin uses of OkHttp 3.x to 4.x
+   without changing `.kt` files.
+
+With a few small exceptions (below), OkHttp 4.x is both binary- and Java source-compatible with
+OkHttp 3.x. You can use an OkHttp 4.x .jar file with applications or libraries built for OkHttp 3.x.
+
+OkHttp is **not** source-compatible for Kotlin callers, but upgrading should be automatic thanks to
+Kotlin’s powerful deprecation features. Most developers should be able to use IntelliJ’s _Code
+Cleanup_ for a safe and fast upgrade.
+
+
+Backwards-Incompatible Changes
+------------------------------
+
+#### OkHttpClient final methods
+
+`OkHttpClient` has 26 accessors like `interceptors()` and `writeTimeoutMillis()` that were non-final
+in OkHttp 3.x and are final in 4.x. These were made non-final for use with mocking frameworks like
+[Mockito][mockito]. We believe subtyping `OkHttpClient` is the wrong way to test with OkHttp. If
+you must, mock `Call.Factory` which is the interface that `OkHttpClient` implements.
+
+#### Internal API changes
+
+The `okhttp3.internal` package is not a published API and we change it frequently without warning.
+Depending on code in this package is bad and will cause you problems with any upgrade! But the 4.x
+will be particularly painful to naughty developers that import from this package! We changed a lot
+to take advantage of sweet Kotlin features.
+
+#### Credentials.basic()
+
+The username and password parameters to `Credentials.basic()` are now non-null strings. In OkHttp
+3.x, null would yield a username or password of "null".
+
+#### HttpUrl.queryParameterValues()
+
+The return type of `HttpUrl.queryParameterValues()` is `List<String?>`. Lists that may contain null
+are uncommon and Kotlin callers may have incorrectly assigned the result to `List<String>`.
+
+
+Code Cleanup
+------------
+
+IntelliJ and Android Studio offer a **Code Cleanup** feature that will automatically update
+deprecated APIs with their replacements. Access this feature from the _Search Anywhere_ dialog
+(double-press shift) or under the _Analyze_ menu.
+
+We’ve included deprecated APIs in OkHttp 4.0 because they make migration easy. We will remove them
+in a future release! If you’re skipping releases, it’ll be much easier if you upgrade to OkHttp 4.0
+as an intermediate step.
+
+#### Vars and Vals
+
+Java doesn’t have language support for properties so developers make do with getters and setters.
+Kotlin does have properties and we take advantage of them in OkHttp.
+
+ * **Address**: certificatePinner, connectionSpecs, dns, hostnameVerifier, protocols, proxy,
+   proxyAuthenticator, proxySelector, socketFactory, sslSocketFactory, url
+ * **Cache**: directory
+ * **CacheControl**: immutable, maxAgeSeconds, maxStaleSeconds, minFreshSeconds, mustRevalidate,
+   noCache, noStore, noTransform, onlyIfCached, sMaxAgeSeconds
+ * **Challenge**: authParams, charset, realm, scheme
+ * **CipherSuite**: javaName
+ * **ConnectionSpec**: cipherSuites, supportsTlsExtensions, tlsVersions
+ * **Cookie**: domain, expiresAt, hostOnly, httpOnly, name, path, persistent, value
+ * **Dispatcher**: executorService
+ * **FormBody**: size
+ * **Handshake**: cipherSuite, localCertificates, localPrincipal, peerCertificates, peerPrincipal,
+   tlsVersion
+ * **HandshakeCertificates**: keyManager, trustManager
+ * **Headers**: size
+ * **HeldCertificate**: certificate, keyPair
+ * **HttpLoggingInterceptor**: level
+ * **HttpUrl**: encodedFragment, encodedPassword, encodedPath, encodedPathSegments, encodedQuery,
+   encodedUsername, fragment, host, password, pathSegments, pathSize, port, query,
+   queryParameterNames, querySize, scheme, username
+ * **MockResponse**: headers, http2ErrorCode, socketPolicy, status, trailers
+ * **MockWebServer**: bodyLimit, port, protocolNegotiationEnabled, protocols, requestCount,
+   serverSocketFactory
+ * **MultipartBody.Part**: body, headers
+ * **MultipartBody.**: boundary, parts, size, type
+ * **OkHttpClient**: authenticator, cache, callTimeoutMillis, certificatePinner,
+   connectTimeoutMillis, connectionPool, connectionSpecs, cookieJar, dispatcher, dns,
+   eventListenerFactory, followRedirects, followSslRedirects, hostnameVerifier, interceptors,
+   networkInterceptors, pingIntervalMillis, protocols, proxy, proxyAuthenticator, proxySelector,
+   readTimeoutMillis, retryOnConnectionFailure, socketFactory, sslSocketFactory, writeTimeoutMillis
+ * **PushPromise**: headers, method, path, response
+ * **Request**: body, cacheControl, headers, method, url
+ * **Response**: body, cacheControl, cacheResponse, code, handshake, headers, message,
+   networkResponse, priorResponse, protocol, receivedResponseAtMillis, request, sentRequestAtMillis
+ * **Route**: address, proxy, socketAddress
+ * **TlsVersion**: javaName
+
+#### Renamed Functions
+
+* **Headers.of()**: for symmetry with `listOf()`, `setOf()`, etc., we’ve replaced
+  `Headers.of(String...)` with `headersOf(vararg String)`.
+
+#### Extension Functions
+
+We’ve migrated from static functions to extension functions where we think they fit.
+
+| Java                                | Kotlin                          |
+| :---------------------------------- | :------------------------------ |
+| Handshake.get(SSLSession)           | SSLSession.handshake()          |
+| Headers.of(Map<String, String>)     | Map<String, String>.toHeaders() |
+| HttpUrl.get(String)                 | String.toHttpUrl()              |
+| HttpUrl.get(URI)                    | URI.toHttpUrlOrNull()           |
+| HttpUrl.get(URL)                    | URL.toHttpUrlOrNull()           |
+| HttpUrl.parse(String)               | String.toHttpUrlOrNull()        |
+| HttpUrl.uri()                       | HttpUrl.toUri()                 |
+| HttpUrl.url()                       | HttpUrl.toUrl()                 |
+| MediaType.get(String)               | String.toMediaType()            |
+| MediaType.parse(String)             | String.toMediaTypeOrNull()      |
+| RequestBody.create(ByteArray)       | ByteArray.toRequestBody()       |
+| RequestBody.create(ByteString)      | ByteString.toRequestBody()      |
+| RequestBody.create(File)            | File.asRequestBody()            |
+| RequestBody.create(String)          | String.toRequestBody()          |
+| ResponseBody.create(BufferedSource) | BufferedSource.asResponseBody() |
+| ResponseBody.create(ByteArray)      | ByteArray.toResponseBody()      |
+| ResponseBody.create(ByteString)     | ByteString.toResponseBody()     |
+| ResponseBody.create(String)         | String.toResponseBody()         |
+
+
+SAM Conversions
+---------------
+
+When you use Java APIs from Kotlin you can operate on Java interfaces as if they were Kotlin
+lambdas. The [feature][java_sams] is available for interfaces that define a Single Abstract Method
+(SAM).
+
+But when you use Kotlin APIs from Kotlin there’s no automatic conversion. Code that used SAM lambdas
+with OkHttp 3.x: must use `object :` with OkHttp 4.x:
+
+Kotlin calling OkHttp 3.x:
+
+```kotlin
+val client = OkHttpClient.Builder()
+    .dns { hostname -> InetAddress.getAllByName(hostname).toList() }
+    .build()
+```
+
+Kotlin calling OkHttp 4.x:
+
+```kotlin
+val client = OkHttpClient.Builder()
+    .dns(object : Dns {
+      override fun lookup(hostname: String) =
+          InetAddress.getAllByName(hostname).toList()
+    })
+    .build()
+```
+
+SAM conversion impacts these APIs:
+
+ * Authenticator
+ * Dispatcher.setIdleCallback(Runnable)
+ * Dns
+ * EventListener.Factory
+ * HttpLoggingInterceptor.Logger
+ * LoggingEventListener.Factory
+ * OkHttpClient.Builder.hostnameVerifier(HostnameVerifier)
+
+JetBrains [is working on][kotlin_sams] SAM conversions of Kotlin interfaces. Expect it in a future
+release of the Kotlin language.
+
+
+Companion Imports
+-----------------
+
+The equivalent of static methods in Java is companion object functions in Kotlin. The bytecode is
+the same but `.kt` files now need `Companion` in the import.
+
+This works with OkHttp 3.x:
+
+```kotlin
+import okhttp3.CipherSuite.forJavaName
+```
+
+But OkHttp 4.x needs a `Companion`:
+
+```kotlin
+import okhttp3.CipherSuite.Companion.forJavaName
+```
+
+In the unlikely event that you have a lot of these, run this:
+
+```bash
+sed -i "" \
+  's/^\(import okhttp3\.[^.]*\)\.\([a-z][a-zA-Z]*\)$/\1.Companion.\2/g' \
+  `find . -name "*.kt"`
+```
+
+
+Advanced Profiling
+------------------
+
+Android Studio’s Advanced Profiling feature rewrites OkHttp bytecode for instrumentation.
+Unfortunately it crashes on OkHttp 4.x’s bytecode. Until [Google’s bug][advanced_profiling_bug] is
+fixed you must disable advanced profiling in Android Studio.
+
+![Disable Advanced Profiling](images/disable_advanced_profiling@2x.png)
+
+
+R8 / ProGuard
+-------------
+
+R8 and ProGuard are both code optimizers for `.class` files.
+
+R8 is the [default optimizer][r8] in Android Studio 3.4 and newer. It works well with all
+releases of OkHttp.
+
+ProGuard was the previous default. We’re [tracking problems][proguard_problems] with interactions
+between ProGuard, OkHttp 4.x, and Kotlin-originated `.class` files. Make sure you’re on the latest
+release if you’re using ProGuard,
+
+
+Gradle
+------
+
+OkHttp 4’s minimum requirements are Java 8+ and Android 5+. These requirements were
+[first introduced][require_android_5] with OkHttp 3.13.
+
+Here’s what you need in `build.gradle` to target Java 8 byte code for Kotlin, Java, and Android
+plugins respectively.
+
+```
+compileKotlin {
+  kotlinOptions {
+    jvmTarget = "1.8"
+  }
+}
+compileTestKotlin {
+  kotlinOptions {
+    jvmTarget = "1.8"
+  }
+}
+
+compileJava {
+  sourceCompatibility = JavaVersion.VERSION_1_8
+  targetCompatibility = JavaVersion.VERSION_1_8
+}
+
+android {
+  compileOptions {
+    sourceCompatibility JavaVersion.VERSION_1_8
+    targetCompatibility JavaVersion.VERSION_1_8
+  }
+}
+```
+
+
+ [advanced_profiling_bug]: https://issuetracker.google.com/issues/135141615
+ [japicmp]: https://github.com/siom79/japicmp
+ [japicmp_gradle]: https://github.com/melix/japicmp-gradle-plugin
+ [java_sams]: https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions
+ [kotlin_sams]: https://youtrack.jetbrains.com/issue/KT-11129
+ [mockito]: https://site.mockito.org/
+ [proguard_problems]: https://github.com/square/okhttp/issues/5167
+ [require_android_5]: https://cashapp.github.io/2019-02-05/okhttp-3-13-requires-android-5
+ [r8]: https://developer.android.com/studio/releases#r8-default
diff --git a/docs/works_with_okhttp.md b/docs/works_with_okhttp.md
new file mode 100644
index 0000000000..8bb7716109
--- /dev/null
+++ b/docs/works_with_okhttp.md
@@ -0,0 +1,34 @@
+Works with OkHttp
+=================
+
+Here’s some libraries that work nicely with OkHttp.
+
+ * [Chucker](https://github.com/ChuckerTeam/chucker): An in-app HTTP inspector for Android OkHttp clients.
+ * [Coil](https://github.com/coil-kt/coil): An image loading library for Android backed by Kotlin Coroutines.
+ * [Communicator](https://github.com/Taig/Communicator): An OkHttp wrapper for Scala built with Android in mind.
+ * [CWAC-NetSecurity](https://github.com/commonsguy/cwac-netsecurity): Simplifying Secure Internet Access.
+ * [Flipper](https://fbflipper.com/): A desktop debugging platform for mobile developers.
+ * [Fresco](https://github.com/facebook/fresco): An Android library for managing images and the memory they use.
+ * [Glide](https://github.com/bumptech/glide): An image loading and caching library for Android focused on smooth scrolling.
+ * [GoogleAppEngineOkHttp](https://github.com/apkelly/GoogleAppEngineOkHttp): An OkHttp Call that works on Google App Engine.
+ * [Hunter](https://github.com/Leaking/Hunter): Configure all OkHttpClients centrally.
+ * ⬜️ [Moshi](https://github.com/square/moshi): A modern JSON library for Android and Java.
+ * [Ok2Curl](https://github.com/mrmike/Ok2Curl): Convert OkHttp requests into curl logs.
+ * [OkHttp AWS Signer](https://github.com/babbel/okhttp-aws-signer): AWS V4 signing algorithm for OkHttp requests
+ * [okhttp-digest](https://github.com/rburgst/okhttp-digest): A digest authenticator for OkHttp.
+ * [OkHttp Idling Resource](https://github.com/JakeWharton/okhttp-idling-resource): An Espresso IdlingResource for OkHttp.
+ * [okhttp-client-mock](https://github.com/gmazzo/okhttp-client-mock): A simple OKHttp client mock, using a programmable request interceptor.
+ * [OkHttp Profiler](https://plugins.jetbrains.com/plugin/11249-okhttp-profiler): An IntelliJ plugin for monitoring OkHttp calls.
+ * [OkReplay](https://github.com/airbnb/okreplay): Record and replay OkHttp network interaction in your tests.
+ * [okhttp-signpost](https://github.com/pakerfeldt/okhttp-signpost): OAuth signing with signpost and OkHttp.
+ * [okhttp-staleiferror-interceptor](https://github.com/PeelTechnologies/okhttp-staleiferror-interceptor/): serve stale responses when the server isn’t reachable.
+ * [okhttp-stats](https://github.com/flipkart-incubator/okhttp-stats): Get stats like average network speed.
+ * ⬜️ [Okio](https://github.com/square/okio/): A modern I/O API for Java.
+ * [OkLog](https://github.com/simonpercic/OkLog): Response logging interceptor for OkHttp. Logs a URL link with URL-encoded response for every OkHttp call.
+ * [Okurl](https://github.com/yschimke/okurl/wiki) A curl-like client for social networks and other APIs.
+ * [PersistentCookieJar](https://github.com/franmontiel/PersistentCookieJar): A persistent `CookieJar`.
+ * ⬜️ [Picasso](https://github.com/square/picasso): A powerful image downloading and caching library for Android.
+ * ⬜️ [Retrofit](https://github.com/square/retrofit): Type-safe HTTP client for Android and Java by Square.
+ * [Stetho](https://github.com/facebook/stetho): Stetho is a debug bridge for Android applications.
+ * [Thrifty](https://github.com/Microsoft/thrifty): An implementation of Apache Thrift for Android.
+ * ⬜️ [Wire](https://github.com/square/wire): Clean, lightweight protocol buffers for Android and Java.
diff --git a/gradle.properties b/gradle.properties
index 7c006bc8bb..1a261d695b 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,7 +1,7 @@
 org.gradle.jvmargs='-Dfile.encoding=UTF-8'
 
 GROUP=com.squareup.okhttp3
-VERSION_NAME=4.0.0-SNAPSHOT
+VERSION_NAME=4.2.0-SNAPSHOT
 
 POM_URL=https://github.com/square/okhttp
 POM_SCM_URL=https://github.com/square/okhttp
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index ed5aaee4f8..e0c4de36dd 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-5.4-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.5-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
diff --git a/gradlew b/gradlew
index b0d6d0ab5d..8e25e6c19d 100755
--- a/gradlew
+++ b/gradlew
@@ -7,7 +7,7 @@
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
-#      http://www.apache.org/licenses/LICENSE-2.0
+#      https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
diff --git a/gradlew.bat b/gradlew.bat
index 15e1ee37a7..24467a141f 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -5,7 +5,7 @@
 @rem you may not use this file except in compliance with the License.
 @rem You may obtain a copy of the License at
 @rem
-@rem      http://www.apache.org/licenses/LICENSE-2.0
+@rem      https://www.apache.org/licenses/LICENSE-2.0
 @rem
 @rem Unless required by applicable law or agreed to in writing, software
 @rem distributed under the License is distributed on an "AS IS" BASIS,
diff --git a/mkdocs.yml b/mkdocs.yml
new file mode 100644
index 0000000000..f54d97518b
--- /dev/null
+++ b/mkdocs.yml
@@ -0,0 +1,68 @@
+site_name: OkHttp
+repo_name: OkHttp
+repo_url: https://github.com/square/okhttp
+site_description: "An HTTP & HTTP/2 client for Android and Java applications"
+site_author: Square, Inc.
+remote_branch: gh-pages
+
+copyright: 'Copyright &copy; 2019 Square, Inc.'
+
+theme:
+  name: 'material'
+  favicon: images/icon-square.png
+  logo: images/icon-square.png
+  palette:
+    primary: 'teal'
+    accent: 'white'
+
+extra_css:
+  - 'css/app.css'
+
+markdown_extensions:
+  - smarty
+  - codehilite:
+      guess_lang: false
+  - footnotes
+  - meta
+  - toc:
+      permalink: true
+  - pymdownx.betterem:
+      smart_enable: all
+  - pymdownx.caret
+  - pymdownx.inlinehilite
+  - pymdownx.magiclink
+  - pymdownx.smartsymbols
+  - pymdownx.superfences
+  - tables
+
+nav:
+  - 'Overview': index.md
+  - 'Calls': calls.md
+  - 'Connections': connections.md
+  - 'Recipes': recipes.md
+  - 'Interceptors': interceptors.md
+  - 'HTTPS': https.md
+  - 'Events': events.md
+  - 'Works with OkHttp': works_with_okhttp.md
+  - 'Stack Overflow ⏏': https://stackoverflow.com/questions/tagged/okhttp?sort=active
+  - '4.x API':
+    - 'okhttp': 4.x/okhttp/okhttp3/index.md
+    - 'dnsoverhttps': 4.x/okhttp-dnsoverhttps/okhttp3.dnsoverhttps/index.md
+    - 'logging-interceptor': 4.x/okhttp-logging-interceptor/okhttp3.logging/index.md
+    - 'sse': 4.x/okhttp-sse/okhttp3.sse/index.md
+    - 'tls': 4.x/okhttp-tls/okhttp3.tls/index.md
+    - 'urlconnection': 4.x/okhttp-urlconnection/okhttp3/index.md
+    - 'mockwebserver': 4.x/mockwebserver/okhttp3.mockwebserver/index.md
+  - '3.x API':
+    - 'okhttp ⏏': https://square.github.io/okhttp/3.x/okhttp/
+    - 'dnsoverhttps ⏏': https://square.github.io/okhttp/3.x/okhttp-dnsoverhttps/
+    - 'logging-interceptor ⏏': https://square.github.io/okhttp/3.x/logging-interceptor/
+    - 'sse ⏏': https://square.github.io/okhttp/3.x/okhttp-sse/
+    - 'tls ⏏': https://square.github.io/okhttp/3.x/okhttp-tls/
+    - 'urlconnection ⏏': https://square.github.io/okhttp/3.x/okhttp-urlconnection/
+    - 'mockwebserver ⏏': https://square.github.io/okhttp/3.x/mockwebserver/
+  - 'Change Log': changelog.md
+  - 'Upgrading to OkHttp 4': upgrading_to_okhttp_4.md
+  - 'Contributing': contributing.md
+  - 'Code of Conduct': code_of_conduct.md
+
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
index 73503bb6d2..5843aa1558 100644
--- a/mockwebserver/README.md
+++ b/mockwebserver/README.md
@@ -122,14 +122,15 @@ You can, for example, filter the request instead of using `server.enqueue()`.
 final Dispatcher dispatcher = new Dispatcher() {
 
     @Override
-    public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
-
-        if (request.getPath().equals("/v1/login/auth/")){
-            return new MockResponse().setResponseCode(200);
-        } else if (request.getPath().equals("v1/check/version/")){
-            return new MockResponse().setResponseCode(200).setBody("version=9");
-        } else if (request.getPath().equals("/v1/profile/info")) {
-            return new MockResponse().setResponseCode(200).setBody("{\\\"info\\\":{\\\"name\":\"Lucas Albuquerque\",\"age\":\"21\",\"gender\":\"male\"}}");
+    public MockResponse dispatch (RecordedRequest request) throws InterruptedException {
+
+        switch (request.getPath()) {
+            case "/v1/login/auth/":
+                return new MockResponse().setResponseCode(200);
+            case "v1/check/version/":
+                return new MockResponse().setResponseCode(200).setBody("version=9");
+            case "/v1/profile/info":
+                return new MockResponse().setResponseCode(200).setBody("{\\\"info\\\":{\\\"name\":\"Lucas Albuquerque\",\"age\":\"21\",\"gender\":\"male\"}}");
         }
         return new MockResponse().setResponseCode(404);
     }
@@ -140,19 +141,8 @@ server.setDispatcher(dispatcher);
 
 ### Download
 
-Get MockWebServer via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>mockwebserver</artifactId>
-  <version>(insert latest version)</version>
-  <scope>test</scope>
-</dependency>
-```
-
-or via Gradle 
-```groovy
-testImplementation 'com.squareup.okhttp3:mockwebserver:(insert latest version)'
+```kotlin
+testImplementation("com.squareup.okhttp3:mockwebserver:4.1.1")
 ```
 
 ### License
diff --git a/mockwebserver/build.gradle b/mockwebserver/build.gradle
index 7381f4573a..d48d2ed554 100644
--- a/mockwebserver/build.gradle
+++ b/mockwebserver/build.gradle
@@ -16,6 +16,13 @@ dependencies {
   testImplementation deps.assertj
 }
 
+afterEvaluate { project ->
+  project.tasks.dokka {
+    outputDirectory = "$rootDir/docs/4.x"
+    outputFormat = 'gfm'
+  }
+}
+
 task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
   oldClasspath = files(baselineJar(project, baselineVersion))
   newClasspath = files(jar.archivePath)
@@ -27,5 +34,86 @@ task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
   packageExcludes = [
       'okhttp3.mockwebserver.internal',
   ]        
+  methodExcludes = [
+      // Became 'final' in 4.0.0:
+      'okhttp3.mockwebserver.RecordedRequest#getChunkSizes()',
+      'okhttp3.mockwebserver.RecordedRequest#getHandshake()',
+      'okhttp3.mockwebserver.RecordedRequest#getHeader(java.lang.String)',
+      'okhttp3.mockwebserver.RecordedRequest#getHeaders()',
+      'okhttp3.mockwebserver.RecordedRequest#getMethod()',
+      'okhttp3.mockwebserver.RecordedRequest#getPath()',
+      'okhttp3.mockwebserver.RecordedRequest#getRequestLine()',
+      'okhttp3.mockwebserver.RecordedRequest#getRequestUrl()',
+      'okhttp3.mockwebserver.RecordedRequest#getSequenceNumber()',
+      'okhttp3.mockwebserver.RecordedRequest#getTlsVersion()',
+      'okhttp3.mockwebserver.RecordedRequest#getUtf8Body()',
+      'okhttp3.mockwebserver.RecordedRequest#getBody()',
+      'okhttp3.mockwebserver.RecordedRequest#getBodySize()',
+      'okhttp3.mockwebserver.PushPromise#headers()',
+      'okhttp3.mockwebserver.PushPromise#method()',
+      'okhttp3.mockwebserver.PushPromise#path()',
+      'okhttp3.mockwebserver.PushPromise#response()',
+      'okhttp3.mockwebserver.MockResponse#addHeader(java.lang.String)',
+      'okhttp3.mockwebserver.MockResponse#addHeader(java.lang.String, java.lang.Object)',
+      'okhttp3.mockwebserver.MockResponse#addHeaderLenient(java.lang.String, java.lang.Object)',
+      'okhttp3.mockwebserver.MockResponse#clearHeaders()',
+      'okhttp3.mockwebserver.MockResponse#getBody()',
+      'okhttp3.mockwebserver.MockResponse#getBodyDelay(java.util.concurrent.TimeUnit)',
+      'okhttp3.mockwebserver.MockResponse#getDuplexResponseBody()',
+      'okhttp3.mockwebserver.MockResponse#getHeadersDelay(java.util.concurrent.TimeUnit)',
+      'okhttp3.mockwebserver.MockResponse#getHttp2ErrorCode()',
+      'okhttp3.mockwebserver.MockResponse#getPushPromises()',
+      'okhttp3.mockwebserver.MockResponse#getSettings()',
+      'okhttp3.mockwebserver.MockResponse#getSocketPolicy()',
+      'okhttp3.mockwebserver.MockResponse#getStatus()',
+      'okhttp3.mockwebserver.MockResponse#getThrottleBytesPerPeriod()',
+      'okhttp3.mockwebserver.MockResponse#getThrottlePeriod(java.util.concurrent.TimeUnit)',
+      'okhttp3.mockwebserver.MockResponse#getTrailers()',
+      'okhttp3.mockwebserver.MockResponse#getWebSocketListener()',
+      'okhttp3.mockwebserver.MockResponse#removeHeader(java.lang.String)',
+      'okhttp3.mockwebserver.MockResponse#setBody(okio.Buffer)',
+      'okhttp3.mockwebserver.MockResponse#setBody(java.lang.String)',
+      'okhttp3.mockwebserver.MockResponse#setBodyDelay(long, java.util.concurrent.TimeUnit)',
+      'okhttp3.mockwebserver.MockResponse#setChunkedBody(okio.Buffer, int)',
+      'okhttp3.mockwebserver.MockResponse#setChunkedBody(java.lang.String, int)',
+      'okhttp3.mockwebserver.MockResponse#setHeader(java.lang.String, java.lang.Object)',
+      'okhttp3.mockwebserver.MockResponse#setHeaders(okhttp3.Headers)',
+      'okhttp3.mockwebserver.MockResponse#setHeadersDelay(long, java.util.concurrent.TimeUnit)',
+      'okhttp3.mockwebserver.MockResponse#setHttp2ErrorCode(int)',
+      'okhttp3.mockwebserver.MockResponse#setResponseCode(int)',
+      'okhttp3.mockwebserver.MockResponse#setSocketPolicy(okhttp3.mockwebserver.SocketPolicy)',
+      'okhttp3.mockwebserver.MockResponse#setTrailers(okhttp3.Headers)',
+      'okhttp3.mockwebserver.MockResponse#throttleBody(long, long, java.util.concurrent.TimeUnit)',
+      'okhttp3.mockwebserver.MockResponse#withPush(okhttp3.mockwebserver.PushPromise)',
+      'okhttp3.mockwebserver.MockResponse#withSettings(okhttp3.internal.http2.Settings)',
+      'okhttp3.mockwebserver.MockResponse#withWebSocketUpgrade(okhttp3.WebSocketListener)',
+      'okhttp3.mockwebserver.MockResponse#getHeaders()',
+      'okhttp3.mockwebserver.MockResponse#setStatus(java.lang.String)',
+      'okhttp3.mockwebserver.MockResponse#isDuplex()',
+      'okhttp3.mockwebserver.MockResponse#setBody(okhttp3.mockwebserver.internal.duplex.DuplexResponseBody)',
+      'okhttp3.mockwebserver.MockWebServer#enqueue(okhttp3.mockwebserver.MockResponse)',
+      'okhttp3.mockwebserver.MockWebServer#getDispatcher()',
+      'okhttp3.mockwebserver.MockWebServer#getHostName()',
+      'okhttp3.mockwebserver.MockWebServer#getPort()',
+      'okhttp3.mockwebserver.MockWebServer#getRequestCount()',
+      'okhttp3.mockwebserver.MockWebServer#noClientAuth()',
+      'okhttp3.mockwebserver.MockWebServer#protocols()',
+      'okhttp3.mockwebserver.MockWebServer#requestClientAuth()',
+      'okhttp3.mockwebserver.MockWebServer#requireClientAuth()',
+      'okhttp3.mockwebserver.MockWebServer#setBodyLimit(long)',
+      'okhttp3.mockwebserver.MockWebServer#setDispatcher(okhttp3.mockwebserver.Dispatcher)',
+      'okhttp3.mockwebserver.MockWebServer#setProtocolNegotiationEnabled(boolean)',
+      'okhttp3.mockwebserver.MockWebServer#setProtocols(java.util.List)',
+      'okhttp3.mockwebserver.MockWebServer#setServerSocketFactory(javax.net.ServerSocketFactory)',
+      'okhttp3.mockwebserver.MockWebServer#shutdown()',
+      'okhttp3.mockwebserver.MockWebServer#start()',
+      'okhttp3.mockwebserver.MockWebServer#start(int)',
+      'okhttp3.mockwebserver.MockWebServer#start(java.net.InetAddress, int)',
+      'okhttp3.mockwebserver.MockWebServer#takeRequest()',
+      'okhttp3.mockwebserver.MockWebServer#takeRequest(long, java.util.concurrent.TimeUnit)',
+      'okhttp3.mockwebserver.MockWebServer#toProxyAddress()',
+      'okhttp3.mockwebserver.MockWebServer#url(java.lang.String)',
+      'okhttp3.mockwebserver.MockWebServer#useHttps(javax.net.ssl.SSLSocketFactory, boolean)',
+  ]
 }
 check.dependsOn(japicmp)
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.kt
index a780e70c76..5208a3b47b 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.kt
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/Dispatcher.kt
@@ -15,7 +15,7 @@
  */
 package okhttp3.mockwebserver
 
-/** Handler for mock server requests.  */
+/** Handler for mock server requests. */
 abstract class Dispatcher {
   /**
    * Returns a response to satisfy `request`. This method may block (for instance, to wait on
@@ -31,7 +31,7 @@ abstract class Dispatcher {
    * request bodies.
    */
   open fun peek(): MockResponse {
-    return MockResponse().setSocketPolicy(SocketPolicy.KEEP_OPEN)
+    return MockResponse().apply { this.socketPolicy = SocketPolicy.KEEP_OPEN }
   }
 
   /**
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
deleted file mode 100644
index 51aba7624c..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
+++ /dev/null
@@ -1,342 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Headers;
-import okhttp3.WebSocketListener;
-import okhttp3.internal.InternalKtKt;
-import okhttp3.internal.http2.Settings;
-import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
-import okio.Buffer;
-
-/** A scripted response to be replayed by the mock web server. */
-public final class MockResponse implements Cloneable {
-  private static final String CHUNKED_BODY_HEADER = "Transfer-encoding: chunked";
-
-  private String status;
-  private Headers.Builder headers = new Headers.Builder();
-  private Headers.Builder trailers = new Headers.Builder();
-
-  private Buffer body;
-
-  private long throttleBytesPerPeriod = Long.MAX_VALUE;
-  private long throttlePeriodAmount = 1;
-  private TimeUnit throttlePeriodUnit = TimeUnit.SECONDS;
-
-  private SocketPolicy socketPolicy = SocketPolicy.KEEP_OPEN;
-  private int http2ErrorCode = -1;
-
-  private long bodyDelayAmount = 0;
-  private TimeUnit bodyDelayUnit = TimeUnit.MILLISECONDS;
-
-  private long headersDelayAmount = 0;
-  private TimeUnit headersDelayUnit = TimeUnit.MILLISECONDS;
-
-  private List<PushPromise> promises = new ArrayList<>();
-  private Settings settings;
-  private WebSocketListener webSocketListener;
-  private DuplexResponseBody duplexResponseBody;
-
-  /** Creates a new mock response with an empty body. */
-  public MockResponse() {
-    setResponseCode(200);
-    setHeader("Content-Length", 0);
-  }
-
-  @Override public MockResponse clone() {
-    try {
-      MockResponse result = (MockResponse) super.clone();
-      result.headers = headers.build().newBuilder();
-      result.promises = new ArrayList<>(promises);
-      return result;
-    } catch (CloneNotSupportedException e) {
-      throw new AssertionError();
-    }
-  }
-
-  /** Returns the HTTP response line, such as "HTTP/1.1 200 OK". */
-  public String getStatus() {
-    return status;
-  }
-
-  public MockResponse setResponseCode(int code) {
-    String reason = "Mock Response";
-    if (code >= 100 && code < 200) {
-      reason = "Informational";
-    } else if (code >= 200 && code < 300) {
-      reason = "OK";
-    } else if (code >= 300 && code < 400) {
-      reason = "Redirection";
-    } else if (code >= 400 && code < 500) {
-      reason = "Client Error";
-    } else if (code >= 500 && code < 600) {
-      reason = "Server Error";
-    }
-    return setStatus("HTTP/1.1 " + code + " " + reason);
-  }
-
-  public MockResponse setStatus(String status) {
-    this.status = status;
-    return this;
-  }
-
-  /** Returns the HTTP headers, such as "Content-Length: 0". */
-  public Headers getHeaders() {
-    return headers.build();
-  }
-
-  public Headers getTrailers() {
-    return trailers.build();
-  }
-
-  /**
-   * Removes all HTTP headers including any "Content-Length" and "Transfer-encoding" headers that
-   * were added by default.
-   */
-  public MockResponse clearHeaders() {
-    headers = new Headers.Builder();
-    return this;
-  }
-
-  /**
-   * Adds {@code header} as an HTTP header. For well-formed HTTP {@code header} should contain a
-   * name followed by a colon and a value.
-   */
-  public MockResponse addHeader(String header) {
-    headers.add(header);
-    return this;
-  }
-
-  /**
-   * Adds a new header with the name and value. This may be used to add multiple headers with the
-   * same name.
-   */
-  public MockResponse addHeader(String name, Object value) {
-    headers.add(name, String.valueOf(value));
-    return this;
-  }
-
-  /**
-   * Adds a new header with the name and value. This may be used to add multiple headers with the
-   * same name. Unlike {@link #addHeader(String, Object)} this does not validate the name and
-   * value.
-   */
-  public MockResponse addHeaderLenient(String name, Object value) {
-    InternalKtKt.addHeaderLenient(headers, name, String.valueOf(value));
-    return this;
-  }
-
-  /**
-   * Removes all headers named {@code name}, then adds a new header with the name and value.
-   */
-  public MockResponse setHeader(String name, Object value) {
-    removeHeader(name);
-    return addHeader(name, value);
-  }
-
-  /** Replaces all headers with those specified. */
-  public MockResponse setHeaders(Headers headers) {
-    this.headers = headers.newBuilder();
-    return this;
-  }
-
-  /** Replaces all trailers with those specified. */
-  public MockResponse setTrailers(Headers trailers) {
-    this.trailers = trailers.newBuilder();
-    return this;
-  }
-
-  /** Removes all headers named {@code name}. */
-  public MockResponse removeHeader(String name) {
-    headers.removeAll(name);
-    return this;
-  }
-
-  boolean isDuplex() {
-    return duplexResponseBody != null;
-  }
-
-  DuplexResponseBody getDuplexResponseBody() {
-    return duplexResponseBody;
-  }
-
-  /** Returns a copy of the raw HTTP payload. */
-  public Buffer getBody() {
-    return body != null ? body.clone() : null;
-  }
-
-  public MockResponse setBody(Buffer body) {
-    setHeader("Content-Length", body.size());
-    this.body = body.clone(); // Defensive copy.
-    return this;
-  }
-
-  /** Sets the response body to the UTF-8 encoded bytes of {@code body}. */
-  public MockResponse setBody(String body) {
-    return setBody(new Buffer().writeUtf8(body));
-  }
-
-  MockResponse setBody(DuplexResponseBody duplexResponseBody) {
-    this.duplexResponseBody = duplexResponseBody;
-    return this;
-  }
-
-  /**
-   * Sets the response body to {@code body}, chunked every {@code maxChunkSize} bytes.
-   */
-  public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
-    removeHeader("Content-Length");
-    headers.add(CHUNKED_BODY_HEADER);
-
-    Buffer bytesOut = new Buffer();
-    while (!body.exhausted()) {
-      long chunkSize = Math.min(body.size(), maxChunkSize);
-      bytesOut.writeHexadecimalUnsignedLong(chunkSize);
-      bytesOut.writeUtf8("\r\n");
-      bytesOut.write(body, chunkSize);
-      bytesOut.writeUtf8("\r\n");
-    }
-    bytesOut.writeUtf8("0\r\n"); // Last chunk. Trailers follow!
-
-    this.body = bytesOut;
-    return this;
-  }
-
-  /**
-   * Sets the response body to the UTF-8 encoded bytes of {@code body}, chunked every {@code
-   * maxChunkSize} bytes.
-   */
-  public MockResponse setChunkedBody(String body, int maxChunkSize) {
-    return setChunkedBody(new Buffer().writeUtf8(body), maxChunkSize);
-  }
-
-  public SocketPolicy getSocketPolicy() {
-    return socketPolicy;
-  }
-
-  public MockResponse setSocketPolicy(SocketPolicy socketPolicy) {
-    this.socketPolicy = socketPolicy;
-    return this;
-  }
-
-  public int getHttp2ErrorCode() {
-    return http2ErrorCode;
-  }
-
-  /**
-   * Sets the <a href="https://tools.ietf.org/html/rfc7540#section-7">HTTP/2 error code</a> to be
-   * returned when resetting the stream. This is only valid with {@link
-   * SocketPolicy#RESET_STREAM_AT_START}.
-   */
-  public MockResponse setHttp2ErrorCode(int http2ErrorCode) {
-    this.http2ErrorCode = http2ErrorCode;
-    return this;
-  }
-
-  /**
-   * Throttles the request reader and response writer to sleep for the given period after each
-   * series of {@code bytesPerPeriod} bytes are transferred. Use this to simulate network behavior.
-   */
-  public MockResponse throttleBody(long bytesPerPeriod, long period, TimeUnit unit) {
-    this.throttleBytesPerPeriod = bytesPerPeriod;
-    this.throttlePeriodAmount = period;
-    this.throttlePeriodUnit = unit;
-    return this;
-  }
-
-  public long getThrottleBytesPerPeriod() {
-    return throttleBytesPerPeriod;
-  }
-
-  public long getThrottlePeriod(TimeUnit unit) {
-    return unit.convert(throttlePeriodAmount, throttlePeriodUnit);
-  }
-
-  /**
-   * Set the delayed time of the response body to {@code delay}. This applies to the response body
-   * only; response headers are not affected.
-   */
-  public MockResponse setBodyDelay(long delay, TimeUnit unit) {
-    bodyDelayAmount = delay;
-    bodyDelayUnit = unit;
-    return this;
-  }
-
-  public long getBodyDelay(TimeUnit unit) {
-    return unit.convert(bodyDelayAmount, bodyDelayUnit);
-  }
-
-  public MockResponse setHeadersDelay(long delay, TimeUnit unit) {
-    headersDelayAmount = delay;
-    headersDelayUnit = unit;
-    return this;
-  }
-
-  public long getHeadersDelay(TimeUnit unit) {
-    return unit.convert(headersDelayAmount, headersDelayUnit);
-  }
-
-  /**
-   * When {@link MockWebServer#setProtocols(java.util.List) protocols} include {@linkplain
-   * okhttp3.Protocol#HTTP_2}, this attaches a pushed stream to this response.
-   */
-  public MockResponse withPush(PushPromise promise) {
-    this.promises.add(promise);
-    return this;
-  }
-
-  /** Returns the streams the server will push with this response. */
-  public List<PushPromise> getPushPromises() {
-    return promises;
-  }
-
-  /**
-   * When {@linkplain MockWebServer#setProtocols(java.util.List) protocols} include {@linkplain
-   * okhttp3.Protocol#HTTP_2 HTTP/2}, this pushes {@code settings} before writing the response.
-   */
-  public MockResponse withSettings(Settings settings) {
-    this.settings = settings;
-    return this;
-  }
-
-  public Settings getSettings() {
-    return settings;
-  }
-
-  /**
-   * Attempts to perform a web socket upgrade on the connection. This will overwrite any previously
-   * set status or body.
-   */
-  public MockResponse withWebSocketUpgrade(WebSocketListener listener) {
-    setStatus("HTTP/1.1 101 Switching Protocols");
-    setHeader("Connection", "Upgrade");
-    setHeader("Upgrade", "websocket");
-    body = null;
-    webSocketListener = listener;
-    return this;
-  }
-
-  public WebSocketListener getWebSocketListener() {
-    return webSocketListener;
-  }
-
-  @Override public String toString() {
-    return status;
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.kt
new file mode 100644
index 0000000000..0e8c5f247a
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.kt
@@ -0,0 +1,337 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.mockwebserver
+
+import okhttp3.Headers
+import okhttp3.WebSocketListener
+import okhttp3.internal.addHeaderLenient
+import okhttp3.internal.http2.Settings
+import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody
+import okio.Buffer
+import java.util.concurrent.TimeUnit
+
+/** A scripted response to be replayed by the mock web server. */
+class MockResponse : Cloneable {
+  /** Returns the HTTP response line, such as "HTTP/1.1 200 OK". */
+  @set:JvmName("status")
+  var status: String = ""
+
+  private var headersBuilder = Headers.Builder()
+  private var trailersBuilder = Headers.Builder()
+
+  /** The HTTP headers, such as "Content-Length: 0". */
+  @set:JvmName("headers")
+  var headers: Headers
+    get() = headersBuilder.build()
+    set(value) {
+      this.headersBuilder = value.newBuilder()
+    }
+
+  @set:JvmName("trailers")
+  var trailers: Headers
+    get() = trailersBuilder.build()
+    set(value) {
+      this.trailersBuilder = value.newBuilder()
+    }
+
+  private var body: Buffer? = null
+
+  var throttleBytesPerPeriod = Long.MAX_VALUE
+    private set
+  private var throttlePeriodAmount = 1L
+  private var throttlePeriodUnit = TimeUnit.SECONDS
+
+  @set:JvmName("socketPolicy")
+  var socketPolicy = SocketPolicy.KEEP_OPEN
+
+  /**
+   * Sets the [HTTP/2 error code](https://tools.ietf.org/html/rfc7540#section-7) to be
+   * returned when resetting the stream.
+   * This is only valid with [SocketPolicy.RESET_STREAM_AT_START].
+   */
+  @set:JvmName("http2ErrorCode")
+  var http2ErrorCode = -1
+
+  private var bodyDelayAmount = 0L
+  private var bodyDelayUnit = TimeUnit.MILLISECONDS
+
+  private var headersDelayAmount = 0L
+  private var headersDelayUnit = TimeUnit.MILLISECONDS
+
+  private var promises = mutableListOf<PushPromise>()
+  var settings: Settings = Settings()
+    private set
+  var webSocketListener: WebSocketListener? = null
+    private set
+  var duplexResponseBody: DuplexResponseBody? = null
+    private set
+  val isDuplex: Boolean
+    get() = duplexResponseBody != null
+
+  /** Returns the streams the server will push with this response. */
+  val pushPromises: List<PushPromise>
+    get() = promises
+
+  /** Creates a new mock response with an empty body. */
+  init {
+    setResponseCode(200)
+    setHeader("Content-Length", 0L)
+  }
+
+  public override fun clone(): MockResponse {
+    val result = super.clone() as MockResponse
+    result.headersBuilder = headersBuilder.build().newBuilder()
+    result.promises = promises.toMutableList()
+    return result
+  }
+
+  @JvmName("-deprecated_getStatus")
+  @Deprecated(
+      message = "moved to var",
+      replaceWith = ReplaceWith(expression = "status"),
+      level = DeprecationLevel.ERROR)
+  fun getStatus(): String = status
+
+  @Deprecated(
+      message = "moved to var.  Replace setStatus(...) with status(...) to fix Java",
+      replaceWith = ReplaceWith(expression = "apply { this.status = status }"),
+      level = DeprecationLevel.WARNING)
+  fun setStatus(status: String) = apply {
+    this.status = status
+  }
+
+  fun setResponseCode(code: Int): MockResponse {
+    val reason = when (code) {
+      in 100..199 -> "Informational"
+      in 200..299 -> "OK"
+      in 300..399 -> "Redirection"
+      in 400..499 -> "Client Error"
+      in 500..599 -> "Server Error"
+      else -> "Mock Response"
+    }
+    return apply { status = "HTTP/1.1 $code $reason" }
+  }
+
+  /**
+   * Removes all HTTP headers including any "Content-Length" and "Transfer-encoding" headers that
+   * were added by default.
+   */
+  fun clearHeaders() = apply {
+    headersBuilder = Headers.Builder()
+  }
+
+  /**
+   * Adds [header] as an HTTP header. For well-formed HTTP [header] should contain a
+   * name followed by a colon and a value.
+   */
+  fun addHeader(header: String) = apply {
+    headersBuilder.add(header)
+  }
+
+  /**
+   * Adds a new header with the name and value. This may be used to add multiple headers with the
+   * same name.
+   */
+  fun addHeader(name: String, value: Any) = apply {
+    headersBuilder.add(name, value.toString())
+  }
+
+  /**
+   * Adds a new header with the name and value. This may be used to add multiple headers with the
+   * same name. Unlike [addHeader] this does not validate the name and
+   * value.
+   */
+  fun addHeaderLenient(name: String, value: Any) = apply {
+    addHeaderLenient(headersBuilder, name, value.toString())
+  }
+
+  /**
+   * Removes all headers named [name], then adds a new header with the name and value.
+   */
+  fun setHeader(name: String, value: Any) = apply {
+    removeHeader(name)
+    addHeader(name, value)
+  }
+
+  /** Removes all headers named [name]. */
+  fun removeHeader(name: String) = apply {
+    headersBuilder.removeAll(name)
+  }
+
+  /** Returns a copy of the raw HTTP payload. */
+  fun getBody(): Buffer? = body?.clone()
+
+  fun setBody(body: Buffer) = apply {
+    setHeader("Content-Length", body.size)
+    this.body = body.clone() // Defensive copy.
+  }
+
+  /** Sets the response body to the UTF-8 encoded bytes of [body]. */
+  fun setBody(body: String): MockResponse = setBody(Buffer().writeUtf8(body))
+
+  fun setBody(duplexResponseBody: DuplexResponseBody) = apply {
+    this.duplexResponseBody = duplexResponseBody
+  }
+
+  /**
+   * Sets the response body to [body], chunked every [maxChunkSize] bytes.
+   */
+  fun setChunkedBody(body: Buffer, maxChunkSize: Int) = apply {
+    removeHeader("Content-Length")
+    headersBuilder.add(CHUNKED_BODY_HEADER)
+
+    val bytesOut = Buffer()
+    while (!body.exhausted()) {
+      val chunkSize = minOf(body.size, maxChunkSize.toLong())
+      bytesOut.writeHexadecimalUnsignedLong(chunkSize)
+      bytesOut.writeUtf8("\r\n")
+      bytesOut.write(body, chunkSize)
+      bytesOut.writeUtf8("\r\n")
+    }
+    bytesOut.writeUtf8("0\r\n") // Last chunk. Trailers follow!
+    this.body = bytesOut
+  }
+
+  /**
+   * Sets the response body to the UTF-8 encoded bytes of [body],
+   * chunked every [maxChunkSize] bytes.
+   */
+  fun setChunkedBody(body: String, maxChunkSize: Int): MockResponse =
+    setChunkedBody(Buffer().writeUtf8(body), maxChunkSize)
+
+  @JvmName("-deprecated_getHeaders")
+  @Deprecated(
+      message = "moved to var",
+      replaceWith = ReplaceWith(expression = "headers"),
+      level = DeprecationLevel.ERROR)
+  fun getHeaders(): Headers = headers
+
+  @Deprecated(
+      message = "moved to var. Replace setHeaders(...) with headers(...) to fix Java",
+      replaceWith = ReplaceWith(expression = "apply { this.headers = headers }"),
+      level = DeprecationLevel.WARNING)
+  fun setHeaders(headers: Headers) = apply { this.headers = headers }
+
+  @JvmName("-deprecated_getTrailers")
+  @Deprecated(
+      message = "moved to var",
+      replaceWith = ReplaceWith(expression = "trailers"),
+      level = DeprecationLevel.ERROR)
+  fun getTrailers(): Headers = trailers
+
+  @Deprecated(
+      message = "moved to var. Replace setTrailers(...) with trailers(...) to fix Java",
+      replaceWith = ReplaceWith(expression = "apply { this.trailers = trailers }"),
+      level = DeprecationLevel.WARNING)
+  fun setTrailers(trailers: Headers) = apply { this.trailers = trailers }
+
+  @JvmName("-deprecated_getSocketPolicy")
+  @Deprecated(
+      message = "moved to var",
+      replaceWith = ReplaceWith(expression = "socketPolicy"),
+      level = DeprecationLevel.ERROR)
+  fun getSocketPolicy() = socketPolicy
+
+  @Deprecated(
+      message = "moved to var. Replace setSocketPolicy(...) with socketPolicy(...) to fix Java",
+      replaceWith = ReplaceWith(expression = "apply { this.socketPolicy = socketPolicy }"),
+      level = DeprecationLevel.WARNING)
+  fun setSocketPolicy(socketPolicy: SocketPolicy) = apply {
+    this.socketPolicy = socketPolicy
+  }
+
+  @JvmName("-deprecated_getHttp2ErrorCode")
+  @Deprecated(
+      message = "moved to var",
+      replaceWith = ReplaceWith(expression = "http2ErrorCode"),
+      level = DeprecationLevel.ERROR)
+  fun getHttp2ErrorCode() = http2ErrorCode
+
+  @Deprecated(
+      message = "moved to var. Replace setHttp2ErrorCode(...) with http2ErrorCode(...) to fix Java",
+      replaceWith = ReplaceWith(expression = "apply { this.http2ErrorCode = http2ErrorCode }"),
+      level = DeprecationLevel.WARNING)
+  fun setHttp2ErrorCode(http2ErrorCode: Int) = apply {
+    this.http2ErrorCode = http2ErrorCode
+  }
+
+  /**
+   * Throttles the request reader and response writer to sleep for the given period after each
+   * series of [bytesPerPeriod] bytes are transferred. Use this to simulate network behavior.
+   */
+  fun throttleBody(bytesPerPeriod: Long, period: Long, unit: TimeUnit) = apply {
+    throttleBytesPerPeriod = bytesPerPeriod
+    throttlePeriodAmount = period
+    throttlePeriodUnit = unit
+  }
+
+  fun getThrottlePeriod(unit: TimeUnit): Long =
+    unit.convert(throttlePeriodAmount, throttlePeriodUnit)
+
+  /**
+   * Set the delayed time of the response body to [delay]. This applies to the response body
+   * only; response headers are not affected.
+   */
+  fun setBodyDelay(delay: Long, unit: TimeUnit) = apply {
+    bodyDelayAmount = delay
+    bodyDelayUnit = unit
+  }
+
+  fun getBodyDelay(unit: TimeUnit): Long =
+    unit.convert(bodyDelayAmount, bodyDelayUnit)
+
+  fun setHeadersDelay(delay: Long, unit: TimeUnit) = apply {
+    headersDelayAmount = delay
+    headersDelayUnit = unit
+  }
+
+  fun getHeadersDelay(unit: TimeUnit): Long =
+    unit.convert(headersDelayAmount, headersDelayUnit)
+
+  /**
+   * When [protocols][MockWebServer.protocols] include [HTTP_2][okhttp3.Protocol], this attaches a
+   * pushed stream to this response.
+   */
+  fun withPush(promise: PushPromise) = apply {
+    promises.add(promise)
+  }
+
+  /**
+   * When [protocols][MockWebServer.protocols] include [HTTP_2][okhttp3.Protocol], this pushes
+   * [settings] before writing the response.
+   */
+  fun withSettings(settings: Settings) = apply {
+    this.settings = settings
+  }
+
+  /**
+   * Attempts to perform a web socket upgrade on the connection.
+   * This will overwrite any previously set status or body.
+   */
+  fun withWebSocketUpgrade(listener: WebSocketListener) = apply {
+    status = "HTTP/1.1 101 Switching Protocols"
+    setHeader("Connection", "Upgrade")
+    setHeader("Upgrade", "websocket")
+    body = null
+    webSocketListener = listener
+  }
+
+  override fun toString() = status
+
+  companion object {
+    private const val CHUNKED_BODY_HEADER = "Transfer-encoding: chunked"
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
deleted file mode 100644
index 025e6bf195..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ /dev/null
@@ -1,1095 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.mockwebserver;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketException;
-import java.security.SecureRandom;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Set;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import javax.net.ServerSocketFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Internal;
-import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.Util;
-import okhttp3.internal.duplex.MwsDuplexAccess;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http2.ErrorCode;
-import okhttp3.internal.http2.Header;
-import okhttp3.internal.http2.Http2Connection;
-import okhttp3.internal.http2.Http2Stream;
-import okhttp3.internal.http2.Settings;
-import okhttp3.internal.platform.Platform;
-import okhttp3.internal.ws.RealWebSocket;
-import okhttp3.internal.ws.WebSocketProtocol;
-import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-import okio.Sink;
-import okio.Timeout;
-import org.junit.rules.ExternalResource;
-
-import static okhttp3.internal.InternalKtKt.addHeaderLenient;
-import static okhttp3.internal.Util.closeQuietly;
-import static okhttp3.mockwebserver.SocketPolicy.CONTINUE_ALWAYS;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_REQUEST_BODY;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY;
-import static okhttp3.mockwebserver.SocketPolicy.EXPECT_CONTINUE;
-import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
-import static okhttp3.mockwebserver.SocketPolicy.NO_RESPONSE;
-import static okhttp3.mockwebserver.SocketPolicy.RESET_STREAM_AT_START;
-import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE;
-import static okhttp3.mockwebserver.SocketPolicy.STALL_SOCKET_AT_START;
-import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
-
-/**
- * A scriptable web server. Callers supply canned responses and the server replays them upon request
- * in sequence.
- */
-public final class MockWebServer extends ExternalResource implements Closeable {
-  static {
-    Internal.initializeInstanceForTests();
-    MwsDuplexAccess.instance = new MwsDuplexAccess() {
-      @Override public void setBody(
-          MockResponse mockResponse, DuplexResponseBody duplexResponseBody) {
-        mockResponse.setBody(duplexResponseBody);
-      }
-    };
-  }
-
-  private static final int CLIENT_AUTH_NONE = 0;
-  private static final int CLIENT_AUTH_REQUESTED = 1;
-  private static final int CLIENT_AUTH_REQUIRED = 2;
-
-  private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
-    @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
-      throw new CertificateException();
-    }
-
-    @Override public void checkServerTrusted(X509Certificate[] chain, String authType) {
-      throw new AssertionError();
-    }
-
-    @Override public X509Certificate[] getAcceptedIssuers() {
-      throw new AssertionError();
-    }
-  };
-
-  private static final Logger logger = Logger.getLogger(MockWebServer.class.getName());
-
-  private final BlockingQueue<RecordedRequest> requestQueue = new LinkedBlockingQueue<>();
-
-  private final Set<Socket> openClientSockets =
-      Collections.newSetFromMap(new ConcurrentHashMap<>());
-  private final Set<Http2Connection> openConnections =
-      Collections.newSetFromMap(new ConcurrentHashMap<>());
-  private final AtomicInteger requestCount = new AtomicInteger();
-  private long bodyLimit = Long.MAX_VALUE;
-  private ServerSocketFactory serverSocketFactory;
-  private ServerSocket serverSocket;
-  private SSLSocketFactory sslSocketFactory;
-  private ExecutorService executor;
-  private boolean tunnelProxy;
-  private int clientAuth = CLIENT_AUTH_NONE;
-  private Dispatcher dispatcher = new QueueDispatcher();
-
-  private int port = -1;
-  private InetSocketAddress inetSocketAddress;
-  private boolean protocolNegotiationEnabled = true;
-  private List<Protocol> protocols = Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1);
-
-  private boolean started;
-
-  @Override protected synchronized void before() {
-    if (started) return;
-    try {
-      start();
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  public int getPort() {
-    before();
-    return port;
-  }
-
-  public String getHostName() {
-    before();
-    return inetSocketAddress.getAddress().getCanonicalHostName();
-  }
-
-  public Proxy toProxyAddress() {
-    before();
-    InetSocketAddress address = new InetSocketAddress(inetSocketAddress.getAddress()
-            .getCanonicalHostName(), getPort());
-    return new Proxy(Proxy.Type.HTTP, address);
-  }
-
-  public void setServerSocketFactory(ServerSocketFactory serverSocketFactory) {
-    if (executor != null) {
-      throw new IllegalStateException(
-          "setServerSocketFactory() must be called before start()");
-    }
-    this.serverSocketFactory = serverSocketFactory;
-  }
-
-  /**
-   * Returns a URL for connecting to this server.
-   *
-   * @param path the request path, such as "/".
-   */
-  public HttpUrl url(String path) {
-    return new HttpUrl.Builder()
-        .scheme(sslSocketFactory != null ? "https" : "http")
-        .host(getHostName())
-        .port(getPort())
-        .build()
-        .resolve(path);
-  }
-
-  /**
-   * Sets the number of bytes of the POST body to keep in memory to the given limit.
-   */
-  public void setBodyLimit(long maxBodyLength) {
-    this.bodyLimit = maxBodyLength;
-  }
-
-  /**
-   * Sets whether ALPN is used on incoming HTTPS connections to negotiate a protocol like HTTP/1.1
-   * or HTTP/2. Call this method to disable negotiation and restrict connections to HTTP/1.1.
-   */
-  public void setProtocolNegotiationEnabled(boolean protocolNegotiationEnabled) {
-    this.protocolNegotiationEnabled = protocolNegotiationEnabled;
-  }
-
-  /**
-   * Indicates the protocols supported by ALPN on incoming HTTPS connections. This list is ignored
-   * when {@link #setProtocolNegotiationEnabled negotiation is disabled}.
-   *
-   * @param protocols the protocols to use, in order of preference. The list must contain
-   * {@linkplain Protocol#HTTP_1_1}. It must not contain null.
-   */
-  public void setProtocols(List<Protocol> protocols) {
-    protocols = Util.immutableList(protocols);
-    if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
-      // when using h2_prior_knowledge, no other protocol should be supported.
-      throw new IllegalArgumentException(
-          "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
-    } else if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
-        && !protocols.contains(Protocol.HTTP_1_1)) {
-      throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
-    }
-    if (protocols.contains(null)) {
-      throw new IllegalArgumentException("protocols must not contain null");
-    }
-    this.protocols = protocols;
-  }
-
-  public List<Protocol> protocols() {
-    return protocols;
-  }
-
-  /**
-   * Serve requests with HTTPS rather than otherwise.
-   *
-   * @param tunnelProxy true to expect the HTTP CONNECT method before negotiating TLS.
-   */
-  public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
-    this.sslSocketFactory = sslSocketFactory;
-    this.tunnelProxy = tunnelProxy;
-  }
-
-  /**
-   * Configure the server to not perform SSL authentication of the client. This leaves
-   * authentication to another layer such as in an HTTP cookie or header. This is the default and
-   * most common configuration.
-   */
-  public void noClientAuth() {
-    this.clientAuth = CLIENT_AUTH_NONE;
-  }
-
-  /**
-   * Configure the server to {@linkplain SSLSocket#setWantClientAuth want client auth}. If the
-   * client presents a certificate that is {@linkplain TrustManager trusted} the handshake will
-   * proceed normally. The connection will also proceed normally if the client presents no
-   * certificate at all! But if the client presents an untrusted certificate the handshake will fail
-   * and no connection will be established.
-   */
-  public void requestClientAuth() {
-    this.clientAuth = CLIENT_AUTH_REQUESTED;
-  }
-
-  /**
-   * Configure the server to {@linkplain SSLSocket#setNeedClientAuth need client auth}. If the
-   * client presents a certificate that is {@linkplain TrustManager trusted} the handshake will
-   * proceed normally. If the client presents an untrusted certificate or no certificate at all the
-   * handshake will fail and no connection will be established.
-   */
-  public void requireClientAuth() {
-    this.clientAuth = CLIENT_AUTH_REQUIRED;
-  }
-
-  /**
-   * Awaits the next HTTP request, removes it, and returns it. Callers should use this to verify the
-   * request was sent as intended. This method will block until the request is available, possibly
-   * forever.
-   *
-   * @return the head of the request queue
-   */
-  public RecordedRequest takeRequest() throws InterruptedException {
-    return requestQueue.take();
-  }
-
-  /**
-   * Awaits the next HTTP request (waiting up to the specified wait time if necessary), removes it,
-   * and returns it. Callers should use this to verify the request was sent as intended within the
-   * given time.
-   *
-   * @param timeout how long to wait before giving up, in units of {@code unit}
-   * @param unit a {@code TimeUnit} determining how to interpret the {@code timeout} parameter
-   * @return the head of the request queue
-   */
-  public RecordedRequest takeRequest(long timeout, TimeUnit unit) throws InterruptedException {
-    return requestQueue.poll(timeout, unit);
-  }
-
-  /**
-   * Returns the number of HTTP requests received thus far by this server. This may exceed the
-   * number of HTTP connections when connection reuse is in practice.
-   */
-  public int getRequestCount() {
-    return requestCount.get();
-  }
-
-  /**
-   * Scripts {@code response} to be returned to a request made in sequence. The first request is
-   * served by the first enqueued response; the second request by the second enqueued response; and
-   * so on.
-   *
-   * @throws ClassCastException if the default dispatcher has been replaced with {@link
-   * #setDispatcher(Dispatcher)}.
-   */
-  public void enqueue(MockResponse response) {
-    ((QueueDispatcher) dispatcher).enqueueResponse(response.clone());
-  }
-
-  /** Equivalent to {@code start(0)}. */
-  public void start() throws IOException {
-    start(0);
-  }
-
-  /**
-   * Starts the server on the loopback interface for the given port.
-   *
-   * @param port the port to listen to, or 0 for any available port. Automated tests should always
-   * use port 0 to avoid flakiness when a specific port is unavailable.
-   */
-  public void start(int port) throws IOException {
-    start(InetAddress.getByName("localhost"), port);
-  }
-
-  /**
-   * Starts the server on the given address and port.
-   *
-   * @param inetAddress the address to create the server socket on
-   * @param port the port to listen to, or 0 for any available port. Automated tests should always
-   * use port 0 to avoid flakiness when a specific port is unavailable.
-   */
-  public void start(InetAddress inetAddress, int port) throws IOException {
-    start(new InetSocketAddress(inetAddress, port));
-  }
-
-  /**
-   * Starts the server and binds to the given socket address.
-   *
-   * @param inetSocketAddress the socket address to bind the server on
-   */
-  private synchronized void start(InetSocketAddress inetSocketAddress) throws IOException {
-    if (started) throw new IllegalStateException("start() already called");
-    started = true;
-
-    executor = Executors.newCachedThreadPool(Util.threadFactory("MockWebServer", false));
-    this.inetSocketAddress = inetSocketAddress;
-
-    if (serverSocketFactory == null) {
-      serverSocketFactory = ServerSocketFactory.getDefault();
-    }
-    serverSocket = serverSocketFactory.createServerSocket();
-
-    // Reuse if the user specified a port
-    serverSocket.setReuseAddress(inetSocketAddress.getPort() != 0);
-    serverSocket.bind(inetSocketAddress, 50);
-
-    port = serverSocket.getLocalPort();
-    executor.execute(new NamedRunnable("MockWebServer %s", port) {
-      @Override protected void execute() {
-        try {
-          logger.info(MockWebServer.this + " starting to accept connections");
-          acceptConnections();
-        } catch (Throwable e) {
-          logger.log(Level.WARNING, MockWebServer.this + " failed unexpectedly", e);
-        }
-
-        // Release all sockets and all threads, even if any close fails.
-        closeQuietly(serverSocket);
-        for (Iterator<Socket> s = openClientSockets.iterator(); s.hasNext(); ) {
-          closeQuietly(s.next());
-          s.remove();
-        }
-        for (Iterator<Http2Connection> s = openConnections.iterator(); s.hasNext(); ) {
-          closeQuietly(s.next());
-          s.remove();
-        }
-        dispatcher.shutdown();
-        executor.shutdown();
-      }
-
-      private void acceptConnections() throws Exception {
-        while (true) {
-          Socket socket;
-          try {
-            socket = serverSocket.accept();
-          } catch (SocketException e) {
-            logger.info(MockWebServer.this + " done accepting connections: " + e.getMessage());
-            return;
-          }
-          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
-          if (socketPolicy == DISCONNECT_AT_START) {
-            dispatchBookkeepingRequest(0, socket);
-            socket.close();
-          } else {
-            openClientSockets.add(socket);
-            serveConnection(socket);
-          }
-        }
-      }
-    });
-  }
-
-  public synchronized void shutdown() throws IOException {
-    if (!started) return;
-    if (serverSocket == null) throw new IllegalStateException("shutdown() before start()");
-
-    // Cause acceptConnections() to break out.
-    serverSocket.close();
-
-    // Await shutdown.
-    try {
-      if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
-        throw new IOException("Gave up waiting for executor to shut down");
-      }
-    } catch (InterruptedException e) {
-      throw new AssertionError();
-    }
-  }
-
-  @Override protected synchronized void after() {
-    try {
-      shutdown();
-    } catch (IOException e) {
-      logger.log(Level.WARNING, "MockWebServer shutdown failed", e);
-    }
-  }
-
-  private void serveConnection(final Socket raw) {
-    executor.execute(new NamedRunnable("MockWebServer %s", raw.getRemoteSocketAddress()) {
-      int sequenceNumber = 0;
-
-      @Override protected void execute() {
-        try {
-          processConnection();
-        } catch (IOException e) {
-          logger.info(
-              MockWebServer.this + " connection from " + raw.getInetAddress() + " failed: " + e);
-        } catch (Exception e) {
-          logger.log(Level.SEVERE,
-              MockWebServer.this + " connection from " + raw.getInetAddress() + " crashed", e);
-        }
-      }
-
-      public void processConnection() throws Exception {
-        SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
-        Protocol protocol = Protocol.HTTP_1_1;
-        Socket socket;
-        if (sslSocketFactory != null) {
-          if (tunnelProxy) {
-            createTunnel();
-          }
-          if (socketPolicy == FAIL_HANDSHAKE) {
-            dispatchBookkeepingRequest(sequenceNumber, raw);
-            processHandshakeFailure(raw);
-            return;
-          }
-          socket = sslSocketFactory.createSocket(raw, raw.getInetAddress().getHostAddress(),
-              raw.getPort(), true);
-          SSLSocket sslSocket = (SSLSocket) socket;
-          sslSocket.setUseClientMode(false);
-          if (clientAuth == CLIENT_AUTH_REQUIRED) {
-            sslSocket.setNeedClientAuth(true);
-          } else if (clientAuth == CLIENT_AUTH_REQUESTED) {
-            sslSocket.setWantClientAuth(true);
-          }
-          openClientSockets.add(socket);
-
-          if (protocolNegotiationEnabled) {
-            Platform.get().configureTlsExtensions(sslSocket, null, protocols);
-          }
-
-          sslSocket.startHandshake();
-
-          if (protocolNegotiationEnabled) {
-            String protocolString = Platform.get().getSelectedProtocol(sslSocket);
-            protocol = protocolString != null ? Protocol.get(protocolString) : Protocol.HTTP_1_1;
-            Platform.get().afterHandshake(sslSocket);
-          }
-          openClientSockets.remove(raw);
-        } else if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
-          socket = raw;
-          protocol = Protocol.H2_PRIOR_KNOWLEDGE;
-        } else {
-          socket = raw;
-        }
-
-        if (socketPolicy == STALL_SOCKET_AT_START) {
-          return; // Ignore the socket until the server is shut down!
-        }
-
-        if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
-          Http2SocketHandler http2SocketHandler = new Http2SocketHandler(socket, protocol);
-          Http2Connection connection = new Http2Connection.Builder(false)
-              .socket(socket)
-              .listener(http2SocketHandler)
-              .build();
-          connection.start();
-          openConnections.add(connection);
-          openClientSockets.remove(socket);
-          return;
-        } else if (protocol != Protocol.HTTP_1_1) {
-          throw new AssertionError();
-        }
-
-        BufferedSource source = Okio.buffer(Okio.source(socket));
-        BufferedSink sink = Okio.buffer(Okio.sink(socket));
-
-        while (processOneRequest(socket, source, sink)) {
-        }
-
-        if (sequenceNumber == 0) {
-          logger.warning(MockWebServer.this
-              + " connection from "
-              + raw.getInetAddress()
-              + " didn't make a request");
-        }
-
-        socket.close();
-        openClientSockets.remove(socket);
-      }
-
-      /**
-       * Respond to CONNECT requests until a SWITCH_TO_SSL_AT_END response is
-       * dispatched.
-       */
-      private void createTunnel() throws IOException, InterruptedException {
-        BufferedSource source = Okio.buffer(Okio.source(raw));
-        BufferedSink sink = Okio.buffer(Okio.sink(raw));
-        while (true) {
-          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
-          if (!processOneRequest(raw, source, sink)) {
-            throw new IllegalStateException("Tunnel without any CONNECT!");
-          }
-          if (socketPolicy == UPGRADE_TO_SSL_AT_END) return;
-        }
-      }
-
-      /**
-       * Reads a request and writes its response. Returns true if further calls should be attempted
-       * on the socket.
-       */
-      private boolean processOneRequest(Socket socket, BufferedSource source, BufferedSink sink)
-          throws IOException, InterruptedException {
-        RecordedRequest request = readRequest(socket, source, sink, sequenceNumber);
-        if (request == null) return false;
-
-        requestCount.incrementAndGet();
-        requestQueue.add(request);
-
-        MockResponse response = dispatcher.dispatch(request);
-        if (response.getSocketPolicy() == DISCONNECT_AFTER_REQUEST) {
-          socket.close();
-          return false;
-        }
-        if (response.getSocketPolicy() == NO_RESPONSE) {
-          // This read should block until the socket is closed. (Because nobody is writing.)
-          if (source.exhausted()) return false;
-          throw new ProtocolException("unexpected data");
-        }
-
-        boolean reuseSocket = true;
-        boolean requestWantsWebSockets = "Upgrade".equalsIgnoreCase(request.getHeader("Connection"))
-            && "websocket".equalsIgnoreCase(request.getHeader("Upgrade"));
-        boolean responseWantsWebSockets = response.getWebSocketListener() != null;
-        if (requestWantsWebSockets && responseWantsWebSockets) {
-          handleWebSocketUpgrade(socket, source, sink, request, response);
-          reuseSocket = false;
-        } else {
-          writeHttpResponse(socket, sink, response);
-        }
-
-        if (logger.isLoggable(Level.INFO)) {
-          logger.info(MockWebServer.this + " received request: " + request
-              + " and responded: " + response);
-        }
-
-        // See warnings associated with these socket policies in SocketPolicy.
-        if (response.getSocketPolicy() == DISCONNECT_AT_END) {
-          socket.close();
-          return false;
-        } else if (response.getSocketPolicy() == SHUTDOWN_INPUT_AT_END) {
-          socket.shutdownInput();
-        } else if (response.getSocketPolicy() == SHUTDOWN_OUTPUT_AT_END) {
-          socket.shutdownOutput();
-        } else if (response.getSocketPolicy() == SHUTDOWN_SERVER_AFTER_RESPONSE) {
-          shutdown();
-        }
-
-        sequenceNumber++;
-        return reuseSocket;
-      }
-    });
-  }
-
-  private void processHandshakeFailure(Socket raw) throws Exception {
-    SSLContext context = SSLContext.getInstance("TLS");
-    context.init(null, new TrustManager[] {UNTRUSTED_TRUST_MANAGER}, new SecureRandom());
-    SSLSocketFactory sslSocketFactory = context.getSocketFactory();
-    SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(
-        raw, raw.getInetAddress().getHostAddress(), raw.getPort(), true);
-    try {
-      socket.startHandshake(); // we're testing a handshake failure
-      throw new AssertionError();
-    } catch (IOException expected) {
-    }
-    socket.close();
-  }
-
-  private void dispatchBookkeepingRequest(int sequenceNumber, Socket socket)
-      throws InterruptedException {
-    RecordedRequest request = new RecordedRequest(
-        null, null, null, -1, null, sequenceNumber, socket);
-    requestCount.incrementAndGet();
-    requestQueue.add(request);
-    dispatcher.dispatch(request);
-  }
-
-  /** @param sequenceNumber the index of this request on this connection. */
-  private RecordedRequest readRequest(Socket socket, BufferedSource source, BufferedSink sink,
-      int sequenceNumber) throws IOException {
-    String request;
-    try {
-      request = source.readUtf8LineStrict();
-    } catch (IOException streamIsClosed) {
-      return null; // no request because we closed the stream
-    }
-    if (request.length() == 0) {
-      return null; // no request because the stream is exhausted
-    }
-
-    Headers.Builder headers = new Headers.Builder();
-    long contentLength = -1;
-    boolean chunked = false;
-    boolean expectContinue = false;
-    String header;
-    while ((header = source.readUtf8LineStrict()).length() != 0) {
-      addHeaderLenient(headers, header);
-      String lowercaseHeader = header.toLowerCase(Locale.US);
-      if (contentLength == -1 && lowercaseHeader.startsWith("content-length:")) {
-        contentLength = Long.parseLong(header.substring(15).trim());
-      }
-      if (lowercaseHeader.startsWith("transfer-encoding:")
-          && lowercaseHeader.substring(18).trim().equals("chunked")) {
-        chunked = true;
-      }
-      if (lowercaseHeader.startsWith("expect:")
-          && lowercaseHeader.substring(7).trim().equalsIgnoreCase("100-continue")) {
-        expectContinue = true;
-      }
-    }
-
-    final SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
-    if ((expectContinue && socketPolicy == EXPECT_CONTINUE) || socketPolicy == CONTINUE_ALWAYS) {
-      sink.writeUtf8("HTTP/1.1 100 Continue\r\n");
-      sink.writeUtf8("Content-Length: 0\r\n");
-      sink.writeUtf8("\r\n");
-      sink.flush();
-    }
-
-    boolean hasBody = false;
-    TruncatingBuffer requestBody = new TruncatingBuffer(bodyLimit);
-    List<Integer> chunkSizes = new ArrayList<>();
-    MockResponse policy = dispatcher.peek();
-    if (contentLength != -1) {
-      hasBody = contentLength > 0;
-      throttledTransfer(policy, socket, source, Okio.buffer(requestBody), contentLength, true);
-    } else if (chunked) {
-      hasBody = true;
-      while (true) {
-        int chunkSize = Integer.parseInt(source.readUtf8LineStrict().trim(), 16);
-        if (chunkSize == 0) {
-          readEmptyLine(source);
-          break;
-        }
-        chunkSizes.add(chunkSize);
-        throttledTransfer(policy, socket, source, Okio.buffer(requestBody), chunkSize, true);
-        readEmptyLine(source);
-      }
-    }
-
-    String method = request.substring(0, request.indexOf(' '));
-    if (hasBody && !HttpMethod.permitsRequestBody(method)) {
-      throw new IllegalArgumentException("Request must not have a body: " + request);
-    }
-
-    return new RecordedRequest(request, headers.build(), chunkSizes, requestBody.receivedByteCount,
-        requestBody.buffer, sequenceNumber, socket);
-  }
-
-  private void handleWebSocketUpgrade(Socket socket, BufferedSource source, BufferedSink sink,
-      RecordedRequest request, MockResponse response) throws IOException {
-    String key = request.getHeader("Sec-WebSocket-Key");
-    response.setHeader("Sec-WebSocket-Accept", WebSocketProtocol.acceptHeader(key));
-
-    writeHttpResponse(socket, sink, response);
-
-    // Adapt the request and response into our Request and Response domain model.
-    String scheme = request.getTlsVersion() != null ? "https" : "http";
-    String authority = request.getHeader("Host"); // Has host and port.
-    final Request fancyRequest = new Request.Builder()
-        .url(scheme + "://" + authority + "/")
-        .headers(request.getHeaders())
-        .build();
-    String[] statusParts = response.getStatus().split(" ", 3);
-    final Response fancyResponse = new Response.Builder()
-        .code(Integer.parseInt(statusParts[1]))
-        .message(statusParts[2])
-        .headers(response.getHeaders())
-        .request(fancyRequest)
-        .protocol(Protocol.HTTP_1_1)
-        .build();
-
-    final CountDownLatch connectionClose = new CountDownLatch(1);
-    RealWebSocket.Streams streams = new RealWebSocket.Streams(false, source, sink) {
-      @Override public void close() {
-        connectionClose.countDown();
-      }
-    };
-    RealWebSocket webSocket = new RealWebSocket(fancyRequest,
-        response.getWebSocketListener(), new SecureRandom(), 0);
-    response.getWebSocketListener().onOpen(webSocket, fancyResponse);
-    String name = "MockWebServer WebSocket " + request.getPath();
-    webSocket.initReaderAndWriter(name, streams);
-    try {
-      webSocket.loopReader();
-
-      // Even if messages are no longer being read we need to wait for the connection close signal.
-      try {
-        connectionClose.await();
-      } catch (InterruptedException e) {
-        throw new AssertionError(e);
-      }
-
-    } catch (IOException e) {
-      webSocket.failWebSocket(e, null);
-    } finally {
-      closeQuietly(source);
-    }
-  }
-
-  private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse response)
-      throws IOException {
-    sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS));
-    sink.writeUtf8(response.getStatus());
-    sink.writeUtf8("\r\n");
-
-    writeHeaders(sink, response.getHeaders());
-
-    Buffer body = response.getBody();
-    if (body == null) return;
-    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
-    throttledTransfer(response, socket, body, sink, body.size(), false);
-
-    if ("chunked".equalsIgnoreCase(response.getHeaders().get("Transfer-Encoding"))) {
-      writeHeaders(sink, response.getTrailers());
-    }
-  }
-
-  private void writeHeaders(BufferedSink sink, Headers headers) throws IOException {
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      sink.writeUtf8(headers.name(i));
-      sink.writeUtf8(": ");
-      sink.writeUtf8(headers.value(i));
-      sink.writeUtf8("\r\n");
-    }
-    sink.writeUtf8("\r\n");
-    sink.flush();
-  }
-
-  private void sleepIfDelayed(long delayMs) {
-    if (delayMs != 0) {
-      try {
-        Thread.sleep(delayMs);
-      } catch (InterruptedException e) {
-        throw new AssertionError(e);
-      }
-    }
-  }
-
-  /**
-   * Transfer bytes from {@code source} to {@code sink} until either {@code byteCount} bytes have
-   * been transferred or {@code source} is exhausted. The transfer is throttled according to {@code
-   * policy}.
-   */
-  private void throttledTransfer(MockResponse policy, Socket socket, BufferedSource source,
-      BufferedSink sink, long byteCount, boolean isRequest) throws IOException {
-    if (byteCount == 0) return;
-
-    Buffer buffer = new Buffer();
-    long bytesPerPeriod = policy.getThrottleBytesPerPeriod();
-    long periodDelayMs = policy.getThrottlePeriod(TimeUnit.MILLISECONDS);
-
-    long halfByteCount = byteCount / 2;
-    boolean disconnectHalfway = isRequest
-        ? policy.getSocketPolicy() == DISCONNECT_DURING_REQUEST_BODY
-        : policy.getSocketPolicy() == DISCONNECT_DURING_RESPONSE_BODY;
-
-    while (!socket.isClosed()) {
-      for (long b = 0; b < bytesPerPeriod; ) {
-        // Ensure we do not read past the allotted bytes in this period.
-        long toRead = Math.min(byteCount, bytesPerPeriod - b);
-        // Ensure we do not read past halfway if the policy will kill the connection.
-        if (disconnectHalfway) {
-          toRead = Math.min(toRead, byteCount - halfByteCount);
-        }
-
-        long read = source.read(buffer, toRead);
-        if (read == -1) return;
-
-        sink.write(buffer, read);
-        sink.flush();
-        b += read;
-        byteCount -= read;
-
-        if (disconnectHalfway && byteCount == halfByteCount) {
-          socket.close();
-          return;
-        }
-
-        if (byteCount == 0) return;
-      }
-
-      if (periodDelayMs != 0) {
-        try {
-          Thread.sleep(periodDelayMs);
-        } catch (InterruptedException e) {
-          throw new AssertionError(e);
-        }
-      }
-    }
-  }
-
-  private void readEmptyLine(BufferedSource source) throws IOException {
-    String line = source.readUtf8LineStrict();
-    if (line.length() != 0) throw new IllegalStateException("Expected empty but was: " + line);
-  }
-
-  /**
-   * Returns the dispatcher used to respond to HTTP requests. The default dispatcher is a {@link
-   * QueueDispatcher} but other dispatchers can be configured.
-   */
-  public Dispatcher getDispatcher() {
-    return dispatcher;
-  }
-
-  /**
-   * Sets the dispatcher used to match incoming requests to mock responses. The default dispatcher
-   * simply serves a fixed sequence of responses from a {@link #enqueue(MockResponse) queue}; custom
-   * dispatchers can vary the response based on timing or the content of the request.
-   */
-  public void setDispatcher(Dispatcher dispatcher) {
-    if (dispatcher == null) throw new NullPointerException();
-    this.dispatcher = dispatcher;
-  }
-
-  @Override public String toString() {
-    return "MockWebServer[" + port + "]";
-  }
-
-  @Override public void close() throws IOException {
-    shutdown();
-  }
-
-  /** A buffer wrapper that drops data after {@code bodyLimit} bytes. */
-  private static class TruncatingBuffer implements Sink {
-    private final Buffer buffer = new Buffer();
-    private long remainingByteCount;
-    private long receivedByteCount;
-
-    TruncatingBuffer(long bodyLimit) {
-      remainingByteCount = bodyLimit;
-    }
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      long toRead = Math.min(remainingByteCount, byteCount);
-      if (toRead > 0) {
-        source.read(buffer, toRead);
-      }
-      long toSkip = byteCount - toRead;
-      if (toSkip > 0) {
-        source.skip(toSkip);
-      }
-      remainingByteCount -= toRead;
-      receivedByteCount += byteCount;
-    }
-
-    @Override public void flush() throws IOException {
-    }
-
-    @Override public Timeout timeout() {
-      return Timeout.NONE;
-    }
-
-    @Override public void close() throws IOException {
-    }
-  }
-
-  /** Processes HTTP requests layered over HTTP/2. */
-  private class Http2SocketHandler extends Http2Connection.Listener {
-    private final Socket socket;
-    private final Protocol protocol;
-    private final AtomicInteger sequenceNumber = new AtomicInteger();
-
-    private Http2SocketHandler(Socket socket, Protocol protocol) {
-      this.socket = socket;
-      this.protocol = protocol;
-    }
-
-    @Override public void onStream(Http2Stream stream) throws IOException {
-      MockResponse peekedResponse = dispatcher.peek();
-      if (peekedResponse.getSocketPolicy() == RESET_STREAM_AT_START) {
-        try {
-          dispatchBookkeepingRequest(sequenceNumber.getAndIncrement(), socket);
-          stream.close(ErrorCode.Companion.fromHttp2(peekedResponse.getHttp2ErrorCode()), null);
-          return;
-        } catch (InterruptedException e) {
-          throw new AssertionError(e);
-        }
-      }
-
-      RecordedRequest request = readRequest(stream);
-      requestCount.incrementAndGet();
-      requestQueue.add(request);
-
-      MockResponse response;
-      try {
-        response = dispatcher.dispatch(request);
-      } catch (InterruptedException e) {
-        throw new AssertionError(e);
-      }
-      if (response.getSocketPolicy() == DISCONNECT_AFTER_REQUEST) {
-        socket.close();
-        return;
-      }
-      writeResponse(stream, request, response);
-      if (logger.isLoggable(Level.INFO)) {
-        logger.info(MockWebServer.this + " received request: " + request
-            + " and responded: " + response + " protocol is " + protocol.toString());
-      }
-
-      if (response.getSocketPolicy() == DISCONNECT_AT_END) {
-        Http2Connection connection = stream.getConnection();
-        connection.shutdown(ErrorCode.NO_ERROR);
-      }
-    }
-
-    private RecordedRequest readRequest(Http2Stream stream) throws IOException {
-      Headers streamHeaders = stream.takeHeaders();
-      Headers.Builder httpHeaders = new Headers.Builder();
-      String method = "<:method omitted>";
-      String path = "<:path omitted>";
-      boolean readBody = true;
-      for (int i = 0, size = streamHeaders.size(); i < size; i++) {
-        String name = streamHeaders.name(i);
-        String value = streamHeaders.value(i);
-        if (name.equals(Header.TARGET_METHOD_UTF8)) {
-          method = value;
-        } else if (name.equals(Header.TARGET_PATH_UTF8)) {
-          path = value;
-        } else if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
-          httpHeaders.add(name, value);
-        } else {
-          throw new IllegalStateException();
-        }
-        if (name.equals("expect") && value.equalsIgnoreCase("100-continue")) {
-          // Don't read the body unless we've invited the client to send it.
-          readBody = false;
-        }
-      }
-      Headers headers = httpHeaders.build();
-
-      MockResponse peek = dispatcher.peek();
-      if (!readBody && peek.getSocketPolicy() == EXPECT_CONTINUE) {
-        List<Header> continueHeaders = Collections.singletonList(
-            new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue")));
-        stream.writeHeaders(continueHeaders, false, true);
-        stream.getConnection().flush();
-        readBody = true;
-      }
-
-      Buffer body = new Buffer();
-      if (readBody && !peek.isDuplex()) {
-        String contentLengthString = headers.get("content-length");
-        long byteCount = contentLengthString != null
-            ? Long.parseLong(contentLengthString)
-            : Long.MAX_VALUE;
-        throttledTransfer(peek, socket, Okio.buffer(stream.getSource()), body, byteCount, true);
-      }
-
-      String requestLine = method + ' ' + path + " HTTP/1.1";
-      List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for HTTP/2.
-      return new RecordedRequest(requestLine, headers, chunkSizes, body.size(), body,
-          sequenceNumber.getAndIncrement(), socket);
-    }
-
-    private void writeResponse(final Http2Stream stream,
-        final RecordedRequest request, final MockResponse response) throws IOException {
-      Settings settings = response.getSettings();
-      if (settings != null) {
-        stream.getConnection().setSettings(settings);
-      }
-
-      if (response.getSocketPolicy() == NO_RESPONSE) {
-        return;
-      }
-      List<Header> http2Headers = new ArrayList<>();
-      String[] statusParts = response.getStatus().split(" ", 3);
-      if (statusParts.length < 2) {
-        throw new AssertionError("Unexpected status: " + response.getStatus());
-      }
-      // TODO: constants for well-known header names.
-      http2Headers.add(new Header(Header.RESPONSE_STATUS, statusParts[1]));
-      Headers headers = response.getHeaders();
-      for (int i = 0, size = headers.size(); i < size; i++) {
-        http2Headers.add(new Header(headers.name(i), headers.value(i)));
-      }
-      Headers trailers = response.getTrailers();
-
-      sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS));
-
-      Buffer body = response.getBody();
-      boolean outFinished = body == null
-          && response.getPushPromises().isEmpty()
-          && !response.isDuplex();
-      boolean flushHeaders = body == null;
-      if (outFinished && trailers.size() > 0) {
-        throw new IllegalStateException("unsupported: no body and non-empty trailers " + trailers);
-      }
-      stream.writeHeaders(http2Headers, outFinished, flushHeaders);
-      if (trailers.size() > 0) {
-        stream.enqueueTrailers(trailers);
-      }
-      pushPromises(stream, request, response.getPushPromises());
-      if (body != null) {
-        try (BufferedSink sink = Okio.buffer(stream.getSink())) {
-          sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
-          throttledTransfer(response, socket, body, sink, body.size(), false);
-        }
-      } else if (response.isDuplex()) {
-        try (BufferedSink sink = Okio.buffer(stream.getSink());
-             BufferedSource source = Okio.buffer(stream.getSource())) {
-          DuplexResponseBody duplexResponseBody = response.getDuplexResponseBody();
-          duplexResponseBody.onRequest(request, source, sink);
-        }
-      } else if (!outFinished) {
-        stream.close(ErrorCode.NO_ERROR, null);
-      }
-    }
-
-    private void pushPromises(Http2Stream stream, RecordedRequest request,
-        List<PushPromise> promises) throws IOException {
-      for (PushPromise pushPromise : promises) {
-        List<Header> pushedHeaders = new ArrayList<>();
-        pushedHeaders.add(new Header(Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
-        pushedHeaders.add(new Header(Header.TARGET_METHOD, pushPromise.method()));
-        pushedHeaders.add(new Header(Header.TARGET_PATH, pushPromise.path()));
-        Headers pushPromiseHeaders = pushPromise.headers();
-        for (int i = 0, size = pushPromiseHeaders.size(); i < size; i++) {
-          pushedHeaders.add(new Header(pushPromiseHeaders.name(i), pushPromiseHeaders.value(i)));
-        }
-        String requestLine = pushPromise.method() + ' ' + pushPromise.path() + " HTTP/1.1";
-        List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for HTTP/2.
-        requestQueue.add(new RecordedRequest(requestLine, pushPromise.headers(), chunkSizes, 0,
-            new Buffer(), sequenceNumber.getAndIncrement(), socket));
-        boolean hasBody = pushPromise.response().getBody() != null;
-        Http2Stream pushedStream =
-            stream.getConnection().pushStream(stream.getId(), pushedHeaders, hasBody);
-        writeResponse(pushedStream, request, pushPromise.response());
-      }
-    }
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
new file mode 100644
index 0000000000..14f69c51e0
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.kt
@@ -0,0 +1,1132 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.mockwebserver
+
+import okhttp3.Headers
+import okhttp3.Headers.Companion.headersOf
+import okhttp3.HttpUrl
+import okhttp3.Protocol
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.internal.addHeaderLenient
+import okhttp3.internal.closeQuietly
+import okhttp3.internal.duplex.MwsDuplexAccess
+import okhttp3.internal.execute
+import okhttp3.internal.http.HttpMethod
+import okhttp3.internal.http2.ErrorCode
+import okhttp3.internal.http2.Header
+import okhttp3.internal.http2.Http2Connection
+import okhttp3.internal.http2.Http2Stream
+import okhttp3.internal.immutableListOf
+import okhttp3.internal.platform.Platform
+import okhttp3.internal.threadFactory
+import okhttp3.internal.toImmutableList
+import okhttp3.internal.ws.RealWebSocket
+import okhttp3.internal.ws.WebSocketProtocol
+import okhttp3.mockwebserver.SocketPolicy.CONTINUE_ALWAYS
+import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST
+import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END
+import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START
+import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_REQUEST_BODY
+import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY
+import okhttp3.mockwebserver.SocketPolicy.EXPECT_CONTINUE
+import okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE
+import okhttp3.mockwebserver.SocketPolicy.NO_RESPONSE
+import okhttp3.mockwebserver.SocketPolicy.RESET_STREAM_AT_START
+import okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END
+import okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END
+import okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE
+import okhttp3.mockwebserver.SocketPolicy.STALL_SOCKET_AT_START
+import okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END
+import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody
+import okio.Buffer
+import okio.BufferedSink
+import okio.BufferedSource
+import okio.ByteString.Companion.encodeUtf8
+import okio.Sink
+import okio.Timeout
+import okio.buffer
+import okio.sink
+import okio.source
+import org.junit.rules.ExternalResource
+import java.io.Closeable
+import java.io.IOException
+import java.net.InetAddress
+import java.net.InetSocketAddress
+import java.net.ProtocolException
+import java.net.Proxy
+import java.net.ServerSocket
+import java.net.Socket
+import java.net.SocketException
+import java.security.SecureRandom
+import java.security.cert.CertificateException
+import java.security.cert.X509Certificate
+import java.util.Collections
+import java.util.Locale
+import java.util.concurrent.ConcurrentHashMap
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.ExecutorService
+import java.util.concurrent.Executors
+import java.util.concurrent.LinkedBlockingQueue
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.atomic.AtomicInteger
+import java.util.logging.Level
+import java.util.logging.Logger
+import javax.net.ServerSocketFactory
+import javax.net.ssl.SSLContext
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.TrustManager
+import javax.net.ssl.X509TrustManager
+
+/**
+ * A scriptable web server. Callers supply canned responses and the server replays them upon request
+ * in sequence.
+ */
+class MockWebServer : ExternalResource(), Closeable {
+  private val requestQueue = LinkedBlockingQueue<RecordedRequest>()
+  private val openClientSockets =
+      Collections.newSetFromMap(ConcurrentHashMap<Socket, Boolean>())
+  private val openConnections =
+      Collections.newSetFromMap(ConcurrentHashMap<Http2Connection, Boolean>())
+
+  private val atomicRequestCount = AtomicInteger()
+
+  /**
+   * The number of HTTP requests received thus far by this server. This may exceed the number of
+   * HTTP connections when connection reuse is in practice.
+   */
+  val requestCount: Int
+    get() = atomicRequestCount.get()
+
+  /** The number of bytes of the POST body to keep in memory to the given limit. */
+  var bodyLimit = Long.MAX_VALUE
+
+  var serverSocketFactory: ServerSocketFactory? = null
+    get() {
+      if (field == null && started) {
+        field = ServerSocketFactory.getDefault() // Build the default value lazily.
+      }
+      return field
+    }
+    set(value) {
+      check(!started) { "serverSocketFactory must not be set after start()" }
+      field = value
+    }
+
+  private var serverSocket: ServerSocket? = null
+  private var sslSocketFactory: SSLSocketFactory? = null
+  private var executor: ExecutorService? = null
+  private var tunnelProxy: Boolean = false
+  private var clientAuth = CLIENT_AUTH_NONE
+
+  /**
+   * The dispatcher used to respond to HTTP requests. The default dispatcher is a [QueueDispatcher],
+   * which serves a fixed sequence of responses from a [queue][enqueue].
+   *
+   * Other dispatchers can be configured. They can vary the response based on timing or the content
+   * of the request.
+   */
+  var dispatcher: Dispatcher = QueueDispatcher()
+
+  private var portField: Int = -1
+  val port: Int
+    get() {
+      before()
+      return portField
+    }
+
+  val hostName: String
+    get() {
+      before()
+      return inetSocketAddress!!.address.canonicalHostName
+    }
+
+  private var inetSocketAddress: InetSocketAddress? = null
+
+  /**
+   * True if ALPN is used on incoming HTTPS connections to negotiate a protocol like HTTP/1.1 or
+   * HTTP/2. This is true by default; set to false to disable negotiation and restrict connections
+   * to HTTP/1.1.
+   */
+  var protocolNegotiationEnabled = true
+
+  /**
+   * The protocols supported by ALPN on incoming HTTPS connections in order of preference. The list
+   * must contain [Protocol.HTTP_1_1]. It must not contain null.
+   *
+   * This list is ignored when [negotiation is disabled][protocolNegotiationEnabled].
+   */
+  @get:JvmName("protocols") var protocols: List<Protocol> =
+      immutableListOf(Protocol.HTTP_2, Protocol.HTTP_1_1)
+    set(value) {
+      val protocolList = value.toImmutableList()
+      require(Protocol.H2_PRIOR_KNOWLEDGE !in protocolList || protocolList.size == 1) {
+        "protocols containing h2_prior_knowledge cannot use other protocols: $protocolList"
+      }
+      require(Protocol.HTTP_1_1 in protocolList || Protocol.H2_PRIOR_KNOWLEDGE in protocolList) {
+        "protocols doesn't contain http/1.1: $protocolList"
+      }
+      require(null !in protocolList as List<Protocol?>) { "protocols must not contain null" }
+      field = protocolList
+    }
+
+  private var started: Boolean = false
+
+  @Synchronized override fun before() {
+    if (started) return
+    try {
+      start()
+    } catch (e: IOException) {
+      throw RuntimeException(e)
+    }
+  }
+
+  @JvmName("-deprecated_port")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "port"),
+      level = DeprecationLevel.ERROR)
+  fun getPort(): Int = port
+
+  fun toProxyAddress(): Proxy {
+    before()
+    val address = InetSocketAddress(inetSocketAddress!!.address.canonicalHostName, port)
+    return Proxy(Proxy.Type.HTTP, address)
+  }
+
+  @JvmName("-deprecated_serverSocketFactory")
+  @Deprecated(
+      message = "moved to var",
+      replaceWith = ReplaceWith(
+          expression = "run { this.serverSocketFactory = serverSocketFactory }"
+      ),
+      level = DeprecationLevel.ERROR)
+  fun setServerSocketFactory(serverSocketFactory: ServerSocketFactory) = run {
+    this.serverSocketFactory = serverSocketFactory
+  }
+
+  /**
+   * Returns a URL for connecting to this server.
+   *
+   * @param path the request path, such as "/".
+   */
+  fun url(path: String): HttpUrl {
+    return HttpUrl.Builder()
+        .scheme(if (sslSocketFactory != null) "https" else "http")
+        .host(hostName)
+        .port(port)
+        .build()
+        .resolve(path)!!
+  }
+
+  @JvmName("-deprecated_bodyLimit")
+  @Deprecated(
+      message = "moved to var",
+      replaceWith = ReplaceWith(
+          expression = "run { this.bodyLimit = bodyLimit }"
+      ),
+      level = DeprecationLevel.ERROR)
+  fun setBodyLimit(bodyLimit: Long) = run { this.bodyLimit = bodyLimit }
+
+  @JvmName("-deprecated_protocolNegotiationEnabled")
+  @Deprecated(
+      message = "moved to var",
+      replaceWith = ReplaceWith(
+          expression = "run { this.protocolNegotiationEnabled = protocolNegotiationEnabled }"
+      ),
+      level = DeprecationLevel.ERROR)
+  fun setProtocolNegotiationEnabled(protocolNegotiationEnabled: Boolean) = run {
+    this.protocolNegotiationEnabled = protocolNegotiationEnabled
+  }
+
+  @JvmName("-deprecated_protocols")
+  @Deprecated(
+      message = "moved to var",
+      replaceWith = ReplaceWith(expression = "run { this.protocols = protocols }"),
+      level = DeprecationLevel.ERROR)
+  fun setProtocols(protocols: List<Protocol>) = run { this.protocols = protocols }
+
+  @JvmName("-deprecated_protocols")
+  @Deprecated(
+      message = "moved to var",
+      replaceWith = ReplaceWith(expression = "protocols"),
+      level = DeprecationLevel.ERROR)
+  fun protocols(): List<Protocol> = protocols
+
+  /**
+   * Serve requests with HTTPS rather than otherwise.
+   *
+   * @param tunnelProxy true to expect the HTTP CONNECT method before negotiating TLS.
+   */
+  fun useHttps(sslSocketFactory: SSLSocketFactory, tunnelProxy: Boolean) {
+    this.sslSocketFactory = sslSocketFactory
+    this.tunnelProxy = tunnelProxy
+  }
+
+  /**
+   * Configure the server to not perform SSL authentication of the client. This leaves
+   * authentication to another layer such as in an HTTP cookie or header. This is the default and
+   * most common configuration.
+   */
+  fun noClientAuth() {
+    this.clientAuth = CLIENT_AUTH_NONE
+  }
+
+  /**
+   * Configure the server to [want client auth][SSLSocket.setWantClientAuth]. If the
+   * client presents a certificate that is [trusted][TrustManager] the handshake will
+   * proceed normally. The connection will also proceed normally if the client presents no
+   * certificate at all! But if the client presents an untrusted certificate the handshake
+   * will fail and no connection will be established.
+   */
+  fun requestClientAuth() {
+    this.clientAuth = CLIENT_AUTH_REQUESTED
+  }
+
+  /**
+   * Configure the server to [need client auth][SSLSocket.setNeedClientAuth]. If the
+   * client presents a certificate that is [trusted][TrustManager] the handshake will
+   * proceed normally. If the client presents an untrusted certificate or no certificate at all the
+   * handshake will fail and no connection will be established.
+   */
+  fun requireClientAuth() {
+    this.clientAuth = CLIENT_AUTH_REQUIRED
+  }
+
+  /**
+   * Awaits the next HTTP request, removes it, and returns it. Callers should use this to verify the
+   * request was sent as intended. This method will block until the request is available, possibly
+   * forever.
+   *
+   * @return the head of the request queue
+   */
+  @Throws(InterruptedException::class)
+  fun takeRequest(): RecordedRequest = requestQueue.take()
+
+  /**
+   * Awaits the next HTTP request (waiting up to the specified wait time if necessary), removes it,
+   * and returns it. Callers should use this to verify the request was sent as intended within the
+   * given time.
+   *
+   * @param timeout how long to wait before giving up, in units of [unit]
+   * @param unit a [TimeUnit] determining how to interpret the [timeout] parameter
+   * @return the head of the request queue
+   */
+  @Throws(InterruptedException::class)
+  fun takeRequest(timeout: Long, unit: TimeUnit): RecordedRequest? = requestQueue.poll(timeout, unit)
+
+  @JvmName("-deprecated_requestCount")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "requestCount"),
+      level = DeprecationLevel.ERROR)
+  fun getRequestCount(): Int = requestCount
+
+  /**
+   * Scripts [response] to be returned to a request made in sequence. The first request is
+   * served by the first enqueued response; the second request by the second enqueued response; and
+   * so on.
+   *
+   * @throws ClassCastException if the default dispatcher has been
+   * replaced with [setDispatcher][dispatcher].
+   */
+  fun enqueue(response: MockResponse) =
+      (dispatcher as QueueDispatcher).enqueueResponse(response.clone())
+
+  /**
+   * Starts the server on the loopback interface for the given port.
+   *
+   * @param port the port to listen to, or 0 for any available port. Automated tests should always
+   * use port 0 to avoid flakiness when a specific port is unavailable.
+   */
+  @Throws(IOException::class)
+  @JvmOverloads fun start(port: Int = 0) = start(InetAddress.getByName("localhost"), port)
+
+  /**
+   * Starts the server on the given address and port.
+   *
+   * @param inetAddress the address to create the server socket on
+   * @param port the port to listen to, or 0 for any available port. Automated tests should always
+   * use port 0 to avoid flakiness when a specific port is unavailable.
+   */
+  @Throws(IOException::class)
+  fun start(inetAddress: InetAddress, port: Int) = start(InetSocketAddress(inetAddress, port))
+
+  /**
+   * Starts the server and binds to the given socket address.
+   *
+   * @param inetSocketAddress the socket address to bind the server on
+   */
+  @Synchronized @Throws(IOException::class)
+  private fun start(inetSocketAddress: InetSocketAddress) {
+    require(!started) { "start() already called" }
+    started = true
+
+    executor = Executors.newCachedThreadPool(threadFactory("MockWebServer", false))
+    this.inetSocketAddress = inetSocketAddress
+
+    serverSocket = serverSocketFactory!!.createServerSocket()
+
+    // Reuse if the user specified a port
+    serverSocket!!.reuseAddress = inetSocketAddress.port != 0
+    serverSocket!!.bind(inetSocketAddress, 50)
+
+    portField = serverSocket!!.localPort
+    executor!!.execute("MockWebServer $portField") {
+      try {
+        logger.info("${this@MockWebServer} starting to accept connections")
+        acceptConnections()
+      } catch (e: Throwable) {
+        logger.log(Level.WARNING, "${this@MockWebServer}  failed unexpectedly", e)
+      }
+
+      // Release all sockets and all threads, even if any close fails.
+      serverSocket?.closeQuietly()
+
+      val openClientSocket = openClientSockets.iterator()
+      while (openClientSocket.hasNext()) {
+        openClientSocket.next().closeQuietly()
+        openClientSocket.remove()
+      }
+
+      val httpConnection = openConnections.iterator()
+      while (httpConnection.hasNext()) {
+        httpConnection.next().closeQuietly()
+        httpConnection.remove()
+      }
+      dispatcher.shutdown()
+      executor!!.shutdown()
+    }
+  }
+
+  @Throws(Exception::class)
+  private fun acceptConnections() {
+    while (true) {
+      val socket: Socket
+      try {
+        socket = serverSocket!!.accept()
+      } catch (e: SocketException) {
+        logger.info("${this@MockWebServer} done accepting connections: ${e.message}")
+        return
+      }
+
+      val socketPolicy = dispatcher.peek().socketPolicy
+      if (socketPolicy === DISCONNECT_AT_START) {
+        dispatchBookkeepingRequest(0, socket)
+        socket.close()
+      } else {
+        openClientSockets.add(socket)
+        serveConnection(socket)
+      }
+    }
+  }
+
+  @Synchronized
+  @Throws(IOException::class)
+  fun shutdown() {
+    if (!started) return
+    require(serverSocket != null) { "shutdown() before start()" }
+
+    // Cause acceptConnections() to break out.
+    serverSocket!!.close()
+
+    // Await shutdown.
+    try {
+      if (!executor!!.awaitTermination(5, TimeUnit.SECONDS)) {
+        throw IOException("Gave up waiting for executor to shut down")
+      }
+    } catch (e: InterruptedException) {
+      throw AssertionError()
+    }
+  }
+
+  @Synchronized override fun after() {
+    try {
+      shutdown()
+    } catch (e: IOException) {
+      logger.log(Level.WARNING, "MockWebServer shutdown failed", e)
+    }
+  }
+
+  private fun serveConnection(raw: Socket) {
+    executor!!.execute("MockWebServer ${raw.remoteSocketAddress}") {
+      try {
+        SocketHandler(raw).handle()
+      } catch (e: IOException) {
+        logger.info("${this@MockWebServer} connection from ${raw.inetAddress} failed: $e")
+      } catch (e: Exception) {
+        logger.log(Level.SEVERE,
+            "${this@MockWebServer} connection from ${raw.inetAddress} crashed", e)
+      }
+    }
+  }
+
+  internal inner class SocketHandler(private val raw: Socket) {
+    private var sequenceNumber = 0
+
+    @Throws(Exception::class)
+    fun handle() {
+      val socketPolicy = dispatcher.peek().socketPolicy
+      var protocol = Protocol.HTTP_1_1
+      val socket: Socket
+      when {
+        sslSocketFactory != null -> {
+          if (tunnelProxy) {
+            createTunnel()
+          }
+          if (socketPolicy === FAIL_HANDSHAKE) {
+            dispatchBookkeepingRequest(sequenceNumber, raw)
+            processHandshakeFailure(raw)
+            return
+          }
+          socket = sslSocketFactory!!.createSocket(raw, raw.inetAddress.hostAddress,
+              raw.port, true)
+          val sslSocket = socket as SSLSocket
+          sslSocket.useClientMode = false
+          if (clientAuth == CLIENT_AUTH_REQUIRED) {
+            sslSocket.needClientAuth = true
+          } else if (clientAuth == CLIENT_AUTH_REQUESTED) {
+            sslSocket.wantClientAuth = true
+          }
+          openClientSockets.add(socket)
+
+          if (protocolNegotiationEnabled) {
+            Platform.get().configureTlsExtensions(sslSocket, null, protocols)
+          }
+
+          sslSocket.startHandshake()
+
+          if (protocolNegotiationEnabled) {
+            val protocolString = Platform.get().getSelectedProtocol(sslSocket)
+            protocol =
+                if (protocolString != null) Protocol.get(protocolString) else Protocol.HTTP_1_1
+            Platform.get().afterHandshake(sslSocket)
+          }
+          openClientSockets.remove(raw)
+        }
+        Protocol.H2_PRIOR_KNOWLEDGE in protocols -> {
+          socket = raw
+          protocol = Protocol.H2_PRIOR_KNOWLEDGE
+        }
+        else -> socket = raw
+      }
+
+      if (socketPolicy === STALL_SOCKET_AT_START) {
+        return // Ignore the socket until the server is shut down!
+      }
+
+      if (protocol === Protocol.HTTP_2 || protocol === Protocol.H2_PRIOR_KNOWLEDGE) {
+        val http2SocketHandler = Http2SocketHandler(socket, protocol)
+        val connection = Http2Connection.Builder(false)
+            .socket(socket)
+            .listener(http2SocketHandler)
+            .build()
+        connection.start()
+        openConnections.add(connection)
+        openClientSockets.remove(socket)
+        return
+      } else if (protocol !== Protocol.HTTP_1_1) {
+        throw AssertionError()
+      }
+
+      val source = socket.source().buffer()
+      val sink = socket.sink().buffer()
+
+      while (processOneRequest(socket, source, sink)) {
+      }
+
+      if (sequenceNumber == 0) {
+        logger.warning(
+            "${this@MockWebServer} connection from ${raw.inetAddress} didn't make a request")
+      }
+
+      socket.close()
+      openClientSockets.remove(socket)
+    }
+
+    /**
+     * Respond to CONNECT requests until a SWITCH_TO_SSL_AT_END response is
+     * dispatched.
+     */
+    @Throws(IOException::class, InterruptedException::class)
+    private fun createTunnel() {
+      val source = raw.source().buffer()
+      val sink = raw.sink().buffer()
+      while (true) {
+        val socketPolicy = dispatcher.peek().socketPolicy
+        check(processOneRequest(raw, source, sink)) { "Tunnel without any CONNECT!" }
+        if (socketPolicy === UPGRADE_TO_SSL_AT_END) return
+      }
+    }
+
+    /**
+     * Reads a request and writes its response. Returns true if further calls should be attempted
+     * on the socket.
+     */
+    @Throws(IOException::class, InterruptedException::class)
+    private fun processOneRequest(
+      socket: Socket,
+      source: BufferedSource,
+      sink: BufferedSink
+    ): Boolean {
+      val request = readRequest(socket, source, sink, sequenceNumber) ?: return false
+
+      atomicRequestCount.incrementAndGet()
+      requestQueue.add(request)
+
+      val response = dispatcher.dispatch(request)
+      if (response.socketPolicy === DISCONNECT_AFTER_REQUEST) {
+        socket.close()
+        return false
+      }
+      if (response.socketPolicy === NO_RESPONSE) {
+        // This read should block until the socket is closed. (Because nobody is writing.)
+        if (source.exhausted()) return false
+        throw ProtocolException("unexpected data")
+      }
+
+      var reuseSocket = true
+      val requestWantsWebSockets = "Upgrade".equals(request.getHeader("Connection"),
+          ignoreCase = true) && "websocket".equals(request.getHeader("Upgrade"),
+          ignoreCase = true)
+      val responseWantsWebSockets = response.webSocketListener != null
+      if (requestWantsWebSockets && responseWantsWebSockets) {
+        handleWebSocketUpgrade(socket, source, sink, request, response)
+        reuseSocket = false
+      } else {
+        writeHttpResponse(socket, sink, response)
+      }
+
+      if (logger.isLoggable(Level.INFO)) {
+        logger.info(
+            "${this@MockWebServer} received request: $request and responded: $response")
+      }
+
+      // See warnings associated with these socket policies in SocketPolicy.
+      when (response.socketPolicy) {
+        DISCONNECT_AT_END -> {
+          socket.close()
+          return false
+        }
+        SHUTDOWN_INPUT_AT_END -> socket.shutdownInput()
+        SHUTDOWN_OUTPUT_AT_END -> socket.shutdownOutput()
+        SHUTDOWN_SERVER_AFTER_RESPONSE -> shutdown()
+        else -> {
+        }
+      }
+      sequenceNumber++
+      return reuseSocket
+    }
+  }
+
+  @Throws(Exception::class)
+  private fun processHandshakeFailure(raw: Socket) {
+    val context = SSLContext.getInstance("TLS")
+    context.init(null, arrayOf<TrustManager>(UNTRUSTED_TRUST_MANAGER), SecureRandom())
+    val sslSocketFactory = context.socketFactory
+    val socket = sslSocketFactory.createSocket(
+        raw, raw.inetAddress.hostAddress, raw.port, true) as SSLSocket
+    try {
+      socket.startHandshake() // we're testing a handshake failure
+      throw AssertionError()
+    } catch (expected: IOException) {
+    }
+    socket.close()
+  }
+
+  @Throws(InterruptedException::class)
+  private fun dispatchBookkeepingRequest(sequenceNumber: Int, socket: Socket) {
+    val request = RecordedRequest(
+        "", headersOf(), emptyList(), 0L, Buffer(), sequenceNumber, socket)
+    atomicRequestCount.incrementAndGet()
+    requestQueue.add(request)
+    dispatcher.dispatch(request)
+  }
+
+  /** @param sequenceNumber the index of this request on this connection.*/
+  @Throws(IOException::class)
+  private fun readRequest(
+    socket: Socket,
+    source: BufferedSource,
+    sink: BufferedSink,
+    sequenceNumber: Int
+  ): RecordedRequest? {
+    val request: String
+    try {
+      request = source.readUtf8LineStrict()
+    } catch (streamIsClosed: IOException) {
+      return null // no request because we closed the stream
+    }
+
+    if (request.isEmpty()) {
+      return null // no request because the stream is exhausted
+    }
+    val headers = Headers.Builder()
+    var contentLength = -1L
+    var chunked = false
+    var expectContinue = false
+    while (true) {
+      val header = source.readUtf8LineStrict()
+      if (header.isEmpty()) {
+        break
+      }
+      addHeaderLenient(headers, header)
+      val lowercaseHeader = header.toLowerCase(Locale.US)
+      if (contentLength == -1L && lowercaseHeader.startsWith("content-length:")) {
+        contentLength = header.substring(15).trim().toLong()
+      }
+      if (lowercaseHeader.startsWith("transfer-encoding:") && lowercaseHeader.substring(
+              18).trim() == "chunked") {
+        chunked = true
+      }
+      if (lowercaseHeader.startsWith("expect:") && lowercaseHeader.substring(
+              7).trim().equals("100-continue", ignoreCase = true)) {
+        expectContinue = true
+      }
+    }
+
+    val socketPolicy = dispatcher.peek().socketPolicy
+    if (expectContinue && socketPolicy === EXPECT_CONTINUE || socketPolicy === CONTINUE_ALWAYS) {
+      sink.writeUtf8("HTTP/1.1 100 Continue\r\n")
+      sink.writeUtf8("Content-Length: 0\r\n")
+      sink.writeUtf8("\r\n")
+      sink.flush()
+    }
+
+    var hasBody = false
+    val requestBody = TruncatingBuffer(bodyLimit)
+    val chunkSizes = mutableListOf<Int>()
+    val policy = dispatcher.peek()
+    if (contentLength != -1L) {
+      hasBody = contentLength > 0L
+      throttledTransfer(policy, socket, source, requestBody.buffer(), contentLength, true)
+    } else if (chunked) {
+      hasBody = true
+      while (true) {
+        val chunkSize = Integer.parseInt(source.readUtf8LineStrict().trim(), 16)
+        if (chunkSize == 0) {
+          readEmptyLine(source)
+          break
+        }
+        chunkSizes.add(chunkSize)
+        throttledTransfer(policy, socket, source,
+            requestBody.buffer(), chunkSize.toLong(), true)
+        readEmptyLine(source)
+      }
+    }
+
+    val method = request.substringBefore(' ')
+    require(!hasBody || HttpMethod.permitsRequestBody(method)) {
+      "Request must not have a body: $request"
+    }
+
+    return RecordedRequest(request, headers.build(), chunkSizes, requestBody.receivedByteCount,
+        requestBody.buffer, sequenceNumber, socket)
+  }
+
+  @Throws(IOException::class)
+  private fun handleWebSocketUpgrade(
+    socket: Socket,
+    source: BufferedSource,
+    sink: BufferedSink,
+    request: RecordedRequest,
+    response: MockResponse
+  ) {
+    val key = request.getHeader("Sec-WebSocket-Key")
+    response.setHeader("Sec-WebSocket-Accept", WebSocketProtocol.acceptHeader(key!!))
+
+    writeHttpResponse(socket, sink, response)
+
+    // Adapt the request and response into our Request and Response domain model.
+    val scheme = if (request.tlsVersion != null) "https" else "http"
+    val authority = request.getHeader("Host") // Has host and port.
+    val fancyRequest = Request.Builder()
+        .url("$scheme://$authority/")
+        .headers(request.headers)
+        .build()
+    val statusParts = response.status.split(' ', limit = 3)
+    val fancyResponse = Response.Builder()
+        .code(Integer.parseInt(statusParts[1]))
+        .message(statusParts[2])
+        .headers(response.headers)
+        .request(fancyRequest)
+        .protocol(Protocol.HTTP_1_1)
+        .build()
+
+    val connectionClose = CountDownLatch(1)
+    val streams = object : RealWebSocket.Streams(false, source, sink) {
+      override fun close() = connectionClose.countDown()
+    }
+    val webSocket = RealWebSocket(fancyRequest, response.webSocketListener!!, SecureRandom(), 0)
+    response.webSocketListener!!.onOpen(webSocket, fancyResponse)
+    val name = "MockWebServer WebSocket ${request.path!!}"
+    webSocket.initReaderAndWriter(name, streams)
+    try {
+      webSocket.loopReader()
+
+      // Even if messages are no longer being read we need to wait for the connection close signal.
+      connectionClose.await()
+    } catch (e: IOException) {
+      webSocket.failWebSocket(e, null)
+    } finally {
+      source.closeQuietly()
+    }
+  }
+
+  @Throws(IOException::class)
+  private fun writeHttpResponse(socket: Socket, sink: BufferedSink, response: MockResponse) {
+    sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS))
+    sink.writeUtf8(response.status)
+    sink.writeUtf8("\r\n")
+
+    writeHeaders(sink, response.headers)
+
+    val body = response.getBody() ?: return
+    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS))
+    throttledTransfer(response, socket, body, sink, body.size, false)
+
+    if ("chunked".equals(response.headers["Transfer-Encoding"], ignoreCase = true)) {
+      writeHeaders(sink, response.trailers)
+    }
+  }
+
+  @Throws(IOException::class)
+  private fun writeHeaders(sink: BufferedSink, headers: Headers) {
+    for ((name, value) in headers) {
+      sink.writeUtf8(name)
+      sink.writeUtf8(": ")
+      sink.writeUtf8(value)
+      sink.writeUtf8("\r\n")
+    }
+    sink.writeUtf8("\r\n")
+    sink.flush()
+  }
+
+  private fun sleepIfDelayed(delayMs: Long) {
+    if (delayMs != 0L) {
+      Thread.sleep(delayMs)
+    }
+  }
+
+  /**
+   * Transfer bytes from [source] to [sink] until either [byteCount] bytes have
+   * been transferred or [source] is exhausted. The transfer is throttled according to [policy].
+   */
+  @Throws(IOException::class)
+  private fun throttledTransfer(
+    policy: MockResponse,
+    socket: Socket,
+    source: BufferedSource,
+    sink: BufferedSink,
+    byteCount: Long,
+    isRequest: Boolean
+  ) {
+    var byteCountNum = byteCount
+    if (byteCountNum == 0L) return
+
+    val buffer = Buffer()
+    val bytesPerPeriod = policy.throttleBytesPerPeriod
+    val periodDelayMs = policy.getThrottlePeriod(TimeUnit.MILLISECONDS)
+
+    val halfByteCount = byteCountNum / 2
+    val disconnectHalfway = if (isRequest) {
+      policy.socketPolicy === DISCONNECT_DURING_REQUEST_BODY
+    } else {
+      policy.socketPolicy === DISCONNECT_DURING_RESPONSE_BODY
+    }
+
+    while (!socket.isClosed) {
+      var b = 0L
+      while (b < bytesPerPeriod) {
+        // Ensure we do not read past the allotted bytes in this period.
+        var toRead = minOf(byteCountNum, bytesPerPeriod - b)
+        // Ensure we do not read past halfway if the policy will kill the connection.
+        if (disconnectHalfway) {
+          toRead = minOf(toRead, byteCountNum - halfByteCount)
+        }
+
+        val read = source.read(buffer, toRead)
+        if (read == -1L) return
+
+        sink.write(buffer, read)
+        sink.flush()
+        b += read
+        byteCountNum -= read
+
+        if (disconnectHalfway && byteCountNum == halfByteCount) {
+          socket.close()
+          return
+        }
+
+        if (byteCountNum == 0L) return
+      }
+
+      if (periodDelayMs != 0L) {
+        Thread.sleep(periodDelayMs)
+      }
+    }
+  }
+
+  @Throws(IOException::class)
+  private fun readEmptyLine(source: BufferedSource) {
+    val line = source.readUtf8LineStrict()
+    check(line.isEmpty()) { "Expected empty but was: $line" }
+  }
+
+  override fun toString(): String = "MockWebServer[$portField]"
+
+  @Throws(IOException::class)
+  override fun close() = shutdown()
+
+  /** A buffer wrapper that drops data after [bodyLimit] bytes. */
+  private class TruncatingBuffer internal constructor(
+    private var remainingByteCount: Long
+  ) : Sink {
+    internal val buffer = Buffer()
+    internal var receivedByteCount = 0L
+
+    @Throws(IOException::class)
+    override fun write(source: Buffer, byteCount: Long) {
+      val toRead = minOf(remainingByteCount, byteCount)
+      if (toRead > 0L) {
+        source.read(buffer, toRead)
+      }
+      val toSkip = byteCount - toRead
+      if (toSkip > 0L) {
+        source.skip(toSkip)
+      }
+      remainingByteCount -= toRead
+      receivedByteCount += byteCount
+    }
+
+    @Throws(IOException::class)
+    override fun flush() {
+    }
+
+    override fun timeout(): Timeout = Timeout.NONE
+
+    @Throws(IOException::class)
+    override fun close() {
+    }
+  }
+
+  /** Processes HTTP requests layered over HTTP/2. */
+  private inner class Http2SocketHandler constructor(
+    private val socket: Socket,
+    private val protocol: Protocol
+  ) : Http2Connection.Listener() {
+    private val sequenceNumber = AtomicInteger()
+
+    @Throws(IOException::class)
+    override fun onStream(stream: Http2Stream) {
+      val peekedResponse = dispatcher.peek()
+      if (peekedResponse.socketPolicy === RESET_STREAM_AT_START) {
+        dispatchBookkeepingRequest(sequenceNumber.getAndIncrement(), socket)
+        stream.close(ErrorCode.fromHttp2(peekedResponse.http2ErrorCode)!!, null)
+        return
+      }
+
+      val request = readRequest(stream)
+      atomicRequestCount.incrementAndGet()
+      requestQueue.add(request)
+
+      val response: MockResponse = dispatcher.dispatch(request)
+
+      if (response.socketPolicy === DISCONNECT_AFTER_REQUEST) {
+        socket.close()
+        return
+      }
+      writeResponse(stream, request, response)
+      if (logger.isLoggable(Level.INFO)) {
+        logger.info(
+            "${this@MockWebServer} received request: $request " +
+                "and responded: $response protocol is $protocol")
+      }
+
+      if (response.socketPolicy === DISCONNECT_AT_END) {
+        val connection = stream.connection
+        connection.shutdown(ErrorCode.NO_ERROR)
+      }
+    }
+
+    @Throws(IOException::class)
+    private fun readRequest(stream: Http2Stream): RecordedRequest {
+      val streamHeaders = stream.takeHeaders()
+      val httpHeaders = Headers.Builder()
+      var method = "<:method omitted>"
+      var path = "<:path omitted>"
+      var readBody = true
+      for ((name, value) in streamHeaders) {
+        if (name == Header.TARGET_METHOD_UTF8) {
+          method = value
+        } else if (name == Header.TARGET_PATH_UTF8) {
+          path = value
+        } else if (protocol === Protocol.HTTP_2 || protocol === Protocol.H2_PRIOR_KNOWLEDGE) {
+          httpHeaders.add(name, value)
+        } else {
+          throw IllegalStateException()
+        }
+        if (name == "expect" && value.equals("100-continue", ignoreCase = true)) {
+          // Don't read the body unless we've invited the client to send it.
+          readBody = false
+        }
+      }
+      val headers = httpHeaders.build()
+
+      val peek = dispatcher.peek()
+      if (!readBody && peek.socketPolicy === EXPECT_CONTINUE) {
+        val continueHeaders =
+            listOf(Header(Header.RESPONSE_STATUS, "100 Continue".encodeUtf8()))
+        stream.writeHeaders(continueHeaders, outFinished = false, flushHeaders = true)
+        stream.connection.flush()
+        readBody = true
+      }
+
+      val body = Buffer()
+      if (readBody && !peek.isDuplex) {
+        val contentLengthString = headers["content-length"]
+        val byteCount = contentLengthString?.toLong() ?: Long.MAX_VALUE
+        throttledTransfer(peek, socket, stream.getSource().buffer(),
+            body, byteCount, true)
+      }
+
+      val requestLine = "$method $path HTTP/1.1"
+      val chunkSizes = emptyList<Int>() // No chunked encoding for HTTP/2.
+      return RecordedRequest(requestLine, headers, chunkSizes, body.size, body,
+          sequenceNumber.getAndIncrement(), socket)
+    }
+
+    @Throws(IOException::class)
+    private fun writeResponse(
+      stream: Http2Stream,
+      request: RecordedRequest,
+      response: MockResponse
+    ) {
+      val settings = response.settings
+      stream.connection.setSettings(settings)
+
+      if (response.socketPolicy === NO_RESPONSE) {
+        return
+      }
+      val http2Headers = mutableListOf<Header>()
+      val statusParts = response.status.split(' ', limit = 3)
+
+      if (statusParts.size < 2) {
+        throw AssertionError("Unexpected status: ${response.status}")
+      }
+      // TODO: constants for well-known header names.
+      http2Headers.add(Header(Header.RESPONSE_STATUS, statusParts[1]))
+      val headers = response.headers
+      for ((name, value) in headers) {
+        http2Headers.add(Header(name, value))
+      }
+      val trailers = response.trailers
+
+      sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS))
+
+      val body = response.getBody()
+      val outFinished = (body == null &&
+          response.pushPromises.isEmpty() &&
+          !response.isDuplex)
+      val flushHeaders = body == null
+      require(!outFinished || trailers.size == 0) {
+        "unsupported: no body and non-empty trailers $trailers"
+      }
+      stream.writeHeaders(http2Headers, outFinished, flushHeaders)
+      if (trailers.size > 0) {
+        stream.enqueueTrailers(trailers)
+      }
+      pushPromises(stream, request, response.pushPromises)
+      if (body != null) {
+        stream.getSink().buffer().use { sink ->
+          sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS))
+          throttledTransfer(response, socket, body, sink, body.size, false)
+        }
+      } else if (response.isDuplex) {
+        stream.getSink().buffer().use { sink ->
+          stream.getSource().buffer().use { source ->
+            val duplexResponseBody = response.duplexResponseBody
+            duplexResponseBody!!.onRequest(request, source, sink)
+          }
+        }
+      } else if (!outFinished) {
+        stream.close(ErrorCode.NO_ERROR, null)
+      }
+    }
+
+    @Throws(IOException::class)
+    private fun pushPromises(
+      stream: Http2Stream,
+      request: RecordedRequest,
+      promises: List<PushPromise>
+    ) {
+      for (pushPromise in promises) {
+        val pushedHeaders = mutableListOf<Header>()
+        pushedHeaders.add(Header(Header.TARGET_AUTHORITY, url(pushPromise.path).host))
+        pushedHeaders.add(Header(Header.TARGET_METHOD, pushPromise.method))
+        pushedHeaders.add(Header(Header.TARGET_PATH, pushPromise.path))
+        val pushPromiseHeaders = pushPromise.headers
+        for ((name, value) in pushPromiseHeaders) {
+          pushedHeaders.add(Header(name, value))
+        }
+        val requestLine = "${pushPromise.method} ${pushPromise.path} HTTP/1.1"
+        val chunkSizes = emptyList<Int>() // No chunked encoding for HTTP/2.
+        requestQueue.add(RecordedRequest(requestLine, pushPromise.headers, chunkSizes, 0,
+            Buffer(), sequenceNumber.getAndIncrement(), socket))
+        val hasBody = pushPromise.response.getBody() != null
+        val pushedStream = stream.connection.pushStream(stream.id, pushedHeaders, hasBody)
+        writeResponse(pushedStream, request, pushPromise.response)
+      }
+    }
+  }
+
+  companion object {
+    init {
+      MwsDuplexAccess.instance = object : MwsDuplexAccess() {
+        override fun setBody(
+          mockResponse: MockResponse,
+          duplexResponseBody: DuplexResponseBody
+        ) {
+          mockResponse.setBody(duplexResponseBody)
+        }
+      }
+    }
+
+    private const val CLIENT_AUTH_NONE = 0
+    private const val CLIENT_AUTH_REQUESTED = 1
+    private const val CLIENT_AUTH_REQUIRED = 2
+
+    private val UNTRUSTED_TRUST_MANAGER = object : X509TrustManager {
+      @Throws(CertificateException::class)
+      override fun checkClientTrusted(
+        chain: Array<X509Certificate>,
+        authType: String
+      ) = throw CertificateException()
+
+      override fun checkServerTrusted(
+        chain: Array<X509Certificate>,
+        authType: String
+      ) = throw AssertionError()
+
+      override fun getAcceptedIssuers(): Array<X509Certificate> = throw AssertionError()
+    }
+
+    private val logger = Logger.getLogger(MockWebServer::class.java.name)
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.java
deleted file mode 100644
index 744127cadd..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver;
-
-import okhttp3.Headers;
-
-/** An HTTP request initiated by the server. */
-public final class PushPromise {
-  private final String method;
-  private final String path;
-  private final Headers headers;
-  private final MockResponse response;
-
-  public PushPromise(String method, String path, Headers headers, MockResponse response) {
-    this.method = method;
-    this.path = path;
-    this.headers = headers;
-    this.response = response;
-  }
-
-  public String method() {
-    return method;
-  }
-
-  public String path() {
-    return path;
-  }
-
-  public Headers headers() {
-    return headers;
-  }
-
-  public MockResponse response() {
-    return response;
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.kt
new file mode 100644
index 0000000000..fe078a79c9
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/PushPromise.kt
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.mockwebserver
+
+import okhttp3.Headers
+
+/** An HTTP request initiated by the server. */
+class PushPromise(
+  @get:JvmName("method") val method: String,
+  @get:JvmName("path") val path: String,
+  @get:JvmName("headers") val headers: Headers,
+  @get:JvmName("response") val response: MockResponse
+) {
+
+  @JvmName("-deprecated_method")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "method"),
+      level = DeprecationLevel.ERROR)
+  fun method() = method
+
+  @JvmName("-deprecated_path")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "path"),
+      level = DeprecationLevel.ERROR)
+  fun path() = path
+
+  @JvmName("-deprecated_headers")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "headers"),
+      level = DeprecationLevel.ERROR)
+  fun headers() = headers
+
+  @JvmName("-deprecated_response")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "response"),
+      level = DeprecationLevel.ERROR)
+  fun response() = response
+}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.kt
index 3c71a3d040..557567156e 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.kt
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/QueueDispatcher.kt
@@ -32,7 +32,7 @@ open class QueueDispatcher : Dispatcher() {
   override fun dispatch(request: RecordedRequest): MockResponse {
     // To permit interactive/browser testing, ignore requests for favicons.
     val requestLine = request.requestLine
-    if (requestLine != null && requestLine == "GET /favicon.ico HTTP/1.1") {
+    if (requestLine == "GET /favicon.ico HTTP/1.1") {
       logger.info("served $requestLine")
       return MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_FOUND)
     }
@@ -81,8 +81,9 @@ open class QueueDispatcher : Dispatcher() {
      * Enqueued on shutdown to release threads waiting on [dispatch]. Note that this response
      * isn't transmitted because the connection is closed before this response is returned.
      */
-    private val DEAD_LETTER = MockResponse()
-        .setStatus("HTTP/1.1 $HTTP_UNAVAILABLE shutting down")
+    private val DEAD_LETTER = MockResponse().apply {
+      this.status = "HTTP/1.1 $HTTP_UNAVAILABLE shutting down"
+    }
 
     private val logger = Logger.getLogger(QueueDispatcher::class.java.name)
   }
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
deleted file mode 100644
index 52beb79323..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.mockwebserver;
-
-import java.io.IOException;
-import java.net.Inet6Address;
-import java.net.InetAddress;
-import java.net.Socket;
-import java.util.List;
-import javax.net.ssl.SSLSocket;
-import okhttp3.Handshake;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.TlsVersion;
-import okio.Buffer;
-
-/** An HTTP request that came into the mock web server. */
-public final class RecordedRequest {
-  private final String requestLine;
-  private final String method;
-  private final String path;
-  private final Headers headers;
-  private final Handshake handshake;
-  private final List<Integer> chunkSizes;
-  private final long bodySize;
-  private final Buffer body;
-  private final int sequenceNumber;
-  private final HttpUrl requestUrl;
-
-  public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkSizes,
-      long bodySize, Buffer body, int sequenceNumber, Socket socket) {
-    this.requestLine = requestLine;
-    this.headers = headers;
-    this.chunkSizes = chunkSizes;
-    this.bodySize = bodySize;
-    this.body = body;
-    this.sequenceNumber = sequenceNumber;
-    if (socket instanceof SSLSocket) {
-      try {
-        this.handshake = Handshake.get(((SSLSocket) socket).getSession());
-      } catch (IOException e) {
-        throw new IllegalArgumentException(e);
-      }
-    } else {
-      this.handshake = null;
-    }
-
-    if (requestLine != null) {
-      int methodEnd = requestLine.indexOf(' ');
-      int pathEnd = requestLine.indexOf(' ', methodEnd + 1);
-      this.method = requestLine.substring(0, methodEnd);
-      String path = requestLine.substring(methodEnd + 1, pathEnd);
-      if (!path.startsWith("/")) {
-        path = "/";
-      }
-      this.path = path;
-
-      String scheme = socket instanceof SSLSocket ? "https" : "http";
-      InetAddress inetAddress = socket.getLocalAddress();
-
-      String hostname = inetAddress.getHostName();
-      if (inetAddress instanceof Inet6Address) {
-        hostname = "[" + hostname + "]";
-      }
-
-      int localPort = socket.getLocalPort();
-      // Allow null in failure case to allow for testing bad requests
-      this.requestUrl =
-          HttpUrl.parse(String.format("%s://%s:%s%s", scheme, hostname, localPort, path));
-    } else {
-      this.requestUrl = null;
-      this.method = null;
-      this.path = null;
-    }
-  }
-
-  public HttpUrl getRequestUrl() {
-    return requestUrl;
-  }
-
-  public String getRequestLine() {
-    return requestLine;
-  }
-
-  public String getMethod() {
-    return method;
-  }
-
-  public String getPath() {
-    return path;
-  }
-
-  /** Returns all headers. */
-  public Headers getHeaders() {
-    return headers;
-  }
-
-  /** Returns the first header named {@code name}, or null if no such header exists. */
-  public String getHeader(String name) {
-    List<String> values = headers.values(name);
-    return values.isEmpty() ? null : values.get(0);
-  }
-
-  /**
-   * Returns the sizes of the chunks of this request's body, or an empty list if the request's body
-   * was empty or unchunked.
-   */
-  public List<Integer> getChunkSizes() {
-    return chunkSizes;
-  }
-
-  /**
-   * Returns the total size of the body of this POST request (before truncation).
-   */
-  public long getBodySize() {
-    return bodySize;
-  }
-
-  /** Returns the body of this POST request. This may be truncated. */
-  public Buffer getBody() {
-    return body;
-  }
-
-  /** @deprecated Use {@link #getBody() getBody().readUtf8()}. */
-  public String getUtf8Body() {
-    return getBody().readUtf8();
-  }
-
-  /**
-   * Returns the index of this request on its HTTP connection. Since a single HTTP connection may
-   * serve multiple requests, each request is assigned its own sequence number.
-   */
-  public int getSequenceNumber() {
-    return sequenceNumber;
-  }
-
-  /** Returns the connection's TLS version or null if the connection doesn't use SSL. */
-  public TlsVersion getTlsVersion() {
-    return handshake != null ? handshake.tlsVersion() : null;
-  }
-
-  /**
-   * Returns the TLS handshake of the connection that carried this request, or null if the request
-   * was received without TLS.
-   */
-  public Handshake getHandshake() {
-    return handshake;
-  }
-
-  @Override public String toString() {
-    return requestLine;
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt
new file mode 100644
index 0000000000..9b34b23203
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.kt
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.mockwebserver
+
+import okhttp3.Handshake
+import okhttp3.Handshake.Companion.handshake
+import okhttp3.Headers
+import okhttp3.HttpUrl
+import okhttp3.HttpUrl.Companion.toHttpUrlOrNull
+import okhttp3.TlsVersion
+import okio.Buffer
+import java.io.IOException
+import java.net.Inet6Address
+import java.net.Socket
+import javax.net.ssl.SSLSocket
+
+/** An HTTP request that came into the mock web server. */
+class RecordedRequest(
+  val requestLine: String,
+
+  /** All headers. */
+  val headers: Headers,
+
+  /**
+   * The sizes of the chunks of this request's body, or an empty list if the request's body
+   * was empty or unchunked.
+   */
+  val chunkSizes: List<Int>,
+
+  /** The total size of the body of this POST request (before truncation).*/
+  val bodySize: Long,
+
+  /** The body of this POST request. This may be truncated. */
+  val body: Buffer,
+
+  /**
+   * The index of this request on its HTTP connection. Since a single HTTP connection may serve
+   * multiple requests, each request is assigned its own sequence number.
+   */
+  val sequenceNumber: Int,
+  socket: Socket
+) {
+  val method: String?
+  val path: String?
+
+  /**
+   * The TLS handshake of the connection that carried this request, or null if the request was
+   * received without TLS.
+   */
+  val handshake: Handshake?
+  val requestUrl: HttpUrl?
+
+  @get:JvmName("-deprecated_utf8Body")
+  @Deprecated(
+      message = "Use body.readUtf8()",
+      replaceWith = ReplaceWith("body.readUtf8()"),
+      level = DeprecationLevel.ERROR)
+  val utf8Body: String
+    get() = body.readUtf8()
+
+  /** Returns the connection's TLS version or null if the connection doesn't use SSL. */
+  val tlsVersion: TlsVersion?
+    get() = handshake?.tlsVersion
+
+  init {
+    if (socket is SSLSocket) {
+      try {
+        this.handshake = socket.session.handshake()
+      } catch (e: IOException) {
+        throw IllegalArgumentException(e)
+      }
+    } else {
+      this.handshake = null
+    }
+
+    if (requestLine.isNotEmpty()) {
+      val methodEnd = requestLine.indexOf(' ')
+      val pathEnd = requestLine.indexOf(' ', methodEnd + 1)
+      this.method = requestLine.substring(0, methodEnd)
+      var path = requestLine.substring(methodEnd + 1, pathEnd)
+      if (!path.startsWith("/")) {
+        path = "/"
+      }
+      this.path = path
+
+      val scheme = if (socket is SSLSocket) "https" else "http"
+      val inetAddress = socket.localAddress
+
+      var hostname = inetAddress.hostName
+      if (inetAddress is Inet6Address && hostname.contains(':')) {
+        // hostname is likely some form representing the IPv6 bytes
+        // 2001:0db8:85a3:0000:0000:8a2e:0370:7334
+        // 2001:db8:85a3::8a2e:370:7334
+        // ::1
+        hostname = "[$hostname]"
+      }
+
+      val localPort = socket.localPort
+      // Allow null in failure case to allow for testing bad requests
+      this.requestUrl = "$scheme://$hostname:$localPort$path".toHttpUrlOrNull()
+    } else {
+      this.requestUrl = null
+      this.method = null
+      this.path = null
+    }
+  }
+
+  @Deprecated(
+      message = "Use body.readUtf8()",
+      replaceWith = ReplaceWith("body.readUtf8()"),
+      level = DeprecationLevel.WARNING)
+  fun getUtf8Body(): String = body.readUtf8()
+
+  /** Returns the first header named [name], or null if no such header exists. */
+  fun getHeader(name: String): String? = headers.values(name).firstOrNull()
+
+  override fun toString(): String = requestLine
+}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.kt
similarity index 73%
rename from mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
rename to mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.kt
index beeb2c9a6d..60f26e5fdc 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.kt
@@ -14,13 +14,13 @@
  * limitations under the License.
  */
 
-package okhttp3.mockwebserver;
+package okhttp3.mockwebserver
 
 /**
  * What should be done with the incoming socket.
  *
- * <p>Be careful when using values like {@link #DISCONNECT_AT_END}, {@link #SHUTDOWN_INPUT_AT_END}
- * and {@link #SHUTDOWN_OUTPUT_AT_END} that close a socket after a response, and where there are
+ * Be careful when using values like [DISCONNECT_AT_END], [SHUTDOWN_INPUT_AT_END]
+ * and [SHUTDOWN_OUTPUT_AT_END] that close a socket after a response, and where there are
  * follow-up requests. The client is unblocked and free to continue as soon as it has received the
  * entire response body. If and when the client makes a subsequent request using a pooled socket the
  * server may not have had time to close the socket. The socket will be closed at an indeterminate
@@ -29,10 +29,10 @@
  * client behavior non-deterministic. Add delays in the client to improve the chances that the
  * server has closed the socket before follow up requests are made.
  */
-public enum SocketPolicy {
+enum class SocketPolicy {
 
   /**
-   * Shutdown {@link MockWebServer} after writing response.
+   * Shutdown [MockWebServer] after writing response.
    */
   SHUTDOWN_SERVER_AFTER_RESPONSE,
 
@@ -43,11 +43,11 @@
 
   /**
    * Close the socket after the response. This is the default HTTP/1.0 behavior. For HTTP/2
-   * connections, this sends a <a href="https://tools.ietf.org/html/rfc7540#section-6.8">GOAWAY
-   * frame</a> immediately after the response and will close the connection when the client's socket
+   * connections, this sends a [GOAWAYframe](https://tools.ietf.org/html/rfc7540#section-6.8)
+   * immediately after the response and will close the connection when the client's socket
    * is exhausted.
    *
-   * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
+   * See [SocketPolicy] for reasons why this can cause test flakiness and how to avoid it.
    */
   DISCONNECT_AT_END,
 
@@ -81,14 +81,14 @@
   /**
    * Shutdown the socket input after sending the response. For testing bad behavior.
    *
-   * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
+   * See [SocketPolicy] for reasons why this can cause test flakiness and how to avoid it.
    */
   SHUTDOWN_INPUT_AT_END,
 
   /**
    * Shutdown the socket output after sending the response. For testing bad behavior.
    *
-   * <p>See {@link SocketPolicy} for reasons why this can cause test flakiness and how to avoid it.
+   * See [SocketPolicy] for reasons why this can cause test flakiness and how to avoid it.
    */
   SHUTDOWN_OUTPUT_AT_END,
 
@@ -105,21 +105,19 @@
   NO_RESPONSE,
 
   /**
-   * Fail HTTP/2 requests without processing them by sending an {@linkplain
-   * MockResponse#getHttp2ErrorCode() HTTP/2 error code}.
+   * Fail HTTP/2 requests without processing them by sending an [MockResponse.getHttp2ErrorCode].
    */
   RESET_STREAM_AT_START,
 
   /**
-   * Transmit a {@code HTTP/1.1 100 Continue} response before reading the HTTP request body.
-   * Typically this response is sent when a client makes a request with the header {@code
-   * Expect: 100-continue}.
+   * Transmit a `HTTP/1.1 100 Continue` response before reading the HTTP request body.
+   * Typically this response is sent when a client makes a request with the header `Expect: 100-continue`.
    */
   EXPECT_CONTINUE,
 
   /**
-   * Transmit a {@code HTTP/1.1 100 Continue} response before reading the HTTP request body even
-   * if the client does not send the header {@code Expect: 100-continue} in its request.
+   * Transmit a `HTTP/1.1 100 Continue` response before reading the HTTP request body even
+   * if the client does not send the header `Expect: 100-continue` in its request.
    */
   CONTINUE_ALWAYS
 }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index ceea8b934a..2f09a8201e 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -27,6 +27,7 @@
 import java.net.SocketTimeoutException;
 import java.net.URL;
 import java.net.URLConnection;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
@@ -48,6 +49,7 @@
 
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static java.util.Arrays.asList;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static okhttp3.tls.internal.TlsUtil.localhost;
@@ -56,6 +58,7 @@
 import static org.junit.Assert.fail;
 import static org.junit.Assume.assumeFalse;
 
+@SuppressWarnings({"ArraysAsListWithZeroOrOneArgument", "deprecation"})
 public final class MockWebServerTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
@@ -133,13 +136,16 @@
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
     connection.setRequestProperty("Accept-Language", "en-US");
     InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));
     assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
     assertThat(reader.readLine()).isEqualTo("hello world");
 
     RecordedRequest request = server.takeRequest();
     assertThat(request.getRequestLine()).isEqualTo("GET / HTTP/1.1");
     assertThat(request.getHeader("Accept-Language")).isEqualTo("en-US");
+
+    // Server has no more requests.
+    assertThat(server.takeRequest(100, MILLISECONDS)).isNull();
   }
 
   @Test public void redirect() throws Exception {
@@ -151,7 +157,7 @@
 
     URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));
     assertThat(reader.readLine()).isEqualTo("This is the new location!");
 
     RecordedRequest first = server.takeRequest();
@@ -175,7 +181,7 @@
 
     URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));
     assertThat(reader.readLine()).isEqualTo("enqueued in the background");
   }
 
@@ -373,15 +379,15 @@
     server.shutdown();
   }
 
-  @Test public void portImplicitlyStarts() throws IOException {
+  @Test public void portImplicitlyStarts() {
     assertThat(server.getPort()).isGreaterThan(0);
   }
 
-  @Test public void hostnameImplicitlyStarts() throws IOException {
+  @Test public void hostnameImplicitlyStarts() {
     assertThat(server.getHostName()).isNotNull();
   }
 
-  @Test public void toProxyAddressImplicitlyStarts() throws IOException {
+  @Test public void toProxyAddressImplicitlyStarts() {
     assertThat(server.toProxyAddress()).isNotNull();
   }
 
@@ -430,7 +436,7 @@
     URL url = server.url("/a/deep/path?key=foo%20bar").url();
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
     InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));
     assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
     assertThat(reader.readLine()).isEqualTo("hello world");
 
@@ -474,7 +480,7 @@
     connection.getOutputStream().write("request".getBytes(UTF_8));
 
     InputStream in = connection.getInputStream();
-    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in, UTF_8));
     assertThat(reader.readLine()).isEqualTo("response");
 
     RecordedRequest request = server.takeRequest();
@@ -522,7 +528,8 @@
     connection.setHostnameVerifier(new RecordingHostnameVerifier());
 
     assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
-    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+    BufferedReader reader =
+        new BufferedReader(new InputStreamReader(connection.getInputStream(), UTF_8));
     assertThat(reader.readLine()).isEqualTo("abc");
 
     RecordedRequest request = server.takeRequest();
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
index 4d498406a8..5e9bb82d75 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
@@ -16,7 +16,6 @@
 
 package okhttp3.mockwebserver;
 
-import java.net.Inet4Address;
 import java.net.InetAddress;
 import java.net.Socket;
 import java.net.UnknownHostException;
@@ -30,24 +29,22 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
+@SuppressWarnings("ConstantConditions")
 public class RecordedRequestTest {
-  Headers headers = Util.EMPTY_HEADERS;
+  private Headers headers = Util.EMPTY_HEADERS;
 
-  private class FakeSocket extends Socket {
+  private static class FakeSocket extends Socket {
     private final InetAddress localAddress;
     private final int remotePort;
     private final InetAddress remoteAddress;
     private final int localPort;
 
-    private FakeSocket(int localPort) {
-      this(Inet4Address.getLoopbackAddress(), localPort);
-    }
-
     private FakeSocket(InetAddress inetAddress, int localPort) {
       this(inetAddress, localPort, inetAddress, 1234);
     }
 
-    private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAddress, int remotePort) {
+    private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAddress,
+        int remotePort) {
       this.localAddress = localAddress;
       this.localPort = localPort;
       this.remoteAddress = remoteAddress;
@@ -75,7 +72,7 @@ private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAd
 
   @Test public void testIPv4() throws UnknownHostException {
     Socket socket =
-        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] { 127, 0, 0, 1 }), 80);
+        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] {127, 0, 0, 1}), 80);
 
     RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
         Collections.emptyList(), 0, new Buffer(), 0, socket);
@@ -85,7 +82,7 @@ private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAd
 
   @Test public void testIpv6() throws UnknownHostException {
     Socket socket = new FakeSocket(InetAddress.getByAddress("::1",
-        new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }), 80);
+        new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}), 80);
 
     RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
         Collections.emptyList(), 0, new Buffer(), 0, socket);
@@ -95,11 +92,31 @@ private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAd
 
   @Test public void testUsesLocal() throws UnknownHostException {
     Socket socket =
-        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] { 127, 0, 0, 1 }), 80);
+        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] {127, 0, 0, 1}), 80);
 
     RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
         Collections.emptyList(), 0, new Buffer(), 0, socket);
 
     assertThat(request.getRequestUrl().toString()).isEqualTo("http://127.0.0.1/");
   }
+
+  @Test public void testLocalhostIpv6() throws UnknownHostException {
+    Socket socket = new FakeSocket(InetAddress.getByAddress("localhost",
+        new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}), 80);
+
+    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
+        Collections.emptyList(), 0, new Buffer(), 0, socket);
+
+    assertThat(request.getRequestUrl().toString()).isEqualTo("http://localhost/");
+  }
+
+  @Test public void testLocalhostIpv4() throws UnknownHostException {
+    Socket socket =
+        new FakeSocket(InetAddress.getByAddress("localhost", new byte[] {127, 0, 0, 1}), 80);
+
+    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
+        Collections.emptyList(), 0, new Buffer(), 0, socket);
+
+    assertThat(request.getRequestUrl().toString()).isEqualTo("http://localhost/");
+  }
 }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
index eeed8d2b08..160159d98e 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
@@ -29,7 +29,6 @@
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Headers;
 import okhttp3.Protocol;
-import okhttp3.internal.Util;
 import okhttp3.internal.http2.Header;
 import okhttp3.internal.http2.Http2Connection;
 import okhttp3.internal.http2.Http2Stream;
@@ -39,6 +38,7 @@
 import okio.Source;
 
 import static java.util.Arrays.asList;
+import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.platform.Platform.INFO;
 import static okhttp3.tls.internal.TlsUtil.localhost;
 
@@ -76,10 +76,14 @@ private void run() throws Exception {
         connection.start();
       } catch (IOException e) {
         logger.log(Level.INFO, "Http2Server connection failure: " + e);
-        Util.closeQuietly(socket);
+        if (socket != null) {
+          closeQuietly(socket);
+        }
       } catch (Exception e) {
         logger.log(Level.WARNING, "Http2Server unexpected failure", e);
-        Util.closeQuietly(socket);
+        if (socket != null) {
+          closeQuietly(socket);
+        }
       }
     }
   }
diff --git a/okcurl/build.gradle b/okcurl/build.gradle
index 54ebfabf50..990860e3e2 100644
--- a/okcurl/build.gradle
+++ b/okcurl/build.gradle
@@ -25,7 +25,7 @@ task copyResourcesTemplates(type: Copy) {
 dependencies {
   api project(':okhttp')
   api project(':okhttp-logging-interceptor')
-  implementation deps.airline
+  implementation deps.picocli
   implementation deps.guava
 
   testImplementation project(':okhttp-testing-support')
diff --git a/okcurl/okcurl b/okcurl/okcurl
new file mode 100755
index 0000000000..72d5ac525a
--- /dev/null
+++ b/okcurl/okcurl
@@ -0,0 +1,5 @@
+#!/bin/sh -e
+
+../gradlew -q --console plain installDist
+
+./build/install/okcurl/bin/okcurl "$@"
diff --git a/okcurl/src/main/java/okhttp3/curl/Main.java b/okcurl/src/main/java/okhttp3/curl/Main.java
deleted file mode 100644
index a6c799b944..0000000000
--- a/okcurl/src/main/java/okhttp3/curl/Main.java
+++ /dev/null
@@ -1,303 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.curl;
-
-import com.google.common.base.Joiner;
-import io.airlift.airline.Arguments;
-import io.airlift.airline.Command;
-import io.airlift.airline.HelpOption;
-import io.airlift.airline.Option;
-import io.airlift.airline.SingleCommand;
-import java.io.IOException;
-import java.io.InputStream;
-import java.security.cert.X509Certificate;
-import java.util.List;
-import java.util.Properties;
-import java.util.logging.ConsoleHandler;
-import java.util.logging.Level;
-import java.util.logging.LogRecord;
-import java.util.logging.Logger;
-import java.util.logging.SimpleFormatter;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Headers;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.StatusLine;
-import okhttp3.internal.http2.Http2;
-import okhttp3.internal.platform.Platform;
-import okhttp3.logging.HttpLoggingInterceptor;
-import okhttp3.logging.LoggingEventListener;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Sink;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-
-@Command(name = Main.NAME, description = "A curl for the next-generation web.")
-public class Main extends HelpOption implements Runnable {
-  static final String NAME = "okcurl";
-  static final int DEFAULT_TIMEOUT = -1;
-  private static Logger frameLogger;
-
-  static Main fromArgs(String... args) {
-    return SingleCommand.singleCommand(Main.class).parse(args);
-  }
-
-  public static void main(String... args) {
-    fromArgs(args).run();
-  }
-
-  private static String versionString() {
-    try {
-      Properties prop = new Properties();
-      InputStream in = Main.class.getResourceAsStream("/okcurl-version.properties");
-      prop.load(in);
-      in.close();
-      return prop.getProperty("version");
-    } catch (IOException e) {
-      throw new AssertionError("Could not load okcurl-version.properties.");
-    }
-  }
-
-  private static String protocols() {
-    return Joiner.on(", ").join(Protocol.values());
-  }
-
-  @Option(name = {"-X", "--request"}, description = "Specify request command to use")
-  public String method;
-
-  @Option(name = {"-d", "--data"}, description = "HTTP POST data")
-  public String data;
-
-  @Option(name = {"-H", "--header"}, description = "Custom header to pass to server")
-  public List<String> headers;
-
-  @Option(name = {"-A", "--user-agent"}, description = "User-Agent to send to server")
-  public String userAgent = NAME + "/" + versionString();
-
-  @Option(name = "--connect-timeout", description = "Maximum time allowed for connection (seconds)")
-  public int connectTimeout = DEFAULT_TIMEOUT;
-
-  @Option(name = "--read-timeout", description = "Maximum time allowed for reading data (seconds)")
-  public int readTimeout = DEFAULT_TIMEOUT;
-
-  @Option(
-      name = "--call-timeout",
-      description = "Maximum time allowed for the entire call (seconds)")
-  public int callTimeout = DEFAULT_TIMEOUT;
-
-  @Option(name = {"-L", "--location"}, description = "Follow redirects")
-  public boolean followRedirects;
-
-  @Option(name = {"-k", "--insecure"},
-      description = "Allow connections to SSL sites without certs")
-  public boolean allowInsecure;
-
-  @Option(name = {"-i", "--include"}, description = "Include protocol headers in the output")
-  public boolean showHeaders;
-
-  @Option(name = "--frames", description = "Log HTTP/2 frames to STDERR")
-  public boolean showHttp2Frames;
-
-  @Option(name = {"-e", "--referer"}, description = "Referer URL")
-  public String referer;
-
-  @Option(name = {"-V", "--version"}, description = "Show version number and quit")
-  public boolean version;
-
-  @Option(
-      name = {"-v", "--verbose"},
-      description = "Makes " + NAME + " verbose during the operation")
-  public boolean verbose;
-
-  @Arguments(title = "url", description = "Remote resource URL")
-  public String url;
-
-  private OkHttpClient client;
-
-  @Override public void run() {
-    if (showHelpIfRequested()) {
-      return;
-    }
-    if (version) {
-      System.out.println(NAME + " " + versionString());
-      System.out.println("Protocols: " + protocols());
-      return;
-    }
-
-    if (showHttp2Frames) {
-      enableHttp2FrameLogging();
-    }
-
-    client = createClient();
-    Request request = createRequest();
-    try {
-      Response response = client.newCall(request).execute();
-      if (showHeaders) {
-        System.out.println(StatusLine.get(response));
-        Headers headers = response.headers();
-        for (int i = 0, size = headers.size(); i < size; i++) {
-          System.out.println(headers.name(i) + ": " + headers.value(i));
-        }
-        System.out.println();
-      }
-
-      // Stream the response to the System.out as it is returned from the server.
-      Sink out = Okio.sink(System.out);
-      BufferedSource source = response.body().source();
-      while (!source.exhausted()) {
-        out.write(source.getBuffer(), source.getBuffer().size());
-        out.flush();
-      }
-
-      response.body().close();
-    } catch (IOException e) {
-      e.printStackTrace();
-    } finally {
-      close();
-    }
-  }
-
-  private OkHttpClient createClient() {
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    builder.followSslRedirects(followRedirects);
-    if (connectTimeout != DEFAULT_TIMEOUT) {
-      builder.connectTimeout(connectTimeout, SECONDS);
-    }
-    if (readTimeout != DEFAULT_TIMEOUT) {
-      builder.readTimeout(readTimeout, SECONDS);
-    }
-    if (callTimeout != DEFAULT_TIMEOUT) {
-      builder.callTimeout(callTimeout, SECONDS);
-    }
-    if (allowInsecure) {
-      X509TrustManager trustManager = createInsecureTrustManager();
-      SSLSocketFactory sslSocketFactory = createInsecureSslSocketFactory(trustManager);
-      builder.sslSocketFactory(sslSocketFactory, trustManager);
-      builder.hostnameVerifier(createInsecureHostnameVerifier());
-    }
-    if (verbose) {
-      HttpLoggingInterceptor.Logger logger = System.out::println;
-      builder.eventListenerFactory(new LoggingEventListener.Factory(logger));
-    }
-    return builder.build();
-  }
-
-  private String getRequestMethod() {
-    if (method != null) {
-      return method;
-    }
-    if (data != null) {
-      return "POST";
-    }
-    return "GET";
-  }
-
-  private RequestBody getRequestBody() {
-    if (data == null) {
-      return null;
-    }
-    String bodyData = data;
-
-    String mimeType = "application/x-www-form-urlencoded";
-    if (headers != null) {
-      for (String header : headers) {
-        String[] parts = header.split(":", -1);
-        if ("Content-Type".equalsIgnoreCase(parts[0])) {
-          mimeType = parts[1].trim();
-          headers.remove(header);
-          break;
-        }
-      }
-    }
-
-    return RequestBody.create(MediaType.parse(mimeType), bodyData);
-  }
-
-  Request createRequest() {
-    Request.Builder request = new Request.Builder();
-
-    request.url(url);
-    request.method(getRequestMethod(), getRequestBody());
-
-    if (headers != null) {
-      for (String header : headers) {
-        String[] parts = header.split(":", 2);
-        request.header(parts[0], parts[1]);
-      }
-    }
-    if (referer != null) {
-      request.header("Referer", referer);
-    }
-    request.header("User-Agent", userAgent);
-
-    return request.build();
-  }
-
-  private void close() {
-    client.connectionPool().evictAll(); // Close any persistent connections.
-  }
-
-  private static X509TrustManager createInsecureTrustManager() {
-    return new X509TrustManager() {
-      @Override public void checkClientTrusted(X509Certificate[] chain, String authType) {
-      }
-
-      @Override public void checkServerTrusted(X509Certificate[] chain, String authType) {
-      }
-
-      @Override public X509Certificate[] getAcceptedIssuers() {
-        return new X509Certificate[0];
-      }
-    };
-  }
-
-  private static SSLSocketFactory createInsecureSslSocketFactory(TrustManager trustManager) {
-    try {
-      SSLContext context = Platform.get().newSSLContext();
-      context.init(null, new TrustManager[] {trustManager}, null);
-      return context.getSocketFactory();
-    } catch (Exception e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  private static HostnameVerifier createInsecureHostnameVerifier() {
-    return (name, session) -> true;
-  }
-
-  private static void enableHttp2FrameLogging() {
-    frameLogger = Logger.getLogger(Http2.class.getName());
-    frameLogger.setLevel(Level.FINE);
-    ConsoleHandler handler = new ConsoleHandler();
-    handler.setLevel(Level.FINE);
-    handler.setFormatter(new SimpleFormatter() {
-      @Override public String format(LogRecord record) {
-        return Util.format("%s%n", record.getMessage());
-      }
-    });
-    frameLogger.addHandler(handler);
-  }
-}
diff --git a/okcurl/src/main/java/okhttp3/curl/Main.kt b/okcurl/src/main/java/okhttp3/curl/Main.kt
new file mode 100644
index 0000000000..9a8f323d52
--- /dev/null
+++ b/okcurl/src/main/java/okhttp3/curl/Main.kt
@@ -0,0 +1,275 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.curl
+
+import okhttp3.MediaType
+import okhttp3.MediaType.Companion.toMediaTypeOrNull
+import okhttp3.OkHttpClient
+import okhttp3.Protocol
+import okhttp3.Request
+import okhttp3.RequestBody.Companion.toRequestBody
+import okhttp3.curl.Main.Companion.NAME
+import okhttp3.internal.format
+import okhttp3.internal.http.StatusLine
+import okhttp3.internal.http2.Http2
+import okhttp3.internal.platform.Platform
+import okhttp3.logging.HttpLoggingInterceptor
+import okhttp3.logging.LoggingEventListener
+import okio.sink
+import picocli.CommandLine
+import picocli.CommandLine.Command
+import picocli.CommandLine.IVersionProvider
+import picocli.CommandLine.Option
+import picocli.CommandLine.Parameters
+import java.io.IOException
+import java.security.cert.X509Certificate
+import java.util.Properties
+import java.util.concurrent.TimeUnit.SECONDS
+import java.util.logging.ConsoleHandler
+import java.util.logging.Level
+import java.util.logging.LogRecord
+import java.util.logging.Logger
+import java.util.logging.SimpleFormatter
+import javax.net.ssl.HostnameVerifier
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.TrustManager
+import javax.net.ssl.X509TrustManager
+import kotlin.system.exitProcess
+
+@Command(name = NAME, description = ["A curl for the next-generation web."],
+    mixinStandardHelpOptions = true, versionProvider = Main.VersionProvider::class)
+class Main : Runnable {
+  @Option(names = ["-X", "--request"], description = ["Specify request command to use"])
+  var method: String? = null
+
+  @Option(names = ["-d", "--data"], description = ["HTTP POST data"])
+  var data: String? = null
+
+  @Option(names = ["-H", "--header"], description = ["Custom header to pass to server"])
+  var headers: MutableList<String>? = null
+
+  @Option(names = ["-A", "--user-agent"], description = ["User-Agent to send to server"])
+  var userAgent = NAME + "/" + versionString()
+
+  @Option(names = ["--connect-timeout"],
+      description = ["Maximum time allowed for connection (seconds)"])
+  var connectTimeout = DEFAULT_TIMEOUT
+
+  @Option(names = ["--read-timeout"],
+      description = ["Maximum time allowed for reading data (seconds)"])
+  var readTimeout = DEFAULT_TIMEOUT
+
+  @Option(names = ["--call-timeout"],
+      description = ["Maximum time allowed for the entire call (seconds)"])
+  var callTimeout = DEFAULT_TIMEOUT
+
+  @Option(names = ["-L", "--location"], description = ["Follow redirects"])
+  var followRedirects: Boolean = false
+
+  @Option(names = ["-k", "--insecure"], description = ["Allow connections to SSL sites without certs"])
+  var allowInsecure: Boolean = false
+
+  @Option(names = ["-i", "--include"], description = ["Include protocol headers in the output"])
+  var showHeaders: Boolean = false
+
+  @Option(names = ["--frames"], description = ["Log HTTP/2 frames to STDERR"])
+  var showHttp2Frames: Boolean = false
+
+  @Option(names = ["-e", "--referer"], description = ["Referer URL"])
+  var referer: String? = null
+
+  @Option(names = ["-v", "--verbose"], description = ["Makes $NAME verbose during the operation"])
+  var verbose: Boolean = false
+
+  @Option(names = ["--completionScript"], hidden = true)
+  var completionScript: Boolean = false
+
+  @Parameters(paramLabel = "url", description = ["Remote resource URL"])
+  var url: String? = null
+
+  private lateinit var client: OkHttpClient
+
+  override fun run() {
+    if (completionScript) {
+      println(picocli.AutoComplete.bash("okcurl", CommandLine(Main())))
+      return
+    }
+
+    if (showHttp2Frames) {
+      enableHttp2FrameLogging()
+    }
+
+    client = createClient()
+    val request = createRequest()
+
+    try {
+      val response = client.newCall(request).execute()
+      if (showHeaders) {
+        println(StatusLine.get(response))
+        val headers = response.headers
+        for ((name, value) in headers) {
+          println("$name: $value")
+        }
+        println()
+      }
+
+      // Stream the response to the System.out as it is returned from the server.
+      val out = System.out.sink()
+      val source = response.body!!.source()
+      while (!source.exhausted()) {
+        out.write(source.buffer, source.buffer.size)
+        out.flush()
+      }
+
+      response.body!!.close()
+    } catch (e: IOException) {
+      e.printStackTrace()
+    } finally {
+      close()
+    }
+  }
+
+  private fun createClient(): OkHttpClient {
+    val builder = OkHttpClient.Builder()
+    builder.followSslRedirects(followRedirects)
+    if (connectTimeout != DEFAULT_TIMEOUT) {
+      builder.connectTimeout(connectTimeout.toLong(), SECONDS)
+    }
+    if (readTimeout != DEFAULT_TIMEOUT) {
+      builder.readTimeout(readTimeout.toLong(), SECONDS)
+    }
+    if (callTimeout != DEFAULT_TIMEOUT) {
+      builder.callTimeout(callTimeout.toLong(), SECONDS)
+    }
+    if (allowInsecure) {
+      val trustManager = createInsecureTrustManager()
+      val sslSocketFactory = createInsecureSslSocketFactory(trustManager)
+      builder.sslSocketFactory(sslSocketFactory, trustManager)
+      builder.hostnameVerifier(createInsecureHostnameVerifier())
+    }
+    if (verbose) {
+      val logger = object : HttpLoggingInterceptor.Logger {
+        override fun log(message: String) {
+          println(message)
+        }
+      }
+      builder.eventListenerFactory(LoggingEventListener.Factory(logger))
+    }
+    return builder.build()
+  }
+
+  public fun createRequest(): Request {
+    val request = Request.Builder()
+
+    val requestMethod = method ?: if (data != null) "POST" else "GET"
+
+    request.url(url!!)
+
+    data?.let {
+      request.method(requestMethod, it.toRequestBody(mediaType()))
+    }
+
+    for (header in headers.orEmpty()) {
+      val parts = header.split(':', limit = 2)
+      request.header(parts[0], parts[1])
+    }
+    referer?.let {
+      request.header("Referer", it)
+    }
+    request.header("User-Agent", userAgent)
+
+    return request.build()
+  }
+
+  private fun mediaType(): MediaType? {
+    val mimeType = headers?.let {
+      for (header in it) {
+        val parts = header.split(':', limit = 2)
+        if ("Content-Type".equals(parts[0], ignoreCase = true)) {
+          it.remove(header)
+          return@let parts[1].trim()
+        }
+      }
+      return@let null
+    } ?: "application/x-www-form-urlencoded"
+
+    return mimeType.toMediaTypeOrNull()
+  }
+
+  private fun close() {
+    client.connectionPool.evictAll() // Close any persistent connections.
+    client.dispatcher.executorService.shutdownNow()
+  }
+
+  class VersionProvider : IVersionProvider {
+    override fun getVersion(): Array<String> {
+      return arrayOf(
+          "$NAME ${versionString()}",
+          "Protocols: ${Protocol.values().joinToString(", ")}",
+          "Platform: ${Platform.get()::class.java.simpleName}"
+      )
+    }
+  }
+
+  companion object {
+    internal const val NAME = "okcurl"
+    internal const val DEFAULT_TIMEOUT = -1
+    private var frameLogger: Logger? = null
+
+    @JvmStatic
+    fun main(args: Array<String>) {
+      exitProcess(CommandLine(Main()).execute(*args))
+    }
+
+    private fun versionString(): String? {
+      val prop = Properties()
+      Main::class.java.getResourceAsStream("/okcurl-version.properties").use {
+        prop.load(it)
+      }
+      return prop.getProperty("version", "dev")
+    }
+
+    private fun createInsecureTrustManager(): X509TrustManager = object : X509TrustManager {
+      override fun checkClientTrusted(chain: Array<X509Certificate>, authType: String) {}
+
+      override fun checkServerTrusted(chain: Array<X509Certificate>, authType: String) {}
+
+      override fun getAcceptedIssuers(): Array<X509Certificate> = arrayOf()
+    }
+
+    private fun createInsecureSslSocketFactory(trustManager: TrustManager): SSLSocketFactory =
+        Platform.get().newSSLContext().apply {
+          init(null, arrayOf(trustManager), null)
+        }.socketFactory
+
+    private fun createInsecureHostnameVerifier(): HostnameVerifier =
+        HostnameVerifier { _, _ -> true }
+
+    private fun enableHttp2FrameLogging() {
+      frameLogger = Logger.getLogger(Http2::class.java.name).apply {
+        level = Level.FINE
+        addHandler(ConsoleHandler().apply {
+          level = Level.FINE
+          formatter = object : SimpleFormatter() {
+            override fun format(record: LogRecord): String {
+              return format("%s%n", record.message)
+            }
+          }
+        })
+      }
+    }
+  }
+}
diff --git a/okcurl/src/test/java/okhttp3/curl/MainTest.java b/okcurl/src/test/java/okhttp3/curl/MainTest.java
index 6277c93f8a..4eecbc938f 100644
--- a/okcurl/src/test/java/okhttp3/curl/MainTest.java
+++ b/okcurl/src/test/java/okhttp3/curl/MainTest.java
@@ -20,11 +20,15 @@
 import okhttp3.RequestBody;
 import okio.Buffer;
 import org.junit.Test;
+import picocli.CommandLine;
 
-import static okhttp3.curl.Main.fromArgs;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class MainTest {
+  public static Main fromArgs(String... args) {
+    return CommandLine.populateCommand(new Main(), args);
+  }
+
   @Test public void simple() {
     Request request = fromArgs("http://example.com").createRequest();
     assertThat(request.method()).isEqualTo("GET");
diff --git a/okhttp-brotli/README.md b/okhttp-brotli/README.md
new file mode 100644
index 0000000000..95d73f722e
--- /dev/null
+++ b/okhttp-brotli/README.md
@@ -0,0 +1,20 @@
+OkHttp Brotli Implementation
+============================
+
+This module is an implementation of [Brotli][1] compression.  
+It enables Brotli support in addition to tranparent Gzip support, 
+provided Accept-Encoding is not set previously.  Modern web servers
+must choose to return Brotli responses.  n.b. It is not used for
+sending requests.
+
+```java
+OkHttpClient client = new OkHttpClient.Builder()
+  .addInterceptor(BrotliInterceptor.INSTANCE)
+  .build();
+```
+
+```kotlin
+implementation("com.squareup.okhttp3:okhttp-brotli:4.1.1")
+```
+
+ [1]: https://github.com/google/brotli
diff --git a/okhttp-brotli/build.gradle b/okhttp-brotli/build.gradle
new file mode 100644
index 0000000000..c04a996383
--- /dev/null
+++ b/okhttp-brotli/build.gradle
@@ -0,0 +1,19 @@
+apply plugin: 'com.vanniktech.maven.publish'
+
+jar {
+  manifest {
+    attributes('Automatic-Module-Name': 'okhttp3.brotli')
+  }
+}
+
+dependencies {
+  api project(':okhttp')
+  api deps.brotli
+  compileOnly deps.jsr305
+
+  testImplementation project(':okhttp-testing-support')
+  testImplementation project(':mockwebserver')
+  testImplementation deps.conscrypt
+  testImplementation deps.junit
+  testImplementation deps.assertj
+}
diff --git a/okhttp-brotli/gradle.properties b/okhttp-brotli/gradle.properties
new file mode 100644
index 0000000000..dc6217c482
--- /dev/null
+++ b/okhttp-brotli/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=okhttp-brotli
+POM_NAME=okhttp-brotli
+POM_PACKAGING=jar
diff --git a/okhttp-brotli/src/main/java/okhttp3/brotli/BrotliInterceptor.kt b/okhttp-brotli/src/main/java/okhttp3/brotli/BrotliInterceptor.kt
new file mode 100644
index 0000000000..ab4e18220e
--- /dev/null
+++ b/okhttp-brotli/src/main/java/okhttp3/brotli/BrotliInterceptor.kt
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.brotli
+
+import okhttp3.Interceptor
+import okhttp3.Response
+import okhttp3.ResponseBody.Companion.asResponseBody
+import okio.GzipSource
+import okio.buffer
+import okio.source
+import org.brotli.dec.BrotliInputStream
+
+/**
+ * Transparent Brotli response support.
+ *
+ * Adds Accept-Encoding: br to request and checks (and strips) for Content-Encoding: br in
+ * responses.  n.b. this replaces the transparent gzip compression in BridgeInterceptor.
+ */
+object BrotliInterceptor : Interceptor {
+  override fun intercept(chain: Interceptor.Chain): Response =
+      if (chain.request().header("Accept-Encoding") == null) {
+        val request = chain.request().newBuilder()
+            .header("Accept-Encoding", "br,gzip")
+            .build()
+
+        val response = chain.proceed(request)
+
+        uncompress(response)
+      } else {
+        chain.proceed(chain.request())
+      }
+
+  internal fun uncompress(response: Response): Response {
+    val body = response.body ?: return response
+    val encoding = response.header("Content-Encoding") ?: return response
+
+    val decompressedSource = when {
+      encoding.equals("br", ignoreCase = true) ->
+        BrotliInputStream(body.source().inputStream()).source().buffer()
+      encoding.equals("gzip", ignoreCase = true) ->
+        GzipSource(body.source()).buffer()
+      else -> return response
+    }
+
+    return response.newBuilder()
+        .removeHeader("Content-Encoding")
+        .removeHeader("Content-Length")
+        .body(decompressedSource.asResponseBody(body.contentType(), -1))
+        .build()
+  }
+}
diff --git a/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorJavaApiTest.java b/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorJavaApiTest.java
new file mode 100644
index 0000000000..9b0efd0b11
--- /dev/null
+++ b/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorJavaApiTest.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.brotli;
+
+import org.junit.Ignore;
+import org.junit.Test;
+
+public class BrotliInterceptorJavaApiTest {
+  @Test @Ignore
+  public void testApi() {
+    BrotliInterceptor.INSTANCE.intercept(null);
+  }
+}
diff --git a/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorTest.kt b/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorTest.kt
new file mode 100644
index 0000000000..c4e16e6b9d
--- /dev/null
+++ b/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorTest.kt
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.brotli
+
+import okhttp3.MediaType.Companion.toMediaType
+import okhttp3.Protocol
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.ResponseBody.Companion.toResponseBody
+import okio.ByteString
+import okio.ByteString.Companion.decodeHex
+import okio.ByteString.Companion.encodeUtf8
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Assert.fail
+import org.junit.Test
+import java.io.IOException
+
+class BrotliInterceptorTest {
+  @Test
+  fun testUncompressBrotli() {
+    val s =
+        "1bce00009c05ceb9f028d14e416230f718960a537b0922d2f7b6adef56532c08dff44551516690131494db" +
+            "6021c7e3616c82c1bc2416abb919aaa06e8d30d82cc2981c2f5c900bfb8ee29d5c03deb1c0dacff80e" +
+            "abe82ba64ed250a497162006824684db917963ecebe041b352a3e62d629cc97b95cac24265b175171e" +
+            "5cb384cd0912aeb5b5dd9555f2dd1a9b20688201"
+
+    val response = response("https://httpbin.org/brotli", s.decodeHex()) {
+      header("Content-Encoding", "br")
+    }
+
+    val uncompressed = BrotliInterceptor.uncompress(response)
+
+    val responseString = uncompressed.body?.string()
+    assertThat(responseString).contains("\"brotli\": true,")
+    assertThat(responseString).contains("\"Accept-Encoding\": \"br\"")
+  }
+
+  @Test
+  fun testUncompressGzip() {
+    val s =
+        "1f8b0800968f215d02ff558ec10e82301044ef7c45b3e75269d0c478e340e4a426e007086c4a636c9bb65e" +
+            "24fcbb5b484c3cec61deccecee9c3106eaa39dc3114e2cfa377296d8848f117d20369324500d03ba98" +
+            "d766b0a3368a0ce83d4f55581b14696c88894f31ba5e1b61bdfa79f7803eaf149a35619f29b3db0b29" +
+            "8abcbd54b7b6b97640c965bbfec238d9f4109ceb6edb01d66ba54d6247296441531e445970f627215b" +
+            "b22f1017320dd5000000"
+
+    val response = response("https://httpbin.org/gzip", s.decodeHex()) {
+      header("Content-Encoding", "gzip")
+    }
+
+    val uncompressed = BrotliInterceptor.uncompress(response)
+
+    val responseString = uncompressed.body?.string()
+    assertThat(responseString).contains("\"gzipped\": true,")
+    assertThat(responseString).contains("\"Accept-Encoding\": \"br,gzip\"")
+  }
+
+  @Test
+  fun testNoUncompress() {
+    val response = response("https://httpbin.org/brotli", "XXXX".encodeUtf8())
+
+    val same = BrotliInterceptor.uncompress(response)
+
+    val responseString = same.body?.string()
+    assertThat(responseString).isEqualTo("XXXX")
+  }
+
+  @Test
+  fun testFailsUncompress() {
+    val response = response("https://httpbin.org/brotli", "bb919aaa06e8".decodeHex()) {
+      header("Content-Encoding", "br")
+    }
+
+    try {
+      val failingResponse = BrotliInterceptor.uncompress(response)
+      failingResponse.body?.string()
+
+      fail("expected uncompress error")
+    } catch (ioe: IOException) {
+      assertThat(ioe).hasMessage("Brotli stream decoding failed")
+      assertThat(ioe.cause?.javaClass?.simpleName).isEqualTo("BrotliRuntimeException")
+    }
+  }
+
+  private fun response(
+    url: String,
+    bodyHex: ByteString,
+    fn: Response.Builder.() -> Unit = {}
+  ): Response {
+    return Response.Builder()
+        .body(bodyHex.toResponseBody("text/plain".toMediaType()))
+        .code(200)
+        .message("OK")
+        .request(Request.Builder().url(url).build())
+        .protocol(Protocol.HTTP_2)
+        .apply(fn)
+        .build()
+  }
+}
diff --git a/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliTestMain.kt b/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliTestMain.kt
new file mode 100644
index 0000000000..bfae423ee1
--- /dev/null
+++ b/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliTestMain.kt
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.brotli
+
+import okhttp3.OkHttpClient
+import okhttp3.Request
+
+fun main() {
+  val client = OkHttpClient.Builder()
+      .addInterceptor(BrotliInterceptor)
+      .build()
+
+  sendRequest("https://httpbin.org/brotli", client)
+  sendRequest("https://httpbin.org/gzip", client)
+}
+
+private fun sendRequest(url: String, client: OkHttpClient) {
+  val req = Request.Builder().url(url).build()
+
+  client.newCall(req).execute().use {
+    println(it.body?.string())
+  }
+}
\ No newline at end of file
diff --git a/okhttp-dnsoverhttps/README.md b/okhttp-dnsoverhttps/README.md
index 30132b47c8..bd9c0ea601 100644
--- a/okhttp-dnsoverhttps/README.md
+++ b/okhttp-dnsoverhttps/README.md
@@ -3,3 +3,9 @@ OkHttp DNS over HTTPS Implementation
 
 This module is an experimental implementation of DNS over HTTPS using OkHttp.
 API is not considered stable and may change at any time.
+
+### Download
+
+```kotlin
+testImplementation("com.squareup.okhttp3:okhttp-dnsoverhttps:4.1.1")
+```
diff --git a/okhttp-dnsoverhttps/build.gradle b/okhttp-dnsoverhttps/build.gradle
index 1a9f104092..16fb4c80fb 100644
--- a/okhttp-dnsoverhttps/build.gradle
+++ b/okhttp-dnsoverhttps/build.gradle
@@ -16,3 +16,10 @@ dependencies {
   testImplementation deps.junit
   testImplementation deps.assertj
 }
+
+afterEvaluate { project ->
+  project.tasks.dokka {
+    outputDirectory = "$rootDir/docs/4.x"
+    outputFormat = 'gfm'
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt
index 5f088fa71b..bb4d37cfc2 100644
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt
@@ -21,10 +21,11 @@ import okhttp3.Callback
 import okhttp3.Dns
 import okhttp3.HttpUrl
 import okhttp3.MediaType
+import okhttp3.MediaType.Companion.toMediaType
 import okhttp3.OkHttpClient
 import okhttp3.Protocol
 import okhttp3.Request
-import okhttp3.RequestBody
+import okhttp3.RequestBody.Companion.toRequestBody
 import okhttp3.Response
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.publicsuffix.PublicSuffixDatabase
@@ -35,43 +36,29 @@ import java.util.ArrayList
 import java.util.concurrent.CountDownLatch
 
 /**
- * [DNS over HTTPS implementation][[doh_spec]].
+ * [DNS over HTTPS implementation][doh_spec].
  *
- * <blockquote>A DNS API client encodes a single DNS query into an HTTP request
- * using either the HTTP GET or POST method and the other requirements
- * of this section.  The DNS API server defines the URI used by the
- * request through the use of a URI Template.</blockquote>
+ * > A DNS API client encodes a single DNS query into an HTTP request
+ * > using either the HTTP GET or POST method and the other requirements
+ * > of this section.  The DNS API server defines the URI used by the
+ * > request through the use of a URI Template.
  *
- * <h3>Warning: This is a non-final API.</h3>
+ * ### Warning: This is a non-final API.
  *
- * As of OkHttp 3.14, this feature is an unstable preview: the API is subject to change,
- * and the implementation is incomplete. We expect that OkHttp 4.0 or 4.1 will finalize this API.
- * Until then, expect API and behavior changes when you update your OkHttp dependency.**
+ * As of OkHttp 3.14, this feature is an unstable preview: the API is subject to change, and the
+ * implementation is incomplete. We expect that OkHttp 4.0 or 4.1 will finalize this API. Until
+ * then, expect API and behavior changes when you update your OkHttp dependency.**
  *
  * [doh_spec]: https://tools.ietf.org/html/draft-ietf-doh-dns-over-https-13
  */
-class DnsOverHttps internal constructor(builder: Builder) : Dns {
-  private val client: OkHttpClient =
-      builder.client?.newBuilder()?.dns(buildBootstrapClient(builder))?.build()
-          ?: throw NullPointerException("client not set")
-  private val url: HttpUrl = builder.url ?: throw NullPointerException("url not set")
-  private val includeIPv6: Boolean = builder.includeIPv6
-  private val post: Boolean = builder.post
-  private val resolvePrivateAddresses: Boolean = builder.resolvePrivateAddresses
-  private val resolvePublicAddresses: Boolean = builder.resolvePublicAddresses
-
-  fun url(): HttpUrl = url
-
-  fun post(): Boolean = post
-
-  fun includeIPv6(): Boolean = includeIPv6
-
-  fun client(): OkHttpClient = client
-
-  fun resolvePrivateAddresses(): Boolean = resolvePrivateAddresses
-
-  fun resolvePublicAddresses(): Boolean = resolvePublicAddresses
-
+class DnsOverHttps internal constructor(
+  @get:JvmName("client") val client: OkHttpClient,
+  @get:JvmName("url") val url: HttpUrl,
+  @get:JvmName("includeIPv6") val includeIPv6: Boolean,
+  @get:JvmName("post") val post: Boolean,
+  @get:JvmName("resolvePrivateAddresses") val resolvePrivateAddresses: Boolean,
+  @get:JvmName("resolvePublicAddresses") val resolvePublicAddresses: Boolean
+) : Dns {
   @Throws(UnknownHostException::class)
   override fun lookup(hostname: String): List<InetAddress> {
     if (!resolvePrivateAddresses || !resolvePublicAddresses) {
@@ -103,7 +90,7 @@ class DnsOverHttps internal constructor(builder: Builder) : Dns {
 
     executeRequests(hostname, networkRequests, results, failures)
 
-    return if (!results.isEmpty()) {
+    return if (results.isNotEmpty()) {
       results
     } else {
       throwBestFailure(hostname, failures)
@@ -196,13 +183,13 @@ class DnsOverHttps internal constructor(builder: Builder) : Dns {
   }
 
   private fun getCacheOnlyResponse(request: Request): Response? {
-    if (!post && client.cache() != null) {
+    if (!post && client.cache != null) {
       try {
         val cacheRequest = request.newBuilder().cacheControl(CacheControl.FORCE_CACHE).build()
 
         val cacheResponse = client.newCall(cacheRequest).execute()
 
-        if (cacheResponse.code() != 504) {
+        if (cacheResponse.code != 504) {
           return cacheResponse
         }
       } catch (ioe: IOException) {
@@ -216,16 +203,16 @@ class DnsOverHttps internal constructor(builder: Builder) : Dns {
 
   @Throws(Exception::class)
   private fun readResponse(hostname: String, response: Response): List<InetAddress> {
-    if (response.cacheResponse() == null && response.protocol() !== Protocol.HTTP_2) {
-      Platform.get().log(Platform.WARN, "Incorrect protocol: ${response.protocol()}", null)
+    if (response.cacheResponse == null && response.protocol !== Protocol.HTTP_2) {
+      Platform.get().log(Platform.WARN, "Incorrect protocol: ${response.protocol}", null)
     }
 
     response.use {
       if (!response.isSuccessful) {
-        throw IOException("response: " + response.code() + " " + response.message())
+        throw IOException("response: " + response.code + " " + response.message)
       }
 
-      val body = response.body()
+      val body = response.body
 
       if (body!!.contentLength() > MAX_RESPONSE_SIZE) {
         throw IOException(
@@ -244,7 +231,7 @@ class DnsOverHttps internal constructor(builder: Builder) : Dns {
         val query = DnsRecordCodec.encodeQuery(hostname, type)
 
         if (post) {
-          url(url).post(RequestBody.create(DNS_MESSAGE, query))
+          url(url).post(query.toRequestBody(DNS_MESSAGE))
         } else {
           val encoded = query.base64Url().replace("=", "")
           val requestUrl = url.newBuilder().addQueryParameter("dns", encoded).build()
@@ -263,62 +250,63 @@ class DnsOverHttps internal constructor(builder: Builder) : Dns {
     internal var resolvePrivateAddresses = false
     internal var resolvePublicAddresses = true
 
-    fun build(): DnsOverHttps = DnsOverHttps(this)
+    fun build(): DnsOverHttps {
+      val client = this.client ?: throw NullPointerException("client not set")
+      return DnsOverHttps(
+          client.newBuilder().dns(buildBootstrapClient(this)).build(),
+          checkNotNull(url) { "url not set" },
+          includeIPv6,
+          post,
+          resolvePrivateAddresses,
+          resolvePublicAddresses
+      )
+    }
 
-    fun client(client: OkHttpClient): Builder {
+    fun client(client: OkHttpClient) = apply {
       this.client = client
-      return this
     }
 
-    fun url(url: HttpUrl): Builder {
+    fun url(url: HttpUrl) = apply {
       this.url = url
-      return this
     }
 
-    fun includeIPv6(includeIPv6: Boolean): Builder {
+    fun includeIPv6(includeIPv6: Boolean) = apply {
       this.includeIPv6 = includeIPv6
-      return this
     }
 
-    fun post(post: Boolean): Builder {
+    fun post(post: Boolean) = apply {
       this.post = post
-      return this
     }
 
-    fun resolvePrivateAddresses(resolvePrivateAddresses: Boolean): Builder {
+    fun resolvePrivateAddresses(resolvePrivateAddresses: Boolean) = apply {
       this.resolvePrivateAddresses = resolvePrivateAddresses
-      return this
     }
 
-    fun resolvePublicAddresses(resolvePublicAddresses: Boolean): Builder {
+    fun resolvePublicAddresses(resolvePublicAddresses: Boolean) = apply {
       this.resolvePublicAddresses = resolvePublicAddresses
-      return this
     }
 
-    fun bootstrapDnsHosts(bootstrapDnsHosts: List<InetAddress>?): Builder {
+    fun bootstrapDnsHosts(bootstrapDnsHosts: List<InetAddress>?) = apply {
       this.bootstrapDnsHosts = bootstrapDnsHosts
-      return this
     }
 
-    fun bootstrapDnsHosts(vararg bootstrapDnsHosts: InetAddress): Builder {
-      return bootstrapDnsHosts(bootstrapDnsHosts.toList())
-    }
+    fun bootstrapDnsHosts(vararg bootstrapDnsHosts: InetAddress): Builder =
+        bootstrapDnsHosts(bootstrapDnsHosts.toList())
 
-    fun systemDns(systemDns: Dns): Builder {
+    fun systemDns(systemDns: Dns) = apply {
       this.systemDns = systemDns
-      return this
     }
   }
 
   companion object {
-    val DNS_MESSAGE: MediaType = MediaType.get("application/dns-message")
+    val DNS_MESSAGE: MediaType = "application/dns-message".toMediaType()
     const val MAX_RESPONSE_SIZE = 64 * 1024
 
     private fun buildBootstrapClient(builder: Builder): Dns {
       val hosts = builder.bootstrapDnsHosts
 
       return if (hosts != null) {
-        BootstrapDns(builder.url!!.host(), hosts)
+        BootstrapDns(builder.url!!.host, hosts)
       } else {
         builder.systemDns
       }
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt
index 0551d39f6f..ebf0d4a592 100644
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt
@@ -22,7 +22,6 @@ import java.io.EOFException
 import java.net.InetAddress
 import java.net.UnknownHostException
 import java.nio.charset.StandardCharsets
-import java.util.ArrayList
 
 /**
  * Trivial Dns Encoder/Decoder, basically ripped from Netty full implementation.
@@ -35,7 +34,6 @@ object DnsRecordCodec {
   private const val TYPE_PTR = 0x000c
   private val ASCII = StandardCharsets.US_ASCII
 
-  @JvmStatic
   fun encodeQuery(host: String, type: Int): ByteString = Buffer().apply {
     writeShort(0) // query id
     writeShort(256) // flags with recursion
@@ -45,12 +43,10 @@ object DnsRecordCodec {
     writeShort(0) // additional
 
     val nameBuf = Buffer()
-    val labels = host.split('.').dropLastWhile { it.isEmpty() }.toTypedArray()
+    val labels = host.split('.').dropLastWhile { it.isEmpty() }
     for (label in labels) {
       val utf8ByteCount = label.utf8Size()
-      if (utf8ByteCount != label.length.toLong()) {
-        throw IllegalArgumentException("non-ascii hostname: $host")
-      }
+      require(utf8ByteCount == label.length.toLong()) { "non-ascii hostname: $host" }
       nameBuf.writeByte(utf8ByteCount.toInt())
       nameBuf.writeUtf8(label)
     }
@@ -62,18 +58,15 @@ object DnsRecordCodec {
   }.readByteString()
 
   @Throws(Exception::class)
-  @JvmStatic
   fun decodeAnswers(hostname: String, byteString: ByteString): List<InetAddress> {
-    val result = ArrayList<InetAddress>()
+    val result = mutableListOf<InetAddress>()
 
     val buf = Buffer()
     buf.write(byteString)
     buf.readShort() // query id
 
     val flags = buf.readShort().toInt() and 0xffff
-    if (flags shr 15 == 0) {
-      throw IllegalArgumentException("not a response")
-    }
+    require(flags shr 15 != 0) { "not a response" }
 
     val responseCode = flags and 0xf
 
@@ -99,7 +92,7 @@ object DnsRecordCodec {
 
       val type = buf.readShort().toInt() and 0xffff
       buf.readShort() // class
-      val ttl = buf.readInt().toLong() and 0xffffffffL // ttl
+      @Suppress("UNUSED_VARIABLE") val ttl = buf.readInt().toLong() and 0xffffffffL // ttl
       val length = buf.readShort().toInt() and 0xffff
 
       if (type == TYPE_A || type == TYPE_AAAA) {
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.kt
index f0f89d115b..b998f5b899 100644
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.kt
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.kt
@@ -1,2 +1,2 @@
-/** A DNS over HTTPS implementation for OkHttp.  */
+/** A DNS over HTTPS implementation for OkHttp. */
 package okhttp3.dnsoverhttps
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
index 8eea96c7bd..88e1bb3aad 100644
--- a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
@@ -34,7 +34,7 @@
   }
 
   private String encodeQuery(String host, int type) {
-    return DnsRecordCodec.encodeQuery(host, type).base64Url().replace("=", "");
+    return DnsRecordCodec.INSTANCE.encodeQuery(host, type).base64Url().replace("=", "");
   }
 
   @Test public void testGoogleDotComEncodingWithIPv6() {
@@ -44,30 +44,37 @@ private String encodeQuery(String host, int type) {
   }
 
   @Test public void testGoogleDotComDecodingFromCloudflare() throws Exception {
-    List<InetAddress> encoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
-        "00008180000100010000000006676f6f676c6503636f6d0000010001c00c00010001000000430004d83ad54e"));
+    List<InetAddress> encoded = DnsRecordCodec.INSTANCE.decodeAnswers("test.com",
+        ByteString.decodeHex("00008180000100010000000006676f6f676c6503636f6d0000010001c00c000100010"
+            + "00000430004d83ad54e"));
 
     assertThat(encoded).containsExactly(InetAddress.getByName("216.58.213.78"));
   }
 
   @Test public void testGoogleDotComDecodingFromGoogle() throws Exception {
-    List<InetAddress> decoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
-        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c0005000100000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c042000100010000003b00049df00112"));
+    List<InetAddress> decoded = DnsRecordCodec.INSTANCE.decodeAnswers("test.com",
+        ByteString.decodeHex("0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010"
+            + "001c00c0005000100000a6d000603617069c012c0300005000100000cde000c04737461720463313072c"
+            + "012c042000100010000003b00049df00112"));
 
     assertThat(decoded).containsExactly(InetAddress.getByName("157.240.1.18"));
   }
 
   @Test public void testGoogleDotComDecodingFromGoogleIPv6() throws Exception {
-    List<InetAddress> decoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
-        "0000818000010003000000000567726170680866616365626f6f6b03636f6d00001c0001c00c0005000100000a1b000603617069c012c0300005000100000b1f000c04737461720463313072c012c042001c00010000003b00102a032880f0290011faceb00c00000002"));
+    List<InetAddress> decoded = DnsRecordCodec.INSTANCE.decodeAnswers("test.com",
+        ByteString.decodeHex("0000818000010003000000000567726170680866616365626f6f6b03636f6d00001c0"
+            + "001c00c0005000100000a1b000603617069c012c0300005000100000b1f000c04737461720463313072c"
+            + "012c042001c00010000003b00102a032880f0290011faceb00c00000002"));
 
     assertThat(decoded).containsExactly(InetAddress.getByName("2a03:2880:f029:11:face:b00c:0:2"));
   }
 
   @Test public void testGoogleDotComDecodingNxdomainFailure() throws Exception {
     try {
-      DnsRecordCodec.decodeAnswers("sdflkhfsdlkjdf.ee", ByteString.decodeHex(
-          "0000818300010000000100000e7364666c6b686673646c6b6a64660265650000010001c01b00060001000007070038026e7303746c64c01b0a686f73746d61737465720d6565737469696e7465726e6574c01b5adb12c100000e10000003840012750000000e10"));
+      DnsRecordCodec.INSTANCE.decodeAnswers("sdflkhfsdlkjdf.ee", ByteString.decodeHex("000081830001"
+          + "0000000100000e7364666c6b686673646c6b6a64660265650000010001c01b00060001000007070038026e"
+          + "7303746c64c01b0a686f73746d61737465720d6565737469696e7465726e6574c01b5adb12c100000e1000"
+          + "0003840012750000000e10"));
       fail();
     } catch (UnknownHostException uhe) {
       assertThat(uhe.getMessage()).isEqualTo("sdflkhfsdlkjdf.ee: NXDOMAIN");
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
index fae2f6e6ca..e09ca8fd50 100644
--- a/okhttp-logging-interceptor/README.md
+++ b/okhttp-logging-interceptor/README.md
@@ -36,20 +36,10 @@ logging.redactHeader("Cookie");
 Download
 --------
 
-Get via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>logging-interceptor</artifactId>
-  <version>(insert latest version)</version>
-</dependency>
-```
-
-or via Gradle 
-```groovy
-implementation 'com.squareup.okhttp3:logging-interceptor:(insert latest version)'
+```kotlin
+implementation("com.squareup.okhttp3:logging-interceptor:4.1.1")
 ```
 
 
 
- [1]: https://github.com/square/okhttp/wiki/Interceptors
+ [1]: ../INTERCEPTORS.md
diff --git a/okhttp-logging-interceptor/build.gradle b/okhttp-logging-interceptor/build.gradle
index 5381903882..b9d5410558 100644
--- a/okhttp-logging-interceptor/build.gradle
+++ b/okhttp-logging-interceptor/build.gradle
@@ -19,6 +19,13 @@ dependencies {
   testImplementation deps.assertj
 }
 
+afterEvaluate { project ->
+  project.tasks.dokka {
+    outputDirectory = "$rootDir/docs/4.x"
+    outputFormat = 'gfm'
+  }
+}
+
 task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
   oldClasspath = files(baselineJar(project, baselineVersion))
   newClasspath = files(jar.archivePath)
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
index f31b005a82..233142b7a3 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
@@ -19,15 +19,14 @@ import okhttp3.Headers
 import okhttp3.Interceptor
 import okhttp3.OkHttpClient
 import okhttp3.Response
-import okhttp3.internal.http.HttpHeaders
+import okhttp3.internal.http.promisesBody
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.platform.Platform.Companion.INFO
 import okio.Buffer
 import okio.GzipSource
-import java.io.EOFException
 import java.io.IOException
 import java.nio.charset.Charset
-import java.nio.charset.StandardCharsets
+import java.nio.charset.StandardCharsets.UTF_8
 import java.util.TreeSet
 import java.util.concurrent.TimeUnit
 
@@ -44,7 +43,8 @@ class HttpLoggingInterceptor @JvmOverloads constructor(
 
   @Volatile private var headersToRedact = emptySet<String>()
 
-  @Volatile @set:JvmName("-deprecated_setLevel") var level = Level.NONE
+  @set:JvmName("level")
+  @Volatile var level = Level.NONE
 
   enum class Level {
     /** No logs. */
@@ -109,15 +109,7 @@ class HttpLoggingInterceptor @JvmOverloads constructor(
     fun log(message: String)
 
     companion object {
-      // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
-      @JvmName("-deprecated_Logger")
-      inline operator fun invoke(
-        crossinline block: (message: String) -> Unit
-      ): Logger = object : Logger {
-        override fun log(message: String) = block(message)
-      }
-
-      /** A [Logger] defaults output appropriate for the current platform.  */
+      /** A [Logger] defaults output appropriate for the current platform. */
       @JvmField
       val DEFAULT: Logger = object : Logger {
         override fun log(message: String) {
@@ -129,16 +121,24 @@ class HttpLoggingInterceptor @JvmOverloads constructor(
 
   fun redactHeader(name: String) {
     val newHeadersToRedact = TreeSet(String.CASE_INSENSITIVE_ORDER)
-    newHeadersToRedact.addAll(headersToRedact)
-    newHeadersToRedact.add(name)
+    newHeadersToRedact += headersToRedact
+    newHeadersToRedact += name
     headersToRedact = newHeadersToRedact
   }
 
+  @Deprecated(
+      message = "Moved to var. Replace setLevel(...) with level(...) to fix Java",
+      replaceWith = ReplaceWith(expression = "apply { this.level = level }"),
+      level = DeprecationLevel.WARNING)
   fun setLevel(level: Level) = apply {
     this.level = level
   }
 
-  @JvmName("-deprecated_getLevel")
+  @JvmName("-deprecated_level")
+  @Deprecated(
+      message = "moved to var",
+      replaceWith = ReplaceWith(expression = "level"),
+      level = DeprecationLevel.ERROR)
   fun getLevel(): Level = level
 
   @Throws(IOException::class)
@@ -153,61 +153,58 @@ class HttpLoggingInterceptor @JvmOverloads constructor(
     val logBody = level == Level.BODY
     val logHeaders = logBody || level == Level.HEADERS
 
-    val requestBody = request.body()
+    val requestBody = request.body
 
     val connection = chain.connection()
     var requestStartMessage =
-        ("--> ${request.method()} ${request.url()}${if (connection != null) " " + connection.protocol() else ""}")
+        ("--> ${request.method} ${request.url}${if (connection != null) " " + connection.protocol() else ""}")
     if (!logHeaders && requestBody != null) {
       requestStartMessage += " (${requestBody.contentLength()}-byte body)"
     }
     logger.log(requestStartMessage)
 
     if (logHeaders) {
+      val headers = request.headers
+
       if (requestBody != null) {
-        // Request body headers are only present when installed as a network interceptor. Force
-        // them to be included (when available) so there values are known.
+        // Request body headers are only present when installed as a network interceptor. When not
+        // already present, force them to be included (if available) so their values are known.
         requestBody.contentType()?.let {
-          logger.log("Content-Type: $it")
+          if (headers["Content-Type"] == null) {
+            logger.log("Content-Type: $it")
+          }
         }
         if (requestBody.contentLength() != -1L) {
-          logger.log("Content-Length: ${requestBody.contentLength()}")
+          if (headers["Content-Length"] == null) {
+            logger.log("Content-Length: ${requestBody.contentLength()}")
+          }
         }
       }
 
-      val headers = request.headers()
-      var i = 0
-      val count = headers.size()
-      while (i < count) {
-        val name = headers.name(i)
-        // Skip headers from the request body as they are explicitly logged above.
-        if (!"Content-Type".equals(name, ignoreCase = true) && !"Content-Length".equals(name,
-                ignoreCase = true)) {
-          logHeader(headers, i)
-        }
-        i++
+      for (i in 0 until headers.size) {
+        logHeader(headers, i)
       }
 
       if (!logBody || requestBody == null) {
-        logger.log("--> END ${request.method()}")
-      } else if (bodyHasUnknownEncoding(request.headers())) {
-        logger.log("--> END ${request.method()} (encoded body omitted)")
+        logger.log("--> END ${request.method}")
+      } else if (bodyHasUnknownEncoding(request.headers)) {
+        logger.log("--> END ${request.method} (encoded body omitted)")
       } else if (requestBody.isDuplex()) {
-        logger.log("--> END ${request.method()} (duplex request body omitted)")
+        logger.log("--> END ${request.method} (duplex request body omitted)")
       } else {
         val buffer = Buffer()
         requestBody.writeTo(buffer)
 
         val contentType = requestBody.contentType()
-        val charset: Charset = contentType?.charset(UTF8) ?: UTF8
+        val charset: Charset = contentType?.charset(UTF_8) ?: UTF_8
 
         logger.log("")
-        if (buffer.isUtf8()) {
+        if (buffer.isProbablyUtf8()) {
           logger.log(buffer.readString(charset))
-          logger.log("--> END ${request.method()} (${requestBody.contentLength()}-byte body)")
+          logger.log("--> END ${request.method} (${requestBody.contentLength()}-byte body)")
         } else {
           logger.log(
-              "--> END ${request.method()} (binary ${requestBody.contentLength()}-byte body omitted)")
+              "--> END ${request.method} (binary ${requestBody.contentLength()}-byte body omitted)")
         }
       }
     }
@@ -223,25 +220,25 @@ class HttpLoggingInterceptor @JvmOverloads constructor(
 
     val tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs)
 
-    val responseBody = response.body()!!
+    val responseBody = response.body!!
     val contentLength = responseBody.contentLength()
     val bodySize = if (contentLength != -1L) "$contentLength-byte" else "unknown-length"
     logger.log(
-        "<-- ${response.code()}${if (response.message().isEmpty()) "" else ' ' + response.message()} ${response.request().url()} (${tookMs}ms${if (!logHeaders) ", $bodySize body" else ""})")
+        "<-- ${response.code}${if (response.message.isEmpty()) "" else ' ' + response.message} ${response.request.url} (${tookMs}ms${if (!logHeaders) ", $bodySize body" else ""})")
 
     if (logHeaders) {
-      val headers = response.headers()
-      for (i in 0 until headers.size()) {
+      val headers = response.headers
+      for (i in 0 until headers.size) {
         logHeader(headers, i)
       }
 
-      if (!logBody || !HttpHeaders.hasBody(response)) {
+      if (!logBody || !response.promisesBody()) {
         logger.log("<-- END HTTP")
-      } else if (bodyHasUnknownEncoding(response.headers())) {
+      } else if (bodyHasUnknownEncoding(response.headers)) {
         logger.log("<-- END HTTP (encoded body omitted)")
       } else {
         val source = responseBody.source()
-        source.request(java.lang.Long.MAX_VALUE) // Buffer the entire body.
+        source.request(Long.MAX_VALUE) // Buffer the entire body.
         var buffer = source.buffer
 
         var gzippedLength: Long? = null
@@ -254,9 +251,9 @@ class HttpLoggingInterceptor @JvmOverloads constructor(
         }
 
         val contentType = responseBody.contentType()
-        val charset: Charset = contentType?.charset(UTF8) ?: UTF8
+        val charset: Charset = contentType?.charset(UTF_8) ?: UTF_8
 
-        if (!buffer.isUtf8()) {
+        if (!buffer.isProbablyUtf8()) {
           logger.log("")
           logger.log("<-- END HTTP (binary ${buffer.size}-byte body omitted)")
           return response
@@ -279,43 +276,13 @@ class HttpLoggingInterceptor @JvmOverloads constructor(
   }
 
   private fun logHeader(headers: Headers, i: Int) {
-    val value = if (headersToRedact.contains(headers.name(i))) "██" else headers.value(i)
+    val value = if (headers.name(i) in headersToRedact) "██" else headers.value(i)
     logger.log(headers.name(i) + ": " + value)
   }
 
-  companion object {
-    private val UTF8 = StandardCharsets.UTF_8
-
-    /**
-     * Returns true if the body in question probably contains human readable text. Uses a small
-     * sample of code points to detect unicode control characters commonly used in binary file
-     * signatures.
-     */
-    internal fun Buffer.isUtf8(): Boolean {
-      try {
-        val prefix = Buffer()
-        val byteCount = if (size < 64) size else 64
-        copyTo(prefix, 0, byteCount)
-        for (i in 0 until 16) {
-          if (prefix.exhausted()) {
-            break
-          }
-          val codePoint = prefix.readUtf8CodePoint()
-          if (Character.isISOControl(codePoint) && !Character.isWhitespace(codePoint)) {
-            return false
-          }
-        }
-        return true
-      } catch (e: EOFException) {
-        return false // Truncated UTF-8 sequence.
-      }
-    }
-
-    private fun bodyHasUnknownEncoding(headers: Headers): Boolean {
-      val contentEncoding = headers["Content-Encoding"]
-      return (contentEncoding != null &&
-          !contentEncoding.equals("identity", ignoreCase = true) &&
-          !contentEncoding.equals("gzip", ignoreCase = true))
-    }
+  private fun bodyHasUnknownEncoding(headers: Headers): Boolean {
+    val contentEncoding = headers["Content-Encoding"] ?: return false
+    return !contentEncoding.equals("identity", ignoreCase = true) &&
+        !contentEncoding.equals("gzip", ignoreCase = true)
   }
 }
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt
index 33253db6ee..35024ed219 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt
@@ -19,6 +19,7 @@ import okhttp3.Call
 import okhttp3.Connection
 import okhttp3.EventListener
 import okhttp3.Handshake
+import okhttp3.HttpUrl
 import okhttp3.OkHttpClient
 import okhttp3.Protocol
 import okhttp3.Request
@@ -47,6 +48,14 @@ class LoggingEventListener private constructor(
     logWithTime("callStart: ${call.request()}")
   }
 
+  override fun proxySelectStart(call: Call, url: HttpUrl) {
+    logWithTime("proxySelectStart: $url")
+  }
+
+  override fun proxySelectEnd(call: Call, url: HttpUrl, proxies: List<Proxy>) {
+    logWithTime("proxySelectEnd: $proxies")
+  }
+
   override fun dnsStart(call: Call, domainName: String) {
     logWithTime("dnsStart: $domainName")
   }
@@ -150,8 +159,6 @@ class LoggingEventListener private constructor(
   open class Factory @JvmOverloads constructor(
     private val logger: HttpLoggingInterceptor.Logger = HttpLoggingInterceptor.Logger.DEFAULT
   ) : EventListener.Factory {
-    constructor(block: (string: String) -> Unit) : this(HttpLoggingInterceptor.Logger(block))
-
     override fun create(call: Call): EventListener = LoggingEventListener(logger)
   }
 }
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/utf8.kt b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/utf8.kt
new file mode 100644
index 0000000000..d8ebe52e17
--- /dev/null
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/utf8.kt
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging
+
+import okio.Buffer
+import java.io.EOFException
+
+/**
+ * Returns true if the body in question probably contains human readable text. Uses a small
+ * sample of code points to detect unicode control characters commonly used in binary file
+ * signatures.
+ */
+internal fun Buffer.isProbablyUtf8(): Boolean {
+  try {
+    val prefix = Buffer()
+    val byteCount = size.coerceAtMost(64)
+    copyTo(prefix, 0, byteCount)
+    for (i in 0 until 16) {
+      if (prefix.exhausted()) {
+        break
+      }
+      val codePoint = prefix.readUtf8CodePoint()
+      if (Character.isISOControl(codePoint) && !Character.isWhitespace(codePoint)) {
+        return false
+      }
+    }
+    return true
+  } catch (_: EOFException) {
+    return false // Truncated UTF-8 sequence.
+  }
+}
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index 0c3b850867..48e8a50e9e 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -23,9 +23,10 @@
 import javax.annotation.Nullable;
 import javax.net.ssl.HostnameVerifier;
 import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
-import okhttp3.PlatformRule;
+import okhttp3.testing.PlatformRule;
 import okhttp3.Protocol;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
@@ -69,6 +70,8 @@
   private final HttpLoggingInterceptor applicationInterceptor =
       new HttpLoggingInterceptor(applicationLogs);
 
+  private Interceptor extraNetworkInterceptor = null;
+
   private void setLevel(Level level) {
     networkInterceptor.setLevel(level);
     applicationInterceptor.setLevel(level);
@@ -76,6 +79,9 @@ private void setLevel(Level level) {
 
   @Before public void setUp() {
     client = new OkHttpClient.Builder()
+        .addNetworkInterceptor(chain -> extraNetworkInterceptor != null
+            ? extraNetworkInterceptor.intercept(chain)
+            : chain.proceed(chain.request()))
         .addNetworkInterceptor(networkInterceptor)
         .addInterceptor(applicationInterceptor)
         .sslSocketFactory(
@@ -140,7 +146,7 @@ private void setLevel(Level level) {
     setLevel(Level.BASIC);
 
     server.enqueue(new MockResponse());
-    client.newCall(request().post(RequestBody.create(PLAIN, "Hi?")).build()).execute();
+    client.newCall(request().post(RequestBody.create("Hi?", PLAIN)).build()).execute();
 
     applicationLogs
         .assertLogEqual("--> POST " + url + " (3-byte body)")
@@ -225,7 +231,7 @@ private void setLevel(Level level) {
     setLevel(Level.HEADERS);
 
     server.enqueue(new MockResponse());
-    Request request = request().post(RequestBody.create(PLAIN, "Hi?")).build();
+    Request request = request().post(RequestBody.create("Hi?", PLAIN)).build();
     Response response = client.newCall(request).execute();
     response.body().close();
 
@@ -258,7 +264,7 @@ private void setLevel(Level level) {
     setLevel(Level.HEADERS);
 
     server.enqueue(new MockResponse());
-    Request request = request().post(RequestBody.create(null, "Hi?")).build();
+    Request request = request().post(RequestBody.create("Hi?", null)).build();
     Response response = client.newCall(request).execute();
     response.body().close();
 
@@ -325,6 +331,45 @@ private void setLevel(Level level) {
         .assertNoMoreLogs();
   }
 
+  @Test public void headersPostWithHeaderOverrides() throws IOException {
+    setLevel(Level.HEADERS);
+
+    extraNetworkInterceptor = chain -> chain.proceed(chain.request()
+        .newBuilder()
+        .header("Content-Length", "2")
+        .header("Content-Type", "text/plain-ish")
+        .build());
+
+    server.enqueue(new MockResponse());
+    client.newCall(request()
+        .post(RequestBody.create("Hi?", PLAIN))
+        .build()).execute();
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url)
+        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+        .assertLogEqual("Content-Length: 3")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("Content-Length: 2")
+        .assertLogEqual("Content-Type: text/plain-ish")
+        .assertLogEqual("--> END POST")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
   @Test public void headersResponseBody() throws IOException {
     setLevel(Level.HEADERS);
 
@@ -426,7 +471,7 @@ private void bodyGetNoBody(int code) throws IOException {
     setLevel(Level.BODY);
 
     server.enqueue(new MockResponse());
-    Request request = request().post(RequestBody.create(PLAIN, "Hi?")).build();
+    Request request = request().post(RequestBody.create("Hi?", PLAIN)).build();
     Response response = client.newCall(request).execute();
     response.body().close();
 
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorKotlinTest.kt b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/IsProbablyUtf8Test.kt
similarity index 56%
rename from okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorKotlinTest.kt
rename to okhttp-logging-interceptor/src/test/java/okhttp3/logging/IsProbablyUtf8Test.kt
index 05d63c9684..c31d990129 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorKotlinTest.kt
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/IsProbablyUtf8Test.kt
@@ -15,19 +15,18 @@
  */
 package okhttp3.logging
 
-import okhttp3.logging.HttpLoggingInterceptor.Companion.isUtf8
 import okio.Buffer
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Test
 
-class HttpLoggingInterceptorKotlinTest {
-  @Test fun isPlaintext() {
-    assertThat(Buffer().isUtf8()).isTrue()
-    assertThat(Buffer().writeUtf8("abc").isUtf8()).isTrue()
-    assertThat(Buffer().writeUtf8("new\r\nlines").isUtf8()).isTrue()
-    assertThat(Buffer().writeUtf8("white\t space").isUtf8()).isTrue()
-    assertThat(Buffer().writeByte(0x80).isUtf8()).isTrue()
-    assertThat(Buffer().writeByte(0x00).isUtf8()).isFalse()
-    assertThat(Buffer().writeByte(0xc0).isUtf8()).isFalse()
+class IsProbablyUtf8Test {
+  @Test fun isProbablyUtf8() {
+    assertThat(Buffer().isProbablyUtf8()).isTrue()
+    assertThat(Buffer().writeUtf8("abc").isProbablyUtf8()).isTrue()
+    assertThat(Buffer().writeUtf8("new\r\nlines").isProbablyUtf8()).isTrue()
+    assertThat(Buffer().writeUtf8("white\t space").isProbablyUtf8()).isTrue()
+    assertThat(Buffer().writeByte(0x80).isProbablyUtf8()).isTrue()
+    assertThat(Buffer().writeByte(0x00).isProbablyUtf8()).isFalse()
+    assertThat(Buffer().writeByte(0xc0).isProbablyUtf8()).isFalse()
   }
 }
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
index f1e5c239b2..97690f5997 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
@@ -20,7 +20,7 @@
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
-import okhttp3.PlatformRule;
+import okhttp3.testing.PlatformRule;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
@@ -73,7 +73,9 @@ public void get() throws Exception {
     response.body().bytes();
 
     logRecorder
-        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + "\\}")
+        .assertLogMatch("proxySelectStart: " + url)
+        .assertLogMatch("proxySelectEnd: \\[DIRECT\\]")
         .assertLogMatch("dnsStart: " + url.host())
         .assertLogMatch("dnsEnd: \\[.+\\]")
         .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
@@ -101,10 +103,12 @@ public void get() throws Exception {
   @Test
   public void post() throws IOException {
     server.enqueue(new MockResponse());
-    client.newCall(request().post(RequestBody.create(PLAIN, "Hello!")).build()).execute();
+    client.newCall(request().post(RequestBody.create("Hello!", PLAIN)).build()).execute();
 
     logRecorder
-        .assertLogMatch("callStart: Request\\{method=POST, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("callStart: Request\\{method=POST, url=" + url + "\\}")
+        .assertLogMatch("proxySelectStart: " + url)
+        .assertLogMatch("proxySelectEnd: \\[DIRECT\\]")
         .assertLogMatch("dnsStart: " + url.host())
         .assertLogMatch("dnsEnd: \\[.+\\]")
         .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
@@ -144,7 +148,9 @@ public void secureGet() throws Exception {
     platform.assumeHttp2Support();
 
     logRecorder
-        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + "\\}")
+        .assertLogMatch("proxySelectStart: " + url)
+        .assertLogMatch("proxySelectEnd: \\[DIRECT\\]")
         .assertLogMatch("dnsStart: " + url.host())
         .assertLogMatch("dnsEnd: \\[.+\\]")
         .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
@@ -187,7 +193,9 @@ public void dnsFail() throws IOException {
     }
 
     logRecorder
-        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + "\\}")
+        .assertLogMatch("proxySelectStart: " + url)
+        .assertLogMatch("proxySelectEnd: \\[DIRECT\\]")
         .assertLogMatch("dnsStart: " + url.host())
         .assertLogMatch("callFailed: java.net.UnknownHostException: reason")
         .assertNoMoreLogs();
@@ -207,7 +215,9 @@ public void connectFail() {
     }
 
     logRecorder
-        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + "\\}")
+        .assertLogMatch("proxySelectStart: " + url)
+        .assertLogMatch("proxySelectEnd: \\[DIRECT\\]")
         .assertLogMatch("dnsStart: " + url.host())
         .assertLogMatch("dnsEnd: \\[.+\\]")
         .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
diff --git a/okhttp-sse/README.md b/okhttp-sse/README.md
index 2b1bc42830..a8d7227903 100644
--- a/okhttp-sse/README.md
+++ b/okhttp-sse/README.md
@@ -3,3 +3,9 @@ OkHttp Server-Sent Events
 
 Experimental support for server-sent events.
 API is not considered stable and may change at any time.
+
+### Download
+
+```kotlin
+testImplementation("com.squareup.okhttp3:okhttp-sse:4.1.1")
+```
diff --git a/okhttp-sse/build.gradle b/okhttp-sse/build.gradle
index a6a478907b..db2745599c 100644
--- a/okhttp-sse/build.gradle
+++ b/okhttp-sse/build.gradle
@@ -18,6 +18,13 @@ dependencies {
   testCompileOnly deps.jsr305
 }
 
+afterEvaluate { project ->
+  project.tasks.dokka {
+    outputDirectory = "$rootDir/docs/4.x"
+    outputFormat = 'gfm'
+  }
+}
+
 task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
   oldClasspath = files(baselineJar(project, baselineVersion))
   newClasspath = files(jar.archivePath)
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.kt b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.kt
index 116764187d..1d72013c2f 100644
--- a/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.kt
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.kt
@@ -22,8 +22,8 @@ import okhttp3.OkHttpClient
 import okhttp3.Request
 import okhttp3.Response
 import okhttp3.ResponseBody
-import okhttp3.internal.Internal
-import okhttp3.internal.Util
+import okhttp3.internal.EMPTY_RESPONSE
+import okhttp3.internal.connection.Exchange
 import okhttp3.sse.EventSource
 import okhttp3.sse.EventSourceListener
 import java.io.IOException
@@ -53,7 +53,7 @@ class RealEventSource(
         return
       }
 
-      val body = response.body()!!
+      val body = response.body!!
 
       if (!body.isEventStream()) {
         listener.onFailure(this,
@@ -62,11 +62,11 @@ class RealEventSource(
       }
 
       // This is a long-lived response. Cancel full-call timeouts.
-      Internal.instance.exchange(response)?.timeoutEarlyExit()
+      Exchange.get(response)?.timeoutEarlyExit()
 
       // Replace the body with an empty one so the callbacks can't see real data.
       val response = response.newBuilder()
-          .body(Util.EMPTY_RESPONSE)
+          .body(EMPTY_RESPONSE)
           .build()
 
       val reader = ServerSentEventReader(body.source(), this)
@@ -84,7 +84,7 @@ class RealEventSource(
 
   private fun ResponseBody.isEventStream(): Boolean {
     val contentType = contentType() ?: return false
-    return contentType.type() == "text" && contentType.subtype() == "event-stream"
+    return contentType.type == "text" && contentType.subtype == "event-stream"
   }
 
   override fun onFailure(call: Call, e: IOException) {
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.kt b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.kt
index 98e4d0f970..ca2ee2e1e9 100644
--- a/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.kt
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.kt
@@ -15,6 +15,7 @@
  */
 package okhttp3.internal.sse
 
+import okhttp3.internal.toLongOrDefault
 import okio.Buffer
 import okio.BufferedSource
 import okio.ByteString.Companion.encodeUtf8
@@ -151,11 +152,7 @@ class ServerSentEventReader(
     @Throws(IOException::class)
     private fun BufferedSource.readRetryMs(): Long {
       val retryString = readUtf8LineStrict()
-      return try {
-        retryString.toLong()
-      } catch (_: NumberFormatException) {
-        -1L
-      }
+      return retryString.toLongOrDefault(-1L)
     }
   }
 }
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java
deleted file mode 100644
index afcf5f4f9d..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java
+++ /dev/null
@@ -1,3 +0,0 @@
-/** Private support classes for server-sent events. */
-@okhttp3.internal.annotations.EverythingIsNonNull
-package okhttp3.internal.sse;
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSource.kt b/okhttp-sse/src/main/java/okhttp3/sse/EventSource.kt
index 93ac828aa0..38174e1ab0 100644
--- a/okhttp-sse/src/main/java/okhttp3/sse/EventSource.kt
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSource.kt
@@ -18,7 +18,7 @@ package okhttp3.sse
 import okhttp3.Request
 
 interface EventSource {
-  /** Returns the original request that initiated this event source.  */
+  /** Returns the original request that initiated this event source. */
   fun request(): Request
 
   /**
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSources.kt b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.kt
index 2702cd365f..e7297a500c 100644
--- a/okhttp-sse/src/main/java/okhttp3/sse/EventSources.kt
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.kt
@@ -34,7 +34,7 @@ object EventSources {
 
   @JvmStatic
   fun processResponse(response: Response, listener: EventSourceListener) {
-    val eventSource = RealEventSource(response.request(), listener)
+    val eventSource = RealEventSource(response.request, listener)
     eventSource.processResponse(response)
   }
 }
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
index 0dbec41be1..be0e5e69db 100644
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
@@ -24,6 +24,7 @@
 import okhttp3.sse.EventSource;
 import okhttp3.sse.EventSources;
 import org.junit.After;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -34,7 +35,11 @@
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   private final EventSourceRecorder listener = new EventSourceRecorder();
-  private OkHttpClient client = clientTestRule.client;
+  private OkHttpClient client;
+
+  @Before public void setUp() {
+    client = clientTestRule.newClient();
+  }
 
   @After public void after() {
     listener.assertExhausted();
diff --git a/okhttp-testing-support/README.md b/okhttp-testing-support/README.md
new file mode 100644
index 0000000000..f47dbe11bb
--- /dev/null
+++ b/okhttp-testing-support/README.md
@@ -0,0 +1,5 @@
+OkHttp Testing Support
+======================
+
+This module offers utilities and support for testing OkHttp itself. It's not intended for use by
+other projects or consumers of the OkHttp library.
diff --git a/okhttp-testing-support/build.gradle b/okhttp-testing-support/build.gradle
index b2611277a1..3efe882543 100644
--- a/okhttp-testing-support/build.gradle
+++ b/okhttp-testing-support/build.gradle
@@ -3,6 +3,7 @@ dependencies {
   api deps.junit
   api deps.assertj
   api deps.conscrypt
+  api deps.openjsse
   
   compileOnly deps.jsr305
 }
diff --git a/okhttp-testing-support/src/main/java/okhttp3/ClientRuleEventListener.kt b/okhttp-testing-support/src/main/java/okhttp3/ClientRuleEventListener.kt
new file mode 100644
index 0000000000..28444acdb2
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/ClientRuleEventListener.kt
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.io.IOException
+import java.net.InetAddress
+import java.net.InetSocketAddress
+import java.net.Proxy
+import java.util.concurrent.TimeUnit
+
+class ClientRuleEventListener(var logger: (String) -> Unit) : EventListener(),
+    EventListener.Factory {
+  private var startNs: Long = 0
+
+  override fun create(call: Call): EventListener = this
+
+  override fun callStart(call: Call) {
+    startNs = System.nanoTime()
+
+    logWithTime("callStart: ${call.request()}")
+  }
+
+  override fun proxySelectStart(call: Call, url: HttpUrl) {
+    logWithTime("proxySelectStart: $url")
+  }
+
+  override fun proxySelectEnd(call: Call, url: HttpUrl, proxies: List<Proxy>) {
+    logWithTime("proxySelectEnd: $proxies")
+  }
+
+  override fun dnsStart(call: Call, domainName: String) {
+    logWithTime("dnsStart: $domainName")
+  }
+
+  override fun dnsEnd(call: Call, domainName: String, inetAddressList: List<InetAddress>) {
+    logWithTime("dnsEnd: $inetAddressList")
+  }
+
+  override fun connectStart(call: Call, inetSocketAddress: InetSocketAddress, proxy: Proxy) {
+    logWithTime("connectStart: $inetSocketAddress $proxy")
+  }
+
+  override fun secureConnectStart(call: Call) {
+    logWithTime("secureConnectStart")
+  }
+
+  override fun secureConnectEnd(call: Call, handshake: Handshake?) {
+    logWithTime("secureConnectEnd: $handshake")
+  }
+
+  override fun connectEnd(
+    call: Call,
+    inetSocketAddress: InetSocketAddress,
+    proxy: Proxy,
+    protocol: Protocol?
+  ) {
+    logWithTime("connectEnd: $protocol")
+  }
+
+  override fun connectFailed(
+    call: Call,
+    inetSocketAddress: InetSocketAddress,
+    proxy: Proxy,
+    protocol: Protocol?,
+    ioe: IOException
+  ) {
+    logWithTime("connectFailed: $protocol $ioe")
+  }
+
+  override fun connectionAcquired(call: Call, connection: Connection) {
+    logWithTime("connectionAcquired: $connection")
+  }
+
+  override fun connectionReleased(call: Call, connection: Connection) {
+    logWithTime("connectionReleased")
+  }
+
+  override fun requestHeadersStart(call: Call) {
+    logWithTime("requestHeadersStart")
+  }
+
+  override fun requestHeadersEnd(call: Call, request: Request) {
+    logWithTime("requestHeadersEnd")
+  }
+
+  override fun requestBodyStart(call: Call) {
+    logWithTime("requestBodyStart")
+  }
+
+  override fun requestBodyEnd(call: Call, byteCount: Long) {
+    logWithTime("requestBodyEnd: byteCount=$byteCount")
+  }
+
+  override fun requestFailed(call: Call, ioe: IOException) {
+    logWithTime("requestFailed: $ioe")
+  }
+
+  override fun responseHeadersStart(call: Call) {
+    logWithTime("responseHeadersStart")
+  }
+
+  override fun responseHeadersEnd(call: Call, response: Response) {
+    logWithTime("responseHeadersEnd: $response")
+  }
+
+  override fun responseBodyStart(call: Call) {
+    logWithTime("responseBodyStart")
+  }
+
+  override fun responseBodyEnd(call: Call, byteCount: Long) {
+    logWithTime("responseBodyEnd: byteCount=$byteCount")
+  }
+
+  override fun responseFailed(call: Call, ioe: IOException) {
+    logWithTime("responseFailed: $ioe")
+  }
+
+  override fun callEnd(call: Call) {
+    logWithTime("callEnd")
+  }
+
+  override fun callFailed(call: Call, ioe: IOException) {
+    logWithTime("callFailed: $ioe")
+  }
+
+  private fun logWithTime(message: String) {
+    val timeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs)
+    logger.invoke("[$timeMs ms] $message")
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.java b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.java
deleted file mode 100644
index 41dacf9b13..0000000000
--- a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import org.junit.rules.TestRule;
-import org.junit.runner.Description;
-import org.junit.runners.model.Statement;
-
-import static okhttp3.TestUtil.defaultClient;
-
-public class OkHttpClientTestRule implements TestRule {
-  public OkHttpClient client = defaultClient();
-
-  @Override
-  public Statement apply(Statement base, Description description) {
-    return statement(base);
-  }
-
-  private Statement statement(final Statement base) {
-    return new Statement() {
-      @Override
-      public void evaluate() throws Throwable {
-        try {
-          base.evaluate();
-        } finally {
-          TestUtil.ensureAllConnectionsReleased(client);
-        }
-      }
-    };
-  }
-}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
new file mode 100644
index 0000000000..6d3484807e
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.kt
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.testing.Flaky
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.rules.TestRule
+import org.junit.runner.Description
+import org.junit.runners.model.Statement
+import java.net.InetAddress
+import java.util.concurrent.ConcurrentLinkedDeque
+
+/** Apply this rule to tests that need an OkHttpClient instance. */
+class OkHttpClientTestRule : TestRule {
+  private val clientEventsList = mutableListOf<String>()
+  private var prototype: OkHttpClient? = null
+
+  /**
+   * Returns an OkHttpClient for all tests to use as a starting point.
+   *
+   * The shared instance allows all tests to share a single connection pool, which prevents idle
+   * connections from consuming unnecessary resources while connections wait to be evicted.
+   *
+   * This client is also configured to be slightly more deterministic, returning a single IP
+   * address for all hosts, regardless of the actual number of IP addresses reported by DNS.
+   */
+  fun newClient(): OkHttpClient {
+    return newClientBuilder().build()
+  }
+
+  fun newClientBuilder(): OkHttpClient.Builder {
+    return checkNotNull(prototype) { "don't create clients in test initialization!" }
+        .newBuilder()
+        .eventListener(ClientRuleEventListener { addEvent(it) })
+  }
+
+  @Synchronized private fun addEvent(it: String) {
+    clientEventsList.add(it)
+  }
+
+  fun ensureAllConnectionsReleased() {
+    prototype?.let {
+      val connectionPool = it.connectionPool
+      connectionPool.evictAll()
+      assertThat(connectionPool.connectionCount()).isEqualTo(0)
+    }
+  }
+
+  override fun apply(base: Statement, description: Description): Statement {
+    return object : Statement() {
+      override fun evaluate() {
+        acquireClient()
+        try {
+          base.evaluate()
+          logEventsIfFlaky(description)
+        } catch (t: Throwable) {
+          logEvents()
+          throw t
+        } finally {
+          ensureAllConnectionsReleased()
+          releaseClient()
+        }
+      }
+
+      private fun acquireClient() {
+        prototype = prototypes.poll() ?: freshClient()
+      }
+
+      private fun releaseClient() {
+        prototype?.let {
+          prototypes.push(it)
+          prototype = null
+        }
+      }
+    }
+  }
+
+  private fun logEventsIfFlaky(description: Description) {
+    if (isTestFlaky(description)) {
+      logEvents()
+    }
+  }
+
+  private fun isTestFlaky(description: Description): Boolean {
+    return description.annotations.any { it.annotationClass == Flaky::class } ||
+        description.testClass.annotations.any { it.annotationClass == Flaky::class }
+  }
+
+  @Synchronized private fun logEvents() {
+    // Will be ineffective if test overrides the listener
+    println("Events (${clientEventsList.size})")
+
+    for (e in clientEventsList) {
+      println(e)
+    }
+  }
+
+  /**
+   * Called if a test is known to be leaky.
+   */
+  fun abandonClient() {
+    prototype?.let {
+      prototype = null
+      it.dispatcher.executorService.shutdownNow()
+      it.connectionPool.evictAll()
+    }
+  }
+
+  companion object {
+    /**
+     * Quick and dirty pool of OkHttpClient instances. Each has its own independent dispatcher and
+     * connection pool. This way we can reuse expensive resources while preventing concurrent tests
+     * from interfering with each other.
+     */
+    internal val prototypes = ConcurrentLinkedDeque<OkHttpClient>()
+
+    /**
+     * A network that resolves only one IP address per host. Use this when testing route selection
+     * fallbacks to prevent the host machine's various IP addresses from interfering.
+     */
+    internal val SINGLE_INET_ADDRESS_DNS = object : Dns {
+      override fun lookup(hostname: String): List<InetAddress> {
+        val addresses = Dns.SYSTEM.lookup(hostname)
+        return listOf(addresses[0])
+      }
+    }
+
+    private fun freshClient(): OkHttpClient {
+      return OkHttpClient.Builder()
+          .dns(SINGLE_INET_ADDRESS_DNS) // Prevent unexpected fallback addresses.
+          .build()
+    }
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/RecordingEventListener.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingEventListener.java
similarity index 94%
rename from okhttp/src/test/java/okhttp3/RecordingEventListener.java
rename to okhttp-testing-support/src/main/java/okhttp3/RecordingEventListener.java
index 47d3be7a14..8bd4f86f57 100644
--- a/okhttp/src/test/java/okhttp3/RecordingEventListener.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/RecordingEventListener.java
@@ -27,6 +27,7 @@
 
 import static java.util.Arrays.asList;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertTrue;
 
 public class RecordingEventListener extends EventListener {
   final Deque<CallEvent> eventSequence = new ConcurrentLinkedDeque<>();
@@ -75,12 +76,21 @@ private void logEvent(CallEvent e) {
     CallEvent startEvent = e.closes();
 
     if (startEvent != null) {
-      assertThat(eventSequence).contains(startEvent);
+      assertTrue(eventSequence.contains(startEvent));
     }
 
     eventSequence.offer(e);
   }
 
+  @Override public void proxySelectStart(Call call, HttpUrl url) {
+    logEvent(new ProxySelectStart(call, url));
+  }
+
+  @Override public void proxySelectEnd(Call call, HttpUrl url,
+      List<Proxy> proxies) {
+    logEvent(new ProxySelectEnd(call, url, proxies));
+  }
+
   @Override public void dnsStart(Call call, String domainName) {
     logEvent(new DnsStart(call, domainName));
   }
@@ -208,6 +218,24 @@ public String getName() {
     }
   }
 
+  static final class ProxySelectStart extends CallEvent {
+    final HttpUrl url;
+
+    ProxySelectStart(Call call, HttpUrl url) {
+      super(call, url);
+      this.url = url;
+    }
+  }
+
+  static final class ProxySelectEnd extends CallEvent {
+    final HttpUrl url;
+
+    ProxySelectEnd(Call call, HttpUrl url, List<Proxy> proxies) {
+      super(call, url, proxies);
+      this.url = url;
+    }
+  }
+
   static final class DnsStart extends CallEvent {
     final String domainName;
 
diff --git a/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java b/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
index f3038c090a..8a6bc3443c 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
@@ -17,50 +17,21 @@
 
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 import okhttp3.internal.http2.Header;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assume.assumeNoException;
 
 public final class TestUtil {
   public static final InetSocketAddress UNREACHABLE_ADDRESS
       = new InetSocketAddress("198.51.100.1", 8080);
 
-  /**
-   * A network that resolves only one IP address per host. Use this when testing route selection
-   * fallbacks to prevent the host machine's various IP addresses from interfering.
-   */
-  private static final Dns SINGLE_INET_ADDRESS_DNS = hostname -> {
-    List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
-    return Collections.singletonList(addresses.get(0));
-  };
-
   private TestUtil() {
   }
 
-  private static final ConnectionPool connectionPool = new ConnectionPool();
-  private static final Dispatcher dispatcher = new Dispatcher();
-
-  /**
-   * Returns an OkHttpClient for all tests to use as a starting point.
-   *
-   * <p>The shared instance allows all tests to share a single connection pool, which prevents idle
-   * connections from consuming unnecessary resources while connections wait to be evicted.
-   *
-   * <p>This client is also configured to be slightly more deterministic, returning a single IP
-   * address for all hosts, regardless of the actual number of IP addresses reported by DNS.
-   */
-  public static OkHttpClient defaultClient() {
-    return new OkHttpClient.Builder()
-        .connectionPool(connectionPool)
-        .dispatcher(dispatcher)
-        .dns(SINGLE_INET_ADDRESS_DNS) // Prevent unexpected fallback addresses.
-        .build();
-  }
-
   public static List<Header> headerEntries(String... elements) {
     List<Header> result = new ArrayList<>(elements.length / 2);
     for (int i = 0; i < elements.length; i += 2) {
@@ -86,8 +57,11 @@ public static void awaitGarbageCollection() throws Exception {
     System.runFinalization();
   }
 
-  public static void ensureAllConnectionsReleased(OkHttpClient client) {
-    client.connectionPool().evictAll();
-    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(0);
+  public static void assumeNetwork() {
+    try {
+      InetAddress.getByName("www.google.com");
+    } catch (UnknownHostException uhe) {
+      assumeNoException(uhe);
+    }
   }
 }
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/Flaky.kt b/okhttp-testing-support/src/main/java/okhttp3/testing/Flaky.kt
new file mode 100644
index 0000000000..f3b04d8809
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/testing/Flaky.kt
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.testing
+
+@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)
+@Retention(AnnotationRetention.RUNTIME)
+/**
+ * Annotation marking a test as flaky, and requires extra logging and linking against
+ * a known github issue.  This does not ignore the failure.
+ */
+annotation class Flaky
diff --git a/okhttp-testing-support/src/main/java/okhttp3/PlatformRule.kt b/okhttp-testing-support/src/main/java/okhttp3/testing/PlatformRule.kt
similarity index 56%
rename from okhttp-testing-support/src/main/java/okhttp3/PlatformRule.kt
rename to okhttp-testing-support/src/main/java/okhttp3/testing/PlatformRule.kt
index 359de2c688..49f98011c5 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/PlatformRule.kt
+++ b/okhttp-testing-support/src/main/java/okhttp3/testing/PlatformRule.kt
@@ -13,18 +13,29 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3
+package okhttp3.testing
 
 import okhttp3.internal.platform.ConscryptPlatform
 import okhttp3.internal.platform.Jdk8WithJettyBootPlatform
 import okhttp3.internal.platform.Jdk9Platform
+import okhttp3.internal.platform.OpenJSSEPlatform
 import okhttp3.internal.platform.Platform
 import org.conscrypt.Conscrypt
+import org.hamcrest.BaseMatcher
+import org.hamcrest.CoreMatchers
 import org.hamcrest.CoreMatchers.equalTo
 import org.hamcrest.CoreMatchers.not
+import org.hamcrest.Description
+import org.hamcrest.Matcher
+import org.hamcrest.StringDescription
+import org.hamcrest.TypeSafeMatcher
+import org.junit.Assert
 import org.junit.Assume.assumeThat
 import org.junit.Assume.assumeTrue
-import org.junit.rules.ExternalResource
+import org.junit.AssumptionViolatedException
+import org.junit.rules.TestRule
+import org.junit.runners.model.Statement
+import org.openjsse.net.ssl.OpenJSSE
 import java.security.Security
 
 /**
@@ -37,8 +48,36 @@ import java.security.Security
 open class PlatformRule @JvmOverloads constructor(
   val requiredPlatformName: String? = null,
   val platform: Platform? = null
-) : ExternalResource() {
-  override fun before() {
+) : TestRule {
+  private val versionChecks = mutableListOf<Pair<Matcher<out Any>, Matcher<out Any>>>()
+
+  override fun apply(base: Statement, description: org.junit.runner.Description): Statement {
+    return object : Statement() {
+      @Throws(Throwable::class)
+      override fun evaluate() {
+        var failed = false
+        try {
+          setupPlatform()
+
+          System.err.println("Running with ${Platform.get().javaClass.simpleName}")
+
+          base.evaluate()
+        } catch (e: AssumptionViolatedException) {
+          throw e
+        } catch (e: Throwable) {
+          failed = true
+          rethrowIfNotExpected(e)
+        } finally {
+          resetPlatform()
+        }
+        if (!failed) {
+          failIfExpected()
+        }
+      }
+    }
+  }
+
+  fun setupPlatform() {
     if (requiredPlatformName != null) {
       assumeThat(getPlatformSystemProperty(), equalTo(requiredPlatformName))
     }
@@ -50,12 +89,76 @@ open class PlatformRule @JvmOverloads constructor(
     }
   }
 
-  override fun after() {
+  fun resetPlatform() {
     if (platform != null) {
       Platform.resetForTests()
     }
   }
 
+  fun expectFailureOnConscryptPlatform() {
+    expectFailure(platformMatches(CONSCRYPT_PROPERTY))
+  }
+
+  fun expectFailureOnOpenJSSEPlatform() {
+    expectFailure(platformMatches(OPENJSSE_PROPERTY))
+  }
+
+  fun expectFailureFromJdkVersion(majorVersion: Int) {
+    expectFailure(fromMajor(majorVersion))
+  }
+
+  private fun expectFailure(
+    versionMatcher: Matcher<out Any>,
+    failureMatcher: Matcher<out Any> = CoreMatchers.anything()
+  ) {
+    versionChecks.add(Pair(versionMatcher, failureMatcher))
+  }
+
+  fun platformMatches(platform: String): Matcher<Any> = object : BaseMatcher<Any>() {
+    override fun describeTo(description: Description) {
+      description.appendText(platform)
+    }
+
+    override fun matches(item: Any?): Boolean {
+      return getPlatformSystemProperty() == platform
+    }
+  }
+
+  fun fromMajor(version: Int): Matcher<PlatformVersion> {
+    return object : TypeSafeMatcher<PlatformVersion>() {
+      override fun describeTo(description: Description) {
+        description.appendText("JDK with version from $version")
+      }
+
+      override fun matchesSafely(item: PlatformVersion): Boolean {
+        return item.majorVersion >= version
+      }
+    }
+  }
+
+  fun rethrowIfNotExpected(e: Throwable) {
+    versionChecks.forEach { (versionMatcher, failureMatcher) ->
+      if (versionMatcher.matches(PlatformVersion) && failureMatcher.matches(e)) {
+        return
+      }
+    }
+
+    throw e
+  }
+
+  fun failIfExpected() {
+    versionChecks.forEach { (versionMatcher, failureMatcher) ->
+      if (versionMatcher.matches(PlatformVersion)) {
+        val description = StringDescription()
+        versionMatcher.describeTo(description)
+        description.appendText(" expected to fail with exception that ")
+        failureMatcher.describeTo(description)
+
+        Assert.fail(description.toString())
+      }
+    }
+  }
+
   fun isConscrypt() = getPlatformSystemProperty() == CONSCRYPT_PROPERTY
 
   fun isJdk9() = getPlatformSystemProperty() == JDK9_PROPERTY
@@ -76,6 +179,11 @@ open class PlatformRule @JvmOverloads constructor(
         JDK9_PROPERTY))
   }
 
+  fun assumeOpenJSSE() {
+    assumeThat(getPlatformSystemProperty(), equalTo(
+        OPENJSSE_PROPERTY))
+  }
+
   fun assumeJdk8() {
     assumeThat(getPlatformSystemProperty(), equalTo(
         JDK8_PROPERTY))
@@ -111,6 +219,11 @@ open class PlatformRule @JvmOverloads constructor(
         JDK8_ALPN_PROPERTY))
   }
 
+  fun assumeNotOpenJSSE() {
+    assumeThat(getPlatformSystemProperty(), not(
+        OPENJSSE_PROPERTY))
+  }
+
   fun assumeNotHttp2Support() {
     assumeThat(getPlatformSystemProperty(), equalTo(
         JDK8_PROPERTY))
@@ -126,6 +239,7 @@ open class PlatformRule @JvmOverloads constructor(
     const val JDK9_PROPERTY = "jdk9"
     const val JDK8_ALPN_PROPERTY = "jdk8alpn"
     const val JDK8_PROPERTY = "jdk8"
+    const val OPENJSSE_PROPERTY = "openjsse"
 
     init {
       if (getPlatformSystemProperty() == CONSCRYPT_PROPERTY && Security.getProviders()[0].name != "Conscrypt") {
@@ -143,16 +257,26 @@ open class PlatformRule @JvmOverloads constructor(
         if (isAlpnBootEnabled()) {
           System.err.println("Warning: ALPN Boot enabled unintentionally")
         }
+      } else if (getPlatformSystemProperty() == OPENJSSE_PROPERTY && Security.getProviders()[0].name != "OpenJSSE") {
+        if (!OpenJSSEPlatform.isSupported) {
+          System.err.println("Warning: OpenJSSE not available")
+        }
+
+        Security.insertProviderAt(OpenJSSE(), 1)
       }
+
+      Platform.resetForTests()
     }
 
     @JvmStatic
     fun getPlatformSystemProperty(): String {
-      var property: String? = System.getProperty(PROPERTY_NAME)
+      var property: String? = System.getProperty(
+          PROPERTY_NAME)
 
       if (property == null) {
         property = when (Platform.get()) {
           is ConscryptPlatform -> CONSCRYPT_PROPERTY
+          is OpenJSSEPlatform -> OPENJSSE_PROPERTY
           is Jdk8WithJettyBootPlatform -> CONSCRYPT_PROPERTY
           is Jdk9Platform -> JDK9_PROPERTY
           else -> JDK8_PROPERTY
@@ -165,6 +289,9 @@ open class PlatformRule @JvmOverloads constructor(
     @JvmStatic
     fun conscrypt() = PlatformRule(CONSCRYPT_PROPERTY)
 
+    @JvmStatic
+    fun openjsse() = PlatformRule(OPENJSSE_PROPERTY)
+
     @JvmStatic
     fun jdk9() = PlatformRule(JDK9_PROPERTY)
 
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/PlatformVersion.kt b/okhttp-testing-support/src/main/java/okhttp3/testing/PlatformVersion.kt
new file mode 100644
index 0000000000..17870a7ba7
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/testing/PlatformVersion.kt
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.testing
+
+object PlatformVersion {
+  val majorVersion: Int by lazy {
+    when (val jvmSpecVersion = getJvmSpecVersion()) {
+      "1.8" -> 8
+      else -> jvmSpecVersion.toInt()
+    }
+  }
+
+  fun getJvmSpecVersion(): String {
+    return System.getProperty("java.specification.version", "unknown")
+  }
+}
\ No newline at end of file
diff --git a/okhttp/src/test/java/okhttp3/PlatformRuleTest.kt b/okhttp-testing-support/src/test/kotlin/okhttp3/testing/PlatformRuleTest.kt
similarity index 76%
rename from okhttp/src/test/java/okhttp3/PlatformRuleTest.kt
rename to okhttp-testing-support/src/test/kotlin/okhttp3/testing/PlatformRuleTest.kt
index 2c61838d8a..5fe531cd00 100644
--- a/okhttp/src/test/java/okhttp3/PlatformRuleTest.kt
+++ b/okhttp-testing-support/src/test/kotlin/okhttp3/testing/PlatformRuleTest.kt
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3
+package okhttp3.testing
 
 import okhttp3.internal.platform.Platform
 import org.junit.Rule
@@ -32,4 +32,19 @@ class PlatformRuleTest {
     println(PlatformRule.getPlatformSystemProperty())
     println(Platform.get().javaClass.simpleName)
   }
+  @Test
+  fun testGreenCase() {
+  }
+
+  @Test
+  fun testGreenCaseFailingOnLater() {
+    platform.expectFailureFromJdkVersion(PlatformVersion.majorVersion + 1)
+  }
+
+  @Test
+  fun failureCase() {
+    platform.expectFailureFromJdkVersion(PlatformVersion.majorVersion)
+
+    check(false)
+  }
 }
\ No newline at end of file
diff --git a/okhttp-tls/README.md b/okhttp-tls/README.md
index 2ecaa5c3bf..ec3f7857dd 100644
--- a/okhttp-tls/README.md
+++ b/okhttp-tls/README.md
@@ -226,21 +226,11 @@ clients use `HeldCertificate.Builder.rsa2048()`.
 Download
 --------
 
-Get via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>okhttp-tls</artifactId>
-  <version>(insert latest version)</version>
-</dependency>
+```kotlin
+implementation("com.squareup.okhttp3:okhttp-tls:4.1.1")
 ```
 
-or via Gradle
-```groovy
-implementation 'com.squareup.okhttp3:okhttp-tls:(insert latest version)'
-```
-
- [held_certificate]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HeldCertificate.html
- [held_certificate_builder]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HeldCertificate.Builder.html
- [handshake_certificates]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HandshakeCertificates.html
- [handshake_certificates_builder]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HandshakeCertificates.Builder.html
+ [held_certificate]: http://square.github.io/okhttp/4.x/okhttp-tls/okhttp3.tls/-held-certificate/
+ [held_certificate_builder]: http://square.github.io/okhttp/4.x/okhttp-tls/okhttp3.tls/-held-certificate/-builder/
+ [handshake_certificates]: http://square.github.io/okhttp/4.x/okhttp-tls/okhttp3.tls/-handshake-certificates/
+ [handshake_certificates_builder]: http://square.github.io/okhttp/4.x/okhttp-tls/okhttp3.tls/-handshake-certificates/-builder/
diff --git a/okhttp-tls/build.gradle b/okhttp-tls/build.gradle
index 3ea56bc9ee..011d8c0abc 100644
--- a/okhttp-tls/build.gradle
+++ b/okhttp-tls/build.gradle
@@ -18,6 +18,13 @@ dependencies {
   testImplementation deps.assertj
 }
 
+afterEvaluate { project ->
+  project.tasks.dokka {
+    outputDirectory = "$rootDir/docs/4.x"
+    outputFormat = 'gfm'
+  }
+}
+
 task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
   oldClasspath = files(baselineJar(project, baselineVersion))
   newClasspath = files(jar.archivePath)
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.kt b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.kt
index a21f35a0c4..a9859a241d 100644
--- a/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.kt
+++ b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.kt
@@ -16,7 +16,6 @@
 package okhttp3.tls
 
 import okhttp3.CertificatePinner
-import okhttp3.internal.Util
 import okhttp3.internal.platform.Platform
 import okhttp3.tls.internal.TlsUtil.newKeyManager
 import okhttp3.tls.internal.TlsUtil.newTrustManager
@@ -68,11 +67,22 @@ import javax.net.ssl.X509TrustManager
  *    roots private to an organization or service.
  */
 class HandshakeCertificates private constructor(
-  private val keyManager: X509KeyManager,
-  private val trustManager: X509TrustManager
+  @get:JvmName("keyManager") val keyManager: X509KeyManager,
+  @get:JvmName("trustManager") val trustManager: X509TrustManager
 ) {
+
+  @JvmName("-deprecated_keyManager")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "keyManager"),
+      level = DeprecationLevel.ERROR)
   fun keyManager(): X509KeyManager = keyManager
 
+  @JvmName("-deprecated_trustManager")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "trustManager"),
+      level = DeprecationLevel.ERROR)
   fun trustManager(): X509TrustManager = trustManager
 
   fun sslSocketFactory(): SSLSocketFactory = sslContext().socketFactory
@@ -126,7 +136,7 @@ class HandshakeCertificates private constructor(
      * this problem with [certificate pinning][CertificatePinner].
      */
     fun addPlatformTrustedCertificates() = apply {
-      val platformTrustManager = Util.platformTrustManager()
+      val platformTrustManager = Platform.get().platformTrustManager()
       Collections.addAll(trustedCertificates, *platformTrustManager.acceptedIssuers)
     }
 
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.kt b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.kt
index d27ff0797c..6fae9ee615 100644
--- a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.kt
+++ b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.kt
@@ -15,7 +15,7 @@
  */
 package okhttp3.tls
 
-import okhttp3.internal.Util.verifyAsIpAddress
+import okhttp3.internal.canParseAsIpAddress
 import okio.ByteString
 import okio.ByteString.Companion.toByteString
 import org.bouncycastle.asn1.ASN1Encodable
@@ -111,9 +111,23 @@ import javax.security.auth.x500.X500Principal
  * a chain of certificates. The server uses a set of trusted root certificates to authenticate the
  * client. Subject alternative names are not used for client authentication.
  */
-class HeldCertificate(private val keyPair: KeyPair, private val certificate: X509Certificate) {
+class HeldCertificate(
+  @get:JvmName("keyPair") val keyPair: KeyPair,
+  @get:JvmName("certificate") val certificate: X509Certificate
+) {
+
+  @JvmName("-deprecated_certificate")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "certificate"),
+      level = DeprecationLevel.ERROR)
   fun certificate(): X509Certificate = certificate
 
+  @JvmName("-deprecated_keyPair")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "keyPair"),
+      level = DeprecationLevel.ERROR)
   fun keyPair(): KeyPair = keyPair
 
   /**
@@ -150,7 +164,7 @@ class HeldCertificate(private val keyPair: KeyPair, private val certificate: X50
    * [rfc_7468]: https://tools.ietf.org/html/rfc7468
    */
   fun privateKeyPkcs1Pem(): String {
-    require(keyPair.private is RSAPrivateKey) { "PKCS1 only supports RSA keys" }
+    check(keyPair.private is RSAPrivateKey) { "PKCS1 only supports RSA keys" }
     return buildString {
       append("-----BEGIN RSA PRIVATE KEY-----\n")
       encodeBase64Lines(pkcs1Bytes())
@@ -166,11 +180,11 @@ class HeldCertificate(private val keyPair: KeyPair, private val certificate: X50
   private fun StringBuilder.encodeBase64Lines(data: ByteString) {
     val base64 = data.base64()
     for (i in 0 until base64.length step 64) {
-      append(base64, i, Math.min(i + 64, base64.length)).append('\n')
+      append(base64, i, minOf(i + 64, base64.length)).append('\n')
     }
   }
 
-  /** Build a held certificate with reasonable defaults.  */
+  /** Build a held certificate with reasonable defaults. */
   class Builder {
     private var notBefore = -1L
     private var notAfter = -1L
@@ -357,12 +371,12 @@ class HeldCertificate(private val keyPair: KeyPair, private val certificate: X50
             BasicConstraints(maxIntermediateCas))
       }
 
-      if (!altNames.isEmpty()) {
+      if (altNames.isNotEmpty()) {
         val encodableAltNames = arrayOfNulls<ASN1Encodable>(altNames.size)
         for (i in 0 until altNames.size) {
           val altName = altNames[i]
           val tag = when {
-            verifyAsIpAddress(altName) -> GeneralName.iPAddress
+            altName.canParseAsIpAddress() -> GeneralName.iPAddress
             else -> GeneralName.dNSName
           }
           encodableAltNames[i] = GeneralName(tag, altName)
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.kt b/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.kt
index 32b41832fa..c5bb9d8e00 100644
--- a/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.kt
+++ b/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.kt
@@ -38,15 +38,15 @@ object TlsUtil {
         .build()
     return@lazy HandshakeCertificates.Builder()
         .heldCertificate(heldCertificate)
-        .addTrustedCertificate(heldCertificate.certificate())
+        .addTrustedCertificate(heldCertificate.certificate)
         .build()
   }
 
-  /** Returns an SSL client for this host's localhost address.  */
+  /** Returns an SSL client for this host's localhost address. */
   @JvmStatic
   fun localhost(): HandshakeCertificates = localhost
 
-  /** Returns a trust manager that trusts `trustedCertificates`.  */
+  /** Returns a trust manager that trusts `trustedCertificates`. */
   @JvmStatic
   fun newTrustManager(
     keyStoreType: String?,
@@ -80,9 +80,9 @@ object TlsUtil {
     val keyStore = newEmptyKeyStore(keyStoreType)
     if (heldCertificate != null) {
       val chain = arrayOfNulls<Certificate>(1 + intermediates.size)
-      chain[0] = heldCertificate.certificate()
+      chain[0] = heldCertificate.certificate
       intermediates.copyInto(chain, 1)
-      keyStore.setKeyEntry("private", heldCertificate.keyPair().private, password, chain)
+      keyStore.setKeyEntry("private", heldCertificate.keyPair.private, password, chain)
     }
 
     val factory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/package-info.java b/okhttp-tls/src/main/java/okhttp3/tls/package-info.java
deleted file mode 100644
index 061e524be6..0000000000
--- a/okhttp-tls/src/main/java/okhttp3/tls/package-info.java
+++ /dev/null
@@ -1,3 +0,0 @@
-/** OkHttp Transport Layer Security (TLS) library. */
-@okhttp3.internal.annotations.EverythingIsNonNull
-package okhttp3.tls;
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
index 9a78178437..96b876cb94 100644
--- a/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
+++ b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
@@ -51,7 +51,9 @@
 
   @After public void tearDown() {
     executorService.shutdown();
-    closeQuietly(serverSocket);
+    if (serverSocket != null) {
+      closeQuietly(serverSocket);
+    }
   }
 
   @Test public void clientAndServer() throws Exception {
@@ -162,8 +164,12 @@ private InetSocketAddress startTlsServer() throws IOException {
         sslSocket.startHandshake();
         return Handshake.get(sslSocket.getSession());
       } finally {
-        closeQuietly(rawSocket);
-        closeQuietly(sslSocket);
+        if (rawSocket != null) {
+          closeQuietly(rawSocket);
+        }
+        if (sslSocket != null) {
+          closeQuietly(sslSocket);
+        }
       }
     });
   }
@@ -181,7 +187,9 @@ private InetSocketAddress startTlsServer() throws IOException {
         return Handshake.get(sslSocket.getSession());
       } finally {
         closeQuietly(rawSocket);
-        closeQuietly(sslSocket);
+        if (sslSocket != null) {
+          closeQuietly(sslSocket);
+        }
       }
     });
   }
diff --git a/okhttp-urlconnection/README.md b/okhttp-urlconnection/README.md
new file mode 100644
index 0000000000..fffe6dbd9c
--- /dev/null
+++ b/okhttp-urlconnection/README.md
@@ -0,0 +1,10 @@
+OkHttp URLConnection
+====================
+
+This module integrates OkHttp with `Authenticator` and `CookieHandler` from `java.net`.
+
+### Download
+
+```kotlin
+testImplementation("com.squareup.okhttp3:okhttp-urlconnection:4.1.1")
+```
diff --git a/okhttp-urlconnection/build.gradle b/okhttp-urlconnection/build.gradle
index 4b997f5710..8a197bdcd3 100644
--- a/okhttp-urlconnection/build.gradle
+++ b/okhttp-urlconnection/build.gradle
@@ -19,6 +19,13 @@ dependencies {
   testImplementation deps.assertj
 }
 
+afterEvaluate { project ->
+  project.tasks.dokka {
+    outputDirectory = "$rootDir/docs/4.x"
+    outputFormat = 'gfm'
+  }
+}
+
 task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
   oldClasspath = files(baselineJar(project, baselineVersion))
   newClasspath = files(jar.archivePath)
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.kt b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.kt
index c0bc871051..edeba08462 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.kt
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.kt
@@ -29,13 +29,13 @@ class JavaNetAuthenticator : okhttp3.Authenticator {
   @Throws(IOException::class)
   override fun authenticate(route: Route?, response: Response): Request? {
     val challenges = response.challenges()
-    val request = response.request()
-    val url = request.url()
-    val proxyAuthorization = response.code() == 407
-    val proxy = route?.proxy() ?: Proxy.NO_PROXY
+    val request = response.request
+    val url = request.url
+    val proxyAuthorization = response.code == 407
+    val proxy = route?.proxy ?: Proxy.NO_PROXY
 
     for (challenge in challenges) {
-      if (!"Basic".equals(challenge.scheme(), ignoreCase = true)) {
+      if (!"Basic".equals(challenge.scheme, ignoreCase = true)) {
         continue
       }
 
@@ -45,21 +45,21 @@ class JavaNetAuthenticator : okhttp3.Authenticator {
             proxyAddress.hostName,
             proxy.connectToInetAddress(url),
             proxyAddress.port,
-            url.scheme(),
-            challenge.realm(),
-            challenge.scheme(),
-            url.url(),
+            url.scheme,
+            challenge.realm,
+            challenge.scheme,
+            url.toUrl(),
             Authenticator.RequestorType.PROXY
         )
       } else {
         Authenticator.requestPasswordAuthentication(
-            url.host(),
+            url.host,
             proxy.connectToInetAddress(url),
-            url.port(),
-            url.scheme(),
-            challenge.realm(),
-            challenge.scheme(),
-            url.url(),
+            url.port,
+            url.scheme,
+            challenge.realm,
+            challenge.scheme,
+            url.toUrl(),
             Authenticator.RequestorType.SERVER
         )
       }
@@ -67,7 +67,7 @@ class JavaNetAuthenticator : okhttp3.Authenticator {
       if (auth != null) {
         val credentialHeader = if (proxyAuthorization) "Proxy-Authorization" else "Authorization"
         val credential = Credentials.basic(
-            auth.userName, String(auth.password), challenge.charset())
+            auth.userName, String(auth.password), challenge.charset)
         return request.newBuilder()
             .header(credentialHeader, credential)
             .build()
@@ -80,8 +80,8 @@ class JavaNetAuthenticator : okhttp3.Authenticator {
   @Throws(IOException::class)
   private fun Proxy.connectToInetAddress(url: HttpUrl): InetAddress {
     return when {
-      type() == Proxy.Type.DIRECT -> InetAddress.getByName(url.host())
+      type() == Proxy.Type.DIRECT -> InetAddress.getByName(url.host)
       else -> (address() as InetSocketAddress).address
     }
   }
-}
\ No newline at end of file
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
index dbed55acba..0b3f7afa85 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
@@ -15,18 +15,17 @@
  */
 package okhttp3
 
-import okhttp3.internal.Util.delimiterOffset
-import okhttp3.internal.Util.trimSubstring
 import okhttp3.internal.cookieToString
+import okhttp3.internal.delimiterOffset
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.platform.Platform.Companion.WARN
+import okhttp3.internal.trimSubstring
 import java.io.IOException
 import java.net.CookieHandler
 import java.net.HttpCookie
-import java.util.ArrayList
 import java.util.Collections
 
-/** A cookie jar that delegates to a [java.net.CookieHandler].  */
+/** A cookie jar that delegates to a [java.net.CookieHandler]. */
 class JavaNetCookieJar(private val cookieHandler: CookieHandler) : CookieJar {
 
   override fun saveFromResponse(url: HttpUrl, cookies: List<Cookie>) {
@@ -36,7 +35,7 @@ class JavaNetCookieJar(private val cookieHandler: CookieHandler) : CookieJar {
     }
     val multimap = mapOf("Set-Cookie" to cookieStrings)
     try {
-      cookieHandler.put(url.uri(), multimap)
+      cookieHandler.put(url.toUri(), multimap)
     } catch (e: IOException) {
       Platform.get().log(WARN, "Saving cookies failed for " + url.resolve("/...")!!, e)
     }
@@ -45,7 +44,7 @@ class JavaNetCookieJar(private val cookieHandler: CookieHandler) : CookieJar {
   override fun loadForRequest(url: HttpUrl): List<Cookie> {
     val cookieHeaders = try {
       // The RI passes all headers. We don't have 'em, so we don't pass 'em!
-      cookieHandler.get(url.uri(), emptyMap<String, List<String>>())
+      cookieHandler.get(url.toUri(), emptyMap<String, List<String>>())
     } catch (e: IOException) {
       Platform.get().log(WARN, "Loading cookies failed for " + url.resolve("/...")!!, e)
       return emptyList()
@@ -56,7 +55,7 @@ class JavaNetCookieJar(private val cookieHandler: CookieHandler) : CookieJar {
       if (("Cookie".equals(key, ignoreCase = true) || "Cookie2".equals(key, ignoreCase = true)) &&
           value.isNotEmpty()) {
         for (header in value) {
-          if (cookies == null) cookies = ArrayList()
+          if (cookies == null) cookies = mutableListOf()
           cookies.addAll(decodeHeaderAsJavaNetCookies(url, header))
         }
       }
@@ -79,9 +78,9 @@ class JavaNetCookieJar(private val cookieHandler: CookieHandler) : CookieJar {
     val limit = header.length
     var pairEnd: Int
     while (pos < limit) {
-      pairEnd = delimiterOffset(header, pos, limit, ";,")
-      val equalsSign = delimiterOffset(header, pos, pairEnd, '=')
-      val name = trimSubstring(header, pos, equalsSign)
+      pairEnd = header.delimiterOffset(";,", pos, limit)
+      val equalsSign = header.delimiterOffset('=', pos, pairEnd)
+      val name = header.trimSubstring(pos, equalsSign)
       if (name.startsWith("$")) {
         pos = pairEnd + 1
         continue
@@ -89,7 +88,7 @@ class JavaNetCookieJar(private val cookieHandler: CookieHandler) : CookieJar {
 
       // We have either name=value or just a name.
       var value = if (equalsSign < pairEnd) {
-        trimSubstring(header, equalsSign + 1, pairEnd)
+        header.trimSubstring(equalsSign + 1, pairEnd)
       } else {
         ""
       }
@@ -102,7 +101,7 @@ class JavaNetCookieJar(private val cookieHandler: CookieHandler) : CookieJar {
       result.add(Cookie.Builder()
           .name(name)
           .value(value)
-          .domain(url.host())
+          .domain(url.host)
           .build())
       pos = pairEnd + 1
     }
diff --git a/okhttp/build.gradle b/okhttp/build.gradle
index 10172a0841..087ca5b6f8 100644
--- a/okhttp/build.gradle
+++ b/okhttp/build.gradle
@@ -26,11 +26,11 @@ dependencies {
   api deps.okio
   api deps.kotlinStdlib
   compileOnly deps.conscrypt
+  compileOnly deps.openjsse
   compileOnly deps.android
   compileOnly deps.jsr305
   compileOnly deps.animalSniffer
 
-  testImplementation deps.okio
   testImplementation project(':okhttp-testing-support')
   testImplementation project(':okhttp-tls')
   testImplementation project(':okhttp-urlconnection')
@@ -39,9 +39,17 @@ dependencies {
   testImplementation deps.conscrypt
   testImplementation deps.junit
   testImplementation deps.assertj
+  testImplementation deps.openjsse
   testCompileOnly deps.jsr305
 }
 
+afterEvaluate { project ->
+  project.tasks.dokka {
+    outputDirectory = "$rootDir/docs/4.x"
+    outputFormat = 'gfm'
+  }
+}
+
 task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
   oldClasspath = files(baselineJar(project, baselineVersion))
   newClasspath = files(jar.archivePath)
@@ -56,6 +64,7 @@ task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
   classExcludes = [
       // Package-private in 3.x, internal in 4.0.0:
       'okhttp3.Cache$CacheResponseBody$1',
+      'okhttp3.RealCall$AsyncCall',
   ]
   methodExcludes = [
       // Became 'final' in 4.0.0:
@@ -354,6 +363,33 @@ task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
       'okhttp3.Route#requiresTunnel()',
       'okhttp3.Route#socketAddress()',
       'okhttp3.TlsVersion#javaName()',
+      // Real API change! Became 'final' despite a non-final enclosing class in 4.0.0:
+      'okhttp3.OkHttpClient#authenticator()',
+      'okhttp3.OkHttpClient#cache()',
+      'okhttp3.OkHttpClient#callTimeoutMillis()',
+      'okhttp3.OkHttpClient#certificatePinner()',
+      'okhttp3.OkHttpClient#connectionPool()',
+      'okhttp3.OkHttpClient#connectionSpecs()',
+      'okhttp3.OkHttpClient#connectTimeoutMillis()',
+      'okhttp3.OkHttpClient#cookieJar()',
+      'okhttp3.OkHttpClient#dispatcher()',
+      'okhttp3.OkHttpClient#dns()',
+      'okhttp3.OkHttpClient#eventListenerFactory()',
+      'okhttp3.OkHttpClient#followRedirects()',
+      'okhttp3.OkHttpClient#followSslRedirects()',
+      'okhttp3.OkHttpClient#hostnameVerifier()',
+      'okhttp3.OkHttpClient#interceptors()',
+      'okhttp3.OkHttpClient#networkInterceptors()',
+      'okhttp3.OkHttpClient#pingIntervalMillis()',
+      'okhttp3.OkHttpClient#protocols()',
+      'okhttp3.OkHttpClient#proxy()',
+      'okhttp3.OkHttpClient#proxyAuthenticator()',
+      'okhttp3.OkHttpClient#proxySelector()',
+      'okhttp3.OkHttpClient#readTimeoutMillis()',
+      'okhttp3.OkHttpClient#retryOnConnectionFailure()',
+      'okhttp3.OkHttpClient#socketFactory()',
+      'okhttp3.OkHttpClient#sslSocketFactory()',
+      'okhttp3.OkHttpClient#writeTimeoutMillis()',
   ]
 }
 check.dependsOn(japicmp)
diff --git a/okhttp/src/main/java/okhttp3/Address.kt b/okhttp/src/main/java/okhttp3/Address.kt
index 8d24789752..e09d129e8a 100644
--- a/okhttp/src/main/java/okhttp3/Address.kt
+++ b/okhttp/src/main/java/okhttp3/Address.kt
@@ -15,13 +15,13 @@
  */
 package okhttp3
 
+import okhttp3.internal.toImmutableList
 import java.net.Proxy
 import java.net.ProxySelector
 import java.util.Objects
 import javax.net.SocketFactory
 import javax.net.ssl.HostnameVerifier
 import javax.net.ssl.SSLSocketFactory
-import okhttp3.internal.Util
 
 /**
  * A specification for a connection to an origin server. For simple connections, this is the
@@ -29,23 +29,49 @@ import okhttp3.internal.Util
  * this also includes that proxy information. For secure connections the address also includes the SSL socket factory,
  * hostname verifier, and certificate pinner.
  *
- * HTTP requests that share the same `Address` may also share the same [Connection].
+ * HTTP requests that share the same [Address] may also share the same [Connection].
  */
 class Address(
   uriHost: String,
   uriPort: Int,
-  private val dns: Dns,
-  private val socketFactory: SocketFactory,
-  private val sslSocketFactory: SSLSocketFactory?,
-  private val hostnameVerifier: HostnameVerifier?,
-  private val certificatePinner: CertificatePinner?,
-  private val proxyAuthenticator: Authenticator,
-  private val proxy: Proxy?,
+  /** Returns the service that will be used to resolve IP addresses for hostnames. */
+  @get:JvmName("dns") val dns: Dns,
+
+  /** Returns the socket factory for new connections. */
+  @get:JvmName("socketFactory") val socketFactory: SocketFactory,
+
+  /** Returns the SSL socket factory, or null if this is not an HTTPS address. */
+  @get:JvmName("sslSocketFactory") val sslSocketFactory: SSLSocketFactory?,
+
+  /** Returns the hostname verifier, or null if this is not an HTTPS address. */
+  @get:JvmName("hostnameVerifier") val hostnameVerifier: HostnameVerifier?,
+
+  /** Returns this address's certificate pinner, or null if this is not an HTTPS address. */
+  @get:JvmName("certificatePinner") val certificatePinner: CertificatePinner?,
+
+  /** Returns the client's proxy authenticator. */
+  @get:JvmName("proxyAuthenticator") val proxyAuthenticator: Authenticator,
+
+  /**
+   * Returns this address's explicitly-specified HTTP proxy, or null to delegate to the {@linkplain
+   * #proxySelector proxy selector}.
+   */
+  @get:JvmName("proxy") val proxy: Proxy?,
+
   protocols: List<Protocol>,
   connectionSpecs: List<ConnectionSpec>,
-  private val proxySelector: ProxySelector
+
+  /**
+   * Returns this address's proxy selector. Only used if the proxy is null. If none of this
+   * selector's proxies are reachable, a direct connection will be attempted.
+   */
+  @get:JvmName("proxySelector") val proxySelector: ProxySelector
 ) {
-  private val url: HttpUrl = HttpUrl.Builder()
+  /**
+   * Returns a URL with the hostname and port of the origin server. The path, query, and fragment of
+   * this URL are always empty, since they are not significant for planning a route.
+   */
+  @get:JvmName("url") val url: HttpUrl = HttpUrl.Builder()
       .scheme(if (sslSocketFactory != null) "https" else "http")
       .host(uriHost)
       .port(uriPort)
@@ -55,52 +81,86 @@ class Address(
    * The protocols the client supports. This method always returns a non-null list that
    * contains minimally [Protocol.HTTP_1_1].
    */
-  private val protocols: List<Protocol> = Util.immutableList(protocols)
+  @get:JvmName("protocols") val protocols: List<Protocol> = protocols.toImmutableList()
 
-  private val connectionSpecs: List<ConnectionSpec> = Util.immutableList(connectionSpecs)
+  @get:JvmName("connectionSpecs") val connectionSpecs: List<ConnectionSpec> =
+      connectionSpecs.toImmutableList()
 
-  /**
-   * Returns a URL with the hostname and port of the origin server. The path, query, and fragment of
-   * this URL are always empty, since they are not significant for planning a route.
-   */
+  @JvmName("-deprecated_url")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "url"),
+      level = DeprecationLevel.ERROR)
   fun url() = url
 
-  /** Returns the service that will be used to resolve IP addresses for hostnames. */
+  @JvmName("-deprecated_dns")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "dns"),
+      level = DeprecationLevel.ERROR)
   fun dns() = dns
 
-  /** Returns the socket factory for new connections. */
+  @JvmName("-deprecated_socketFactory")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "socketFactory"),
+      level = DeprecationLevel.ERROR)
   fun socketFactory() = socketFactory
 
-  /** Returns the client's proxy authenticator. */
+  @JvmName("-deprecated_proxyAuthenticator")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "proxyAuthenticator"),
+      level = DeprecationLevel.ERROR)
   fun proxyAuthenticator() = proxyAuthenticator
 
-  /**
-   * Returns the protocols the client supports. This method always returns a non-null list that
-   * contains minimally {@link Protocol#HTTP_1_1}.
-   */
+  @JvmName("-deprecated_protocols")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "protocols"),
+      level = DeprecationLevel.ERROR)
   fun protocols() = protocols
 
+  @JvmName("-deprecated_connectionSpecs")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "connectionSpecs"),
+      level = DeprecationLevel.ERROR)
   fun connectionSpecs() = connectionSpecs
 
-  /**
-   * Returns this address's proxy selector. Only used if the proxy is null. If none of this
-   * selector's proxies are reachable, a direct connection will be attempted.
-   */
+  @JvmName("-deprecated_proxySelector")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "proxySelector"),
+      level = DeprecationLevel.ERROR)
   fun proxySelector() = proxySelector
 
-  /**
-   * Returns this address's explicitly-specified HTTP proxy, or null to delegate to the {@linkplain
-   * #proxySelector proxy selector}.
-   */
+  @JvmName("-deprecated_proxy")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "proxy"),
+      level = DeprecationLevel.ERROR)
   fun proxy() = proxy
 
-  /** Returns the SSL socket factory, or null if this is not an HTTPS address. */
+  @JvmName("-deprecated_sslSocketFactory")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "sslSocketFactory"),
+      level = DeprecationLevel.ERROR)
   fun sslSocketFactory() = sslSocketFactory
 
-  /** Returns the hostname verifier, or null if this is not an HTTPS address. */
+  @JvmName("-deprecated_hostnameVerifier")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "hostnameVerifier"),
+      level = DeprecationLevel.ERROR)
   fun hostnameVerifier() = hostnameVerifier
 
-  /** Returns this address's certificate pinner, or null if this is not an HTTPS address. */
+  @JvmName("-deprecated_certificatePinner")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "certificatePinner"),
+      level = DeprecationLevel.ERROR)
   fun certificatePinner() = certificatePinner
 
   override fun equals(other: Any?): Boolean {
@@ -134,12 +194,12 @@ class Address(
         this.sslSocketFactory == that.sslSocketFactory &&
         this.hostnameVerifier == that.hostnameVerifier &&
         this.certificatePinner == that.certificatePinner &&
-        this.url().port() == that.url().port()
+        this.url.port == that.url.port
   }
 
   override fun toString(): String {
     return "Address{" +
-        "${url.host()}:${url.port()}, " +
+        "${url.host}:${url.port}, " +
         (if (proxy != null) "proxy=$proxy" else "proxySelector=$proxySelector") +
         "}"
   }
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.kt b/okhttp/src/main/java/okhttp3/Authenticator.kt
index 31031f3879..e33d11820f 100644
--- a/okhttp/src/main/java/okhttp3/Authenticator.kt
+++ b/okhttp/src/main/java/okhttp3/Authenticator.kt
@@ -26,7 +26,7 @@ import java.io.IOException
  *
  * To make HTTPS calls using an HTTP proxy server OkHttp must first negotiate a connection with
  * the proxy. This proxy connection is called a "TLS Tunnel" and is specified by
- * [RFC 2817][rfc_2817]. The HTTP CONNECT request that creates this tunnel connection is special: it
+ * [RFC 2817][1]. The HTTP CONNECT request that creates this tunnel connection is special: it
  * does not participate in any [interceptors][Interceptor] or [event listeners][EventListener]. It
  * doesn't include the motivating request's HTTP headers or even its full URL; only the target
  * server's hostname is sent to the proxy.
@@ -93,12 +93,12 @@ import java.io.IOException
  * Applications may configure OkHttp with an authenticator for origin servers, or proxy servers,
  * or both.
  *
- * [rfc_2817]: https://tools.ietf.org/html/rfc2817
+ * [1]: https://tools.ietf.org/html/rfc2817
  */
 interface Authenticator {
   /**
    * Returns a request that includes a credential to satisfy an authentication challenge in
-   * `response`. Returns null if the challenge cannot be satisfied.
+   * [response]. Returns null if the challenge cannot be satisfied.
    *
    * The route is best effort, it currently may not always be provided even when logically
    * available. It may also not be provided when an authenticator is re-used manually in an
@@ -108,18 +108,10 @@ interface Authenticator {
   fun authenticate(route: Route?, response: Response): Request?
 
   companion object {
-    /** An authenticator that knows no credentials and makes no attempt to authenticate.  */
+    /** An authenticator that knows no credentials and makes no attempt to authenticate. */
     @JvmField
     val NONE = object : Authenticator {
       override fun authenticate(route: Route?, response: Response): Request? = null
     }
-
-    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
-    @JvmName("-deprecated_Authenticator")
-    inline operator fun invoke(
-      crossinline block: (route: Route?, response: Response) -> Request?
-    ): Authenticator = object : Authenticator {
-      override fun authenticate(route: Route?, response: Response) = block(route, response)
-    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Cache.kt b/okhttp/src/main/java/okhttp3/Cache.kt
index ba8ff45340..b84bb141e1 100644
--- a/okhttp/src/main/java/okhttp3/Cache.kt
+++ b/okhttp/src/main/java/okhttp3/Cache.kt
@@ -15,17 +15,17 @@
  */
 package okhttp3
 
-import okhttp3.internal.Util.closeQuietly
-import okhttp3.internal.addHeaderLenient
+import okhttp3.MediaType.Companion.toMediaTypeOrNull
+import okhttp3.internal.EMPTY_HEADERS
 import okhttp3.internal.cache.CacheRequest
 import okhttp3.internal.cache.CacheStrategy
 import okhttp3.internal.cache.DiskLruCache
-import okhttp3.internal.cache.InternalCache
-import okhttp3.internal.http.HttpHeaders
+import okhttp3.internal.closeQuietly
 import okhttp3.internal.http.HttpMethod
 import okhttp3.internal.http.StatusLine
 import okhttp3.internal.io.FileSystem
 import okhttp3.internal.platform.Platform
+import okhttp3.internal.toLongOrDefault
 import okio.Buffer
 import okio.BufferedSink
 import okio.BufferedSource
@@ -45,8 +45,8 @@ import java.security.cert.Certificate
 import java.security.cert.CertificateEncodingException
 import java.security.cert.CertificateException
 import java.security.cert.CertificateFactory
-import java.util.ArrayList
 import java.util.NoSuchElementException
+import java.util.TreeSet
 
 /**
  * Caches HTTP and HTTPS responses to the filesystem so they may be reused, saving time and
@@ -142,68 +142,40 @@ class Cache internal constructor(
   maxSize: Long,
   fileSystem: FileSystem
 ) : Closeable, Flushable {
-  internal val internalCache: InternalCache = object : InternalCache {
-    override fun get(request: Request): Response? {
-      return this@Cache.get(request)
-    }
-
-    override fun put(response: Response): CacheRequest? {
-      return this@Cache.put(response)
-    }
-
-    override fun remove(request: Request) {
-      this@Cache.remove(request)
-    }
-
-    override fun update(cached: Response, network: Response) {
-      this@Cache.update(cached, network)
-    }
-
-    override fun trackConditionalCacheHit() {
-      this@Cache.trackConditionalCacheHit()
-    }
-
-    override fun trackResponse(cacheStrategy: CacheStrategy) {
-      this@Cache.trackResponse(cacheStrategy)
-    }
-  }
-
-  internal val cache: DiskLruCache
+  internal val cache: DiskLruCache =
+      DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize)
 
   // read and write statistics, all guarded by 'this'.
-  internal var writeSuccessCount: Int = 0
-  internal var writeAbortCount: Int = 0
-  private var networkCount: Int = 0
-  private var hitCount: Int = 0
-  private var requestCount: Int = 0
+  internal var writeSuccessCount = 0
+  internal var writeAbortCount = 0
+  private var networkCount = 0
+  private var hitCount = 0
+  private var requestCount = 0
 
-  val isClosed: Boolean get() = cache.isClosed()
+  val isClosed: Boolean
+    get() = cache.isClosed()
 
-  /** Create a cache of at most `maxSize` bytes in `directory`. */
+  /** Create a cache of at most [maxSize] bytes in [directory]. */
   constructor(directory: File, maxSize: Long) : this(directory, maxSize, FileSystem.SYSTEM)
 
-  init {
-    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize)
-  }
-
   internal fun get(request: Request): Response? {
-    val key = key(request.url())
+    val key = key(request.url)
     val snapshot: DiskLruCache.Snapshot = try {
-      cache.get(key) ?: return null
-    } catch (e: IOException) {
+      cache[key] ?: return null
+    } catch (_: IOException) {
       return null // Give up because the cache cannot be read.
     }
 
     val entry: Entry = try {
       Entry(snapshot.getSource(ENTRY_METADATA))
-    } catch (e: IOException) {
-      closeQuietly(snapshot)
+    } catch (_: IOException) {
+      snapshot.closeQuietly()
       return null
     }
 
     val response = entry.response(snapshot)
     if (!entry.matches(request, response)) {
-      closeQuietly(response.body())
+      response.body?.closeQuietly()
       return null
     }
 
@@ -211,12 +183,12 @@ class Cache internal constructor(
   }
 
   internal fun put(response: Response): CacheRequest? {
-    val requestMethod = response.request().method()
+    val requestMethod = response.request.method
 
-    if (HttpMethod.invalidatesCache(response.request().method())) {
+    if (HttpMethod.invalidatesCache(response.request.method)) {
       try {
-        remove(response.request())
-      } catch (ignored: IOException) {
+        remove(response.request)
+      } catch (_: IOException) {
         // The cache cannot be written.
       }
       return null
@@ -228,17 +200,17 @@ class Cache internal constructor(
       return null
     }
 
-    if (HttpHeaders.hasVaryAll(response)) {
+    if (response.hasVaryAll()) {
       return null
     }
 
     val entry = Entry(response)
     var editor: DiskLruCache.Editor? = null
     try {
-      editor = cache.edit(key(response.request().url())) ?: return null
+      editor = cache.edit(key(response.request.url)) ?: return null
       entry.writeTo(editor)
       return RealCacheRequest(editor)
-    } catch (e: IOException) {
+    } catch (_: IOException) {
       abortQuietly(editor)
       return null
     }
@@ -246,12 +218,12 @@ class Cache internal constructor(
 
   @Throws(IOException::class)
   internal fun remove(request: Request) {
-    cache.remove(key(request.url()))
+    cache.remove(key(request.url))
   }
 
   internal fun update(cached: Response, network: Response) {
     val entry = Entry(network)
-    val snapshot = (cached.body() as CacheResponseBody).snapshot
+    val snapshot = (cached.body as CacheResponseBody).snapshot
     var editor: DiskLruCache.Editor? = null
     try {
       editor = snapshot.edit() // Returns null if snapshot is not current.
@@ -259,7 +231,7 @@ class Cache internal constructor(
         entry.writeTo(editor)
         editor.commit()
       }
-    } catch (e: IOException) {
+    } catch (_: IOException) {
       abortQuietly(editor)
     }
   }
@@ -268,7 +240,7 @@ class Cache internal constructor(
     // Give up because the cache cannot be written.
     try {
       editor?.abort()
-    } catch (ignored: IOException) {
+    } catch (_: IOException) {
     }
   }
 
@@ -333,7 +305,7 @@ class Cache internal constructor(
               nextUrl = metadata.readUtf8LineStrict()
               return true
             }
-          } catch (ignored: IOException) {
+          } catch (_: IOException) {
             // We couldn't read the metadata for this snapshot; possibly because the host filesystem
             // has disappeared! Skip it.
           }
@@ -351,7 +323,7 @@ class Cache internal constructor(
       }
 
       override fun remove() {
-        if (!canRemove) throw IllegalStateException("remove() before next()")
+        check(canRemove) { "remove() before next()" }
         delegate.remove()
       }
     }
@@ -364,7 +336,7 @@ class Cache internal constructor(
   @Throws(IOException::class)
   fun size(): Long = cache.size()
 
-  /** Max size of the cache (in bytes).  */
+  /** Max size of the cache (in bytes). */
   fun maxSize(): Long = cache.maxSize
 
   @Throws(IOException::class)
@@ -377,6 +349,14 @@ class Cache internal constructor(
     cache.close()
   }
 
+  @get:JvmName("directory") val directory: File
+    get() = cache.directory
+
+  @JvmName("-deprecated_directory")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "directory"),
+      level = DeprecationLevel.ERROR)
   fun directory(): File = cache.directory
 
   @Synchronized internal fun trackResponse(cacheStrategy: CacheStrategy) {
@@ -429,10 +409,10 @@ class Cache internal constructor(
         done = true
         writeAbortCount++
       }
-      closeQuietly(cacheOut)
+      cacheOut.closeQuietly()
       try {
         editor.abort()
-      } catch (ignored: IOException) {
+      } catch (_: IOException) {
       }
     }
 
@@ -513,7 +493,7 @@ class Cache internal constructor(
         val varyHeadersBuilder = Headers.Builder()
         val varyRequestHeaderLineCount = readInt(source)
         for (i in 0 until varyRequestHeaderLineCount) {
-          addHeaderLenient(varyHeadersBuilder, source.readUtf8LineStrict())
+          varyHeadersBuilder.addLenient(source.readUtf8LineStrict())
         }
         varyHeaders = varyHeadersBuilder.build()
 
@@ -524,7 +504,7 @@ class Cache internal constructor(
         val responseHeadersBuilder = Headers.Builder()
         val responseHeaderLineCount = readInt(source)
         for (i in 0 until responseHeaderLineCount) {
-          addHeaderLenient(responseHeadersBuilder, source.readUtf8LineStrict())
+          responseHeadersBuilder.addLenient(source.readUtf8LineStrict())
         }
         val sendRequestMillisString = responseHeadersBuilder[SENT_MILLIS]
         val receivedResponseMillisString = responseHeadersBuilder[RECEIVED_MILLIS]
@@ -558,16 +538,16 @@ class Cache internal constructor(
     }
 
     internal constructor(response: Response) {
-      this.url = response.request().url().toString()
-      this.varyHeaders = HttpHeaders.varyHeaders(response)
-      this.requestMethod = response.request().method()
-      this.protocol = response.protocol()
-      this.code = response.code()
-      this.message = response.message()
-      this.responseHeaders = response.headers()
-      this.handshake = response.handshake()
-      this.sentRequestMillis = response.sentRequestAtMillis()
-      this.receivedResponseMillis = response.receivedResponseAtMillis()
+      this.url = response.request.url.toString()
+      this.varyHeaders = response.varyHeaders()
+      this.requestMethod = response.request.method
+      this.protocol = response.protocol
+      this.code = response.code
+      this.message = response.message
+      this.responseHeaders = response.headers
+      this.handshake = response.handshake
+      this.sentRequestMillis = response.sentRequestAtMillis
+      this.receivedResponseMillis = response.receivedResponseAtMillis
     }
 
     @Throws(IOException::class)
@@ -575,8 +555,8 @@ class Cache internal constructor(
       val sink = editor.newSink(ENTRY_METADATA).buffer()
       sink.writeUtf8(url).writeByte('\n'.toInt())
       sink.writeUtf8(requestMethod).writeByte('\n'.toInt())
-      sink.writeDecimalLong(varyHeaders.size().toLong()).writeByte('\n'.toInt())
-      for (i in 0 until varyHeaders.size()) {
+      sink.writeDecimalLong(varyHeaders.size.toLong()).writeByte('\n'.toInt())
+      for (i in 0 until varyHeaders.size) {
         sink.writeUtf8(varyHeaders.name(i))
             .writeUtf8(": ")
             .writeUtf8(varyHeaders.value(i))
@@ -584,8 +564,8 @@ class Cache internal constructor(
       }
 
       sink.writeUtf8(StatusLine(protocol, code, message).toString()).writeByte('\n'.toInt())
-      sink.writeDecimalLong((responseHeaders.size() + 2).toLong()).writeByte('\n'.toInt())
-      for (i in 0 until responseHeaders.size()) {
+      sink.writeDecimalLong((responseHeaders.size + 2).toLong()).writeByte('\n'.toInt())
+      for (i in 0 until responseHeaders.size) {
         sink.writeUtf8(responseHeaders.name(i))
             .writeUtf8(": ")
             .writeUtf8(responseHeaders.value(i))
@@ -602,10 +582,10 @@ class Cache internal constructor(
 
       if (isHttps) {
         sink.writeByte('\n'.toInt())
-        sink.writeUtf8(handshake!!.cipherSuite().javaName()).writeByte('\n'.toInt())
-        writeCertList(sink, handshake.peerCertificates())
-        writeCertList(sink, handshake.localCertificates())
-        sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte('\n'.toInt())
+        sink.writeUtf8(handshake!!.cipherSuite.javaName).writeByte('\n'.toInt())
+        writeCertList(sink, handshake.peerCertificates)
+        writeCertList(sink, handshake.localCertificates)
+        sink.writeUtf8(handshake.tlsVersion.javaName).writeByte('\n'.toInt())
       }
       sink.close()
     }
@@ -645,9 +625,9 @@ class Cache internal constructor(
     }
 
     fun matches(request: Request, response: Response): Boolean {
-      return url == request.url().toString() &&
-          requestMethod == request.method() &&
-          HttpHeaders.varyMatches(response, varyHeaders, request)
+      return url == request.url.toString() &&
+          requestMethod == request.method &&
+          varyMatches(response, varyHeaders, request)
     }
 
     fun response(snapshot: DiskLruCache.Snapshot): Response {
@@ -672,10 +652,10 @@ class Cache internal constructor(
     }
 
     companion object {
-      /** Synthetic response header: the local time when the request was sent.  */
+      /** Synthetic response header: the local time when the request was sent. */
       private val SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis"
 
-      /** Synthetic response header: the local time when the response was received.  */
+      /** Synthetic response header: the local time when the response was received. */
       private val RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis"
     }
   }
@@ -698,17 +678,9 @@ class Cache internal constructor(
       }.buffer()
     }
 
-    override fun contentType(): MediaType? {
-      return if (contentType != null) MediaType.parse(contentType) else null
-    }
+    override fun contentType(): MediaType? = contentType?.toMediaTypeOrNull()
 
-    override fun contentLength(): Long {
-      return try {
-        contentLength?.toLong() ?: -1
-      } catch (e: NumberFormatException) {
-        -1L
-      }
-    }
+    override fun contentLength(): Long = contentLength?.toLongOrDefault(-1L) ?: -1L
 
     override fun source(): BufferedSource = bodySource
   }
@@ -723,12 +695,11 @@ class Cache internal constructor(
     fun key(url: HttpUrl): String = url.toString().encodeUtf8().md5().hex()
 
     @Throws(IOException::class)
-    @JvmStatic
     internal fun readInt(source: BufferedSource): Int {
       try {
         val result = source.readDecimalLong()
         val line = source.readUtf8LineStrict()
-        if (result < 0 || result > Integer.MAX_VALUE || line.isNotEmpty()) {
+        if (result < 0L || result > Integer.MAX_VALUE || line.isNotEmpty()) {
           throw IOException("expected an int but was \"$result$line\"")
         }
         return result.toInt()
@@ -736,5 +707,72 @@ class Cache internal constructor(
         throw IOException(e.message)
       }
     }
+
+    /**
+     * Returns true if none of the Vary headers have changed between [cachedRequest] and
+     * [newRequest].
+     */
+    fun varyMatches(
+      cachedResponse: Response,
+      cachedRequest: Headers,
+      newRequest: Request
+    ): Boolean {
+      return cachedResponse.headers.varyFields().none {
+        cachedRequest.values(it) != newRequest.headers(it)
+      }
+    }
+
+    /** Returns true if a Vary header contains an asterisk. Such responses cannot be cached. */
+    fun Response.hasVaryAll() = "*" in headers.varyFields()
+
+    /**
+     * Returns the names of the request headers that need to be checked for equality when caching.
+     */
+    private fun Headers.varyFields(): Set<String> {
+      var result: MutableSet<String>? = null
+      for (i in 0 until size) {
+        if (!"Vary".equals(name(i), ignoreCase = true)) {
+          continue
+        }
+
+        val value = value(i)
+        if (result == null) {
+          result = TreeSet(String.CASE_INSENSITIVE_ORDER)
+        }
+        for (varyField in value.split(',')) {
+          result.add(varyField.trim())
+        }
+      }
+      return result ?: emptySet()
+    }
+
+    /**
+     * Returns the subset of the headers in this's request that impact the content of this's body.
+     */
+    fun Response.varyHeaders(): Headers {
+      // Use the request headers sent over the network, since that's what the response varies on.
+      // Otherwise OkHttp-supplied headers like "Accept-Encoding: gzip" may be lost.
+      val requestHeaders = networkResponse!!.request.headers
+      val responseHeaders = headers
+      return varyHeaders(requestHeaders, responseHeaders)
+    }
+
+    /**
+     * Returns the subset of the headers in [requestHeaders] that impact the content of the
+     * response's body.
+     */
+    private fun varyHeaders(requestHeaders: Headers, responseHeaders: Headers): Headers {
+      val varyFields = responseHeaders.varyFields()
+      if (varyFields.isEmpty()) return EMPTY_HEADERS
+
+      val result = Headers.Builder()
+      for (i in 0 until requestHeaders.size) {
+        val fieldName = requestHeaders.name(i)
+        if (fieldName in varyFields) {
+          result.add(fieldName, requestHeaders.value(i))
+        }
+      }
+      return result.build()
+    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/CacheControl.kt b/okhttp/src/main/java/okhttp3/CacheControl.kt
index cb13511a98..d9e887c578 100644
--- a/okhttp/src/main/java/okhttp3/CacheControl.kt
+++ b/okhttp/src/main/java/okhttp3/CacheControl.kt
@@ -15,7 +15,8 @@
  */
 package okhttp3
 
-import okhttp3.internal.http.HttpHeaders
+import okhttp3.internal.indexOfNonWhitespace
+import okhttp3.internal.toNonNegativeInt
 import java.util.concurrent.TimeUnit
 
 /**
@@ -25,20 +26,6 @@ import java.util.concurrent.TimeUnit
  * See [RFC 7234, 5.2](https://tools.ietf.org/html/rfc7234#section-5.2).
  */
 class CacheControl private constructor(
-  private val noCache: Boolean,
-  private val noStore: Boolean,
-  private val maxAgeSeconds: Int,
-  private val sMaxAgeSeconds: Int,
-  val isPrivate: Boolean,
-  val isPublic: Boolean,
-  private val mustRevalidate: Boolean,
-  private val maxStaleSeconds: Int,
-  private val minFreshSeconds: Int,
-  private val onlyIfCached: Boolean,
-  private val noTransform: Boolean,
-  private val immutable: Boolean,
-  private var headerValue: String?
-) {
   /**
    * In a response, this field's name "no-cache" is misleading. It doesn't prevent us from caching
    * the response; it only means we have to validate the response with the origin server before
@@ -46,25 +33,28 @@ class CacheControl private constructor(
    *
    * In a request, it means do not use a cache to satisfy the request.
    */
-  fun noCache() = noCache
+  @get:JvmName("noCache") val noCache: Boolean,
 
-  /** If true, this response should not be cached.  */
-  fun noStore() = noStore
+  /** If true, this response should not be cached. */
+  @get:JvmName("noStore") val noStore: Boolean,
 
   /** The duration past the response's served date that it can be served without validation. */
-  fun maxAgeSeconds() = maxAgeSeconds
+  @get:JvmName("maxAgeSeconds") val maxAgeSeconds: Int,
 
   /**
    * The "s-maxage" directive is the max age for shared caches. Not to be confused with "max-age"
    * for non-shared caches, As in Firefox and Chrome, this directive is not honored by this cache.
    */
-  fun sMaxAgeSeconds() = sMaxAgeSeconds
+  @get:JvmName("sMaxAgeSeconds") val sMaxAgeSeconds: Int,
 
-  fun mustRevalidate() = mustRevalidate
+  val isPrivate: Boolean,
+  val isPublic: Boolean,
 
-  fun maxStaleSeconds() = maxStaleSeconds
+  @get:JvmName("mustRevalidate") val mustRevalidate: Boolean,
 
-  fun minFreshSeconds() = minFreshSeconds
+  @get:JvmName("maxStaleSeconds") val maxStaleSeconds: Int,
+
+  @get:JvmName("minFreshSeconds") val minFreshSeconds: Int,
 
   /**
    * This field's name "only-if-cached" is misleading. It actually means "do not use the network".
@@ -72,10 +62,82 @@ class CacheControl private constructor(
    * cache. Cached responses that would require validation (ie. conditional gets) are not permitted
    * if this header is set.
    */
+  @get:JvmName("onlyIfCached") val onlyIfCached: Boolean,
+
+  @get:JvmName("noTransform") val noTransform: Boolean,
+
+  @get:JvmName("immutable") val immutable: Boolean,
+
+  private var headerValue: String?
+) {
+  @JvmName("-deprecated_noCache")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "noCache"),
+      level = DeprecationLevel.ERROR)
+  fun noCache() = noCache
+
+  @JvmName("-deprecated_noStore")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "noStore"),
+      level = DeprecationLevel.ERROR)
+  fun noStore() = noStore
+
+  @JvmName("-deprecated_maxAgeSeconds")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "maxAgeSeconds"),
+      level = DeprecationLevel.ERROR)
+  fun maxAgeSeconds() = maxAgeSeconds
+
+  @JvmName("-deprecated_sMaxAgeSeconds")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "sMaxAgeSeconds"),
+      level = DeprecationLevel.ERROR)
+  fun sMaxAgeSeconds() = sMaxAgeSeconds
+
+  @JvmName("-deprecated_mustRevalidate")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "mustRevalidate"),
+      level = DeprecationLevel.ERROR)
+  fun mustRevalidate() = mustRevalidate
+
+  @JvmName("-deprecated_maxStaleSeconds")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "maxStaleSeconds"),
+      level = DeprecationLevel.ERROR)
+  fun maxStaleSeconds() = maxStaleSeconds
+
+  @JvmName("-deprecated_minFreshSeconds")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "minFreshSeconds"),
+      level = DeprecationLevel.ERROR)
+  fun minFreshSeconds() = minFreshSeconds
+
+  @JvmName("-deprecated_onlyIfCached")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "onlyIfCached"),
+      level = DeprecationLevel.ERROR)
   fun onlyIfCached() = onlyIfCached
 
+  @JvmName("-deprecated_noTransform")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "noTransform"),
+      level = DeprecationLevel.ERROR)
   fun noTransform() = noTransform
 
+  @JvmName("-deprecated_immutable")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "immutable"),
+      level = DeprecationLevel.ERROR)
   fun immutable() = immutable
 
   override fun toString(): String {
@@ -102,7 +164,7 @@ class CacheControl private constructor(
     return result
   }
 
-  /** Builds a `Cache-Control` request header.  */
+  /** Builds a `Cache-Control` request header. */
   class Builder {
     private var noCache: Boolean = false
     private var noStore: Boolean = false
@@ -113,25 +175,25 @@ class CacheControl private constructor(
     private var noTransform: Boolean = false
     private var immutable: Boolean = false
 
-    /** Don't accept an unvalidated cached response.  */
+    /** Don't accept an unvalidated cached response. */
     fun noCache() = apply {
       this.noCache = true
     }
 
-    /** Don't store the server's response in any cache.  */
+    /** Don't store the server's response in any cache. */
     fun noStore() = apply {
       this.noStore = true
     }
 
     /**
-     * Sets the maximum age of a cached response. If the cache response's age exceeds `maxAge`, it
+     * Sets the maximum age of a cached response. If the cache response's age exceeds [maxAge], it
      * will not be used and a network request will be made.
      *
      * @param maxAge a non-negative integer. This is stored and transmitted with [TimeUnit.SECONDS]
      *     precision; finer precision will be lost.
      */
     fun maxAge(maxAge: Int, timeUnit: TimeUnit) = apply {
-      if (maxAge < 0) throw IllegalArgumentException("maxAge < 0: $maxAge")
+      require(maxAge >= 0) { "maxAge < 0: $maxAge" }
       val maxAgeSecondsLong = timeUnit.toSeconds(maxAge.toLong())
       this.maxAgeSeconds = maxAgeSecondsLong.clampToInt()
     }
@@ -144,21 +206,21 @@ class CacheControl private constructor(
      *     [TimeUnit.SECONDS] precision; finer precision will be lost.
      */
     fun maxStale(maxStale: Int, timeUnit: TimeUnit) = apply {
-      if (maxStale < 0) throw IllegalArgumentException("maxStale < 0: $maxStale")
+      require(maxStale >= 0) { "maxStale < 0: $maxStale" }
       val maxStaleSecondsLong = timeUnit.toSeconds(maxStale.toLong())
       this.maxStaleSeconds = maxStaleSecondsLong.clampToInt()
     }
 
     /**
      * Sets the minimum number of seconds that a response will continue to be fresh for. If the
-     * response will be stale when `minFresh` have elapsed, the cached response will not be used and
+     * response will be stale when [minFresh] have elapsed, the cached response will not be used and
      * a network request will be made.
      *
      * @param minFresh a non-negative integer. This is stored and transmitted with
      *     [TimeUnit.SECONDS] precision; finer precision will be lost.
      */
     fun minFresh(minFresh: Int, timeUnit: TimeUnit) = apply {
-      if (minFresh < 0) throw IllegalArgumentException("minFresh < 0: $minFresh")
+      require(minFresh >= 0) { "minFresh < 0: $minFresh" }
       val minFreshSecondsLong = timeUnit.toSeconds(minFresh.toLong())
       this.minFreshSeconds = minFreshSecondsLong.clampToInt()
     }
@@ -171,7 +233,7 @@ class CacheControl private constructor(
       this.onlyIfCached = true
     }
 
-    /** Don't accept a transformed response.  */
+    /** Don't accept a transformed response. */
     fun noTransform() = apply {
       this.noTransform = true
     }
@@ -215,7 +277,7 @@ class CacheControl private constructor(
         .build()
 
     /**
-     * Returns the cache directives of `headers`. This honors both Cache-Control and Pragma headers
+     * Returns the cache directives of [headers]. This honors both Cache-Control and Pragma headers
      * if they are present.
      */
     @JvmStatic
@@ -236,7 +298,7 @@ class CacheControl private constructor(
       var canUseHeaderValue = true
       var headerValue: String? = null
 
-      loop@ for (i in 0 until headers.size()) {
+      loop@ for (i in 0 until headers.size) {
         val name = headers.name(i)
         val value = headers.value(i)
 
@@ -261,8 +323,8 @@ class CacheControl private constructor(
         var pos = 0
         while (pos < value.length) {
           val tokenStart = pos
-          pos = HttpHeaders.skipUntil(value, pos, "=,;")
-          val directive = value.substring(tokenStart, pos).trim { it <= ' ' }
+          pos = value.indexOfElement("=,;", pos)
+          val directive = value.substring(tokenStart, pos).trim()
           val parameter: String?
 
           if (pos == value.length || value[pos] == ',' || value[pos] == ';') {
@@ -270,20 +332,20 @@ class CacheControl private constructor(
             parameter = null
           } else {
             pos++ // Consume '='.
-            pos = HttpHeaders.skipWhitespace(value, pos)
+            pos = value.indexOfNonWhitespace(pos)
 
             if (pos < value.length && value[pos] == '\"') {
               // Quoted string.
               pos++ // Consume '"' open quote.
               val parameterStart = pos
-              pos = HttpHeaders.skipUntil(value, pos, "\"")
+              pos = value.indexOf('"', pos)
               parameter = value.substring(parameterStart, pos)
               pos++ // Consume '"' close quote (if necessary).
             } else {
               // Unquoted string.
               val parameterStart = pos
-              pos = HttpHeaders.skipUntil(value, pos, ",;")
-              parameter = value.substring(parameterStart, pos).trim { it <= ' ' }
+              pos = value.indexOfElement(",;", pos)
+              parameter = value.substring(parameterStart, pos).trim()
             }
           }
 
@@ -295,10 +357,10 @@ class CacheControl private constructor(
               noStore = true
             }
             "max-age".equals(directive, ignoreCase = true) -> {
-              maxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1)
+              maxAgeSeconds = parameter.toNonNegativeInt(-1)
             }
             "s-maxage".equals(directive, ignoreCase = true) -> {
-              sMaxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1)
+              sMaxAgeSeconds = parameter.toNonNegativeInt(-1)
             }
             "private".equals(directive, ignoreCase = true) -> {
               isPrivate = true
@@ -310,10 +372,10 @@ class CacheControl private constructor(
               mustRevalidate = true
             }
             "max-stale".equals(directive, ignoreCase = true) -> {
-              maxStaleSeconds = HttpHeaders.parseSeconds(parameter, Integer.MAX_VALUE)
+              maxStaleSeconds = parameter.toNonNegativeInt(Integer.MAX_VALUE)
             }
             "min-fresh".equals(directive, ignoreCase = true) -> {
-              minFreshSeconds = HttpHeaders.parseSeconds(parameter, -1)
+              minFreshSeconds = parameter.toNonNegativeInt(-1)
             }
             "only-if-cached".equals(directive, ignoreCase = true) -> {
               onlyIfCached = true
@@ -336,5 +398,18 @@ class CacheControl private constructor(
           mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, immutable,
           headerValue)
     }
+
+    /**
+     * Returns the next index in this at or after [startIndex] that is a character from
+     * [characters]. Returns the input length if none of the requested characters can be found.
+     */
+    private fun String.indexOfElement(characters: String, startIndex: Int = 0): Int {
+      for (i in startIndex until length) {
+        if (this[i] in characters) {
+          return i
+        }
+      }
+      return length
+    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Call.kt b/okhttp/src/main/java/okhttp3/Call.kt
index cc36ccef9b..4ea40e96d4 100644
--- a/okhttp/src/main/java/okhttp3/Call.kt
+++ b/okhttp/src/main/java/okhttp3/Call.kt
@@ -23,7 +23,7 @@ import java.io.IOException
  * represents a single request/response pair (stream), it cannot be executed twice.
  */
 interface Call : Cloneable {
-  /** Returns the original request that initiated this call.  */
+  /** Returns the original request that initiated this call. */
   fun request(): Request
 
   /**
@@ -67,7 +67,7 @@ interface Call : Cloneable {
    */
   fun enqueue(responseCallback: Callback)
 
-  /** Cancels the request, if possible. Requests that are already complete cannot be canceled.  */
+  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
   fun cancel()
 
   /**
@@ -91,7 +91,7 @@ interface Call : Cloneable {
    * Create a new, identical call to this one which can be enqueued or executed even if this call
    * has already been.
    */
-  override fun clone(): Call
+  public override fun clone(): Call
 
   interface Factory {
     fun newCall(request: Request): Call
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.kt b/okhttp/src/main/java/okhttp3/CertificatePinner.kt
index 69f2fa95ed..29e3f9ddaf 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.kt
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.kt
@@ -15,6 +15,7 @@
  */
 package okhttp3
 
+import okhttp3.HttpUrl.Companion.toHttpUrl
 import okhttp3.internal.tls.CertificateChainCleaner
 import okio.ByteString
 import okio.ByteString.Companion.decodeBase64
@@ -122,7 +123,8 @@ import javax.net.ssl.SSLPeerUnverifiedException
  * [rfc_7469]: http://tools.ietf.org/html/rfc7469
  * [static_certificates]: http://goo.gl/XDh6je
  */
-data class CertificatePinner internal constructor(
+@Suppress("NAME_SHADOWING")
+class CertificatePinner internal constructor(
   private val pins: Set<Pin>,
   private val certificateChainCleaner: CertificateChainCleaner?
 ) {
@@ -154,11 +156,11 @@ data class CertificatePinner internal constructor(
       for (pin in pins) {
         when (pin.hashAlgorithm) {
           "sha256/" -> {
-            if (sha256 == null) sha256 = sha256(x509Certificate)
+            if (sha256 == null) sha256 = x509Certificate.toSha256ByteString()
             if (pin.hash == sha256) return // Success!
           }
           "sha1/" -> {
-            if (sha1 == null) sha1 = sha1(x509Certificate)
+            if (sha1 == null) sha1 = x509Certificate.toSha1ByteString()
             if (pin.hash == sha1) return // Success!
           }
           else -> throw AssertionError("unsupported hashAlgorithm: ${pin.hashAlgorithm}")
@@ -212,7 +214,7 @@ data class CertificatePinner internal constructor(
     return result
   }
 
-  /** Returns a certificate pinner that uses `certificateChainCleaner`.  */
+  /** Returns a certificate pinner that uses `certificateChainCleaner`. */
   internal fun withCertificateChainCleaner(
     certificateChainCleaner: CertificateChainCleaner?
   ): CertificatePinner {
@@ -223,22 +225,34 @@ data class CertificatePinner internal constructor(
     }
   }
 
+  override fun equals(other: Any?): Boolean {
+    return other is CertificatePinner &&
+        other.pins == pins &&
+        other.certificateChainCleaner == certificateChainCleaner
+  }
+
+  override fun hashCode(): Int {
+    var result = 37
+    result = 41 * result + pins.hashCode()
+    result = 41 * result + certificateChainCleaner.hashCode()
+    return result
+  }
+
   internal data class Pin(
-    /** A hostname like `example.com` or a pattern like `*.example.com`.  */
+    /** A hostname like `example.com` or a pattern like `*.example.com`. */
     val pattern: String,
-    /** The canonical hostname, i.e. `EXAMPLE.com` becomes `example.com`.  */
+    /** The canonical hostname, i.e. `EXAMPLE.com` becomes `example.com`. */
     private val canonicalHostname: String,
-    /** Either `sha1/` or `sha256/`.  */
+    /** Either `sha1/` or `sha256/`. */
     val hashAlgorithm: String,
-    /** The hash of the pinned certificate using [hashAlgorithm].  */
+    /** The hash of the pinned certificate using [hashAlgorithm]. */
     val hash: ByteString
   ) {
     fun matches(hostname: String): Boolean {
       if (pattern.startsWith(WILDCARD)) {
         val firstDot = hostname.indexOf('.')
         return hostname.length - firstDot - 1 == canonicalHostname.length &&
-            hostname.regionMatches(firstDot + 1, canonicalHostname, 0, canonicalHostname.length,
-            ignoreCase = false)
+            hostname.startsWith(canonicalHostname, startIndex = firstDot + 1)
       }
       return hostname == canonicalHostname
     }
@@ -246,7 +260,7 @@ data class CertificatePinner internal constructor(
     override fun toString(): String = hashAlgorithm + hash.base64()
   }
 
-  /** Builds a configured certificate pinner.  */
+  /** Builds a configured certificate pinner. */
   class Builder {
     private val pins = mutableListOf<Pin>()
 
@@ -281,22 +295,22 @@ data class CertificatePinner internal constructor(
     @JvmStatic
     fun pin(certificate: Certificate): String {
       require(certificate is X509Certificate) { "Certificate pinning requires X509 certificates" }
-      return "sha256/${sha256(certificate).base64()}"
+      return "sha256/${certificate.toSha256ByteString().base64()}"
     }
 
-    internal fun sha1(x509Certificate: X509Certificate): ByteString =
-        x509Certificate.publicKey.encoded.toByteString().sha1()
+    internal fun X509Certificate.toSha1ByteString(): ByteString =
+        publicKey.encoded.toByteString().sha1()
 
-    internal fun sha256(x509Certificate: X509Certificate): ByteString =
-        x509Certificate.publicKey.encoded.toByteString().sha256()
+    internal fun X509Certificate.toSha256ByteString(): ByteString =
+        publicKey.encoded.toByteString().sha256()
 
     internal fun newPin(pattern: String, pin: String): Pin {
       val canonicalHostname = when {
         pattern.startsWith(WILDCARD) -> {
-          HttpUrl.get("http://${pattern.substring(WILDCARD.length)}").host()
+          "http://${pattern.substring(WILDCARD.length)}".toHttpUrl().host
         }
         else -> {
-          HttpUrl.get("http://$pattern").host()
+          "http://$pattern".toHttpUrl().host
         }
       }
 
diff --git a/okhttp/src/main/java/okhttp3/Challenge.kt b/okhttp/src/main/java/okhttp3/Challenge.kt
index c69b7950df..38e5bcc1e2 100644
--- a/okhttp/src/main/java/okhttp3/Challenge.kt
+++ b/okhttp/src/main/java/okhttp3/Challenge.kt
@@ -21,12 +21,41 @@ import java.util.Collections.singletonMap
 import java.util.Collections.unmodifiableMap
 import java.util.Locale.US
 
-/** An RFC 7235 challenge. */
+/**
+ * An [RFC 7235][rfc_7235] challenge.
+ *
+ * [rfc_7235]: https://tools.ietf.org/html/rfc7235
+ */
 class Challenge(
-  private val scheme: String,
+  /** Returns the authentication scheme, like `Basic`. */
+  @get:JvmName("scheme") val scheme: String,
+
   authParams: Map<String?, String>
 ) {
-  private val authParams: Map<String?, String>
+  /**
+   * Returns the auth params, including [realm] and [charset] if present, but as
+   * strings. The map's keys are lowercase and should be treated case-insensitively.
+   */
+  @get:JvmName("authParams") val authParams: Map<String?, String>
+
+  /** Returns the protection space. */
+  @get:JvmName("realm") val realm: String?
+    get() = authParams["realm"]
+
+  /** The charset that should be used to encode the credentials. */
+  @get:JvmName("charset") val charset: Charset
+    get() {
+      val charset = authParams["charset"]
+      if (charset != null) {
+        try {
+          return Charset.forName(charset)
+        } catch (ignore: Exception) {
+        }
+      }
+      return ISO_8859_1
+    }
+
+  constructor(scheme: String, realm: String) : this(scheme, singletonMap("realm", realm))
 
   init {
     val newAuthParams = mutableMapOf<String?, String>()
@@ -37,8 +66,6 @@ class Challenge(
     this.authParams = unmodifiableMap<String?, String>(newAuthParams)
   }
 
-  constructor(scheme: String, realm: String) : this(scheme, singletonMap("realm", realm))
-
   /** Returns a copy of this charset that expects a credential encoded with [charset]. */
   fun withCharset(charset: Charset): Challenge {
     val authParams = this.authParams.toMutableMap()
@@ -46,29 +73,33 @@ class Challenge(
     return Challenge(scheme, authParams)
   }
 
-  /** Returns the authentication scheme, like `Basic`. */
+  @JvmName("-deprecated_scheme")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "scheme"),
+      level = DeprecationLevel.ERROR)
   fun scheme() = scheme
 
-  /**
-   * Returns the auth params, including [realm] and [charset] if present, but as
-   * strings. The map's keys are lowercase and should be treated case-insensitively.
-   */
+  @JvmName("-deprecated_authParams")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "authParams"),
+      level = DeprecationLevel.ERROR)
   fun authParams() = authParams
 
-  /** Returns the protection space. */
-  fun realm(): String? = authParams["realm"]
+  @JvmName("-deprecated_realm")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "realm"),
+      level = DeprecationLevel.ERROR)
+  fun realm(): String? = realm
 
-  /** Returns the charset that should be used to encode the credentials. */
-  fun charset(): Charset {
-    val charset = authParams["charset"]
-    if (charset != null) {
-      try {
-        return Charset.forName(charset)
-      } catch (ignore: Exception) {
-      }
-    }
-    return ISO_8859_1
-  }
+  @JvmName("-deprecated_charset")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "charset"),
+      level = DeprecationLevel.ERROR)
+  fun charset(): Charset = charset
 
   override fun equals(other: Any?): Boolean {
     return other is Challenge &&
@@ -83,7 +114,5 @@ class Challenge(
     return result
   }
 
-  override fun toString(): String {
-    return "$scheme authParams=$authParams"
-  }
+  override fun toString() = "$scheme authParams=$authParams"
 }
\ No newline at end of file
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.kt b/okhttp/src/main/java/okhttp3/CipherSuite.kt
index 877bbfd733..734047d933 100644
--- a/okhttp/src/main/java/okhttp3/CipherSuite.kt
+++ b/okhttp/src/main/java/okhttp3/CipherSuite.kt
@@ -36,14 +36,19 @@ package okhttp3
  * [conscrypt_providers]: https://github.com/google/conscrypt/blob/master/common/src/main/java/org/conscrypt/NativeCrypto.java
  */
 class CipherSuite private constructor(
-  private val javaName: String
-) {
   /**
    * Returns the Java name of this cipher suite. For some older cipher suites the Java name has the
    * prefix `SSL_`, causing the Java name to be different from the instance name which is always
    * prefixed `TLS_`. For example, `TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName()` is
    * `"SSL_RSA_EXPORT_WITH_RC4_40_MD5"`.
    */
+  @get:JvmName("javaName") val javaName: String
+) {
+  @JvmName("-deprecated_javaName")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "javaName"),
+      level = DeprecationLevel.ERROR)
   fun javaName(): String = javaName
 
   override fun toString(): String = javaName
@@ -57,7 +62,7 @@ class CipherSuite private constructor(
     internal val ORDER_BY_NAME = object : Comparator<String> {
       override fun compare(a: String, b: String): Int {
         var i = 4
-        val limit = Math.min(a.length, b.length)
+        val limit = minOf(a.length, b.length)
         while (i < limit) {
           val charA = a[i]
           val charB = b[i]
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.kt b/okhttp/src/main/java/okhttp3/ConnectionPool.kt
index 0a85d80849..3bdc491397 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.kt
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.kt
@@ -34,19 +34,17 @@ class ConnectionPool(
   keepAliveDuration: Long,
   timeUnit: TimeUnit
 ) {
-  // TODO(kotlin): remove @JvmField once OkHttpClient is in Kotlin
-  @JvmField internal val delegate =
-      RealConnectionPool(maxIdleConnections, keepAliveDuration, timeUnit)
+  internal val delegate = RealConnectionPool(maxIdleConnections, keepAliveDuration, timeUnit)
 
   constructor() : this(5, 5, TimeUnit.MINUTES)
 
-  /** Returns the number of idle connections in the pool.  */
+  /** Returns the number of idle connections in the pool. */
   fun idleConnectionCount(): Int = delegate.idleConnectionCount()
 
-  /** Returns total number of connections in the pool.  */
+  /** Returns total number of connections in the pool. */
   fun connectionCount(): Int = delegate.connectionCount()
 
-  /** Close and remove all idle connections in the pool.  */
+  /** Close and remove all idle connections in the pool. */
   fun evictAll() {
     delegate.evictAll()
   }
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.kt b/okhttp/src/main/java/okhttp3/ConnectionSpec.kt
index 1f8e4816a7..7804b0d98d 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.kt
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.kt
@@ -16,11 +16,10 @@
 package okhttp3
 
 import okhttp3.ConnectionSpec.Builder
-import okhttp3.internal.Util
-import okhttp3.internal.Util.concat
-import okhttp3.internal.Util.indexOf
-import okhttp3.internal.Util.intersect
-import okhttp3.internal.Util.nonEmptyIntersection
+import okhttp3.internal.concat
+import okhttp3.internal.hasIntersection
+import okhttp3.internal.indexOf
+import okhttp3.internal.intersect
 import java.util.Arrays
 import java.util.Objects
 import javax.net.ssl.SSLSocket
@@ -44,51 +43,77 @@ import javax.net.ssl.SSLSocket
  *
  * [tls_history]: https://github.com/square/okhttp/wiki/TLS-Configuration-History
  */
-class ConnectionSpec internal constructor(builder: Builder) {
-  val isTls: Boolean = builder.tls
-  internal val supportsTlsExtensions: Boolean = builder.supportsTlsExtensions
-  internal val cipherSuites: Array<String>? = builder.cipherSuites
-  internal val tlsVersions: Array<String>? = builder.tlsVersions
+class ConnectionSpec internal constructor(
+  @get:JvmName("isTls") val isTls: Boolean,
+  @get:JvmName("supportsTlsExtensions") val supportsTlsExtensions: Boolean,
+  private val cipherSuitesAsString: Array<String>?,
+  private val tlsVersionsAsString: Array<String>?
+) {
 
   /**
    * Returns the cipher suites to use for a connection. Returns null if all of the SSL socket's
    * enabled cipher suites should be used.
    */
-  fun cipherSuites(): List<CipherSuite>? = cipherSuites?.map(CipherSuite.Companion::forJavaName)
+  @get:JvmName("cipherSuites") val cipherSuites: List<CipherSuite>?
+    get() {
+      return cipherSuitesAsString?.map { CipherSuite.forJavaName(it) }?.toList()
+    }
+
+  @JvmName("-deprecated_cipherSuites")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "cipherSuites"),
+      level = DeprecationLevel.ERROR)
+  fun cipherSuites(): List<CipherSuite>? = cipherSuites
 
   /**
    * Returns the TLS versions to use when negotiating a connection. Returns null if all of the SSL
    * socket's enabled TLS versions should be used.
    */
-  fun tlsVersions(): List<TlsVersion>? = tlsVersions?.map(TlsVersion.Companion::forJavaName)
+  @get:JvmName("tlsVersions") val tlsVersions: List<TlsVersion>?
+    get() {
+      return tlsVersionsAsString?.map { TlsVersion.forJavaName(it) }?.toList()
+    }
 
+  @JvmName("-deprecated_tlsVersions")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "tlsVersions"),
+      level = DeprecationLevel.ERROR)
+  fun tlsVersions(): List<TlsVersion>? = tlsVersions
+
+  @JvmName("-deprecated_supportsTlsExtensions")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "supportsTlsExtensions"),
+      level = DeprecationLevel.ERROR)
   fun supportsTlsExtensions(): Boolean = supportsTlsExtensions
 
-  /** Applies this spec to `sslSocket`.  */
+  /** Applies this spec to [sslSocket]. */
   internal fun apply(sslSocket: SSLSocket, isFallback: Boolean) {
     val specToApply = supportedSpec(sslSocket, isFallback)
 
     if (specToApply.tlsVersions != null) {
-      sslSocket.enabledProtocols = specToApply.tlsVersions
+      sslSocket.enabledProtocols = specToApply.tlsVersionsAsString
     }
 
     if (specToApply.cipherSuites != null) {
-      sslSocket.enabledCipherSuites = specToApply.cipherSuites
+      sslSocket.enabledCipherSuites = specToApply.cipherSuitesAsString
     }
   }
 
   /**
-   * Returns a copy of this that omits cipher suites and TLS versions not enabled by `sslSocket`.
+   * Returns a copy of this that omits cipher suites and TLS versions not enabled by [sslSocket].
    */
   private fun supportedSpec(sslSocket: SSLSocket, isFallback: Boolean): ConnectionSpec {
-    var cipherSuitesIntersection = if (cipherSuites != null) {
-      intersect(CipherSuite.ORDER_BY_NAME, sslSocket.enabledCipherSuites, cipherSuites)
+    var cipherSuitesIntersection = if (cipherSuitesAsString != null) {
+      sslSocket.enabledCipherSuites.intersect(cipherSuitesAsString, CipherSuite.ORDER_BY_NAME)
     } else {
       sslSocket.enabledCipherSuites
     }
 
-    val tlsVersionsIntersection = if (tlsVersions != null) {
-      intersect(Util.NATURAL_ORDER, sslSocket.enabledProtocols, tlsVersions)
+    val tlsVersionsIntersection = if (tlsVersionsAsString != null) {
+      sslSocket.enabledProtocols.intersect(tlsVersionsAsString, naturalOrder())
     } else {
       sslSocket.enabledProtocols
     }
@@ -96,11 +121,11 @@ class ConnectionSpec internal constructor(builder: Builder) {
     // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00 the SCSV
     // cipher is added to signal that a protocol fallback has taken place.
     val supportedCipherSuites = sslSocket.supportedCipherSuites
-    val indexOfFallbackScsv = indexOf(
-        CipherSuite.ORDER_BY_NAME, supportedCipherSuites, "TLS_FALLBACK_SCSV")
+    val indexOfFallbackScsv = supportedCipherSuites.indexOf(
+        "TLS_FALLBACK_SCSV", CipherSuite.ORDER_BY_NAME)
     if (isFallback && indexOfFallbackScsv != -1) {
-      cipherSuitesIntersection = concat(
-          cipherSuitesIntersection, supportedCipherSuites[indexOfFallbackScsv])
+      cipherSuitesIntersection = cipherSuitesIntersection.concat(
+          supportedCipherSuites[indexOfFallbackScsv])
     }
 
     return Builder(this)
@@ -125,14 +150,14 @@ class ConnectionSpec internal constructor(builder: Builder) {
       return false
     }
 
-    if (tlsVersions != null &&
-        !nonEmptyIntersection(Util.NATURAL_ORDER, tlsVersions, socket.enabledProtocols)) {
+    if (tlsVersionsAsString != null &&
+        !tlsVersionsAsString.hasIntersection(socket.enabledProtocols, naturalOrder())) {
       return false
     }
 
-    if (cipherSuites != null &&
-        !nonEmptyIntersection(
-            CipherSuite.ORDER_BY_NAME, cipherSuites, socket.enabledCipherSuites)) {
+    if (cipherSuitesAsString != null &&
+        !cipherSuitesAsString.hasIntersection(
+            socket.enabledCipherSuites, CipherSuite.ORDER_BY_NAME)) {
       return false
     }
 
@@ -143,13 +168,12 @@ class ConnectionSpec internal constructor(builder: Builder) {
     if (other !is ConnectionSpec) return false
     if (other === this) return true
 
-    val that = other as ConnectionSpec?
-    if (this.isTls != that!!.isTls) return false
+    if (this.isTls != other.isTls) return false
 
     if (isTls) {
-      if (!Arrays.equals(this.cipherSuites, that.cipherSuites)) return false
-      if (!Arrays.equals(this.tlsVersions, that.tlsVersions)) return false
-      if (this.supportsTlsExtensions != that.supportsTlsExtensions) return false
+      if (!Arrays.equals(this.cipherSuitesAsString, other.cipherSuitesAsString)) return false
+      if (!Arrays.equals(this.tlsVersionsAsString, other.tlsVersionsAsString)) return false
+      if (this.supportsTlsExtensions != other.supportsTlsExtensions) return false
     }
 
     return true
@@ -158,8 +182,8 @@ class ConnectionSpec internal constructor(builder: Builder) {
   override fun hashCode(): Int {
     var result = 17
     if (isTls) {
-      result = 31 * result + cipherSuites!!.contentHashCode()
-      result = 31 * result + tlsVersions!!.contentHashCode()
+      result = 31 * result + (cipherSuitesAsString?.contentHashCode() ?: 0)
+      result = 31 * result + (tlsVersionsAsString?.contentHashCode() ?: 0)
       result = 31 * result + if (supportsTlsExtensions) 0 else 1
     }
     return result
@@ -169,8 +193,8 @@ class ConnectionSpec internal constructor(builder: Builder) {
     if (!isTls) return "ConnectionSpec()"
 
     return ("ConnectionSpec(" +
-        "cipherSuites=${Objects.toString(cipherSuites(), "[all enabled]")}, " +
-        "tlsVersions=${Objects.toString(tlsVersions(), "[all enabled]")}, " +
+        "cipherSuites=${Objects.toString(cipherSuites, "[all enabled]")}, " +
+        "tlsVersions=${Objects.toString(tlsVersions, "[all enabled]")}, " +
         "supportsTlsExtensions=$supportsTlsExtensions)")
   }
 
@@ -186,8 +210,8 @@ class ConnectionSpec internal constructor(builder: Builder) {
 
     constructor(connectionSpec: ConnectionSpec) {
       this.tls = connectionSpec.isTls
-      this.cipherSuites = connectionSpec.cipherSuites
-      this.tlsVersions = connectionSpec.tlsVersions
+      this.cipherSuites = connectionSpec.cipherSuitesAsString
+      this.tlsVersions = connectionSpec.tlsVersionsAsString
       this.supportsTlsExtensions = connectionSpec.supportsTlsExtensions
     }
 
@@ -198,7 +222,7 @@ class ConnectionSpec internal constructor(builder: Builder) {
 
     fun cipherSuites(vararg cipherSuites: CipherSuite): Builder = apply {
       require(tls) { "no cipher suites for cleartext connections" }
-      val strings = cipherSuites.map(CipherSuite::javaName).toTypedArray()
+      val strings = cipherSuites.map { it.javaName }.toTypedArray()
       return cipherSuites(*strings)
     }
 
@@ -217,7 +241,7 @@ class ConnectionSpec internal constructor(builder: Builder) {
     fun tlsVersions(vararg tlsVersions: TlsVersion): Builder = apply {
       require(tls) { "no TLS versions for cleartext connections" }
 
-      val strings = tlsVersions.map(TlsVersion::javaName).toTypedArray()
+      val strings = tlsVersions.map { it.javaName }.toTypedArray()
       return tlsVersions(*strings)
     }
 
@@ -236,9 +260,15 @@ class ConnectionSpec internal constructor(builder: Builder) {
       this.supportsTlsExtensions = supportsTlsExtensions
     }
 
-    fun build(): ConnectionSpec = ConnectionSpec(this)
+    fun build(): ConnectionSpec = ConnectionSpec(
+        tls,
+        supportsTlsExtensions,
+        cipherSuites,
+        tlsVersions
+    )
   }
 
+  @Suppress("DEPRECATION")
   companion object {
     // Most secure but generally supported list.
     private val RESTRICTED_CIPHER_SUITES = arrayOf(
@@ -281,7 +311,7 @@ class ConnectionSpec internal constructor(builder: Builder) {
         CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
         CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA)
 
-    /** A secure TLS connection that requires a recent client platform and a recent server.  */
+    /** A secure TLS connection that requires a recent client platform and a recent server. */
     @JvmField
     val RESTRICTED_TLS = Builder(true)
         .cipherSuites(*RESTRICTED_CIPHER_SUITES)
@@ -312,7 +342,7 @@ class ConnectionSpec internal constructor(builder: Builder) {
         .supportsTlsExtensions(true)
         .build()
 
-    /** Unencrypted, unauthenticated connections for `http:` URLs.  */
+    /** Unencrypted, unauthenticated connections for `http:` URLs. */
     @JvmField
     val CLEARTEXT = Builder(false).build()
   }
diff --git a/okhttp/src/main/java/okhttp3/Cookie.kt b/okhttp/src/main/java/okhttp3/Cookie.kt
index 020b64b19e..3a16bb64f9 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.kt
+++ b/okhttp/src/main/java/okhttp3/Cookie.kt
@@ -15,15 +15,16 @@
  */
 package okhttp3
 
-import okhttp3.internal.Util
-import okhttp3.internal.Util.UTC
-import okhttp3.internal.Util.canonicalizeHost
-import okhttp3.internal.Util.delimiterOffset
-import okhttp3.internal.Util.indexOfControlOrNonAscii
-import okhttp3.internal.Util.trimSubstring
-import okhttp3.internal.Util.verifyAsIpAddress
-import okhttp3.internal.http.HttpDate
+import okhttp3.internal.UTC
+import okhttp3.internal.canParseAsIpAddress
+import okhttp3.internal.delimiterOffset
+import okhttp3.internal.http.MAX_DATE
+import okhttp3.internal.http.toHttpDateString
+import okhttp3.internal.indexOfControlOrNonAscii
 import okhttp3.internal.publicsuffix.PublicSuffixDatabase
+import okhttp3.internal.toCanonicalHost
+import okhttp3.internal.trimSubstring
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
 import java.util.Calendar
 import java.util.Collections
 import java.util.Date
@@ -39,25 +40,13 @@ import java.util.regex.Pattern
  *
  * [chromium_extension]: https://code.google.com/p/chromium/issues/detail?id=232693
  */
-data class Cookie private constructor(
-  private val name: String,
-  private val value: String,
-  private val expiresAt: Long,
-  private val domain: String,
-  private val path: String,
-  private val secure: Boolean,
-  private val httpOnly: Boolean,
-  private val persistent: Boolean, // True if 'expires' or 'max-age' is present.
-  private val hostOnly: Boolean // True unless 'domain' is present.
-) {
-  /** Returns a non-empty string with this cookie's name.  */
-  fun name(): String = name
+@Suppress("NAME_SHADOWING")
+class Cookie private constructor(
+  /** Returns a non-empty string with this cookie's name. */
+  @get:JvmName("name") val name: String,
 
-  /** Returns a possibly-empty string with this cookie's value.  */
-  fun value(): String = value
-
-  /** Returns true if this cookie does not expire at the end of the current session.  */
-  fun persistent(): Boolean = persistent
+  /** Returns a possibly-empty string with this cookie's value. */
+  @get:JvmName("value") val value: String,
 
   /**
    * Returns the time that this cookie expires, in the same format as [System.currentTimeMillis].
@@ -68,50 +57,54 @@ data class Cookie private constructor(
    * expired. Webservers may return expired cookies as a mechanism to delete previously set cookies
    * that may or may not themselves be expired.
    */
-  fun expiresAt(): Long = expiresAt
-
-  /**
-   * Returns true if this cookie's domain should be interpreted as a single host name, or false if
-   * it should be interpreted as a pattern. This flag will be false if its `Set-Cookie` header
-   * included a `domain` attribute.
-   *
-   * For example, suppose the cookie's domain is `example.com`. If this flag is true it matches
-   * **only** `example.com`. If this flag is false it matches `example.com` and all subdomains
-   * including `api.example.com`, `www.example.com`, and `beta.api.example.com`.
-   */
-  fun hostOnly(): Boolean = hostOnly
+  @get:JvmName("expiresAt") val expiresAt: Long,
 
   /**
    * Returns the cookie's domain. If [hostOnly] returns true this is the only domain that matches
    * this cookie; otherwise it matches this domain and all subdomains.
    */
-  fun domain(): String = domain
+  @get:JvmName("domain") val domain: String,
 
   /**
    * Returns this cookie's path. This cookie matches URLs prefixed with path segments that match
    * this path's segments. For example, if this path is `/foo` this cookie matches requests to
    * `/foo` and `/foo/bar`, but not `/` or `/football`.
    */
-  fun path(): String = path
+  @get:JvmName("path") val path: String,
+
+  /** Returns true if this cookie should be limited to only HTTPS requests. */
+  @get:JvmName("secure") val secure: Boolean,
 
   /**
    * Returns true if this cookie should be limited to only HTTP APIs. In web browsers this prevents
    * the cookie from being accessible to scripts.
    */
-  fun httpOnly(): Boolean = httpOnly
+  @get:JvmName("httpOnly") val httpOnly: Boolean,
 
-  /** Returns true if this cookie should be limited to only HTTPS requests.  */
-  fun secure(): Boolean = secure
+  /** Returns true if this cookie does not expire at the end of the current session. */
+  @get:JvmName("persistent") val persistent: Boolean, // True if 'expires' or 'max-age' is present.
+
+  /**
+   * Returns true if this cookie's domain should be interpreted as a single host name, or false if
+   * it should be interpreted as a pattern. This flag will be false if its `Set-Cookie` header
+   * included a `domain` attribute.
+   *
+   * For example, suppose the cookie's domain is `example.com`. If this flag is true it matches
+   * **only** `example.com`. If this flag is false it matches `example.com` and all subdomains
+   * including `api.example.com`, `www.example.com`, and `beta.api.example.com`.
+   */
+  @get:JvmName("hostOnly") val hostOnly: Boolean // True unless 'domain' is present.
+) {
 
   /**
-   * Returns true if this cookie should be included on a request to `url`. In addition to this
+   * Returns true if this cookie should be included on a request to [url]. In addition to this
    * check callers should also confirm that this cookie has not expired.
    */
   fun matches(url: HttpUrl): Boolean {
     val domainMatch = if (hostOnly) {
-      url.host() == domain
+      url.host == domain
     } else {
-      domainMatch(url.host(), domain)
+      domainMatch(url.host, domain)
     }
     if (!domainMatch) return false
 
@@ -120,6 +113,140 @@ data class Cookie private constructor(
     return !secure || url.isHttps
   }
 
+  override fun equals(other: Any?): Boolean {
+    return other is Cookie &&
+        other.name == name &&
+        other.value == value &&
+        other.expiresAt == expiresAt &&
+        other.domain == domain &&
+        other.path == path &&
+        other.secure == secure &&
+        other.httpOnly == httpOnly &&
+        other.persistent == persistent &&
+        other.hostOnly == hostOnly
+  }
+
+  @IgnoreJRERequirement // As of AGP 3.4.1, D8 desugars API 24 hashCode methods.
+  override fun hashCode(): Int {
+    var result = 17
+    result = 31 * result + name.hashCode()
+    result = 31 * result + value.hashCode()
+    result = 31 * result + expiresAt.hashCode()
+    result = 31 * result + domain.hashCode()
+    result = 31 * result + path.hashCode()
+    result = 31 * result + secure.hashCode()
+    result = 31 * result + httpOnly.hashCode()
+    result = 31 * result + persistent.hashCode()
+    result = 31 * result + hostOnly.hashCode()
+    return result
+  }
+
+  override fun toString(): String = toString(false)
+
+  @JvmName("-deprecated_name")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "name"),
+      level = DeprecationLevel.ERROR)
+  fun name(): String = name
+
+  @JvmName("-deprecated_value")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "value"),
+      level = DeprecationLevel.ERROR)
+  fun value(): String = value
+
+  @JvmName("-deprecated_persistent")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "persistent"),
+      level = DeprecationLevel.ERROR)
+  fun persistent(): Boolean = persistent
+
+  @JvmName("-deprecated_expiresAt")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "expiresAt"),
+      level = DeprecationLevel.ERROR)
+  fun expiresAt(): Long = expiresAt
+
+  @JvmName("-deprecated_hostOnly")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "hostOnly"),
+      level = DeprecationLevel.ERROR)
+  fun hostOnly(): Boolean = hostOnly
+
+  @JvmName("-deprecated_domain")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "domain"),
+      level = DeprecationLevel.ERROR)
+  fun domain(): String = domain
+
+  @JvmName("-deprecated_path")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "path"),
+      level = DeprecationLevel.ERROR)
+  fun path(): String = path
+
+  @JvmName("-deprecated_httpOnly")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "httpOnly"),
+      level = DeprecationLevel.ERROR)
+  fun httpOnly(): Boolean = httpOnly
+
+  @JvmName("-deprecated_secure")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "secure"),
+      level = DeprecationLevel.ERROR)
+  fun secure(): Boolean = secure
+
+  /**
+   * @param forObsoleteRfc2965 true to include a leading `.` on the domain pattern. This is
+   *     necessary for `example.com` to match `www.example.com` under RFC 2965. This extra dot is
+   *     ignored by more recent specifications.
+   */
+  internal fun toString(forObsoleteRfc2965: Boolean): String {
+    return buildString {
+      append(name)
+      append('=')
+      append(value)
+
+      if (persistent) {
+        if (expiresAt == Long.MIN_VALUE) {
+          append("; max-age=0")
+        } else {
+          append("; expires=").append(Date(expiresAt).toHttpDateString())
+        }
+      }
+
+      if (!hostOnly) {
+        append("; domain=")
+        if (forObsoleteRfc2965) {
+          append(".")
+        }
+        append(domain)
+      }
+
+      append("; path=").append(path)
+
+      if (secure) {
+        append("; secure")
+      }
+
+      if (httpOnly) {
+        append("; httponly")
+      }
+
+      return toString()
+    }
+  }
+
   /**
    * Builds a cookie. The [name], [value], and [domain] values must all be set before calling
    * [build].
@@ -127,46 +254,46 @@ data class Cookie private constructor(
   class Builder {
     private var name: String? = null
     private var value: String? = null
-    private var expiresAt = HttpDate.MAX_DATE
+    private var expiresAt = MAX_DATE
     private var domain: String? = null
     private var path = "/"
-    private var secure: Boolean = false
-    private var httpOnly: Boolean = false
-    private var persistent: Boolean = false
-    private var hostOnly: Boolean = false
+    private var secure = false
+    private var httpOnly = false
+    private var persistent = false
+    private var hostOnly = false
 
     fun name(name: String) = apply {
-      require(name.trim { it <= ' ' } == name) { "name is not trimmed" }
+      require(name.trim() == name) { "name is not trimmed" }
       this.name = name
     }
 
     fun value(value: String) = apply {
-      require(value.trim { it <= ' ' } == value) { "value is not trimmed" }
+      require(value.trim() == value) { "value is not trimmed" }
       this.value = value
     }
 
     fun expiresAt(expiresAt: Long) = apply {
       var expiresAt = expiresAt
-      if (expiresAt <= 0) expiresAt = Long.MIN_VALUE
-      if (expiresAt > HttpDate.MAX_DATE) expiresAt = HttpDate.MAX_DATE
+      if (expiresAt <= 0L) expiresAt = Long.MIN_VALUE
+      if (expiresAt > MAX_DATE) expiresAt = MAX_DATE
       this.expiresAt = expiresAt
       this.persistent = true
     }
 
     /**
-     * Set the domain pattern for this cookie. The cookie will match `domain` and all of its
+     * Set the domain pattern for this cookie. The cookie will match [domain] and all of its
      * subdomains.
      */
     fun domain(domain: String): Builder = domain(domain, false)
 
     /**
-     * Set the host-only domain for this cookie. The cookie will match `domain` but none of
+     * Set the host-only domain for this cookie. The cookie will match [domain] but none of
      * its subdomains.
      */
     fun hostOnlyDomain(domain: String): Builder = domain(domain, true)
 
     private fun domain(domain: String, hostOnly: Boolean) = apply {
-      val canonicalDomain = Util.canonicalizeHost(domain)
+      val canonicalDomain = domain.toCanonicalHost()
           ?: throw IllegalArgumentException("unexpected domain: $domain")
       this.domain = canonicalDomain
       this.hostOnly = hostOnly
@@ -199,49 +326,7 @@ data class Cookie private constructor(
     }
   }
 
-  override fun toString(): String = toString(false)
-
-  /**
-   * @param forObsoleteRfc2965 true to include a leading `.` on the domain pattern. This is
-   *     necessary for `example.com` to match `www.example.com` under RFC 2965. This extra dot is
-   *     ignored by more recent specifications.
-   */
-  internal fun toString(forObsoleteRfc2965: Boolean): String {
-    return buildString {
-      append(name)
-      append('=')
-      append(value)
-
-      if (persistent) {
-        if (expiresAt == Long.MIN_VALUE) {
-          append("; max-age=0")
-        } else {
-          append("; expires=").append(HttpDate.format(Date(expiresAt)))
-        }
-      }
-
-      if (!hostOnly) {
-        append("; domain=")
-        if (forObsoleteRfc2965) {
-          append(".")
-        }
-        append(domain)
-      }
-
-      append("; path=").append(path)
-
-      if (secure) {
-        append("; secure")
-      }
-
-      if (httpOnly) {
-        append("; httponly")
-      }
-
-      return toString()
-    }
-  }
-
+  @Suppress("NAME_SHADOWING")
   companion object {
     private val YEAR_PATTERN = Pattern.compile("(\\d{2,4})[^\\d]*")
     private val MONTH_PATTERN =
@@ -256,11 +341,11 @@ data class Cookie private constructor(
 
       return urlHost.endsWith(domain) &&
           urlHost[urlHost.length - domain.length - 1] == '.' &&
-          !verifyAsIpAddress(urlHost)
+          !urlHost.canParseAsIpAddress()
     }
 
     private fun pathMatch(url: HttpUrl, path: String): Boolean {
-      val urlPath = url.encodedPath()
+      val urlPath = url.encodedPath
 
       if (urlPath == path) {
         return true // As in '/foo' matching '/foo'.
@@ -275,28 +360,26 @@ data class Cookie private constructor(
     }
 
     /**
-     * Attempt to parse a `Set-Cookie` HTTP header value `setCookie` as a cookie. Returns null if
-     * `setCookie` is not a well-formed cookie.
+     * Attempt to parse a `Set-Cookie` HTTP header value [setCookie] as a cookie. Returns null if
+     * [setCookie] is not a well-formed cookie.
      */
     @JvmStatic
     fun parse(url: HttpUrl, setCookie: String): Cookie? =
         parse(System.currentTimeMillis(), url, setCookie)
 
     internal fun parse(currentTimeMillis: Long, url: HttpUrl, setCookie: String): Cookie? {
-      var pos = 0
-      val limit = setCookie.length
-      val cookiePairEnd = delimiterOffset(setCookie, pos, limit, ';')
+      val cookiePairEnd = setCookie.delimiterOffset(';')
 
-      val pairEqualsSign = delimiterOffset(setCookie, pos, cookiePairEnd, '=')
+      val pairEqualsSign = setCookie.delimiterOffset('=', endIndex = cookiePairEnd)
       if (pairEqualsSign == cookiePairEnd) return null
 
-      val cookieName = trimSubstring(setCookie, pos, pairEqualsSign)
-      if (cookieName.isEmpty() || indexOfControlOrNonAscii(cookieName) != -1) return null
+      val cookieName = setCookie.trimSubstring(endIndex = pairEqualsSign)
+      if (cookieName.isEmpty() || cookieName.indexOfControlOrNonAscii() != -1) return null
 
-      val cookieValue = trimSubstring(setCookie, pairEqualsSign + 1, cookiePairEnd)
-      if (indexOfControlOrNonAscii(cookieValue) != -1) return null
+      val cookieValue = setCookie.trimSubstring(pairEqualsSign + 1, cookiePairEnd)
+      if (cookieValue.indexOfControlOrNonAscii() != -1) return null
 
-      var expiresAt = HttpDate.MAX_DATE
+      var expiresAt = MAX_DATE
       var deltaSeconds = -1L
       var domain: String? = null
       var path: String? = null
@@ -305,14 +388,15 @@ data class Cookie private constructor(
       var hostOnly = true
       var persistent = false
 
-      pos = cookiePairEnd + 1
+      var pos = cookiePairEnd + 1
+      val limit = setCookie.length
       while (pos < limit) {
-        val attributePairEnd = delimiterOffset(setCookie, pos, limit, ';')
+        val attributePairEnd = setCookie.delimiterOffset(';', pos, limit)
 
-        val attributeEqualsSign = delimiterOffset(setCookie, pos, attributePairEnd, '=')
-        val attributeName = trimSubstring(setCookie, pos, attributeEqualsSign)
+        val attributeEqualsSign = setCookie.delimiterOffset('=', pos, attributePairEnd)
+        val attributeName = setCookie.trimSubstring(pos, attributeEqualsSign)
         val attributeValue = if (attributeEqualsSign < attributePairEnd) {
-          trimSubstring(setCookie, attributeEqualsSign + 1, attributePairEnd)
+          setCookie.trimSubstring(attributeEqualsSign + 1, attributePairEnd)
         } else {
           ""
         }
@@ -322,7 +406,7 @@ data class Cookie private constructor(
             try {
               expiresAt = parseExpires(attributeValue, 0, attributeValue.length)
               persistent = true
-            } catch (e: IllegalArgumentException) {
+            } catch (_: IllegalArgumentException) {
               // Ignore this attribute, it isn't recognizable as a date.
             }
           }
@@ -330,7 +414,7 @@ data class Cookie private constructor(
             try {
               deltaSeconds = parseMaxAge(attributeValue)
               persistent = true
-            } catch (e: NumberFormatException) {
+            } catch (_: NumberFormatException) {
               // Ignore this attribute, it isn't recognizable as a max age.
             }
           }
@@ -338,7 +422,7 @@ data class Cookie private constructor(
             try {
               domain = parseDomain(attributeValue)
               hostOnly = false
-            } catch (e: IllegalArgumentException) {
+            } catch (_: IllegalArgumentException) {
               // Ignore this attribute, it isn't recognizable as a domain.
             }
           }
@@ -367,13 +451,13 @@ data class Cookie private constructor(
           Long.MAX_VALUE
         }
         expiresAt = currentTimeMillis + deltaMilliseconds
-        if (expiresAt < currentTimeMillis || expiresAt > HttpDate.MAX_DATE) {
-          expiresAt = HttpDate.MAX_DATE // Handle overflow & limit the date range.
+        if (expiresAt < currentTimeMillis || expiresAt > MAX_DATE) {
+          expiresAt = MAX_DATE // Handle overflow & limit the date range.
         }
       }
 
       // If the domain is present, it must domain match. Otherwise we have a host-only cookie.
-      val urlHost = url.host()
+      val urlHost = url.host
       if (domain == null) {
         domain = urlHost
       } else if (!domainMatch(urlHost, domain)) {
@@ -389,7 +473,7 @@ data class Cookie private constructor(
       // If the path is absent or didn't start with '/', use the default path. It's a string like
       // '/foo/bar' for a URL like 'http://example.com/foo/bar/baz'. It always starts with '/'.
       if (path == null || !path.startsWith("/")) {
-        val encodedPath = url.encodedPath()
+        val encodedPath = url.encodedPath
         val lastSlash = encodedPath.lastIndexOf('/')
         path = if (lastSlash != 0) encodedPath.substring(0, lastSlash) else "/"
       }
@@ -398,7 +482,7 @@ data class Cookie private constructor(
           persistent, hostOnly)
     }
 
-    /** Parse a date as specified in RFC 6265, section 5.1.1.  */
+    /** Parse a date as specified in RFC 6265, section 5.1.1. */
     private fun parseExpires(s: String, pos: Int, limit: Int): Long {
       var pos = pos
       pos = dateCharacterOffset(s, pos, limit, false)
@@ -480,11 +564,10 @@ data class Cookie private constructor(
     }
 
     /**
-     * Returns the positive value if `attributeValue` is positive, or [Long.MIN_VALUE] if it is
-     * either 0 or negative. If the value is positive but out of range, this returns
-     * [Long.MAX_VALUE].
+     * Returns the positive value if [s] is positive, or [Long.MIN_VALUE] if it is either 0 or
+     * negative. If the value is positive but out of range, this returns [Long.MAX_VALUE].
      *
-     * @throws NumberFormatException if `s` is not an integer of any precision.
+     * @throws NumberFormatException if [s] is not an integer of any precision.
      */
     private fun parseMaxAge(s: String): Long {
       try {
@@ -505,17 +588,17 @@ data class Cookie private constructor(
      */
     private fun parseDomain(s: String): String {
       require(!s.endsWith("."))
-      return canonicalizeHost(s.removePrefix(".")) ?: throw IllegalArgumentException()
+      return s.removePrefix(".").toCanonicalHost() ?: throw IllegalArgumentException()
     }
 
-    /** Returns all of the cookies from a set of HTTP response headers.  */
+    /** Returns all of the cookies from a set of HTTP response headers. */
     @JvmStatic
     fun parseAll(url: HttpUrl, headers: Headers): List<Cookie> {
       val cookieStrings = headers.values("Set-Cookie")
       var cookies: MutableList<Cookie>? = null
 
       for (i in 0 until cookieStrings.size) {
-        val cookie = Cookie.parse(url, cookieStrings[i]) ?: continue
+        val cookie = parse(url, cookieStrings[i]) ?: continue
         if (cookies == null) cookies = mutableListOf()
         cookies.add(cookie)
       }
diff --git a/okhttp/src/main/java/okhttp3/CookieJar.kt b/okhttp/src/main/java/okhttp3/CookieJar.kt
index 8ae48fd7cd..cae9aebc88 100644
--- a/okhttp/src/main/java/okhttp3/CookieJar.kt
+++ b/okhttp/src/main/java/okhttp3/CookieJar.kt
@@ -31,20 +31,20 @@ package okhttp3
  */
 interface CookieJar {
   /**
-   * Saves `cookies` from an HTTP response to this store according to this jar's policy.
+   * Saves [cookies] from an HTTP response to this store according to this jar's policy.
    *
    * Note that this method may be called a second time for a single HTTP response if the response
-   * includes a trailer. For this obscure HTTP feature, `cookies` contains only the trailer's
+   * includes a trailer. For this obscure HTTP feature, [cookies] contains only the trailer's
    * cookies.
    */
   fun saveFromResponse(url: HttpUrl, cookies: List<Cookie>)
 
   /**
-   * Load cookies from the jar for an HTTP request to `url`. This method returns a possibly
+   * Load cookies from the jar for an HTTP request to [url]. This method returns a possibly
    * empty list of cookies for the network request.
    *
    * Simple implementations will return the accepted cookies that have not yet expired and that
-   * [match][Cookie.matches] `url`.
+   * [match][Cookie.matches] [url].
    */
   fun loadForRequest(url: HttpUrl): List<Cookie>
 
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.kt b/okhttp/src/main/java/okhttp3/Dispatcher.kt
index fbd92dd67f..d64d82693c 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.kt
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.kt
@@ -16,9 +16,8 @@
 package okhttp3
 
 import okhttp3.RealCall.AsyncCall
-import okhttp3.internal.Util
+import okhttp3.internal.threadFactory
 import java.util.ArrayDeque
-import java.util.ArrayList
 import java.util.Collections
 import java.util.Deque
 import java.util.concurrent.ExecutorService
@@ -29,18 +28,17 @@ import java.util.concurrent.TimeUnit
 /**
  * Policy on when async requests are executed.
  *
- *
  * Each dispatcher uses an [ExecutorService] to run calls internally. If you supply your own
  * executor, it should be able to run [the configured maximum][maxRequests] number of calls
  * concurrently.
  */
 class Dispatcher constructor() {
   /**
-   * Set the maximum number of requests to execute concurrently. Above this requests queue in
-   * memory, waiting for the running calls to complete.
+   * The maximum number of requests to execute concurrently. Above this requests queue in memory,
+   * waiting for the running calls to complete.
    *
-   * If more than `maxRequests` requests are in flight when this is invoked, those requests
-   * will remain in flight.
+   * If more than [maxRequests] requests are in flight when this is invoked, those requests will
+   * remain in flight.
    */
   @get:Synchronized var maxRequests = 64
     set(maxRequests) {
@@ -52,13 +50,12 @@ class Dispatcher constructor() {
     }
 
   /**
-   * Set the maximum number of requests for each host to execute concurrently. This limits requests
-   * by the URL's host name. Note that concurrent requests to a single IP address may still exceed
-   * this limit: multiple hostnames may share an IP address or be routed through the same HTTP
-   * proxy.
+   * The maximum number of requests for each host to execute concurrently. This limits requests by
+   * the URL's host name. Note that concurrent requests to a single IP address may still exceed this
+   * limit: multiple hostnames may share an IP address or be routed through the same HTTP proxy.
    *
-   * If more than `maxRequestsPerHost` requests are in flight when this is invoked, those
-   * requests will remain in flight.
+   * If more than [maxRequestsPerHost] requests are in flight when this is invoked, those requests
+   * will remain in flight.
    *
    * WebSocket connections to hosts **do not** count against this limit.
    */
@@ -71,52 +68,46 @@ class Dispatcher constructor() {
       promoteAndExecute()
     }
 
-  private var idleCallback: Runnable? = null
-
-  /** Executes calls. Created lazily.  */
-  private var executorService: ExecutorService? = null
+  /**
+   * A callback to be invoked each time the dispatcher becomes idle (when the number of running
+   * calls returns to zero).
+   *
+   * Note: The time at which a [call][Call] is considered idle is different depending on whether it
+   * was run [asynchronously][Call.enqueue] or [synchronously][Call.execute]. Asynchronous calls
+   * become idle after the [onResponse][Callback.onResponse] or [onFailure][Callback.onFailure]
+   * callback has returned. Synchronous calls become idle once [execute()][Call.execute] returns.
+   * This means that if you are doing synchronous calls the network layer will not truly be idle
+   * until every returned [Response] has been closed.
+   */
+  @set:Synchronized
+  @get:Synchronized
+  var idleCallback: Runnable? = null
+
+  private var executorServiceOrNull: ExecutorService? = null
+
+  @get:Synchronized
+  @get:JvmName("executorService") val executorService: ExecutorService
+    get() {
+      if (executorServiceOrNull == null) {
+        executorServiceOrNull = ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS,
+            SynchronousQueue(), threadFactory("OkHttp Dispatcher", false))
+      }
+      return executorServiceOrNull!!
+    }
 
-  /** Ready async calls in the order they'll be run.  */
+  /** Ready async calls in the order they'll be run. */
   private val readyAsyncCalls = ArrayDeque<AsyncCall>()
 
-  /** Running asynchronous calls. Includes canceled calls that haven't finished yet.  */
+  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
   private val runningAsyncCalls = ArrayDeque<AsyncCall>()
 
-  /** Running synchronous calls. Includes canceled calls that haven't finished yet.  */
+  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
   private val runningSyncCalls = ArrayDeque<RealCall>()
 
   constructor(executorService: ExecutorService) : this() {
-    this.executorService = executorService
+    this.executorServiceOrNull = executorService
   }
 
-  @Synchronized fun executorService(): ExecutorService {
-    if (executorService == null) {
-      executorService = ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS,
-          SynchronousQueue(), Util.threadFactory("OkHttp Dispatcher", false))
-    }
-    return executorService!!
-  }
-
-  /**
-   * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running
-   * calls returns to zero).
-   *
-   * Note: The time at which a [call][Call] is considered idle is different depending
-   * on whether it was run [asynchronously][Call.enqueue] or [synchronously][Call.execute].
-   * Asynchronous calls become idle after the [onResponse][Callback.onResponse] or
-   * [onFailure][Callback.onFailure] callback has returned. Synchronous calls become idle once
-   * [execute()][Call.execute] returns. This means that if you are doing synchronous calls the
-   * network layer will not truly be idle until every returned [Response] has been closed.
-   */
-  @Synchronized fun setIdleCallback(idleCallback: Runnable?) {
-    this.idleCallback = idleCallback
-  }
-
-  // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
-  @JvmName("-deprecated_setIdleCallback")
-  inline fun setIdleCallback(crossinline idleCallback: () -> Unit) =
-      setIdleCallback(Runnable { idleCallback() })
-
   internal fun enqueue(call: AsyncCall) {
     synchronized(this) {
       readyAsyncCalls.add(call)
@@ -167,7 +158,7 @@ class Dispatcher constructor() {
   private fun promoteAndExecute(): Boolean {
     assert(!Thread.holdsLock(this))
 
-    val executableCalls = ArrayList<AsyncCall>()
+    val executableCalls = mutableListOf<AsyncCall>()
     val isRunning: Boolean
     synchronized(this) {
       val i = readyAsyncCalls.iterator()
@@ -187,24 +178,24 @@ class Dispatcher constructor() {
 
     for (i in 0 until executableCalls.size) {
       val asyncCall = executableCalls[i]
-      asyncCall.executeOn(executorService())
+      asyncCall.executeOn(executorService)
     }
 
     return isRunning
   }
 
-  /** Used by `Call#execute` to signal it is in-flight.  */
+  /** Used by `Call#execute` to signal it is in-flight. */
   @Synchronized internal fun executed(call: RealCall) {
     runningSyncCalls.add(call)
   }
 
-  /** Used by `AsyncCall#run` to signal completion.  */
+  /** Used by `AsyncCall#run` to signal completion. */
   internal fun finished(call: AsyncCall) {
     call.callsPerHost().decrementAndGet()
     finished(runningAsyncCalls, call)
   }
 
-  /** Used by `Call#execute` to signal completion.  */
+  /** Used by `Call#execute` to signal completion. */
   internal fun finished(call: RealCall) {
     finished(runningSyncCalls, call)
   }
@@ -223,12 +214,12 @@ class Dispatcher constructor() {
     }
   }
 
-  /** Returns a snapshot of the calls currently awaiting execution.  */
+  /** Returns a snapshot of the calls currently awaiting execution. */
   @Synchronized fun queuedCalls(): List<Call> {
     return Collections.unmodifiableList(readyAsyncCalls.map { it.get() })
   }
 
-  /** Returns a snapshot of the calls currently being executed.  */
+  /** Returns a snapshot of the calls currently being executed. */
   @Synchronized fun runningCalls(): List<Call> {
     return Collections.unmodifiableList(runningSyncCalls + runningAsyncCalls.map { it.get() })
   }
@@ -236,4 +227,11 @@ class Dispatcher constructor() {
   @Synchronized fun queuedCallsCount(): Int = readyAsyncCalls.size
 
   @Synchronized fun runningCallsCount(): Int = runningAsyncCalls.size + runningSyncCalls.size
+
+  @JvmName("-deprecated_executorService")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "executorService"),
+      level = DeprecationLevel.ERROR)
+  fun executorService(): ExecutorService = executorService
 }
diff --git a/okhttp/src/main/java/okhttp3/Dns.kt b/okhttp/src/main/java/okhttp3/Dns.kt
index 4aef7fd93b..3f6a63814b 100644
--- a/okhttp/src/main/java/okhttp3/Dns.kt
+++ b/okhttp/src/main/java/okhttp3/Dns.kt
@@ -47,20 +47,11 @@ interface Dns {
         try {
           return InetAddress.getAllByName(hostname).toList()
         } catch (e: NullPointerException) {
-          val unknownHostException = UnknownHostException(
-              "Broken system behaviour for dns lookup of $hostname")
-          unknownHostException.initCause(e)
-          throw unknownHostException
+          throw UnknownHostException("Broken system behaviour for dns lookup of $hostname").apply {
+            initCause(e)
+          }
         }
       }
     }
-
-    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
-    @JvmName("-deprecated_Dns")
-    inline operator fun invoke(
-      crossinline block: (String) -> List<InetAddress>
-    ): Dns = object : Dns {
-      override fun lookup(hostname: String): List<InetAddress> = block(hostname)
-    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/EventListener.kt b/okhttp/src/main/java/okhttp3/EventListener.kt
index 169174c13b..f52fa00af2 100644
--- a/okhttp/src/main/java/okhttp3/EventListener.kt
+++ b/okhttp/src/main/java/okhttp3/EventListener.kt
@@ -60,6 +60,42 @@ abstract class EventListener {
   ) {
   }
 
+  /**
+   * Invoked prior to a proxy selection.
+   *
+   * This will be invoked for route selection regardless of whether the client
+   * is configured with a single proxy, a proxy selector, or neither.
+   *
+   * @param url a URL with only the scheme, hostname, and port specified.
+   */
+  open fun proxySelectStart(
+    call: Call,
+    url: HttpUrl
+  ) {
+  }
+
+  /**
+   * Invoked after proxy selection.
+   *
+   * Note that the list of proxies is never null, but it may be a list containing
+   * only [Proxy.NO_PROXY]. This comes up in several situations:
+   *
+   * * If neither a proxy nor proxy selector is configured.
+   * * If the proxy is configured explicitly as [Proxy.NO_PROXY].
+   * * If the proxy selector returns only [Proxy.NO_PROXY].
+   * * If the proxy selector returns an empty list or null.
+   *
+   * Otherwise it lists the proxies in the order they will be attempted.
+   *
+   * @param url a URL with only the scheme, hostname, and port specified.
+   */
+  open fun proxySelectEnd(
+    call: Call,
+    url: HttpUrl,
+    proxies: List<@JvmSuppressWildcards Proxy>
+  ) {
+  }
+
   /**
    * Invoked just prior to a DNS lookup. See [Dns.lookup].
    *
@@ -338,24 +374,14 @@ abstract class EventListener {
   interface Factory {
     /**
      * Creates an instance of the [EventListener] for a particular [Call]. The returned
-     * [EventListener] instance will be used during the lifecycle of the `call`.
+     * [EventListener] instance will be used during the lifecycle of [call].
      *
-     * This method is invoked after the `call` is created. See [OkHttpClient.newCall].
+     * This method is invoked after [call] is created. See [OkHttpClient.newCall].
      *
-     * **It is an error for implementations to issue any mutating operations on the `call` instance
+     * **It is an error for implementations to issue any mutating operations on the [call] instance
      * from this method.**
      */
     fun create(call: Call): EventListener
-
-    companion object {
-      // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
-      @JvmName("-deprecated_Factory")
-      inline operator fun invoke(
-        crossinline block: (call: Call) -> EventListener
-      ): Factory = object : Factory {
-        override fun create(call: Call) = block(call)
-      }
-    }
   }
 
   companion object {
diff --git a/okhttp/src/main/java/okhttp3/FormBody.kt b/okhttp/src/main/java/okhttp3/FormBody.kt
index cef74278bc..de55d44279 100644
--- a/okhttp/src/main/java/okhttp3/FormBody.kt
+++ b/okhttp/src/main/java/okhttp3/FormBody.kt
@@ -16,8 +16,10 @@
 package okhttp3
 
 import okhttp3.HttpUrl.Companion.FORM_ENCODE_SET
+import okhttp3.HttpUrl.Companion.canonicalize
 import okhttp3.HttpUrl.Companion.percentDecode
-import okhttp3.internal.Util
+import okhttp3.MediaType.Companion.toMediaType
+import okhttp3.internal.toImmutableList
 import okio.Buffer
 import okio.BufferedSink
 import java.io.IOException
@@ -27,19 +29,27 @@ class FormBody internal constructor(
   encodedNames: List<String>,
   encodedValues: List<String>
 ) : RequestBody() {
-  private val encodedNames: List<String> = Util.immutableList(encodedNames)
-  private val encodedValues: List<String> = Util.immutableList(encodedValues)
+  private val encodedNames: List<String> = encodedNames.toImmutableList()
+  private val encodedValues: List<String> = encodedValues.toImmutableList()
 
-  /** The number of key-value pairs in this form-encoded body.  */
-  fun size(): Int = encodedNames.size
+  /** The number of key-value pairs in this form-encoded body. */
+  @get:JvmName("size") val size: Int
+    get() = encodedNames.size
+
+  @JvmName("-deprecated_size")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "size"),
+      level = DeprecationLevel.ERROR)
+  fun size(): Int = size
 
   fun encodedName(index: Int) = encodedNames[index]
 
-  fun name(index: Int) = percentDecode(encodedName(index), true)
+  fun name(index: Int) = encodedName(index).percentDecode(plusIsSpace = true)
 
   fun encodedValue(index: Int) = encodedValues[index]
 
-  fun value(index: Int) = percentDecode(encodedValue(index), true)
+  fun value(index: Int) = encodedValue(index).percentDecode(plusIsSpace = true)
 
   override fun contentType() = CONTENT_TYPE
 
@@ -51,7 +61,7 @@ class FormBody internal constructor(
   }
 
   /**
-   * Either writes this request to `sink` or measures its content length. We have one method
+   * Either writes this request to [sink] or measures its content length. We have one method
    * do double-duty to make sure the counting and content are consistent, particularly when it comes
    * to awkward operations like measuring the encoded length of header strings, or the
    * length-in-digits of an encoded integer.
@@ -80,19 +90,37 @@ class FormBody internal constructor(
     private val values = mutableListOf<String>()
 
     fun add(name: String, value: String) = apply {
-      names += HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true, charset)
-      values += HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true, charset)
+      names += name.canonicalize(
+          encodeSet = FORM_ENCODE_SET,
+          plusIsSpace = true,
+          charset = charset
+      )
+      values += value.canonicalize(
+          encodeSet = FORM_ENCODE_SET,
+          plusIsSpace = true,
+          charset = charset
+      )
     }
 
     fun addEncoded(name: String, value: String) = apply {
-      names += HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true, charset)
-      values += HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true, charset)
+      names += name.canonicalize(
+          encodeSet = FORM_ENCODE_SET,
+          alreadyEncoded = true,
+          plusIsSpace = true,
+          charset = charset
+      )
+      values += value.canonicalize(
+          encodeSet = FORM_ENCODE_SET,
+          alreadyEncoded = true,
+          plusIsSpace = true,
+          charset = charset
+      )
     }
 
     fun build(): FormBody = FormBody(names, values)
   }
 
   companion object {
-    private val CONTENT_TYPE: MediaType = MediaType.get("application/x-www-form-urlencoded")
+    private val CONTENT_TYPE: MediaType = "application/x-www-form-urlencoded".toMediaType()
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Handshake.kt b/okhttp/src/main/java/okhttp3/Handshake.kt
index edc6e3ebf1..ffe41afd2e 100644
--- a/okhttp/src/main/java/okhttp3/Handshake.kt
+++ b/okhttp/src/main/java/okhttp3/Handshake.kt
@@ -15,7 +15,8 @@
  */
 package okhttp3
 
-import okhttp3.internal.Util
+import okhttp3.internal.toImmutableList
+import okhttp3.internal.immutableListOf
 import java.io.IOException
 import java.security.Principal
 import java.security.cert.Certificate
@@ -24,50 +25,96 @@ import javax.net.ssl.SSLPeerUnverifiedException
 import javax.net.ssl.SSLSession
 
 /**
- * A record of a TLS handshake. For HTTPS clients, the client is *local* and the remote server
- * is its *peer*.
+ * A record of a TLS handshake. For HTTPS clients, the client is *local* and the remote server is
+ * its *peer*.
  *
- * This value object describes a completed handshake. Use [ConnectionSpec] to set policy
- * for new handshakes.
+ * This value object describes a completed handshake. Use [ConnectionSpec] to set policy for new
+ * handshakes.
  */
-data class Handshake private constructor(
-  private val tlsVersion: TlsVersion,
-  private val cipherSuite: CipherSuite,
-  private val peerCertificates: List<Certificate>,
-  private val localCertificates: List<Certificate>
-) {
-
+class Handshake private constructor(
   /**
    * Returns the TLS version used for this connection. This value wasn't tracked prior to OkHttp
    * 3.0. For responses cached by preceding versions this returns [TlsVersion.SSL_3_0].
    */
-  fun tlsVersion() = tlsVersion
+  @get:JvmName("tlsVersion") val tlsVersion: TlsVersion,
 
   /** Returns the cipher suite used for the connection. */
-  fun cipherSuite() = cipherSuite
+  @get:JvmName("cipherSuite") val cipherSuite: CipherSuite,
 
   /** Returns a possibly-empty list of certificates that identify the remote peer. */
+  @get:JvmName("peerCertificates") val peerCertificates: List<Certificate>,
+
+  /** Returns a possibly-empty list of certificates that identify this peer. */
+  @get:JvmName("localCertificates") val localCertificates: List<Certificate>
+) {
+
+  @JvmName("-deprecated_tlsVersion")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "tlsVersion"),
+      level = DeprecationLevel.ERROR)
+  fun tlsVersion() = tlsVersion
+
+  @JvmName("-deprecated_cipherSuite")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "cipherSuite"),
+      level = DeprecationLevel.ERROR)
+  fun cipherSuite() = cipherSuite
+
+  @JvmName("-deprecated_peerCertificates")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "peerCertificates"),
+      level = DeprecationLevel.ERROR)
   fun peerCertificates() = peerCertificates
 
   /** Returns the remote peer's principle, or null if that peer is anonymous. */
-  fun peerPrincipal(): Principal? {
-    return if (peerCertificates.isNotEmpty()) {
-      (peerCertificates[0] as X509Certificate).subjectX500Principal
-    } else {
-      null
-    }
-  }
-
-  /** Returns a possibly-empty list of certificates that identify this peer. */
+  @get:JvmName("peerPrincipal")
+  val peerPrincipal: Principal?
+    get() = (peerCertificates.firstOrNull() as? X509Certificate)?.subjectX500Principal
+
+  @JvmName("-deprecated_peerPrincipal")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "peerPrincipal"),
+      level = DeprecationLevel.ERROR)
+  fun peerPrincipal() = peerPrincipal
+
+  @JvmName("-deprecated_localCertificates")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "localCertificates"),
+      level = DeprecationLevel.ERROR)
   fun localCertificates() = localCertificates
 
   /** Returns the local principle, or null if this peer is anonymous. */
-  fun localPrincipal(): Principal? {
-    return if (localCertificates.isNotEmpty()) {
-      (localCertificates[0] as X509Certificate).subjectX500Principal
-    } else {
-      null
-    }
+  @get:JvmName("localPrincipal")
+  val localPrincipal: Principal?
+    get() = (localCertificates.firstOrNull() as? X509Certificate)?.subjectX500Principal
+
+  @JvmName("-deprecated_localPrincipal")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "localPrincipal"),
+      level = DeprecationLevel.ERROR)
+  fun localPrincipal() = localPrincipal
+
+  override fun equals(other: Any?): Boolean {
+    return other is Handshake &&
+        other.tlsVersion == tlsVersion &&
+        other.cipherSuite == cipherSuite &&
+        other.peerCertificates == peerCertificates &&
+        other.localCertificates == localCertificates
+  }
+
+  override fun hashCode(): Int {
+    var result = 17
+    result = 31 * result + tlsVersion.hashCode()
+    result = 31 * result + cipherSuite.hashCode()
+    result = 31 * result + peerCertificates.hashCode()
+    result = 31 * result + localCertificates.hashCode()
+    return result
   }
 
   override fun toString(): String {
@@ -87,32 +134,33 @@ data class Handshake private constructor(
   companion object {
     @Throws(IOException::class)
     @JvmStatic
-    fun get(session: SSLSession): Handshake {
-      val cipherSuiteString = checkNotNull(session.cipherSuite) { "cipherSuite == null" }
+    @JvmName("get")
+    fun SSLSession.handshake(): Handshake {
+      val cipherSuiteString = checkNotNull(cipherSuite) { "cipherSuite == null" }
       if ("SSL_NULL_WITH_NULL_NULL" == cipherSuiteString) {
         throw IOException("cipherSuite == SSL_NULL_WITH_NULL_NULL")
       }
       val cipherSuite = CipherSuite.forJavaName(cipherSuiteString)
 
-      val tlsVersionString = session.protocol ?: throw IllegalStateException("tlsVersion == null")
+      val tlsVersionString = checkNotNull(protocol) { "tlsVersion == null" }
       if ("NONE" == tlsVersionString) throw IOException("tlsVersion == NONE")
       val tlsVersion = TlsVersion.forJavaName(tlsVersionString)
 
       val peerCertificates: Array<Certificate>? = try {
-        session.peerCertificates
-      } catch (ignored: SSLPeerUnverifiedException) {
+        peerCertificates
+      } catch (_: SSLPeerUnverifiedException) {
         null
       }
 
       val peerCertificatesList = if (peerCertificates != null) {
-        Util.immutableList(*peerCertificates)
+        immutableListOf(*peerCertificates)
       } else {
         emptyList()
       }
 
-      val localCertificates = session.localCertificates
+      val localCertificates = localCertificates
       val localCertificatesList = if (localCertificates != null) {
-        Util.immutableList(*localCertificates)
+        immutableListOf(*localCertificates)
       } else {
         emptyList()
       }
@@ -120,6 +168,14 @@ data class Handshake private constructor(
       return Handshake(tlsVersion, cipherSuite, peerCertificatesList, localCertificatesList)
     }
 
+    @Throws(IOException::class)
+    @JvmName("-deprecated_get")
+    @Deprecated(
+        message = "moved to extension function",
+        replaceWith = ReplaceWith(expression = "sslSession.handshake()"),
+        level = DeprecationLevel.ERROR)
+    fun get(sslSession: SSLSession) = sslSession.handshake()
+
     @JvmStatic
     fun get(
       tlsVersion: TlsVersion,
@@ -127,8 +183,8 @@ data class Handshake private constructor(
       peerCertificates: List<Certificate>,
       localCertificates: List<Certificate>
     ): Handshake {
-      return Handshake(tlsVersion, cipherSuite, Util.immutableList(peerCertificates),
-          Util.immutableList(localCertificates))
+      return Handshake(tlsVersion, cipherSuite, peerCertificates.toImmutableList(),
+          localCertificates.toImmutableList())
     }
   }
 }
\ No newline at end of file
diff --git a/okhttp/src/main/java/okhttp3/Headers.kt b/okhttp/src/main/java/okhttp3/Headers.kt
index bdc7b65506..40b52296c9 100644
--- a/okhttp/src/main/java/okhttp3/Headers.kt
+++ b/okhttp/src/main/java/okhttp3/Headers.kt
@@ -18,12 +18,12 @@
 package okhttp3
 
 import okhttp3.Headers.Builder
-import okhttp3.internal.Util
-import okhttp3.internal.http.HttpDate
+import okhttp3.internal.format
+import okhttp3.internal.http.toHttpDateOrNull
+import okhttp3.internal.http.toHttpDateString
 import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
 import java.time.Instant
 import java.util.ArrayList
-import java.util.Arrays
 import java.util.Collections
 import java.util.Date
 import java.util.Locale
@@ -46,9 +46,10 @@ import java.util.TreeSet
  *
  * Instances of this class are immutable. Use [Builder] to create instances.
  */
+@Suppress("NAME_SHADOWING")
 class Headers private constructor(
   private val namesAndValues: Array<String>
-) {
+) : Iterable<Pair<String, String>> {
   /** Returns the last value corresponding to the specified field, or null. */
   operator fun get(name: String): String? = get(namesAndValues, name)
 
@@ -56,10 +57,7 @@ class Headers private constructor(
    * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
    * either the field is absent or cannot be parsed as a date.
    */
-  fun getDate(name: String): Date? {
-    val value = get(name)
-    return if (value != null) HttpDate.parse(value) else null
-  }
+  fun getDate(name: String): Date? = get(name)?.toHttpDateOrNull()
 
   /**
    * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
@@ -71,28 +69,36 @@ class Headers private constructor(
     return value?.toInstant()
   }
 
-  /** Returns the number of field values.  */
-  fun size(): Int = namesAndValues.size / 2
+  /** Returns the number of field values. */
+  @get:JvmName("size") val size: Int
+    get() = namesAndValues.size / 2
+
+  @JvmName("-deprecated_size")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "size"),
+      level = DeprecationLevel.ERROR)
+  fun size(): Int = size
 
-  /** Returns the field at `position`.  */
+  /** Returns the field at `position`. */
   fun name(index: Int): String = namesAndValues[index * 2]
 
-  /** Returns the value at `index`.  */
+  /** Returns the value at `index`. */
   fun value(index: Int): String = namesAndValues[index * 2 + 1]
 
-  /** Returns an immutable case-insensitive set of header names.  */
+  /** Returns an immutable case-insensitive set of header names. */
   fun names(): Set<String> {
     val result = TreeSet(String.CASE_INSENSITIVE_ORDER)
-    for (i in 0 until size()) {
+    for (i in 0 until size) {
       result.add(name(i))
     }
     return Collections.unmodifiableSet(result)
   }
 
-  /** Returns an immutable list of the header values for `name`.  */
+  /** Returns an immutable list of the header values for `name`. */
   fun values(name: String): List<String> {
     var result: MutableList<String>? = null
-    for (i in 0 until size()) {
+    for (i in 0 until size) {
       if (name.equals(name(i), ignoreCase = true)) {
         if (result == null) result = ArrayList(2)
         result.add(value(i))
@@ -122,9 +128,13 @@ class Headers private constructor(
     return result
   }
 
+  override operator fun iterator(): Iterator<Pair<String, String>> {
+    return Array(size) { name(it) to value(it) }.iterator()
+  }
+
   fun newBuilder(): Builder {
     val result = Builder()
-    Collections.addAll(result.namesAndValues, *namesAndValues)
+    result.namesAndValues += namesAndValues
     return result
   }
 
@@ -165,14 +175,14 @@ class Headers private constructor(
    * before comparing them for equality.
    */
   override fun equals(other: Any?): Boolean {
-    return other is Headers && Arrays.equals(other.namesAndValues, namesAndValues)
+    return other is Headers && namesAndValues.contentEquals(other.namesAndValues)
   }
 
-  override fun hashCode(): Int = Arrays.hashCode(namesAndValues)
+  override fun hashCode(): Int = namesAndValues.contentHashCode()
 
   override fun toString(): String {
     return buildString {
-      for (i in 0 until size()) {
+      for (i in 0 until size) {
         append(name(i))
         append(": ")
         append(value(i))
@@ -183,7 +193,7 @@ class Headers private constructor(
 
   fun toMultimap(): Map<String, List<String>> {
     val result = TreeMap<String, MutableList<String>>(String.CASE_INSENSITIVE_ORDER)
-    for (i in 0 until size()) {
+    for (i in 0 until size) {
       val name = name(i).toLowerCase(Locale.US)
       var values: MutableList<String>? = result[name]
       if (values == null) {
@@ -203,14 +213,14 @@ class Headers private constructor(
      * or cache.
      */
     internal fun addLenient(line: String) = apply {
-      val index = line.indexOf(":", 1)
+      val index = line.indexOf(':', 1)
       when {
         index != -1 -> {
           addLenient(line.substring(0, index), line.substring(index + 1))
         }
-        line.startsWith(":") -> {
-          // Work around empty header names and header names that start with a
-          // colon (created by old broken SPDY versions of the response cache).
+        line[0] == ':' -> {
+          // Work around empty header names and header names that start with a colon (created by old
+          // broken SPDY versions of the response cache).
           addLenient("", line.substring(1)) // Empty header name.
         }
         else -> {
@@ -222,9 +232,9 @@ class Headers private constructor(
 
     /** Add an header line containing a field name, a literal colon, and a value. */
     fun add(line: String) = apply {
-      val index = line.indexOf(":")
+      val index = line.indexOf(':')
       require(index != -1) { "Unexpected header: $line" }
-      add(line.substring(0, index).trim { it <= ' ' }, line.substring(index + 1))
+      add(line.substring(0, index).trim(), line.substring(index + 1))
     }
 
     /**
@@ -249,7 +259,7 @@ class Headers private constructor(
      * Adds all headers from an existing collection.
      */
     fun addAll(headers: Headers) = apply {
-      for (i in 0 until headers.size()) {
+      for (i in 0 until headers.size) {
         addLenient(headers.name(i), headers.value(i))
       }
     }
@@ -259,7 +269,7 @@ class Headers private constructor(
      * value.
      */
     fun add(name: String, value: Date) = apply {
-      add(name, HttpDate.format(value))
+      add(name, value.toHttpDateString())
     }
 
     /**
@@ -276,7 +286,7 @@ class Headers private constructor(
      * found, the existing values are replaced.
      */
     operator fun set(name: String, value: Date) = apply {
-      set(name, HttpDate.format(value))
+      set(name, value.toHttpDateString())
     }
 
     /**
@@ -294,7 +304,7 @@ class Headers private constructor(
      */
     internal fun addLenient(name: String, value: String) = apply {
       namesAndValues.add(name)
-      namesAndValues.add(value.trim { it <= ' ' })
+      namesAndValues.add(value.trim())
     }
 
     fun removeAll(name: String) = apply {
@@ -320,7 +330,7 @@ class Headers private constructor(
       addLenient(name, value)
     }
 
-    /** Equivalent to `build().get(name)`, but potentially faster.  */
+    /** Equivalent to `build().get(name)`, but potentially faster. */
     operator fun get(name: String): String? {
       for (i in namesAndValues.size - 2 downTo 0 step 2) {
         if (name.equals(namesAndValues[i], ignoreCase = true)) {
@@ -348,14 +358,15 @@ class Headers private constructor(
      * arguments, and they must alternate between header names and values.
      */
     @JvmStatic
-    fun of(vararg namesAndValues: String): Headers {
+    @JvmName("of")
+    fun headersOf(vararg namesAndValues: String): Headers {
       require(namesAndValues.size % 2 == 0) { "Expected alternating header names and values" }
 
       // Make a defensive copy and clean it up.
       val namesAndValues: Array<String> = namesAndValues.clone() as Array<String>
       for (i in namesAndValues.indices) {
         require(namesAndValues[i] != null) { "Headers cannot be null" }
-        namesAndValues[i] = namesAndValues[i].trim { it <= ' ' }
+        namesAndValues[i] = namesAndValues[i].trim()
       }
 
       // Check for malformed headers.
@@ -369,15 +380,25 @@ class Headers private constructor(
       return Headers(namesAndValues)
     }
 
+    @JvmName("-deprecated_of")
+    @Deprecated(
+        message = "function name changed",
+        replaceWith = ReplaceWith(expression = "headersOf(*namesAndValues)"),
+        level = DeprecationLevel.ERROR)
+    fun of(vararg namesAndValues: String): Headers {
+      return headersOf(*namesAndValues)
+    }
+
     /** Returns headers for the header names and values in the [Map]. */
     @JvmStatic
-    fun of(headers: Map<String, String>): Headers {
+    @JvmName("of")
+    fun Map<String, String>.toHeaders(): Headers {
       // Make a defensive copy and clean it up.
-      val namesAndValues = arrayOfNulls<String>(headers.size * 2)
+      val namesAndValues = arrayOfNulls<String>(size * 2)
       var i = 0
-      for ((key, value1) in headers) {
-        val name = key.trim { it <= ' ' }
-        val value = value1.trim { it <= ' ' }
+      for ((k, v) in this) {
+        val name = k.trim()
+        val value = v.trim()
         checkName(name)
         checkValue(value, name)
         namesAndValues[i] = name
@@ -388,21 +409,30 @@ class Headers private constructor(
       return Headers(namesAndValues as Array<String>)
     }
 
-    internal fun checkName(name: String) {
+    @JvmName("-deprecated_of")
+    @Deprecated(
+        message = "function moved to extension",
+        replaceWith = ReplaceWith(expression = "headers.toHeaders()"),
+        level = DeprecationLevel.ERROR)
+    fun of(headers: Map<String, String>): Headers {
+      return headers.toHeaders()
+    }
+
+    private fun checkName(name: String) {
       require(name.isNotEmpty()) { "name is empty" }
       for (i in 0 until name.length) {
         val c = name[i]
         require(c in '\u0021'..'\u007e') {
-          Util.format("Unexpected char %#04x at %d in header name: %s", c.toInt(), i, name)
+          format("Unexpected char %#04x at %d in header name: %s", c.toInt(), i, name)
         }
       }
     }
 
-    internal fun checkValue(value: String, name: String) {
+    private fun checkValue(value: String, name: String) {
       for (i in 0 until value.length) {
         val c = value[i]
         require(c == '\t' || c in '\u0020'..'\u007e') {
-          Util.format("Unexpected char %#04x at %d in %s value: %s", c.toInt(), i, name, value)
+          format("Unexpected char %#04x at %d in %s value: %s", c.toInt(), i, name, value)
         }
       }
     }
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.kt b/okhttp/src/main/java/okhttp3/HttpUrl.kt
index 270fdeb1e0..b415928d83 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.kt
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.kt
@@ -15,15 +15,15 @@
  */
 package okhttp3
 
-import okhttp3.HttpUrl.Companion.get
-import okhttp3.HttpUrl.Companion.parse
-import okhttp3.internal.Util
-import okhttp3.internal.Util.decodeHexDigit
-import okhttp3.internal.Util.delimiterOffset
-import okhttp3.internal.Util.skipLeadingAsciiWhitespace
-import okhttp3.internal.Util.skipTrailingAsciiWhitespace
-import okhttp3.internal.Util.verifyAsIpAddress
+import okhttp3.HttpUrl.Companion.toHttpUrl
+import okhttp3.HttpUrl.Companion.toHttpUrlOrNull
+import okhttp3.internal.canParseAsIpAddress
+import okhttp3.internal.delimiterOffset
+import okhttp3.internal.indexOfFirstNonAsciiWhitespace
+import okhttp3.internal.indexOfLastNonAsciiWhitespace
+import okhttp3.internal.parseHexDigit
 import okhttp3.internal.publicsuffix.PublicSuffixDatabase
+import okhttp3.internal.toCanonicalHost
 import okio.Buffer
 import java.net.InetAddress
 import java.net.MalformedURLException
@@ -280,56 +280,112 @@ import java.util.LinkedHashSet
  * `java.net.URL` it's possible to create an awkward URL like `http:/` with scheme and path but no
  * hostname. Building APIs that consume such malformed values is difficult!
  *
- * This class has a modern API. It avoids punitive checked exceptions: [get] throws
- * [IllegalArgumentException] on invalid input or [parse] returns null if the input is an invalid
- * URL. You can even be explicit about whether each component has been encoded already.
+ * This class has a modern API. It avoids punitive checked exceptions: [toHttpUrl] throws
+ * [IllegalArgumentException] on invalid input or [toHttpUrlOrNull] returns null if the input is an
+ * invalid URL. You can even be explicit about whether each component has been encoded already.
  *
  * [idna]: http://www.unicode.org/reports/tr46/#ToASCII
  */
-class HttpUrl internal constructor(builder: Builder) {
+class HttpUrl internal constructor(
+  /** Either "http" or "https". */
+  @get:JvmName("scheme") val scheme: String,
 
-  /** Either "http" or "https".  */
-  internal val scheme: String = builder.scheme ?: throw IllegalStateException("scheme == null")
-
-  /** Decoded username.  */
-  private val username: String = percentDecode(builder.encodedUsername, false)
+  /**
+   * The decoded username, or an empty string if none is present.
+   *
+   * | URL                              | `username()` |
+   * | :------------------------------- | :----------- |
+   * | `http://host/`                   | `""`         |
+   * | `http://username@host/`          | `"username"` |
+   * | `http://username:password@host/` | `"username"` |
+   * | `http://a%20b:c%20d@host/`       | `"a b"`      |
+   */
+  @get:JvmName("username") val username: String,
 
-  /** Decoded password.  */
-  private val password: String = percentDecode(builder.encodedPassword, false)
+  /**
+   * Returns the decoded password, or an empty string if none is present.
+   *
+   * | URL                              | `password()` |
+   * | :------------------------------- | :----------- |
+   * | `http://host/`                   | `""`         |
+   * | `http://username@host/`          | `""`         |
+   * | `http://username:password@host/` | `"password"` |
+   * | `http://a%20b:c%20d@host/`       | `"c d"`      |
+   */
+  @get:JvmName("password") val password: String,
 
-  /** Canonical hostname.  */
-  internal val host: String = builder.host ?: throw IllegalStateException("host == null")
+  /**
+   * The host address suitable for use with [InetAddress.getAllByName]. May be:
+   *
+   *  * A regular host name, like `android.com`.
+   *
+   *  * An IPv4 address, like `127.0.0.1`.
+   *
+   *  * An IPv6 address, like `::1`. Note that there are no square braces.
+   *
+   *  * An encoded IDN, like `xn--n3h.net`.
+   *
+   * | URL                   | `host()`        |
+   * | :-------------------- | :-------------- |
+   * | `http://android.com/` | `"android.com"` |
+   * | `http://127.0.0.1/`   | `"127.0.0.1"`   |
+   * | `http://[::1]/`       | `"::1"`         |
+   * | `http://xn--n3h.net/` | `"xn--n3h.net"` |
+   */
+  @get:JvmName("host") val host: String,
 
-  /** Either 80, 443 or a user-specified port. In range [1..65535].  */
-  internal val port: Int = builder.effectivePort()
+  /**
+   * The explicitly-specified port if one was provided, or the default port for this URL's scheme.
+   * For example, this returns 8443 for `https://square.com:8443/` and 443 for
+   * `https://square.com/`. The result is in `[1..65535]`.
+   *
+   * | URL                 | `port()` |
+   * | :------------------ | :------- |
+   * | `http://host/`      | `80`     |
+   * | `http://host:8000/` | `8000`   |
+   * | `https://host/`     | `443`    |
+   */
+  @get:JvmName("port") val port: Int,
 
   /**
-   * A list of canonical path segments. This list always contains at least one element, which may be
-   * the empty string. Each segment is formatted with a leading '/', so if path segments were ["a",
-   * "b", ""], then the encoded path would be "/a/b/".
+   * A list of path segments like `["a", "b", "c"]` for the URL `http://host/a/b/c`. This list is
+   * never empty though it may contain a single empty string.
+   *
+   * | URL                      | `pathSegments()`    |
+   * | :----------------------- | :------------------ |
+   * | `http://host/`           | `[""]`              |
+   * | `http://host/a/b/c"`     | `["a", "b", "c"]`   |
+   * | `http://host/a/b%20c/d"` | `["a", "b c", "d"]` |
    */
-  @Suppress("UNCHECKED_CAST")
-  private val pathSegments: List<String> =
-      percentDecode(builder.encodedPathSegments, false) as List<String>
+  @get:JvmName("pathSegments") val pathSegments: List<String>,
 
   /**
    * Alternating, decoded query names and values, or null for no query. Names may be empty or
    * non-empty, but never null. Values are null if the name has no corresponding '=' separator, or
    * empty, or non-empty.
    */
-  private val queryNamesAndValues: List<String?>? =
-      builder.encodedQueryNamesAndValues?.let { percentDecode(it, true) }
-
-  /** Decoded fragment.  */
-  private val fragment: String? = builder.encodedFragment?.let { percentDecode(it, false) }
+  private val queryNamesAndValues: List<String?>?,
 
-  /** Canonical URL.  */
-  private val url: String = builder.toString()
+  /**
+   * This URL's fragment, like `"abc"` for `http://host/#abc`. This is null if the URL has no
+   * fragment.
+   *
+   * | URL                    | `fragment()` |
+   * | :--------------------- | :----------- |
+   * | `http://host/`         | null         |
+   * | `http://host/#`        | `""`         |
+   * | `http://host/#abc`     | `"abc"`      |
+   * | `http://host/#abc|def` | `"abc|def"`  |
+   */
+  @get:JvmName("fragment") val fragment: String?,
 
+  /** Canonical URL. */
+  private val url: String
+) {
   val isHttps: Boolean = scheme == "https"
 
-  /** Returns this URL as a [java.net.URL][URL].  */
-  fun url(): URL {
+  /** Returns this URL as a [java.net.URL][URL]. */
+  @JvmName("url") fun toUrl(): URL {
     try {
       return URL(url)
     } catch (e: MalformedURLException) {
@@ -350,262 +406,181 @@ class HttpUrl internal constructor(builder: Builder) {
    * These differences may have a significant consequence when the URI is interpreted by a
    * web server. For this reason the [URI class][URI] and this method should be avoided.
    */
-  fun uri(): URI {
+  @JvmName("uri") fun toUri(): URI {
     val uri = newBuilder().reencodeForUri().toString()
-    try {
-      return URI(uri)
+    return try {
+      URI(uri)
     } catch (e: URISyntaxException) {
       // Unlikely edge case: the URI has a forbidden character in the fragment. Strip it & retry.
       try {
         val stripped = uri.replace(Regex("[\\u0000-\\u001F\\u007F-\\u009F\\p{javaWhitespace}]"), "")
-        return URI.create(stripped)
+        URI.create(stripped)
       } catch (e1: Exception) {
         throw RuntimeException(e) // Unexpected!
       }
     }
   }
 
-  /** Returns either "http" or "https".  */
-  fun scheme(): String = scheme
-
-  /**
-   * Returns the username, or an empty string if none is set.
-   *
-   * <table summary="">
-   * <tr><th>URL</th><th>`encodedUsername()`</th></tr>
-   * <tr><td>`http://host/`</td><td>`""`</td></tr>
-   * <tr><td>`http://username@host/`</td><td>`"username"`</td></tr>
-   * <tr><td>`http://username:password@host/`</td><td>`"username"`</td></tr>
-   * <tr><td>`http://a%20b:c%20d@host/`</td><td>`"a%20b"`</td></tr>
-   * </table>
-   */
-  fun encodedUsername(): String {
-    if (username.isEmpty()) return ""
-    val usernameStart = scheme.length + 3 // "://".length() == 3.
-    val usernameEnd = delimiterOffset(url, usernameStart, url.length, ":@")
-    return url.substring(usernameStart, usernameEnd)
-  }
-
-  /**
-   * Returns the decoded username, or an empty string if none is present.
-   *
-   * <table summary="">
-   * <tr><th>URL</th><th>`username()`</th></tr>
-   * <tr><td>`http://host/`</td><td>`""`</td></tr>
-   * <tr><td>`http://username@host/`</td><td>`"username"`</td></tr>
-   * <tr><td>`http://username:password@host/`</td><td>`"username"`</td></tr>
-   * <tr><td>`http://a%20b:c%20d@host/`</td><td>`"a b"`</td></tr>
-   * </table>
-   */
-  fun username(): String = username
-
-  /**
-   * Returns the password, or an empty string if none is set.
-   *
-   * <table summary="">
-   * <tr><th>URL</th><th>`encodedPassword()`</th></tr>
-   * <tr><td>`http://host/`</td><td>`""`</td></tr>
-   * <tr><td>`http://username@host/`</td><td>`""`</td></tr>
-   * <tr><td>`http://username:password@host/`</td><td>`"password"`</td></tr>
-   * <tr><td>`http://a%20b:c%20d@host/`</td><td>`"c%20d"`</td></tr>
-   * </table>
-   */
-  fun encodedPassword(): String {
-    if (password.isEmpty()) return ""
-    val passwordStart = url.indexOf(':', scheme.length + 3) + 1
-    val passwordEnd = url.indexOf('@')
-    return url.substring(passwordStart, passwordEnd)
-  }
-
-  /**
-   * Returns the decoded password, or an empty string if none is present.
-   *
-   * <table summary="">
-   * <tr><th>URL</th><th>`password()`</th></tr>
-   * <tr><td>`http://host/`</td><td>`""`</td></tr>
-   * <tr><td>`http://username@host/`</td><td>`""`</td></tr>
-   * <tr><td>`http://username:password@host/`</td><td>`"password"`</td></tr>
-   * <tr><td>`http://a%20b:c%20d@host/`</td><td>`"c d"`</td></tr>
-   * </table>
-   */
-  fun password(): String = password
-
-  /**
-   * Returns the host address suitable for use with [InetAddress.getAllByName]. May be:
-   *
-   *  * A regular host name, like `android.com`.
-   *
-   *  * An IPv4 address, like `127.0.0.1`.
-   *
-   *  * An IPv6 address, like `::1`. Note that there are no square braces.
-   *
-   *  * An encoded IDN, like `xn--n3h.net`.
-   *
-   * <table summary="">
-   * <tr><th>URL</th><th>`host()`</th></tr>
-   * <tr><td>`http://android.com/`</td><td>`"android.com"`</td></tr>
-   * <tr><td>`http://127.0.0.1/`</td><td>`"127.0.0.1"`</td></tr>
-   * <tr><td>`http://[::1]/`</td><td>`"::1"`</td></tr>
-   * <tr><td>`http://xn--n3h.net/`</td><td>`"xn--n3h.net"`</td></tr>
-   * </table>
-   */
-  fun host(): String = host
-
   /**
-   * Returns the explicitly-specified port if one was provided, or the default port for this URL's
-   * scheme. For example, this returns 8443 for `https://square.com:8443/` and 443 for
-   * `https://square.com/`. The result is in `[1..65535]`.
+   * The username, or an empty string if none is set.
    *
-   * <table summary="">
-   * <tr><th>URL</th><th>`port()`</th></tr>
-   * <tr><td>`http://host/`</td><td>`80`</td></tr>
-   * <tr><td>`http://host:8000/`</td><td>`8000`</td></tr>
-   * <tr><td>`https://host/`</td><td>`443`</td></tr>
-   * </table>
+   * | URL                              | `encodedUsername()` |
+   * | :------------------------------- | :------------------ |
+   * | `http://host/`                   | `""`                |
+   * | `http://username@host/`          | `"username"`        |
+   * | `http://username:password@host/` | `"username"`        |
+   * | `http://a%20b:c%20d@host/`       | `"a%20b"`           |
    */
-  fun port(): Int = port
+  @get:JvmName("encodedUsername") val encodedUsername: String
+    get() {
+      if (username.isEmpty()) return ""
+      val usernameStart = scheme.length + 3 // "://".length() == 3.
+      val usernameEnd = url.delimiterOffset(":@", usernameStart, url.length)
+      return url.substring(usernameStart, usernameEnd)
+    }
 
   /**
-   * Returns the number of segments in this URL's path. This is also the number of slashes in the
-   * URL's path, like 3 in `http://host/a/b/c`. This is always at least 1.
+   * The password, or an empty string if none is set.
    *
-   * <table summary="">
-   * <tr><th>URL</th><th>`pathSize()`</th></tr>
-   * <tr><td>`http://host/`</td><td>`1`</td></tr>
-   * <tr><td>`http://host/a/b/c`</td><td>`3`</td></tr>
-   * <tr><td>`http://host/a/b/c/`</td><td>`4`</td></tr>
-   * </table>
+   * | URL                              | `encodedPassword()` |
+   * | :--------------------------------| :------------------ |
+   * | `http://host/`                   | `""`                |
+   * | `http://username@host/`          | `""`                |
+   * | `http://username:password@host/` | `"password"`        |
+   * | `http://a%20b:c%20d@host/`       | `"c%20d"`           |
    */
-  fun pathSize(): Int = pathSegments.size
+  @get:JvmName("encodedPassword") val encodedPassword: String
+    get() {
+      if (password.isEmpty()) return ""
+      val passwordStart = url.indexOf(':', scheme.length + 3) + 1
+      val passwordEnd = url.indexOf('@')
+      return url.substring(passwordStart, passwordEnd)
+    }
 
   /**
-   * Returns the entire path of this URL encoded for use in HTTP resource resolution. The returned
-   * path will start with `"/"`.
+   * The number of segments in this URL's path. This is also the number of slashes in this URL's
+   * path, like 3 in `http://host/a/b/c`. This is always at least 1.
    *
-   * <table summary="">
-   * <tr><th>URL</th><th>`encodedPath()`</th></tr>
-   * <tr><td>`http://host/`</td><td>`"/"`</td></tr>
-   * <tr><td>`http://host/a/b/c`</td><td>`"/a/b/c"`</td></tr>
-   * <tr><td>`http://host/a/b%20c/d`</td><td>`"/a/b%20c/d"`</td></tr>
-   * </table>
+   * | URL                  | `pathSize()` |
+   * | :------------------- | :----------- |
+   * | `http://host/`       | `1`          |
+   * | `http://host/a/b/c`  | `3`          |
+   * | `http://host/a/b/c/` | `4`          |
    */
-  fun encodedPath(): String {
-    val pathStart = url.indexOf('/', scheme.length + 3) // "://".length() == 3.
-    val pathEnd = delimiterOffset(url, pathStart, url.length, "?#")
-    return url.substring(pathStart, pathEnd)
-  }
+  @get:JvmName("pathSize") val pathSize: Int get() = pathSegments.size
 
   /**
-   * Returns a list of encoded path segments like `["a", "b", "c"]` for the URL `http://host/a/b/c`.
-   * This list is never empty though it may contain a single empty string.
+   * The entire path of this URL encoded for use in HTTP resource resolution. The returned path will
+   * start with `"/"`.
    *
-   * <table summary="">
-   * <tr><th>URL</th><th>`encodedPathSegments()`</th></tr>
-   * <tr><td>`http://host/`</td><td>`[""]`</td></tr>
-   * <tr><td>`http://host/a/b/c`</td><td>`["a", "b", "c"]`</td></tr>
-   * <tr><td>`http://host/a/b%20c/d`</td><td>`["a", "b%20c", "d"]`</td></tr>
-   * </table>
+   * | URL                     | `encodedPath()` |
+   * | :---------------------- | :-------------- |
+   * | `http://host/`          | `"/"`           |
+   * | `http://host/a/b/c`     | `"/a/b/c"`      |
+   * | `http://host/a/b%20c/d` | `"/a/b%20c/d"`  |
    */
-  fun encodedPathSegments(): List<String> {
-    val pathStart = url.indexOf('/', scheme.length + 3)
-    val pathEnd = delimiterOffset(url, pathStart, url.length, "?#")
-    val result = ArrayList<String>()
-    var i = pathStart
-    while (i < pathEnd) {
-      i++ // Skip the '/'.
-      val segmentEnd = delimiterOffset(url, i, pathEnd, '/')
-      result.add(url.substring(i, segmentEnd))
-      i = segmentEnd
+  @get:JvmName("encodedPath") val encodedPath: String
+    get() {
+      val pathStart = url.indexOf('/', scheme.length + 3) // "://".length() == 3.
+      val pathEnd = url.delimiterOffset("?#", pathStart, url.length)
+      return url.substring(pathStart, pathEnd)
     }
-    return result
-  }
 
   /**
-   * Returns a list of path segments like `["a", "b", "c"]` for the URL `http://host/a/b/c`. This
+   * A list of encoded path segments like `["a", "b", "c"]` for the URL `http://host/a/b/c`. This
    * list is never empty though it may contain a single empty string.
    *
-   * <table summary="">
-   * <tr><th>URL</th><th>`pathSegments()`</th></tr>
-   * <tr><td>`http://host/`</td><td>`[""]`</td></tr>
-   * <tr><td>`http://host/a/b/c"`</td><td>`["a", "b", "c"]`</td></tr>
-   * <tr><td>`http://host/a/b%20c/d"`</td><td>`["a", "b c", "d"]`</td></tr>
-   * </table>
+   * | URL                     | `encodedPathSegments()` |
+   * | :---------------------- | :---------------------- |
+   * | `http://host/`          | `[""]`                  |
+   * | `http://host/a/b/c`     | `["a", "b", "c"]`       |
+   * | `http://host/a/b%20c/d` | `["a", "b%20c", "d"]`   |
    */
-  fun pathSegments(): List<String> = pathSegments
+  @get:JvmName("encodedPathSegments") val encodedPathSegments: List<String>
+    get() {
+      val pathStart = url.indexOf('/', scheme.length + 3)
+      val pathEnd = url.delimiterOffset("?#", pathStart, url.length)
+      val result = mutableListOf<String>()
+      var i = pathStart
+      while (i < pathEnd) {
+        i++ // Skip the '/'.
+        val segmentEnd = url.delimiterOffset('/', i, pathEnd)
+        result.add(url.substring(i, segmentEnd))
+        i = segmentEnd
+      }
+      return result
+    }
 
   /**
-   * Returns the query of this URL, encoded for use in HTTP resource resolution. The returned string
-   * may be null (for URLs with no query), empty (for URLs with an empty query) or non-empty (all
-   * other URLs).
+   * The query of this URL, encoded for use in HTTP resource resolution. This string may be null
+   * (for URLs with no query), empty (for URLs with an empty query) or non-empty (all other URLs).
    *
-   * <table summary="">
-   * <tr><th>URL</th><th>`encodedQuery()`</th></tr>
-   * <tr><td>`http://host/`</td><td>null</td></tr>
-   * <tr><td>`http://host/?`</td><td>`""`</td></tr>
-   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`"a=apple&k=key+lime"`</td></tr>
-   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`"a=apple&a=apricot"`</td></tr>
-   * <tr><td>`http://host/?a=apple&b`</td><td>`"a=apple&b"`</td></tr>
-   * </table>
+   * | URL                               | `encodedQuery()`       |
+   * | :-------------------------------- | :--------------------- |
+   * | `http://host/`                    | null                   |
+   * | `http://host/?`                   | `""`                   |
+   * | `http://host/?a=apple&k=key+lime` | `"a=apple&k=key+lime"` |
+   * | `http://host/?a=apple&a=apricot`  | `"a=apple&a=apricot"`  |
+   * | `http://host/?a=apple&b`          | `"a=apple&b"`          |
    */
-  fun encodedQuery(): String? {
-    if (queryNamesAndValues == null) return null // No query.
-    val queryStart = url.indexOf('?') + 1
-    val queryEnd = delimiterOffset(url, queryStart, url.length, '#')
-    return url.substring(queryStart, queryEnd)
-  }
+  @get:JvmName("encodedQuery") val encodedQuery: String?
+    get() {
+      if (queryNamesAndValues == null) return null // No query.
+      val queryStart = url.indexOf('?') + 1
+      val queryEnd = url.delimiterOffset('#', queryStart, url.length)
+      return url.substring(queryStart, queryEnd)
+    }
 
   /**
-   * Returns this URL's query, like `"abc"` for `http://host/?abc`. Most callers should
-   * prefer [queryParameterName] and [queryParameterValue] because these methods offer direct access
-   * to individual query parameters.
+   * This URL's query, like `"abc"` for `http://host/?abc`. Most callers should prefer
+   * [queryParameterName] and [queryParameterValue] because these methods offer direct access to
+   * individual query parameters.
    *
-   * <table summary="">
-   * <tr><th>URL</th><th>`query()`</th></tr>
-   * <tr><td>`http://host/`</td><td>null</td></tr>
-   * <tr><td>`http://host/?`</td><td>`""`</td></tr>
-   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`"a=apple&k=key
-   * lime"`</td></tr>
-   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`"a=apple&a=apricot"`</td></tr>
-   * <tr><td>`http://host/?a=apple&b`</td><td>`"a=apple&b"`</td></tr>
-   * </table>
+   * | URL                               | `query()`              |
+   * | :-------------------------------- | :--------------------- |
+   * | `http://host/`                    | null                   |
+   * | `http://host/?`                   | `""`                   |
+   * | `http://host/?a=apple&k=key+lime` | `"a=apple&k=key lime"` |
+   * | `http://host/?a=apple&a=apricot`  | `"a=apple&a=apricot"`  |
+   * | `http://host/?a=apple&b`          | `"a=apple&b"`          |
    */
-  fun query(): String? {
-    if (queryNamesAndValues == null) return null // No query.
-    val result = StringBuilder()
-    namesAndValuesToQueryString(result, queryNamesAndValues)
-    return result.toString()
-  }
+  @get:JvmName("query") val query: String?
+    get() {
+      if (queryNamesAndValues == null) return null // No query.
+      val result = StringBuilder()
+      queryNamesAndValues.toQueryString(result)
+      return result.toString()
+    }
 
   /**
-   * Returns the number of query parameters in this URL, like 2 for `http://host/?a=apple&b=banana`.
-   * If this URL has no query this returns 0. Otherwise it returns one more than the number of `"&"`
-   * separators in the query.
+   * The number of query parameters in this URL, like 2 for `http://host/?a=apple&b=banana`. If this
+   * URL has no query this is 0. Otherwise it is one more than the number of `"&"` separators in the
+   * query.
    *
-   * <table summary="">
-   * <tr><th>URL</th><th>`querySize()`</th></tr>
-   * <tr><td>`http://host/`</td><td>`0`</td></tr>
-   * <tr><td>`http://host/?`</td><td>`1`</td></tr>
-   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`2`</td></tr>
-   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`2`</td></tr>
-   * <tr><td>`http://host/?a=apple&b`</td><td>`2`</td></tr>
-   * </table>
+   * | URL                               | `querySize()` |
+   * | :-------------------------------- | :------------ |
+   * | `http://host/`                    | `0`           |
+   * | `http://host/?`                   | `1`           |
+   * | `http://host/?a=apple&k=key+lime` | `2`           |
+   * | `http://host/?a=apple&a=apricot`  | `2`           |
+   * | `http://host/?a=apple&b`          | `2`           |
    */
-  fun querySize(): Int {
-    return if (queryNamesAndValues != null) queryNamesAndValues.size / 2 else 0
-  }
+  @get:JvmName("querySize") val querySize: Int
+    get() {
+      return if (queryNamesAndValues != null) queryNamesAndValues.size / 2 else 0
+    }
 
   /**
-   * Returns the first query parameter named `name` decoded using UTF-8, or null if there is
-   * no such query parameter.
+   * The first query parameter named `name` decoded using UTF-8, or null if there is no such query
+   * parameter.
    *
-   * <table summary="">
-   * <tr><th>URL</th><th>`queryParameter("a")`</th></tr>
-   * <tr><td>`http://host/`</td><td>null</td></tr>
-   * <tr><td>`http://host/?`</td><td>null</td></tr>
-   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`"apple"`</td></tr>
-   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`"apple"`</td></tr>
-   * <tr><td>`http://host/?a=apple&b`</td><td>`"apple"`</td></tr>
-   * </table>
+   * | URL                               | `queryParameter("a")` |
+   * | :-------------------------------- | :-------------------- |
+   * | `http://host/`                    | null                  |
+   * | `http://host/?`                   | null                  |
+   * | `http://host/?a=apple&k=key+lime` | `"apple"`             |
+   * | `http://host/?a=apple&a=apricot`  | `"apple"`             |
+   * | `http://host/?a=apple&b`          | `"apple"`             |
    */
   fun queryParameter(name: String): String? {
     if (queryNamesAndValues == null) return null
@@ -618,44 +593,43 @@ class HttpUrl internal constructor(builder: Builder) {
   }
 
   /**
-   * Returns the distinct query parameter names in this URL, like `["a", "b"]` for
-   * `http://host/?a=apple&b=banana`. If this URL has no query this returns the empty set.
+   * The distinct query parameter names in this URL, like `["a", "b"]` for
+   * `http://host/?a=apple&b=banana`. If this URL has no query this is the empty set.
    *
-   * <table summary="">
-   * <tr><th>URL</th><th>`queryParameterNames()`</th></tr>
-   * <tr><td>`http://host/`</td><td>`[]`</td></tr>
-   * <tr><td>`http://host/?`</td><td>`[""]`</td></tr>
-   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`["a", "k"]`</td></tr>
-   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`["a"]`</td></tr>
-   * <tr><td>`http://host/?a=apple&b`</td><td>`["a", "b"]`</td></tr>
-   * </table>
+   * | URL                               | `queryParameterNames()` |
+   * | :-------------------------------- | :---------------------- |
+   * | `http://host/`                    | `[]`                    |
+   * | `http://host/?`                   | `[""]`                  |
+   * | `http://host/?a=apple&k=key+lime` | `["a", "k"]`            |
+   * | `http://host/?a=apple&a=apricot`  | `["a"]`                 |
+   * | `http://host/?a=apple&b`          | `["a", "b"]`            |
    */
-  fun queryParameterNames(): Set<String> {
-    if (queryNamesAndValues == null) return emptySet()
-    val result = LinkedHashSet<String>()
-    for (i in 0 until queryNamesAndValues.size step 2) {
-      result.add(queryNamesAndValues[i]!!)
+  @get:JvmName("queryParameterNames") val queryParameterNames: Set<String>
+    get() {
+      if (queryNamesAndValues == null) return emptySet()
+      val result = LinkedHashSet<String>()
+      for (i in 0 until queryNamesAndValues.size step 2) {
+        result.add(queryNamesAndValues[i]!!)
+      }
+      return Collections.unmodifiableSet(result)
     }
-    return Collections.unmodifiableSet(result)
-  }
 
   /**
    * Returns all values for the query parameter `name` ordered by their appearance in this
    * URL. For example this returns `["banana"]` for `queryParameterValue("b")` on
    * `http://host/?a=apple&b=banana`.
    *
-   * <table summary="">
-   * <tr><th>URL</th><th>`queryParameterValues("a")`</th><th>`queryParameterValues("b")`</th></tr>
-   * <tr><td>`http://host/`</td><td>`[]`</td><td>`[]`</td></tr>
-   * <tr><td>`http://host/?`</td><td>`[]`</td><td>`[]`</td></tr>
-   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`["apple"]`</td><td>`[]`</td></tr>
-   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`["apple", "apricot"]`</td><td>`[]`</td></tr>
-   * <tr><td>`http://host/?a=apple&b`</td><td>`["apple"]`</td><td>`[null]`</td></tr>
-   * </table>
+   * | URL                               | `queryParameterValues("a")` | `queryParameterValues("b")` |
+   * | :-------------------------------- | :-------------------------- | :-------------------------- |
+   * | `http://host/`                    | `[]`                        | `[]`                        |
+   * | `http://host/?`                   | `[]`                        | `[]`                        |
+   * | `http://host/?a=apple&k=key+lime` | `["apple"]`                 | `[]`                        |
+   * | `http://host/?a=apple&a=apricot`  | `["apple", "apricot"]`      | `[]`                        |
+   * | `http://host/?a=apple&b`          | `["apple"]`                 | `[null]`                    |
    */
   fun queryParameterValues(name: String): List<String?> {
     if (queryNamesAndValues == null) return emptyList()
-    val result = ArrayList<String?>()
+    val result = mutableListOf<String?>()
     for (i in 0 until queryNamesAndValues.size step 2) {
       if (name == queryNamesAndValues[i]) {
         result.add(queryNamesAndValues[i + 1])
@@ -669,14 +643,13 @@ class HttpUrl internal constructor(builder: Builder) {
    * for `queryParameterName(0)` on `http://host/?a=apple&b=banana`. This throws if
    * `index` is not less than the [query size][querySize].
    *
-   * <table summary="">
-   * <tr><th>URL</th><th>`queryParameterName(0)`</th><th>`queryParameterName(1)`</th></tr>
-   * <tr><td>`http://host/`</td><td>exception</td><td>exception</td></tr>
-   * <tr><td>`http://host/?`</td><td>`""`</td><td>exception</td></tr>
-   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`"a"`</td><td>`"k"`</td></tr>
-   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`"a"`</td><td>`"a"`</td></tr>
-   * <tr><td>`http://host/?a=apple&b`</td><td>`"a"`</td><td>`"b"`</td></tr>
-   * </table>
+   * | URL                               | `queryParameterName(0)` | `queryParameterName(1)` |
+   * | :-------------------------------- | :---------------------- | :---------------------- |
+   * | `http://host/`                    | exception               | exception               |
+   * | `http://host/?`                   | `""`                    | exception               |
+   * | `http://host/?a=apple&k=key+lime` | `"a"`                   | `"k"`                   |
+   * | `http://host/?a=apple&a=apricot`  | `"a"`                   | `"a"`                   |
+   * | `http://host/?a=apple&b`          | `"a"`                   | `"b"`                   |
    */
   fun queryParameterName(index: Int): String {
     if (queryNamesAndValues == null) throw IndexOutOfBoundsException()
@@ -688,14 +661,13 @@ class HttpUrl internal constructor(builder: Builder) {
    * `queryParameterName(0)` on `http://host/?a=apple&b=banana`. This throws if `index` is not less
    * than the [query size][querySize].
    *
-   * <table summary="">
-   * <tr><th>URL</th><th>`queryParameterValue(0)`</th><th>`queryParameterValue(1)`</th></tr>
-   * <tr><td>`http://host/`</td><td>exception</td><td>exception</td></tr>
-   * <tr><td>`http://host/?`</td><td>null</td><td>exception</td></tr>
-   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`"apple"`</td><td>`"key lime"`</td></tr>
-   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`"apple"`</td><td>`"apricot"`</td></tr>
-   * <tr><td>`http://host/?a=apple&b`</td><td>`"apple"`</td><td>null</td></tr>
-   * </table>
+   * | URL                               | `queryParameterValue(0)` | `queryParameterValue(1)` |
+   * | :-------------------------------- | :----------------------- | :----------------------- |
+   * | `http://host/`                    | exception                | exception                |
+   * | `http://host/?`                   | null                     | exception                |
+   * | `http://host/?a=apple&k=key+lime` | `"apple"`                | `"key lime"`             |
+   * | `http://host/?a=apple&a=apricot`  | `"apple"`                | `"apricot"`              |
+   * | `http://host/?a=apple&b`          | `"apple"`                | null                     |
    */
   fun queryParameterValue(index: Int): String? {
     if (queryNamesAndValues == null) throw IndexOutOfBoundsException()
@@ -703,37 +675,23 @@ class HttpUrl internal constructor(builder: Builder) {
   }
 
   /**
-   * Returns this URL's encoded fragment, like `"abc"` for `http://host/#abc`. This returns null if
-   * the URL has no fragment.
+   * This URL's encoded fragment, like `"abc"` for `http://host/#abc`. This is null if the URL has
+   * no fragment.
    *
-   * <table summary="">
-   * <tr><th>URL</th><th>`encodedFragment()`</th></tr>
-   * <tr><td>`http://host/`</td><td>null</td></tr>
-   * <tr><td>`http://host/#`</td><td>`""`</td></tr>
-   * <tr><td>`http://host/#abc`</td><td>`"abc"`</td></tr>
-   * <tr><td>`http://host/#abc|def`</td><td>`"abc|def"`</td></tr>
-   * </table>
+   * | URL                    | `encodedFragment()` |
+   * | :--------------------- | :------------------ |
+   * | `http://host/`         | null                |
+   * | `http://host/#`        | `""`                |
+   * | `http://host/#abc`     | `"abc"`             |
+   * | `http://host/#abc|def` | `"abc|def"`         |
    */
-  fun encodedFragment(): String? {
+  @get:JvmName("encodedFragment") val encodedFragment: String?
+    get() {
     if (fragment == null) return null
     val fragmentStart = url.indexOf('#') + 1
     return url.substring(fragmentStart)
   }
 
-  /**
-   * Returns this URL's fragment, like `"abc"` for `http://host/#abc`. This returns null
-   * if the URL has no fragment.
-   *
-   * <table summary="">
-   * <tr><th>URL</th><th>`fragment()`</th></tr>
-   * <tr><td>`http://host/`</td><td>null</td></tr>
-   * <tr><td>`http://host/#`</td><td>`""`</td></tr>
-   * <tr><td>`http://host/#abc`</td><td>`"abc"`</td></tr>
-   * <tr><td>`http://host/#abc|def`</td><td>`"abc|def"`</td></tr>
-   * </table>
-   */
-  fun fragment(): String? = fragment
-
   /**
    * Returns a string with containing this URL with its username, password, query, and fragment
    * stripped, and its path replaced with `/...`. For example, redacting
@@ -759,15 +717,15 @@ class HttpUrl internal constructor(builder: Builder) {
   fun newBuilder(): Builder {
     val result = Builder()
     result.scheme = scheme
-    result.encodedUsername = encodedUsername()
-    result.encodedPassword = encodedPassword()
+    result.encodedUsername = encodedUsername
+    result.encodedPassword = encodedPassword
     result.host = host
     // If we're set to a default port, unset it in case of a scheme change.
     result.port = if (port != defaultPort(scheme)) port else -1
     result.encodedPathSegments.clear()
-    result.encodedPathSegments.addAll(encodedPathSegments())
-    result.encodedQuery(encodedQuery())
-    result.encodedFragment = encodedFragment()
+    result.encodedPathSegments.addAll(encodedPathSegments)
+    result.encodedQuery(encodedQuery)
+    result.encodedFragment = encodedFragment
     return result
   }
 
@@ -776,10 +734,10 @@ class HttpUrl internal constructor(builder: Builder) {
    * or null if the resulting URL is not well-formed.
    */
   fun newBuilder(link: String): Builder? {
-    try {
-      return Builder().parse(this, link)
-    } catch (ignored: IllegalArgumentException) {
-      return null
+    return try {
+      Builder().parse(this, link)
+    } catch (_: IllegalArgumentException) {
+      null
     }
   }
 
@@ -799,24 +757,156 @@ class HttpUrl internal constructor(builder: Builder) {
    * In general this method **should not** be used to test whether a domain is valid or routable.
    * Instead, DNS is the recommended source for that information.
    *
-   * <table summary="">
-   * <tr><th>URL</th><th>`topPrivateDomain()`</th></tr>
-   * <tr><td>`http://google.com`</td><td>`"google.com"`</td></tr>
-   * <tr><td>`http://adwords.google.co.uk`</td><td>`"google.co.uk"`</td></tr>
-   * <tr><td>`http://square`</td><td>null</td></tr>
-   * <tr><td>`http://co.uk`</td><td>null</td></tr>
-   * <tr><td>`http://localhost`</td><td>null</td></tr>
-   * <tr><td>`http://127.0.0.1`</td><td>null</td></tr>
-   * </table>
+   * | URL                           | `topPrivateDomain()` |
+   * | :---------------------------- | :------------------- |
+   * | `http://google.com`           | `"google.com"`       |
+   * | `http://adwords.google.co.uk` | `"google.co.uk"`     |
+   * | `http://square`               | null                 |
+   * | `http://co.uk`                | null                 |
+   * | `http://localhost`            | null                 |
+   * | `http://127.0.0.1`            | null                 |
    */
   fun topPrivateDomain(): String? {
-    if (verifyAsIpAddress(host)) {
-      return null
+    return if (host.canParseAsIpAddress()) {
+      null
     } else {
-      return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host)
+      PublicSuffixDatabase.get().getEffectiveTldPlusOne(host)
     }
   }
 
+  @JvmName("-deprecated_url")
+  @Deprecated(
+      message = "moved to toUrl()",
+      replaceWith = ReplaceWith(expression = "toUrl()"),
+      level = DeprecationLevel.ERROR)
+  fun url() = toUrl()
+
+  @JvmName("-deprecated_uri")
+  @Deprecated(
+      message = "moved to toUri()",
+      replaceWith = ReplaceWith(expression = "toUri()"),
+      level = DeprecationLevel.ERROR)
+  fun uri() = toUri()
+
+  @JvmName("-deprecated_scheme")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "scheme"),
+      level = DeprecationLevel.ERROR)
+  fun scheme(): String = scheme
+
+  @JvmName("-deprecated_encodedUsername")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "encodedUsername"),
+      level = DeprecationLevel.ERROR)
+  fun encodedUsername(): String = encodedUsername
+
+  @JvmName("-deprecated_username")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "username"),
+      level = DeprecationLevel.ERROR)
+  fun username(): String = username
+
+  @JvmName("-deprecated_encodedPassword")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "encodedPassword"),
+      level = DeprecationLevel.ERROR)
+  fun encodedPassword(): String = encodedPassword
+
+  @JvmName("-deprecated_password")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "password"),
+      level = DeprecationLevel.ERROR)
+  fun password(): String = password
+
+  @JvmName("-deprecated_host")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "host"),
+      level = DeprecationLevel.ERROR)
+  fun host(): String = host
+
+  @JvmName("-deprecated_port")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "port"),
+      level = DeprecationLevel.ERROR)
+  fun port(): Int = port
+
+  @JvmName("-deprecated_pathSize")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "pathSize"),
+      level = DeprecationLevel.ERROR)
+  fun pathSize(): Int = pathSize
+
+  @JvmName("-deprecated_encodedPath")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "encodedPath"),
+      level = DeprecationLevel.ERROR)
+  fun encodedPath(): String = encodedPath
+
+  @JvmName("-deprecated_encodedPathSegments")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "encodedPathSegments"),
+      level = DeprecationLevel.ERROR)
+  fun encodedPathSegments(): List<String> = encodedPathSegments
+
+  @JvmName("-deprecated_pathSegments")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "pathSegments"),
+      level = DeprecationLevel.ERROR)
+  fun pathSegments(): List<String> = pathSegments
+
+  @JvmName("-deprecated_encodedQuery")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "encodedQuery"),
+      level = DeprecationLevel.ERROR)
+  fun encodedQuery(): String? = encodedQuery
+
+  @JvmName("-deprecated_query")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "query"),
+      level = DeprecationLevel.ERROR)
+  fun query(): String? = query
+
+  @JvmName("-deprecated_querySize")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "querySize"),
+      level = DeprecationLevel.ERROR)
+  fun querySize(): Int = querySize
+
+  @JvmName("-deprecated_queryParameterNames")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "queryParameterNames"),
+      level = DeprecationLevel.ERROR)
+  fun queryParameterNames(): Set<String> = queryParameterNames
+
+  @JvmName("-deprecated_encodedFragment")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "encodedFragment"),
+      level = DeprecationLevel.ERROR)
+  fun encodedFragment(): String? = encodedFragment
+
+  @JvmName("-deprecated_fragment")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "fragment"),
+      level = DeprecationLevel.ERROR)
+  fun fragment(): String? = fragment
+
   class Builder {
     internal var scheme: String? = null
     internal var encodedUsername = ""
@@ -834,218 +924,191 @@ class HttpUrl internal constructor(builder: Builder) {
     /**
      * @param scheme either "http" or "https".
      */
-    fun scheme(scheme: String): Builder {
+    fun scheme(scheme: String) = apply {
       when {
         scheme.equals("http", ignoreCase = true) -> this.scheme = "http"
         scheme.equals("https", ignoreCase = true) -> this.scheme = "https"
         else -> throw IllegalArgumentException("unexpected scheme: $scheme")
       }
-      return this
     }
 
-    fun username(username: String): Builder {
-      this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, alreadyEncoded = false,
-              strict = false, plusIsSpace = false, asciiOnly = true)
-      return this
+    fun username(username: String) = apply {
+      this.encodedUsername = username.canonicalize(encodeSet = USERNAME_ENCODE_SET)
     }
 
-    fun encodedUsername(encodedUsername: String): Builder {
-      this.encodedUsername = canonicalize(
-          encodedUsername, USERNAME_ENCODE_SET, alreadyEncoded = true, strict = false,
-              plusIsSpace = false, asciiOnly = true)
-      return this
+    fun encodedUsername(encodedUsername: String) = apply {
+      this.encodedUsername = encodedUsername.canonicalize(
+          encodeSet = USERNAME_ENCODE_SET,
+          alreadyEncoded = true
+      )
     }
 
-    fun password(password: String): Builder {
-      this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, alreadyEncoded = false,
-              strict = false, plusIsSpace = false, asciiOnly = true)
-      return this
+    fun password(password: String) = apply {
+      this.encodedPassword = password.canonicalize(encodeSet = PASSWORD_ENCODE_SET)
     }
 
-    fun encodedPassword(encodedPassword: String): Builder {
-      this.encodedPassword = canonicalize(
-          encodedPassword, PASSWORD_ENCODE_SET, alreadyEncoded = true, strict = false,
-              plusIsSpace = false, asciiOnly = true)
-      return this
+    fun encodedPassword(encodedPassword: String) = apply {
+      this.encodedPassword = encodedPassword.canonicalize(
+          encodeSet = PASSWORD_ENCODE_SET,
+          alreadyEncoded = true
+      )
     }
 
     /**
      * @param host either a regular hostname, International Domain Name, IPv4 address, or IPv6
      * address.
      */
-    fun host(host: String): Builder {
-      val encoded = canonicalizeHost(host, 0, host.length) ?: throw IllegalArgumentException(
+    fun host(host: String) = apply {
+      val encoded = host.percentDecode().toCanonicalHost() ?: throw IllegalArgumentException(
           "unexpected host: $host")
       this.host = encoded
-      return this
     }
 
-    fun port(port: Int): Builder {
-      if (port <= 0 || port > 65535) throw IllegalArgumentException("unexpected port: $port")
+    fun port(port: Int) = apply {
+      require(port in 1..65535) { "unexpected port: $port" }
       this.port = port
-      return this
     }
 
-    internal fun effectivePort(): Int {
+    private fun effectivePort(): Int {
       return if (port != -1) port else defaultPort(scheme!!)
     }
 
-    fun addPathSegment(pathSegment: String): Builder {
+    fun addPathSegment(pathSegment: String) = apply {
       push(pathSegment, 0, pathSegment.length, addTrailingSlash = false, alreadyEncoded = false)
-      return this
     }
 
     /**
      * Adds a set of path segments separated by a slash (either `\` or `/`). If `pathSegments`
      * starts with a slash, the resulting URL will have empty path segment.
      */
-    fun addPathSegments(pathSegments: String): Builder {
-      return addPathSegments(pathSegments, false)
-    }
+    fun addPathSegments(pathSegments: String): Builder = addPathSegments(pathSegments, false)
 
-    fun addEncodedPathSegment(encodedPathSegment: String): Builder {
+    fun addEncodedPathSegment(encodedPathSegment: String) = apply {
       push(encodedPathSegment, 0, encodedPathSegment.length, addTrailingSlash = false,
-              alreadyEncoded = true)
-      return this
+          alreadyEncoded = true)
     }
 
     /**
      * Adds a set of encoded path segments separated by a slash (either `\` or `/`). If
      * `encodedPathSegments` starts with a slash, the resulting URL will have empty path segment.
      */
-    fun addEncodedPathSegments(encodedPathSegments: String): Builder {
-      return addPathSegments(encodedPathSegments, true)
-    }
+    fun addEncodedPathSegments(encodedPathSegments: String): Builder =
+        addPathSegments(encodedPathSegments, true)
 
-    private fun addPathSegments(pathSegments: String, alreadyEncoded: Boolean): Builder {
+    private fun addPathSegments(pathSegments: String, alreadyEncoded: Boolean) = apply {
       var offset = 0
       do {
-        val segmentEnd = delimiterOffset(pathSegments, offset, pathSegments.length, "/\\")
+        val segmentEnd = pathSegments.delimiterOffset("/\\", offset, pathSegments.length)
         val addTrailingSlash = segmentEnd < pathSegments.length
         push(pathSegments, offset, segmentEnd, addTrailingSlash, alreadyEncoded)
         offset = segmentEnd + 1
       } while (offset <= pathSegments.length)
-      return this
     }
 
-    fun setPathSegment(index: Int, pathSegment: String): Builder {
-      val canonicalPathSegment = canonicalize(pathSegment, 0, pathSegment.length,
-          PATH_SEGMENT_ENCODE_SET, false, false, false, true, null)
-      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
-        throw IllegalArgumentException("unexpected path segment: $pathSegment")
+    fun setPathSegment(index: Int, pathSegment: String) = apply {
+      val canonicalPathSegment = pathSegment.canonicalize(encodeSet = PATH_SEGMENT_ENCODE_SET)
+      require(!isDot(canonicalPathSegment) && !isDotDot(canonicalPathSegment)) {
+        "unexpected path segment: $pathSegment"
       }
       encodedPathSegments[index] = canonicalPathSegment
-      return this
     }
 
-    fun setEncodedPathSegment(index: Int, encodedPathSegment: String): Builder {
-      val canonicalPathSegment = canonicalize(encodedPathSegment, 0, encodedPathSegment.length,
-          PATH_SEGMENT_ENCODE_SET, true, false, false, true, null)
+    fun setEncodedPathSegment(index: Int, encodedPathSegment: String) = apply {
+      val canonicalPathSegment = encodedPathSegment.canonicalize(
+          encodeSet = PATH_SEGMENT_ENCODE_SET,
+          alreadyEncoded = true
+      )
       encodedPathSegments[index] = canonicalPathSegment
-      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
-        throw IllegalArgumentException("unexpected path segment: $encodedPathSegment")
+      require(!isDot(canonicalPathSegment) && !isDotDot(canonicalPathSegment)) {
+        "unexpected path segment: $encodedPathSegment"
       }
-      return this
     }
 
-    fun removePathSegment(index: Int): Builder {
+    fun removePathSegment(index: Int) = apply {
       encodedPathSegments.removeAt(index)
       if (encodedPathSegments.isEmpty()) {
         encodedPathSegments.add("") // Always leave at least one '/'.
       }
-      return this
     }
 
-    fun encodedPath(encodedPath: String): Builder {
-      if (!encodedPath.startsWith("/")) {
-        throw IllegalArgumentException("unexpected encodedPath: $encodedPath")
-      }
+    fun encodedPath(encodedPath: String) = apply {
+      require(encodedPath.startsWith("/")) { "unexpected encodedPath: $encodedPath" }
       resolvePath(encodedPath, 0, encodedPath.length)
-      return this
     }
 
-    fun query(query: String?): Builder {
-      this.encodedQueryNamesAndValues = if (query != null) {
-        queryStringToNamesAndValues(canonicalize(query, QUERY_ENCODE_SET, alreadyEncoded = false,
-                strict = false, plusIsSpace = true, asciiOnly = true))
-      } else {
-        null
-      }
-      return this
+    fun query(query: String?) = apply {
+      this.encodedQueryNamesAndValues = query?.canonicalize(
+          encodeSet = QUERY_ENCODE_SET,
+          plusIsSpace = true
+      )?.toQueryNamesAndValues()
     }
 
-    fun encodedQuery(encodedQuery: String?): Builder {
-      this.encodedQueryNamesAndValues = if (encodedQuery != null) {
-        queryStringToNamesAndValues(
-            canonicalize(encodedQuery, QUERY_ENCODE_SET, alreadyEncoded = true, strict = false,
-                    plusIsSpace = true, asciiOnly = true))
-      } else {
-        null
-      }
-      return this
+    fun encodedQuery(encodedQuery: String?) = apply {
+      this.encodedQueryNamesAndValues = encodedQuery?.canonicalize(
+          encodeSet = QUERY_ENCODE_SET,
+          alreadyEncoded = true,
+          plusIsSpace = true
+      )?.toQueryNamesAndValues()
     }
 
-    /** Encodes the query parameter using UTF-8 and adds it to this URL's query string.  */
-    fun addQueryParameter(name: String, value: String?): Builder {
-      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = ArrayList()
-      encodedQueryNamesAndValues!!.add(
-          canonicalize(name, QUERY_COMPONENT_ENCODE_SET, alreadyEncoded = false, strict = false,
-                  plusIsSpace = true, asciiOnly = true))
-      encodedQueryNamesAndValues!!.add(if (value != null) {
-        canonicalize(value, QUERY_COMPONENT_ENCODE_SET, alreadyEncoded = false, strict = false,
-                plusIsSpace = true, asciiOnly = true)
-      } else {
-        null
-      })
-      return this
+    /** Encodes the query parameter using UTF-8 and adds it to this URL's query string. */
+    fun addQueryParameter(name: String, value: String?) = apply {
+      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = mutableListOf()
+      encodedQueryNamesAndValues!!.add(name.canonicalize(
+          encodeSet = QUERY_COMPONENT_ENCODE_SET,
+          plusIsSpace = true
+      ))
+      encodedQueryNamesAndValues!!.add(value?.canonicalize(
+          encodeSet = QUERY_COMPONENT_ENCODE_SET,
+          plusIsSpace = true
+      ))
     }
 
-    /** Adds the pre-encoded query parameter to this URL's query string.  */
-    fun addEncodedQueryParameter(encodedName: String, encodedValue: String?): Builder {
-      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = ArrayList()
-      encodedQueryNamesAndValues!!.add(
-          canonicalize(encodedName, QUERY_COMPONENT_REENCODE_SET, alreadyEncoded = true,
-                  strict = false, plusIsSpace = true, asciiOnly = true))
-      encodedQueryNamesAndValues!!.add(if (encodedValue != null) {
-        canonicalize(encodedValue, QUERY_COMPONENT_REENCODE_SET, alreadyEncoded = true,
-                strict = false, plusIsSpace = true, asciiOnly = true)
-      } else {
-        null
-      })
-      return this
+    /** Adds the pre-encoded query parameter to this URL's query string. */
+    fun addEncodedQueryParameter(encodedName: String, encodedValue: String?) = apply {
+      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = mutableListOf()
+      encodedQueryNamesAndValues!!.add(encodedName.canonicalize(
+          encodeSet = QUERY_COMPONENT_REENCODE_SET,
+          alreadyEncoded = true,
+          plusIsSpace = true
+      ))
+      encodedQueryNamesAndValues!!.add(encodedValue?.canonicalize(
+          encodeSet = QUERY_COMPONENT_REENCODE_SET,
+          alreadyEncoded = true,
+          plusIsSpace = true
+      ))
     }
 
-    fun setQueryParameter(name: String, value: String?): Builder {
+    fun setQueryParameter(name: String, value: String?) = apply {
       removeAllQueryParameters(name)
       addQueryParameter(name, value)
-      return this
     }
 
-    fun setEncodedQueryParameter(encodedName: String, encodedValue: String?): Builder {
+    fun setEncodedQueryParameter(encodedName: String, encodedValue: String?) = apply {
       removeAllEncodedQueryParameters(encodedName)
       addEncodedQueryParameter(encodedName, encodedValue)
-      return this
     }
 
-    fun removeAllQueryParameters(name: String): Builder {
+    fun removeAllQueryParameters(name: String) = apply {
       if (encodedQueryNamesAndValues == null) return this
-      val nameToRemove = canonicalize(name, QUERY_COMPONENT_ENCODE_SET, alreadyEncoded = false,
-              strict = false, plusIsSpace = true, asciiOnly = true)
+      val nameToRemove = name.canonicalize(
+          encodeSet = QUERY_COMPONENT_ENCODE_SET,
+          plusIsSpace = true
+      )
       removeAllCanonicalQueryParameters(nameToRemove)
-      return this
     }
 
-    fun removeAllEncodedQueryParameters(encodedName: String): Builder {
+    fun removeAllEncodedQueryParameters(encodedName: String) = apply {
       if (encodedQueryNamesAndValues == null) return this
-      removeAllCanonicalQueryParameters(
-          canonicalize(encodedName, QUERY_COMPONENT_REENCODE_SET, alreadyEncoded = true,
-                  strict = false, plusIsSpace = true, asciiOnly = true))
-      return this
+      removeAllCanonicalQueryParameters(encodedName.canonicalize(
+          encodeSet = QUERY_COMPONENT_REENCODE_SET,
+          alreadyEncoded = true,
+          plusIsSpace = true
+      ))
     }
 
     private fun removeAllCanonicalQueryParameters(canonicalName: String) {
-      var i = encodedQueryNamesAndValues!!.size - 2
-      while (i >= 0) {
+      for (i in encodedQueryNamesAndValues!!.size - 2 downTo 0 step 2) {
         if (canonicalName == encodedQueryNamesAndValues!![i]) {
           encodedQueryNamesAndValues!!.removeAt(i + 1)
           encodedQueryNamesAndValues!!.removeAt(i)
@@ -1054,128 +1117,138 @@ class HttpUrl internal constructor(builder: Builder) {
             return
           }
         }
-        i -= 2
       }
     }
 
-    fun fragment(fragment: String?): Builder {
-      this.encodedFragment = if (fragment != null) {
-        canonicalize(fragment, FRAGMENT_ENCODE_SET, alreadyEncoded = false, strict = false,
-                plusIsSpace = false, asciiOnly = false)
-      } else {
-        null
-      }
-      return this
+    fun fragment(fragment: String?) = apply {
+      this.encodedFragment = fragment?.canonicalize(
+          encodeSet = FRAGMENT_ENCODE_SET,
+          unicodeAllowed = true
+      )
     }
 
-    fun encodedFragment(encodedFragment: String?): Builder {
-      this.encodedFragment = if (encodedFragment != null) {
-        canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, alreadyEncoded = true, strict = false,
-                plusIsSpace = false, asciiOnly = false)
-      } else {
-        null
-      }
-      return this
+    fun encodedFragment(encodedFragment: String?) = apply {
+      this.encodedFragment = encodedFragment?.canonicalize(
+          encodeSet = FRAGMENT_ENCODE_SET,
+          alreadyEncoded = true,
+          unicodeAllowed = true
+      )
     }
 
     /**
      * Re-encodes the components of this URL so that it satisfies (obsolete) RFC 2396, which is
      * particularly strict for certain components.
      */
-    internal fun reencodeForUri(): Builder {
+    internal fun reencodeForUri() = apply {
       for (i in 0 until encodedPathSegments.size) {
-        val pathSegment = encodedPathSegments[i]
-        encodedPathSegments[i] =
-            canonicalize(pathSegment, PATH_SEGMENT_ENCODE_SET_URI, alreadyEncoded = true,
-                    strict = true, plusIsSpace = false, asciiOnly = true)
+        encodedPathSegments[i] = encodedPathSegments[i].canonicalize(
+            encodeSet = PATH_SEGMENT_ENCODE_SET_URI,
+            alreadyEncoded = true,
+            strict = true
+        )
       }
+      val encodedQueryNamesAndValues = this.encodedQueryNamesAndValues
       if (encodedQueryNamesAndValues != null) {
-        for (i in 0 until encodedQueryNamesAndValues!!.size) {
-          val component = encodedQueryNamesAndValues!![i]
-          if (component != null) {
-            encodedQueryNamesAndValues!![i] =
-                canonicalize(component, QUERY_COMPONENT_ENCODE_SET_URI, alreadyEncoded = true,
-                        strict = true, plusIsSpace = true, asciiOnly = true)
-          }
+        for (i in 0 until encodedQueryNamesAndValues.size) {
+          encodedQueryNamesAndValues[i] = encodedQueryNamesAndValues[i]?.canonicalize(
+              encodeSet = QUERY_COMPONENT_ENCODE_SET_URI,
+              alreadyEncoded = true,
+              strict = true,
+              plusIsSpace = true
+          )
         }
       }
-      if (encodedFragment != null) {
-        encodedFragment = canonicalize(
-            encodedFragment!!, FRAGMENT_ENCODE_SET_URI, alreadyEncoded = true, strict = true,
-                plusIsSpace = false, asciiOnly = false)
-      }
-      return this
+      encodedFragment = encodedFragment?.canonicalize(
+          encodeSet = FRAGMENT_ENCODE_SET_URI,
+          alreadyEncoded = true,
+          strict = true,
+          unicodeAllowed = true
+      )
     }
 
-    fun build(): HttpUrl = HttpUrl(this)
+    fun build(): HttpUrl {
+      @Suppress("UNCHECKED_CAST") // percentDecode returns either List<String?> or List<String>.
+      return HttpUrl(
+          scheme = scheme ?: throw IllegalStateException("scheme == null"),
+          username = encodedUsername.percentDecode(),
+          password = encodedPassword.percentDecode(),
+          host = host ?: throw IllegalStateException("host == null"),
+          port = effectivePort(),
+          pathSegments = encodedPathSegments.percentDecode() as List<String>,
+          queryNamesAndValues = encodedQueryNamesAndValues?.percentDecode(plusIsSpace = true),
+          fragment = encodedFragment?.percentDecode(),
+          url = toString()
+      )
+    }
 
     override fun toString(): String {
-      val result = StringBuilder()
-      if (scheme != null) {
-        result.append(scheme)
-        result.append("://")
-      } else {
-        result.append("//")
-      }
+      return buildString {
+        if (scheme != null) {
+          append(scheme)
+          append("://")
+        } else {
+          append("//")
+        }
 
-      if (encodedUsername.isNotEmpty() || encodedPassword.isNotEmpty()) {
-        result.append(encodedUsername)
-        if (encodedPassword.isNotEmpty()) {
-          result.append(':')
-          result.append(encodedPassword)
+        if (encodedUsername.isNotEmpty() || encodedPassword.isNotEmpty()) {
+          append(encodedUsername)
+          if (encodedPassword.isNotEmpty()) {
+            append(':')
+            append(encodedPassword)
+          }
+          append('@')
         }
-        result.append('@')
-      }
 
-      if (host != null) {
-        if (host!!.indexOf(':') != -1) {
-          // Host is an IPv6 address.
-          result.append('[')
-          result.append(host)
-          result.append(']')
-        } else {
-          result.append(host)
+        if (host != null) {
+          if (':' in host!!) {
+            // Host is an IPv6 address.
+            append('[')
+            append(host)
+            append(']')
+          } else {
+            append(host)
+          }
         }
-      }
 
-      if (port != -1 || scheme != null) {
-        val effectivePort = effectivePort()
-        if (scheme == null || effectivePort != defaultPort(scheme!!)) {
-          result.append(':')
-          result.append(effectivePort)
+        if (port != -1 || scheme != null) {
+          val effectivePort = effectivePort()
+          if (scheme == null || effectivePort != defaultPort(scheme!!)) {
+            append(':')
+            append(effectivePort)
+          }
         }
-      }
 
-      pathSegmentsToString(result, encodedPathSegments)
+        encodedPathSegments.toPathString(this)
 
-      if (encodedQueryNamesAndValues != null) {
-        result.append('?')
-        namesAndValuesToQueryString(result, encodedQueryNamesAndValues!!)
-      }
+        if (encodedQueryNamesAndValues != null) {
+          append('?')
+          encodedQueryNamesAndValues!!.toQueryString(this)
+        }
 
-      if (encodedFragment != null) {
-        result.append('#')
-        result.append(encodedFragment)
+        if (encodedFragment != null) {
+          append('#')
+          append(encodedFragment)
+        }
       }
-
-      return result.toString()
     }
 
     internal fun parse(base: HttpUrl?, input: String): Builder {
-      var pos = skipLeadingAsciiWhitespace(input, 0, input.length)
-      val limit = skipTrailingAsciiWhitespace(input, pos, input.length)
+      var pos = input.indexOfFirstNonAsciiWhitespace()
+      val limit = input.indexOfLastNonAsciiWhitespace(pos)
 
       // Scheme.
       val schemeDelimiterOffset = schemeDelimiterOffset(input, pos, limit)
       if (schemeDelimiterOffset != -1) {
-        if (input.regionMatches(pos, "https:", 0, 6, ignoreCase = true)) {
-          this.scheme = "https"
-          pos += "https:".length
-        } else if (input.regionMatches(pos, "http:", 0, 5, ignoreCase = true)) {
-          this.scheme = "http"
-          pos += "http:".length
-        } else {
-          throw IllegalArgumentException("Expected URL scheme 'http' or 'https' but was '" +
+        when {
+          input.startsWith("https:", ignoreCase = true, startIndex = pos) -> {
+            this.scheme = "https"
+            pos += "https:".length
+          }
+          input.startsWith("http:", ignoreCase = true, startIndex = pos) -> {
+            this.scheme = "http"
+            pos += "http:".length
+          }
+          else -> throw IllegalArgumentException("Expected URL scheme 'http' or 'https' but was '" +
               input.substring(0, schemeDelimiterOffset) + "'")
         }
       } else if (base != null) {
@@ -1188,7 +1261,7 @@ class HttpUrl internal constructor(builder: Builder) {
       // Authority.
       var hasUsername = false
       var hasPassword = false
-      val slashCount = slashCount(input, pos, limit)
+      val slashCount = input.slashCount(pos, limit)
       if (slashCount >= 2 || base == null || base.scheme != this.scheme) {
         // Read an authority if either:
         //  * The input starts with 2 or more slashes. These follow the scheme if it exists.
@@ -1201,7 +1274,7 @@ class HttpUrl internal constructor(builder: Builder) {
         //   [username[:password]@]host[:port]
         pos += slashCount
         authority@ while (true) {
-          val componentDelimiterOffset = delimiterOffset(input, pos, limit, "@/\\?#")
+          val componentDelimiterOffset = input.delimiterOffset("@/\\?#", pos, limit)
           val c = if (componentDelimiterOffset != limit) {
             input[componentDelimiterOffset].toInt()
           } else {
@@ -1211,10 +1284,13 @@ class HttpUrl internal constructor(builder: Builder) {
             '@'.toInt() -> {
               // User info precedes.
               if (!hasPassword) {
-                val passwordColonOffset = delimiterOffset(
-                    input, pos, componentDelimiterOffset, ':')
-                val canonicalUsername = canonicalize(input, pos, passwordColonOffset,
-                    USERNAME_ENCODE_SET, true, false, false, true, null)
+                val passwordColonOffset = input.delimiterOffset(':', pos, componentDelimiterOffset)
+                val canonicalUsername = input.canonicalize(
+                    pos = pos,
+                    limit = passwordColonOffset,
+                    encodeSet = USERNAME_ENCODE_SET,
+                    alreadyEncoded = true
+                )
                 this.encodedUsername = if (hasUsername) {
                   this.encodedUsername + "%40" + canonicalUsername
                 } else {
@@ -1222,13 +1298,21 @@ class HttpUrl internal constructor(builder: Builder) {
                 }
                 if (passwordColonOffset != componentDelimiterOffset) {
                   hasPassword = true
-                  this.encodedPassword = canonicalize(input, passwordColonOffset + 1,
-                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true, null)
+                  this.encodedPassword = input.canonicalize(
+                      pos = passwordColonOffset + 1,
+                      limit = componentDelimiterOffset,
+                      encodeSet = PASSWORD_ENCODE_SET,
+                      alreadyEncoded = true
+                  )
                 }
                 hasUsername = true
               } else {
-                this.encodedPassword = this.encodedPassword + "%40" + canonicalize(input, pos,
-                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true, null)
+                this.encodedPassword = this.encodedPassword + "%40" + input.canonicalize(
+                    pos = pos,
+                    limit = componentDelimiterOffset,
+                    encodeSet = PASSWORD_ENCODE_SET,
+                    alreadyEncoded = true
+                )
               }
               pos = componentDelimiterOffset + 1
             }
@@ -1237,14 +1321,14 @@ class HttpUrl internal constructor(builder: Builder) {
               // Host info precedes.
               val portColonOffset = portColonOffset(input, pos, componentDelimiterOffset)
               if (portColonOffset + 1 < componentDelimiterOffset) {
-                host = canonicalizeHost(input, pos, portColonOffset)
+                host = input.percentDecode(pos = pos, limit = portColonOffset).toCanonicalHost()
                 port = parsePort(input, portColonOffset + 1, componentDelimiterOffset)
                 require(port != -1) {
                   "Invalid URL port: \"${input.substring(portColonOffset + 1,
                       componentDelimiterOffset)}\""
                 }
               } else {
-                host = canonicalizeHost(input, pos, portColonOffset)
+                host = input.percentDecode(pos = pos, limit = portColonOffset).toCanonicalHost()
                 port = defaultPort(scheme!!)
               }
               require(host != null) {
@@ -1257,34 +1341,44 @@ class HttpUrl internal constructor(builder: Builder) {
         }
       } else {
         // This is a relative link. Copy over all authority components. Also maybe the path & query.
-        this.encodedUsername = base.encodedUsername()
-        this.encodedPassword = base.encodedPassword()
+        this.encodedUsername = base.encodedUsername
+        this.encodedPassword = base.encodedPassword
         this.host = base.host
         this.port = base.port
         this.encodedPathSegments.clear()
-        this.encodedPathSegments.addAll(base.encodedPathSegments())
+        this.encodedPathSegments.addAll(base.encodedPathSegments)
         if (pos == limit || input[pos] == '#') {
-          encodedQuery(base.encodedQuery())
+          encodedQuery(base.encodedQuery)
         }
       }
 
       // Resolve the relative path.
-      val pathDelimiterOffset = delimiterOffset(input, pos, limit, "?#")
+      val pathDelimiterOffset = input.delimiterOffset("?#", pos, limit)
       resolvePath(input, pos, pathDelimiterOffset)
       pos = pathDelimiterOffset
 
       // Query.
       if (pos < limit && input[pos] == '?') {
-        val queryDelimiterOffset = delimiterOffset(input, pos, limit, '#')
-        this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
-            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true, null))
+        val queryDelimiterOffset = input.delimiterOffset('#', pos, limit)
+        this.encodedQueryNamesAndValues = input.canonicalize(
+            pos = pos + 1,
+            limit = queryDelimiterOffset,
+            encodeSet = QUERY_ENCODE_SET,
+            alreadyEncoded = true,
+            plusIsSpace = true
+        ).toQueryNamesAndValues()
         pos = queryDelimiterOffset
       }
 
       // Fragment.
       if (pos < limit && input[pos] == '#') {
-        this.encodedFragment = canonicalize(
-            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false, null)
+        this.encodedFragment = input.canonicalize(
+            pos = pos + 1,
+            limit = limit,
+            encodeSet = FRAGMENT_ENCODE_SET,
+            alreadyEncoded = true,
+            unicodeAllowed = true
+        )
       }
 
       return this
@@ -1311,7 +1405,7 @@ class HttpUrl internal constructor(builder: Builder) {
       // Read path segments.
       var i = pos
       while (i < limit) {
-        val pathSegmentDelimiterOffset = delimiterOffset(input, i, limit, "/\\")
+        val pathSegmentDelimiterOffset = input.delimiterOffset("/\\", i, limit)
         val segmentHasTrailingSlash = pathSegmentDelimiterOffset < limit
         push(input, i, pathSegmentDelimiterOffset, segmentHasTrailingSlash, true)
         i = pathSegmentDelimiterOffset
@@ -1319,7 +1413,7 @@ class HttpUrl internal constructor(builder: Builder) {
       }
     }
 
-    /** Adds a path segment. If the input is ".." or equivalent, this pops a path segment.  */
+    /** Adds a path segment. If the input is ".." or equivalent, this pops a path segment. */
     private fun push(
       input: String,
       pos: Int,
@@ -1327,8 +1421,12 @@ class HttpUrl internal constructor(builder: Builder) {
       addTrailingSlash: Boolean,
       alreadyEncoded: Boolean
     ) {
-      val segment = canonicalize(
-          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false, false, true, null)
+      val segment = input.canonicalize(
+          pos = pos,
+          limit = limit,
+          encodeSet = PATH_SEGMENT_ENCODE_SET,
+          alreadyEncoded = alreadyEncoded
+      )
       if (isDot(segment)) {
         return // Skip '.' path segments.
       }
@@ -1351,10 +1449,10 @@ class HttpUrl internal constructor(builder: Builder) {
     }
 
     private fun isDotDot(input: String): Boolean {
-      return (input == ".." ||
+      return input == ".." ||
           input.equals("%2e.", ignoreCase = true) ||
           input.equals(".%2e", ignoreCase = true) ||
-          input.equals("%2e%2e", ignoreCase = true))
+          input.equals("%2e%2e", ignoreCase = true)
     }
 
     /**
@@ -1385,39 +1483,33 @@ class HttpUrl internal constructor(builder: Builder) {
        * Returns the index of the ':' in `input` that is after scheme characters. Returns -1 if
        * `input` does not have a scheme that starts at `pos`.
        */
-      @JvmStatic
       private fun schemeDelimiterOffset(input: String, pos: Int, limit: Int): Int {
         if (limit - pos < 2) return -1
 
         val c0 = input[pos]
         if ((c0 < 'a' || c0 > 'z') && (c0 < 'A' || c0 > 'Z')) return -1 // Not a scheme start char.
 
-        for (i in pos + 1 until limit) {
-          val c = input[i]
-
-          if (c in 'a'..'z' ||
-            c in 'A'..'Z' ||
-            c in '0'..'9' ||
-            c == '+' ||
-            c == '-' ||
-            c == '.') {
-            continue // Scheme character. Keep going.
-          } else if (c == ':') {
-            return i // Scheme prefix!
-          } else {
-            return -1 // Non-scheme character before the first ':'.
+        characters@ for (i in pos + 1 until limit) {
+          return when (input[i]) {
+            // Scheme character. Keep going.
+            in 'a'..'z', in 'A'..'Z', in '0'..'9', '+', '-', '.' -> continue@characters
+
+            // Scheme prefix!
+            ':' -> i
+
+            // Non-scheme character before the first ':'.
+            else -> -1
           }
         }
 
         return -1 // No ':'; doesn't start with a scheme.
       }
 
-      /** Returns the number of '/' and '\' slashes in `input`, starting at `pos`.  */
-      @JvmStatic
-      private fun slashCount(input: String, pos: Int, limit: Int): Int {
+      /** Returns the number of '/' and '\' slashes in this, starting at `pos`. */
+      private fun String.slashCount(pos: Int, limit: Int): Int {
         var slashCount = 0
         for (i in pos until limit) {
-          val c = input[i]
+          val c = this[i]
           if (c == '\\' || c == '/') {
             slashCount++
           } else {
@@ -1427,8 +1519,7 @@ class HttpUrl internal constructor(builder: Builder) {
         return slashCount
       }
 
-      /** Finds the first ':' in `input`, skipping characters between square braces "[...]".  */
-      @JvmStatic
+      /** Finds the first ':' in `input`, skipping characters between square braces "[...]". */
       private fun portColonOffset(input: String, pos: Int, limit: Int): Int {
         var i = pos
         while (i < limit) {
@@ -1445,40 +1536,20 @@ class HttpUrl internal constructor(builder: Builder) {
         return limit // No colon.
       }
 
-      @JvmStatic
-      private fun canonicalizeHost(input: String, pos: Int, limit: Int): String? {
-        // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
-        // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
-        val percentDecoded = percentDecode(input, pos, limit, false)
-        return Util.canonicalizeHost(percentDecoded)
-      }
-
-      @JvmStatic
       private fun parsePort(input: String, pos: Int, limit: Int): Int {
-        try {
+        return try {
           // Canonicalize the port string to skip '\n' etc.
-          val portString = canonicalize(input, pos, limit, "", false, false, false, true, null)
+          val portString = input.canonicalize(pos = pos, limit = limit, encodeSet = "")
           val i = Integer.parseInt(portString)
-          return if (i in 1..65535) i else -1
-        } catch (e: NumberFormatException) {
-          return -1 // Invalid port.
+          if (i in 1..65535) i else -1
+        } catch (_: NumberFormatException) {
+          -1 // Invalid port.
         }
       }
     }
   }
 
-  private fun percentDecode(list: List<String?>, plusIsSpace: Boolean): List<String?> {
-    val size = list.size
-    val result = ArrayList<String?>(size)
-    for (i in 0 until size) {
-      val s = list[i]
-      result.add(if (s != null) percentDecode(s, plusIsSpace) else null)
-    }
-    return Collections.unmodifiableList(result)
-  }
-
   companion object {
-    @JvmStatic
     private val HEX_DIGITS =
         charArrayOf('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F')
     internal const val USERNAME_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#"
@@ -1503,19 +1574,19 @@ class HttpUrl internal constructor(builder: Builder) {
       }
     }
 
-    @JvmStatic
-    internal fun pathSegmentsToString(out: StringBuilder, pathSegments: List<String>) {
-      for (i in 0 until pathSegments.size) {
+    /** Returns a path string for this list of path segments. */
+    internal fun List<String>.toPathString(out: StringBuilder) {
+      for (i in 0 until size) {
         out.append('/')
-        out.append(pathSegments[i])
+        out.append(this[i])
       }
     }
 
-    @JvmStatic
-    internal fun namesAndValuesToQueryString(out: StringBuilder, namesAndValues: List<String?>) {
-      for (i in 0 until namesAndValues.size step 2) {
-        val name = namesAndValues[i]
-        val value = namesAndValues[i + 1]
+    /** Returns a string for this list of query names and values. */
+    internal fun List<String?>.toQueryString(out: StringBuilder) {
+      for (i in 0 until size step 2) {
+        val name = this[i]
+        val value = this[i + 1]
         if (i > 0) out.append('&')
         out.append(name)
         if (value != null) {
@@ -1526,25 +1597,24 @@ class HttpUrl internal constructor(builder: Builder) {
     }
 
     /**
-     * Cuts `encodedQuery` up into alternating parameter names and values. This divides a query
-     * string like `subject=math&easy&problem=5-2=3` into the list `["subject", "math", "easy",
-     * null, "problem", "5-2=3"]`. Note that values may be null and may contain '=' characters.
+     * Cuts this string up into alternating parameter names and values. This divides a query string
+     * like `subject=math&easy&problem=5-2=3` into the list `["subject", "math", "easy", null,
+     * "problem", "5-2=3"]`. Note that values may be null and may contain '=' characters.
      */
-    @JvmStatic
-    internal fun queryStringToNamesAndValues(encodedQuery: String): MutableList<String?> {
+    internal fun String.toQueryNamesAndValues(): MutableList<String?> {
       val result = mutableListOf<String?>()
       var pos = 0
-      while (pos <= encodedQuery.length) {
-        var ampersandOffset = encodedQuery.indexOf('&', pos)
-        if (ampersandOffset == -1) ampersandOffset = encodedQuery.length
+      while (pos <= length) {
+        var ampersandOffset = indexOf('&', pos)
+        if (ampersandOffset == -1) ampersandOffset = length
 
-        val equalsOffset = encodedQuery.indexOf('=', pos)
+        val equalsOffset = indexOf('=', pos)
         if (equalsOffset == -1 || equalsOffset > ampersandOffset) {
-          result.add(encodedQuery.substring(pos, ampersandOffset))
+          result.add(substring(pos, ampersandOffset))
           result.add(null) // No value for this name.
         } else {
-          result.add(encodedQuery.substring(pos, equalsOffset))
-          result.add(encodedQuery.substring(equalsOffset + 1, ampersandOffset))
+          result.add(substring(pos, equalsOffset))
+          result.add(substring(equalsOffset + 1, ampersandOffset))
         }
         pos = ampersandOffset + 1
       }
@@ -1552,65 +1622,93 @@ class HttpUrl internal constructor(builder: Builder) {
     }
 
     /**
-     * Returns a new `HttpUrl` representing `url` if it is a well-formed HTTP or HTTPS URL, or null
-     * if it isn't.
+     * Returns a new [HttpUrl] representing this.
+     *
+     * @throws IllegalArgumentException If this is not a well-formed HTTP or HTTPS URL.
      */
     @JvmStatic
-    fun parse(url: String): HttpUrl? {
-      try {
-        return get(url)
-      } catch (ignored: IllegalArgumentException) {
-        return null
-      }
-    }
+    @JvmName("get") fun String.toHttpUrl(): HttpUrl = Builder().parse(null, this).build()
 
     /**
-     * Returns a new `HttpUrl` representing `url`.
-     *
-     * @throws IllegalArgumentException If `url` is not a well-formed HTTP or HTTPS URL.
+     * Returns a new `HttpUrl` representing `url` if it is a well-formed HTTP or HTTPS URL, or null
+     * if it isn't.
      */
     @JvmStatic
-    fun get(url: String): HttpUrl = Builder().parse(null, url).build()
+    @JvmName("parse") fun String.toHttpUrlOrNull(): HttpUrl? {
+      return try {
+        toHttpUrl()
+      } catch (_: IllegalArgumentException) {
+        null
+      }
+    }
 
     /**
-     * Returns an [HttpUrl] for `url` if its protocol is `http` or `https`, or
-     * null if it has any other protocol.
+     * Returns an [HttpUrl] for this if its protocol is `http` or `https`, or null if it has any
+     * other protocol.
      */
     @JvmStatic
-    fun get(url: URL): HttpUrl? = parse(url.toString())
-
-    @JvmStatic
-    fun get(uri: URI): HttpUrl? = parse(uri.toString())
+    @JvmName("get") fun URL.toHttpUrlOrNull(): HttpUrl? = toString().toHttpUrlOrNull()
 
     @JvmStatic
-    internal fun percentDecode(encoded: String, plusIsSpace: Boolean): String =
-        percentDecode(encoded, 0, encoded.length, plusIsSpace)
-
-    @JvmStatic
-    internal fun percentDecode(
-      encoded: String,
-      pos: Int,
-      limit: Int,
-      plusIsSpace: Boolean
+    @JvmName("get") fun URI.toHttpUrlOrNull(): HttpUrl? = toString().toHttpUrlOrNull()
+
+    @JvmName("-deprecated_get")
+    @Deprecated(
+        message = "moved to extension function",
+        replaceWith = ReplaceWith(
+            expression = "url.toHttpUrl()",
+            imports = ["okhttp3.HttpUrl.Companion.toHttpUrl"]),
+        level = DeprecationLevel.ERROR)
+    fun get(url: String): HttpUrl = url.toHttpUrl()
+
+    @JvmName("-deprecated_parse")
+    @Deprecated(
+        message = "moved to extension function",
+        replaceWith = ReplaceWith(
+            expression = "url.toHttpUrlOrNull()",
+            imports = ["okhttp3.HttpUrl.Companion.toHttpUrlOrNull"]),
+        level = DeprecationLevel.ERROR)
+    fun parse(url: String): HttpUrl? = url.toHttpUrlOrNull()
+
+    @JvmName("-deprecated_get")
+    @Deprecated(
+        message = "moved to extension function",
+        replaceWith = ReplaceWith(
+            expression = "url.toHttpUrlOrNull()",
+            imports = ["okhttp3.HttpUrl.Companion.toHttpUrlOrNull"]),
+        level = DeprecationLevel.ERROR)
+    fun get(url: URL): HttpUrl? = url.toHttpUrlOrNull()
+
+    @JvmName("-deprecated_get")
+    @Deprecated(
+        message = "moved to extension function",
+        replaceWith = ReplaceWith(
+            expression = "uri.toHttpUrlOrNull()",
+            imports = ["okhttp3.HttpUrl.Companion.toHttpUrlOrNull"]),
+        level = DeprecationLevel.ERROR)
+    fun get(uri: URI): HttpUrl? = uri.toHttpUrlOrNull()
+
+    internal fun String.percentDecode(
+      pos: Int = 0,
+      limit: Int = length,
+      plusIsSpace: Boolean = false
     ): String {
       for (i in pos until limit) {
-        val c = encoded[i]
+        val c = this[i]
         if (c == '%' || c == '+' && plusIsSpace) {
           // Slow path: the character at i requires decoding!
           val out = Buffer()
-          out.writeUtf8(encoded, pos, i)
-          percentDecode(out, encoded, i, limit, plusIsSpace)
+          out.writeUtf8(this, pos, i)
+          out.writePercentDecoded(this, pos = i, limit = limit, plusIsSpace = plusIsSpace)
           return out.readUtf8()
         }
       }
 
       // Fast path: no characters in [pos..limit) required decoding.
-      return encoded.substring(pos, limit)
+      return substring(pos, limit)
     }
 
-    @JvmStatic
-    internal fun percentDecode(
-      out: Buffer,
+    private fun Buffer.writePercentDecoded(
       encoded: String,
       pos: Int,
       limit: Int,
@@ -1621,30 +1719,38 @@ class HttpUrl internal constructor(builder: Builder) {
       while (i < limit) {
         codePoint = encoded.codePointAt(i)
         if (codePoint == '%'.toInt() && i + 2 < limit) {
-          val d1 = decodeHexDigit(encoded[i + 1])
-          val d2 = decodeHexDigit(encoded[i + 2])
+          val d1 = encoded[i + 1].parseHexDigit()
+          val d2 = encoded[i + 2].parseHexDigit()
           if (d1 != -1 && d2 != -1) {
-            out.writeByte((d1 shl 4) + d2)
+            writeByte((d1 shl 4) + d2)
             i += 2
             i += Character.charCount(codePoint)
             continue
           }
         } else if (codePoint == '+'.toInt() && plusIsSpace) {
-          out.writeByte(' '.toInt())
+          writeByte(' '.toInt())
           i++
           continue
         }
-        out.writeUtf8CodePoint(codePoint)
+        writeUtf8CodePoint(codePoint)
         i += Character.charCount(codePoint)
       }
     }
 
-    @JvmStatic
-    internal fun percentEncoded(encoded: String, pos: Int, limit: Int): Boolean {
-      return (pos + 2 < limit &&
-          encoded[pos] == '%' &&
-          decodeHexDigit(encoded[pos + 1]) != -1 &&
-          decodeHexDigit(encoded[pos + 2]) != -1)
+    private fun List<String?>.percentDecode(plusIsSpace: Boolean = false): List<String?> {
+      val size = size
+      val result = ArrayList<String?>(size)
+      for (i in this) {
+        result.add(i?.percentDecode(plusIsSpace = plusIsSpace))
+      }
+      return Collections.unmodifiableList(result)
+    }
+
+    private fun String.isPercentEncoded(pos: Int, limit: Int): Boolean {
+      return pos + 2 < limit &&
+          this[pos] == '%' &&
+          this[pos + 1].parseHexDigit() != -1 &&
+          this[pos + 2].parseHexDigit() != -1
     }
 
     /**
@@ -1664,49 +1770,54 @@ class HttpUrl internal constructor(builder: Builder) {
      * @param alreadyEncoded true to leave '%' as-is; false to convert it to '%25'.
      * @param strict true to encode '%' if it is not the prefix of a valid percent encoding.
      * @param plusIsSpace true to encode '+' as "%2B" if it is not already encoded.
-     * @param asciiOnly true to encode all non-ASCII codepoints.
+     * @param unicodeAllowed true to leave non-ASCII codepoint unencoded.
      * @param charset which charset to use, null equals UTF-8.
      */
-    @JvmStatic
-    internal fun canonicalize(
-      input: String,
-      pos: Int,
-      limit: Int,
+    internal fun String.canonicalize(
+      pos: Int = 0,
+      limit: Int = length,
       encodeSet: String,
-      alreadyEncoded: Boolean,
-      strict: Boolean,
-      plusIsSpace: Boolean,
-      asciiOnly: Boolean,
-      charset: Charset?
+      alreadyEncoded: Boolean = false,
+      strict: Boolean = false,
+      plusIsSpace: Boolean = false,
+      unicodeAllowed: Boolean = false,
+      charset: Charset? = null
     ): String {
       var codePoint: Int
       var i = pos
       while (i < limit) {
-        codePoint = input.codePointAt(i)
+        codePoint = codePointAt(i)
         if (codePoint < 0x20 ||
             codePoint == 0x7f ||
-            codePoint >= 0x80 && asciiOnly ||
-            encodeSet.indexOf(codePoint.toChar()) != -1 ||
-            codePoint == '%'.toInt() && (!alreadyEncoded || strict && !percentEncoded(input, i,
-                limit)) ||
+            codePoint >= 0x80 && !unicodeAllowed ||
+            codePoint.toChar() in encodeSet ||
+            codePoint == '%'.toInt() &&
+            (!alreadyEncoded || strict && !isPercentEncoded(i, limit)) ||
             codePoint == '+'.toInt() && plusIsSpace) {
           // Slow path: the character at i requires encoding!
           val out = Buffer()
-          out.writeUtf8(input, pos, i)
-          canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, strict, plusIsSpace,
-              asciiOnly, charset)
+          out.writeUtf8(this, pos, i)
+          out.writeCanonicalized(
+              input = this,
+              pos = i,
+              limit = limit,
+              encodeSet = encodeSet,
+              alreadyEncoded = alreadyEncoded,
+              strict = strict,
+              plusIsSpace = plusIsSpace,
+              unicodeAllowed = unicodeAllowed,
+              charset = charset
+          )
           return out.readUtf8()
         }
         i += Character.charCount(codePoint)
       }
 
       // Fast path: no characters in [pos..limit) required encoding.
-      return input.substring(pos, limit)
+      return substring(pos, limit)
     }
 
-    @JvmStatic
-    internal fun canonicalize(
-      out: Buffer,
+    private fun Buffer.writeCanonicalized(
       input: String,
       pos: Int,
       limit: Int,
@@ -1714,7 +1825,7 @@ class HttpUrl internal constructor(builder: Builder) {
       alreadyEncoded: Boolean,
       strict: Boolean,
       plusIsSpace: Boolean,
-      asciiOnly: Boolean,
+      unicodeAllowed: Boolean,
       charset: Charset?
     ) {
       var encodedCharBuffer: Buffer? = null // Lazily allocated.
@@ -1722,17 +1833,18 @@ class HttpUrl internal constructor(builder: Builder) {
       var i = pos
       while (i < limit) {
         codePoint = input.codePointAt(i)
-        if (alreadyEncoded && (codePoint == '\t'.toInt() || codePoint == '\n'.toInt() || codePoint == '\u000c'.toInt() || codePoint == '\r'.toInt())) {
+        if (alreadyEncoded && (codePoint == '\t'.toInt() || codePoint == '\n'.toInt() ||
+                codePoint == '\u000c'.toInt() || codePoint == '\r'.toInt())) {
           // Skip this character.
         } else if (codePoint == '+'.toInt() && plusIsSpace) {
           // Encode '+' as '%2B' since we permit ' ' to be encoded as either '+' or '%20'.
-          out.writeUtf8(if (alreadyEncoded) "+" else "%2B")
+          writeUtf8(if (alreadyEncoded) "+" else "%2B")
         } else if (codePoint < 0x20 ||
             codePoint == 0x7f ||
-            codePoint >= 0x80 && asciiOnly ||
-            encodeSet.indexOf(codePoint.toChar()) != -1 ||
-            codePoint == '%'.toInt() && (!alreadyEncoded || strict && !percentEncoded(input, i,
-                limit))) {
+            codePoint >= 0x80 && !unicodeAllowed ||
+            codePoint.toChar() in encodeSet ||
+            codePoint == '%'.toInt() &&
+            (!alreadyEncoded || strict && !input.isPercentEncoded(i, limit))) {
           // Percent encode this character.
           if (encodedCharBuffer == null) {
             encodedCharBuffer = Buffer()
@@ -1746,39 +1858,16 @@ class HttpUrl internal constructor(builder: Builder) {
 
           while (!encodedCharBuffer.exhausted()) {
             val b = encodedCharBuffer.readByte().toInt() and 0xff
-            out.writeByte('%'.toInt())
-            out.writeByte(HEX_DIGITS[b shr 4 and 0xf].toInt())
-            out.writeByte(HEX_DIGITS[b and 0xf].toInt())
+            writeByte('%'.toInt())
+            writeByte(HEX_DIGITS[b shr 4 and 0xf].toInt())
+            writeByte(HEX_DIGITS[b and 0xf].toInt())
           }
         } else {
           // This character doesn't need encoding. Just copy it over.
-          out.writeUtf8CodePoint(codePoint)
+          writeUtf8CodePoint(codePoint)
         }
         i += Character.charCount(codePoint)
       }
     }
-
-    @JvmStatic
-    internal fun canonicalize(
-      input: String,
-      encodeSet: String,
-      alreadyEncoded: Boolean,
-      strict: Boolean,
-      plusIsSpace: Boolean,
-      asciiOnly: Boolean,
-      charset: Charset?
-    ): String = canonicalize(input, 0, input.length, encodeSet, alreadyEncoded, strict, plusIsSpace,
-        asciiOnly, charset)
-
-    @JvmStatic
-    internal fun canonicalize(
-      input: String,
-      encodeSet: String,
-      alreadyEncoded: Boolean,
-      strict: Boolean,
-      plusIsSpace: Boolean,
-      asciiOnly: Boolean
-    ): String = canonicalize(
-        input, 0, input.length, encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly, null)
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Interceptor.kt b/okhttp/src/main/java/okhttp3/Interceptor.kt
index 43739a90b2..2452cff367 100644
--- a/okhttp/src/main/java/okhttp3/Interceptor.kt
+++ b/okhttp/src/main/java/okhttp3/Interceptor.kt
@@ -28,13 +28,20 @@ interface Interceptor {
   fun intercept(chain: Chain): Response
 
   companion object {
-    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
-    @JvmName("-deprecated_Interceptor")
-    inline operator fun invoke(
-      crossinline block: (chain: Chain) -> Response
-    ): Interceptor = object : Interceptor {
-      override fun intercept(chain: Chain) = block(chain)
-    }
+    /**
+     * Constructs an interceptor for a lambda. This compact syntax is most useful for inline
+     * interceptors.
+     *
+     * ```
+     * val interceptor = Interceptor { chain: Interceptor.Chain ->
+     *     chain.proceed(chain.request())
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (chain: Chain) -> Response): Interceptor =
+        object : Interceptor {
+          override fun intercept(chain: Chain) = block(chain)
+        }
   }
 
   interface Chain {
diff --git a/okhttp/src/main/java/okhttp3/MediaType.kt b/okhttp/src/main/java/okhttp3/MediaType.kt
index d628a4aac6..d50a09c34a 100644
--- a/okhttp/src/main/java/okhttp3/MediaType.kt
+++ b/okhttp/src/main/java/okhttp3/MediaType.kt
@@ -27,43 +27,56 @@ import java.util.regex.Pattern
  */
 class MediaType private constructor(
   private val mediaType: String,
-  val type: String,
-  val subtype: String,
+
+  /**
+   * Returns the high-level media type, such as "text", "image", "audio", "video", or "application".
+   */
+  @get:JvmName("type") val type: String,
+
+  /**
+   * Returns a specific media subtype, such as "plain" or "png", "mpeg", "mp4" or "xml".
+   */
+  @get:JvmName("subtype") val subtype: String,
+
   private val charset: String?
 ) {
+
   /**
-   * Returns the charset of this media type, or `defaultValue` if either this media type
-   * doesn't specify a charset, of it its charset is unsupported by the current runtime.
+   * Returns the charset of this media type, or [defaultValue] if either this media type doesn't
+   * specify a charset, of it its charset is unsupported by the current runtime.
    */
   @JvmOverloads
   fun charset(defaultValue: Charset? = null): Charset? {
-      return try {
-          if (charset != null) Charset.forName(charset) else defaultValue
-      } catch (e: IllegalArgumentException) {
-          defaultValue // This charset is invalid or unsupported. Give up.
-      }
+    return try {
+      if (charset != null) Charset.forName(charset) else defaultValue
+    } catch (_: IllegalArgumentException) {
+      defaultValue // This charset is invalid or unsupported. Give up.
+    }
   }
 
-  /**
-   * Returns the high-level media type, such as "text", "image", "audio", "video", or
-   * "application".
-   */
+  @JvmName("-deprecated_type")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "type"),
+      level = DeprecationLevel.ERROR)
   fun type() = type
 
-  /**
-   * Returns a specific media subtype, such as "plain" or "png", "mpeg", "mp4" or "xml".
-   */
+  @JvmName("-deprecated_subtype")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "subtype"),
+      level = DeprecationLevel.ERROR)
   fun subtype() = subtype
 
   /**
    * Returns the encoded media type, like "text/plain; charset=utf-8", appropriate for use in a
    * Content-Type header.
    */
-  override fun toString(): String = mediaType
+  override fun toString() = mediaType
 
-  override fun equals(other: Any?): Boolean = other is MediaType && other.mediaType == mediaType
+  override fun equals(other: Any?) = other is MediaType && other.mediaType == mediaType
 
-  override fun hashCode(): Int = mediaType.hashCode()
+  override fun hashCode() = mediaType.hashCode()
 
   companion object {
     private const val TOKEN = "([a-zA-Z0-9-!#$%&'*+.^_`{|}~]+)"
@@ -72,24 +85,25 @@ class MediaType private constructor(
     private val PARAMETER = Pattern.compile(";\\s*(?:$TOKEN=(?:$TOKEN|$QUOTED))?")
 
     /**
-     * Returns a media type for `string`.
+     * Returns a media type for this string.
      *
-     * @throws IllegalArgumentException if `string` is not a well-formed media type.
+     * @throws IllegalArgumentException if this is not a well-formed media type.
      */
     @JvmStatic
-    fun get(string: String): MediaType {
-      val typeSubtype = TYPE_SUBTYPE.matcher(string)
-      require(typeSubtype.lookingAt()) { "No subtype found for: \"$string\"" }
+    @JvmName("get")
+    fun String.toMediaType(): MediaType {
+      val typeSubtype = TYPE_SUBTYPE.matcher(this)
+      require(typeSubtype.lookingAt()) { "No subtype found for: \"$this\"" }
       val type = typeSubtype.group(1).toLowerCase(Locale.US)
       val subtype = typeSubtype.group(2).toLowerCase(Locale.US)
 
       var charset: String? = null
-      val parameter = PARAMETER.matcher(string)
+      val parameter = PARAMETER.matcher(this)
       var s = typeSubtype.end()
-      while (s < string.length) {
-        parameter.region(s, string.length)
+      while (s < length) {
+        parameter.region(s, length)
         require(parameter.lookingAt()) {
-          "Parameter is not formatted correctly: \"${string.substring(s)}\" for: \"$string\""
+          "Parameter is not formatted correctly: \"${substring(s)}\" for: \"$this\""
         }
 
         val name = parameter.group(1)
@@ -111,23 +125,42 @@ class MediaType private constructor(
           else -> token
         }
         require(charset == null || charsetParameter.equals(charset, ignoreCase = true)) {
-          "Multiple charsets defined: \"$charset\" and: \"$charsetParameter\" for: \"$string\""
+          "Multiple charsets defined: \"$charset\" and: \"$charsetParameter\" for: \"$this\""
         }
         charset = charsetParameter
         s = parameter.end()
       }
 
-      return MediaType(string, type, subtype, charset)
+      return MediaType(this, type, subtype, charset)
     }
 
-    /** Returns a media type for `string`, or null if `string` is not a well-formed media type. */
+    /** Returns a media type for this, or null if this is not a well-formed media type. */
     @JvmStatic
-    fun parse(string: String): MediaType? {
-        return try {
-            get(string)
-        } catch (ignored: IllegalArgumentException) {
-            null
-        }
+    @JvmName("parse")
+    fun String.toMediaTypeOrNull(): MediaType? {
+      return try {
+        toMediaType()
+      } catch (_: IllegalArgumentException) {
+        null
+      }
     }
+
+    @JvmName("-deprecated_get")
+    @Deprecated(
+        message = "moved to extension function",
+        replaceWith = ReplaceWith(
+            expression = "mediaType.toMediaType()",
+            imports = ["okhttp3.MediaType.Companion.toMediaType"]),
+        level = DeprecationLevel.ERROR)
+    fun get(mediaType: String): MediaType = mediaType.toMediaType()
+
+    @JvmName("-deprecated_parse")
+    @Deprecated(
+        message = "moved to extension function",
+        replaceWith = ReplaceWith(
+            expression = "mediaType.toMediaTypeOrNull()",
+            imports = ["okhttp3.MediaType.Companion.toMediaTypeOrNull"]),
+        level = DeprecationLevel.ERROR)
+    fun parse(mediaType: String): MediaType? = mediaType.toMediaTypeOrNull()
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.kt b/okhttp/src/main/java/okhttp3/MultipartBody.kt
index 1e7bc4e8a2..abf62fbe59 100644
--- a/okhttp/src/main/java/okhttp3/MultipartBody.kt
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.kt
@@ -15,7 +15,8 @@
  */
 package okhttp3
 
-import okhttp3.internal.Util
+import okhttp3.MediaType.Companion.toMediaType
+import okhttp3.internal.toImmutableList
 import okio.Buffer
 import okio.BufferedSink
 import okio.ByteString
@@ -28,29 +29,55 @@ import java.util.UUID
  *
  * [rfc_2387]: http://www.ietf.org/rfc/rfc2387.txt
  */
+@Suppress("NAME_SHADOWING")
 class MultipartBody internal constructor(
-  private val boundary: ByteString,
-  private val originalType: MediaType,
-  parts: List<Part>
+  private val boundaryByteString: ByteString,
+  @get:JvmName("type") val type: MediaType,
+  @get:JvmName("parts") val parts: List<Part>
 ) : RequestBody() {
-  private val contentType: MediaType = MediaType.get("$originalType; boundary=${boundary.utf8()}")
-  private val parts: List<Part> = Util.immutableList(parts)
+  private val contentType: MediaType = "$type; boundary=$boundary".toMediaType()
   private var contentLength = -1L
 
-  fun type(): MediaType = originalType
+  @get:JvmName("boundary") val boundary: String
+    get() = boundaryByteString.utf8()
 
-  fun boundary(): String = boundary.utf8()
-
-  /** The number of parts in this multipart body.  */
-  fun size(): Int = parts.size
-
-  fun parts(): List<Part> = parts
+  /** The number of parts in this multipart body. */
+  @get:JvmName("size") val size: Int
+    get() = parts.size
 
   fun part(index: Int): Part = parts[index]
 
-  /** A combination of [type] and [boundary].  */
+  /** A combination of [type] and [boundaryByteString]. */
   override fun contentType(): MediaType = contentType
 
+  @JvmName("-deprecated_type")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "type"),
+      level = DeprecationLevel.ERROR)
+  fun type(): MediaType = type
+
+  @JvmName("-deprecated_boundary")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "boundary"),
+      level = DeprecationLevel.ERROR)
+  fun boundary(): String = boundary
+
+  @JvmName("-deprecated_size")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "size"),
+      level = DeprecationLevel.ERROR)
+  fun size(): Int = size
+
+  @JvmName("-deprecated_parts")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "parts"),
+      level = DeprecationLevel.ERROR)
+  fun parts(): List<Part> = parts
+
   @Throws(IOException::class)
   override fun contentLength(): Long {
     var result = contentLength
@@ -92,11 +119,11 @@ class MultipartBody internal constructor(
       val body = part.body
 
       sink!!.write(DASHDASH)
-      sink.write(boundary)
+      sink.write(boundaryByteString)
       sink.write(CRLF)
 
       if (headers != null) {
-        for (h in 0 until headers.size()) {
+        for (h in 0 until headers.size) {
           sink.writeUtf8(headers.name(h))
               .write(COLONSPACE)
               .writeUtf8(headers.value(h))
@@ -134,7 +161,7 @@ class MultipartBody internal constructor(
     }
 
     sink!!.write(DASHDASH)
-    sink.write(boundary)
+    sink.write(boundaryByteString)
     sink.write(DASHDASH)
     sink.write(CRLF)
 
@@ -146,10 +173,23 @@ class MultipartBody internal constructor(
     return byteCount
   }
 
-  class Part private constructor(internal val headers: Headers?, internal val body: RequestBody) {
+  class Part private constructor(
+    @get:JvmName("headers") val headers: Headers?,
+    @get:JvmName("body") val body: RequestBody
+  ) {
 
+    @JvmName("-deprecated_headers")
+    @Deprecated(
+        message = "moved to val",
+        replaceWith = ReplaceWith(expression = "headers"),
+        level = DeprecationLevel.ERROR)
     fun headers(): Headers? = headers
 
+    @JvmName("-deprecated_body")
+    @Deprecated(
+        message = "moved to val",
+        replaceWith = ReplaceWith(expression = "body"),
+        level = DeprecationLevel.ERROR)
     fun body(): RequestBody = body
 
     companion object {
@@ -165,20 +205,22 @@ class MultipartBody internal constructor(
 
       @JvmStatic
       fun createFormData(name: String, value: String): Part =
-          createFormData(name, null, RequestBody.create(null, value))
+          createFormData(name, null, value.toRequestBody())
 
       @JvmStatic
       fun createFormData(name: String, filename: String?, body: RequestBody): Part {
-        val disposition = StringBuilder("form-data; name=")
-        disposition.appendQuotedString(name)
-
-        if (filename != null) {
-          disposition.append("; filename=")
-          disposition.appendQuotedString(filename)
+        val disposition = buildString {
+          append("form-data; name=")
+          appendQuotedString(name)
+
+          if (filename != null) {
+            append("; filename=")
+            appendQuotedString(filename)
+          }
         }
 
         val headers = Headers.Builder()
-            .addUnsafeNonAscii("Content-Disposition", disposition.toString())
+            .addUnsafeNonAscii("Content-Disposition", disposition)
             .build()
 
         return create(headers, body)
@@ -196,39 +238,39 @@ class MultipartBody internal constructor(
      * [DIGEST], [PARALLEL] and [FORM].
      */
     fun setType(type: MediaType) = apply {
-      require(type.type() == "multipart") { "multipart != $type" }
+      require(type.type == "multipart") { "multipart != $type" }
       this.type = type
     }
 
-    /** Add a part to the body.  */
+    /** Add a part to the body. */
     fun addPart(body: RequestBody) = apply {
       addPart(Part.create(body))
     }
 
-    /** Add a part to the body.  */
+    /** Add a part to the body. */
     fun addPart(headers: Headers?, body: RequestBody) = apply {
       addPart(Part.create(headers, body))
     }
 
-    /** Add a form data part to the body.  */
+    /** Add a form data part to the body. */
     fun addFormDataPart(name: String, value: String) = apply {
       addPart(Part.createFormData(name, value))
     }
 
-    /** Add a form data part to the body.  */
+    /** Add a form data part to the body. */
     fun addFormDataPart(name: String, filename: String?, body: RequestBody) = apply {
       addPart(Part.createFormData(name, filename, body))
     }
 
-    /** Add a part to the body.  */
+    /** Add a part to the body. */
     fun addPart(part: Part) = apply {
-      parts.add(part)
+      parts += part
     }
 
-    /** Assemble the specified parts into a request body.  */
+    /** Assemble the specified parts into a request body. */
     fun build(): MultipartBody {
       check(parts.isNotEmpty()) { "Multipart body must have at least one part." }
-      return MultipartBody(boundary, type, parts)
+      return MultipartBody(boundary, type, parts.toImmutableList())
     }
   }
 
@@ -239,7 +281,7 @@ class MultipartBody internal constructor(
      * does not recognize must be treated as being of subtype "mixed".
      */
     @JvmField
-    val MIXED = MediaType.get("multipart/mixed")
+    val MIXED = "multipart/mixed".toMediaType()
 
     /**
      * The "multipart/alternative" type is syntactically identical to "multipart/mixed", but the
@@ -247,7 +289,7 @@ class MultipartBody internal constructor(
      * the same information.
      */
     @JvmField
-    val ALTERNATIVE = MediaType.get("multipart/alternative")
+    val ALTERNATIVE = "multipart/alternative".toMediaType()
 
     /**
      * This type is syntactically identical to "multipart/mixed", but the semantics are different.
@@ -255,14 +297,14 @@ class MultipartBody internal constructor(
      * "text/plain" to "message/rfc822".
      */
     @JvmField
-    val DIGEST = MediaType.get("multipart/digest")
+    val DIGEST = "multipart/digest".toMediaType()
 
     /**
      * This type is syntactically identical to "multipart/mixed", but the semantics are different.
      * In particular, in a parallel entity, the order of body parts is not significant.
      */
     @JvmField
-    val PARALLEL = MediaType.get("multipart/parallel")
+    val PARALLEL = "multipart/parallel".toMediaType()
 
     /**
      * The media-type multipart/form-data follows the rules of all multipart MIME data streams as
@@ -270,7 +312,7 @@ class MultipartBody internal constructor(
      * fills out the form. Each field has a name. Within a given form, the names are unique.
      */
     @JvmField
-    val FORM = MediaType.get("multipart/form-data")
+    val FORM = "multipart/form-data".toMediaType()
 
     private val COLONSPACE = byteArrayOf(':'.toByte(), ' '.toByte())
     private val CRLF = byteArrayOf('\r'.toByte(), '\n'.toByte())
@@ -289,8 +331,7 @@ class MultipartBody internal constructor(
     internal fun StringBuilder.appendQuotedString(key: String) {
       append('"')
       for (i in 0 until key.length) {
-        val ch = key[i]
-        when (ch) {
+        when (val ch = key[i]) {
           '\n' -> append("%0A")
           '\r' -> append("%0D")
           '"' -> append("%22")
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.kt b/okhttp/src/main/java/okhttp3/OkHttpClient.kt
index 3ddc869b99..009f303cf9 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.kt
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.kt
@@ -17,15 +17,14 @@ package okhttp3
 
 import okhttp3.Protocol.HTTP_1_1
 import okhttp3.Protocol.HTTP_2
-import okhttp3.internal.Internal
-import okhttp3.internal.Util
-import okhttp3.internal.Util.checkDuration
-import okhttp3.internal.cache.InternalCache
-import okhttp3.internal.connection.Exchange
+import okhttp3.internal.asFactory
+import okhttp3.internal.checkDuration
+import okhttp3.internal.immutableListOf
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.proxy.NullProxySelector
 import okhttp3.internal.tls.CertificateChainCleaner
 import okhttp3.internal.tls.OkHostnameVerifier
+import okhttp3.internal.toImmutableList
 import okhttp3.internal.ws.RealWebSocket
 import okio.Sink
 import okio.Source
@@ -44,7 +43,6 @@ import javax.net.ssl.HostnameVerifier
 import javax.net.ssl.SSLSocketFactory
 import javax.net.ssl.TrustManager
 import javax.net.ssl.X509TrustManager
-import kotlin.DeprecationLevel.ERROR
 
 /**
  * Factory for [calls][Call], which can be used to send HTTP requests and read their responses.
@@ -121,382 +119,492 @@ import kotlin.DeprecationLevel.ERROR
 open class OkHttpClient internal constructor(
   builder: Builder
 ) : Cloneable, Call.Factory, WebSocket.Factory {
-  private val dispatcher: Dispatcher = builder.dispatcher
-  private val proxy: Proxy? = builder.proxy
-  private val protocols: List<Protocol> = builder.protocols
-  private val connectionSpecs: List<ConnectionSpec> = builder.connectionSpecs
-  private val interceptors: List<Interceptor> =
-      Util.immutableList(builder.interceptors)
-  private val networkInterceptors: List<Interceptor> =
-      Util.immutableList(builder.networkInterceptors)
-  private val eventListenerFactory: EventListener.Factory = builder.eventListenerFactory
-  private val proxySelector: ProxySelector = builder.proxySelector
-  private val cookieJar: CookieJar = builder.cookieJar
-  private val cache: Cache? = builder.cache
-  private val socketFactory: SocketFactory = builder.socketFactory
-  private val sslSocketFactory: SSLSocketFactory?
-  private val hostnameVerifier: HostnameVerifier = builder.hostnameVerifier
-  private val certificatePinner: CertificatePinner
-  private val proxyAuthenticator: Authenticator = builder.proxyAuthenticator
-  private val authenticator: Authenticator = builder.authenticator
-  private val connectionPool: ConnectionPool = builder.connectionPool
-  private val dns: Dns = builder.dns
-  private val followSslRedirects: Boolean = builder.followSslRedirects
-  private val followRedirects: Boolean = builder.followRedirects
-  private val retryOnConnectionFailure: Boolean = builder.retryOnConnectionFailure
-  private val callTimeout: Int = builder.callTimeout
-  private val connectTimeout: Int = builder.connectTimeout
-  private val readTimeout: Int = builder.readTimeout
-  private val writeTimeout: Int = builder.writeTimeout
-  private val pingInterval: Int = builder.pingInterval
-  private val internalCache: InternalCache? = builder.internalCache
-  private val certificateChainCleaner: CertificateChainCleaner?
 
-  constructor() : this(Builder())
-
-  init {
-    var isTLS = false
-    for (spec in connectionSpecs) {
-      isTLS = isTLS || spec.isTls
-    }
-
-    // TODO - these nullability warnings existed in Java
-    if (builder.sslSocketFactory != null || !isTLS) {
-      this.sslSocketFactory = builder.sslSocketFactory
-      this.certificateChainCleaner = builder.certificateChainCleaner
-    } else {
-      val trustManager = Util.platformTrustManager()
-      Platform.get().configureTrustManager(trustManager)
-      this.sslSocketFactory = newSslSocketFactory(trustManager)
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager)
-    }
-
-    if (sslSocketFactory != null) {
-      Platform.get().configureSslSocketFactory(sslSocketFactory)
-    }
-
-    this.certificatePinner = builder.certificatePinner
-        .withCertificateChainCleaner(certificateChainCleaner)
-
-    check(null !in (interceptors as List<Interceptor?>)) {
-      "Null interceptor: $interceptors"
-    }
-    check(null !in (networkInterceptors as List<Interceptor?>)) {
-      "Null network interceptor: $networkInterceptors"
-    }
-  }
+  @get:JvmName("dispatcher") val dispatcher: Dispatcher = builder.dispatcher
 
-  open fun dispatcher(): Dispatcher = dispatcher
-
-  open fun proxy(): Proxy? = proxy
-
-  open fun protocols(): List<Protocol> = protocols
-
-  open fun connectionSpecs(): List<ConnectionSpec> = connectionSpecs
+  @get:JvmName("connectionPool") val connectionPool: ConnectionPool = builder.connectionPool
 
   /**
    * Returns an immutable list of interceptors that observe the full span of each call: from before
    * the connection is established (if any) until after the response source is selected (either the
    * origin server, cache, or both).
    */
-  open fun interceptors(): List<Interceptor> = interceptors
+  @get:JvmName("interceptors") val interceptors: List<Interceptor> =
+      builder.interceptors.toImmutableList()
 
   /**
    * Returns an immutable list of interceptors that observe a single network request and response.
    * These interceptors must call [Interceptor.Chain.proceed] exactly once: it is an error for
    * a network interceptor to short-circuit or repeat a network request.
    */
-  open fun networkInterceptors(): List<Interceptor> = networkInterceptors
+  @get:JvmName("networkInterceptors") val networkInterceptors: List<Interceptor> =
+      builder.networkInterceptors.toImmutableList()
 
-  open fun eventListenerFactory(): EventListener.Factory = eventListenerFactory
+  @get:JvmName("eventListenerFactory") val eventListenerFactory: EventListener.Factory =
+      builder.eventListenerFactory
 
-  open fun proxySelector(): ProxySelector = proxySelector
+  @get:JvmName("retryOnConnectionFailure") val retryOnConnectionFailure: Boolean =
+      builder.retryOnConnectionFailure
 
-  open fun cookieJar(): CookieJar = cookieJar
+  @get:JvmName("authenticator") val authenticator: Authenticator = builder.authenticator
 
-  open fun cache(): Cache? = cache
+  @get:JvmName("followRedirects") val followRedirects: Boolean = builder.followRedirects
 
-  open fun socketFactory(): SocketFactory = socketFactory
+  @get:JvmName("followSslRedirects") val followSslRedirects: Boolean = builder.followSslRedirects
 
-  open fun sslSocketFactory(): SSLSocketFactory = sslSocketFactory!!
+  @get:JvmName("cookieJar") val cookieJar: CookieJar = builder.cookieJar
 
-  open fun hostnameVerifier(): HostnameVerifier = hostnameVerifier
+  @get:JvmName("cache") val cache: Cache? = builder.cache
 
-  open fun certificatePinner(): CertificatePinner = certificatePinner
+  @get:JvmName("dns") val dns: Dns = builder.dns
+
+  @get:JvmName("proxy") val proxy: Proxy? = builder.proxy
+
+  @get:JvmName("proxySelector") val proxySelector: ProxySelector =
+      when {
+        // Avoid possible SecurityException from ProxySelector.getDefault
+        builder.proxy != null -> NullProxySelector()
+        else -> builder.proxySelector ?: ProxySelector.getDefault() ?: NullProxySelector()
+      }
 
-  open fun proxyAuthenticator(): Authenticator = proxyAuthenticator
+  @get:JvmName("proxyAuthenticator") val proxyAuthenticator: Authenticator =
+      builder.proxyAuthenticator
 
-  open fun authenticator(): Authenticator = authenticator
+  @get:JvmName("socketFactory") val socketFactory: SocketFactory = builder.socketFactory
 
-  open fun connectionPool(): ConnectionPool = connectionPool
+  private val sslSocketFactoryOrNull: SSLSocketFactory?
 
-  open fun dns(): Dns = dns
+  @get:JvmName("sslSocketFactory") val sslSocketFactory: SSLSocketFactory
+    get() = sslSocketFactoryOrNull ?: throw IllegalStateException("CLEARTEXT-only client")
 
-  open fun followSslRedirects(): Boolean = followSslRedirects
+  @get:JvmName("x509TrustManager") val x509TrustManager: X509TrustManager?
 
-  open fun followRedirects(): Boolean = followRedirects
+  @get:JvmName("connectionSpecs") val connectionSpecs: List<ConnectionSpec> =
+      builder.connectionSpecs
 
-  open fun retryOnConnectionFailure(): Boolean = retryOnConnectionFailure
+  @get:JvmName("protocols") val protocols: List<Protocol> = builder.protocols
+
+  @get:JvmName("hostnameVerifier") val hostnameVerifier: HostnameVerifier = builder.hostnameVerifier
+
+  @get:JvmName("certificatePinner") val certificatePinner: CertificatePinner
+
+  @get:JvmName("certificateChainCleaner") val certificateChainCleaner: CertificateChainCleaner?
 
   /**
    * Default call timeout (in milliseconds). By default there is no timeout for complete calls, but
    * there is for the connect, write, and read actions within a call.
    */
-  open fun callTimeoutMillis(): Int = callTimeout
+  @get:JvmName("callTimeoutMillis") val callTimeoutMillis: Int = builder.callTimeout
 
-  /** Default connect timeout (in milliseconds). The default is 10 seconds.  */
-  open fun connectTimeoutMillis(): Int = connectTimeout
+  /** Default connect timeout (in milliseconds). The default is 10 seconds. */
+  @get:JvmName("connectTimeoutMillis") val connectTimeoutMillis: Int = builder.connectTimeout
 
   /** Default read timeout (in milliseconds). The default is 10 seconds. */
-  open fun readTimeoutMillis(): Int = readTimeout
+  @get:JvmName("readTimeoutMillis") val readTimeoutMillis: Int = builder.readTimeout
 
   /** Default write timeout (in milliseconds). The default is 10 seconds. */
-  open fun writeTimeoutMillis(): Int = writeTimeout
+  @get:JvmName("writeTimeoutMillis") val writeTimeoutMillis: Int = builder.writeTimeout
 
   /** Web socket and HTTP/2 ping interval (in milliseconds). By default pings are not sent. */
-  open fun pingIntervalMillis(): Int = pingInterval
+  @get:JvmName("pingIntervalMillis") val pingIntervalMillis: Int = builder.pingInterval
+
+  constructor() : this(Builder())
 
-  internal fun internalCache(): InternalCache? {
-    return cache?.internalCache ?: internalCache
+  init {
+    if (builder.sslSocketFactoryOrNull != null || connectionSpecs.none { it.isTls }) {
+      this.sslSocketFactoryOrNull = builder.sslSocketFactoryOrNull
+      this.certificateChainCleaner = builder.certificateChainCleaner
+      this.x509TrustManager = builder.x509TrustManagerOrNull
+    } else {
+      this.x509TrustManager = Platform.get().platformTrustManager()
+      Platform.get().configureTrustManager(x509TrustManager)
+      this.sslSocketFactoryOrNull = newSslSocketFactory(x509TrustManager!!)
+      this.certificateChainCleaner = CertificateChainCleaner.get(x509TrustManager!!)
+    }
+
+    if (sslSocketFactoryOrNull != null) {
+      Platform.get().configureSslSocketFactory(sslSocketFactoryOrNull)
+    }
+
+    this.certificatePinner = builder.certificatePinner
+        .withCertificateChainCleaner(certificateChainCleaner)
+
+    check(null !in (interceptors as List<Interceptor?>)) {
+      "Null interceptor: $interceptors"
+    }
+    check(null !in (networkInterceptors as List<Interceptor?>)) {
+      "Null network interceptor: $networkInterceptors"
+    }
   }
 
   /** Prepares the [request] to be executed at some point in the future. */
   override fun newCall(request: Request): Call {
-    return RealCall.newRealCall(this, request, false /* for web socket */)
+    return RealCall.newRealCall(this, request, forWebSocket = false)
   }
 
   /** Uses [request] to connect a new web socket. */
   override fun newWebSocket(request: Request, listener: WebSocketListener): WebSocket {
-    val webSocket = RealWebSocket(request, listener, Random(), pingInterval.toLong())
+    val webSocket = RealWebSocket(request, listener, Random(), pingIntervalMillis.toLong())
     webSocket.connect(this)
     return webSocket
   }
 
   open fun newBuilder(): Builder = Builder(this)
 
+  @JvmName("-deprecated_dispatcher")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "dispatcher"),
+      level = DeprecationLevel.ERROR)
+  fun dispatcher(): Dispatcher = dispatcher
+
+  @JvmName("-deprecated_connectionPool")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "connectionPool"),
+      level = DeprecationLevel.ERROR)
+  fun connectionPool(): ConnectionPool = connectionPool
+
+  @JvmName("-deprecated_interceptors")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "interceptors"),
+      level = DeprecationLevel.ERROR)
+  fun interceptors(): List<Interceptor> = interceptors
+
+  @JvmName("-deprecated_networkInterceptors")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "networkInterceptors"),
+      level = DeprecationLevel.ERROR)
+  fun networkInterceptors(): List<Interceptor> = networkInterceptors
+
+  @JvmName("-deprecated_eventListenerFactory")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "eventListenerFactory"),
+      level = DeprecationLevel.ERROR)
+  fun eventListenerFactory(): EventListener.Factory = eventListenerFactory
+
+  @JvmName("-deprecated_retryOnConnectionFailure")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "retryOnConnectionFailure"),
+      level = DeprecationLevel.ERROR)
+  fun retryOnConnectionFailure(): Boolean = retryOnConnectionFailure
+
+  @JvmName("-deprecated_authenticator")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "authenticator"),
+      level = DeprecationLevel.ERROR)
+  fun authenticator(): Authenticator = authenticator
+
+  @JvmName("-deprecated_followRedirects")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "followRedirects"),
+      level = DeprecationLevel.ERROR)
+  fun followRedirects(): Boolean = followRedirects
+
+  @JvmName("-deprecated_followSslRedirects")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "followSslRedirects"),
+      level = DeprecationLevel.ERROR)
+  fun followSslRedirects(): Boolean = followSslRedirects
+
+  @JvmName("-deprecated_cookieJar")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "cookieJar"),
+      level = DeprecationLevel.ERROR)
+  fun cookieJar(): CookieJar = cookieJar
+
+  @JvmName("-deprecated_cache")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "cache"),
+      level = DeprecationLevel.ERROR)
+  fun cache(): Cache? = cache
+
+  @JvmName("-deprecated_dns")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "dns"),
+      level = DeprecationLevel.ERROR)
+  fun dns(): Dns = dns
+
+  @JvmName("-deprecated_proxy")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "proxy"),
+      level = DeprecationLevel.ERROR)
+  fun proxy(): Proxy? = proxy
+
+  @JvmName("-deprecated_proxySelector")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "proxySelector"),
+      level = DeprecationLevel.ERROR)
+  fun proxySelector(): ProxySelector = proxySelector
+
+  @JvmName("-deprecated_proxyAuthenticator")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "proxyAuthenticator"),
+      level = DeprecationLevel.ERROR)
+  fun proxyAuthenticator(): Authenticator = proxyAuthenticator
+
+  @JvmName("-deprecated_socketFactory")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "socketFactory"),
+      level = DeprecationLevel.ERROR)
+  fun socketFactory(): SocketFactory = socketFactory
+
+  @JvmName("-deprecated_sslSocketFactory")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "sslSocketFactory"),
+      level = DeprecationLevel.ERROR)
+  fun sslSocketFactory(): SSLSocketFactory = sslSocketFactory
+
+  @JvmName("-deprecated_connectionSpecs")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "connectionSpecs"),
+      level = DeprecationLevel.ERROR)
+  fun connectionSpecs(): List<ConnectionSpec> = connectionSpecs
+
+  @JvmName("-deprecated_protocols")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "protocols"),
+      level = DeprecationLevel.ERROR)
+  fun protocols(): List<Protocol> = protocols
+
+  @JvmName("-deprecated_hostnameVerifier")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "hostnameVerifier"),
+      level = DeprecationLevel.ERROR)
+  fun hostnameVerifier(): HostnameVerifier = hostnameVerifier
+
+  @JvmName("-deprecated_certificatePinner")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "certificatePinner"),
+      level = DeprecationLevel.ERROR)
+  fun certificatePinner(): CertificatePinner = certificatePinner
+
+  @JvmName("-deprecated_callTimeoutMillis")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "callTimeoutMillis"),
+      level = DeprecationLevel.ERROR)
+  fun callTimeoutMillis(): Int = callTimeoutMillis
+
+  @JvmName("-deprecated_connectTimeoutMillis")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "connectTimeoutMillis"),
+      level = DeprecationLevel.ERROR)
+  fun connectTimeoutMillis(): Int = connectTimeoutMillis
+
+  @JvmName("-deprecated_readTimeoutMillis")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "readTimeoutMillis"),
+      level = DeprecationLevel.ERROR)
+  fun readTimeoutMillis(): Int = readTimeoutMillis
+
+  @JvmName("-deprecated_writeTimeoutMillis")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "writeTimeoutMillis"),
+      level = DeprecationLevel.ERROR)
+  fun writeTimeoutMillis(): Int = writeTimeoutMillis
+
+  @JvmName("-deprecated_pingIntervalMillis")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "pingIntervalMillis"),
+      level = DeprecationLevel.ERROR)
+  fun pingIntervalMillis(): Int = pingIntervalMillis
+
   class Builder constructor() {
     internal var dispatcher: Dispatcher = Dispatcher()
-    internal var proxy: Proxy? = null
-    internal var protocols: List<Protocol> = DEFAULT_PROTOCOLS
-    internal var connectionSpecs: List<ConnectionSpec> = DEFAULT_CONNECTION_SPECS
+    internal var connectionPool: ConnectionPool = ConnectionPool()
     internal val interceptors: MutableList<Interceptor> = mutableListOf()
     internal val networkInterceptors: MutableList<Interceptor> = mutableListOf()
-    internal var eventListenerFactory: EventListener.Factory = Util.eventListenerFactory(
-        EventListener.NONE)
-    internal var proxySelector: ProxySelector = ProxySelector.getDefault() ?: NullProxySelector()
+    internal var eventListenerFactory: EventListener.Factory = EventListener.NONE.asFactory()
+    internal var retryOnConnectionFailure = true
+    internal var authenticator: Authenticator = Authenticator.NONE
+    internal var followRedirects = true
+    internal var followSslRedirects = true
     internal var cookieJar: CookieJar = CookieJar.NO_COOKIES
     internal var cache: Cache? = null
-    internal var internalCache: InternalCache? = null
+    internal var dns: Dns = Dns.SYSTEM
+    internal var proxy: Proxy? = null
+    internal var proxySelector: ProxySelector? = null
+    internal var proxyAuthenticator: Authenticator = Authenticator.NONE
     internal var socketFactory: SocketFactory = SocketFactory.getDefault()
-    internal var sslSocketFactory: SSLSocketFactory? = null
-    internal var certificateChainCleaner: CertificateChainCleaner? = null
+    internal var sslSocketFactoryOrNull: SSLSocketFactory? = null
+    internal var x509TrustManagerOrNull: X509TrustManager? = null
+    internal var connectionSpecs: List<ConnectionSpec> = DEFAULT_CONNECTION_SPECS
+    internal var protocols: List<Protocol> = DEFAULT_PROTOCOLS
     internal var hostnameVerifier: HostnameVerifier = OkHostnameVerifier
     internal var certificatePinner: CertificatePinner = CertificatePinner.DEFAULT
-    internal var proxyAuthenticator: Authenticator = Authenticator.NONE
-    internal var authenticator: Authenticator = Authenticator.NONE
-    internal var connectionPool: ConnectionPool = ConnectionPool()
-    internal var dns: Dns = Dns.SYSTEM
-    internal var followSslRedirects: Boolean = true
-    internal var followRedirects: Boolean = true
-    internal var retryOnConnectionFailure: Boolean = true
-    internal var callTimeout: Int = 0
-    internal var connectTimeout: Int = 10000
-    internal var readTimeout: Int = 10000
-    internal var writeTimeout: Int = 10000
-    internal var pingInterval: Int = 0
+    internal var certificateChainCleaner: CertificateChainCleaner? = null
+    internal var callTimeout = 0
+    internal var connectTimeout = 10_000
+    internal var readTimeout = 10_000
+    internal var writeTimeout = 10_000
+    internal var pingInterval = 0
 
     internal constructor(okHttpClient: OkHttpClient) : this() {
       this.dispatcher = okHttpClient.dispatcher
-      this.proxy = okHttpClient.proxy
-      this.protocols = okHttpClient.protocols
-      this.connectionSpecs = okHttpClient.connectionSpecs
+      this.connectionPool = okHttpClient.connectionPool
       this.interceptors += okHttpClient.interceptors
       this.networkInterceptors += okHttpClient.networkInterceptors
       this.eventListenerFactory = okHttpClient.eventListenerFactory
-      this.proxySelector = okHttpClient.proxySelector
+      this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure
+      this.authenticator = okHttpClient.authenticator
+      this.followRedirects = okHttpClient.followRedirects
+      this.followSslRedirects = okHttpClient.followSslRedirects
       this.cookieJar = okHttpClient.cookieJar
-      this.internalCache = okHttpClient.internalCache
       this.cache = okHttpClient.cache
+      this.dns = okHttpClient.dns
+      this.proxy = okHttpClient.proxy
+      this.proxySelector = okHttpClient.proxySelector
+      this.proxyAuthenticator = okHttpClient.proxyAuthenticator
       this.socketFactory = okHttpClient.socketFactory
-      this.sslSocketFactory = okHttpClient.sslSocketFactory
-      this.certificateChainCleaner = okHttpClient.certificateChainCleaner
+      this.sslSocketFactoryOrNull = okHttpClient.sslSocketFactoryOrNull
+      this.x509TrustManagerOrNull = okHttpClient.x509TrustManager
+      this.connectionSpecs = okHttpClient.connectionSpecs
+      this.protocols = okHttpClient.protocols
       this.hostnameVerifier = okHttpClient.hostnameVerifier
       this.certificatePinner = okHttpClient.certificatePinner
-      this.proxyAuthenticator = okHttpClient.proxyAuthenticator
-      this.authenticator = okHttpClient.authenticator
-      this.connectionPool = okHttpClient.connectionPool
-      this.dns = okHttpClient.dns
-      this.followSslRedirects = okHttpClient.followSslRedirects
-      this.followRedirects = okHttpClient.followRedirects
-      this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure
-      this.callTimeout = okHttpClient.callTimeout
-      this.connectTimeout = okHttpClient.connectTimeout
-      this.readTimeout = okHttpClient.readTimeout
-      this.writeTimeout = okHttpClient.writeTimeout
-      this.pingInterval = okHttpClient.pingInterval
+      this.certificateChainCleaner = okHttpClient.certificateChainCleaner
+      this.callTimeout = okHttpClient.callTimeoutMillis
+      this.connectTimeout = okHttpClient.connectTimeoutMillis
+      this.readTimeout = okHttpClient.readTimeoutMillis
+      this.writeTimeout = okHttpClient.writeTimeoutMillis
+      this.pingInterval = okHttpClient.pingIntervalMillis
     }
 
     /**
-     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
-     * must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
-     *
-     * The call timeout spans the entire call: resolving DNS, connecting, writing the request body,
-     * server processing, and reading the response body. If the call requires redirects or retries
-     * all must complete within one timeout period.
-     *
-     * The default value is 0 which imposes no timeout.
+     * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
      */
-    fun callTimeout(timeout: Long, unit: TimeUnit) = apply {
-      callTimeout = checkDuration("timeout", timeout, unit)
+    fun dispatcher(dispatcher: Dispatcher) = apply {
+      this.dispatcher = dispatcher
     }
 
     /**
-     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
-     * must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
-     *
-     * The call timeout spans the entire call: resolving DNS, connecting, writing the request body,
-     * server processing, and reading the response body. If the call requires redirects or retries
-     * all must complete within one timeout period.
+     * Sets the connection pool used to recycle HTTP and HTTPS connections.
      *
-     * The default value is 0 which imposes no timeout.
+     * If unset, a new connection pool will be used.
      */
-    @IgnoreJRERequirement
-    fun callTimeout(duration: Duration) = apply {
-      callTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+    fun connectionPool(connectionPool: ConnectionPool) = apply {
+      this.connectionPool = connectionPool
     }
 
     /**
-     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
-     * otherwise values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
-     *
-     * The connect timeout is applied when connecting a TCP socket to the target host. The default
-     * value is 10 seconds.
+     * Returns a modifiable list of interceptors that observe the full span of each call: from
+     * before the connection is established (if any) until after the response source is selected
+     * (either the origin server, cache, or both).
      */
-    fun connectTimeout(timeout: Long, unit: TimeUnit) = apply {
-      connectTimeout = checkDuration("timeout", timeout, unit)
-    }
+    fun interceptors(): MutableList<Interceptor> = interceptors
 
-    /**
-     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
-     * otherwise values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
-     *
-     * The connect timeout is applied when connecting a TCP socket to the target host. The default
-     * value is 10 seconds.
-     */
-    @IgnoreJRERequirement
-    fun connectTimeout(duration: Duration) = apply {
-      connectTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+    fun addInterceptor(interceptor: Interceptor) = apply {
+      interceptors += interceptor
     }
 
+    @JvmName("-addInterceptor") // Prefix with '-' to prevent ambiguous overloads from Java.
+    inline fun addInterceptor(crossinline block: (chain: Interceptor.Chain) -> Response) =
+        addInterceptor(Interceptor { chain -> block(chain) })
+
     /**
-     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
-     *
-     * The read timeout is applied to both the TCP socket and for individual read IO operations
-     * including on [Source] of the [Response]. The default value is 10 seconds.
-     *
-     * @see Socket.setSoTimeout
-     * @see Source.timeout
+     * Returns a modifiable list of interceptors that observe a single network request and response.
+     * These interceptors must call [Interceptor.Chain.proceed] exactly once: it is an error for a
+     * network interceptor to short-circuit or repeat a network request.
      */
-    fun readTimeout(timeout: Long, unit: TimeUnit) = apply {
-      readTimeout = checkDuration("timeout", timeout, unit)
+    fun networkInterceptors(): MutableList<Interceptor> = networkInterceptors
+
+    fun addNetworkInterceptor(interceptor: Interceptor) = apply {
+      networkInterceptors += interceptor
     }
 
+    @JvmName("-addNetworkInterceptor") // Prefix with '-' to prevent ambiguous overloads from Java.
+    inline fun addNetworkInterceptor(crossinline block: (chain: Interceptor.Chain) -> Response) =
+        addNetworkInterceptor(Interceptor { chain -> block(chain) })
+
     /**
-     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
-     *
-     * The read timeout is applied to both the TCP socket and for individual read IO operations
-     * including on [Source] of the [Response]. The default value is 10 seconds.
+     * Configure a single client scoped listener that will receive all analytic events for this
+     * client.
      *
-     * @see Socket.setSoTimeout
-     * @see Source.timeout
+     * @see EventListener for semantics and restrictions on listener implementations.
      */
-    @IgnoreJRERequirement
-    fun readTimeout(duration: Duration) = apply {
-      readTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+    fun eventListener(eventListener: EventListener) = apply {
+      this.eventListenerFactory = eventListener.asFactory()
     }
 
     /**
-     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
-     *
-     * The write timeout is applied for individual write IO operations. The default value is 10
-     * seconds.
+     * Configure a factory to provide per-call scoped listeners that will receive analytic events
+     * for this client.
      *
-     * @see Sink.timeout
+     * @see EventListener for semantics and restrictions on listener implementations.
      */
-    fun writeTimeout(timeout: Long, unit: TimeUnit) = apply {
-      writeTimeout = checkDuration("timeout", timeout, unit)
+    fun eventListenerFactory(eventListenerFactory: EventListener.Factory) = apply {
+      this.eventListenerFactory = eventListenerFactory
     }
 
     /**
-     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     * Configure this client to retry or not when a connectivity problem is encountered. By default,
+     * this client silently recovers from the following problems:
      *
-     * The write timeout is applied for individual write IO operations. The default value is 10
-     * seconds.
+     * * **Unreachable IP addresses.** If the URL's host has multiple IP addresses,
+     *   failure to reach any individual IP address doesn't fail the overall request. This can
+     *   increase availability of multi-homed services.
      *
-     * @see Sink.timeout
-     */
-    @IgnoreJRERequirement
-    fun writeTimeout(duration: Duration) = apply {
-      writeTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
-    }
-
-    /**
-     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
-     * automatically send ping frames until either the connection fails or it is closed. This keeps
-     * the connection alive and may detect connectivity failures.
+     * * **Stale pooled connections.** The [ConnectionPool] reuses sockets
+     *   to decrease request latency, but these connections will occasionally time out.
      *
-     * If the server does not respond to each ping with a pong within `interval`, this client will
-     * assume that connectivity has been lost. When this happens on a web socket the connection is
-     * canceled and its listener is [notified][WebSocketListener.onFailure]. When it happens on an
-     * HTTP/2 connection the connection is closed and any calls it is carrying
-     * [will fail with an IOException][java.io.IOException].
+     * * **Unreachable proxy servers.** A [ProxySelector] can be used to
+     *   attempt multiple proxy servers in sequence, eventually falling back to a direct
+     *   connection.
      *
-     * The default value of 0 disables client-initiated pings.
+     * Set this to false to avoid retrying requests when doing so is destructive. In this case the
+     * calling application should do its own recovery of connectivity failures.
      */
-    fun pingInterval(interval: Long, unit: TimeUnit) = apply {
-      pingInterval = checkDuration("interval", interval, unit)
+    fun retryOnConnectionFailure(retryOnConnectionFailure: Boolean) = apply {
+      this.retryOnConnectionFailure = retryOnConnectionFailure
     }
 
     /**
-     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
-     * automatically send ping frames until either the connection fails or it is closed. This keeps
-     * the connection alive and may detect connectivity failures.
-     *
-     * If the server does not respond to each ping with a pong within `interval`, this client will
-     * assume that connectivity has been lost. When this happens on a web socket the connection is
-     * canceled and its listener is [notified][WebSocketListener.onFailure]. When it happens on an
-     * HTTP/2 connection the connection is closed and any calls it is carrying
-     * [will fail with an IOException][java.io.IOException].
+     * Sets the authenticator used to respond to challenges from origin servers. Use
+     * [proxyAuthenticator] to set the authenticator for proxy servers.
      *
-     * The default value of 0 disables client-initiated pings.
+     * If unset, the [no authentication will be attempted][Authenticator.NONE].
      */
-    @IgnoreJRERequirement
-    fun pingInterval(duration: Duration) = apply {
-      pingInterval = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+    fun authenticator(authenticator: Authenticator) = apply {
+      this.authenticator = authenticator
     }
 
-    /**
-     * Sets the HTTP proxy that will be used by connections created by this client. This takes
-     * precedence over [proxySelector], which is only honored when this proxy is null (which it is
-     * by default). To disable proxy use completely, call `proxy(Proxy.NO_PROXY)`.
-     */
-    fun proxy(proxy: Proxy?) = apply {
-      this.proxy = proxy
+    /** Configure this client to follow redirects. If unset, redirects will be followed. */
+    fun followRedirects(followRedirects: Boolean) = apply {
+      this.followRedirects = followRedirects
     }
 
     /**
-     * Sets the proxy selection policy to be used if no [proxy][proxy] is specified explicitly. The
-     * proxy selector may return multiple proxies; in that case they will be tried in sequence until
-     * a successful connection is established.
+     * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
      *
-     * If unset, the [system-wide default][ProxySelector.getDefault] proxy selector will be used.
+     * If unset, protocol redirects will be followed. This is different than the built-in
+     * `HttpURLConnection`'s default.
      */
-    fun proxySelector(proxySelector: ProxySelector) = apply {
-      this.proxySelector = proxySelector
+    fun followSslRedirects(followProtocolRedirects: Boolean) = apply {
+      this.followSslRedirects = followProtocolRedirects
     }
 
     /**
@@ -509,10 +617,9 @@ open class OkHttpClient internal constructor(
       this.cookieJar = cookieJar
     }
 
-    /** Sets the response cache to be used to read and write cached responses.  */
+    /** Sets the response cache to be used to read and write cached responses. */
     fun cache(cache: Cache?) = apply {
       this.cache = cache
-      this.internalCache = null
     }
 
     /**
@@ -525,101 +632,23 @@ open class OkHttpClient internal constructor(
     }
 
     /**
-     * Sets the socket factory used to create connections. OkHttp only uses the parameterless
-     * [SocketFactory.createSocket] method to create unconnected sockets. Overriding this method,
-     * e. g., allows the socket to be bound to a specific local address.
-     *
-     * If unset, the [system-wide default][SocketFactory.getDefault] socket factory will be used.
-     */
-    fun socketFactory(socketFactory: SocketFactory) = apply {
-      if (socketFactory is SSLSocketFactory) {
-        throw IllegalArgumentException("socketFactory instanceof SSLSocketFactory")
-      }
-      this.socketFactory = socketFactory
-    }
-
-    /**
-     * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
-     * be used.
-     *
-     * @deprecated [SSLSocketFactory] does not expose its [X509TrustManager], which is a field that
-     *     OkHttp needs to build a clean certificate chain. This method instead must use reflection
-     *     to extract the trust manager. Applications should prefer to call
-     *     `sslSocketFactory(SSLSocketFactory, X509TrustManager)`, which avoids such reflection.
-     */
-    @Deprecated(
-        message = "Use the sslSocketFactory overload that accepts a X509TrustManager.",
-        level = ERROR
-    )
-    fun sslSocketFactory(sslSocketFactory: SSLSocketFactory) = apply {
-      this.sslSocketFactory = sslSocketFactory
-      this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory)
-    }
-
-    /**
-     * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
-     * system defaults will be used.
-     *
-     * Most applications should not call this method, and instead use the system defaults. Those
-     * classes include special optimizations that can be lost if the implementations are decorated.
-     *
-     * If necessary, you can create and configure the defaults yourself with the following code:
-     *
-     * ```
-     * TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-     * TrustManagerFactory.getDefaultAlgorithm());
-     * trustManagerFactory.init((KeyStore) null);
-     * TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-     * if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-     *     throw new IllegalStateException("Unexpected default trust managers:"
-     *         + Arrays.toString(trustManagers));
-     * }
-     * X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
-     *
-     * SSLContext sslContext = SSLContext.getInstance("TLS");
-     * sslContext.init(null, new TrustManager[] { trustManager }, null);
-     * SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
-     *
-     * OkHttpClient client = new OkHttpClient.Builder()
-     *     .sslSocketFactory(sslSocketFactory, trustManager)
-     *     .build();
-     * ```
-     */
-    fun sslSocketFactory(
-      sslSocketFactory: SSLSocketFactory,
-      trustManager: X509TrustManager
-    ) = apply {
-      this.sslSocketFactory = sslSocketFactory
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager)
-    }
-
-    /**
-     * Sets the verifier used to confirm that response certificates apply to requested hostnames for
-     * HTTPS connections.
-     *
-     * If unset, a default hostname verifier will be used.
-     */
-    fun hostnameVerifier(hostnameVerifier: HostnameVerifier) = apply {
-      this.hostnameVerifier = hostnameVerifier
-    }
-
-    /**
-     * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
-     * connections rely on only the [SSL socket factory][sslSocketFactory] to establish trust.
-     * Pinning certificates avoids the need to trust certificate authorities.
+     * Sets the HTTP proxy that will be used by connections created by this client. This takes
+     * precedence over [proxySelector], which is only honored when this proxy is null (which it is
+     * by default). To disable proxy use completely, call `proxy(Proxy.NO_PROXY)`.
      */
-    fun certificatePinner(certificatePinner: CertificatePinner) = apply {
-      this.certificatePinner = certificatePinner
+    fun proxy(proxy: Proxy?) = apply {
+      this.proxy = proxy
     }
 
     /**
-     * Sets the authenticator used to respond to challenges from origin servers. Use
-     * [proxyAuthenticator] to set the authenticator for proxy servers.
+     * Sets the proxy selection policy to be used if no [proxy][proxy] is specified explicitly. The
+     * proxy selector may return multiple proxies; in that case they will be tried in sequence until
+     * a successful connection is established.
      *
-     * If unset, the [no authentication will be attempted][Authenticator.NONE].
+     * If unset, the [system-wide default][ProxySelector.getDefault] proxy selector will be used.
      */
-    fun authenticator(authenticator: Authenticator) = apply {
-      this.authenticator = authenticator
+    fun proxySelector(proxySelector: ProxySelector) = apply {
+      this.proxySelector = proxySelector
     }
 
     /**
@@ -633,56 +662,75 @@ open class OkHttpClient internal constructor(
     }
 
     /**
-     * Sets the connection pool used to recycle HTTP and HTTPS connections.
+     * Sets the socket factory used to create connections. OkHttp only uses the parameterless
+     * [SocketFactory.createSocket] method to create unconnected sockets. Overriding this method,
+     * e. g., allows the socket to be bound to a specific local address.
      *
-     * If unset, a new connection pool will be used.
+     * If unset, the [system-wide default][SocketFactory.getDefault] socket factory will be used.
      */
-    fun connectionPool(connectionPool: ConnectionPool) = apply {
-      this.connectionPool = connectionPool
+    fun socketFactory(socketFactory: SocketFactory) = apply {
+      require(socketFactory !is SSLSocketFactory) { "socketFactory instanceof SSLSocketFactory" }
+      this.socketFactory = socketFactory
     }
 
     /**
-     * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
+     * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
+     * be used.
      *
-     * If unset, protocol redirects will be followed. This is different than the built-in
-     * `HttpURLConnection`'s default.
+     * @deprecated [SSLSocketFactory] does not expose its [X509TrustManager], which is a field that
+     *     OkHttp needs to build a clean certificate chain. This method instead must use reflection
+     *     to extract the trust manager. Applications should prefer to call
+     *     `sslSocketFactory(SSLSocketFactory, X509TrustManager)`, which avoids such reflection.
      */
-    fun followSslRedirects(followProtocolRedirects: Boolean) = apply {
-      this.followSslRedirects = followProtocolRedirects
-    }
-
-    /** Configure this client to follow redirects. If unset, redirects will be followed. */
-    fun followRedirects(followRedirects: Boolean) = apply {
-      this.followRedirects = followRedirects
+    @Deprecated(
+        message = "Use the sslSocketFactory overload that accepts a X509TrustManager.",
+        level = DeprecationLevel.ERROR
+    )
+    fun sslSocketFactory(sslSocketFactory: SSLSocketFactory) = apply {
+      this.sslSocketFactoryOrNull = sslSocketFactory
+      this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory)
     }
 
     /**
-     * Configure this client to retry or not when a connectivity problem is encountered. By default,
-     * this client silently recovers from the following problems:
+     * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
+     * system defaults will be used.
      *
-     * * **Unreachable IP addresses.** If the URL's host has multiple IP addresses,
-     *   failure to reach any individual IP address doesn't fail the overall request. This can
-     *   increase availability of multi-homed services.
+     * Most applications should not call this method, and instead use the system defaults. Those
+     * classes include special optimizations that can be lost if the implementations are decorated.
      *
-     * * **Stale pooled connections.** The [ConnectionPool] reuses sockets
-     *   to decrease request latency, but these connections will occasionally time out.
+     * If necessary, you can create and configure the defaults yourself with the following code:
      *
-     * * **Unreachable proxy servers.** A [ProxySelector] can be used to
-     *   attempt multiple proxy servers in sequence, eventually falling back to a direct
-     *   connection.
+     * ```
+     * TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+     * TrustManagerFactory.getDefaultAlgorithm());
+     * trustManagerFactory.init((KeyStore) null);
+     * TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+     * if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+     *     throw new IllegalStateException("Unexpected default trust managers:"
+     *         + Arrays.toString(trustManagers));
+     * }
+     * X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
      *
-     * Set this to false to avoid retrying requests when doing so is destructive. In this case the
-     * calling application should do its own recovery of connectivity failures.
+     * SSLContext sslContext = SSLContext.getInstance("TLS");
+     * sslContext.init(null, new TrustManager[] { trustManager }, null);
+     * SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+     *
+     * OkHttpClient client = new OkHttpClient.Builder()
+     *     .sslSocketFactory(sslSocketFactory, trustManager)
+     *     .build();
+     * ```
      */
-    fun retryOnConnectionFailure(retryOnConnectionFailure: Boolean) = apply {
-      this.retryOnConnectionFailure = retryOnConnectionFailure
+    fun sslSocketFactory(
+      sslSocketFactory: SSLSocketFactory,
+      trustManager: X509TrustManager
+    ) = apply {
+      this.sslSocketFactoryOrNull = sslSocketFactory
+      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager)
+      this.x509TrustManagerOrNull = trustManager
     }
 
-    /**
-     * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
-     */
-    fun dispatcher(dispatcher: Dispatcher) = apply {
-      this.dispatcher = dispatcher
+    fun connectionSpecs(connectionSpecs: List<ConnectionSpec>) = apply {
+      this.connectionSpecs = connectionSpecs.toImmutableList()
     }
 
     /**
@@ -721,7 +769,7 @@ open class OkHttpClient internal constructor(
       val protocolsCopy = protocols.toMutableList()
 
       // Validate that the list has everything we require and nothing we forbid.
-      require(Protocol.H2_PRIOR_KNOWLEDGE in protocolsCopy || Protocol.HTTP_1_1 in protocolsCopy) {
+      require(Protocol.H2_PRIOR_KNOWLEDGE in protocolsCopy || HTTP_1_1 in protocolsCopy) {
         "protocols must contain h2_prior_knowledge or http/1.1: $protocolsCopy"
       }
       require(Protocol.H2_PRIOR_KNOWLEDGE !in protocolsCopy || protocolsCopy.size <= 1) {
@@ -730,7 +778,7 @@ open class OkHttpClient internal constructor(
       require(Protocol.HTTP_1_0 !in protocolsCopy) {
         "protocols must not contain http/1.0: $protocolsCopy"
       }
-      require(null !in (protocols as List<Protocol?>)) {
+      require(null !in (protocolsCopy as List<Protocol?>)) {
         "protocols must not contain null"
       }
 
@@ -742,109 +790,177 @@ open class OkHttpClient internal constructor(
       this.protocols = Collections.unmodifiableList(protocols)
     }
 
-    fun connectionSpecs(connectionSpecs: List<ConnectionSpec>) = apply {
-      this.connectionSpecs = Util.immutableList(connectionSpecs)
+    /**
+     * Sets the verifier used to confirm that response certificates apply to requested hostnames for
+     * HTTPS connections.
+     *
+     * If unset, a default hostname verifier will be used.
+     */
+    fun hostnameVerifier(hostnameVerifier: HostnameVerifier) = apply {
+      this.hostnameVerifier = hostnameVerifier
     }
 
     /**
-     * Returns a modifiable list of interceptors that observe the full span of each call: from
-     * before the connection is established (if any) until after the response source is selected
-     * (either the origin server, cache, or both).
+     * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
+     * connections rely on only the [SSL socket factory][sslSocketFactory] to establish trust.
+     * Pinning certificates avoids the need to trust certificate authorities.
      */
-    fun interceptors(): MutableList<Interceptor> = interceptors
+    fun certificatePinner(certificatePinner: CertificatePinner) = apply {
+      this.certificatePinner = certificatePinner
+    }
 
-    fun addInterceptor(interceptor: Interceptor) = apply {
-      interceptors += interceptor
+    /**
+     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+     * must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The call timeout spans the entire call: resolving DNS, connecting, writing the request body,
+     * server processing, and reading the response body. If the call requires redirects or retries
+     * all must complete within one timeout period.
+     *
+     * The default value is 0 which imposes no timeout.
+     */
+    fun callTimeout(timeout: Long, unit: TimeUnit) = apply {
+      callTimeout = checkDuration("timeout", timeout, unit)
     }
 
-    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
-    @JvmName("-deprecated_addInterceptor")
-    inline fun addInterceptor(
-      crossinline interceptor: (chain: Interceptor.Chain) -> Response
-    ) = apply {
-      addInterceptor(object : Interceptor {
-        override fun intercept(chain: Interceptor.Chain): Response = interceptor(chain)
-      })
+    /**
+     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+     * must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The call timeout spans the entire call: resolving DNS, connecting, writing the request body,
+     * server processing, and reading the response body. If the call requires redirects or retries
+     * all must complete within one timeout period.
+     *
+     * The default value is 0 which imposes no timeout.
+     */
+    @IgnoreJRERequirement
+    fun callTimeout(duration: Duration) = apply {
+      callTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
     }
 
     /**
-     * Returns a modifiable list of interceptors that observe a single network request and response.
-     * These interceptors must call [Interceptor.Chain.proceed] exactly once: it is an error for a
-     * network interceptor to short-circuit or repeat a network request.
+     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+     * otherwise values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The connect timeout is applied when connecting a TCP socket to the target host. The default
+     * value is 10 seconds.
      */
-    fun networkInterceptors(): MutableList<Interceptor> = networkInterceptors
+    fun connectTimeout(timeout: Long, unit: TimeUnit) = apply {
+      connectTimeout = checkDuration("timeout", timeout, unit)
+    }
 
-    fun addNetworkInterceptor(interceptor: Interceptor) = apply {
-      networkInterceptors += interceptor
+    /**
+     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+     * otherwise values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The connect timeout is applied when connecting a TCP socket to the target host. The default
+     * value is 10 seconds.
+     */
+    @IgnoreJRERequirement
+    fun connectTimeout(duration: Duration) = apply {
+      connectTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
     }
 
-    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
-    @JvmName("-deprecated_addNetworkInterceptor")
-    inline fun addNetworkInterceptor(
-      crossinline interceptor: (chain: Interceptor.Chain) -> Response
-    ) = apply {
-      addInterceptor(object : Interceptor {
-        override fun intercept(chain: Interceptor.Chain): Response = interceptor(chain)
-      })
+    /**
+     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The read timeout is applied to both the TCP socket and for individual read IO operations
+     * including on [Source] of the [Response]. The default value is 10 seconds.
+     *
+     * @see Socket.setSoTimeout
+     * @see Source.timeout
+     */
+    fun readTimeout(timeout: Long, unit: TimeUnit) = apply {
+      readTimeout = checkDuration("timeout", timeout, unit)
     }
 
     /**
-     * Configure a single client scoped listener that will receive all analytic events for this
-     * client.
+     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
      *
-     * @see EventListener for semantics and restrictions on listener implementations.
+     * The read timeout is applied to both the TCP socket and for individual read IO operations
+     * including on [Source] of the [Response]. The default value is 10 seconds.
+     *
+     * @see Socket.setSoTimeout
+     * @see Source.timeout
      */
-    fun eventListener(eventListener: EventListener) = apply {
-      this.eventListenerFactory = Util.eventListenerFactory(eventListener)
+    @IgnoreJRERequirement
+    fun readTimeout(duration: Duration) = apply {
+      readTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
     }
 
     /**
-     * Configure a factory to provide per-call scoped listeners that will receive analytic events
-     * for this client.
+     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
      *
-     * @see EventListener for semantics and restrictions on listener implementations.
+     * The write timeout is applied for individual write IO operations. The default value is 10
+     * seconds.
+     *
+     * @see Sink.timeout
      */
-    fun eventListenerFactory(eventListenerFactory: EventListener.Factory) = apply {
-      this.eventListenerFactory = eventListenerFactory
+    fun writeTimeout(timeout: Long, unit: TimeUnit) = apply {
+      writeTimeout = checkDuration("timeout", timeout, unit)
+    }
+
+    /**
+     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The write timeout is applied for individual write IO operations. The default value is 10
+     * seconds.
+     *
+     * @see Sink.timeout
+     */
+    @IgnoreJRERequirement
+    fun writeTimeout(duration: Duration) = apply {
+      writeTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+    }
+
+    /**
+     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+     * automatically send ping frames until either the connection fails or it is closed. This keeps
+     * the connection alive and may detect connectivity failures.
+     *
+     * If the server does not respond to each ping with a pong within `interval`, this client will
+     * assume that connectivity has been lost. When this happens on a web socket the connection is
+     * canceled and its listener is [notified][WebSocketListener.onFailure]. When it happens on an
+     * HTTP/2 connection the connection is closed and any calls it is carrying
+     * [will fail with an IOException][java.io.IOException].
+     *
+     * The default value of 0 disables client-initiated pings.
+     */
+    fun pingInterval(interval: Long, unit: TimeUnit) = apply {
+      pingInterval = checkDuration("interval", interval, unit)
     }
 
-    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
-    @JvmName("-deprecated_eventListenerFactory")
-    inline fun eventListenerFactory(crossinline block: (call: Call) -> EventListener) = apply {
-      eventListenerFactory(object : EventListener.Factory {
-        override fun create(call: Call) = block(call)
-      })
+    /**
+     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+     * automatically send ping frames until either the connection fails or it is closed. This keeps
+     * the connection alive and may detect connectivity failures.
+     *
+     * If the server does not respond to each ping with a pong within `interval`, this client will
+     * assume that connectivity has been lost. When this happens on a web socket the connection is
+     * canceled and its listener is [notified][WebSocketListener.onFailure]. When it happens on an
+     * HTTP/2 connection the connection is closed and any calls it is carrying
+     * [will fail with an IOException][java.io.IOException].
+     *
+     * The default value of 0 disables client-initiated pings.
+     */
+    @IgnoreJRERequirement
+    fun pingInterval(duration: Duration) = apply {
+      pingInterval = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
     }
 
     fun build(): OkHttpClient = OkHttpClient(this)
   }
 
   companion object {
-    internal val DEFAULT_PROTOCOLS = Util.immutableList(HTTP_2, HTTP_1_1)
+    internal val DEFAULT_PROTOCOLS = immutableListOf(HTTP_2, HTTP_1_1)
 
-    internal val DEFAULT_CONNECTION_SPECS = Util.immutableList(
+    internal val DEFAULT_CONNECTION_SPECS = immutableListOf(
         ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT)
 
-    init {
-      Internal.instance = object : Internal() {
-        override fun realConnectionPool(connectionPool: ConnectionPool) =
-            connectionPool.delegate
-
-        override fun equalsNonHost(a: Address, b: Address) = a.equalsNonHost(b)
-
-        override fun code(responseBuilder: Response.Builder) = responseBuilder.code
-
-        override fun newWebSocketCall(client: OkHttpClient, originalRequest: Request) =
-            RealCall.newRealCall(client, originalRequest, true)
-
-        override fun initExchange(responseBuilder: Response.Builder, exchange: Exchange) {
-          responseBuilder.initExchange(exchange)
-        }
-
-        override fun exchange(response: Response) = response.exchange
-      }
-    }
-
     private fun newSslSocketFactory(trustManager: X509TrustManager): SSLSocketFactory {
       try {
         val sslContext = Platform.get().newSSLContext()
diff --git a/okhttp/src/main/java/okhttp3/RealCall.kt b/okhttp/src/main/java/okhttp3/RealCall.kt
index 7950927a6b..34057964b2 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.kt
+++ b/okhttp/src/main/java/okhttp3/RealCall.kt
@@ -15,9 +15,8 @@
  */
 package okhttp3
 
-import okhttp3.internal.NamedRunnable
-import okhttp3.internal.Util.closeQuietly
 import okhttp3.internal.cache.CacheInterceptor
+import okhttp3.internal.closeQuietly
 import okhttp3.internal.connection.ConnectInterceptor
 import okhttp3.internal.connection.Transmitter
 import okhttp3.internal.http.BridgeInterceptor
@@ -26,17 +25,17 @@ import okhttp3.internal.http.RealInterceptorChain
 import okhttp3.internal.http.RetryAndFollowUpInterceptor
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.platform.Platform.Companion.INFO
+import okhttp3.internal.threadName
 import okio.Timeout
 import java.io.IOException
 import java.io.InterruptedIOException
-import java.util.ArrayList
 import java.util.concurrent.ExecutorService
 import java.util.concurrent.RejectedExecutionException
 import java.util.concurrent.atomic.AtomicInteger
 
 internal class RealCall private constructor(
   val client: OkHttpClient,
-  /** The application's original request unadulterated by redirects or auth headers.  */
+  /** The application's original request unadulterated by redirects or auth headers. */
   val originalRequest: Request,
   val forWebSocket: Boolean
 ) : Call {
@@ -63,10 +62,10 @@ internal class RealCall private constructor(
     transmitter.timeoutEnter()
     transmitter.callStart()
     try {
-      client.dispatcher().executed(this)
+      client.dispatcher.executed(this)
       return getResponseWithInterceptorChain()
     } finally {
-      client.dispatcher().finished(this)
+      client.dispatcher.finished(this)
     }
   }
 
@@ -76,7 +75,7 @@ internal class RealCall private constructor(
       executed = true
     }
     transmitter.callStart()
-    client.dispatcher().enqueue(AsyncCall(responseCallback))
+    client.dispatcher.enqueue(AsyncCall(responseCallback))
   }
 
   override fun cancel() {
@@ -87,12 +86,12 @@ internal class RealCall private constructor(
 
   @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
   override fun clone(): RealCall {
-    return RealCall.newRealCall(client, originalRequest, forWebSocket)
+    return newRealCall(client, originalRequest, forWebSocket)
   }
 
   internal inner class AsyncCall(
     private val responseCallback: Callback
-  ) : NamedRunnable("OkHttp %s", redactedUrl()) {
+  ) : Runnable {
     @Volatile private var callsPerHost = AtomicInteger(0)
 
     fun callsPerHost(): AtomicInteger = callsPerHost
@@ -101,18 +100,18 @@ internal class RealCall private constructor(
       this.callsPerHost = other.callsPerHost
     }
 
-    fun host(): String = originalRequest.url().host()
+    fun host(): String = originalRequest.url.host
 
     fun request(): Request = originalRequest
 
     fun get(): RealCall = this@RealCall
 
     /**
-     * Attempt to enqueue this async call on `executorService`. This will attempt to clean up
+     * Attempt to enqueue this async call on [executorService]. This will attempt to clean up
      * if the executor has been shut down by reporting the call as failed.
      */
     fun executeOn(executorService: ExecutorService) {
-      assert(!Thread.holdsLock(client.dispatcher()))
+      assert(!Thread.holdsLock(client.dispatcher))
       var success = false
       try {
         executorService.execute(this)
@@ -124,27 +123,29 @@ internal class RealCall private constructor(
         responseCallback.onFailure(this@RealCall, ioException)
       } finally {
         if (!success) {
-          client.dispatcher().finished(this) // This call is no longer running!
+          client.dispatcher.finished(this) // This call is no longer running!
         }
       }
     }
 
-    override fun execute() {
-      var signalledCallback = false
-      transmitter.timeoutEnter()
-      try {
-        val response = getResponseWithInterceptorChain()
-        signalledCallback = true
-        responseCallback.onResponse(this@RealCall, response)
-      } catch (e: IOException) {
-        if (signalledCallback) {
-          // Do not signal the callback twice!
-          Platform.get().log(INFO, "Callback failure for ${toLoggableString()}", e)
-        } else {
-          responseCallback.onFailure(this@RealCall, e)
+    override fun run() {
+      threadName("OkHttp ${redactedUrl()}") {
+        var signalledCallback = false
+        transmitter.timeoutEnter()
+        try {
+          val response = getResponseWithInterceptorChain()
+          signalledCallback = true
+          responseCallback.onResponse(this@RealCall, response)
+        } catch (e: IOException) {
+          if (signalledCallback) {
+            // Do not signal the callback twice!
+            Platform.get().log(INFO, "Callback failure for ${toLoggableString()}", e)
+          } else {
+            responseCallback.onFailure(this@RealCall, e)
+          }
+        } finally {
+          client.dispatcher.finished(this)
         }
-      } finally {
-        client.dispatcher().finished(this)
       }
     }
   }
@@ -159,31 +160,30 @@ internal class RealCall private constructor(
         " to " + redactedUrl())
   }
 
-  fun redactedUrl(): String = originalRequest.url().redact()
+  fun redactedUrl(): String = originalRequest.url.redact()
 
   @Throws(IOException::class)
   fun getResponseWithInterceptorChain(): Response {
     // Build a full stack of interceptors.
-    val interceptors = ArrayList<Interceptor>()
-    interceptors.addAll(client.interceptors())
-    interceptors.add(RetryAndFollowUpInterceptor(client))
-    interceptors.add(BridgeInterceptor(client.cookieJar()))
-    interceptors.add(CacheInterceptor(client.internalCache()))
-    interceptors.add(ConnectInterceptor(client))
+    val interceptors = mutableListOf<Interceptor>()
+    interceptors += client.interceptors
+    interceptors += RetryAndFollowUpInterceptor(client)
+    interceptors += BridgeInterceptor(client.cookieJar)
+    interceptors += CacheInterceptor(client.cache)
+    interceptors += ConnectInterceptor
     if (!forWebSocket) {
-      interceptors.addAll(client.networkInterceptors())
+      interceptors += client.networkInterceptors
     }
-    interceptors.add(CallServerInterceptor(forWebSocket))
+    interceptors += CallServerInterceptor(forWebSocket)
 
-    val chain = RealInterceptorChain(interceptors, transmitter, null, 0,
-        originalRequest, this, client.connectTimeoutMillis(),
-        client.readTimeoutMillis(), client.writeTimeoutMillis())
+    val chain = RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this,
+        client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis)
 
     var calledNoMoreExchanges = false
     try {
       val response = chain.proceed(originalRequest)
       if (transmitter.isCanceled) {
-        closeQuietly(response)
+        response.closeQuietly()
         throw IOException("Canceled")
       }
       return response
diff --git a/okhttp/src/main/java/okhttp3/Request.kt b/okhttp/src/main/java/okhttp3/Request.kt
index 244bd86aef..8a0f1e425e 100644
--- a/okhttp/src/main/java/okhttp3/Request.kt
+++ b/okhttp/src/main/java/okhttp3/Request.kt
@@ -15,8 +15,10 @@
  */
 package okhttp3
 
-import okhttp3.internal.Util
+import okhttp3.HttpUrl.Companion.toHttpUrl
+import okhttp3.internal.EMPTY_REQUEST
 import okhttp3.internal.http.HttpMethod
+import okhttp3.internal.toImmutableMap
 import java.net.URL
 
 /**
@@ -24,32 +26,22 @@ import java.net.URL
  * immutable.
  */
 class Request internal constructor(
-  internal val url: HttpUrl,
-  builder: Builder
+  @get:JvmName("url") val url: HttpUrl,
+  @get:JvmName("method") val method: String,
+  @get:JvmName("headers") val headers: Headers,
+  @get:JvmName("body") val body: RequestBody?,
+  internal val tags: Map<Class<*>, Any>
 ) {
-  internal val method: String = builder.method
-  internal val headers: Headers = builder.headers.build()
-  internal val body: RequestBody? = builder.body
-  internal val tags: Map<Class<*>, Any> = Util.immutableMap(builder.tags)
 
-  @Volatile
-  private var cacheControl: CacheControl? = null // Lazily initialized
+  private var lazyCacheControl: CacheControl? = null
 
   val isHttps: Boolean
     get() = url.isHttps
 
-  fun url(): HttpUrl = url
-
-  fun method(): String = method
-
-  fun headers(): Headers = headers
-
   fun header(name: String): String? = headers[name]
 
   fun headers(name: String): List<String> = headers.values(name)
 
-  fun body(): RequestBody? = body
-
   /**
    * Returns the tag attached with `Object.class` as a key, or null if no tag is attached with
    * that key.
@@ -72,13 +64,74 @@ class Request internal constructor(
    * Returns the cache control directives for this response. This is never null, even if this
    * response contains no `Cache-Control` header.
    */
-  fun cacheControl(): CacheControl {
-    return cacheControl ?: CacheControl.parse(headers).also {
-      this.cacheControl = it
+  @get:JvmName("cacheControl") val cacheControl: CacheControl
+    get() {
+      var result = lazyCacheControl
+      if (result == null) {
+        result = CacheControl.parse(headers)
+        lazyCacheControl = result
+      }
+      return result
     }
-  }
 
-  override fun toString(): String = "Request{method=$method, url=$url, tags=$tags}"
+  @JvmName("-deprecated_url")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "url"),
+      level = DeprecationLevel.ERROR)
+  fun url(): HttpUrl = url
+
+  @JvmName("-deprecated_method")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "method"),
+      level = DeprecationLevel.ERROR)
+  fun method(): String = method
+
+  @JvmName("-deprecated_headers")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "headers"),
+      level = DeprecationLevel.ERROR)
+  fun headers(): Headers = headers
+
+  @JvmName("-deprecated_body")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "body"),
+      level = DeprecationLevel.ERROR)
+  fun body(): RequestBody? = body
+
+  @JvmName("-deprecated_cacheControl")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "cacheControl"),
+      level = DeprecationLevel.ERROR)
+  fun cacheControl(): CacheControl = cacheControl
+
+  override fun toString() = buildString {
+    append("Request{method=")
+    append(method)
+    append(", url=")
+    append(url)
+    if (headers.size != 0) {
+      append(", headers=[")
+      headers.forEachIndexed { index, (name, value) ->
+        if (index > 0) {
+          append(", ")
+        }
+        append(name)
+        append(':')
+        append(value)
+      }
+      append(']')
+    }
+    if (tags.isNotEmpty()) {
+      append(", tags=")
+      append(tags)
+    }
+    append('}')
+  }
 
   open class Builder {
     internal var url: HttpUrl? = null
@@ -119,16 +172,16 @@ class Request internal constructor(
     open fun url(url: String): Builder {
       // Silently replace web socket URLs with HTTP URLs.
       val finalUrl: String = when {
-        url.regionMatches(0, "ws:", 0, 3, ignoreCase = true) -> {
+        url.startsWith("ws:", ignoreCase = true) -> {
           "http:${url.substring(3)}"
         }
-        url.regionMatches(0, "wss:", 0, 4, ignoreCase = true) -> {
+        url.startsWith("wss:", ignoreCase = true) -> {
           "https:${url.substring(4)}"
         }
         else -> url
       }
 
-      return url(HttpUrl.get(finalUrl))
+      return url(finalUrl.toHttpUrl())
     }
 
     /**
@@ -136,7 +189,7 @@ class Request internal constructor(
      *
      * @throws IllegalArgumentException if the scheme of [url] is not `http` or `https`.
      */
-    open fun url(url: URL) = url(HttpUrl.get(url.toString()))
+    open fun url(url: URL) = url(url.toString().toHttpUrl())
 
     /**
      * Sets the header named [name] to [value]. If this request already has any headers
@@ -187,7 +240,7 @@ class Request internal constructor(
     open fun post(body: RequestBody) = method("POST", body)
 
     @JvmOverloads
-    open fun delete(body: RequestBody? = Util.EMPTY_REQUEST) = method("DELETE", body)
+    open fun delete(body: RequestBody? = EMPTY_REQUEST) = method("DELETE", body)
 
     open fun put(body: RequestBody) = method("PUT", body)
 
@@ -231,9 +284,14 @@ class Request internal constructor(
       }
     }
 
-    open fun build(): Request = Request(
-        checkNotNull(url) { "url == null" },
-        this
-    )
+    open fun build(): Request {
+      return Request(
+          checkNotNull(url) { "url == null" },
+          method,
+          headers.build(),
+          body,
+          tags.toImmutableMap()
+      )
+    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/RequestBody.kt b/okhttp/src/main/java/okhttp3/RequestBody.kt
index cd3def54ce..ac32b32fab 100644
--- a/okhttp/src/main/java/okhttp3/RequestBody.kt
+++ b/okhttp/src/main/java/okhttp3/RequestBody.kt
@@ -15,7 +15,8 @@
  */
 package okhttp3
 
-import okhttp3.internal.Util
+import okhttp3.MediaType.Companion.toMediaTypeOrNull
+import okhttp3.internal.checkOffsetAndCount
 import okio.BufferedSink
 import okio.ByteString
 import okio.source
@@ -34,7 +35,7 @@ abstract class RequestBody {
    * or -1 if that count is unknown.
    */
   @Throws(IOException::class)
-  open fun contentLength(): Long = -1
+  open fun contentLength(): Long = -1L
 
   /** Writes the content of this request to [sink]. */
   @Throws(IOException::class)
@@ -91,72 +92,125 @@ abstract class RequestBody {
   companion object {
 
     /**
-     * Returns a new request body that transmits [content]. If [contentType] is non-null
-     * and lacks a charset, this will use UTF-8.
+     * Returns a new request body that transmits this string. If [contentType] is non-null and lacks
+     * a charset, this will use UTF-8.
      */
     @JvmStatic
-    fun create(contentType: MediaType?, content: String): RequestBody {
+    @JvmName("create")
+    fun String.toRequestBody(contentType: MediaType? = null): RequestBody {
       var charset: Charset = UTF_8
       var finalContentType: MediaType? = contentType
       if (contentType != null) {
         val resolvedCharset = contentType.charset()
         if (resolvedCharset == null) {
           charset = UTF_8
-          finalContentType = MediaType.parse("$contentType; charset=utf-8")
+          finalContentType = "$contentType; charset=utf-8".toMediaTypeOrNull()
         } else {
           charset = resolvedCharset
         }
       }
-      val bytes = content.toByteArray(charset)
-      return create(finalContentType, bytes)
+      val bytes = toByteArray(charset)
+      return bytes.toRequestBody(finalContentType, 0, bytes.size)
     }
 
-    /** Returns a new request body that transmits [content]. */
+    /** Returns a new request body that transmits this. */
     @JvmStatic
-    fun create(
-      contentType: MediaType?,
-      content: ByteString
-    ): RequestBody = object : RequestBody() {
-      override fun contentType() = contentType
+    @JvmName("create")
+    fun ByteString.toRequestBody(contentType: MediaType? = null): RequestBody {
+      return object : RequestBody() {
+        override fun contentType() = contentType
 
-      override fun contentLength() = content.size.toLong()
+        override fun contentLength() = size.toLong()
 
-      override fun writeTo(sink: BufferedSink) {
-        sink.write(content)
+        override fun writeTo(sink: BufferedSink) {
+          sink.write(this@toRequestBody)
+        }
       }
     }
 
-    /** Returns a new request body that transmits [content]. */
+    /** Returns a new request body that transmits this. */
     @JvmOverloads
     @JvmStatic
-    fun create(
-      contentType: MediaType?,
-      content: ByteArray,
+    @JvmName("create")
+    fun ByteArray.toRequestBody(
+      contentType: MediaType? = null,
       offset: Int = 0,
-      byteCount: Int = content.size
+      byteCount: Int = size
     ): RequestBody {
-      Util.checkOffsetAndCount(content.size.toLong(), offset.toLong(), byteCount.toLong())
+      checkOffsetAndCount(size.toLong(), offset.toLong(), byteCount.toLong())
       return object : RequestBody() {
         override fun contentType() = contentType
 
         override fun contentLength() = byteCount.toLong()
 
         override fun writeTo(sink: BufferedSink) {
-          sink.write(content, offset, byteCount)
+          sink.write(this@toRequestBody, offset, byteCount)
         }
       }
     }
 
-    /** Returns a new request body that transmits the content of [file]. */
+    /** Returns a new request body that transmits the content of this. */
     @JvmStatic
-    fun create(contentType: MediaType?, file: File): RequestBody = object : RequestBody() {
-      override fun contentType() = contentType
+    @JvmName("create")
+    fun File.asRequestBody(contentType: MediaType? = null): RequestBody {
+      return object : RequestBody() {
+        override fun contentType() = contentType
 
-      override fun contentLength() = file.length()
+        override fun contentLength() = length()
 
-      override fun writeTo(sink: BufferedSink) {
-        file.source().use { source -> sink.writeAll(source) }
+        override fun writeTo(sink: BufferedSink) {
+          source().use { source -> sink.writeAll(source) }
+        }
       }
     }
+
+    @JvmStatic
+    @Deprecated(
+        message = "Moved to extension function. Put the 'content' argument first to fix Java",
+        replaceWith = ReplaceWith(
+            expression = "content.toRequestBody(contentType)",
+            imports = ["okhttp3.RequestBody.Companion.toRequestBody"]
+        ),
+        level = DeprecationLevel.WARNING)
+    fun create(contentType: MediaType?, content: String) = content.toRequestBody(contentType)
+
+    @JvmStatic
+    @Deprecated(
+        message = "Moved to extension function. Put the 'content' argument first to fix Java",
+        replaceWith = ReplaceWith(
+            expression = "content.toRequestBody(contentType)",
+            imports = ["okhttp3.RequestBody.Companion.toRequestBody"]
+        ),
+        level = DeprecationLevel.WARNING)
+    fun create(
+      contentType: MediaType?,
+      content: ByteString
+    ): RequestBody = content.toRequestBody(contentType)
+
+    @JvmOverloads
+    @JvmStatic
+    @Deprecated(
+        message = "Moved to extension function. Put the 'content' argument first to fix Java",
+        replaceWith = ReplaceWith(
+            expression = "content.toRequestBody(contentType, offset, byteCount)",
+            imports = ["okhttp3.RequestBody.Companion.toRequestBody"]
+        ),
+        level = DeprecationLevel.WARNING)
+    fun create(
+      contentType: MediaType?,
+      content: ByteArray,
+      offset: Int = 0,
+      byteCount: Int = content.size
+    ) = content.toRequestBody(contentType, offset, byteCount)
+
+    @JvmStatic
+    @Deprecated(
+        message = "Moved to extension function. Put the 'file' argument first to fix Java",
+        replaceWith = ReplaceWith(
+            expression = "file.asRequestBody(contentType)",
+            imports = ["okhttp3.RequestBody.Companion.asRequestBody"]
+        ),
+        level = DeprecationLevel.WARNING)
+    fun create(contentType: MediaType?, file: File) = file.asRequestBody(contentType)
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Response.kt b/okhttp/src/main/java/okhttp3/Response.kt
index 144071fd62..9456f93dc6 100644
--- a/okhttp/src/main/java/okhttp3/Response.kt
+++ b/okhttp/src/main/java/okhttp3/Response.kt
@@ -15,14 +15,14 @@
  */
 package okhttp3
 
-import java.io.Closeable
-import java.io.IOException
+import okhttp3.ResponseBody.Companion.asResponseBody
 import okhttp3.internal.connection.Exchange
-import okhttp3.internal.http.HttpHeaders
 import okhttp3.internal.http.StatusLine.Companion.HTTP_PERM_REDIRECT
 import okhttp3.internal.http.StatusLine.Companion.HTTP_TEMP_REDIRECT
+import okhttp3.internal.http.parseChallenges
 import okio.Buffer
-
+import java.io.Closeable
+import java.io.IOException
 import java.net.HttpURLConnection.HTTP_MOVED_PERM
 import java.net.HttpURLConnection.HTTP_MOVED_TEMP
 import java.net.HttpURLConnection.HTTP_MULT_CHOICE
@@ -38,25 +38,6 @@ import java.net.HttpURLConnection.HTTP_UNAUTHORIZED
  * [ResponseBody] for an explanation and examples.
  */
 class Response internal constructor(
-  internal val request: Request,
-  internal val protocol: Protocol,
-  internal val message: String,
-  builder: Builder
-) : Closeable {
-  internal val code: Int = builder.code
-  internal val handshake: Handshake? = builder.handshake
-  internal val headers: Headers = builder.headers.build()
-  internal val body: ResponseBody? = builder.body
-  internal val networkResponse: Response? = builder.networkResponse
-  internal val cacheResponse: Response? = builder.cacheResponse
-  internal val priorResponse: Response? = builder.priorResponse
-  internal val sentRequestAtMillis: Long = builder.sentRequestAtMillis
-  internal val receivedResponseAtMillis: Long = builder.receivedResponseAtMillis
-  internal val exchange: Exchange? = builder.exchange
-
-  @Volatile
-  private var cacheControl: CacheControl? = null // Lazily initialized.
-
   /**
    * The wire-level request that initiated this HTTP response. This is not necessarily the same
    * request issued by the application:
@@ -66,12 +47,96 @@ class Response internal constructor(
    * * It may be the request generated in response to an HTTP redirect or authentication
    *   challenge. In this case the request URL may be different than the initial request URL.
    */
-  fun request(): Request = request
+  @get:JvmName("request") val request: Request,
 
   /** Returns the HTTP protocol, such as [Protocol.HTTP_1_1] or [Protocol.HTTP_1_0]. */
-  fun protocol(): Protocol = protocol
+  @get:JvmName("protocol") val protocol: Protocol,
+
+  /** Returns the HTTP status message. */
+  @get:JvmName("message") val message: String,
 
   /** Returns the HTTP status code. */
+  @get:JvmName("code") val code: Int,
+
+  /**
+   * Returns the TLS handshake of the connection that carried this response, or null if the
+   * response was received without TLS.
+   */
+  @get:JvmName("handshake") val handshake: Handshake?,
+
+  /** Returns the HTTP headers. */
+  @get:JvmName("headers") val headers: Headers,
+
+  /**
+   * Returns a non-null value if this response was passed to [Callback.onResponse] or returned
+   * from [Call.execute]. Response bodies must be [closed][ResponseBody] and may
+   * be consumed only once.
+   *
+   * This always returns null on responses returned from [cacheResponse], [networkResponse],
+   * and [priorResponse].
+   */
+  @get:JvmName("body") val body: ResponseBody?,
+
+  /**
+   * Returns the raw response received from the network. Will be null if this response didn't use
+   * the network, such as when the response is fully cached. The body of the returned response
+   * should not be read.
+   */
+  @get:JvmName("networkResponse") val networkResponse: Response?,
+
+  /**
+   * Returns the raw response received from the cache. Will be null if this response didn't use
+   * the cache. For conditional get requests the cache response and network response may both be
+   * non-null. The body of the returned response should not be read.
+   */
+  @get:JvmName("cacheResponse") val cacheResponse: Response?,
+
+  /**
+   * Returns the response for the HTTP redirect or authorization challenge that triggered this
+   * response, or null if this response wasn't triggered by an automatic retry. The body of the
+   * returned response should not be read because it has already been consumed by the redirecting
+   * client.
+   */
+  @get:JvmName("priorResponse") val priorResponse: Response?,
+
+  /**
+   * Returns a [timestamp][System.currentTimeMillis] taken immediately before OkHttp
+   * transmitted the initiating request over the network. If this response is being served from the
+   * cache then this is the timestamp of the original request.
+   */
+  @get:JvmName("sentRequestAtMillis") val sentRequestAtMillis: Long,
+
+  /**
+   * Returns a [timestamp][System.currentTimeMillis] taken immediately after OkHttp
+   * received this response's headers from the network. If this response is being served from the
+   * cache then this is the timestamp of the original response.
+   */
+  @get:JvmName("receivedResponseAtMillis") val receivedResponseAtMillis: Long,
+
+  @get:JvmName("exchange") internal val exchange: Exchange?
+) : Closeable {
+
+  private var lazyCacheControl: CacheControl? = null
+
+  @JvmName("-deprecated_request")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "request"),
+      level = DeprecationLevel.ERROR)
+  fun request(): Request = request
+
+  @JvmName("-deprecated_protocol")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "protocol"),
+      level = DeprecationLevel.ERROR)
+  fun protocol(): Protocol = protocol
+
+  @JvmName("-deprecated_code")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "code"),
+      level = DeprecationLevel.ERROR)
   fun code(): Int = code
 
   /**
@@ -81,13 +146,18 @@ class Response internal constructor(
   val isSuccessful: Boolean
     get() = code in 200..299
 
-  /** Returns the HTTP status message. */
+  @JvmName("-deprecated_message")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "message"),
+      level = DeprecationLevel.ERROR)
   fun message(): String = message
 
-  /**
-   * Returns the TLS handshake of the connection that carried this response, or null if the
-   * response was received without TLS.
-   */
+  @JvmName("-deprecated_handshake")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "handshake"),
+      level = DeprecationLevel.ERROR)
   fun handshake(): Handshake? = handshake
 
   fun headers(name: String): List<String> = headers.values(name)
@@ -95,6 +165,11 @@ class Response internal constructor(
   @JvmOverloads
   fun header(name: String, defaultValue: String? = null): String? = headers[name] ?: defaultValue
 
+  @JvmName("-deprecated_headers")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "headers"),
+      level = DeprecationLevel.ERROR)
   fun headers(): Headers = headers
 
   /**
@@ -120,18 +195,15 @@ class Response internal constructor(
     val peeked = body!!.source().peek()
     val buffer = Buffer()
     peeked.request(byteCount)
-    buffer.write(peeked, Math.min(byteCount, peeked.buffer.size))
-    return ResponseBody.create(body.contentType(), buffer.size, buffer)
+    buffer.write(peeked, minOf(byteCount, peeked.buffer.size))
+    return buffer.asResponseBody(body.contentType(), buffer.size)
   }
 
-  /**
-   * Returns a non-null value if this response was passed to [Callback.onResponse] or returned
-   * from [Call.execute]. Response bodies must be [closed][ResponseBody] and may
-   * be consumed only once.
-   *
-   * This always returns null on responses returned from [cacheResponse], [networkResponse],
-   * and [priorResponse].
-   */
+  @JvmName("-deprecated_body")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "body"),
+      level = DeprecationLevel.ERROR)
   fun body(): ResponseBody? = body
 
   fun newBuilder(): Builder = Builder(this)
@@ -143,26 +215,25 @@ class Response internal constructor(
       else -> false
     }
 
-  /**
-   * Returns the raw response received from the network. Will be null if this response didn't use
-   * the network, such as when the response is fully cached. The body of the returned response
-   * should not be read.
-   */
+  @JvmName("-deprecated_networkResponse")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "networkResponse"),
+      level = DeprecationLevel.ERROR)
   fun networkResponse(): Response? = networkResponse
 
-  /**
-   * Returns the raw response received from the cache. Will be null if this response didn't use
-   * the cache. For conditional get requests the cache response and network response may both be
-   * non-null. The body of the returned response should not be read.
-   */
+  @JvmName("-deprecated_cacheResponse")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "cacheResponse"),
+      level = DeprecationLevel.ERROR)
   fun cacheResponse(): Response? = cacheResponse
 
-  /**
-   * Returns the response for the HTTP redirect or authorization challenge that triggered this
-   * response, or null if this response wasn't triggered by an automatic retry. The body of the
-   * returned response should not be read because it has already been consumed by the redirecting
-   * client.
-   */
+  @JvmName("-deprecated_priorResponse")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "priorResponse"),
+      level = DeprecationLevel.ERROR)
   fun priorResponse(): Response? = priorResponse
 
   /**
@@ -177,8 +248,7 @@ class Response internal constructor(
    * auth param, this is up to the caller that interprets these challenges.
    */
   fun challenges(): List<Challenge> {
-    return HttpHeaders.parseChallenges(
-        headers(),
+    return headers.parseChallenges(
         when (code) {
           HTTP_UNAUTHORIZED -> "WWW-Authenticate"
           HTTP_PROXY_AUTH -> "Proxy-Authenticate"
@@ -191,22 +261,35 @@ class Response internal constructor(
    * Returns the cache control directives for this response. This is never null, even if this
    * response contains no `Cache-Control` header.
    */
-  fun cacheControl(): CacheControl = cacheControl ?: CacheControl.parse(headers).also {
-    cacheControl = it
-  }
+  @get:JvmName("cacheControl") val cacheControl: CacheControl
+    get() {
+      var result = lazyCacheControl
+      if (result == null) {
+        result = CacheControl.parse(headers)
+        lazyCacheControl = result
+      }
+      return result
+    }
 
-  /**
-   * Returns a [timestamp][System.currentTimeMillis] taken immediately before OkHttp
-   * transmitted the initiating request over the network. If this response is being served from the
-   * cache then this is the timestamp of the original request.
-   */
+  @JvmName("-deprecated_cacheControl")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "cacheControl"),
+      level = DeprecationLevel.ERROR)
+  fun cacheControl(): CacheControl = cacheControl
+
+  @JvmName("-deprecated_sentRequestAtMillis")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "sentRequestAtMillis"),
+      level = DeprecationLevel.ERROR)
   fun sentRequestAtMillis(): Long = sentRequestAtMillis
 
-  /**
-   * Returns a [timestamp][System.currentTimeMillis] taken immediately after OkHttp
-   * received this response's headers from the network. If this response is being served from the
-   * cache then this is the timestamp of the original response.
-   */
+  @JvmName("-deprecated_receivedResponseAtMillis")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "receivedResponseAtMillis"),
+      level = DeprecationLevel.ERROR)
   fun receivedResponseAtMillis(): Long = receivedResponseAtMillis
 
   /**
@@ -220,7 +303,7 @@ class Response internal constructor(
   }
 
   override fun toString() =
-      "Response{protocol=$protocol, code=$code, message=$message, url=${request.url()}}"
+      "Response{protocol=$protocol, code=$code, message=$message, url=${request.url}}"
 
   open class Builder {
     internal var request: Request? = null
@@ -350,12 +433,22 @@ class Response internal constructor(
     }
 
     open fun build(): Response {
-      check(code > 0) { "code < 0: $code" }
+      check(code >= 0) { "code < 0: $code" }
       return Response(
           checkNotNull(request) { "request == null" },
           checkNotNull(protocol) { "protocol == null" },
           checkNotNull(message) { "message == null" },
-          this)
+          code,
+          handshake,
+          headers.build(),
+          body,
+          networkResponse,
+          cacheResponse,
+          priorResponse,
+          sentRequestAtMillis,
+          receivedResponseAtMillis,
+          exchange
+      )
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.kt b/okhttp/src/main/java/okhttp3/ResponseBody.kt
index ce63dfb1a0..04731370d1 100644
--- a/okhttp/src/main/java/okhttp3/ResponseBody.kt
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.kt
@@ -15,7 +15,9 @@
  */
 package okhttp3
 
-import okhttp3.internal.Util
+import okhttp3.MediaType.Companion.toMediaTypeOrNull
+import okhttp3.internal.closeQuietly
+import okhttp3.internal.readBomAsCharset
 import okio.Buffer
 import okio.BufferedSource
 import okio.ByteString
@@ -119,16 +121,31 @@ abstract class ResponseBody : Closeable {
    * possibility for your response.
    */
   @Throws(IOException::class)
-  fun bytes(): ByteArray {
+  fun bytes() = consumeSource(BufferedSource::readByteArray) { it.size }
+
+  /**
+   * Returns the response as a [ByteString].
+   *
+   * This method loads entire response body into memory. If the response body is very large this
+   * may trigger an [OutOfMemoryError]. Prefer to stream the response body if this is a
+   * possibility for your response.
+   */
+  @Throws(IOException::class)
+  fun byteString() = consumeSource(BufferedSource::readByteString) { it.size }
+
+  private inline fun <T : Any> consumeSource(
+    consumer: (BufferedSource) -> T,
+    sizeMapper: (T) -> Int
+  ): T {
     val contentLength = contentLength()
-    if (contentLength > Integer.MAX_VALUE) {
+    if (contentLength > Int.MAX_VALUE) {
       throw IOException("Cannot buffer entire body for content length: $contentLength")
     }
 
-    val bytes: ByteArray = source().use(BufferedSource::readByteArray)
-    if (contentLength != -1L && contentLength != bytes.size.toLong()) {
-      throw IOException(
-          "Content-Length ($contentLength) and stream length (${bytes.size}) disagree")
+    val bytes = source().use(consumer)
+    val size = sizeMapper(bytes)
+    if (contentLength != -1L && contentLength != size.toLong()) {
+      throw IOException("Content-Length ($contentLength) and stream length ($size) disagree")
     }
     return bytes
   }
@@ -167,12 +184,12 @@ abstract class ResponseBody : Closeable {
    */
   @Throws(IOException::class)
   fun string(): String = source().use { source ->
-    source.readString(charset = Util.bomAwareCharset(source, charset()))
+    source.readString(charset = source.readBomAsCharset(charset()))
   }
 
   private fun charset() = contentType()?.charset(UTF_8) ?: UTF_8
 
-  override fun close() = Util.closeQuietly(source())
+  override fun close() = source().closeQuietly()
 
   internal class BomAwareReader(
     private val source: BufferedSource,
@@ -188,7 +205,7 @@ abstract class ResponseBody : Closeable {
 
       val finalDelegate = delegate ?: InputStreamReader(
           source.inputStream(),
-          Util.bomAwareCharset(source, charset)).also {
+          source.readBomAsCharset(charset)).also {
         delegate = it
       }
       return finalDelegate.read(cbuf, off, len)
@@ -202,54 +219,102 @@ abstract class ResponseBody : Closeable {
   }
 
   companion object {
-
     /**
-     * Returns a new response body that transmits [content]. If `contentType` is non-null
-     * and lacks a charset, this will use UTF-8.
+     * Returns a new response body that transmits this string. If [contentType] is non-null and
+     * lacks a charset, this will use UTF-8.
      */
     @JvmStatic
-    fun create(contentType: MediaType?, content: String): ResponseBody {
+    @JvmName("create")
+    fun String.toResponseBody(contentType: MediaType? = null): ResponseBody {
       var charset: Charset = UTF_8
       var finalContentType: MediaType? = contentType
       if (contentType != null) {
         val resolvedCharset = contentType.charset()
         if (resolvedCharset == null) {
           charset = UTF_8
-          finalContentType = MediaType.parse("$contentType; charset=utf-8")
+          finalContentType = "$contentType; charset=utf-8".toMediaTypeOrNull()
         } else {
           charset = resolvedCharset
         }
       }
-      val buffer = Buffer().writeString(content, charset)
-      return create(finalContentType, buffer.size, buffer)
+      val buffer = Buffer().writeString(this, charset)
+      return buffer.asResponseBody(finalContentType, buffer.size)
     }
 
-    /** Returns a new response body that transmits [content]. */
+    /** Returns a new response body that transmits this byte array. */
     @JvmStatic
-    fun create(contentType: MediaType?, content: ByteArray): ResponseBody {
-      val buffer = Buffer().write(content)
-      return create(contentType, content.size.toLong(), buffer)
+    @JvmName("create")
+    fun ByteArray.toResponseBody(contentType: MediaType? = null): ResponseBody {
+      return Buffer()
+          .write(this)
+          .asResponseBody(contentType, size.toLong())
     }
 
-    /** Returns a new response body that transmits [content]. */
+    /** Returns a new response body that transmits this byte string. */
     @JvmStatic
-    fun create(contentType: MediaType?, content: ByteString): ResponseBody {
-      val buffer = Buffer().write(content)
-      return create(contentType, content.size.toLong(), buffer)
+    @JvmName("create")
+    fun ByteString.toResponseBody(contentType: MediaType? = null): ResponseBody {
+      return Buffer()
+          .write(this)
+          .asResponseBody(contentType, size.toLong())
     }
 
-    /** Returns a new response body that transmits [content]. */
+    /** Returns a new response body that transmits this source. */
     @JvmStatic
-    fun create(
-      contentType: MediaType?,
-      contentLength: Long,
-      content: BufferedSource
+    @JvmName("create")
+    fun BufferedSource.asResponseBody(
+      contentType: MediaType? = null,
+      contentLength: Long = -1L
     ): ResponseBody = object : ResponseBody() {
       override fun contentType() = contentType
 
       override fun contentLength() = contentLength
 
-      override fun source() = content
+      override fun source() = this@asResponseBody
     }
+
+    @JvmStatic
+    @Deprecated(
+        message = "Moved to extension function. Put the 'content' argument first to fix Java",
+        replaceWith = ReplaceWith(
+            expression = "content.toResponseBody(contentType)",
+            imports = ["okhttp3.ResponseBody.Companion.toResponseBody"]
+        ),
+        level = DeprecationLevel.WARNING)
+    fun create(contentType: MediaType?, content: String) = content.toResponseBody(contentType)
+
+    @JvmStatic
+    @Deprecated(
+        message = "Moved to extension function. Put the 'content' argument first to fix Java",
+        replaceWith = ReplaceWith(
+            expression = "content.toResponseBody(contentType)",
+            imports = ["okhttp3.ResponseBody.Companion.toResponseBody"]
+        ),
+        level = DeprecationLevel.WARNING)
+    fun create(contentType: MediaType?, content: ByteArray) = content.toResponseBody(contentType)
+
+    @JvmStatic
+    @Deprecated(
+        message = "Moved to extension function. Put the 'content' argument first to fix Java",
+        replaceWith = ReplaceWith(
+            expression = "content.toResponseBody(contentType)",
+            imports = ["okhttp3.ResponseBody.Companion.toResponseBody"]
+        ),
+        level = DeprecationLevel.WARNING)
+    fun create(contentType: MediaType?, content: ByteString) = content.toResponseBody(contentType)
+
+    @JvmStatic
+    @Deprecated(
+        message = "Moved to extension function. Put the 'content' argument first to fix Java",
+        replaceWith = ReplaceWith(
+            expression = "content.asResponseBody(contentType, contentLength)",
+            imports = ["okhttp3.ResponseBody.Companion.asResponseBody"]
+        ),
+        level = DeprecationLevel.WARNING)
+    fun create(
+      contentType: MediaType?,
+      contentLength: Long,
+      content: BufferedSource
+    ) = content.asResponseBody(contentType, contentLength)
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Route.kt b/okhttp/src/main/java/okhttp3/Route.kt
index 277dcc7609..6913ee8c11 100644
--- a/okhttp/src/main/java/okhttp3/Route.kt
+++ b/okhttp/src/main/java/okhttp3/Route.kt
@@ -31,23 +31,38 @@ import java.net.Proxy
  *
  * Each route is a specific selection of these options.
  */
-data class Route(
-  internal val address: Address,
-  internal val proxy: Proxy,
-  internal val inetSocketAddress: InetSocketAddress
-) {
-
-  fun address(): Address = address
-
+class Route(
+  @get:JvmName("address") val address: Address,
   /**
    * Returns the [Proxy] of this route.
    *
    * **Warning:** This may disagree with [Address.proxy] when it is null. When
    * the address's proxy is null, the proxy selector is used.
    */
+  @get:JvmName("proxy") val proxy: Proxy,
+  @get:JvmName("socketAddress") val socketAddress: InetSocketAddress
+) {
+
+  @JvmName("-deprecated_address")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "address"),
+      level = DeprecationLevel.ERROR)
+  fun address(): Address = address
+
+  @JvmName("-deprecated_proxy")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "proxy"),
+      level = DeprecationLevel.ERROR)
   fun proxy(): Proxy = proxy
 
-  fun socketAddress(): InetSocketAddress = inetSocketAddress
+  @JvmName("-deprecated_socketAddress")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "socketAddress"),
+      level = DeprecationLevel.ERROR)
+  fun socketAddress(): InetSocketAddress = socketAddress
 
   /**
    * Returns true if this route tunnels HTTPS through an HTTP proxy.
@@ -55,7 +70,22 @@ data class Route(
    *
    * [rfc_2817]: http://www.ietf.org/rfc/rfc2817.txt
    */
-  fun requiresTunnel(): Boolean = address.sslSocketFactory() != null && proxy.type() == Proxy.Type.HTTP
+  fun requiresTunnel() = address.sslSocketFactory != null && proxy.type() == Proxy.Type.HTTP
+
+  override fun equals(other: Any?): Boolean {
+    return other is Route &&
+        other.address == address &&
+        other.proxy == proxy &&
+        other.socketAddress == socketAddress
+  }
+
+  override fun hashCode(): Int {
+    var result = 17
+    result = 31 * result + address.hashCode()
+    result = 31 * result + proxy.hashCode()
+    result = 31 * result + socketAddress.hashCode()
+    return result
+  }
 
-  override fun toString(): String = "Route{$inetSocketAddress}"
+  override fun toString(): String = "Route{$socketAddress}"
 }
diff --git a/okhttp/src/main/java/okhttp3/TlsVersion.kt b/okhttp/src/main/java/okhttp3/TlsVersion.kt
index 7f583cec66..79e8a586fe 100644
--- a/okhttp/src/main/java/okhttp3/TlsVersion.kt
+++ b/okhttp/src/main/java/okhttp3/TlsVersion.kt
@@ -19,13 +19,20 @@ package okhttp3
  * Versions of TLS that can be offered when negotiating a secure socket. See
  * [javax.net.ssl.SSLSocket.setEnabledProtocols].
  */
-enum class TlsVersion(private val javaName: String) {
+enum class TlsVersion(
+  @get:JvmName("javaName") val javaName: String
+) {
   TLS_1_3("TLSv1.3"), // 2016.
   TLS_1_2("TLSv1.2"), // 2008.
   TLS_1_1("TLSv1.1"), // 2006.
   TLS_1_0("TLSv1"), // 1999.
   SSL_3_0("SSLv3"); // 1996.
 
+  @JvmName("-deprecated_javaName")
+  @Deprecated(
+      message = "moved to val",
+      replaceWith = ReplaceWith(expression = "javaName"),
+      level = DeprecationLevel.ERROR)
   fun javaName() = javaName
 
   companion object {
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
deleted file mode 100644
index 44a16ae774..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import javax.annotation.Nullable;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.ConnectionPool;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.connection.Exchange;
-import okhttp3.internal.connection.RealConnectionPool;
-
-/**
- * Escalate internal APIs in {@code okhttp3} so they can be used from OkHttp's implementation
- * packages. The only implementation of this interface is in {@link OkHttpClient}.
- */
-public abstract class Internal {
-
-  public static void initializeInstanceForTests() {
-    // Needed in tests to ensure that the instance is actually pointing to something.
-    new OkHttpClient();
-  }
-
-  public static Internal instance;
-
-  public abstract RealConnectionPool realConnectionPool(ConnectionPool connectionPool);
-
-  public abstract boolean equalsNonHost(Address a, Address b);
-
-  public abstract int code(Response.Builder responseBuilder);
-
-  public abstract Call newWebSocketCall(OkHttpClient client, Request request);
-
-  public abstract void initExchange(
-      Response.Builder responseBuilder, Exchange exchange);
-
-  public abstract @Nullable Exchange exchange(Response response);
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java b/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
deleted file mode 100644
index ff9729e2af..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/NamedRunnable.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-/**
- * Runnable implementation which always sets its thread name.
- */
-public abstract class NamedRunnable implements Runnable {
-  protected final String name;
-
-  public NamedRunnable(String format, Object... args) {
-    this.name = Util.format(format, args);
-  }
-
-  @Override public final void run() {
-    String oldName = Thread.currentThread().getName();
-    Thread.currentThread().setName(name);
-    try {
-      execute();
-    } finally {
-      Thread.currentThread().setName(oldName);
-    }
-  }
-
-  protected abstract void execute();
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
deleted file mode 100644
index 9c3f710799..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ /dev/null
@@ -1,656 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.IDN;
-import java.net.InetAddress;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.UnknownHostException;
-import java.nio.charset.Charset;
-import java.security.AccessControlException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.TimeZone;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.TimeUnit;
-import java.util.regex.Pattern;
-import javax.annotation.Nullable;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.EventListener;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import okhttp3.internal.http2.Header;
-import okhttp3.internal.platform.Platform;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Options;
-import okio.Source;
-
-import static java.nio.charset.StandardCharsets.UTF_16BE;
-import static java.nio.charset.StandardCharsets.UTF_16LE;
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static java.util.Arrays.asList;
-import static okhttp3.internal.InternalKtKt.addHeaderLenient;
-
-/** Junk drawer of utility methods. */
-public final class Util {
-  public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
-  public static final String[] EMPTY_STRING_ARRAY = new String[0];
-  public static final Headers EMPTY_HEADERS = Headers.of();
-
-  public static final ResponseBody EMPTY_RESPONSE = ResponseBody.create(null, EMPTY_BYTE_ARRAY);
-  public static final RequestBody EMPTY_REQUEST = RequestBody.create(null, EMPTY_BYTE_ARRAY);
-
-  /** Byte order marks. */
-  private static final Options UNICODE_BOMS = Options.of(
-      ByteString.decodeHex("efbbbf"),   // UTF-8
-      ByteString.decodeHex("feff"),     // UTF-16BE
-      ByteString.decodeHex("fffe"),     // UTF-16LE
-      ByteString.decodeHex("0000ffff"), // UTF-32BE
-      ByteString.decodeHex("ffff0000")  // UTF-32LE
-  );
-
-  private static final Charset UTF_32BE = Charset.forName("UTF-32BE");
-  private static final Charset UTF_32LE = Charset.forName("UTF-32LE");
-
-  /** GMT and UTC are equivalent for our purposes. */
-  public static final TimeZone UTC = TimeZone.getTimeZone("GMT");
-
-  public static final Comparator<String> NATURAL_ORDER = String::compareTo;
-
-  /**
-   * Quick and dirty pattern to differentiate IP addresses from hostnames. This is an approximation
-   * of Android's private InetAddress#isNumeric API.
-   *
-   * <p>This matches IPv6 addresses as a hex string containing at least one colon, and possibly
-   * including dots after the first colon. It matches IPv4 addresses as strings containing only
-   * decimal digits and dots. This pattern matches strings like "a:.23" and "54" that are neither IP
-   * addresses nor hostnames; they will be verified as IP addresses (which is a more strict
-   * verification).
-   */
-  private static final Pattern VERIFY_AS_IP_ADDRESS = Pattern.compile(
-      "([0-9a-fA-F]*:[0-9a-fA-F:.]*)|([\\d.]+)");
-
-  private Util() {
-  }
-
-  public static void checkOffsetAndCount(long arrayLength, long offset, long count) {
-    if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
-      throw new ArrayIndexOutOfBoundsException();
-    }
-  }
-
-  /**
-   * Closes {@code closeable}, ignoring any checked exceptions. Does nothing if {@code closeable} is
-   * null.
-   */
-  public static void closeQuietly(Closeable closeable) {
-    if (closeable != null) {
-      try {
-        closeable.close();
-      } catch (RuntimeException rethrown) {
-        throw rethrown;
-      } catch (Exception ignored) {
-      }
-    }
-  }
-
-  /**
-   * Closes {@code socket}, ignoring any checked exceptions. Does nothing if {@code socket} is
-   * null.
-   */
-  public static void closeQuietly(Socket socket) {
-    if (socket != null) {
-      try {
-        socket.close();
-      } catch (AssertionError e) {
-        if (!isAndroidGetsocknameError(e)) throw e;
-      } catch (RuntimeException rethrown) {
-        throw rethrown;
-      } catch (Exception ignored) {
-      }
-    }
-  }
-
-  /**
-   * Closes {@code serverSocket}, ignoring any checked exceptions. Does nothing if {@code
-   * serverSocket} is null.
-   */
-  public static void closeQuietly(ServerSocket serverSocket) {
-    if (serverSocket != null) {
-      try {
-        serverSocket.close();
-      } catch (RuntimeException rethrown) {
-        throw rethrown;
-      } catch (Exception ignored) {
-      }
-    }
-  }
-
-  /**
-   * Attempts to exhaust {@code source}, returning true if successful. This is useful when reading a
-   * complete source is helpful, such as when doing so completes a cache body or frees a socket
-   * connection for reuse.
-   */
-  public static boolean discard(Source source, int timeout, TimeUnit timeUnit) {
-    try {
-      return skipAll(source, timeout, timeUnit);
-    } catch (IOException e) {
-      return false;
-    }
-  }
-
-  /**
-   * Reads until {@code in} is exhausted or the deadline has been reached. This is careful to not
-   * extend the deadline if one exists already.
-   */
-  public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) throws IOException {
-    long now = System.nanoTime();
-    long originalDuration = source.timeout().hasDeadline()
-        ? source.timeout().deadlineNanoTime() - now
-        : Long.MAX_VALUE;
-    source.timeout().deadlineNanoTime(now + Math.min(originalDuration, timeUnit.toNanos(duration)));
-    try {
-      Buffer skipBuffer = new Buffer();
-      while (source.read(skipBuffer, 8192) != -1) {
-        skipBuffer.clear();
-      }
-      return true; // Success! The source has been exhausted.
-    } catch (InterruptedIOException e) {
-      return false; // We ran out of time before exhausting the source.
-    } finally {
-      if (originalDuration == Long.MAX_VALUE) {
-        source.timeout().clearDeadline();
-      } else {
-        source.timeout().deadlineNanoTime(now + originalDuration);
-      }
-    }
-  }
-
-  /** Returns an immutable copy of {@code list}. */
-  public static <T> List<T> immutableList(List<T> list) {
-    return Collections.unmodifiableList(new ArrayList<>(list));
-  }
-
-  /** Returns an immutable copy of {@code map}. */
-  public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {
-    return map.isEmpty()
-        ? Collections.emptyMap()
-        : Collections.unmodifiableMap(new LinkedHashMap<>(map));
-  }
-
-  /** Returns an immutable list containing {@code elements}. */
-  @SafeVarargs
-  public static <T> List<T> immutableList(T... elements) {
-    return Collections.unmodifiableList(asList(elements.clone()));
-  }
-
-  public static ThreadFactory threadFactory(String name, boolean daemon) {
-    return runnable -> {
-      Thread result = new Thread(runnable, name);
-      result.setDaemon(daemon);
-      return result;
-    };
-  }
-
-  /**
-   * Returns an array containing only elements found in {@code first} and also in {@code
-   * second}. The returned elements are in the same order as in {@code first}.
-   */
-  public static String[] intersect(
-      Comparator<? super String> comparator, String[] first, String[] second) {
-    List<String> result = new ArrayList<>();
-    for (String a : first) {
-      for (String b : second) {
-        if (comparator.compare(a, b) == 0) {
-          result.add(a);
-          break;
-        }
-      }
-    }
-    return result.toArray(new String[0]);
-  }
-
-  /**
-   * Returns true if there is an element in {@code first} that is also in {@code second}. This
-   * method terminates if any intersection is found. The sizes of both arguments are assumed to be
-   * so small, and the likelihood of an intersection so great, that it is not worth the CPU cost of
-   * sorting or the memory cost of hashing.
-   */
-  public static boolean nonEmptyIntersection(
-      Comparator<String> comparator, String[] first, String[] second) {
-    if (first == null || second == null || first.length == 0 || second.length == 0) {
-      return false;
-    }
-    for (String a : first) {
-      for (String b : second) {
-        if (comparator.compare(a, b) == 0) {
-          return true;
-        }
-      }
-    }
-    return false;
-  }
-
-  public static String hostHeader(HttpUrl url, boolean includeDefaultPort) {
-    String host = url.host().contains(":")
-        ? "[" + url.host() + "]"
-        : url.host();
-    return includeDefaultPort || url.port() != HttpUrl.defaultPort(url.scheme())
-        ? host + ":" + url.port()
-        : host;
-  }
-
-  /**
-   * Returns true if {@code e} is due to a firmware bug fixed after Android 4.2.2.
-   * https://code.google.com/p/android/issues/detail?id=54072
-   */
-  public static boolean isAndroidGetsocknameError(AssertionError e) {
-    return e.getCause() != null && e.getMessage() != null
-        && e.getMessage().contains("getsockname failed");
-  }
-
-  public static int indexOf(Comparator<String> comparator, String[] array, String value) {
-    for (int i = 0, size = array.length; i < size; i++) {
-      if (comparator.compare(array[i], value) == 0) return i;
-    }
-    return -1;
-  }
-
-  public static String[] concat(String[] array, String value) {
-    String[] result = Arrays.copyOf(array, array.length + 1);
-    result[result.length - 1] = value;
-    return result;
-  }
-
-  /**
-   * Increments {@code pos} until {@code input[pos]} is not ASCII whitespace. Stops at {@code
-   * limit}.
-   */
-  public static int skipLeadingAsciiWhitespace(String input, int pos, int limit) {
-    for (int i = pos; i < limit; i++) {
-      switch (input.charAt(i)) {
-        case '\t':
-        case '\n':
-        case '\f':
-        case '\r':
-        case ' ':
-          continue;
-        default:
-          return i;
-      }
-    }
-    return limit;
-  }
-
-  /**
-   * Decrements {@code limit} until {@code input[limit - 1]} is not ASCII whitespace. Stops at
-   * {@code pos}.
-   */
-  public static int skipTrailingAsciiWhitespace(String input, int pos, int limit) {
-    for (int i = limit - 1; i >= pos; i--) {
-      switch (input.charAt(i)) {
-        case '\t':
-        case '\n':
-        case '\f':
-        case '\r':
-        case ' ':
-          continue;
-        default:
-          return i + 1;
-      }
-    }
-    return pos;
-  }
-
-  /** Equivalent to {@code string.substring(pos, limit).trim()}. */
-  public static String trimSubstring(String string, int pos, int limit) {
-    int start = skipLeadingAsciiWhitespace(string, pos, limit);
-    int end = skipTrailingAsciiWhitespace(string, start, limit);
-    return string.substring(start, end);
-  }
-
-  /**
-   * Returns the index of the first character in {@code input} that contains a character in {@code
-   * delimiters}. Returns limit if there is no such character.
-   */
-  public static int delimiterOffset(String input, int pos, int limit, String delimiters) {
-    for (int i = pos; i < limit; i++) {
-      if (delimiters.indexOf(input.charAt(i)) != -1) return i;
-    }
-    return limit;
-  }
-
-  /**
-   * Returns the index of the first character in {@code input} that is {@code delimiter}. Returns
-   * limit if there is no such character.
-   */
-  public static int delimiterOffset(String input, int pos, int limit, char delimiter) {
-    for (int i = pos; i < limit; i++) {
-      if (input.charAt(i) == delimiter) return i;
-    }
-    return limit;
-  }
-
-  /**
-   * If {@code host} is an IP address, this returns the IP address in canonical form.
-   *
-   * <p>Otherwise this performs IDN ToASCII encoding and canonicalize the result to lowercase. For
-   * example this converts {@code ☃.net} to {@code xn--n3h.net}, and {@code WwW.GoOgLe.cOm} to
-   * {@code www.google.com}. {@code null} will be returned if the host cannot be ToASCII encoded or
-   * if the result contains unsupported ASCII characters.
-   */
-  public static String canonicalizeHost(String host) {
-    // If the input contains a :, it’s an IPv6 address.
-    if (host.contains(":")) {
-      // If the input is encased in square braces "[...]", drop 'em.
-      InetAddress inetAddress = host.startsWith("[") && host.endsWith("]")
-          ? decodeIpv6(host, 1, host.length() - 1)
-          : decodeIpv6(host, 0, host.length());
-      if (inetAddress == null) return null;
-      byte[] address = inetAddress.getAddress();
-      if (address.length == 16) return inet6AddressToAscii(address);
-      if (address.length == 4) return inetAddress.getHostAddress(); // An IPv4-mapped IPv6 address.
-      throw new AssertionError("Invalid IPv6 address: '" + host + "'");
-    }
-
-    try {
-      String result = IDN.toASCII(host).toLowerCase(Locale.US);
-      if (result.isEmpty()) return null;
-
-      // Confirm that the IDN ToASCII result doesn't contain any illegal characters.
-      if (containsInvalidHostnameAsciiCodes(result)) {
-        return null;
-      }
-      // TODO: implement all label limits.
-      return result;
-    } catch (IllegalArgumentException e) {
-      return null;
-    }
-  }
-
-  private static boolean containsInvalidHostnameAsciiCodes(String hostnameAscii) {
-    for (int i = 0; i < hostnameAscii.length(); i++) {
-      char c = hostnameAscii.charAt(i);
-      // The WHATWG Host parsing rules accepts some character codes which are invalid by
-      // definition for OkHttp's host header checks (and the WHATWG Host syntax definition). Here
-      // we rule out characters that would cause problems in host headers.
-      if (c <= '\u001f' || c >= '\u007f') {
-        return true;
-      }
-      // Check for the characters mentioned in the WHATWG Host parsing spec:
-      // U+0000, U+0009, U+000A, U+000D, U+0020, "#", "%", "/", ":", "?", "@", "[", "\", and "]"
-      // (excluding the characters covered above).
-      if (" #%/:?@[\\]".indexOf(c) != -1) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /**
-   * Returns the index of the first character in {@code input} that is either a control character
-   * (like {@code \u0000 or \n}) or a non-ASCII character. Returns -1 if {@code input} has no such
-   * characters.
-   */
-  public static int indexOfControlOrNonAscii(String input) {
-    for (int i = 0, length = input.length(); i < length; i++) {
-      char c = input.charAt(i);
-      if (c <= '\u001f' || c >= '\u007f') {
-        return i;
-      }
-    }
-    return -1;
-  }
-
-  /** Returns true if {@code host} is not a host name and might be an IP address. */
-  public static boolean verifyAsIpAddress(String host) {
-    return VERIFY_AS_IP_ADDRESS.matcher(host).matches();
-  }
-
-  /** Returns a {@link Locale#US} formatted {@link String}. */
-  public static String format(String format, Object... args) {
-    return String.format(Locale.US, format, args);
-  }
-
-  public static Charset bomAwareCharset(BufferedSource source, Charset charset) throws IOException {
-    switch (source.select(UNICODE_BOMS)) {
-      case 0: return UTF_8;
-      case 1: return UTF_16BE;
-      case 2: return UTF_16LE;
-      case 3: return UTF_32BE;
-      case 4: return UTF_32LE;
-      case -1: return charset;
-      default: throw new AssertionError();
-    }
-  }
-
-  public static int checkDuration(String name, long duration, TimeUnit unit) {
-    if (duration < 0) throw new IllegalArgumentException(name + " < 0");
-    if (unit == null) throw new NullPointerException("unit == null");
-    long millis = unit.toMillis(duration);
-    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException(name + " too large.");
-    if (millis == 0 && duration > 0) throw new IllegalArgumentException(name + " too small.");
-    return (int) millis;
-  }
-
-  public static int decodeHexDigit(char c) {
-    if (c >= '0' && c <= '9') return c - '0';
-    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
-    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
-    return -1;
-  }
-
-  /** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
-  private static @Nullable InetAddress decodeIpv6(String input, int pos, int limit) {
-    byte[] address = new byte[16];
-    int b = 0;
-    int compress = -1;
-    int groupOffset = -1;
-
-    for (int i = pos; i < limit; ) {
-      if (b == address.length) return null; // Too many groups.
-
-      // Read a delimiter.
-      if (i + 2 <= limit && input.regionMatches(i, "::", 0, 2)) {
-        // Compression "::" delimiter, which is anywhere in the input, including its prefix.
-        if (compress != -1) return null; // Multiple "::" delimiters.
-        i += 2;
-        b += 2;
-        compress = b;
-        if (i == limit) break;
-      } else if (b != 0) {
-        // Group separator ":" delimiter.
-        if (input.regionMatches(i, ":", 0, 1)) {
-          i++;
-        } else if (input.regionMatches(i, ".", 0, 1)) {
-          // If we see a '.', rewind to the beginning of the previous group and parse as IPv4.
-          if (!decodeIpv4Suffix(input, groupOffset, limit, address, b - 2)) return null;
-          b += 2; // We rewound two bytes and then added four.
-          break;
-        } else {
-          return null; // Wrong delimiter.
-        }
-      }
-
-      // Read a group, one to four hex digits.
-      int value = 0;
-      groupOffset = i;
-      for (; i < limit; i++) {
-        char c = input.charAt(i);
-        int hexDigit = decodeHexDigit(c);
-        if (hexDigit == -1) break;
-        value = (value << 4) + hexDigit;
-      }
-      int groupLength = i - groupOffset;
-      if (groupLength == 0 || groupLength > 4) return null; // Group is the wrong size.
-
-      // We've successfully read a group. Assign its value to our byte array.
-      address[b++] = (byte) ((value >>> 8) & 0xff);
-      address[b++] = (byte) (value & 0xff);
-    }
-
-    // All done. If compression happened, we need to move bytes to the right place in the
-    // address. Here's a sample:
-    //
-    //      input: "1111:2222:3333::7777:8888"
-    //     before: { 11, 11, 22, 22, 33, 33, 00, 00, 77, 77, 88, 88, 00, 00, 00, 00  }
-    //   compress: 6
-    //          b: 10
-    //      after: { 11, 11, 22, 22, 33, 33, 00, 00, 00, 00, 00, 00, 77, 77, 88, 88 }
-    //
-    if (b != address.length) {
-      if (compress == -1) return null; // Address didn't have compression or enough groups.
-      System.arraycopy(address, compress, address, address.length - (b - compress), b - compress);
-      Arrays.fill(address, compress, compress + (address.length - b), (byte) 0);
-    }
-
-    try {
-      return InetAddress.getByAddress(address);
-    } catch (UnknownHostException e) {
-      throw new AssertionError();
-    }
-  }
-
-  /** Decodes an IPv4 address suffix of an IPv6 address, like 1111::5555:6666:192.168.0.1. */
-  private static boolean decodeIpv4Suffix(
-      String input, int pos, int limit, byte[] address, int addressOffset) {
-    int b = addressOffset;
-
-    for (int i = pos; i < limit; ) {
-      if (b == address.length) return false; // Too many groups.
-
-      // Read a delimiter.
-      if (b != addressOffset) {
-        if (input.charAt(i) != '.') return false; // Wrong delimiter.
-        i++;
-      }
-
-      // Read 1 or more decimal digits for a value in 0..255.
-      int value = 0;
-      int groupOffset = i;
-      for (; i < limit; i++) {
-        char c = input.charAt(i);
-        if (c < '0' || c > '9') break;
-        if (value == 0 && groupOffset != i) return false; // Reject unnecessary leading '0's.
-        value = (value * 10) + c - '0';
-        if (value > 255) return false; // Value out of range.
-      }
-      int groupLength = i - groupOffset;
-      if (groupLength == 0) return false; // No digits.
-
-      // We've successfully read a byte.
-      address[b++] = (byte) value;
-    }
-
-    if (b != addressOffset + 4) return false; // Too few groups. We wanted exactly four.
-    return true; // Success.
-  }
-
-  /** Encodes an IPv6 address in canonical form according to RFC 5952. */
-  private static String inet6AddressToAscii(byte[] address) {
-    // Go through the address looking for the longest run of 0s. Each group is 2-bytes.
-    // A run must be longer than one group (section 4.2.2).
-    // If there are multiple equal runs, the first one must be used (section 4.2.3).
-    int longestRunOffset = -1;
-    int longestRunLength = 0;
-    for (int i = 0; i < address.length; i += 2) {
-      int currentRunOffset = i;
-      while (i < 16 && address[i] == 0 && address[i + 1] == 0) {
-        i += 2;
-      }
-      int currentRunLength = i - currentRunOffset;
-      if (currentRunLength > longestRunLength && currentRunLength >= 4) {
-        longestRunOffset = currentRunOffset;
-        longestRunLength = currentRunLength;
-      }
-    }
-
-    // Emit each 2-byte group in hex, separated by ':'. The longest run of zeroes is "::".
-    Buffer result = new Buffer();
-    for (int i = 0; i < address.length; ) {
-      if (i == longestRunOffset) {
-        result.writeByte(':');
-        i += longestRunLength;
-        if (i == 16) result.writeByte(':');
-      } else {
-        if (i > 0) result.writeByte(':');
-        int group = (address[i] & 0xff) << 8 | address[i + 1] & 0xff;
-        result.writeHexadecimalUnsignedLong(group);
-        i += 2;
-      }
-    }
-    return result.readUtf8();
-  }
-
-  public static X509TrustManager platformTrustManager() {
-    return Platform.get().platformTrustManager();
-  }
-
-  public static Headers toHeaders(List<Header> headerBlock) {
-    Headers.Builder builder = new Headers.Builder();
-    for (Header header : headerBlock) {
-      addHeaderLenient(builder, header.name.utf8(), header.value.utf8());
-    }
-    return builder.build();
-  }
-
-  public static List<Header> toHeaderBlock(Headers headers) {
-    List<Header> result = new ArrayList<>();
-    for (int i = 0; i < headers.size(); i++) {
-      result.add(new Header(headers.name(i), headers.value(i)));
-    }
-    return result;
-  }
-
-  /**
-   * Returns the system property, or {@code defaultValue} if the system property is null or
-   * cannot be read (e.g. because of security policy restrictions).
-   */
-  public static String getSystemProperty(String key, @Nullable String defaultValue) {
-    String value;
-    try {
-      value = System.getProperty(key);
-    } catch (AccessControlException ex) {
-      return defaultValue;
-    }
-    return value != null ? value : defaultValue;
-  }
-
-  /** Returns true if an HTTP request for {@code a} and {@code b} can reuse a connection. */
-  public static boolean sameConnection(HttpUrl a, HttpUrl b) {
-    return a.host().equals(b.host())
-        && a.port() == b.port()
-        && a.scheme().equals(b.scheme());
-  }
-
-  public static EventListener.Factory eventListenerFactory(EventListener listener) {
-    return call -> listener;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.kt b/okhttp/src/main/java/okhttp3/internal/Util.kt
new file mode 100644
index 0000000000..d40f16c4d6
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/Util.kt
@@ -0,0 +1,568 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@file:JvmName("Util")
+
+package okhttp3.internal
+
+import okhttp3.Call
+import okhttp3.EventListener
+import okhttp3.Headers
+import okhttp3.Headers.Companion.headersOf
+import okhttp3.HttpUrl
+import okhttp3.RequestBody.Companion.toRequestBody
+import okhttp3.Response
+import okhttp3.ResponseBody.Companion.toResponseBody
+import okhttp3.internal.http2.Header
+import okio.Buffer
+import okio.BufferedSink
+import okio.BufferedSource
+import okio.ByteString.Companion.decodeHex
+import okio.Options
+import okio.Source
+import java.io.Closeable
+import java.io.IOException
+import java.io.InterruptedIOException
+import java.net.InetSocketAddress
+import java.net.ServerSocket
+import java.net.Socket
+import java.nio.charset.Charset
+import java.nio.charset.StandardCharsets.UTF_16BE
+import java.nio.charset.StandardCharsets.UTF_16LE
+import java.nio.charset.StandardCharsets.UTF_8
+import java.util.Arrays
+import java.util.Collections
+import java.util.Comparator
+import java.util.LinkedHashMap
+import java.util.Locale
+import java.util.TimeZone
+import java.util.concurrent.Executor
+import java.util.concurrent.RejectedExecutionException
+import java.util.concurrent.ThreadFactory
+import java.util.concurrent.TimeUnit
+import kotlin.text.Charsets.UTF_32BE
+import kotlin.text.Charsets.UTF_32LE
+
+@JvmField
+val EMPTY_BYTE_ARRAY = ByteArray(0)
+@JvmField
+val EMPTY_HEADERS = headersOf()
+
+@JvmField
+val EMPTY_RESPONSE = EMPTY_BYTE_ARRAY.toResponseBody()
+@JvmField
+val EMPTY_REQUEST = EMPTY_BYTE_ARRAY.toRequestBody()
+
+/** Byte order marks. */
+private val UNICODE_BOMS = Options.of(
+    "efbbbf".decodeHex(), // UTF-8
+    "feff".decodeHex(), // UTF-16BE
+    "fffe".decodeHex(), // UTF-16LE
+    "0000ffff".decodeHex(), // UTF-32BE
+    "ffff0000".decodeHex() // UTF-32LE
+)
+
+/** GMT and UTC are equivalent for our purposes. */
+@JvmField
+val UTC = TimeZone.getTimeZone("GMT")!!
+
+/**
+ * Quick and dirty pattern to differentiate IP addresses from hostnames. This is an approximation
+ * of Android's private InetAddress#isNumeric API.
+ *
+ * This matches IPv6 addresses as a hex string containing at least one colon, and possibly
+ * including dots after the first colon. It matches IPv4 addresses as strings containing only
+ * decimal digits and dots. This pattern matches strings like "a:.23" and "54" that are neither IP
+ * addresses nor hostnames; they will be verified as IP addresses (which is a more strict
+ * verification).
+ */
+private val VERIFY_AS_IP_ADDRESS =
+    "([0-9a-fA-F]*:[0-9a-fA-F:.]*)|([\\d.]+)".toRegex()
+
+fun checkOffsetAndCount(arrayLength: Long, offset: Long, count: Long) {
+  if (offset or count < 0L || offset > arrayLength || arrayLength - offset < count) {
+    throw ArrayIndexOutOfBoundsException()
+  }
+}
+
+fun threadFactory(
+  name: String,
+  daemon: Boolean
+): ThreadFactory = ThreadFactory { runnable ->
+  Thread(runnable, name).apply {
+    isDaemon = daemon
+  }
+}
+
+/**
+ * Returns an array containing only elements found in this array and also in [other]. The returned
+ * elements are in the same order as in this.
+ */
+fun Array<String>.intersect(
+  other: Array<String>,
+  comparator: Comparator<in String>
+): Array<String> {
+  val result = mutableListOf<String>()
+  for (a in this) {
+    for (b in other) {
+      if (comparator.compare(a, b) == 0) {
+        result.add(a)
+        break
+      }
+    }
+  }
+  return result.toTypedArray()
+}
+
+/**
+ * Returns true if there is an element in this array that is also in [other]. This method terminates
+ * if any intersection is found. The sizes of both arguments are assumed to be so small, and the
+ * likelihood of an intersection so great, that it is not worth the CPU cost of sorting or the
+ * memory cost of hashing.
+ */
+fun Array<String>.hasIntersection(
+  other: Array<String>?,
+  comparator: Comparator<in String>
+): Boolean {
+  if (isEmpty() || other == null || other.isEmpty()) {
+    return false
+  }
+  for (a in this) {
+    for (b in other) {
+      if (comparator.compare(a, b) == 0) {
+        return true
+      }
+    }
+  }
+  return false
+}
+
+fun HttpUrl.toHostHeader(includeDefaultPort: Boolean = false): String {
+  val host = if (":" in host) {
+    "[$host]"
+  } else {
+    host
+  }
+  return if (includeDefaultPort || port != HttpUrl.defaultPort(scheme)) {
+    "$host:$port"
+  } else {
+    host
+  }
+}
+
+fun Array<String>.indexOf(value: String, comparator: Comparator<String>): Int =
+    indexOfFirst { comparator.compare(it, value) == 0 }
+
+@Suppress("UNCHECKED_CAST")
+fun Array<String>.concat(value: String): Array<String> {
+  val result = copyOf(size + 1)
+  result[result.lastIndex] = value
+  return result as Array<String>
+}
+
+/**
+ * Increments [startIndex] until this string is not ASCII whitespace. Stops at [endIndex].
+ */
+fun String.indexOfFirstNonAsciiWhitespace(startIndex: Int = 0, endIndex: Int = length): Int {
+  for (i in startIndex until endIndex) {
+    when (this[i]) {
+      '\t', '\n', '\u000C', '\r', ' ' -> Unit
+      else -> return i
+    }
+  }
+  return endIndex
+}
+
+/**
+ * Decrements [endIndex] until `input[endIndex - 1]` is not ASCII whitespace. Stops at [startIndex].
+ */
+fun String.indexOfLastNonAsciiWhitespace(startIndex: Int = 0, endIndex: Int = length): Int {
+  for (i in endIndex - 1 downTo startIndex) {
+    when (this[i]) {
+      '\t', '\n', '\u000C', '\r', ' ' -> Unit
+      else -> return i + 1
+    }
+  }
+  return startIndex
+}
+
+/** Equivalent to `string.substring(startIndex, endIndex).trim()`. */
+fun String.trimSubstring(startIndex: Int = 0, endIndex: Int = length): String {
+  val start = indexOfFirstNonAsciiWhitespace(startIndex, endIndex)
+  val end = indexOfLastNonAsciiWhitespace(start, endIndex)
+  return substring(start, end)
+}
+
+/**
+ * Returns the index of the first character in this string that contains a character in
+ * [delimiters]. Returns endIndex if there is no such character.
+ */
+fun String.delimiterOffset(delimiters: String, startIndex: Int = 0, endIndex: Int = length): Int {
+  for (i in startIndex until endIndex) {
+    if (this[i] in delimiters) return i
+  }
+  return endIndex
+}
+
+/**
+ * Returns the index of the first character in this string that is [delimiter]. Returns [endIndex]
+ * if there is no such character.
+ */
+fun String.delimiterOffset(delimiter: Char, startIndex: Int = 0, endIndex: Int = length): Int {
+  for (i in startIndex until endIndex) {
+    if (this[i] == delimiter) return i
+  }
+  return endIndex
+}
+
+/**
+ * Returns the index of the first character in this string that is either a control character (like
+ * `\u0000` or `\n`) or a non-ASCII character. Returns -1 if this string has no such characters.
+ */
+fun String.indexOfControlOrNonAscii(): Int {
+  for (i in 0 until length) {
+    val c = this[i]
+    if (c <= '\u001f' || c >= '\u007f') {
+      return i
+    }
+  }
+  return -1
+}
+
+/** Returns true if this string is not a host name and might be an IP address. */
+fun String.canParseAsIpAddress(): Boolean {
+  return VERIFY_AS_IP_ADDRESS.matches(this)
+}
+
+/** Returns a [Locale.US] formatted [String]. */
+fun format(format: String, vararg args: Any): String {
+  return String.format(Locale.US, format, *args)
+}
+
+@Throws(IOException::class)
+fun BufferedSource.readBomAsCharset(default: Charset): Charset {
+  return when (select(UNICODE_BOMS)) {
+    0 -> UTF_8
+    1 -> UTF_16BE
+    2 -> UTF_16LE
+    3 -> UTF_32BE
+    4 -> UTF_32LE
+    -1 -> default
+    else -> throw AssertionError()
+  }
+}
+
+fun checkDuration(name: String, duration: Long, unit: TimeUnit?): Int {
+  check(duration >= 0L) { "$name < 0" }
+  check(unit != null) { "unit == null" }
+  val millis = unit.toMillis(duration)
+  require(millis <= Integer.MAX_VALUE) { "$name too large." }
+  require(millis != 0L || duration <= 0L) { "$name too small." }
+  return millis.toInt()
+}
+
+fun Char.parseHexDigit(): Int = when (this) {
+  in '0'..'9' -> this - '0'
+  in 'a'..'f' -> this - 'a' + 10
+  in 'A'..'F' -> this - 'A' + 10
+  else -> -1
+}
+
+fun List<Header>.toHeaders(): Headers {
+  val builder = Headers.Builder()
+  for ((name, value) in this) {
+    builder.addLenient(name.utf8(), value.utf8())
+  }
+  return builder.build()
+}
+
+fun Headers.toHeaderList(): List<Header> = (0 until size).map {
+  Header(name(it), value(it))
+}
+
+/** Returns true if an HTTP request for this URL and [other] can reuse a connection. */
+fun HttpUrl.canReuseConnectionFor(other: HttpUrl): Boolean = host == other.host &&
+    port == other.port &&
+    scheme == other.scheme
+
+fun EventListener.asFactory() = object : EventListener.Factory {
+  override fun create(call: Call): EventListener = this@asFactory
+}
+
+infix fun Byte.and(mask: Int): Int = toInt() and mask
+infix fun Short.and(mask: Int): Int = toInt() and mask
+infix fun Int.and(mask: Long): Long = toLong() and mask
+
+@Throws(IOException::class)
+fun BufferedSink.writeMedium(medium: Int) {
+  writeByte(medium.ushr(16) and 0xff)
+  writeByte(medium.ushr(8) and 0xff)
+  writeByte(medium and 0xff)
+}
+
+@Throws(IOException::class)
+fun BufferedSource.readMedium(): Int {
+  return (readByte() and 0xff shl 16
+      or (readByte() and 0xff shl 8)
+      or (readByte() and 0xff))
+}
+
+/**
+ * Reads until this is exhausted or the deadline has been reached. This is careful to not extend the
+ * deadline if one exists already.
+ */
+@Throws(IOException::class)
+fun Source.skipAll(duration: Int, timeUnit: TimeUnit): Boolean {
+  val now = System.nanoTime()
+  val originalDuration = if (timeout().hasDeadline()) {
+    timeout().deadlineNanoTime() - now
+  } else {
+    Long.MAX_VALUE
+  }
+  timeout().deadlineNanoTime(now + minOf(originalDuration, timeUnit.toNanos(duration.toLong())))
+  return try {
+    val skipBuffer = Buffer()
+    while (read(skipBuffer, 8192) != -1L) {
+      skipBuffer.clear()
+    }
+    true // Success! The source has been exhausted.
+  } catch (_: InterruptedIOException) {
+    false // We ran out of time before exhausting the source.
+  } finally {
+    if (originalDuration == Long.MAX_VALUE) {
+      timeout().clearDeadline()
+    } else {
+      timeout().deadlineNanoTime(now + originalDuration)
+    }
+  }
+}
+
+/**
+ * Attempts to exhaust this, returning true if successful. This is useful when reading a complete
+ * source is helpful, such as when doing so completes a cache body or frees a socket connection for
+ * reuse.
+ */
+fun Source.discard(timeout: Int, timeUnit: TimeUnit): Boolean = try {
+  this.skipAll(timeout, timeUnit)
+} catch (_: IOException) {
+  false
+}
+
+fun Socket.connectionName(): String {
+  val address = remoteSocketAddress
+  return if (address is InetSocketAddress) address.hostName else address.toString()
+}
+
+/** Run [block] until it either throws an [IOException] or completes. */
+inline fun ignoreIoExceptions(block: () -> Unit) {
+  try {
+    block()
+  } catch (_: IOException) {
+  }
+}
+
+inline fun threadName(name: String, block: () -> Unit) {
+  val currentThread = Thread.currentThread()
+  val oldName = currentThread.name
+  currentThread.name = name
+  try {
+    block()
+  } finally {
+    currentThread.name = oldName
+  }
+}
+
+/** Execute [block], setting the executing thread's name to [name] for the duration. */
+inline fun Executor.execute(name: String, crossinline block: () -> Unit) {
+  execute {
+    threadName(name) {
+      block()
+    }
+  }
+}
+
+/** Executes [block] unless this executor has been shutdown, in which case this does nothing. */
+inline fun Executor.tryExecute(name: String, crossinline block: () -> Unit) {
+  try {
+    execute(name, block)
+  } catch (_: RejectedExecutionException) {
+  }
+}
+
+fun Buffer.skipAll(b: Byte): Int {
+  var count = 0
+  while (!exhausted() && this[0] == b) {
+    count++
+    readByte()
+  }
+  return count
+}
+
+/**
+ * Returns the index of the next non-whitespace character in this. Result is undefined if input
+ * contains newline characters.
+ */
+fun String.indexOfNonWhitespace(startIndex: Int = 0): Int {
+  for (i in startIndex until length) {
+    val c = this[i]
+    if (c != ' ' && c != '\t') {
+      return i
+    }
+  }
+  return length
+}
+
+/** Returns the Content-Length as reported by the response headers. */
+fun Response.headersContentLength(): Long {
+  return headers["Content-Length"]?.toLongOrDefault(-1L) ?: -1L
+}
+
+fun String.toLongOrDefault(defaultValue: Long): Long {
+  return try {
+    toLong()
+  } catch (_: NumberFormatException) {
+    defaultValue
+  }
+}
+
+/**
+ * Returns this as a non-negative integer, or 0 if it is negative, or [Int.MAX_VALUE] if it is too
+ * large, or [defaultValue] if it cannot be parsed.
+ */
+fun String?.toNonNegativeInt(defaultValue: Int): Int {
+  try {
+    val value = this?.toLong() ?: return defaultValue
+    return when {
+      value > Int.MAX_VALUE -> Int.MAX_VALUE
+      value < 0 -> 0
+      else -> value.toInt()
+    }
+  } catch (_: NumberFormatException) {
+    return defaultValue
+  }
+}
+
+/** Returns an immutable copy of this. */
+fun <T> List<T>.toImmutableList(): List<T> {
+  return Collections.unmodifiableList(toMutableList())
+}
+
+/** Returns an immutable list containing [elements]. */
+@SafeVarargs
+fun <T> immutableListOf(vararg elements: T): List<T> {
+  return Collections.unmodifiableList(Arrays.asList(*elements.clone()))
+}
+
+/** Returns an immutable copy of this. */
+fun <K, V> Map<K, V>.toImmutableMap(): Map<K, V> {
+  return if (isEmpty()) {
+    emptyMap()
+  } else {
+    Collections.unmodifiableMap(LinkedHashMap(this))
+  }
+}
+
+/** Closes this, ignoring any checked exceptions. */
+fun Closeable.closeQuietly() {
+  try {
+    close()
+  } catch (rethrown: RuntimeException) {
+    throw rethrown
+  } catch (_: Exception) {
+  }
+}
+
+/** Closes this, ignoring any checked exceptions. */
+fun Socket.closeQuietly() {
+  try {
+    close()
+  } catch (e: AssertionError) {
+    throw e
+  } catch (rethrown: RuntimeException) {
+    throw rethrown
+  } catch (_: Exception) {
+  }
+}
+
+/** Closes this, ignoring any checked exceptions.  */
+fun ServerSocket.closeQuietly() {
+  try {
+    close()
+  } catch (rethrown: RuntimeException) {
+    throw rethrown
+  } catch (_: Exception) {
+  }
+}
+
+fun Long.toHexString(): String = java.lang.Long.toHexString(this)
+
+fun Int.toHexString(): String = Integer.toHexString(this)
+
+/**
+ * Lock and wait a duration in nanoseconds. Unlike [java.lang.Object.wait] this interprets 0 as
+ * "don't wait" instead of "wait forever".
+ */
+@Throws(InterruptedException::class)
+fun Any.lockAndWaitNanos(nanos: Long) {
+  val ms = nanos / 1_000_000L
+  val ns = nanos - (ms * 1_000_000L)
+  synchronized(this) {
+    waitMillis(ms, ns.toInt())
+  }
+}
+
+@Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN", "NOTHING_TO_INLINE")
+inline fun Any.wait() = (this as Object).wait()
+
+/**
+ * Lock and wait a duration in milliseconds and nanos.
+ * Unlike [java.lang.Object.wait] this interprets 0 as "don't wait" instead of "wait forever".
+ */
+@Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN")
+fun Any.waitMillis(timeout: Long, nanos: Int = 0) {
+  if (timeout > 0L || nanos > 0) {
+    (this as Object).wait(timeout, nanos)
+  }
+}
+
+@Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN", "NOTHING_TO_INLINE")
+inline fun Any.notify() = (this as Object).notify()
+
+@Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN", "NOTHING_TO_INLINE")
+inline fun Any.notifyAll() = (this as Object).notifyAll()
+
+fun <T> readFieldOrNull(instance: Any, fieldType: Class<T>, fieldName: String): T? {
+  var c: Class<*> = instance.javaClass
+  while (c != Any::class.java) {
+    try {
+      val field = c.getDeclaredField(fieldName)
+      field.isAccessible = true
+      val value = field.get(instance)
+      return if (!fieldType.isInstance(value)) null else fieldType.cast(value)
+    } catch (_: NoSuchFieldException) {
+    }
+
+    c = c.superclass
+  }
+
+  // Didn't find the field we wanted. As a last gasp attempt,
+  // try to find the value on a delegate.
+  if (fieldName != "delegate") {
+    val delegate = readFieldOrNull(instance, Any::class.java, "delegate")
+    if (delegate != null) return readFieldOrNull(delegate, fieldType, fieldName)
+  }
+
+  return null
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/UtilKt.kt b/okhttp/src/main/java/okhttp3/internal/UtilKt.kt
deleted file mode 100644
index 357b72ae17..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/UtilKt.kt
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal
-
-import okio.BufferedSink
-import okio.BufferedSource
-import java.io.IOException
-
-infix fun Byte.and(mask: Int): Int = toInt() and mask
-infix fun Short.and(mask: Int): Int = toInt() and mask
-infix fun Int.and(mask: Long): Long = toLong() and mask
-
-@Throws(IOException::class)
-fun BufferedSink.writeMedium(medium: Int) {
-  writeByte(medium.ushr(16) and 0xff)
-  writeByte(medium.ushr(8) and 0xff)
-  writeByte(medium and 0xff)
-}
-
-@Throws(IOException::class)
-fun BufferedSource.readMedium(): Int {
-  return (readByte() and 0xff shl 16
-      or (readByte() and 0xff shl 8)
-      or (readByte() and 0xff))
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java b/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java
deleted file mode 100644
index e97bb4d9cb..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.internal.annotations;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import javax.annotation.Nonnull;
-import javax.annotation.meta.TypeQualifierDefault;
-
-/**
- * Extends {@code ParametersAreNonnullByDefault} to also apply to Method results and fields.
- *
- * @see javax.annotation.ParametersAreNonnullByDefault
- */
-@Documented
-@Nonnull
-@TypeQualifierDefault({
-    ElementType.FIELD,
-    ElementType.METHOD,
-    ElementType.PARAMETER
-})
-@Retention(RetentionPolicy.RUNTIME)
-public @interface EverythingIsNonNull { }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.kt b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.kt
index b9f7ffcfd9..20c615a463 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.kt
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.kt
@@ -16,29 +16,29 @@
  */
 package okhttp3.internal.cache
 
-import java.io.IOException
+import okhttp3.Cache
 import okhttp3.Headers
 import okhttp3.Interceptor
 import okhttp3.Protocol
 import okhttp3.Response
-import okhttp3.internal.Util
+import okhttp3.internal.EMPTY_RESPONSE
+import okhttp3.internal.closeQuietly
+import okhttp3.internal.discard
 import okhttp3.internal.http.ExchangeCodec
-import okhttp3.internal.http.HttpHeaders
 import okhttp3.internal.http.HttpMethod
 import okhttp3.internal.http.RealResponseBody
+import okhttp3.internal.http.promisesBody
 import okio.Buffer
 import okio.Source
 import okio.Timeout
-import java.net.HttpURLConnection.HTTP_NOT_MODIFIED
-import java.util.concurrent.TimeUnit.MILLISECONDS
-import okhttp3.internal.Util.closeQuietly
-import okhttp3.internal.Util.discard
-import okhttp3.internal.addHeaderLenient
 import okio.buffer
+import java.io.IOException
 import java.net.HttpURLConnection.HTTP_GATEWAY_TIMEOUT
+import java.net.HttpURLConnection.HTTP_NOT_MODIFIED
+import java.util.concurrent.TimeUnit.MILLISECONDS
 
-/** Serves requests from the cache and writes responses to the cache.  */
-class CacheInterceptor(internal val cache: InternalCache?) : Interceptor {
+/** Serves requests from the cache and writes responses to the cache. */
+class CacheInterceptor(internal val cache: Cache?) : Interceptor {
 
   @Throws(IOException::class)
   override fun intercept(chain: Interceptor.Chain): Response {
@@ -46,17 +46,15 @@ class CacheInterceptor(internal val cache: InternalCache?) : Interceptor {
 
     val now = System.currentTimeMillis()
 
-    val strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).get()
+    val strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()
     val networkRequest = strategy.networkRequest
     val cacheResponse = strategy.cacheResponse
 
-    if (cache != null) {
-      cache.trackResponse(strategy)
-    }
+    cache?.trackResponse(strategy)
 
     if (cacheCandidate != null && cacheResponse == null) {
       // The cache candidate wasn't applicable. Close it.
-      closeQuietly(cacheCandidate.body())
+      cacheCandidate.body?.closeQuietly()
     }
 
     // If we're forbidden from using the network and the cache is insufficient, fail.
@@ -66,7 +64,7 @@ class CacheInterceptor(internal val cache: InternalCache?) : Interceptor {
           .protocol(Protocol.HTTP_1_1)
           .code(HTTP_GATEWAY_TIMEOUT)
           .message("Unsatisfiable Request (only-if-cached)")
-          .body(Util.EMPTY_RESPONSE)
+          .body(EMPTY_RESPONSE)
           .sentRequestAtMillis(-1L)
           .receivedResponseAtMillis(System.currentTimeMillis())
           .build()
@@ -85,22 +83,22 @@ class CacheInterceptor(internal val cache: InternalCache?) : Interceptor {
     } finally {
       // If we're crashing on I/O or otherwise, don't leak the cache body.
       if (networkResponse == null && cacheCandidate != null) {
-        closeQuietly(cacheCandidate.body())
+        cacheCandidate.body?.closeQuietly()
       }
     }
 
     // If we have a cache response too, then we're doing a conditional get.
     if (cacheResponse != null) {
-      if (networkResponse?.code() == HTTP_NOT_MODIFIED) {
+      if (networkResponse?.code == HTTP_NOT_MODIFIED) {
         val response = cacheResponse.newBuilder()
-            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
-            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
-            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
+            .headers(combine(cacheResponse.headers, networkResponse.headers))
+            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)
+            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)
             .cacheResponse(stripBody(cacheResponse))
             .networkResponse(stripBody(networkResponse))
             .build()
 
-        networkResponse.body()!!.close()
+        networkResponse.body!!.close()
 
         // Update the cache after combining headers but before stripping the
         // Content-Encoding header (as performed by initContentStream()).
@@ -108,7 +106,7 @@ class CacheInterceptor(internal val cache: InternalCache?) : Interceptor {
         cache.update(cacheResponse, response)
         return response
       } else {
-        closeQuietly(cacheResponse.body())
+        cacheResponse.body?.closeQuietly()
       }
     }
 
@@ -118,16 +116,16 @@ class CacheInterceptor(internal val cache: InternalCache?) : Interceptor {
         .build()
 
     if (cache != null) {
-      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
+      if (response.promisesBody() && CacheStrategy.isCacheable(response, networkRequest)) {
         // Offer this request to the cache.
         val cacheRequest = cache.put(response)
         return cacheWritingResponse(cacheRequest, response)
       }
 
-      if (HttpMethod.invalidatesCache(networkRequest.method())) {
+      if (HttpMethod.invalidatesCache(networkRequest.method)) {
         try {
           cache.remove(networkRequest)
-        } catch (ignored: IOException) {
+        } catch (_: IOException) {
           // The cache cannot be written.
         }
       }
@@ -137,7 +135,7 @@ class CacheInterceptor(internal val cache: InternalCache?) : Interceptor {
   }
 
   /**
-   * Returns a new source that writes bytes to `cacheRequest` as they are read by the source
+   * Returns a new source that writes bytes to [cacheRequest] as they are read by the source
    * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
    * may never exhaust the source stream and therefore not complete the cached response.
    */
@@ -147,7 +145,7 @@ class CacheInterceptor(internal val cache: InternalCache?) : Interceptor {
     if (cacheRequest == null) return response
     val cacheBodyUnbuffered = cacheRequest.body()
 
-    val source = response.body()!!.source()
+    val source = response.body!!.source()
     val cacheBody = cacheBodyUnbuffered.buffer()
 
     val cacheWritingSource = object : Source {
@@ -185,8 +183,8 @@ class CacheInterceptor(internal val cache: InternalCache?) : Interceptor {
 
       @Throws(IOException::class)
       override fun close() {
-        if (!cacheRequestClosed && !discard(this, ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS,
-                MILLISECONDS)) {
+        if (!cacheRequestClosed &&
+            !discard(ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
           cacheRequestClosed = true
           cacheRequest.abort()
         }
@@ -195,7 +193,7 @@ class CacheInterceptor(internal val cache: InternalCache?) : Interceptor {
     }
 
     val contentType = response.header("Content-Type")
-    val contentLength = response.body()!!.contentLength()
+    val contentLength = response.body.contentLength()
     return response.newBuilder()
         .body(RealResponseBody(contentType, contentLength, cacheWritingSource.buffer()))
         .build()
@@ -204,18 +202,18 @@ class CacheInterceptor(internal val cache: InternalCache?) : Interceptor {
   companion object {
 
     private fun stripBody(response: Response?): Response? {
-      if (response?.body() != null) {
-        return response.newBuilder().body(null).build()
+      return if (response?.body != null) {
+        response.newBuilder().body(null).build()
       } else {
-        return response
+        response
       }
     }
 
-    /** Combines cached headers with a network headers as defined by RFC 7234, 4.3.4.  */
+    /** Combines cached headers with a network headers as defined by RFC 7234, 4.3.4. */
     private fun combine(cachedHeaders: Headers, networkHeaders: Headers): Headers {
       val result = Headers.Builder()
 
-      for (index in cachedHeaders.names().indices) {
+      for (index in 0 until cachedHeaders.size) {
         val fieldName = cachedHeaders.name(index)
         val value = cachedHeaders.value(index)
         if ("Warning".equals(fieldName, ignoreCase = true) && value.startsWith("1")) {
@@ -225,14 +223,14 @@ class CacheInterceptor(internal val cache: InternalCache?) : Interceptor {
         if (isContentSpecificHeader(fieldName) ||
             !isEndToEnd(fieldName) ||
             networkHeaders[fieldName] == null) {
-          addHeaderLenient(result, fieldName, value)
+          result.addLenient(fieldName, value)
         }
       }
 
-      for (index in networkHeaders.names().indices) {
+      for (index in 0 until networkHeaders.size) {
         val fieldName = networkHeaders.name(index)
         if (!isContentSpecificHeader(fieldName) && isEndToEnd(fieldName)) {
-          addHeaderLenient(result, fieldName, networkHeaders.value(index))
+          result.addLenient(fieldName, networkHeaders.value(index))
         }
       }
 
@@ -240,10 +238,10 @@ class CacheInterceptor(internal val cache: InternalCache?) : Interceptor {
     }
 
     /**
-     * Returns true if `fieldName` is an end-to-end HTTP header, as defined by RFC 2616,
+     * Returns true if [fieldName] is an end-to-end HTTP header, as defined by RFC 2616,
      * 13.5.1.
      */
-    internal fun isEndToEnd(fieldName: String): Boolean {
+    private fun isEndToEnd(fieldName: String): Boolean {
       return !"Connection".equals(fieldName, ignoreCase = true) &&
           !"Keep-Alive".equals(fieldName, ignoreCase = true) &&
           !"Proxy-Authenticate".equals(fieldName, ignoreCase = true) &&
@@ -255,10 +253,10 @@ class CacheInterceptor(internal val cache: InternalCache?) : Interceptor {
     }
 
     /**
-     * Returns true if `fieldName` is content specific and therefore should always be used
+     * Returns true if [fieldName] is content specific and therefore should always be used
      * from cached headers.
      */
-    internal fun isContentSpecificHeader(fieldName: String): Boolean {
+    private fun isContentSpecificHeader(fieldName: String): Boolean {
       return "Content-Length".equals(fieldName, ignoreCase = true) ||
           "Content-Encoding".equals(fieldName, ignoreCase = true) ||
           "Content-Type".equals(fieldName, ignoreCase = true)
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
deleted file mode 100644
index 2753cf27f4..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ /dev/null
@@ -1,326 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.util.Date;
-import javax.annotation.Nullable;
-import okhttp3.CacheControl;
-import okhttp3.Headers;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.http.HttpDate;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.StatusLine;
-
-import static java.net.HttpURLConnection.HTTP_BAD_METHOD;
-import static java.net.HttpURLConnection.HTTP_GONE;
-import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
-import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
-import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
-import static java.net.HttpURLConnection.HTTP_NOT_AUTHORITATIVE;
-import static java.net.HttpURLConnection.HTTP_NOT_FOUND;
-import static java.net.HttpURLConnection.HTTP_NOT_IMPLEMENTED;
-import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
-import static java.net.HttpURLConnection.HTTP_OK;
-import static java.net.HttpURLConnection.HTTP_REQ_TOO_LONG;
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static okhttp3.internal.InternalKtKt.addHeaderLenient;
-
-/**
- * Given a request and cached response, this figures out whether to use the network, the cache, or
- * both.
- *
- * <p>Selecting a cache strategy may add conditions to the request (like the "If-Modified-Since"
- * header for conditional GETs) or warnings to the cached response (if the cached data is
- * potentially stale).
- */
-public final class CacheStrategy {
-  /** The request to send on the network, or null if this call doesn't use the network. */
-  public final @Nullable Request networkRequest;
-
-  /** The cached response to return or validate; or null if this call doesn't use a cache. */
-  public final @Nullable Response cacheResponse;
-
-  CacheStrategy(Request networkRequest, Response cacheResponse) {
-    this.networkRequest = networkRequest;
-    this.cacheResponse = cacheResponse;
-  }
-
-  /** Returns true if {@code response} can be stored to later serve another request. */
-  public static boolean isCacheable(Response response, Request request) {
-    // Always go to network for uncacheable response codes (RFC 7231 section 6.1),
-    // This implementation doesn't support caching partial content.
-    switch (response.code()) {
-      case HTTP_OK:
-      case HTTP_NOT_AUTHORITATIVE:
-      case HTTP_NO_CONTENT:
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_NOT_FOUND:
-      case HTTP_BAD_METHOD:
-      case HTTP_GONE:
-      case HTTP_REQ_TOO_LONG:
-      case HTTP_NOT_IMPLEMENTED:
-      case StatusLine.HTTP_PERM_REDIRECT:
-        // These codes can be cached unless headers forbid it.
-        break;
-
-      case HTTP_MOVED_TEMP:
-      case StatusLine.HTTP_TEMP_REDIRECT:
-        // These codes can only be cached with the right response headers.
-        // http://tools.ietf.org/html/rfc7234#section-3
-        // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.
-        if (response.header("Expires") != null
-            || response.cacheControl().maxAgeSeconds() != -1
-            || response.cacheControl().isPublic()
-            || response.cacheControl().isPrivate()) {
-          break;
-        }
-        // Fall-through.
-
-      default:
-        // All other codes cannot be cached.
-        return false;
-    }
-
-    // A 'no-store' directive on request or response prevents the response from being cached.
-    return !response.cacheControl().noStore() && !request.cacheControl().noStore();
-  }
-
-  public static class Factory {
-    final long nowMillis;
-    final Request request;
-    final Response cacheResponse;
-
-    /** The server's time when the cached response was served, if known. */
-    private Date servedDate;
-    private String servedDateString;
-
-    /** The last modified date of the cached response, if known. */
-    private Date lastModified;
-    private String lastModifiedString;
-
-    /**
-     * The expiration date of the cached response, if known. If both this field and the max age are
-     * set, the max age is preferred.
-     */
-    private Date expires;
-
-    /**
-     * Extension header set by OkHttp specifying the timestamp when the cached HTTP request was
-     * first initiated.
-     */
-    private long sentRequestMillis;
-
-    /**
-     * Extension header set by OkHttp specifying the timestamp when the cached HTTP response was
-     * first received.
-     */
-    private long receivedResponseMillis;
-
-    /** Etag of the cached response. */
-    private String etag;
-
-    /** Age of the cached response. */
-    private int ageSeconds = -1;
-
-    public Factory(long nowMillis, Request request, Response cacheResponse) {
-      this.nowMillis = nowMillis;
-      this.request = request;
-      this.cacheResponse = cacheResponse;
-
-      if (cacheResponse != null) {
-        this.sentRequestMillis = cacheResponse.sentRequestAtMillis();
-        this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();
-        Headers headers = cacheResponse.headers();
-        for (int i = 0, size = headers.size(); i < size; i++) {
-          String fieldName = headers.name(i);
-          String value = headers.value(i);
-          if ("Date".equalsIgnoreCase(fieldName)) {
-            servedDate = HttpDate.parse(value);
-            servedDateString = value;
-          } else if ("Expires".equalsIgnoreCase(fieldName)) {
-            expires = HttpDate.parse(value);
-          } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
-            lastModified = HttpDate.parse(value);
-            lastModifiedString = value;
-          } else if ("ETag".equalsIgnoreCase(fieldName)) {
-            etag = value;
-          } else if ("Age".equalsIgnoreCase(fieldName)) {
-            ageSeconds = HttpHeaders.parseSeconds(value, -1);
-          }
-        }
-      }
-    }
-
-    /**
-     * Returns a strategy to satisfy {@code request} using the a cached response {@code response}.
-     */
-    public CacheStrategy get() {
-      CacheStrategy candidate = getCandidate();
-
-      if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {
-        // We're forbidden from using the network and the cache is insufficient.
-        return new CacheStrategy(null, null);
-      }
-
-      return candidate;
-    }
-
-    /** Returns a strategy to use assuming the request can use the network. */
-    private CacheStrategy getCandidate() {
-      // No cached response.
-      if (cacheResponse == null) {
-        return new CacheStrategy(request, null);
-      }
-
-      // Drop the cached response if it's missing a required handshake.
-      if (request.isHttps() && cacheResponse.handshake() == null) {
-        return new CacheStrategy(request, null);
-      }
-
-      // If this response shouldn't have been stored, it should never be used
-      // as a response source. This check should be redundant as long as the
-      // persistence store is well-behaved and the rules are constant.
-      if (!isCacheable(cacheResponse, request)) {
-        return new CacheStrategy(request, null);
-      }
-
-      CacheControl requestCaching = request.cacheControl();
-      if (requestCaching.noCache() || hasConditions(request)) {
-        return new CacheStrategy(request, null);
-      }
-
-      CacheControl responseCaching = cacheResponse.cacheControl();
-
-      long ageMillis = cacheResponseAge();
-      long freshMillis = computeFreshnessLifetime();
-
-      if (requestCaching.maxAgeSeconds() != -1) {
-        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
-      }
-
-      long minFreshMillis = 0;
-      if (requestCaching.minFreshSeconds() != -1) {
-        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
-      }
-
-      long maxStaleMillis = 0;
-      if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
-        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
-      }
-
-      if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
-        Response.Builder builder = cacheResponse.newBuilder();
-        if (ageMillis + minFreshMillis >= freshMillis) {
-          builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
-        }
-        long oneDayMillis = 24 * 60 * 60 * 1000L;
-        if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
-          builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
-        }
-        return new CacheStrategy(null, builder.build());
-      }
-
-      // Find a condition to add to the request. If the condition is satisfied, the response body
-      // will not be transmitted.
-      String conditionName;
-      String conditionValue;
-      if (etag != null) {
-        conditionName = "If-None-Match";
-        conditionValue = etag;
-      } else if (lastModified != null) {
-        conditionName = "If-Modified-Since";
-        conditionValue = lastModifiedString;
-      } else if (servedDate != null) {
-        conditionName = "If-Modified-Since";
-        conditionValue = servedDateString;
-      } else {
-        return new CacheStrategy(request, null); // No condition! Make a regular request.
-      }
-
-      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();
-      addHeaderLenient(conditionalRequestHeaders, conditionName, conditionValue);
-
-      Request conditionalRequest = request.newBuilder()
-          .headers(conditionalRequestHeaders.build())
-          .build();
-      return new CacheStrategy(conditionalRequest, cacheResponse);
-    }
-
-    /**
-     * Returns the number of milliseconds that the response was fresh for, starting from the served
-     * date.
-     */
-    private long computeFreshnessLifetime() {
-      CacheControl responseCaching = cacheResponse.cacheControl();
-      if (responseCaching.maxAgeSeconds() != -1) {
-        return SECONDS.toMillis(responseCaching.maxAgeSeconds());
-      } else if (expires != null) {
-        long servedMillis = servedDate != null
-            ? servedDate.getTime()
-            : receivedResponseMillis;
-        long delta = expires.getTime() - servedMillis;
-        return delta > 0 ? delta : 0;
-      } else if (lastModified != null
-          && cacheResponse.request().url().query() == null) {
-        // As recommended by the HTTP RFC and implemented in Firefox, the
-        // max age of a document should be defaulted to 10% of the
-        // document's age at the time it was served. Default expiration
-        // dates aren't used for URIs containing a query.
-        long servedMillis = servedDate != null
-            ? servedDate.getTime()
-            : sentRequestMillis;
-        long delta = servedMillis - lastModified.getTime();
-        return delta > 0 ? (delta / 10) : 0;
-      }
-      return 0;
-    }
-
-    /**
-     * Returns the current age of the response, in milliseconds. The calculation is specified by RFC
-     * 7234, 4.2.3 Calculating Age.
-     */
-    private long cacheResponseAge() {
-      long apparentReceivedAge = servedDate != null
-          ? Math.max(0, receivedResponseMillis - servedDate.getTime())
-          : 0;
-      long receivedAge = ageSeconds != -1
-          ? Math.max(apparentReceivedAge, SECONDS.toMillis(ageSeconds))
-          : apparentReceivedAge;
-      long responseDuration = receivedResponseMillis - sentRequestMillis;
-      long residentDuration = nowMillis - receivedResponseMillis;
-      return receivedAge + responseDuration + residentDuration;
-    }
-
-    /**
-     * Returns true if computeFreshnessLifetime used a heuristic. If we used a heuristic to serve a
-     * cached response older than 24 hours, we are required to attach a warning.
-     */
-    private boolean isFreshnessLifetimeHeuristic() {
-      return cacheResponse.cacheControl().maxAgeSeconds() == -1 && expires == null;
-    }
-
-    /**
-     * Returns true if the request contains conditions that save the server from sending a response
-     * that the client has locally. When a request is enqueued with its own conditions, the built-in
-     * response cache won't be used.
-     */
-    private static boolean hasConditions(Request request) {
-      return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.kt b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.kt
new file mode 100644
index 0000000000..a1149bec0f
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.kt
@@ -0,0 +1,331 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache
+
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.internal.http.StatusLine
+import okhttp3.internal.http.toHttpDateOrNull
+import okhttp3.internal.toNonNegativeInt
+import java.net.HttpURLConnection.HTTP_BAD_METHOD
+import java.net.HttpURLConnection.HTTP_GONE
+import java.net.HttpURLConnection.HTTP_MOVED_PERM
+import java.net.HttpURLConnection.HTTP_MOVED_TEMP
+import java.net.HttpURLConnection.HTTP_MULT_CHOICE
+import java.net.HttpURLConnection.HTTP_NOT_AUTHORITATIVE
+import java.net.HttpURLConnection.HTTP_NOT_FOUND
+import java.net.HttpURLConnection.HTTP_NOT_IMPLEMENTED
+import java.net.HttpURLConnection.HTTP_NO_CONTENT
+import java.net.HttpURLConnection.HTTP_OK
+import java.net.HttpURLConnection.HTTP_REQ_TOO_LONG
+import java.util.Date
+import java.util.concurrent.TimeUnit.SECONDS
+
+/**
+ * Given a request and cached response, this figures out whether to use the network, the cache, or
+ * both.
+ *
+ * Selecting a cache strategy may add conditions to the request (like the "If-Modified-Since" header
+ * for conditional GETs) or warnings to the cached response (if the cached data is potentially
+ * stale).
+ */
+class CacheStrategy internal constructor(
+  /** The request to send on the network, or null if this call doesn't use the network. */
+  val networkRequest: Request?,
+  /** The cached response to return or validate; or null if this call doesn't use a cache. */
+  val cacheResponse: Response?
+) {
+
+  class Factory(
+    private val nowMillis: Long,
+    internal val request: Request,
+    private val cacheResponse: Response?
+  ) {
+    /** The server's time when the cached response was served, if known. */
+    private var servedDate: Date? = null
+    private var servedDateString: String? = null
+
+    /** The last modified date of the cached response, if known. */
+    private var lastModified: Date? = null
+    private var lastModifiedString: String? = null
+
+    /**
+     * The expiration date of the cached response, if known. If both this field and the max age are
+     * set, the max age is preferred.
+     */
+    private var expires: Date? = null
+
+    /**
+     * Extension header set by OkHttp specifying the timestamp when the cached HTTP request was
+     * first initiated.
+     */
+    private var sentRequestMillis = 0L
+
+    /**
+     * Extension header set by OkHttp specifying the timestamp when the cached HTTP response was
+     * first received.
+     */
+    private var receivedResponseMillis = 0L
+
+    /** Etag of the cached response. */
+    private var etag: String? = null
+
+    /** Age of the cached response. */
+    private var ageSeconds = -1
+
+    /**
+     * Returns true if computeFreshnessLifetime used a heuristic. If we used a heuristic to serve a
+     * cached response older than 24 hours, we are required to attach a warning.
+     */
+    private fun isFreshnessLifetimeHeuristic(): Boolean {
+      return cacheResponse!!.cacheControl.maxAgeSeconds == -1 && expires == null
+    }
+
+    init {
+      if (cacheResponse != null) {
+        this.sentRequestMillis = cacheResponse.sentRequestAtMillis
+        this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis
+        val headers = cacheResponse.headers
+        for (i in 0 until headers.size) {
+          val fieldName = headers.name(i)
+          val value = headers.value(i)
+          when {
+            fieldName.equals("Date", ignoreCase = true) -> {
+              servedDate = value.toHttpDateOrNull()
+              servedDateString = value
+            }
+            fieldName.equals("Expires", ignoreCase = true) -> {
+              expires = value.toHttpDateOrNull()
+            }
+            fieldName.equals("Last-Modified", ignoreCase = true) -> {
+              lastModified = value.toHttpDateOrNull()
+              lastModifiedString = value
+            }
+            fieldName.equals("ETag", ignoreCase = true) -> {
+              etag = value
+            }
+            fieldName.equals("Age", ignoreCase = true) -> {
+              ageSeconds = value.toNonNegativeInt(-1)
+            }
+          }
+        }
+      }
+    }
+
+    /** Returns a strategy to satisfy [request] using [cacheResponse]. */
+    fun compute(): CacheStrategy {
+      val candidate = computeCandidate()
+
+      // We're forbidden from using the network and the cache is insufficient.
+      if (candidate.networkRequest != null && request.cacheControl.onlyIfCached) {
+        return CacheStrategy(null, null)
+      }
+
+      return candidate
+    }
+
+    /** Returns a strategy to use assuming the request can use the network. */
+    private fun computeCandidate(): CacheStrategy {
+      // No cached response.
+      if (cacheResponse == null) {
+        return CacheStrategy(request, null)
+      }
+
+      // Drop the cached response if it's missing a required handshake.
+      if (request.isHttps && cacheResponse.handshake == null) {
+        return CacheStrategy(request, null)
+      }
+
+      // If this response shouldn't have been stored, it should never be used as a response source.
+      // This check should be redundant as long as the persistence store is well-behaved and the
+      // rules are constant.
+      if (!isCacheable(cacheResponse, request)) {
+        return CacheStrategy(request, null)
+      }
+
+      val requestCaching = request.cacheControl
+      if (requestCaching.noCache || hasConditions(request)) {
+        return CacheStrategy(request, null)
+      }
+
+      val responseCaching = cacheResponse.cacheControl
+
+      val ageMillis = cacheResponseAge()
+      var freshMillis = computeFreshnessLifetime()
+
+      if (requestCaching.maxAgeSeconds != -1) {
+        freshMillis = minOf(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds.toLong()))
+      }
+
+      var minFreshMillis: Long = 0
+      if (requestCaching.minFreshSeconds != -1) {
+        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds.toLong())
+      }
+
+      var maxStaleMillis: Long = 0
+      if (!responseCaching.mustRevalidate && requestCaching.maxStaleSeconds != -1) {
+        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds.toLong())
+      }
+
+      if (!responseCaching.noCache && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
+        val builder = cacheResponse.newBuilder()
+        if (ageMillis + minFreshMillis >= freshMillis) {
+          builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"")
+        }
+        val oneDayMillis = 24 * 60 * 60 * 1000L
+        if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
+          builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"")
+        }
+        return CacheStrategy(null, builder.build())
+      }
+
+      // Find a condition to add to the request. If the condition is satisfied, the response body
+      // will not be transmitted.
+      val conditionName: String
+      val conditionValue: String?
+      when {
+        etag != null -> {
+          conditionName = "If-None-Match"
+          conditionValue = etag
+        }
+
+        lastModified != null -> {
+          conditionName = "If-Modified-Since"
+          conditionValue = lastModifiedString
+        }
+
+        servedDate != null -> {
+          conditionName = "If-Modified-Since"
+          conditionValue = servedDateString
+        }
+
+        else -> return CacheStrategy(request, null) // No condition! Make a regular request.
+      }
+
+      val conditionalRequestHeaders = request.headers.newBuilder()
+      conditionalRequestHeaders.addLenient(conditionName, conditionValue!!)
+
+      val conditionalRequest = request.newBuilder()
+          .headers(conditionalRequestHeaders.build())
+          .build()
+      return CacheStrategy(conditionalRequest, cacheResponse)
+    }
+
+    /**
+     * Returns the number of milliseconds that the response was fresh for, starting from the served
+     * date.
+     */
+    private fun computeFreshnessLifetime(): Long {
+      val responseCaching = cacheResponse!!.cacheControl
+      if (responseCaching.maxAgeSeconds != -1) {
+        return SECONDS.toMillis(responseCaching.maxAgeSeconds.toLong())
+      }
+
+      val expires = this.expires
+      if (expires != null) {
+        val servedMillis = servedDate?.time ?: receivedResponseMillis
+        val delta = expires.time - servedMillis
+        return if (delta > 0L) delta else 0L
+      }
+
+      if (lastModified != null && cacheResponse.request.url.query == null) {
+        // As recommended by the HTTP RFC and implemented in Firefox, the max age of a document
+        // should be defaulted to 10% of the document's age at the time it was served. Default
+        // expiration dates aren't used for URIs containing a query.
+        val servedMillis = servedDate?.time ?: sentRequestMillis
+        val delta = servedMillis - lastModified!!.time
+        return if (delta > 0L) delta / 10 else 0L
+      }
+
+      return 0L
+    }
+
+    /**
+     * Returns the current age of the response, in milliseconds. The calculation is specified by RFC
+     * 7234, 4.2.3 Calculating Age.
+     */
+    private fun cacheResponseAge(): Long {
+      val servedDate = this.servedDate
+      val apparentReceivedAge = if (servedDate != null) {
+        maxOf(0, receivedResponseMillis - servedDate.time)
+      } else {
+        0
+      }
+
+      val receivedAge = if (ageSeconds != -1) {
+        maxOf(apparentReceivedAge, SECONDS.toMillis(ageSeconds.toLong()))
+      } else {
+        apparentReceivedAge
+      }
+
+      val responseDuration = receivedResponseMillis - sentRequestMillis
+      val residentDuration = nowMillis - receivedResponseMillis
+      return receivedAge + responseDuration + residentDuration
+    }
+
+    /**
+     * Returns true if the request contains conditions that save the server from sending a response
+     * that the client has locally. When a request is enqueued with its own conditions, the built-in
+     * response cache won't be used.
+     */
+    private fun hasConditions(request: Request): Boolean =
+        request.header("If-Modified-Since") != null || request.header("If-None-Match") != null
+  }
+
+  companion object {
+    /** Returns true if [response] can be stored to later serve another request. */
+    fun isCacheable(response: Response, request: Request): Boolean {
+      // Always go to network for uncacheable response codes (RFC 7231 section 6.1), This
+      // implementation doesn't support caching partial content.
+      when (response.code) {
+        HTTP_OK,
+        HTTP_NOT_AUTHORITATIVE,
+        HTTP_NO_CONTENT,
+        HTTP_MULT_CHOICE,
+        HTTP_MOVED_PERM,
+        HTTP_NOT_FOUND,
+        HTTP_BAD_METHOD,
+        HTTP_GONE,
+        HTTP_REQ_TOO_LONG,
+        HTTP_NOT_IMPLEMENTED,
+        StatusLine.HTTP_PERM_REDIRECT -> {
+          // These codes can be cached unless headers forbid it.
+        }
+
+        HTTP_MOVED_TEMP,
+        StatusLine.HTTP_TEMP_REDIRECT -> {
+          // These codes can only be cached with the right response headers.
+          // http://tools.ietf.org/html/rfc7234#section-3
+          // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.
+          if (response.header("Expires") == null &&
+              response.cacheControl.maxAgeSeconds == -1 &&
+              !response.cacheControl.isPublic &&
+              !response.cacheControl.isPrivate) {
+            return false
+          }
+        }
+
+        else -> {
+          // All other codes cannot be cached.
+          return false
+        }
+      }
+
+      // A 'no-store' directive on request or response prevents the response from being cached.
+      return !response.cacheControl.noStore && !request.cacheControl.noStore
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
index a2be81ae35..b9d028b094 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
@@ -15,11 +15,12 @@
  */
 package okhttp3.internal.cache
 
-import okhttp3.internal.Util
 import okhttp3.internal.cache.DiskLruCache.Editor
+import okhttp3.internal.closeQuietly
 import okhttp3.internal.io.FileSystem
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.platform.Platform.Companion.WARN
+import okhttp3.internal.threadFactory
 import okio.BufferedSink
 import okio.Sink
 import okio.Source
@@ -38,7 +39,6 @@ import java.util.concurrent.Executor
 import java.util.concurrent.LinkedBlockingQueue
 import java.util.concurrent.ThreadPoolExecutor
 import java.util.concurrent.TimeUnit
-import java.util.regex.Pattern
 
 /**
  * A cache that uses a bounded amount of space on a filesystem. Each cache entry has a string key
@@ -80,7 +80,7 @@ import java.util.regex.Pattern
 class DiskLruCache internal constructor(
   internal val fileSystem: FileSystem,
 
-  /** Returns the directory where this cache stores its data.  */
+  /** Returns the directory where this cache stores its data. */
   val directory: File,
 
   private val appVersion: Int,
@@ -90,7 +90,7 @@ class DiskLruCache internal constructor(
   /** Returns the maximum number of bytes that this cache should use to store its data. */
   maxSize: Long,
 
-  /** Used to run 'cleanupRunnable' for journal rebuilds.  */
+  /** Used to run 'cleanupRunnable' for journal rebuilds. */
   private val executor: Executor
 
 ) : Closeable, Flushable {
@@ -150,7 +150,7 @@ class DiskLruCache internal constructor(
   private var journalWriter: BufferedSink? = null
   internal val lruEntries = LinkedHashMap<String, Entry>(0, 0.75f, true)
   private var redundantOpCount: Int = 0
-  internal var hasJournalErrors: Boolean = false
+  private var hasJournalErrors: Boolean = false
 
   // Must be read and written when synchronized on 'this'.
   private var initialized: Boolean = false
@@ -316,8 +316,7 @@ class DiskLruCache internal constructor(
     when {
       secondSpace != -1 && firstSpace == CLEAN.length && line.startsWith(CLEAN) -> {
         val parts = line.substring(secondSpace + 1)
-            .split(" ".toRegex())
-            .toTypedArray()
+            .split(' ')
         entry.readable = true
         entry.currentEditor = null
         entry.setLengths(parts)
@@ -401,7 +400,7 @@ class DiskLruCache internal constructor(
   }
 
   /**
-   * Returns a snapshot of the entry named `key`, or null if it doesn't exist is not currently
+   * Returns a snapshot of the entry named [key], or null if it doesn't exist is not currently
    * readable. If a value is returned, it is moved to the head of the LRU queue.
    */
   @Synchronized @Throws(IOException::class)
@@ -426,7 +425,7 @@ class DiskLruCache internal constructor(
     return snapshot
   }
 
-  /** Returns an editor for the entry named `key`, or null if another edit is in progress. */
+  /** Returns an editor for the entry named [key], or null if another edit is in progress. */
   @Synchronized @Throws(IOException::class)
   @JvmOverloads
   fun edit(key: String, expectedSequenceNumber: Long = ANY_SEQUENCE_NUMBER): Editor? {
@@ -602,7 +601,7 @@ class DiskLruCache internal constructor(
     check(!closed) { "cache is closed" }
   }
 
-  /** Force buffered operations to the filesystem.  */
+  /** Force buffered operations to the filesystem. */
   @Synchronized @Throws(IOException::class)
   override fun flush() {
     if (!initialized) return
@@ -614,7 +613,7 @@ class DiskLruCache internal constructor(
 
   @Synchronized fun isClosed(): Boolean = closed
 
-  /** Closes this cache. Stored values will remain on the filesystem.  */
+  /** Closes this cache. Stored values will remain on the filesystem. */
   @Synchronized @Throws(IOException::class)
   override fun close() {
     if (!initialized || closed) {
@@ -669,8 +668,7 @@ class DiskLruCache internal constructor(
   }
 
   private fun validateKey(key: String) {
-    val matcher = LEGAL_KEY_PATTERN.matcher(key)
-    require(matcher.matches()) { "keys must match regex [a-z0-9_-]{1,120}: \"$key\"" }
+    require(LEGAL_KEY_PATTERN.matches(key)) { "keys must match regex [a-z0-9_-]{1,120}: \"$key\"" }
   }
 
   /**
@@ -690,13 +688,13 @@ class DiskLruCache internal constructor(
   fun snapshots(): MutableIterator<Snapshot> {
     initialize()
     return object : MutableIterator<Snapshot> {
-      /** Iterate a copy of the entries to defend against concurrent modification errors.  */
+      /** Iterate a copy of the entries to defend against concurrent modification errors. */
       val delegate = ArrayList(lruEntries.values).iterator()
 
-      /** The snapshot to return from [next]. Null if we haven't computed that yet.  */
+      /** The snapshot to return from [next]. Null if we haven't computed that yet. */
       var nextSnapshot: Snapshot? = null
 
-      /** The snapshot to remove with [remove]. Null if removal is illegal.  */
+      /** The snapshot to remove with [remove]. Null if removal is illegal. */
       var removeSnapshot: Snapshot? = null
 
       override fun hasNext(): Boolean {
@@ -708,6 +706,8 @@ class DiskLruCache internal constructor(
 
           while (delegate.hasNext()) {
             val entry = delegate.next()
+            if (entry == null || !entry.readable) continue // Entry during edit
+
             val snapshot = entry.snapshot() ?: continue
             // Evicted since we copied the entries.
             nextSnapshot = snapshot
@@ -740,7 +740,7 @@ class DiskLruCache internal constructor(
     }
   }
 
-  /** A snapshot of the values for an entry.  */
+  /** A snapshot of the values for an entry. */
   inner class Snapshot internal constructor(
     private val key: String,
     private val sequenceNumber: Long,
@@ -756,20 +756,20 @@ class DiskLruCache internal constructor(
     @Throws(IOException::class)
     fun edit(): Editor? = this@DiskLruCache.edit(key, sequenceNumber)
 
-    /** Returns the unbuffered stream with the value for `index`.  */
+    /** Returns the unbuffered stream with the value for [index]. */
     fun getSource(index: Int): Source = sources[index]
 
-    /** Returns the byte length of the value for `index`.  */
+    /** Returns the byte length of the value for [index]. */
     fun getLength(index: Int): Long = lengths[index]
 
     override fun close() {
       for (source in sources) {
-        Util.closeQuietly(source)
+        source.closeQuietly()
       }
     }
   }
 
-  /** Edits the values for an entry.  */
+  /** Edits the values for an entry. */
   inner class Editor internal constructor(internal val entry: Entry) {
     internal val written: BooleanArray? = if (entry.readable) null else BooleanArray(valueCount)
     private var done: Boolean = false
@@ -875,18 +875,18 @@ class DiskLruCache internal constructor(
     internal val key: String
   ) {
 
-    /** Lengths of this entry's files.  */
+    /** Lengths of this entry's files. */
     internal val lengths: LongArray = LongArray(valueCount)
     internal val cleanFiles = mutableListOf<File>()
     internal val dirtyFiles = mutableListOf<File>()
 
-    /** True if this entry has ever been published.  */
+    /** True if this entry has ever been published. */
     internal var readable: Boolean = false
 
-    /** The ongoing edit or null if this entry is not being edited.  */
+    /** The ongoing edit or null if this entry is not being edited. */
     internal var currentEditor: Editor? = null
 
-    /** The sequence number of the most recently committed edit to this entry.  */
+    /** The sequence number of the most recently committed edit to this entry. */
     internal var sequenceNumber: Long = 0
 
     init {
@@ -902,9 +902,9 @@ class DiskLruCache internal constructor(
       }
     }
 
-    /** Set lengths using decimal numbers like "10123".  */
+    /** Set lengths using decimal numbers like "10123". */
     @Throws(IOException::class)
-    internal fun setLengths(strings: Array<String>) {
+    internal fun setLengths(strings: List<String>) {
       if (strings.size != valueCount) {
         throw invalidLengths(strings)
       }
@@ -918,7 +918,7 @@ class DiskLruCache internal constructor(
       }
     }
 
-    /** Append space-prefixed lengths to `writer`.  */
+    /** Append space-prefixed lengths to [writer]. */
     @Throws(IOException::class)
     internal fun writeLengths(writer: BufferedSink) {
       for (length in lengths) {
@@ -927,8 +927,8 @@ class DiskLruCache internal constructor(
     }
 
     @Throws(IOException::class)
-    private fun invalidLengths(strings: Array<String>): IOException {
-      throw IOException("unexpected journal line: ${strings.contentToString()}")
+    private fun invalidLengths(strings: List<String>): IOException {
+      throw IOException("unexpected journal line: $strings")
     }
 
     /**
@@ -949,7 +949,7 @@ class DiskLruCache internal constructor(
       } catch (_: FileNotFoundException) {
         // A file must have been deleted manually!
         for (source in sources) {
-          Util.closeQuietly(source)
+          source.closeQuietly()
         }
         // Since the entry is no longer valid, remove it so the metadata is accurate (i.e. the cache
         // size.)
@@ -969,21 +969,20 @@ class DiskLruCache internal constructor(
     @JvmField val MAGIC = "libcore.io.DiskLruCache"
     @JvmField val VERSION_1 = "1"
     @JvmField val ANY_SEQUENCE_NUMBER: Long = -1
-    @JvmField val LEGAL_KEY_PATTERN = Pattern.compile("[a-z0-9_-]{1,120}")
+    @JvmField val LEGAL_KEY_PATTERN = "[a-z0-9_-]{1,120}".toRegex()
     @JvmField val CLEAN = "CLEAN"
     @JvmField val DIRTY = "DIRTY"
     @JvmField val REMOVE = "REMOVE"
     @JvmField val READ = "READ"
 
     /**
-     * Create a cache which will reside in `directory`. This cache is lazily initialized on first
+     * Create a cache which will reside in [directory]. This cache is lazily initialized on first
      * access and will be created if it does not exist.
      *
      * @param directory a writable directory
      * @param valueCount the number of values per cache entry. Must be positive.
      * @param maxSize the maximum number of bytes this cache should use to store
      */
-    @JvmStatic
     fun create(
       fileSystem: FileSystem,
       directory: File,
@@ -991,12 +990,12 @@ class DiskLruCache internal constructor(
       valueCount: Int,
       maxSize: Long
     ): DiskLruCache {
-      require(maxSize > 0) { "maxSize <= 0" }
+      require(maxSize > 0L) { "maxSize <= 0" }
       require(valueCount > 0) { "valueCount <= 0" }
 
       // Use a single background thread to evict entries.
       val executor = ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
-          LinkedBlockingQueue(), Util.threadFactory("OkHttp DiskLruCache", true))
+          LinkedBlockingQueue(), threadFactory("OkHttp DiskLruCache", true))
 
       return DiskLruCache(fileSystem, directory, appVersion, valueCount, maxSize, executor)
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.kt b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.kt
deleted file mode 100644
index f066062fec..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.kt
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache
-
-import okhttp3.Request
-import okhttp3.Response
-import java.io.IOException
-
-/**
- * OkHttp's internal cache interface. Applications shouldn't implement this: instead use [okhttp3.Cache].
- */
-interface InternalCache {
-
-  @Throws(IOException::class)
-  fun get(request: Request): Response?
-
-  @Throws(IOException::class)
-  fun put(response: Response): CacheRequest?
-
-  /**
-   * Remove any cache entries for the supplied [request]. This is invoked when the client
-   * invalidates the cache, such as when making POST requests.
-   */
-  @Throws(IOException::class)
-  fun remove(request: Request)
-
-  /**
-   * Handles a conditional request hit by updating the stored cache response with the headers from
-   * [network]. The cached response body is not updated. If the stored response has changed
-   * since [cached] was returned, this does nothing.
-   */
-  fun update(cached: Response, network: Response)
-
-  /** Track an conditional GET that was satisfied by this cache. */
-  fun trackConditionalCacheHit()
-
-  /** Track an HTTP response being satisfied with [cacheStrategy]. */
-  fun trackResponse(cacheStrategy: CacheStrategy)
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
deleted file mode 100644
index b4ce63012f..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache2;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.nio.channels.FileChannel;
-import okio.Buffer;
-import okio.Okio;
-
-/**
- * Read and write a target file. Unlike Okio's built-in {@linkplain Okio#source(java.io.File) file
- * source} and {@linkplain Okio#sink(java.io.File) file sink} this class offers:
- *
- * <ul>
- *   <li><strong>Read/write:</strong> read and write using the same operator.
- *   <li><strong>Random access:</strong> access any position within the file.
- *   <li><strong>Shared channels:</strong> read and write a file channel that's shared between
- *       multiple operators. Note that although the underlying {@code FileChannel} may be shared,
- *       each {@code FileOperator} should not be.
- * </ul>
- */
-final class FileOperator {
-  private final FileChannel fileChannel;
-
-  FileOperator(FileChannel fileChannel) {
-    this.fileChannel = fileChannel;
-  }
-
-  /** Write {@code byteCount} bytes from {@code source} to the file at {@code pos}. */
-  public void write(long pos, Buffer source, long byteCount) throws IOException {
-    if (byteCount < 0 || byteCount > source.size()) throw new IndexOutOfBoundsException();
-
-    while (byteCount > 0L) {
-      long bytesWritten = fileChannel.transferFrom(source, pos, byteCount);
-      pos += bytesWritten;
-      byteCount -= bytesWritten;
-    }
-  }
-
-  /**
-   * Copy {@code byteCount} bytes from the file at {@code pos} into to {@code source}. It is the
-   * caller's responsibility to make sure there are sufficient bytes to read: if there aren't this
-   * method throws an {@link EOFException}.
-   */
-  public void read(long pos, Buffer sink, long byteCount) throws IOException {
-    if (byteCount < 0) throw new IndexOutOfBoundsException();
-
-    while (byteCount > 0L) {
-      long bytesRead = fileChannel.transferTo(pos, byteCount, sink);
-      pos += bytesRead;
-      byteCount -= bytesRead;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.kt b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.kt
new file mode 100644
index 0000000000..26e6f53750
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.kt
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache2
+
+import okio.Buffer
+import java.io.IOException
+import java.nio.channels.FileChannel
+
+/**
+ * Read and write a target file. Unlike Okio's built-in `Okio.source(java.io.File file)` and `Okio.sink(java.io.File file)`
+ * this class offers:
+ *
+ *  * **Read/write:** read and write using the same operator.
+ *  * **Random access:** access any position within the file.
+ *  * **Shared channels:** read and write a file channel that's shared between
+ * multiple operators. Note that although the underlying [FileChannel] may be shared,
+ * each [FileOperator] should not be.
+ */
+internal class FileOperator(
+  private val fileChannel: FileChannel
+) {
+
+  /** Write [byteCount] bytes from [source] to the file at [pos]. */
+  @Throws(IOException::class)
+  fun write(pos: Long, source: Buffer, byteCount: Long) {
+    if (byteCount < 0L || byteCount > source.size) {
+      throw IndexOutOfBoundsException()
+    }
+    var mutablePos = pos
+    var mutableByteCount = byteCount
+
+    while (mutableByteCount > 0L) {
+      val bytesWritten = fileChannel.transferFrom(source, mutablePos, mutableByteCount)
+      mutablePos += bytesWritten
+      mutableByteCount -= bytesWritten
+    }
+  }
+
+  /**
+   * Copy [byteCount] bytes from the file at [pos] into `source`. It is the
+   * caller's responsibility to make sure there are sufficient bytes to read: if there aren't this
+   * method throws an `EOFException`.
+   */
+  fun read(pos: Long, sink: Buffer, byteCount: Long) {
+    if (byteCount < 0L) {
+      throw IndexOutOfBoundsException()
+    }
+    var mutablePos = pos
+    var mutableByteCount = byteCount
+
+    while (mutableByteCount > 0L) {
+      val bytesRead = fileChannel.transferTo(mutablePos, mutableByteCount, sink)
+      mutablePos += bytesRead
+      mutableByteCount -= bytesRead
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
deleted file mode 100644
index 5131e6cd16..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
+++ /dev/null
@@ -1,361 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache2;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import okio.Buffer;
-import okio.ByteString;
-import okio.Source;
-import okio.Timeout;
-
-import static okhttp3.internal.Util.closeQuietly;
-
-/**
- * Replicates a single upstream source into multiple downstream sources. Each downstream source
- * returns the same bytes as the upstream source. Downstream sources may read data either as it
- * is returned by upstream, or after the upstream source has been exhausted.
- *
- * <p>As bytes are returned from upstream they are written to a local file. Downstream sources read
- * from this file as necessary.
- *
- * <p>This class also keeps a small buffer of bytes recently read from upstream. This is intended to
- * save a small amount of file I/O and data copying.
- */
-// TODO(jwilson): what to do about timeouts? They could be different and unfortunately when any
-//     timeout is hit we like to tear down the whole stream.
-final class Relay {
-  private static final int SOURCE_UPSTREAM = 1;
-  private static final int SOURCE_FILE = 2;
-
-  static final ByteString PREFIX_CLEAN = ByteString.encodeUtf8("OkHttp cache v1\n");
-  static final ByteString PREFIX_DIRTY = ByteString.encodeUtf8("OkHttp DIRTY :(\n");
-  private static final long FILE_HEADER_SIZE = 32L;
-
-  /**
-   * Read/write persistence of the upstream source and its metadata. Its layout is as follows:
-   *
-   * <ul>
-   *   <li>16 bytes: either {@code OkHttp cache v1\n} if the persisted file is complete. This is
-   *       another sequence of bytes if the file is incomplete and should not be used.
-   *   <li>8 bytes: <i>n</i>: upstream data size
-   *   <li>8 bytes: <i>m</i>: metadata size
-   *   <li><i>n</i> bytes: upstream data
-   *   <li><i>m</i> bytes: metadata
-   * </ul>
-   *
-   * <p>This is closed and assigned to null when the last source is closed and no further sources
-   * are permitted.
-   */
-  RandomAccessFile file;
-
-  /** The thread that currently has access to upstream. Possibly null. Guarded by this. */
-  Thread upstreamReader;
-
-  /**
-   * Null once the file has a complete copy of the upstream bytes. Only the {@code upstreamReader}
-   * thread may access this source.
-   */
-  Source upstream;
-
-  /**
-   * A buffer for {@code upstreamReader} to use when pulling bytes from upstream. Only the {@code
-   * upstreamReader} thread may access this buffer.
-   */
-  final Buffer upstreamBuffer = new Buffer();
-
-  /** The number of bytes consumed from {@link #upstream}. Guarded by this. */
-  long upstreamPos;
-
-  /** True if there are no further bytes to read from {@code upstream}. Guarded by this. */
-  boolean complete;
-
-  /** User-supplied additional data persisted with the source data. */
-  private final ByteString metadata;
-
-  /**
-   * The most recently read bytes from {@link #upstream}. This is a suffix of {@link #file}. Guarded
-   * by this.
-   */
-  final Buffer buffer = new Buffer();
-
-  /** The maximum size of {@code buffer}. */
-  final long bufferMaxSize;
-
-  /**
-   * Reference count of the number of active sources reading this stream. When decremented to 0
-   * resources are released and all following calls to {@link #newSource} return null. Guarded by
-   * this.
-   */
-  int sourceCount;
-
-  private Relay(RandomAccessFile file, Source upstream, long upstreamPos, ByteString metadata,
-      long bufferMaxSize) {
-    this.file = file;
-    this.upstream = upstream;
-    this.complete = upstream == null;
-    this.upstreamPos = upstreamPos;
-    this.metadata = metadata;
-    this.bufferMaxSize = bufferMaxSize;
-  }
-
-  /**
-   * Creates a new relay that reads a live stream from {@code upstream}, using {@code file} to share
-   * that data with other sources.
-   *
-   * <p><strong>Warning:</strong> callers to this method must immediately call {@link #newSource} to
-   * create a source and close that when they're done. Otherwise a handle to {@code file} will be
-   * leaked.
-   */
-  public static Relay edit(
-      File file, Source upstream, ByteString metadata, long bufferMaxSize) throws IOException {
-    RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw");
-    Relay result = new Relay(randomAccessFile, upstream, 0L, metadata, bufferMaxSize);
-
-    // Write a dirty header. That way if we crash we won't attempt to recover this.
-    randomAccessFile.setLength(0L);
-    result.writeHeader(PREFIX_DIRTY, -1L, -1L);
-
-    return result;
-  }
-
-  /**
-   * Creates a relay that reads a recorded stream from {@code file}.
-   *
-   * <p><strong>Warning:</strong> callers to this method must immediately call {@link #newSource} to
-   * create a source and close that when they're done. Otherwise a handle to {@code file} will be
-   * leaked.
-   */
-  public static Relay read(File file) throws IOException {
-    RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw");
-    FileOperator fileOperator = new FileOperator(randomAccessFile.getChannel());
-
-    // Read the header.
-    Buffer header = new Buffer();
-    fileOperator.read(0, header, FILE_HEADER_SIZE);
-    ByteString prefix = header.readByteString(PREFIX_CLEAN.size());
-    if (!prefix.equals(PREFIX_CLEAN)) throw new IOException("unreadable cache file");
-    long upstreamSize = header.readLong();
-    long metadataSize = header.readLong();
-
-    // Read the metadata.
-    Buffer metadataBuffer = new Buffer();
-    fileOperator.read(FILE_HEADER_SIZE + upstreamSize, metadataBuffer, metadataSize);
-    ByteString metadata = metadataBuffer.readByteString();
-
-    // Return the result.
-    return new Relay(randomAccessFile, null, upstreamSize, metadata, 0L);
-  }
-
-  private void writeHeader(
-      ByteString prefix, long upstreamSize, long metadataSize) throws IOException {
-    Buffer header = new Buffer();
-    header.write(prefix);
-    header.writeLong(upstreamSize);
-    header.writeLong(metadataSize);
-    if (header.size() != FILE_HEADER_SIZE) throw new IllegalArgumentException();
-
-    FileOperator fileOperator = new FileOperator(file.getChannel());
-    fileOperator.write(0, header, FILE_HEADER_SIZE);
-  }
-
-  private void writeMetadata(long upstreamSize) throws IOException {
-    Buffer metadataBuffer = new Buffer();
-    metadataBuffer.write(metadata);
-
-    FileOperator fileOperator = new FileOperator(file.getChannel());
-    fileOperator.write(FILE_HEADER_SIZE + upstreamSize, metadataBuffer, metadata.size());
-  }
-
-  void commit(long upstreamSize) throws IOException {
-    // Write metadata to the end of the file.
-    writeMetadata(upstreamSize);
-    file.getChannel().force(false);
-
-    // Once everything else is in place we can swap the dirty header for a clean one.
-    writeHeader(PREFIX_CLEAN, upstreamSize, metadata.size());
-    file.getChannel().force(false);
-
-    // This file is complete.
-    synchronized (Relay.this) {
-      complete = true;
-    }
-
-    closeQuietly(upstream);
-    upstream = null;
-  }
-
-  boolean isClosed() {
-    return file == null;
-  }
-
-  public ByteString metadata() {
-    return metadata;
-  }
-
-  /**
-   * Returns a new source that returns the same bytes as upstream. Returns null if this relay has
-   * been closed and no further sources are possible. In that case callers should retry after
-   * building a new relay with {@link #read}.
-   */
-  public Source newSource() {
-    synchronized (Relay.this) {
-      if (file == null) return null;
-      sourceCount++;
-    }
-
-    return new RelaySource();
-  }
-
-  class RelaySource implements Source {
-    private final Timeout timeout = new Timeout();
-
-    /** The operator to read and write the shared file. Null if this source is closed. */
-    private FileOperator fileOperator = new FileOperator(file.getChannel());
-
-    /** The next byte to read. This is always less than or equal to {@code upstreamPos}. */
-    private long sourcePos;
-
-    /**
-     * Selects where to find the bytes for a read and read them. This is one of three sources.
-     *
-     * <h3>Upstream:</h3>
-     * In this case the current thread is assigned as the upstream reader. We read bytes from
-     * upstream and copy them to both the file and to the buffer. Finally we release the upstream
-     * reader lock and return the new bytes.
-     *
-     * <h3>The file</h3>
-     * In this case we copy bytes from the file to the {@code sink}.
-     *
-     * <h3>The buffer</h3>
-     * In this case the bytes are immediately copied into {@code sink} and the number of bytes
-     * copied is returned.
-     *
-     * <p>If upstream would be selected but another thread is already reading upstream this will
-     * block until that read completes. It is possible to time out while waiting for that.
-     */
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (fileOperator == null) throw new IllegalStateException("closed");
-
-      long upstreamPos;
-      int source;
-
-      selectSource:
-      synchronized (Relay.this) {
-        // We need new data from upstream.
-        while (sourcePos == (upstreamPos = Relay.this.upstreamPos)) {
-          // No more data upstream. We're done.
-          if (complete) return -1L;
-
-          // Another thread is already reading. Wait for that.
-          if (upstreamReader != null) {
-            timeout.waitUntilNotified(Relay.this);
-            continue;
-          }
-
-          // We will do the read.
-          upstreamReader = Thread.currentThread();
-          source = SOURCE_UPSTREAM;
-          break selectSource;
-        }
-
-        long bufferPos = upstreamPos - buffer.size();
-
-        // Bytes of the read precede the buffer. Read from the file.
-        if (sourcePos < bufferPos) {
-          source = SOURCE_FILE;
-          break selectSource;
-        }
-
-        // The buffer has the data we need. Read from there and return immediately.
-        long bytesToRead = Math.min(byteCount, upstreamPos - sourcePos);
-        buffer.copyTo(sink, sourcePos - bufferPos, bytesToRead);
-        sourcePos += bytesToRead;
-        return bytesToRead;
-      }
-
-      // Read from the file.
-      if (source == SOURCE_FILE) {
-        long bytesToRead = Math.min(byteCount, upstreamPos - sourcePos);
-        fileOperator.read(FILE_HEADER_SIZE + sourcePos, sink, bytesToRead);
-        sourcePos += bytesToRead;
-        return bytesToRead;
-      }
-
-      // Read from upstream. This always reads a full buffer: that might be more than what the
-      // current call to Source.read() has requested.
-      try {
-        long upstreamBytesRead = upstream.read(upstreamBuffer, bufferMaxSize);
-
-        // If we've exhausted upstream, we're done.
-        if (upstreamBytesRead == -1L) {
-          commit(upstreamPos);
-          return -1L;
-        }
-
-        // Update this source and prepare this call's result.
-        long bytesRead = Math.min(upstreamBytesRead, byteCount);
-        upstreamBuffer.copyTo(sink, 0, bytesRead);
-        sourcePos += bytesRead;
-
-        // Append the upstream bytes to the file.
-        fileOperator.write(
-            FILE_HEADER_SIZE + upstreamPos, upstreamBuffer.clone(), upstreamBytesRead);
-
-        synchronized (Relay.this) {
-          // Append new upstream bytes into the buffer. Trim it to its max size.
-          buffer.write(upstreamBuffer, upstreamBytesRead);
-          if (buffer.size() > bufferMaxSize) {
-            buffer.skip(buffer.size() - bufferMaxSize);
-          }
-
-          // Now that the file and buffer have bytes, adjust upstreamPos.
-          Relay.this.upstreamPos += upstreamBytesRead;
-        }
-
-        return bytesRead;
-      } finally {
-        synchronized (Relay.this) {
-          upstreamReader = null;
-          Relay.this.notifyAll();
-        }
-      }
-    }
-
-    @Override public Timeout timeout() {
-      return timeout;
-    }
-
-    @Override public void close() throws IOException {
-      if (fileOperator == null) return; // Already closed.
-      fileOperator = null;
-
-      RandomAccessFile fileToClose = null;
-      synchronized (Relay.this) {
-        sourceCount--;
-        if (sourceCount == 0) {
-          fileToClose = file;
-          file = null;
-        }
-      }
-
-      if (fileToClose != null) {
-        closeQuietly(fileToClose);
-      }
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/Relay.kt b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.kt
new file mode 100644
index 0000000000..f51820f355
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.kt
@@ -0,0 +1,355 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache2
+
+import okhttp3.internal.closeQuietly
+import okhttp3.internal.notifyAll
+import okio.Buffer
+import okio.ByteString
+import okio.ByteString.Companion.encodeUtf8
+import okio.Source
+import okio.Timeout
+import java.io.File
+import java.io.IOException
+import java.io.RandomAccessFile
+
+/**
+ * Replicates a single upstream source into multiple downstream sources. Each downstream source
+ * returns the same bytes as the upstream source. Downstream sources may read data either as it
+ * is returned by upstream, or after the upstream source has been exhausted.
+ *
+ * As bytes are returned from upstream they are written to a local file. Downstream sources read
+ * from this file as necessary.
+ *
+ * This class also keeps a small buffer of bytes recently read from upstream. This is intended to
+ * save a small amount of file I/O and data copying.
+ */
+class Relay private constructor(
+  /**
+   * Read/write persistence of the upstream source and its metadata. Its layout is as follows:
+   *
+   *  * 16 bytes: either `OkHttp cache v1\n` if the persisted file is complete. This is another
+   *    sequence of bytes if the file is incomplete and should not be used.
+   *  * 8 bytes: *n*: upstream data size
+   *  * 8 bytes: *m*: metadata size
+   *  * *n* bytes: upstream data
+   *  * *m* bytes: metadata
+   *
+   * This is closed and assigned to null when the last source is closed and no further sources
+   * are permitted.
+   */
+  var file: RandomAccessFile?,
+
+  /**
+   * Null once the file has a complete copy of the upstream bytes. Only the [upstreamReader] thread
+   * may access this source.
+   */
+  var upstream: Source?,
+
+  /** The number of bytes consumed from [upstream]. Guarded by this. */
+  var upstreamPos: Long,
+
+  /** User-supplied additional data persisted with the source data. */
+  private val metadata: ByteString,
+
+  /** The maximum size of [buffer]. */
+  val bufferMaxSize: Long
+) {
+  /** The thread that currently has access to upstream. Possibly null. Guarded by this. */
+  var upstreamReader: Thread? = null
+
+  /**
+   * A buffer for [upstreamReader] to use when pulling bytes from upstream. Only the
+   * [upstreamReader] thread may access this buffer.
+   */
+  val upstreamBuffer = Buffer()
+
+  /** True if there are no further bytes to read from [upstream]. Guarded by this. */
+  var complete = (upstream == null)
+
+  /** The most recently read bytes from [upstream]. This is a suffix of [file]. Guarded by this. */
+  val buffer = Buffer()
+
+  /**
+   * Reference count of the number of active sources reading this stream. When decremented to 0
+   * resources are released and all following calls to [.newSource] return null. Guarded by this.
+   */
+  var sourceCount = 0
+
+  val isClosed: Boolean
+    get() = file == null
+
+  @Throws(IOException::class)
+  private fun writeHeader(
+    prefix: ByteString,
+    upstreamSize: Long,
+    metadataSize: Long
+  ) {
+    val header = Buffer().apply {
+      write(prefix)
+      writeLong(upstreamSize)
+      writeLong(metadataSize)
+      require(size == FILE_HEADER_SIZE)
+    }
+
+    val fileOperator = FileOperator(file!!.channel)
+    fileOperator.write(0, header, FILE_HEADER_SIZE)
+  }
+
+  @Throws(IOException::class)
+  private fun writeMetadata(upstreamSize: Long) {
+    val metadataBuffer = Buffer()
+    metadataBuffer.write(metadata)
+
+    val fileOperator = FileOperator(file!!.channel)
+    fileOperator.write(FILE_HEADER_SIZE + upstreamSize, metadataBuffer, metadata.size.toLong())
+  }
+
+  @Throws(IOException::class)
+  fun commit(upstreamSize: Long) {
+    // Write metadata to the end of the file.
+    writeMetadata(upstreamSize)
+    file!!.channel.force(false)
+
+    // Once everything else is in place we can swap the dirty header for a clean one.
+    writeHeader(PREFIX_CLEAN, upstreamSize, metadata.size.toLong())
+    file!!.channel.force(false)
+
+    // This file is complete.
+    synchronized(this@Relay) {
+      complete = true
+    }
+
+    upstream?.closeQuietly()
+    upstream = null
+  }
+
+  fun metadata(): ByteString = metadata
+
+  /**
+   * Returns a new source that returns the same bytes as upstream. Returns null if this relay has
+   * been closed and no further sources are possible. In that case callers should retry after
+   * building a new relay with [.read].
+   */
+  fun newSource(): Source? {
+    synchronized(this@Relay) {
+      if (file == null) return null
+      sourceCount++
+    }
+
+    return RelaySource()
+  }
+
+  internal inner class RelaySource : Source {
+    private val timeout = Timeout()
+
+    /** The operator to read and write the shared file. Null if this source is closed. */
+    private var fileOperator: FileOperator? = FileOperator(file!!.channel)
+
+    /** The next byte to read. This is always less than or equal to [upstreamPos]. */
+    private var sourcePos = 0L
+
+    /**
+     * Selects where to find the bytes for a read and read them. This is one of three sources.
+     *
+     * ## Upstream
+     *
+     * In this case the current thread is assigned as the upstream reader. We read bytes from
+     * upstream and copy them to both the file and to the buffer. Finally we release the upstream
+     * reader lock and return the new bytes.
+     *
+     * ## The file
+     *
+     * In this case we copy bytes from the file to the [sink].
+     *
+     * ## The buffer
+     *
+     * In this case the bytes are immediately copied into [sink] and the number of bytes copied is
+     * returned.
+     *
+     * If upstream would be selected but another thread is already reading upstream this will
+     * block until that read completes. It is possible to time out while waiting for that.
+     */
+    @Throws(IOException::class)
+    override fun read(sink: Buffer, byteCount: Long): Long {
+      check(fileOperator != null)
+
+      val source: Int = synchronized(this@Relay) {
+        // We need new data from upstream.
+        while (true) {
+          val upstreamPos = this@Relay.upstreamPos
+          if (sourcePos != upstreamPos) break
+
+          // No more data upstream. We're done.
+          if (complete) return -1L
+
+          // Another thread is already reading. Wait for that.
+          if (upstreamReader != null) {
+            timeout.waitUntilNotified(this@Relay)
+            continue
+          }
+
+          // We will do the read.
+          upstreamReader = Thread.currentThread()
+          return@synchronized SOURCE_UPSTREAM
+        }
+
+        val bufferPos = upstreamPos - buffer.size
+
+        // Bytes of the read precede the buffer. Read from the file.
+        if (sourcePos < bufferPos) {
+          return@synchronized SOURCE_FILE
+        }
+
+        // The buffer has the data we need. Read from there and return immediately.
+        val bytesToRead = minOf(byteCount, upstreamPos - sourcePos)
+        buffer.copyTo(sink, sourcePos - bufferPos, bytesToRead)
+        sourcePos += bytesToRead
+        return bytesToRead
+      }
+
+      // Read from the file.
+      if (source == SOURCE_FILE) {
+        val bytesToRead = minOf(byteCount, upstreamPos - sourcePos)
+        fileOperator!!.read(FILE_HEADER_SIZE + sourcePos, sink, bytesToRead)
+        sourcePos += bytesToRead
+        return bytesToRead
+      }
+
+      // Read from upstream. This always reads a full buffer: that might be more than what the
+      // current call to Source.read() has requested.
+      try {
+        val upstreamBytesRead = upstream!!.read(upstreamBuffer, bufferMaxSize)
+
+        // If we've exhausted upstream, we're done.
+        if (upstreamBytesRead == -1L) {
+          commit(upstreamPos)
+          return -1L
+        }
+
+        // Update this source and prepare this call's result.
+        val bytesRead = minOf(upstreamBytesRead, byteCount)
+        upstreamBuffer.copyTo(sink, 0, bytesRead)
+        sourcePos += bytesRead
+
+        // Append the upstream bytes to the file.
+        fileOperator!!.write(
+            FILE_HEADER_SIZE + upstreamPos, upstreamBuffer.clone(), upstreamBytesRead)
+
+        synchronized(this@Relay) {
+          // Append new upstream bytes into the buffer. Trim it to its max size.
+          buffer.write(upstreamBuffer, upstreamBytesRead)
+          if (buffer.size > bufferMaxSize) {
+            buffer.skip(buffer.size - bufferMaxSize)
+          }
+
+          // Now that the file and buffer have bytes, adjust upstreamPos.
+          this@Relay.upstreamPos += upstreamBytesRead
+        }
+
+        return bytesRead
+      } finally {
+        synchronized(this@Relay) {
+          upstreamReader = null
+          this@Relay.notifyAll()
+        }
+      }
+    }
+
+    override fun timeout(): Timeout = timeout
+
+    @Throws(IOException::class)
+    override fun close() {
+      if (fileOperator == null) return // Already closed.
+      fileOperator = null
+
+      var fileToClose: RandomAccessFile? = null
+      synchronized(this@Relay) {
+        sourceCount--
+        if (sourceCount == 0) {
+          fileToClose = file
+          file = null
+        }
+      }
+
+      fileToClose?.closeQuietly()
+    }
+  }
+
+  companion object {
+    // TODO(jwilson): what to do about timeouts? They could be different and unfortunately when any
+    //     timeout is hit we like to tear down the whole stream.
+
+    private const val SOURCE_UPSTREAM = 1
+    private const val SOURCE_FILE = 2
+
+    @JvmField val PREFIX_CLEAN = "OkHttp cache v1\n".encodeUtf8()
+    @JvmField val PREFIX_DIRTY = "OkHttp DIRTY :(\n".encodeUtf8()
+    private const val FILE_HEADER_SIZE = 32L
+
+    /**
+     * Creates a new relay that reads a live stream from [upstream], using [file] to share that data
+     * with other sources.
+     *
+     * **Warning:** callers to this method must immediately call [newSource] to create a source and
+     * close that when they're done. Otherwise a handle to [file] will be leaked.
+     */
+    @Throws(IOException::class)
+    fun edit(
+      file: File,
+      upstream: Source,
+      metadata: ByteString,
+      bufferMaxSize: Long
+    ): Relay {
+      val randomAccessFile = RandomAccessFile(file, "rw")
+      val result = Relay(randomAccessFile, upstream, 0L, metadata, bufferMaxSize)
+
+      // Write a dirty header. That way if we crash we won't attempt to recover this.
+      randomAccessFile.setLength(0L)
+      result.writeHeader(PREFIX_DIRTY, -1L, -1L)
+
+      return result
+    }
+
+    /**
+     * Creates a relay that reads a recorded stream from [file].
+     *
+     * **Warning:** callers to this method must immediately call [newSource] to create a source and
+     * close that when they're done. Otherwise a handle to [file] will be leaked.
+     */
+    @Throws(IOException::class)
+    fun read(file: File): Relay {
+      val randomAccessFile = RandomAccessFile(file, "rw")
+      val fileOperator = FileOperator(randomAccessFile.channel)
+
+      // Read the header.
+      val header = Buffer()
+      fileOperator.read(0, header, FILE_HEADER_SIZE)
+      val prefix = header.readByteString(PREFIX_CLEAN.size.toLong())
+      if (prefix != PREFIX_CLEAN) throw IOException("unreadable cache file")
+      val upstreamSize = header.readLong()
+      val metadataSize = header.readLong()
+
+      // Read the metadata.
+      val metadataBuffer = Buffer()
+      fileOperator.read(FILE_HEADER_SIZE + upstreamSize, metadataBuffer, metadataSize)
+      val metadata = metadataBuffer.readByteString()
+
+      // Return the result.
+      return Relay(randomAccessFile, null, upstreamSize, metadata, 0L)
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.kt b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.kt
index 961135c696..51aa298bc5 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.kt
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.kt
@@ -16,14 +16,13 @@
  */
 package okhttp3.internal.connection
 
-import java.io.IOException
 import okhttp3.Interceptor
-import okhttp3.OkHttpClient
 import okhttp3.Response
 import okhttp3.internal.http.RealInterceptorChain
+import java.io.IOException
 
-/** Opens a connection to the target server and proceeds to the next interceptor.  */
-class ConnectInterceptor(val client: OkHttpClient) : Interceptor {
+/** Opens a connection to the target server and proceeds to the next interceptor. */
+object ConnectInterceptor : Interceptor {
 
   @Throws(IOException::class)
   override fun intercept(chain: Interceptor.Chain): Response {
@@ -32,7 +31,7 @@ class ConnectInterceptor(val client: OkHttpClient) : Interceptor {
     val transmitter = realChain.transmitter()
 
     // We need the network to satisfy this request. Possibly for validating a conditional GET.
-    val doExtensiveHealthChecks = request.method() != "GET"
+    val doExtensiveHealthChecks = request.method != "GET"
     val exchange = transmitter.newExchange(chain, doExtensiveHealthChecks)
 
     return realChain.proceed(request, transmitter, exchange)
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/Exchange.java b/okhttp/src/main/java/okhttp3/internal/connection/Exchange.java
deleted file mode 100644
index a5c59fda4a..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/Exchange.java
+++ /dev/null
@@ -1,326 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.net.SocketException;
-import javax.annotation.Nullable;
-import okhttp3.Call;
-import okhttp3.EventListener;
-import okhttp3.Headers;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Internal;
-import okhttp3.internal.http.ExchangeCodec;
-import okhttp3.internal.http.RealResponseBody;
-import okhttp3.internal.ws.RealWebSocket;
-import okio.Buffer;
-import okio.ForwardingSink;
-import okio.ForwardingSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-
-/**
- * Transmits a single HTTP request and a response pair. This layers connection management and events
- * on {@link ExchangeCodec}, which handles the actual I/O.
- */
-public final class Exchange {
-  final Transmitter transmitter;
-  final Call call;
-  final EventListener eventListener;
-  final ExchangeFinder finder;
-  final ExchangeCodec codec;
-  private boolean duplex;
-
-  public Exchange(Transmitter transmitter, Call call, EventListener eventListener,
-      ExchangeFinder finder, ExchangeCodec codec) {
-    this.transmitter = transmitter;
-    this.call = call;
-    this.eventListener = eventListener;
-    this.finder = finder;
-    this.codec = codec;
-  }
-
-  public RealConnection connection() {
-    return codec.connection();
-  }
-
-  /** Returns true if the request body need not complete before the response body starts. */
-  public boolean isDuplex() {
-    return duplex;
-  }
-
-  public void writeRequestHeaders(Request request) throws IOException {
-    try {
-      eventListener.requestHeadersStart(call);
-      codec.writeRequestHeaders(request);
-      eventListener.requestHeadersEnd(call, request);
-    } catch (IOException e) {
-      eventListener.requestFailed(call, e);
-      trackFailure(e);
-      throw e;
-    }
-  }
-
-  public Sink createRequestBody(Request request, boolean duplex) throws IOException {
-    this.duplex = duplex;
-    long contentLength = request.body().contentLength();
-    eventListener.requestBodyStart(call);
-    Sink rawRequestBody = codec.createRequestBody(request, contentLength);
-    return new RequestBodySink(rawRequestBody, contentLength);
-  }
-
-  public void flushRequest() throws IOException {
-    try {
-      codec.flushRequest();
-    } catch (IOException e) {
-      eventListener.requestFailed(call, e);
-      trackFailure(e);
-      throw e;
-    }
-  }
-
-  public void finishRequest() throws IOException {
-    try {
-      codec.finishRequest();
-    } catch (IOException e) {
-      eventListener.requestFailed(call, e);
-      trackFailure(e);
-      throw e;
-    }
-  }
-
-  public void responseHeadersStart() {
-    eventListener.responseHeadersStart(call);
-  }
-
-  public @Nullable Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
-    try {
-      Response.Builder result = codec.readResponseHeaders(expectContinue);
-      if (result != null) {
-        Internal.instance.initExchange(result, this);
-      }
-      return result;
-    } catch (IOException e) {
-      eventListener.responseFailed(call, e);
-      trackFailure(e);
-      throw e;
-    }
-  }
-
-  public void responseHeadersEnd(Response response) {
-    eventListener.responseHeadersEnd(call, response);
-  }
-
-  public ResponseBody openResponseBody(Response response) throws IOException {
-    try {
-      eventListener.responseBodyStart(call);
-      String contentType = response.header("Content-Type");
-      long contentLength = codec.reportedContentLength(response);
-      Source rawSource = codec.openResponseBodySource(response);
-      ResponseBodySource source = new ResponseBodySource(rawSource, contentLength);
-      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
-    } catch (IOException e) {
-      eventListener.responseFailed(call, e);
-      trackFailure(e);
-      throw e;
-    }
-  }
-
-  public Headers trailers() throws IOException {
-    return codec.trailers();
-  }
-
-  public void timeoutEarlyExit() {
-    transmitter.timeoutEarlyExit();
-  }
-
-  public RealWebSocket.Streams newWebSocketStreams() throws SocketException {
-    transmitter.timeoutEarlyExit();
-    return codec.connection().newWebSocketStreams(this);
-  }
-
-  public void webSocketUpgradeFailed() {
-    bodyComplete(-1L, true, true, null);
-  }
-
-  public void noNewExchangesOnConnection() {
-    codec.connection().noNewExchanges();
-  }
-
-  public void cancel() {
-    codec.cancel();
-  }
-
-  /**
-   * Revoke this exchange's access to streams. This is necessary when a follow-up request is
-   * required but the preceding exchange hasn't completed yet.
-   */
-  public void detachWithViolence() {
-    codec.cancel();
-    transmitter.exchangeMessageDone(this, true, true, null);
-  }
-
-  void trackFailure(IOException e) {
-    finder.trackFailure();
-    codec.connection().trackFailure(e);
-  }
-
-  @Nullable IOException bodyComplete(
-      long bytesRead, boolean responseDone, boolean requestDone, @Nullable IOException e) {
-    if (e != null) {
-      trackFailure(e);
-    }
-    if (requestDone) {
-      if (e != null) {
-        eventListener.requestFailed(call, e);
-      } else {
-        eventListener.requestBodyEnd(call, bytesRead);
-      }
-    }
-    if (responseDone) {
-      if (e != null) {
-        eventListener.responseFailed(call, e);
-      } else {
-        eventListener.responseBodyEnd(call, bytesRead);
-      }
-    }
-    return transmitter.exchangeMessageDone(this, requestDone, responseDone, e);
-  }
-
-  public void noRequestBody() {
-    transmitter.exchangeMessageDone(this, true, false, null);
-  }
-
-  /** A request body that fires events when it completes. */
-  private final class RequestBodySink extends ForwardingSink {
-    private boolean completed;
-    /** The exact number of bytes to be written, or -1L if that is unknown. */
-    private long contentLength;
-    private long bytesReceived;
-    private boolean closed;
-
-    RequestBodySink(Sink delegate, long contentLength) {
-      super(delegate);
-      this.contentLength = contentLength;
-    }
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException("closed");
-      if (contentLength != -1L && bytesReceived + byteCount > contentLength) {
-        throw new ProtocolException("expected " + contentLength
-            + " bytes but received " + (bytesReceived + byteCount));
-      }
-      try {
-        super.write(source, byteCount);
-        this.bytesReceived += byteCount;
-      } catch (IOException e) {
-        throw complete(e);
-      }
-    }
-
-    @Override public void flush() throws IOException {
-      try {
-        super.flush();
-      } catch (IOException e) {
-        throw complete(e);
-      }
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      if (contentLength != -1L && bytesReceived != contentLength) {
-        throw new ProtocolException("unexpected end of stream");
-      }
-      try {
-        super.close();
-        complete(null);
-      } catch (IOException e) {
-        throw complete(e);
-      }
-    }
-
-    private @Nullable IOException complete(@Nullable IOException e) {
-      if (completed) return e;
-      completed = true;
-      return bodyComplete(bytesReceived, false, true, e);
-    }
-  }
-
-  /** A response body that fires events when it completes. */
-  final class ResponseBodySource extends ForwardingSource {
-    private final long contentLength;
-    private long bytesReceived;
-    private boolean completed;
-    private boolean closed;
-
-    ResponseBodySource(Source delegate, long contentLength) {
-      super(delegate);
-      this.contentLength = contentLength;
-
-      if (contentLength == 0L) {
-        complete(null);
-      }
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException("closed");
-      try {
-        long read = delegate().read(sink, byteCount);
-        if (read == -1L) {
-          complete(null);
-          return -1L;
-        }
-
-        long newBytesReceived = bytesReceived + read;
-        if (contentLength != -1L && newBytesReceived > contentLength) {
-          throw new ProtocolException("expected " + contentLength
-              + " bytes but received " + newBytesReceived);
-        }
-
-        bytesReceived = newBytesReceived;
-        if (newBytesReceived == contentLength) {
-          complete(null);
-        }
-
-        return read;
-      } catch (IOException e) {
-        throw complete(e);
-      }
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      try {
-        super.close();
-        complete(null);
-      } catch (IOException e) {
-        throw complete(e);
-      }
-    }
-
-    @Nullable IOException complete(@Nullable IOException e) {
-      if (completed) return e;
-      completed = true;
-      return bodyComplete(bytesReceived, true, false, e);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/Exchange.kt b/okhttp/src/main/java/okhttp3/internal/connection/Exchange.kt
new file mode 100644
index 0000000000..740f6f998c
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/Exchange.kt
@@ -0,0 +1,323 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection
+
+import okhttp3.Call
+import okhttp3.EventListener
+import okhttp3.Headers
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.ResponseBody
+import okhttp3.internal.http.ExchangeCodec
+import okhttp3.internal.http.RealResponseBody
+import okhttp3.internal.ws.RealWebSocket
+import okio.Buffer
+import okio.ForwardingSink
+import okio.ForwardingSource
+import okio.Sink
+import okio.Source
+import okio.buffer
+import java.io.IOException
+import java.net.ProtocolException
+import java.net.SocketException
+
+/**
+ * Transmits a single HTTP request and a response pair. This layers connection management and events
+ * on [ExchangeCodec], which handles the actual I/O.
+ */
+class Exchange(
+  internal val transmitter: Transmitter,
+  internal val call: Call,
+  internal val eventListener: EventListener,
+  private val finder: ExchangeFinder,
+  private val codec: ExchangeCodec
+) {
+  /** Returns true if the request body need not complete before the response body starts. */
+  var isDuplex: Boolean = false
+    private set
+
+  fun connection(): RealConnection? = codec.connection()
+
+  @Throws(IOException::class)
+  fun writeRequestHeaders(request: Request) {
+    try {
+      eventListener.requestHeadersStart(call)
+      codec.writeRequestHeaders(request)
+      eventListener.requestHeadersEnd(call, request)
+    } catch (e: IOException) {
+      eventListener.requestFailed(call, e)
+      trackFailure(e)
+      throw e
+    }
+  }
+
+  @Throws(IOException::class)
+  fun createRequestBody(request: Request, duplex: Boolean): Sink {
+    this.isDuplex = duplex
+    val contentLength = request.body!!.contentLength()
+    eventListener.requestBodyStart(call)
+    val rawRequestBody = codec.createRequestBody(request, contentLength)
+    return RequestBodySink(rawRequestBody, contentLength)
+  }
+
+  @Throws(IOException::class)
+  fun flushRequest() {
+    try {
+      codec.flushRequest()
+    } catch (e: IOException) {
+      eventListener.requestFailed(call, e)
+      trackFailure(e)
+      throw e
+    }
+  }
+
+  @Throws(IOException::class)
+  fun finishRequest() {
+    try {
+      codec.finishRequest()
+    } catch (e: IOException) {
+      eventListener.requestFailed(call, e)
+      trackFailure(e)
+      throw e
+    }
+  }
+
+  fun responseHeadersStart() {
+    eventListener.responseHeadersStart(call)
+  }
+
+  @Throws(IOException::class)
+  fun readResponseHeaders(expectContinue: Boolean): Response.Builder? {
+    try {
+      val result = codec.readResponseHeaders(expectContinue)
+      result?.initExchange(this)
+      return result
+    } catch (e: IOException) {
+      eventListener.responseFailed(call, e)
+      trackFailure(e)
+      throw e
+    }
+  }
+
+  fun responseHeadersEnd(response: Response) {
+    eventListener.responseHeadersEnd(call, response)
+  }
+
+  @Throws(IOException::class)
+  fun openResponseBody(response: Response): ResponseBody {
+    try {
+      eventListener.responseBodyStart(call)
+      val contentType = response.header("Content-Type")
+      val contentLength = codec.reportedContentLength(response)
+      val rawSource = codec.openResponseBodySource(response)
+      val source = ResponseBodySource(rawSource, contentLength)
+      return RealResponseBody(contentType, contentLength, source.buffer())
+    } catch (e: IOException) {
+      eventListener.responseFailed(call, e)
+      trackFailure(e)
+      throw e
+    }
+  }
+
+  @Throws(IOException::class)
+  fun trailers(): Headers = codec.trailers()
+
+  fun timeoutEarlyExit() {
+    transmitter.timeoutEarlyExit()
+  }
+
+  @Throws(SocketException::class)
+  fun newWebSocketStreams(): RealWebSocket.Streams {
+    transmitter.timeoutEarlyExit()
+    return codec.connection()!!.newWebSocketStreams(this)
+  }
+
+  fun webSocketUpgradeFailed() {
+    bodyComplete(-1L, true, true, null)
+  }
+
+  fun noNewExchangesOnConnection() {
+    codec.connection()!!.noNewExchanges()
+  }
+
+  fun cancel() {
+    codec.cancel()
+  }
+
+  /**
+   * Revoke this exchange's access to streams. This is necessary when a follow-up request is
+   * required but the preceding exchange hasn't completed yet.
+   */
+  fun detachWithViolence() {
+    codec.cancel()
+    transmitter.exchangeMessageDone(this, true, true, null)
+  }
+
+  private fun trackFailure(e: IOException) {
+    finder.trackFailure()
+    codec.connection()!!.trackFailure(e)
+  }
+
+  fun <E : IOException?> bodyComplete(
+    bytesRead: Long,
+    responseDone: Boolean,
+    requestDone: Boolean,
+    e: E
+  ): E {
+    if (e != null) {
+      trackFailure(e)
+    }
+    if (requestDone) {
+      if (e != null) {
+        eventListener.requestFailed(call, e)
+      } else {
+        eventListener.requestBodyEnd(call, bytesRead)
+      }
+    }
+    if (responseDone) {
+      if (e != null) {
+        eventListener.responseFailed(call, e)
+      } else {
+        eventListener.responseBodyEnd(call, bytesRead)
+      }
+    }
+    return transmitter.exchangeMessageDone(this, requestDone, responseDone, e)
+  }
+
+  fun noRequestBody() {
+    transmitter.exchangeMessageDone(this, true, false, null)
+  }
+
+  /** A request body that fires events when it completes. */
+  private inner class RequestBodySink internal constructor(
+    delegate: Sink,
+    /** The exact number of bytes to be written, or -1L if that is unknown. */
+    private val contentLength: Long
+  ) : ForwardingSink(delegate) {
+    private var completed = false
+    private var bytesReceived = 0L
+    private var closed = false
+
+    @Throws(IOException::class)
+    override fun write(source: Buffer, byteCount: Long) {
+      check(!closed) { "closed" }
+      if (contentLength != -1L && bytesReceived + byteCount > contentLength) {
+        throw ProtocolException(
+            "expected $contentLength bytes but received ${bytesReceived + byteCount}")
+      }
+      try {
+        super.write(source, byteCount)
+        this.bytesReceived += byteCount
+      } catch (e: IOException) {
+        throw complete(e)
+      }
+    }
+
+    @Throws(IOException::class)
+    override fun flush() {
+      try {
+        super.flush()
+      } catch (e: IOException) {
+        throw complete(e)
+      }
+    }
+
+    @Throws(IOException::class)
+    override fun close() {
+      if (closed) return
+      closed = true
+      if (contentLength != -1L && bytesReceived != contentLength) {
+        throw ProtocolException("unexpected end of stream")
+      }
+      try {
+        super.close()
+        complete(null)
+      } catch (e: IOException) {
+        throw complete(e)
+      }
+    }
+
+    private fun <E : IOException?> complete(e: E): E {
+      if (completed) return e
+      completed = true
+      return bodyComplete(bytesReceived, false, true, e)
+    }
+  }
+
+  /** A response body that fires events when it completes. */
+  internal inner class ResponseBodySource(
+    delegate: Source,
+    private val contentLength: Long
+  ) : ForwardingSource(delegate) {
+    private var bytesReceived = 0L
+    private var completed = false
+    private var closed = false
+
+    init {
+      if (contentLength == 0L) {
+        complete(null)
+      }
+    }
+
+    @Throws(IOException::class)
+    override fun read(sink: Buffer, byteCount: Long): Long {
+      check(!closed) { "closed" }
+      try {
+        val read = delegate.read(sink, byteCount)
+        if (read == -1L) {
+          complete(null)
+          return -1L
+        }
+
+        val newBytesReceived = bytesReceived + read
+        if (contentLength != -1L && newBytesReceived > contentLength) {
+          throw ProtocolException("expected $contentLength bytes but received $newBytesReceived")
+        }
+
+        bytesReceived = newBytesReceived
+        if (newBytesReceived == contentLength) {
+          complete(null)
+        }
+
+        return read
+      } catch (e: IOException) {
+        throw complete(e)
+      }
+    }
+
+    @Throws(IOException::class)
+    override fun close() {
+      if (closed) return
+      closed = true
+      try {
+        super.close()
+        complete(null)
+      } catch (e: IOException) {
+        throw complete(e)
+      }
+    }
+
+    fun <E : IOException?> complete(e: E): E {
+      if (completed) return e
+      completed = true
+      return bodyComplete(bytesReceived, true, false, e)
+    }
+  }
+
+  companion object {
+    fun get(response: Response): Exchange? = response.exchange
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.java b/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.java
deleted file mode 100644
index 39b11fa307..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.java
+++ /dev/null
@@ -1,287 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.net.Socket;
-import java.util.List;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.EventListener;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Route;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.ExchangeCodec;
-
-import static okhttp3.internal.Util.closeQuietly;
-
-/**
- * Attempts to find the connections for a sequence of exchanges. This uses the following strategies:
- *
- * <ol>
- *   <li>If the current call already has a connection that can satisfy the request it is used.
- *       Using the same connection for an initial exchange and its follow-ups may improve locality.
- *
- *   <li>If there is a connection in the pool that can satisfy the request it is used. Note that
- *       it is possible for shared exchanges to make requests to different host names! See {@link
- *       RealConnection#isEligible} for details.
- *
- *   <li>If there's no existing connection, make a list of routes (which may require blocking DNS
- *       lookups) and attempt a new connection them. When failures occur, retries iterate the list
- *       of available routes.
- * </ol>
- *
- * <p>If the pool gains an eligible connection while DNS, TCP, or TLS work is in flight, this finder
- * will prefer pooled connections. Only pooled HTTP/2 connections are used for such de-duplication.
- *
- * <p>It is possible to cancel the finding process.
- */
-final class ExchangeFinder {
-  private final Transmitter transmitter;
-  private final Address address;
-  private final RealConnectionPool connectionPool;
-  private final Call call;
-  private final EventListener eventListener;
-
-  private RouteSelector.Selection routeSelection;
-
-  // State guarded by connectionPool.
-  private final RouteSelector routeSelector;
-  private RealConnection connectingConnection;
-  private boolean hasStreamFailure;
-
-  ExchangeFinder(Transmitter transmitter, RealConnectionPool connectionPool,
-      Address address, Call call, EventListener eventListener) {
-    this.transmitter = transmitter;
-    this.connectionPool = connectionPool;
-    this.address = address;
-    this.call = call;
-    this.eventListener = eventListener;
-    this.routeSelector = new RouteSelector(
-        address, connectionPool.getRouteDatabase(), call, eventListener);
-  }
-
-  public ExchangeCodec find(
-      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
-    int connectTimeout = chain.connectTimeoutMillis();
-    int readTimeout = chain.readTimeoutMillis();
-    int writeTimeout = chain.writeTimeoutMillis();
-    int pingIntervalMillis = client.pingIntervalMillis();
-    boolean connectionRetryEnabled = client.retryOnConnectionFailure();
-
-    try {
-      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
-          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
-      return resultConnection.newCodec(client, chain);
-    } catch (RouteException e) {
-      trackFailure();
-      throw e;
-    } catch (IOException e) {
-      trackFailure();
-      throw new RouteException(e);
-    }
-  }
-
-  /**
-   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
-   * until a healthy connection is found.
-   */
-  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
-      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
-      boolean doExtensiveHealthChecks) throws IOException {
-    while (true) {
-      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
-          pingIntervalMillis, connectionRetryEnabled);
-
-      // If this is a brand new connection, we can skip the extensive health checks.
-      synchronized (connectionPool) {
-        if (candidate.successCount == 0) {
-          return candidate;
-        }
-      }
-
-      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
-      // isn't, take it out of the pool and start again.
-      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
-        candidate.noNewExchanges();
-        continue;
-      }
-
-      return candidate;
-    }
-  }
-
-  /**
-   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
-   * then the pool, finally building a new connection.
-   */
-  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
-    boolean foundPooledConnection = false;
-    RealConnection result = null;
-    Route selectedRoute = null;
-    RealConnection releasedConnection;
-    Socket toClose;
-    synchronized (connectionPool) {
-      if (transmitter.isCanceled()) throw new IOException("Canceled");
-      hasStreamFailure = false; // This is a fresh attempt.
-
-      Route previousRoute = retryCurrentRoute()
-          ? transmitter.connection.route()
-          : null;
-
-      // Attempt to use an already-allocated connection. We need to be careful here because our
-      // already-allocated connection may have been restricted from creating new exchanges.
-      releasedConnection = transmitter.connection;
-      toClose = transmitter.connection != null && transmitter.connection.noNewExchanges
-          ? transmitter.releaseConnectionNoEvents()
-          : null;
-
-      if (transmitter.connection != null) {
-        // We had an already-allocated connection and it's good.
-        result = transmitter.connection;
-        releasedConnection = null;
-      }
-
-      if (result == null) {
-        // Attempt to get a connection from the pool.
-        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) {
-          foundPooledConnection = true;
-          result = transmitter.connection;
-        } else {
-          selectedRoute = previousRoute;
-        }
-      }
-    }
-    closeQuietly(toClose);
-
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-    if (foundPooledConnection) {
-      eventListener.connectionAcquired(call, result);
-    }
-    if (result != null) {
-      // If we found an already-allocated or pooled connection, we're done.
-      return result;
-    }
-
-    // If we need a route selection, make one. This is a blocking operation.
-    boolean newRouteSelection = false;
-    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
-      newRouteSelection = true;
-      routeSelection = routeSelector.next();
-    }
-
-    List<Route> routes = null;
-    synchronized (connectionPool) {
-      if (transmitter.isCanceled()) throw new IOException("Canceled");
-
-      if (newRouteSelection) {
-        // Now that we have a set of IP addresses, make another attempt at getting a connection from
-        // the pool. This could match due to connection coalescing.
-        routes = routeSelection.getRoutes();
-        if (connectionPool.transmitterAcquirePooledConnection(
-            address, transmitter, routes, false)) {
-          foundPooledConnection = true;
-          result = transmitter.connection;
-        }
-      }
-
-      if (!foundPooledConnection) {
-        if (selectedRoute == null) {
-          selectedRoute = routeSelection.next();
-        }
-
-        // Create a connection and assign it to this allocation immediately. This makes it possible
-        // for an asynchronous cancel() to interrupt the handshake we're about to do.
-        result = new RealConnection(connectionPool, selectedRoute);
-        connectingConnection = result;
-      }
-    }
-
-    // If we found a pooled connection on the 2nd time around, we're done.
-    if (foundPooledConnection) {
-      eventListener.connectionAcquired(call, result);
-      return result;
-    }
-
-    // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
-        connectionRetryEnabled, call, eventListener);
-    connectionPool.getRouteDatabase().connected(result.route());
-
-    Socket socket = null;
-    synchronized (connectionPool) {
-      connectingConnection = null;
-      // Last attempt at connection coalescing, which only occurs if we attempted multiple
-      // concurrent connections to the same host.
-      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) {
-        // We lost the race! Close the connection we created and return the pooled connection.
-        result.noNewExchanges = true;
-        socket = result.socket();
-        result = transmitter.connection;
-      } else {
-        connectionPool.put(result);
-        transmitter.acquireConnectionNoEvents(result);
-      }
-    }
-    closeQuietly(socket);
-
-    eventListener.connectionAcquired(call, result);
-    return result;
-  }
-
-  RealConnection connectingConnection() {
-    assert (Thread.holdsLock(connectionPool));
-    return connectingConnection;
-  }
-
-  void trackFailure() {
-    assert (!Thread.holdsLock(connectionPool));
-    synchronized (connectionPool) {
-      hasStreamFailure = true; // Permit retries.
-    }
-  }
-
-  /** Returns true if there is a failure that retrying might fix. */
-  boolean hasStreamFailure() {
-    synchronized (connectionPool) {
-      return hasStreamFailure;
-    }
-  }
-
-  /** Returns true if a current route is still good or if there are routes we haven't tried yet. */
-  boolean hasRouteToTry() {
-    synchronized (connectionPool) {
-      return retryCurrentRoute()
-          || (routeSelection != null && routeSelection.hasNext())
-          || routeSelector.hasNext();
-    }
-  }
-
-  /**
-   * Return true if the route used for the current connection should be retried, even if the
-   * connection itself is unhealthy. The biggest gotcha here is that we shouldn't reuse routes from
-   * coalesced connections.
-   */
-  private boolean retryCurrentRoute() {
-    return transmitter.connection != null
-        && transmitter.connection.routeFailureCount == 0
-        && Util.sameConnection(transmitter.connection.route().address().url(), address.url());
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.kt b/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.kt
new file mode 100644
index 0000000000..122e8f5c8d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.kt
@@ -0,0 +1,316 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection
+
+import okhttp3.Address
+import okhttp3.Call
+import okhttp3.EventListener
+import okhttp3.Interceptor
+import okhttp3.OkHttpClient
+import okhttp3.Route
+import okhttp3.internal.canReuseConnectionFor
+import okhttp3.internal.closeQuietly
+import okhttp3.internal.http.ExchangeCodec
+import java.io.IOException
+import java.net.Socket
+
+/**
+ * Attempts to find the connections for a sequence of exchanges. This uses the following strategies:
+ *
+ *  1. If the current call already has a connection that can satisfy the request it is used. Using
+ *     the same connection for an initial exchange and its follow-ups may improve locality.
+ *
+ *  2. If there is a connection in the pool that can satisfy the request it is used. Note that it is
+ *     possible for shared exchanges to make requests to different host names! See
+ *     [RealConnection.isEligible] for details.
+ *
+ *  3. If there's no existing connection, make a list of routes (which may require blocking DNS
+ *     lookups) and attempt a new connection them. When failures occur, retries iterate the list of
+ *     available routes.
+ *
+ * If the pool gains an eligible connection while DNS, TCP, or TLS work is in flight, this finder
+ * will prefer pooled connections. Only pooled HTTP/2 connections are used for such de-duplication.
+ *
+ * It is possible to cancel the finding process.
+ */
+class ExchangeFinder(
+  private val transmitter: Transmitter,
+  private val connectionPool: RealConnectionPool,
+  private val address: Address,
+  private val call: Call,
+  private val eventListener: EventListener
+) {
+  private var routeSelection: RouteSelector.Selection? = null
+
+  // State guarded by connectionPool.
+  private val routeSelector: RouteSelector = RouteSelector(
+      address, connectionPool.routeDatabase, call, eventListener)
+  private var connectingConnection: RealConnection? = null
+  private var hasStreamFailure = false
+  private var nextRouteToTry: Route? = null
+
+  fun find(
+    client: OkHttpClient,
+    chain: Interceptor.Chain,
+    doExtensiveHealthChecks: Boolean
+  ): ExchangeCodec {
+    val connectTimeout = chain.connectTimeoutMillis()
+    val readTimeout = chain.readTimeoutMillis()
+    val writeTimeout = chain.writeTimeoutMillis()
+    val pingIntervalMillis = client.pingIntervalMillis
+    val connectionRetryEnabled = client.retryOnConnectionFailure
+
+    try {
+      val resultConnection = findHealthyConnection(
+          connectTimeout = connectTimeout,
+          readTimeout = readTimeout,
+          writeTimeout = writeTimeout,
+          pingIntervalMillis = pingIntervalMillis,
+          connectionRetryEnabled = connectionRetryEnabled,
+          doExtensiveHealthChecks = doExtensiveHealthChecks
+      )
+      return resultConnection.newCodec(client, chain)
+    } catch (e: RouteException) {
+      trackFailure()
+      throw e
+    } catch (e: IOException) {
+      trackFailure()
+      throw RouteException(e)
+    }
+  }
+
+  /**
+   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
+   * until a healthy connection is found.
+   */
+  @Throws(IOException::class)
+  private fun findHealthyConnection(
+    connectTimeout: Int,
+    readTimeout: Int,
+    writeTimeout: Int,
+    pingIntervalMillis: Int,
+    connectionRetryEnabled: Boolean,
+    doExtensiveHealthChecks: Boolean
+  ): RealConnection {
+    while (true) {
+      val candidate = findConnection(
+          connectTimeout = connectTimeout,
+          readTimeout = readTimeout,
+          writeTimeout = writeTimeout,
+          pingIntervalMillis = pingIntervalMillis,
+          connectionRetryEnabled = connectionRetryEnabled
+      )
+
+      // If this is a brand new connection, we can skip the extensive health checks.
+      synchronized(connectionPool) {
+        if (candidate.successCount == 0) {
+          return candidate
+        }
+      }
+
+      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
+      // isn't, take it out of the pool and start again.
+      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
+        candidate.noNewExchanges()
+        continue
+      }
+
+      return candidate
+    }
+  }
+
+  /**
+   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
+   * then the pool, finally building a new connection.
+   */
+  @Throws(IOException::class)
+  private fun findConnection(
+    connectTimeout: Int,
+    readTimeout: Int,
+    writeTimeout: Int,
+    pingIntervalMillis: Int,
+    connectionRetryEnabled: Boolean
+  ): RealConnection {
+    var foundPooledConnection = false
+    var result: RealConnection? = null
+    var selectedRoute: Route? = null
+    var releasedConnection: RealConnection?
+    val toClose: Socket?
+    synchronized(connectionPool) {
+      if (transmitter.isCanceled) throw IOException("Canceled")
+      hasStreamFailure = false // This is a fresh attempt.
+
+      releasedConnection = transmitter.connection
+      toClose = if (transmitter.connection != null && transmitter.connection!!.noNewExchanges) {
+        transmitter.releaseConnectionNoEvents()
+      } else {
+        null
+      }
+
+      if (transmitter.connection != null) {
+        // We had an already-allocated connection and it's good.
+        result = transmitter.connection
+        releasedConnection = null
+      }
+
+      if (result == null) {
+        // Attempt to get a connection from the pool.
+        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) {
+          foundPooledConnection = true
+          result = transmitter.connection
+        } else if (nextRouteToTry != null) {
+          selectedRoute = nextRouteToTry
+          nextRouteToTry = null
+        } else if (retryCurrentRoute()) {
+          selectedRoute = transmitter.connection!!.route()
+        }
+      }
+    }
+    toClose?.closeQuietly()
+
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection!!)
+    }
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result!!)
+    }
+    if (result != null) {
+      // If we found an already-allocated or pooled connection, we're done.
+      return result!!
+    }
+
+    // If we need a route selection, make one. This is a blocking operation.
+    var newRouteSelection = false
+    if (selectedRoute == null && (routeSelection == null || !routeSelection!!.hasNext())) {
+      newRouteSelection = true
+      routeSelection = routeSelector.next()
+    }
+
+    var routes: List<Route>? = null
+    synchronized(connectionPool) {
+      if (transmitter.isCanceled) throw IOException("Canceled")
+
+      if (newRouteSelection) {
+        // Now that we have a set of IP addresses, make another attempt at getting a connection from
+        // the pool. This could match due to connection coalescing.
+        routes = routeSelection!!.routes
+        if (connectionPool.transmitterAcquirePooledConnection(
+                address, transmitter, routes, false)) {
+          foundPooledConnection = true
+          result = transmitter.connection
+        }
+      }
+
+      if (!foundPooledConnection) {
+        if (selectedRoute == null) {
+          selectedRoute = routeSelection!!.next()
+        }
+
+        // Create a connection and assign it to this allocation immediately. This makes it possible
+        // for an asynchronous cancel() to interrupt the handshake we're about to do.
+        result = RealConnection(connectionPool, selectedRoute!!)
+        connectingConnection = result
+      }
+    }
+
+    // If we found a pooled connection on the 2nd time around, we're done.
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result!!)
+      return result!!
+    }
+
+    // Do TCP + TLS handshakes. This is a blocking operation.
+    result!!.connect(
+        connectTimeout,
+        readTimeout,
+        writeTimeout,
+        pingIntervalMillis,
+        connectionRetryEnabled,
+        call,
+        eventListener
+    )
+    connectionPool.routeDatabase.connected(result!!.route())
+
+    var socket: Socket? = null
+    synchronized(connectionPool) {
+      connectingConnection = null
+      // Last attempt at connection coalescing, which only occurs if we attempted multiple
+      // concurrent connections to the same host.
+      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) {
+        // We lost the race! Close the connection we created and return the pooled connection.
+        result!!.noNewExchanges = true
+        socket = result!!.socket()
+        result = transmitter.connection
+
+        // It's possible for us to obtain a coalesced connection that is immediately unhealthy. In
+        // that case we will retry the route we just successfully connected with.
+        nextRouteToTry = selectedRoute
+      } else {
+        connectionPool.put(result!!)
+        transmitter.acquireConnectionNoEvents(result!!)
+      }
+    }
+    socket?.closeQuietly()
+
+    eventListener.connectionAcquired(call, result!!)
+    return result!!
+  }
+
+  fun connectingConnection(): RealConnection? {
+    assert(Thread.holdsLock(connectionPool))
+    return connectingConnection
+  }
+
+  fun trackFailure() {
+    assert(!Thread.holdsLock(connectionPool))
+    synchronized(connectionPool) {
+      hasStreamFailure = true // Permit retries.
+    }
+  }
+
+  /** Returns true if there is a failure that retrying might fix. */
+  fun hasStreamFailure(): Boolean {
+    synchronized(connectionPool) {
+      return hasStreamFailure
+    }
+  }
+
+  /** Returns true if a current route is still good or if there are routes we haven't tried yet. */
+  fun hasRouteToTry(): Boolean {
+    synchronized(connectionPool) {
+      if (nextRouteToTry != null) {
+        return true
+      }
+      if (retryCurrentRoute()) {
+        // Lock in the route because retryCurrentRoute() is racy and we don't want to call it twice.
+        nextRouteToTry = transmitter.connection!!.route()
+        return true
+      }
+      return (routeSelection?.hasNext() ?: false) || routeSelector.hasNext()
+    }
+  }
+
+  /**
+   * Return true if the route used for the current connection should be retried, even if the
+   * connection itself is unhealthy. The biggest gotcha here is that we shouldn't reuse routes from
+   * coalesced connections.
+   */
+  private fun retryCurrentRoute(): Boolean {
+    return transmitter.connection != null &&
+        transmitter.connection!!.routeFailureCount == 0 &&
+        transmitter.connection!!.route().address.url.canReuseConnectionFor(address.url)
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
deleted file mode 100644
index f52541fdde..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ /dev/null
@@ -1,685 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.lang.ref.Reference;
-import java.net.ConnectException;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.Socket;
-import java.net.SocketException;
-import java.net.SocketTimeoutException;
-import java.net.UnknownServiceException;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.CertificatePinner;
-import okhttp3.Connection;
-import okhttp3.ConnectionSpec;
-import okhttp3.EventListener;
-import okhttp3.Handshake;
-import okhttp3.HttpUrl;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.Route;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.Version;
-import okhttp3.internal.http.ExchangeCodec;
-import okhttp3.internal.http1.Http1ExchangeCodec;
-import okhttp3.internal.http2.ConnectionShutdownException;
-import okhttp3.internal.http2.ErrorCode;
-import okhttp3.internal.http2.Http2Connection;
-import okhttp3.internal.http2.Http2ExchangeCodec;
-import okhttp3.internal.http2.Http2Stream;
-import okhttp3.internal.http2.StreamResetException;
-import okhttp3.internal.platform.Platform;
-import okhttp3.internal.tls.OkHostnameVerifier;
-import okhttp3.internal.ws.RealWebSocket;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-
-import static java.net.HttpURLConnection.HTTP_OK;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static okhttp3.internal.Util.closeQuietly;
-
-public final class RealConnection extends Http2Connection.Listener implements Connection {
-  private static final String NPE_THROW_WITH_NULL = "throw with null exception";
-  private static final int MAX_TUNNEL_ATTEMPTS = 21;
-
-  public final RealConnectionPool connectionPool;
-  private final Route route;
-
-  // The fields below are initialized by connect() and never reassigned.
-
-  /** The low-level TCP socket. */
-  private Socket rawSocket;
-
-  /**
-   * The application layer socket. Either an {@link SSLSocket} layered over {@link #rawSocket}, or
-   * {@link #rawSocket} itself if this connection does not use SSL.
-   */
-  private Socket socket;
-  private Handshake handshake;
-  private Protocol protocol;
-  private Http2Connection http2Connection;
-  private BufferedSource source;
-  private BufferedSink sink;
-
-  // The fields below track connection state and are guarded by connectionPool.
-
-  /**
-   * If true, no new exchanges can be created on this connection. Once true this is always true.
-   * Guarded by {@link #connectionPool}.
-   */
-  boolean noNewExchanges;
-
-  /**
-   * The number of times there was a problem establishing a stream that could be due to route
-   * chosen. Guarded by {@link #connectionPool}.
-   */
-  int routeFailureCount;
-
-  int successCount;
-  private int refusedStreamCount;
-
-  /**
-   * The maximum number of concurrent streams that can be carried by this connection. If {@code
-   * allocations.size() < allocationLimit} then new streams can be created on this connection.
-   */
-  private int allocationLimit = 1;
-
-  /** Current calls carried by this connection. */
-  final List<Reference<Transmitter>> transmitters = new ArrayList<>();
-
-  /** Nanotime timestamp when {@code allocations.size()} reached zero. */
-  long idleAtNanos = Long.MAX_VALUE;
-
-  public RealConnection(RealConnectionPool connectionPool, Route route) {
-    this.connectionPool = connectionPool;
-    this.route = route;
-  }
-
-  /** Prevent further exchanges from being created on this connection. */
-  public void noNewExchanges() {
-    assert (!Thread.holdsLock(connectionPool));
-    synchronized (connectionPool) {
-      noNewExchanges = true;
-    }
-  }
-
-  static RealConnection testConnection(
-      RealConnectionPool connectionPool, Route route, Socket socket, long idleAtNanos) {
-    RealConnection result = new RealConnection(connectionPool, route);
-    result.socket = socket;
-    result.idleAtNanos = idleAtNanos;
-    return result;
-  }
-
-  public void connect(int connectTimeout, int readTimeout, int writeTimeout,
-      int pingIntervalMillis, boolean connectionRetryEnabled, Call call,
-      EventListener eventListener) {
-    if (protocol != null) throw new IllegalStateException("already connected");
-
-    RouteException routeException = null;
-    List<ConnectionSpec> connectionSpecs = route.address().connectionSpecs();
-    ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);
-
-    if (route.address().sslSocketFactory() == null) {
-      if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {
-        throw new RouteException(new UnknownServiceException(
-            "CLEARTEXT communication not enabled for client"));
-      }
-      String host = route.address().url().host();
-      if (!Platform.get().isCleartextTrafficPermitted(host)) {
-        throw new RouteException(new UnknownServiceException(
-            "CLEARTEXT communication to " + host + " not permitted by network security policy"));
-      }
-    } else {
-      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
-        throw new RouteException(new UnknownServiceException(
-            "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS"));
-      }
-    }
-
-    while (true) {
-      try {
-        if (route.requiresTunnel()) {
-          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);
-          if (rawSocket == null) {
-            // We were unable to connect the tunnel but properly closed down our resources.
-            break;
-          }
-        } else {
-          connectSocket(connectTimeout, readTimeout, call, eventListener);
-        }
-        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);
-        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);
-        break;
-      } catch (IOException e) {
-        closeQuietly(socket);
-        closeQuietly(rawSocket);
-        socket = null;
-        rawSocket = null;
-        source = null;
-        sink = null;
-        handshake = null;
-        protocol = null;
-        http2Connection = null;
-
-        eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);
-
-        if (routeException == null) {
-          routeException = new RouteException(e);
-        } else {
-          routeException.addConnectException(e);
-        }
-
-        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {
-          throw routeException;
-        }
-      }
-    }
-
-    if (route.requiresTunnel() && rawSocket == null) {
-      ProtocolException exception = new ProtocolException("Too many tunnel connections attempted: "
-          + MAX_TUNNEL_ATTEMPTS);
-      throw new RouteException(exception);
-    }
-
-    if (http2Connection != null) {
-      synchronized (connectionPool) {
-        allocationLimit = http2Connection.maxConcurrentStreams();
-      }
-    }
-  }
-
-  /**
-   * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
-   * proxy server can issue an auth challenge and then close the connection.
-   */
-  private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout, Call call,
-      EventListener eventListener) throws IOException {
-    Request tunnelRequest = createTunnelRequest();
-    HttpUrl url = tunnelRequest.url();
-    for (int i = 0; i < MAX_TUNNEL_ATTEMPTS; i++) {
-      connectSocket(connectTimeout, readTimeout, call, eventListener);
-      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
-
-      if (tunnelRequest == null) break; // Tunnel successfully created.
-
-      // The proxy decided to close the connection after an auth challenge. We need to create a new
-      // connection, but this time with the auth credentials.
-      closeQuietly(rawSocket);
-      rawSocket = null;
-      sink = null;
-      source = null;
-      eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null);
-    }
-  }
-
-  /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
-  private void connectSocket(int connectTimeout, int readTimeout, Call call,
-      EventListener eventListener) throws IOException {
-    Proxy proxy = route.proxy();
-    Address address = route.address();
-
-    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP
-        ? address.socketFactory().createSocket()
-        : new Socket(proxy);
-
-    eventListener.connectStart(call, route.socketAddress(), proxy);
-    rawSocket.setSoTimeout(readTimeout);
-    try {
-      Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
-    } catch (ConnectException e) {
-      ConnectException ce = new ConnectException("Failed to connect to " + route.socketAddress());
-      ce.initCause(e);
-      throw ce;
-    }
-
-    // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0
-    // More details:
-    // https://github.com/square/okhttp/issues/3245
-    // https://android-review.googlesource.com/#/c/271775/
-    try {
-      source = Okio.buffer(Okio.source(rawSocket));
-      sink = Okio.buffer(Okio.sink(rawSocket));
-    } catch (NullPointerException npe) {
-      if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) {
-        throw new IOException(npe);
-      }
-    }
-  }
-
-  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector,
-      int pingIntervalMillis, Call call, EventListener eventListener) throws IOException {
-    if (route.address().sslSocketFactory() == null) {
-      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
-        socket = rawSocket;
-        protocol = Protocol.H2_PRIOR_KNOWLEDGE;
-        startHttp2(pingIntervalMillis);
-        return;
-      }
-
-      socket = rawSocket;
-      protocol = Protocol.HTTP_1_1;
-      return;
-    }
-
-    eventListener.secureConnectStart(call);
-    connectTls(connectionSpecSelector);
-    eventListener.secureConnectEnd(call, handshake);
-
-    if (protocol == Protocol.HTTP_2) {
-      startHttp2(pingIntervalMillis);
-    }
-  }
-
-  private void startHttp2(int pingIntervalMillis) throws IOException {
-    socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.
-    http2Connection = new Http2Connection.Builder(true)
-        .socket(socket, route.address().url().host(), source, sink)
-        .listener(this)
-        .pingIntervalMillis(pingIntervalMillis)
-        .build();
-    http2Connection.start();
-  }
-
-  private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException {
-    Address address = route.address();
-    SSLSocketFactory sslSocketFactory = address.sslSocketFactory();
-    boolean success = false;
-    SSLSocket sslSocket = null;
-    try {
-      // Create the wrapper over the connected socket.
-      sslSocket = (SSLSocket) sslSocketFactory.createSocket(
-          rawSocket, address.url().host(), address.url().port(), true /* autoClose */);
-
-      // Configure the socket's ciphers, TLS versions, and extensions.
-      ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);
-      if (connectionSpec.supportsTlsExtensions()) {
-        Platform.get().configureTlsExtensions(
-            sslSocket, address.url().host(), address.protocols());
-      }
-
-      // Force handshake. This can throw!
-      sslSocket.startHandshake();
-      // block for session establishment
-      SSLSession sslSocketSession = sslSocket.getSession();
-      Handshake unverifiedHandshake = Handshake.get(sslSocketSession);
-
-      // Verify that the socket's certificates are acceptable for the target host.
-      if (!address.hostnameVerifier().verify(address.url().host(), sslSocketSession)) {
-        List<Certificate> peerCertificates = unverifiedHandshake.peerCertificates();
-        if (!peerCertificates.isEmpty()) {
-          X509Certificate cert = (X509Certificate) peerCertificates.get(0);
-          throw new SSLPeerUnverifiedException(
-              "Hostname " + address.url().host() + " not verified:"
-                  + "\n    certificate: " + CertificatePinner.pin(cert)
-                  + "\n    DN: " + cert.getSubjectDN().getName()
-                  + "\n    subjectAltNames: "
-                  + OkHostnameVerifier.INSTANCE.allSubjectAltNames(cert));
-        } else {
-          throw new SSLPeerUnverifiedException(
-              "Hostname " + address.url().host() + " not verified (no certificates)");
-        }
-      }
-
-      // Check that the certificate pinner is satisfied by the certificates presented.
-      address.certificatePinner().check(address.url().host(),
-          unverifiedHandshake.peerCertificates());
-
-      // Success! Save the handshake and the ALPN protocol.
-      String maybeProtocol = connectionSpec.supportsTlsExtensions()
-          ? Platform.get().getSelectedProtocol(sslSocket)
-          : null;
-      socket = sslSocket;
-      source = Okio.buffer(Okio.source(socket));
-      sink = Okio.buffer(Okio.sink(socket));
-      handshake = unverifiedHandshake;
-      protocol = maybeProtocol != null
-          ? Protocol.get(maybeProtocol)
-          : Protocol.HTTP_1_1;
-      success = true;
-    } catch (AssertionError e) {
-      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
-      throw e;
-    } finally {
-      if (sslSocket != null) {
-        Platform.get().afterHandshake(sslSocket);
-      }
-      if (!success) {
-        closeQuietly(sslSocket);
-      }
-    }
-  }
-
-  /**
-   * To make an HTTPS connection over an HTTP proxy, send an unencrypted CONNECT request to create
-   * the proxy connection. This may need to be retried if the proxy requires authorization.
-   */
-  private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRequest,
-      HttpUrl url) throws IOException {
-    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
-    String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
-    while (true) {
-      Http1ExchangeCodec tunnelCodec = new Http1ExchangeCodec(null, null, source, sink);
-      source.timeout().timeout(readTimeout, MILLISECONDS);
-      sink.timeout().timeout(writeTimeout, MILLISECONDS);
-      tunnelCodec.writeRequest(tunnelRequest.headers(), requestLine);
-      tunnelCodec.finishRequest();
-      Response response = tunnelCodec.readResponseHeaders(false)
-          .request(tunnelRequest)
-          .build();
-      tunnelCodec.skipConnectBody(response);
-
-      switch (response.code()) {
-        case HTTP_OK:
-          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
-          // that happens, then we will have buffered bytes that are needed by the SSLSocket!
-          // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
-          // that it will almost certainly fail because the proxy has sent unexpected data.
-          if (!source.getBuffer().exhausted() || !sink.buffer().exhausted()) {
-            throw new IOException("TLS tunnel buffered too many bytes!");
-          }
-          return null;
-
-        case HTTP_PROXY_AUTH:
-          tunnelRequest = route.address().proxyAuthenticator().authenticate(route, response);
-          if (tunnelRequest == null) throw new IOException("Failed to authenticate with proxy");
-
-          if ("close".equalsIgnoreCase(response.header("Connection"))) {
-            return tunnelRequest;
-          }
-          break;
-
-        default:
-          throw new IOException(
-              "Unexpected response code for CONNECT: " + response.code());
-      }
-    }
-  }
-
-  /**
-   * Returns a request that creates a TLS tunnel via an HTTP proxy. Everything in the tunnel request
-   * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
-   * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
-   *
-   * <p>In order to support preemptive authentication we pass a fake “Auth Failed” response to the
-   * authenticator. This gives the authenticator the option to customize the CONNECT request. It can
-   * decline to do so by returning null, in which case OkHttp will use it as-is
-   */
-  private Request createTunnelRequest() throws IOException {
-    Request proxyConnectRequest = new Request.Builder()
-        .url(route.address().url())
-        .method("CONNECT", null)
-        .header("Host", Util.hostHeader(route.address().url(), true))
-        .header("Proxy-Connection", "Keep-Alive") // For HTTP/1.0 proxies like Squid.
-        .header("User-Agent", Version.userAgent)
-        .build();
-
-    Response fakeAuthChallengeResponse = new Response.Builder()
-        .request(proxyConnectRequest)
-        .protocol(Protocol.HTTP_1_1)
-        .code(HttpURLConnection.HTTP_PROXY_AUTH)
-        .message("Preemptive Authenticate")
-        .body(Util.EMPTY_RESPONSE)
-        .sentRequestAtMillis(-1L)
-        .receivedResponseAtMillis(-1L)
-        .header("Proxy-Authenticate", "OkHttp-Preemptive")
-        .build();
-
-    Request authenticatedRequest = route.address().proxyAuthenticator()
-        .authenticate(route, fakeAuthChallengeResponse);
-
-    return authenticatedRequest != null
-        ? authenticatedRequest
-        : proxyConnectRequest;
-  }
-
-  /**
-   * Returns true if this connection can carry a stream allocation to {@code address}. If non-null
-   * {@code route} is the resolved route for a connection.
-   */
-  boolean isEligible(Address address, @Nullable List<Route> routes) {
-    // If this connection is not accepting new exchanges, we're done.
-    if (transmitters.size() >= allocationLimit || noNewExchanges) return false;
-
-    // If the non-host fields of the address don't overlap, we're done.
-    if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false;
-
-    // If the host exactly matches, we're done: this connection can carry the address.
-    if (address.url().host().equals(this.route().address().url().host())) {
-      return true; // This connection is a perfect match.
-    }
-
-    // At this point we don't have a hostname match. But we still be able to carry the request if
-    // our connection coalescing requirements are met. See also:
-    // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding
-    // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/
-
-    // 1. This connection must be HTTP/2.
-    if (http2Connection == null) return false;
-
-    // 2. The routes must share an IP address.
-    if (routes == null || !routeMatchesAny(routes)) return false;
-
-    // 3. This connection's server certificate's must cover the new host.
-    if (address.hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;
-    if (!supportsUrl(address.url())) return false;
-
-    // 4. Certificate pinning must match the host.
-    try {
-      address.certificatePinner().check(address.url().host(), handshake().peerCertificates());
-    } catch (SSLPeerUnverifiedException e) {
-      return false;
-    }
-
-    return true; // The caller's address can be carried by this connection.
-  }
-
-  /**
-   * Returns true if this connection's route has the same address as any of {@code routes}. This
-   * requires us to have a DNS address for both hosts, which only happens after route planning. We
-   * can't coalesce connections that use a proxy, since proxies don't tell us the origin server's IP
-   * address.
-   */
-  private boolean routeMatchesAny(List<Route> candidates) {
-    for (int i = 0, size = candidates.size(); i < size; i++) {
-      Route candidate = candidates.get(i);
-      if (candidate.proxy().type() == Proxy.Type.DIRECT
-          && route.proxy().type() == Proxy.Type.DIRECT
-          && route.socketAddress().equals(candidate.socketAddress())) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  public boolean supportsUrl(HttpUrl url) {
-    if (url.port() != route.address().url().port()) {
-      return false; // Port mismatch.
-    }
-
-    if (!url.host().equals(route.address().url().host())) {
-      // We have a host mismatch. But if the certificate matches, we're still good.
-      return handshake != null && OkHostnameVerifier.INSTANCE.verify(
-          url.host(), (X509Certificate) handshake.peerCertificates().get(0));
-    }
-
-    return true; // Success. The URL is supported.
-  }
-
-  ExchangeCodec newCodec(OkHttpClient client, Interceptor.Chain chain) throws SocketException {
-    if (http2Connection != null) {
-      return new Http2ExchangeCodec(client, this, chain, http2Connection);
-    } else {
-      socket.setSoTimeout(chain.readTimeoutMillis());
-      source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);
-      sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);
-      return new Http1ExchangeCodec(client, this, source, sink);
-    }
-  }
-
-  RealWebSocket.Streams newWebSocketStreams(Exchange exchange) throws SocketException {
-    socket.setSoTimeout(0);
-    noNewExchanges();
-    return new RealWebSocket.Streams(true, source, sink) {
-      @Override public void close() throws IOException {
-        exchange.bodyComplete(-1L, true, true, null);
-      }
-    };
-  }
-
-  @Override public Route route() {
-    return route;
-  }
-
-  public void cancel() {
-    // Close the raw socket so we don't end up doing synchronous I/O.
-    closeQuietly(rawSocket);
-  }
-
-  @Override public Socket socket() {
-    return socket;
-  }
-
-  /** Returns true if this connection is ready to host new streams. */
-  public boolean isHealthy(boolean doExtensiveChecks) {
-    if (socket.isClosed() || socket.isInputShutdown() || socket.isOutputShutdown()) {
-      return false;
-    }
-
-    if (http2Connection != null) {
-      return !http2Connection.isShutdown();
-    }
-
-    if (doExtensiveChecks) {
-      try {
-        int readTimeout = socket.getSoTimeout();
-        try {
-          socket.setSoTimeout(1);
-          if (source.exhausted()) {
-            return false; // Stream is exhausted; socket is closed.
-          }
-          return true;
-        } finally {
-          socket.setSoTimeout(readTimeout);
-        }
-      } catch (SocketTimeoutException ignored) {
-        // Read timed out; socket is good.
-      } catch (IOException e) {
-        return false; // Couldn't read; socket is closed.
-      }
-    }
-
-    return true;
-  }
-
-  /** Refuse incoming streams. */
-  @Override public void onStream(Http2Stream stream) throws IOException {
-    stream.close(ErrorCode.REFUSED_STREAM, null);
-  }
-
-  /** When settings are received, adjust the allocation limit. */
-  @Override public void onSettings(Http2Connection connection) {
-    synchronized (connectionPool) {
-      allocationLimit = connection.maxConcurrentStreams();
-    }
-  }
-
-  @Override public Handshake handshake() {
-    return handshake;
-  }
-
-  /**
-   * Returns true if this is an HTTP/2 connection. Such connections can be used in multiple HTTP
-   * requests simultaneously.
-   */
-  public boolean isMultiplexed() {
-    return http2Connection != null;
-  }
-
-  /**
-   * Track a failure using this connection. This may prevent both the connection and its route from
-   * being used for future exchanges.
-   */
-  void trackFailure(@Nullable IOException e) {
-    assert (!Thread.holdsLock(connectionPool));
-    synchronized (connectionPool) {
-      if (e instanceof StreamResetException) {
-        ErrorCode errorCode = ((StreamResetException) e).errorCode;
-        if (errorCode == ErrorCode.REFUSED_STREAM) {
-          // Retry REFUSED_STREAM errors once on the same connection.
-          refusedStreamCount++;
-          if (refusedStreamCount > 1) {
-            noNewExchanges = true;
-            routeFailureCount++;
-          }
-        } else if (errorCode != ErrorCode.CANCEL) {
-          // Keep the connection for CANCEL errors. Everything else wants a fresh connection.
-          noNewExchanges = true;
-          routeFailureCount++;
-        }
-      } else if (!isMultiplexed() || e instanceof ConnectionShutdownException) {
-        noNewExchanges = true;
-
-        // If this route hasn't completed a call, avoid it for new connections.
-        if (successCount == 0) {
-          if (e != null) {
-            connectionPool.connectFailed(route, e);
-          }
-          routeFailureCount++;
-        }
-      }
-    }
-  }
-
-  @Override public Protocol protocol() {
-    return protocol;
-  }
-
-  @Override public String toString() {
-    return "Connection{"
-        + route.address().url().host() + ":" + route.address().url().port()
-        + ", proxy="
-        + route.proxy()
-        + " hostAddress="
-        + route.socketAddress()
-        + " cipherSuite="
-        + (handshake != null ? handshake.cipherSuite() : "none")
-        + " protocol="
-        + protocol
-        + '}';
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.kt b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.kt
new file mode 100644
index 0000000000..fce137c6b9
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.kt
@@ -0,0 +1,716 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.connection
+
+import okhttp3.Address
+import okhttp3.Call
+import okhttp3.CertificatePinner
+import okhttp3.Connection
+import okhttp3.ConnectionSpec
+import okhttp3.EventListener
+import okhttp3.Handshake
+import okhttp3.Handshake.Companion.handshake
+import okhttp3.HttpUrl
+import okhttp3.Interceptor
+import okhttp3.OkHttpClient
+import okhttp3.Protocol
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.Route
+import okhttp3.internal.EMPTY_RESPONSE
+import okhttp3.internal.closeQuietly
+import okhttp3.internal.toHostHeader
+import okhttp3.internal.http.ExchangeCodec
+import okhttp3.internal.http1.Http1ExchangeCodec
+import okhttp3.internal.http2.ConnectionShutdownException
+import okhttp3.internal.http2.ErrorCode
+import okhttp3.internal.http2.Http2Connection
+import okhttp3.internal.http2.Http2ExchangeCodec
+import okhttp3.internal.http2.Http2Stream
+import okhttp3.internal.http2.StreamResetException
+import okhttp3.internal.platform.Platform
+import okhttp3.internal.tls.OkHostnameVerifier
+import okhttp3.internal.userAgent
+import okhttp3.internal.ws.RealWebSocket
+import okio.BufferedSink
+import okio.BufferedSource
+import okio.buffer
+import okio.sink
+import okio.source
+import java.io.IOException
+import java.lang.ref.Reference
+import java.net.ConnectException
+import java.net.HttpURLConnection.HTTP_OK
+import java.net.HttpURLConnection.HTTP_PROXY_AUTH
+import java.net.ProtocolException
+import java.net.Proxy
+import java.net.Socket
+import java.net.SocketException
+import java.net.SocketTimeoutException
+import java.net.UnknownServiceException
+import java.security.cert.X509Certificate
+import java.util.concurrent.TimeUnit.MILLISECONDS
+import javax.net.ssl.SSLPeerUnverifiedException
+import javax.net.ssl.SSLSocket
+
+class RealConnection(
+  val connectionPool: RealConnectionPool,
+  private val route: Route
+) : Http2Connection.Listener(), Connection {
+
+  // The fields below are initialized by connect() and never reassigned.
+
+  /** The low-level TCP socket. */
+  private var rawSocket: Socket? = null
+
+  /**
+   * The application layer socket. Either an [SSLSocket] layered over [rawSocket], or [rawSocket]
+   * itself if this connection does not use SSL.
+   */
+  private var socket: Socket? = null
+  private var handshake: Handshake? = null
+  private var protocol: Protocol? = null
+  private var http2Connection: Http2Connection? = null
+  private var source: BufferedSource? = null
+  private var sink: BufferedSink? = null
+
+  // The fields below track connection state and are guarded by connectionPool.
+
+  /**
+   * If true, no new exchanges can be created on this connection. Once true this is always true.
+   * Guarded by [connectionPool].
+   */
+  var noNewExchanges = false
+
+  /**
+   * The number of times there was a problem establishing a stream that could be due to route
+   * chosen. Guarded by [connectionPool].
+   */
+  internal var routeFailureCount = 0
+
+  internal var successCount = 0
+  private var refusedStreamCount = 0
+
+  /**
+   * The maximum number of concurrent streams that can be carried by this connection. If
+   * `allocations.size() < allocationLimit` then new streams can be created on this connection.
+   */
+  private var allocationLimit = 1
+
+  /** Current calls carried by this connection. */
+  val transmitters = mutableListOf<Reference<Transmitter>>()
+
+  /** Nanotime timestamp when `allocations.size()` reached zero. */
+  internal var idleAtNanos = Long.MAX_VALUE
+
+  /**
+   * Returns true if this is an HTTP/2 connection. Such connections can be used in multiple HTTP
+   * requests simultaneously.
+   */
+  val isMultiplexed: Boolean
+    get() = http2Connection != null
+
+  /** Prevent further exchanges from being created on this connection. */
+  fun noNewExchanges() {
+    assert(!Thread.holdsLock(connectionPool))
+    synchronized(connectionPool) {
+      noNewExchanges = true
+    }
+  }
+
+  fun connect(
+    connectTimeout: Int,
+    readTimeout: Int,
+    writeTimeout: Int,
+    pingIntervalMillis: Int,
+    connectionRetryEnabled: Boolean,
+    call: Call,
+    eventListener: EventListener
+  ) {
+    check(protocol == null) { "already connected" }
+
+    var routeException: RouteException? = null
+    val connectionSpecs = route.address.connectionSpecs
+    val connectionSpecSelector = ConnectionSpecSelector(connectionSpecs)
+
+    if (route.address.sslSocketFactory == null) {
+      if (ConnectionSpec.CLEARTEXT !in connectionSpecs) {
+        throw RouteException(UnknownServiceException(
+            "CLEARTEXT communication not enabled for client"))
+      }
+      val host = route.address.url.host
+      if (!Platform.get().isCleartextTrafficPermitted(host)) {
+        throw RouteException(UnknownServiceException(
+            "CLEARTEXT communication to $host not permitted by network security policy"))
+      }
+    } else {
+      if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) {
+        throw RouteException(UnknownServiceException(
+            "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS"))
+      }
+    }
+
+    while (true) {
+      try {
+        if (route.requiresTunnel()) {
+          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)
+          if (rawSocket == null) {
+            // We were unable to connect the tunnel but properly closed down our resources.
+            break
+          }
+        } else {
+          connectSocket(connectTimeout, readTimeout, call, eventListener)
+        }
+        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)
+        eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)
+        break
+      } catch (e: IOException) {
+        socket?.closeQuietly()
+        rawSocket?.closeQuietly()
+        socket = null
+        rawSocket = null
+        source = null
+        sink = null
+        handshake = null
+        protocol = null
+        http2Connection = null
+
+        eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)
+
+        if (routeException == null) {
+          routeException = RouteException(e)
+        } else {
+          routeException.addConnectException(e)
+        }
+
+        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {
+          throw routeException
+        }
+      }
+    }
+
+    if (route.requiresTunnel() && rawSocket == null) {
+      throw RouteException(ProtocolException(
+          "Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS"))
+    }
+
+    val http2Connection = this.http2Connection
+    if (http2Connection != null) {
+      synchronized(connectionPool) {
+        allocationLimit = http2Connection.maxConcurrentStreams()
+      }
+    }
+  }
+
+  /**
+   * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
+   * proxy server can issue an auth challenge and then close the connection.
+   */
+  @Throws(IOException::class)
+  private fun connectTunnel(
+    connectTimeout: Int,
+    readTimeout: Int,
+    writeTimeout: Int,
+    call: Call,
+    eventListener: EventListener
+  ) {
+    var tunnelRequest: Request = createTunnelRequest()
+    val url = tunnelRequest.url
+    for (i in 0 until MAX_TUNNEL_ATTEMPTS) {
+      connectSocket(connectTimeout, readTimeout, call, eventListener)
+      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url)
+          ?: break // Tunnel successfully created.
+
+      // The proxy decided to close the connection after an auth challenge. We need to create a new
+      // connection, but this time with the auth credentials.
+      rawSocket?.closeQuietly()
+      rawSocket = null
+      sink = null
+      source = null
+      eventListener.connectEnd(call, route.socketAddress, route.proxy, null)
+    }
+  }
+
+  /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
+  @Throws(IOException::class)
+  private fun connectSocket(
+    connectTimeout: Int,
+    readTimeout: Int,
+    call: Call,
+    eventListener: EventListener
+  ) {
+    val proxy = route.proxy
+    val address = route.address
+
+    val rawSocket = when (proxy.type()) {
+      Proxy.Type.DIRECT, Proxy.Type.HTTP -> address.socketFactory.createSocket()!!
+      else -> Socket(proxy)
+    }
+    this.rawSocket = rawSocket
+
+    eventListener.connectStart(call, route.socketAddress, proxy)
+    rawSocket.soTimeout = readTimeout
+    try {
+      Platform.get().connectSocket(rawSocket, route.socketAddress, connectTimeout)
+    } catch (e: ConnectException) {
+      throw ConnectException("Failed to connect to ${route.socketAddress}").apply {
+        initCause(e)
+      }
+    }
+
+    // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0
+    // More details:
+    // https://github.com/square/okhttp/issues/3245
+    // https://android-review.googlesource.com/#/c/271775/
+    try {
+      source = rawSocket.source().buffer()
+      sink = rawSocket.sink().buffer()
+    } catch (npe: NullPointerException) {
+      if (npe.message == NPE_THROW_WITH_NULL) {
+        throw IOException(npe)
+      }
+    }
+  }
+
+  @Throws(IOException::class)
+  private fun establishProtocol(
+    connectionSpecSelector: ConnectionSpecSelector,
+    pingIntervalMillis: Int,
+    call: Call,
+    eventListener: EventListener
+  ) {
+    if (route.address.sslSocketFactory == null) {
+      if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) {
+        socket = rawSocket
+        protocol = Protocol.H2_PRIOR_KNOWLEDGE
+        startHttp2(pingIntervalMillis)
+        return
+      }
+
+      socket = rawSocket
+      protocol = Protocol.HTTP_1_1
+      return
+    }
+
+    eventListener.secureConnectStart(call)
+    connectTls(connectionSpecSelector)
+    eventListener.secureConnectEnd(call, handshake)
+
+    if (protocol === Protocol.HTTP_2) {
+      startHttp2(pingIntervalMillis)
+    }
+  }
+
+  @Throws(IOException::class)
+  private fun startHttp2(pingIntervalMillis: Int) {
+    val socket = this.socket!!
+    val source = this.source!!
+    val sink = this.sink!!
+    socket.soTimeout = 0 // HTTP/2 connection timeouts are set per-stream.
+    val http2Connection = Http2Connection.Builder(true)
+        .socket(socket, route.address.url.host, source, sink)
+        .listener(this)
+        .pingIntervalMillis(pingIntervalMillis)
+        .build()
+    this.http2Connection = http2Connection
+    http2Connection.start()
+  }
+
+  @Throws(IOException::class)
+  private fun connectTls(connectionSpecSelector: ConnectionSpecSelector) {
+    val address = route.address
+    val sslSocketFactory = address.sslSocketFactory
+    var success = false
+    var sslSocket: SSLSocket? = null
+    try {
+      // Create the wrapper over the connected socket.
+      sslSocket = sslSocketFactory!!.createSocket(
+          rawSocket, address.url.host, address.url.port, true /* autoClose */) as SSLSocket
+
+      // Configure the socket's ciphers, TLS versions, and extensions.
+      val connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket)
+      if (connectionSpec.supportsTlsExtensions) {
+        Platform.get().configureTlsExtensions(sslSocket, address.url.host, address.protocols)
+      }
+
+      // Force handshake. This can throw!
+      sslSocket.startHandshake()
+      // block for session establishment
+      val sslSocketSession = sslSocket.session
+      val unverifiedHandshake = sslSocketSession.handshake()
+
+      // Verify that the socket's certificates are acceptable for the target host.
+      if (!address.hostnameVerifier!!.verify(address.url.host, sslSocketSession)) {
+        val peerCertificates = unverifiedHandshake.peerCertificates
+        if (peerCertificates.isNotEmpty()) {
+          val cert = peerCertificates[0] as X509Certificate
+          throw SSLPeerUnverifiedException("""
+              |Hostname ${address.url.host} not verified:
+              |    certificate: ${CertificatePinner.pin(cert)}
+              |    DN: ${cert.subjectDN.name}
+              |    subjectAltNames: ${OkHostnameVerifier.allSubjectAltNames(cert)}
+              """.trimMargin())
+        } else {
+          throw SSLPeerUnverifiedException(
+              "Hostname ${address.url.host} not verified (no certificates)")
+        }
+      }
+
+      // Check that the certificate pinner is satisfied by the certificates presented.
+      address.certificatePinner!!.check(address.url.host,
+          unverifiedHandshake.peerCertificates)
+
+      // Success! Save the handshake and the ALPN protocol.
+      val maybeProtocol = if (connectionSpec.supportsTlsExtensions) {
+        Platform.get().getSelectedProtocol(sslSocket)
+      } else {
+        null
+      }
+      socket = sslSocket
+      source = sslSocket.source().buffer()
+      sink = sslSocket.sink().buffer()
+      handshake = unverifiedHandshake
+      protocol = if (maybeProtocol != null) Protocol.get(maybeProtocol) else Protocol.HTTP_1_1
+      success = true
+    } finally {
+      if (sslSocket != null) {
+        Platform.get().afterHandshake(sslSocket)
+      }
+      if (!success) {
+        sslSocket?.closeQuietly()
+      }
+    }
+  }
+
+  /**
+   * To make an HTTPS connection over an HTTP proxy, send an unencrypted CONNECT request to create
+   * the proxy connection. This may need to be retried if the proxy requires authorization.
+   */
+  @Throws(IOException::class)
+  private fun createTunnel(
+    readTimeout: Int,
+    writeTimeout: Int,
+    tunnelRequest: Request,
+    url: HttpUrl
+  ): Request? {
+    var nextRequest = tunnelRequest
+    // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
+    val requestLine = "CONNECT ${url.toHostHeader(includeDefaultPort = true)} HTTP/1.1"
+    while (true) {
+      val source = this.source!!
+      val sink = this.sink!!
+      val tunnelCodec = Http1ExchangeCodec(null, null, source, sink)
+      source.timeout().timeout(readTimeout.toLong(), MILLISECONDS)
+      sink.timeout().timeout(writeTimeout.toLong(), MILLISECONDS)
+      tunnelCodec.writeRequest(nextRequest.headers, requestLine)
+      tunnelCodec.finishRequest()
+      val response = tunnelCodec.readResponseHeaders(false)!!
+          .request(nextRequest)
+          .build()
+      tunnelCodec.skipConnectBody(response)
+
+      when (response.code) {
+        HTTP_OK -> {
+          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
+          // that happens, then we will have buffered bytes that are needed by the SSLSocket!
+          // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
+          // that it will almost certainly fail because the proxy has sent unexpected data.
+          if (!source.buffer.exhausted() || !sink.buffer.exhausted()) {
+            throw IOException("TLS tunnel buffered too many bytes!")
+          }
+          return null
+        }
+
+        HTTP_PROXY_AUTH -> {
+          nextRequest = route.address.proxyAuthenticator.authenticate(route, response)
+              ?: throw IOException("Failed to authenticate with proxy")
+
+          if ("close".equals(response.header("Connection"), ignoreCase = true)) {
+            return nextRequest
+          }
+        }
+
+        else -> throw IOException("Unexpected response code for CONNECT: ${response.code}")
+      }
+    }
+  }
+
+  /**
+   * Returns a request that creates a TLS tunnel via an HTTP proxy. Everything in the tunnel request
+   * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
+   * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
+   *
+   * In order to support preemptive authentication we pass a fake "Auth Failed" response to the
+   * authenticator. This gives the authenticator the option to customize the CONNECT request. It can
+   * decline to do so by returning null, in which case OkHttp will use it as-is.
+   */
+  @Throws(IOException::class)
+  private fun createTunnelRequest(): Request {
+    val proxyConnectRequest = Request.Builder()
+        .url(route.address.url)
+        .method("CONNECT", null)
+        .header("Host", route.address.url.toHostHeader(includeDefaultPort = true))
+        .header("Proxy-Connection", "Keep-Alive") // For HTTP/1.0 proxies like Squid.
+        .header("User-Agent", userAgent)
+        .build()
+
+    val fakeAuthChallengeResponse = Response.Builder()
+        .request(proxyConnectRequest)
+        .protocol(Protocol.HTTP_1_1)
+        .code(HTTP_PROXY_AUTH)
+        .message("Preemptive Authenticate")
+        .body(EMPTY_RESPONSE)
+        .sentRequestAtMillis(-1L)
+        .receivedResponseAtMillis(-1L)
+        .header("Proxy-Authenticate", "OkHttp-Preemptive")
+        .build()
+
+    val authenticatedRequest = route.address.proxyAuthenticator
+        .authenticate(route, fakeAuthChallengeResponse)
+
+    return authenticatedRequest ?: proxyConnectRequest
+  }
+
+  /**
+   * Returns true if this connection can carry a stream allocation to `address`. If non-null
+   * `route` is the resolved route for a connection.
+   */
+  internal fun isEligible(address: Address, routes: List<Route>?): Boolean {
+    // If this connection is not accepting new exchanges, we're done.
+    if (transmitters.size >= allocationLimit || noNewExchanges) return false
+
+    // If the non-host fields of the address don't overlap, we're done.
+    if (!this.route.address.equalsNonHost(address)) return false
+
+    // If the host exactly matches, we're done: this connection can carry the address.
+    if (address.url.host == this.route().address.url.host) {
+      return true // This connection is a perfect match.
+    }
+
+    // At this point we don't have a hostname match. But we still be able to carry the request if
+    // our connection coalescing requirements are met. See also:
+    // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding
+    // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/
+
+    // 1. This connection must be HTTP/2.
+    if (http2Connection == null) return false
+
+    // 2. The routes must share an IP address.
+    if (routes == null || !routeMatchesAny(routes)) return false
+
+    // 3. This connection's server certificate's must cover the new host.
+    if (address.hostnameVerifier !== OkHostnameVerifier) return false
+    if (!supportsUrl(address.url)) return false
+
+    // 4. Certificate pinning must match the host.
+    try {
+      address.certificatePinner!!.check(address.url.host, handshake()!!.peerCertificates)
+    } catch (_: SSLPeerUnverifiedException) {
+      return false
+    }
+
+    return true // The caller's address can be carried by this connection.
+  }
+
+  /**
+   * Returns true if this connection's route has the same address as any of [candidates]. This
+   * requires us to have a DNS address for both hosts, which only happens after route planning. We
+   * can't coalesce connections that use a proxy, since proxies don't tell us the origin server's IP
+   * address.
+   */
+  private fun routeMatchesAny(candidates: List<Route>): Boolean {
+    return candidates.any {
+      it.proxy.type() == Proxy.Type.DIRECT &&
+          route.proxy.type() == Proxy.Type.DIRECT &&
+          route.socketAddress == it.socketAddress
+    }
+  }
+
+  fun supportsUrl(url: HttpUrl): Boolean {
+    val routeUrl = route.address.url
+
+    if (url.port != routeUrl.port) {
+      return false // Port mismatch.
+    }
+
+    if (url.host == routeUrl.host) {
+      return true // Host match. The URL is supported.
+    }
+
+    // We have a host mismatch. But if the certificate matches, we're still good.
+    return handshake != null && OkHostnameVerifier.verify(
+        url.host, handshake!!.peerCertificates[0] as X509Certificate)
+  }
+
+  @Throws(SocketException::class)
+  internal fun newCodec(client: OkHttpClient, chain: Interceptor.Chain): ExchangeCodec {
+    val socket = this.socket!!
+    val source = this.source!!
+    val sink = this.sink!!
+    val http2Connection = this.http2Connection
+
+    return if (http2Connection != null) {
+      Http2ExchangeCodec(client, this, chain, http2Connection)
+    } else {
+      socket.soTimeout = chain.readTimeoutMillis()
+      source.timeout().timeout(chain.readTimeoutMillis().toLong(), MILLISECONDS)
+      sink.timeout().timeout(chain.writeTimeoutMillis().toLong(), MILLISECONDS)
+      Http1ExchangeCodec(client, this, source, sink)
+    }
+  }
+
+  @Throws(SocketException::class)
+  internal fun newWebSocketStreams(exchange: Exchange): RealWebSocket.Streams {
+    val socket = this.socket!!
+    val source = this.source!!
+    val sink = this.sink!!
+
+    socket.soTimeout = 0
+    noNewExchanges()
+    return object : RealWebSocket.Streams(true, source, sink) {
+      override fun close() {
+        exchange.bodyComplete<IOException?>(-1L, true, true, null)
+      }
+    }
+  }
+
+  override fun route(): Route = route
+
+  fun cancel() {
+    // Close the raw socket so we don't end up doing synchronous I/O.
+    rawSocket?.closeQuietly()
+  }
+
+  override fun socket(): Socket = socket!!
+
+  /** Returns true if this connection is ready to host new streams. */
+  fun isHealthy(doExtensiveChecks: Boolean): Boolean {
+    val socket = this.socket!!
+    val source = this.source!!
+    if (socket.isClosed || socket.isInputShutdown || socket.isOutputShutdown) {
+      return false
+    }
+
+    val http2Connection = this.http2Connection
+    if (http2Connection != null) {
+      return !http2Connection.isShutdown
+    }
+
+    if (doExtensiveChecks) {
+      try {
+        val readTimeout = socket.soTimeout
+        try {
+          socket.soTimeout = 1
+          return !source.exhausted()
+        } finally {
+          socket.soTimeout = readTimeout
+        }
+      } catch (_: SocketTimeoutException) {
+        // Read timed out; socket is good.
+      } catch (_: IOException) {
+        return false // Couldn't read; socket is closed.
+      }
+    }
+
+    return true
+  }
+
+  /** Refuse incoming streams. */
+  @Throws(IOException::class)
+  override fun onStream(stream: Http2Stream) {
+    stream.close(ErrorCode.REFUSED_STREAM, null)
+  }
+
+  /** When settings are received, adjust the allocation limit. */
+  override fun onSettings(connection: Http2Connection) {
+    synchronized(connectionPool) {
+      allocationLimit = connection.maxConcurrentStreams()
+    }
+  }
+
+  override fun handshake(): Handshake? = handshake
+
+  /**
+   * Track a failure using this connection. This may prevent both the connection and its route from
+   * being used for future exchanges.
+   */
+  internal fun trackFailure(e: IOException?) {
+    assert(!Thread.holdsLock(connectionPool))
+    synchronized(connectionPool) {
+      if (e is StreamResetException) {
+        when (e.errorCode) {
+          ErrorCode.REFUSED_STREAM -> {
+            // Retry REFUSED_STREAM errors once on the same connection.
+            refusedStreamCount++
+            if (refusedStreamCount > 1) {
+              noNewExchanges = true
+              routeFailureCount++
+            }
+          }
+
+          ErrorCode.CANCEL -> {
+            // Keep the connection for CANCEL errors.
+          }
+
+          else -> {
+            // Everything else wants a fresh connection.
+            noNewExchanges = true
+            routeFailureCount++
+          }
+        }
+      } else if (!isMultiplexed || e is ConnectionShutdownException) {
+        noNewExchanges = true
+
+        // If this route hasn't completed a call, avoid it for new connections.
+        if (successCount == 0) {
+          if (e != null) {
+            connectionPool.connectFailed(route, e)
+          }
+          routeFailureCount++
+        }
+      }
+      return@synchronized // Keep synchronized {} happy.
+    }
+  }
+
+  override fun protocol(): Protocol = protocol!!
+
+  override fun toString(): String {
+    return "Connection{${route.address.url.host}:${route.address.url.port}," +
+        " proxy=${route.proxy}" +
+        " hostAddress=${route.socketAddress}" +
+        " cipherSuite=${handshake?.cipherSuite ?: "none"}" +
+        " protocol=$protocol}"
+  }
+
+  companion object {
+    private const val NPE_THROW_WITH_NULL = "throw with null exception"
+    private const val MAX_TUNNEL_ATTEMPTS = 21
+
+    fun newTestConnection(
+      connectionPool: RealConnectionPool,
+      route: Route,
+      socket: Socket,
+      idleAtNanos: Long
+    ): RealConnection {
+      val result = RealConnection(connectionPool, route)
+      result.socket = socket
+      result.idleAtNanos = idleAtNanos
+      return result
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
index 50dcd59609..8dc3c57bce 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
@@ -17,13 +17,14 @@
 package okhttp3.internal.connection
 
 import okhttp3.Address
+import okhttp3.ConnectionPool
 import okhttp3.Route
-import okhttp3.internal.Util
-import okhttp3.internal.Util.closeQuietly
+import okhttp3.internal.closeQuietly
 import okhttp3.internal.connection.Transmitter.TransmitterReference
+import okhttp3.internal.lockAndWaitNanos
 import okhttp3.internal.notifyAll
 import okhttp3.internal.platform.Platform
-import okhttp3.internal.waitNanos
+import okhttp3.internal.threadFactory
 import java.io.IOException
 import java.net.Proxy
 import java.util.ArrayDeque
@@ -32,7 +33,7 @@ import java.util.concurrent.ThreadPoolExecutor
 import java.util.concurrent.TimeUnit
 
 class RealConnectionPool(
-  /** The maximum number of idle connections for each address.  */
+  /** The maximum number of idle connections for each address. */
   private val maxIdleConnections: Int,
   keepAliveDuration: Long,
   timeUnit: TimeUnit
@@ -45,8 +46,10 @@ class RealConnectionPool(
         val waitNanos = cleanup(System.nanoTime())
         if (waitNanos == -1L) return
         try {
-          this@RealConnectionPool.waitNanos(waitNanos)
-        } catch (_: InterruptedException) {
+          this@RealConnectionPool.lockAndWaitNanos(waitNanos)
+        } catch (ie: InterruptedException) {
+          // Will cause the thread to exit unless other connections are created!
+          evictAll()
         }
       }
     }
@@ -58,7 +61,7 @@ class RealConnectionPool(
 
   init {
     // Put a floor on the keep alive duration, otherwise cleanup will spin loop.
-    require(keepAliveDuration > 0) { "keepAliveDuration <= 0: $keepAliveDuration" }
+    require(keepAliveDuration > 0L) { "keepAliveDuration <= 0: $keepAliveDuration" }
   }
 
   @Synchronized fun idleConnectionCount(): Int {
@@ -70,10 +73,10 @@ class RealConnectionPool(
   }
 
   /**
-   * Attempts to acquire a recycled connection to `address` for `transmitter`. Returns true if a
+   * Attempts to acquire a recycled connection to [address] for [transmitter]. Returns true if a
    * connection was acquired.
    *
-   * If `routes` is non-null these are the resolved routes (ie. IP addresses) for the connection.
+   * If [routes] is non-null these are the resolved routes (ie. IP addresses) for the connection.
    * This is used to coalesce related domains to the same HTTP/2 connection, such as `square.com`
    * and `square.ca`.
    */
@@ -103,18 +106,18 @@ class RealConnectionPool(
   }
 
   /**
-   * Notify this pool that `connection` has become idle. Returns true if the connection has
+   * Notify this pool that [connection] has become idle. Returns true if the connection has
    * been removed from the pool and should be closed.
    */
   fun connectionBecameIdle(connection: RealConnection): Boolean {
     assert(Thread.holdsLock(this))
-    if (connection.noNewExchanges || maxIdleConnections == 0) {
+    return if (connection.noNewExchanges || maxIdleConnections == 0) {
       connections.remove(connection)
-      return true
+      true
     } else {
       // Awake the cleanup thread: we may have exceeded the idle connection limit.
       this.notifyAll()
-      return false
+      false
     }
   }
 
@@ -133,7 +136,7 @@ class RealConnectionPool(
     }
 
     for (connection in evictedConnections) {
-      closeQuietly(connection.socket())
+      connection.socket().closeQuietly()
     }
   }
 
@@ -193,7 +196,7 @@ class RealConnectionPool(
       }
     }
 
-    closeQuietly(longestIdleConnection!!.socket())
+    longestIdleConnection!!.socket().closeQuietly()
 
     // Cleanup again immediately.
     return 0
@@ -201,7 +204,7 @@ class RealConnectionPool(
 
   /**
    * Prunes any leaked transmitters and then returns the number of remaining live transmitters on
-   * `connection`. Transmitters are leaked if the connection is tracking them but the application
+   * [connection]. Transmitters are leaked if the connection is tracking them but the application
    * code has abandoned them. Leak detection is imprecise and relies on garbage collection.
    */
   private fun pruneAndGetAllocationCount(connection: RealConnection, now: Long): Int {
@@ -217,7 +220,7 @@ class RealConnectionPool(
 
       // We've discovered a leaked transmitter. This is an application bug.
       val transmitterRef = reference as TransmitterReference
-      val message = "A connection to ${connection.route().address().url()} was leaked. " +
+      val message = "A connection to ${connection.route().address.url} was leaked. " +
           "Did you forget to close a response body?"
       Platform.get().logCloseableLeak(message, transmitterRef.callStackTrace)
 
@@ -234,13 +237,13 @@ class RealConnectionPool(
     return references.size
   }
 
-  /** Track a bad route in the route database. Other routes will be attempted first.  */
+  /** Track a bad route in the route database. Other routes will be attempted first. */
   fun connectFailed(failedRoute: Route, failure: IOException) {
     // Tell the proxy selector when we fail to connect on a fresh connection.
-    if (failedRoute.proxy().type() != Proxy.Type.DIRECT) {
-      val address = failedRoute.address()
-      address.proxySelector().connectFailed(
-          address.url().uri(), failedRoute.proxy().address(), failure)
+    if (failedRoute.proxy.type() != Proxy.Type.DIRECT) {
+      val address = failedRoute.address
+      address.proxySelector.connectFailed(
+          address.url.toUri(), failedRoute.proxy.address(), failure)
     }
 
     routeDatabase.failed(failedRoute)
@@ -257,7 +260,9 @@ class RealConnectionPool(
         Int.MAX_VALUE, // maximumPoolSize.
         60L, TimeUnit.SECONDS, // keepAliveTime.
         SynchronousQueue(),
-        Util.threadFactory("OkHttp ConnectionPool", true)
+        threadFactory("OkHttp ConnectionPool", true)
     )
+
+    fun get(connectionPool: ConnectionPool): RealConnectionPool = connectionPool.delegate
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.kt b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.kt
index de36fc97b4..c7c7422fc3 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.kt
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.kt
@@ -37,5 +37,5 @@ class RouteDatabase {
   }
 
   /** Returns true if [route] has failed recently and should be avoided. */
-  @Synchronized fun shouldPostpone(route: Route): Boolean = failedRoutes.contains(route)
+  @Synchronized fun shouldPostpone(route: Route): Boolean = route in failedRoutes
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.kt b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.kt
index 9230b8e8ef..a1db48a79f 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.kt
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.kt
@@ -20,7 +20,8 @@ import okhttp3.Call
 import okhttp3.EventListener
 import okhttp3.HttpUrl
 import okhttp3.Route
-import okhttp3.internal.Util
+import okhttp3.internal.immutableListOf
+import okhttp3.internal.toImmutableList
 import java.io.IOException
 import java.net.InetSocketAddress
 import java.net.Proxy
@@ -49,7 +50,7 @@ class RouteSelector(
   private val postponedRoutes = mutableListOf<Route>()
 
   init {
-    resetNextProxy(address.url(), address.proxy())
+    resetNextProxy(address.url, address.proxy)
   }
 
   /**
@@ -91,39 +92,41 @@ class RouteSelector(
     return Selection(routes)
   }
 
-  /** Prepares the proxy servers to try.  */
+  /** Prepares the proxy servers to try. */
   private fun resetNextProxy(url: HttpUrl, proxy: Proxy?) {
-    if (proxy != null) {
+    eventListener.proxySelectStart(call, url)
+    proxies = if (proxy != null) {
       // If the user specifies a proxy, try that and only that.
-      proxies = listOf(proxy)
+      listOf(proxy)
     } else {
       // Try each of the ProxySelector choices until one connection succeeds.
-      val proxiesOrNull = address.proxySelector().select(url.uri())
-      proxies = if (proxiesOrNull != null && proxiesOrNull.isNotEmpty()) {
-        Util.immutableList(proxiesOrNull)
+      val proxiesOrNull = address.proxySelector.select(url.toUri())
+      if (proxiesOrNull != null && proxiesOrNull.isNotEmpty()) {
+        proxiesOrNull.toImmutableList()
       } else {
-        Util.immutableList(Proxy.NO_PROXY)
+        immutableListOf(Proxy.NO_PROXY)
       }
     }
     nextProxyIndex = 0
+    eventListener.proxySelectEnd(call, url, proxies)
   }
 
-  /** Returns true if there's another proxy to try.  */
+  /** Returns true if there's another proxy to try. */
   private fun hasNextProxy(): Boolean = nextProxyIndex < proxies.size
 
-  /** Returns the next proxy to try. May be PROXY.NO_PROXY but never null.  */
+  /** Returns the next proxy to try. May be PROXY.NO_PROXY but never null. */
   @Throws(IOException::class)
   private fun nextProxy(): Proxy {
     if (!hasNextProxy()) {
       throw SocketException(
-          "No route to ${address.url().host()}; exhausted proxy configurations: $proxies")
+          "No route to ${address.url.host}; exhausted proxy configurations: $proxies")
     }
     val result = proxies[nextProxyIndex++]
     resetNextInetSocketAddress(result)
     return result
   }
 
-  /** Prepares the socket addresses to attempt for the current proxy or host.  */
+  /** Prepares the socket addresses to attempt for the current proxy or host. */
   @Throws(IOException::class)
   private fun resetNextInetSocketAddress(proxy: Proxy) {
     // Clear the addresses. Necessary if getAllByName() below throws!
@@ -133,8 +136,8 @@ class RouteSelector(
     val socketHost: String
     val socketPort: Int
     if (proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.SOCKS) {
-      socketHost = address.url().host()
-      socketPort = address.url().port()
+      socketHost = address.url.host
+      socketPort = address.url.port
     } else {
       val proxyAddress = proxy.address()
       require(proxyAddress is InetSocketAddress) {
@@ -154,9 +157,9 @@ class RouteSelector(
       eventListener.dnsStart(call, socketHost)
 
       // Try each address for best behavior in mixed IPv4/IPv6 environments.
-      val addresses = address.dns().lookup(socketHost)
+      val addresses = address.dns.lookup(socketHost)
       if (addresses.isEmpty()) {
-        throw UnknownHostException("${address.dns()} returned no addresses for $socketHost")
+        throw UnknownHostException("${address.dns} returned no addresses for $socketHost")
       }
 
       eventListener.dnsEnd(call, socketHost, addresses)
@@ -181,7 +184,6 @@ class RouteSelector(
 
   companion object {
     /** Obtain a host string containing either an actual host name or a numeric IP address. */
-    @JvmStatic
     val InetSocketAddress.socketHost: String get() {
       // The InetSocketAddress was specified with a string (either a numeric IP or a host name). If
       // it is a name, all IPs for that name should be tried. If it is an IP address, only that IP
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java b/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java
deleted file mode 100644
index 59439c78ef..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java
+++ /dev/null
@@ -1,366 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.lang.ref.Reference;
-import java.lang.ref.WeakReference;
-import java.net.Socket;
-import javax.annotation.Nullable;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.CertificatePinner;
-import okhttp3.Connection;
-import okhttp3.EventListener;
-import okhttp3.HttpUrl;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.internal.Internal;
-import okhttp3.internal.http.ExchangeCodec;
-import okhttp3.internal.platform.Platform;
-import okio.AsyncTimeout;
-import okio.Timeout;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static okhttp3.internal.Util.closeQuietly;
-import static okhttp3.internal.Util.sameConnection;
-
-/**
- * Bridge between OkHttp's application and network layers. This class exposes high-level application
- * layer primitives: connections, requests, responses, and streams.
- *
- * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
- * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
- * but not the other streams sharing its connection. But if the TLS handshake is still in progress
- * then canceling may break the entire connection.
- */
-public final class Transmitter {
-  private final OkHttpClient client;
-  private final RealConnectionPool connectionPool;
-  private final Call call;
-  private final EventListener eventListener;
-  private final AsyncTimeout timeout = new AsyncTimeout() {
-    @Override protected void timedOut() {
-      cancel();
-    }
-  };
-
-  private @Nullable Object callStackTrace;
-
-  private Request request;
-  private ExchangeFinder exchangeFinder;
-
-  // Guarded by connectionPool.
-  public RealConnection connection;
-  private @Nullable Exchange exchange;
-  private boolean exchangeRequestDone;
-  private boolean exchangeResponseDone;
-  private boolean canceled;
-  private boolean timeoutEarlyExit;
-  private boolean noMoreExchanges;
-
-  public Transmitter(OkHttpClient client, Call call) {
-    this.client = client;
-    this.connectionPool = Internal.instance.realConnectionPool(client.connectionPool());
-    this.call = call;
-    this.eventListener = client.eventListenerFactory().create(call);
-    this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);
-  }
-
-  public Timeout timeout() {
-    return timeout;
-  }
-
-  public void timeoutEnter() {
-    timeout.enter();
-  }
-
-  /**
-   * Stops applying the timeout before the call is entirely complete. This is used for WebSockets
-   * and duplex calls where the timeout only applies to the initial setup.
-   */
-  public void timeoutEarlyExit() {
-    if (timeoutEarlyExit) throw new IllegalStateException();
-    timeoutEarlyExit = true;
-    timeout.exit();
-  }
-
-  private @Nullable IOException timeoutExit(@Nullable IOException cause) {
-    if (timeoutEarlyExit) return cause;
-    if (!timeout.exit()) return cause;
-
-    InterruptedIOException e = new InterruptedIOException("timeout");
-    if (cause != null) e.initCause(cause);
-
-    return e;
-  }
-
-  public void callStart() {
-    this.callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
-    eventListener.callStart(call);
-  }
-
-  /**
-   * Prepare to create a stream to carry {@code request}. This prefers to use the existing
-   * connection if it exists.
-   */
-  public void prepareToConnect(Request request) {
-    if (this.request != null) {
-      if (sameConnection(this.request.url(), request.url()) && exchangeFinder.hasRouteToTry()) {
-        return; // Already ready.
-      }
-      if (exchange != null) throw new IllegalStateException();
-
-      if (exchangeFinder != null) {
-        maybeReleaseConnection(null, true);
-        exchangeFinder = null;
-      }
-    }
-
-    this.request = request;
-    this.exchangeFinder = new ExchangeFinder(this, connectionPool, createAddress(request.url()),
-        call, eventListener);
-  }
-
-  private Address createAddress(HttpUrl url) {
-    SSLSocketFactory sslSocketFactory = null;
-    HostnameVerifier hostnameVerifier = null;
-    CertificatePinner certificatePinner = null;
-    if (url.isHttps()) {
-      sslSocketFactory = client.sslSocketFactory();
-      hostnameVerifier = client.hostnameVerifier();
-      certificatePinner = client.certificatePinner();
-    }
-
-    return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
-        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
-        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
-  }
-
-  /** Returns a new exchange to carry a new request and response. */
-  Exchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
-    synchronized (connectionPool) {
-      if (noMoreExchanges) {
-        throw new IllegalStateException("released");
-      }
-      if (exchange != null) {
-        throw new IllegalStateException("cannot make a new request because the previous response "
-            + "is still open: please call response.close()");
-      }
-    }
-
-    ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);
-    Exchange result = new Exchange(this, call, eventListener, exchangeFinder, codec);
-
-    synchronized (connectionPool) {
-      this.exchange = result;
-      this.exchangeRequestDone = false;
-      this.exchangeResponseDone = false;
-      return result;
-    }
-  }
-
-  void acquireConnectionNoEvents(RealConnection connection) {
-    assert (Thread.holdsLock(connectionPool));
-
-    if (this.connection != null) throw new IllegalStateException();
-    this.connection = connection;
-    connection.transmitters.add(new TransmitterReference(this, callStackTrace));
-  }
-
-  /**
-   * Remove the transmitter from the connection's list of allocations. Returns a socket that the
-   * caller should close.
-   */
-  @Nullable Socket releaseConnectionNoEvents() {
-    assert (Thread.holdsLock(connectionPool));
-
-    int index = -1;
-    for (int i = 0, size = this.connection.transmitters.size(); i < size; i++) {
-      Reference<Transmitter> reference = this.connection.transmitters.get(i);
-      if (reference.get() == this) {
-        index = i;
-        break;
-      }
-    }
-
-    if (index == -1) throw new IllegalStateException();
-
-    RealConnection released = this.connection;
-    released.transmitters.remove(index);
-    this.connection = null;
-
-    if (released.transmitters.isEmpty()) {
-      released.idleAtNanos = System.nanoTime();
-      if (connectionPool.connectionBecameIdle(released)) {
-        return released.socket();
-      }
-    }
-
-    return null;
-  }
-
-  public void exchangeDoneDueToException() {
-    synchronized (connectionPool) {
-      if (noMoreExchanges) throw new IllegalStateException();
-      exchange = null;
-    }
-  }
-
-  /**
-   * Releases resources held with the request or response of {@code exchange}. This should be called
-   * when the request completes normally or when it fails due to an exception, in which case {@code
-   * e} should be non-null.
-   *
-   * <p>If the exchange was canceled or timed out, this will wrap {@code e} in an exception that
-   * provides that additional context. Otherwise {@code e} is returned as-is.
-   */
-  @Nullable IOException exchangeMessageDone(
-      Exchange exchange, boolean requestDone, boolean responseDone, @Nullable IOException e) {
-    boolean exchangeDone = false;
-    synchronized (connectionPool) {
-      if (exchange != this.exchange) {
-        return e; // This exchange was detached violently!
-      }
-      boolean changed = false;
-      if (requestDone) {
-        if (!exchangeRequestDone) changed = true;
-        this.exchangeRequestDone = true;
-      }
-      if (responseDone) {
-        if (!exchangeResponseDone) changed = true;
-        this.exchangeResponseDone = true;
-      }
-      if (exchangeRequestDone && exchangeResponseDone && changed) {
-        exchangeDone = true;
-        this.exchange.connection().successCount++;
-        this.exchange = null;
-      }
-    }
-    if (exchangeDone) {
-      e = maybeReleaseConnection(e, false);
-    }
-    return e;
-  }
-
-  public @Nullable IOException noMoreExchanges(@Nullable IOException e) {
-    synchronized (connectionPool) {
-      noMoreExchanges = true;
-    }
-    return maybeReleaseConnection(e, false);
-  }
-
-  /**
-   * Release the connection if it is no longer needed. This is called after each exchange completes
-   * and after the call signals that no more exchanges are expected.
-   *
-   * <p>If the transmitter was canceled or timed out, this will wrap {@code e} in an exception that
-   * provides that additional context. Otherwise {@code e} is returned as-is.
-   *
-   * @param force true to release the connection even if more exchanges are expected for the call.
-   */
-  private @Nullable IOException maybeReleaseConnection(@Nullable IOException e, boolean force) {
-    Socket socket;
-    Connection releasedConnection;
-    boolean callEnd;
-    synchronized (connectionPool) {
-      if (force && exchange != null) {
-        throw new IllegalStateException("cannot release connection while it is in use");
-      }
-      releasedConnection = this.connection;
-      socket = this.connection != null && exchange == null && (force || noMoreExchanges)
-          ? releaseConnectionNoEvents()
-          : null;
-      if (this.connection != null) releasedConnection = null;
-      callEnd = noMoreExchanges && exchange == null;
-    }
-    closeQuietly(socket);
-
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-
-    if (callEnd) {
-      boolean callFailed = (e != null);
-      e = timeoutExit(e);
-      if (callFailed) {
-        eventListener.callFailed(call, e);
-      } else {
-        eventListener.callEnd(call);
-      }
-    }
-    return e;
-  }
-
-  public boolean canRetry() {
-    return exchangeFinder.hasStreamFailure() && exchangeFinder.hasRouteToTry();
-  }
-
-  public boolean hasExchange() {
-    synchronized (connectionPool) {
-      return exchange != null;
-    }
-  }
-
-  /**
-   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
-   * in-flight request from any thread. It's the caller's responsibility to close the request body
-   * and response body streams; otherwise resources may be leaked.
-   *
-   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
-   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
-   * Otherwise if a socket connection is being established, that is terminated.
-   */
-  public void cancel() {
-    Exchange exchangeToCancel;
-    RealConnection connectionToCancel;
-    synchronized (connectionPool) {
-      canceled = true;
-      exchangeToCancel = exchange;
-      connectionToCancel = exchangeFinder != null && exchangeFinder.connectingConnection() != null
-          ? exchangeFinder.connectingConnection()
-          : connection;
-    }
-    if (exchangeToCancel != null) {
-      exchangeToCancel.cancel();
-    } else if (connectionToCancel != null) {
-      connectionToCancel.cancel();
-    }
-  }
-
-  public boolean isCanceled() {
-    synchronized (connectionPool) {
-      return canceled;
-    }
-  }
-
-  static final class TransmitterReference extends WeakReference<Transmitter> {
-    /**
-     * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
-     * identifying the origin of connection leaks.
-     */
-    final Object callStackTrace;
-
-    TransmitterReference(Transmitter referent, Object callStackTrace) {
-      super(referent);
-      this.callStackTrace = callStackTrace;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.kt b/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.kt
new file mode 100644
index 0000000000..b58ab9cc0c
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.kt
@@ -0,0 +1,341 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection
+
+import okhttp3.Address
+import okhttp3.Call
+import okhttp3.CertificatePinner
+import okhttp3.Connection
+import okhttp3.EventListener
+import okhttp3.HttpUrl
+import okhttp3.Interceptor
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.internal.closeQuietly
+import okhttp3.internal.canReuseConnectionFor
+import okhttp3.internal.platform.Platform
+import okio.AsyncTimeout
+import okio.Timeout
+import java.io.IOException
+import java.io.InterruptedIOException
+import java.lang.ref.WeakReference
+import java.net.Socket
+import java.util.concurrent.TimeUnit.MILLISECONDS
+import javax.net.ssl.HostnameVerifier
+import javax.net.ssl.SSLSocketFactory
+
+/**
+ * Bridge between OkHttp's application and network layers. This class exposes high-level application
+ * layer primitives: connections, requests, responses, and streams.
+ *
+ * This class supports [asynchronous canceling][cancel]. This is intended to have the smallest
+ * blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream but not
+ * the other streams sharing its connection. But if the TLS handshake is still in progress then
+ * canceling may break the entire connection.
+ */
+class Transmitter(
+  private val client: OkHttpClient,
+  private val call: Call
+) {
+  private val connectionPool: RealConnectionPool = client.connectionPool.delegate
+  private val eventListener: EventListener = client.eventListenerFactory.create(call)
+  private val timeout = object : AsyncTimeout() {
+    override fun timedOut() {
+      cancel()
+    }
+  }.apply {
+    timeout(client.callTimeoutMillis.toLong(), MILLISECONDS)
+  }
+
+  private var callStackTrace: Any? = null
+
+  private var request: Request? = null
+  private var exchangeFinder: ExchangeFinder? = null
+
+  // Guarded by connectionPool.
+  var connection: RealConnection? = null
+  private var exchange: Exchange? = null
+  private var exchangeRequestDone = false
+  private var exchangeResponseDone = false
+  private var canceled = false
+  private var timeoutEarlyExit = false
+  private var noMoreExchanges = false
+
+  val isCanceled: Boolean
+    get() {
+      synchronized(connectionPool) {
+        return canceled
+      }
+    }
+
+  fun timeout(): Timeout = timeout
+
+  fun timeoutEnter() {
+    timeout.enter()
+  }
+
+  /**
+   * Stops applying the timeout before the call is entirely complete. This is used for WebSockets
+   * and duplex calls where the timeout only applies to the initial setup.
+   */
+  fun timeoutEarlyExit() {
+    check(!timeoutEarlyExit)
+    timeoutEarlyExit = true
+    timeout.exit()
+  }
+
+  private fun <E : IOException?> timeoutExit(cause: E): E {
+    if (timeoutEarlyExit) return cause
+    if (!timeout.exit()) return cause
+
+    val e = InterruptedIOException("timeout")
+    if (cause != null) e.initCause(cause)
+    @Suppress("UNCHECKED_CAST") // E is either IOException or IOException?
+    return e as E
+  }
+
+  fun callStart() {
+    this.callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()")
+    eventListener.callStart(call)
+  }
+
+  /**
+   * Prepare to create a stream to carry [request]. This prefers to use the existing connection if
+   * it exists.
+   */
+  fun prepareToConnect(request: Request) {
+    if (this.request != null) {
+      if (this.request!!.url.canReuseConnectionFor(request.url) && exchangeFinder!!.hasRouteToTry()) {
+        return // Already ready.
+      }
+      check(exchange == null)
+
+      if (exchangeFinder != null) {
+        maybeReleaseConnection(null, true)
+        exchangeFinder = null
+      }
+    }
+
+    this.request = request
+    this.exchangeFinder = ExchangeFinder(
+        this, connectionPool, createAddress(request.url), call, eventListener)
+  }
+
+  private fun createAddress(url: HttpUrl): Address {
+    var sslSocketFactory: SSLSocketFactory? = null
+    var hostnameVerifier: HostnameVerifier? = null
+    var certificatePinner: CertificatePinner? = null
+    if (url.isHttps) {
+      sslSocketFactory = client.sslSocketFactory
+      hostnameVerifier = client.hostnameVerifier
+      certificatePinner = client.certificatePinner
+    }
+
+    return Address(url.host, url.port, client.dns, client.socketFactory,
+        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator,
+        client.proxy, client.protocols, client.connectionSpecs, client.proxySelector)
+  }
+
+  /** Returns a new exchange to carry a new request and response. */
+  internal fun newExchange(chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean): Exchange {
+    synchronized(connectionPool) {
+      check(!noMoreExchanges) { "released" }
+      check(exchange == null) {
+        "cannot make a new request because the previous response is still open: " +
+            "please call response.close()"
+      }
+    }
+
+    val codec = exchangeFinder!!.find(client, chain, doExtensiveHealthChecks)
+    val result = Exchange(this, call, eventListener, exchangeFinder!!, codec)
+
+    synchronized(connectionPool) {
+      this.exchange = result
+      this.exchangeRequestDone = false
+      this.exchangeResponseDone = false
+      return result
+    }
+  }
+
+  fun acquireConnectionNoEvents(connection: RealConnection) {
+    assert(Thread.holdsLock(connectionPool))
+
+    check(this.connection == null)
+    this.connection = connection
+    connection.transmitters.add(TransmitterReference(this, callStackTrace))
+  }
+
+  /**
+   * Remove the transmitter from the connection's list of allocations. Returns a socket that the
+   * caller should close.
+   */
+  fun releaseConnectionNoEvents(): Socket? {
+    assert(Thread.holdsLock(connectionPool))
+
+    val index = connection!!.transmitters.indexOfFirst { it.get() == this@Transmitter }
+    check(index != -1)
+
+    val released = this.connection
+    released!!.transmitters.removeAt(index)
+    this.connection = null
+
+    if (released.transmitters.isEmpty()) {
+      released.idleAtNanos = System.nanoTime()
+      if (connectionPool.connectionBecameIdle(released)) {
+        return released.socket()
+      }
+    }
+
+    return null
+  }
+
+  fun exchangeDoneDueToException() {
+    synchronized(connectionPool) {
+      check(!noMoreExchanges)
+      exchange = null
+    }
+  }
+
+  /**
+   * Releases resources held with the request or response of [exchange]. This should be called when
+   * the request completes normally or when it fails due to an exception, in which case [e] should
+   * be non-null.
+   *
+   * If the exchange was canceled or timed out, this will wrap [e] in an exception that provides
+   * that additional context. Otherwise [e] is returned as-is.
+   */
+  internal fun <E : IOException?> exchangeMessageDone(
+    exchange: Exchange,
+    requestDone: Boolean,
+    responseDone: Boolean,
+    e: E
+  ): E {
+    var result = e
+    var exchangeDone = false
+    synchronized(connectionPool) {
+      if (exchange != this.exchange) {
+        return result // This exchange was detached violently!
+      }
+      var changed = false
+      if (requestDone) {
+        if (!exchangeRequestDone) changed = true
+        this.exchangeRequestDone = true
+      }
+      if (responseDone) {
+        if (!exchangeResponseDone) changed = true
+        this.exchangeResponseDone = true
+      }
+      if (exchangeRequestDone && exchangeResponseDone && changed) {
+        exchangeDone = true
+        this.exchange!!.connection()!!.successCount++
+        this.exchange = null
+      }
+    }
+    if (exchangeDone) {
+      result = maybeReleaseConnection(result, false)
+    }
+    return result
+  }
+
+  fun noMoreExchanges(e: IOException?): IOException? {
+    synchronized(connectionPool) {
+      noMoreExchanges = true
+    }
+    return maybeReleaseConnection(e, false)
+  }
+
+  /**
+   * Release the connection if it is no longer needed. This is called after each exchange completes
+   * and after the call signals that no more exchanges are expected.
+   *
+   * If the transmitter was canceled or timed out, this will wrap [e] in an exception that provides
+   * that additional context. Otherwise [e] is returned as-is.
+   *
+   * @param force true to release the connection even if more exchanges are expected for the call.
+   */
+  private fun <E : IOException?> maybeReleaseConnection(e: E, force: Boolean): E {
+    var result = e
+    val socket: Socket?
+    var releasedConnection: Connection?
+    val callEnd: Boolean
+    synchronized(connectionPool) {
+      check(!force || exchange == null) { "cannot release connection while it is in use" }
+      releasedConnection = this.connection
+      socket = if (this.connection != null && exchange == null && (force || noMoreExchanges)) {
+        releaseConnectionNoEvents()
+      } else {
+        null
+      }
+      if (this.connection != null) releasedConnection = null
+      callEnd = noMoreExchanges && exchange == null
+    }
+    socket?.closeQuietly()
+
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection!!)
+    }
+
+    if (callEnd) {
+      val callFailed = result != null
+      result = timeoutExit(result)
+      if (callFailed) {
+        eventListener.callFailed(call, result!!)
+      } else {
+        eventListener.callEnd(call)
+      }
+    }
+    return result
+  }
+
+  fun canRetry(): Boolean {
+    return exchangeFinder!!.hasStreamFailure() && exchangeFinder!!.hasRouteToTry()
+  }
+
+  fun hasExchange(): Boolean {
+    synchronized(connectionPool) {
+      return exchange != null
+    }
+  }
+
+  /**
+   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
+   * in-flight request from any thread. It's the caller's responsibility to close the request body
+   * and response body streams; otherwise resources may be leaked.
+   *
+   * This method is safe to be called concurrently, but provides limited guarantees. If a transport
+   * layer connection has been established (such as a HTTP/2 stream) that is terminated. Otherwise
+   * if a socket connection is being established, that is terminated.
+   */
+  fun cancel() {
+    val exchangeToCancel: Exchange?
+    val connectionToCancel: RealConnection?
+    synchronized(connectionPool) {
+      canceled = true
+      exchangeToCancel = exchange
+      connectionToCancel = exchangeFinder?.connectingConnection() ?: connection
+    }
+    exchangeToCancel?.cancel() ?: connectionToCancel?.cancel()
+  }
+
+  internal class TransmitterReference(
+    referent: Transmitter,
+    /**
+     * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
+     * identifying the origin of connection leaks.
+     */
+    val callStackTrace: Any?
+  ) : WeakReference<Transmitter>(referent)
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/hostnames.kt b/okhttp/src/main/java/okhttp3/internal/hostnames.kt
new file mode 100644
index 0000000000..611b27339e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/hostnames.kt
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal
+
+import okio.Buffer
+import java.net.IDN
+import java.net.InetAddress
+import java.util.Arrays
+import java.util.Locale
+
+/**
+ * If this is an IP address, this returns the IP address in canonical form.
+ *
+ * Otherwise this performs IDN ToASCII encoding and canonicalize the result to lowercase. For
+ * example this converts `☃.net` to `xn--n3h.net`, and `WwW.GoOgLe.cOm` to `www.google.com`.
+ * `null` will be returned if the host cannot be ToASCII encoded or if the result contains
+ * unsupported ASCII characters.
+ */
+fun String.toCanonicalHost(): String? {
+  val host: String = this
+
+  // If the input contains a :, it’s an IPv6 address.
+  if (":" in host) {
+    // If the input is encased in square braces "[...]", drop 'em.
+    val inetAddress = (if (host.startsWith("[") && host.endsWith("]")) {
+      decodeIpv6(host, 1, host.length - 1)
+    } else {
+      decodeIpv6(host, 0, host.length)
+    }) ?: return null
+    val address = inetAddress.address
+    if (address.size == 16) return inet6AddressToAscii(address)
+    if (address.size == 4) return inetAddress.hostAddress // An IPv4-mapped IPv6 address.
+    throw AssertionError("Invalid IPv6 address: '$host'")
+  }
+
+  try {
+    val result = IDN.toASCII(host).toLowerCase(Locale.US)
+    if (result.isEmpty()) return null
+
+    // Confirm that the IDN ToASCII result doesn't contain any illegal characters.
+    return if (result.containsInvalidHostnameAsciiCodes()) {
+      null
+    } else {
+      result // TODO: implement all label limits.
+    }
+  } catch (_: IllegalArgumentException) {
+    return null
+  }
+}
+
+private fun String.containsInvalidHostnameAsciiCodes(): Boolean {
+  for (i in 0 until length) {
+    val c = this[i]
+    // The WHATWG Host parsing rules accepts some character codes which are invalid by
+    // definition for OkHttp's host header checks (and the WHATWG Host syntax definition). Here
+    // we rule out characters that would cause problems in host headers.
+    if (c <= '\u001f' || c >= '\u007f') {
+      return true
+    }
+    // Check for the characters mentioned in the WHATWG Host parsing spec:
+    // U+0000, U+0009, U+000A, U+000D, U+0020, "#", "%", "/", ":", "?", "@", "[", "\", and "]"
+    // (excluding the characters covered above).
+    if (" #%/:?@[\\]".indexOf(c) != -1) {
+      return true
+    }
+  }
+  return false
+}
+
+/** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
+private fun decodeIpv6(input: String, pos: Int, limit: Int): InetAddress? {
+  val address = ByteArray(16)
+  var b = 0
+  var compress = -1
+  var groupOffset = -1
+
+  var i = pos
+  while (i < limit) {
+    if (b == address.size) return null // Too many groups.
+
+    // Read a delimiter.
+    if (i + 2 <= limit && input.startsWith("::", startIndex = i)) {
+      // Compression "::" delimiter, which is anywhere in the input, including its prefix.
+      if (compress != -1) return null // Multiple "::" delimiters.
+      i += 2
+      b += 2
+      compress = b
+      if (i == limit) break
+    } else if (b != 0) {
+      // Group separator ":" delimiter.
+      if (input.startsWith(":", startIndex = i)) {
+        i++
+      } else if (input.startsWith(".", startIndex = i)) {
+        // If we see a '.', rewind to the beginning of the previous group and parse as IPv4.
+        if (!decodeIpv4Suffix(input, groupOffset, limit, address, b - 2)) return null
+        b += 2 // We rewound two bytes and then added four.
+        break
+      } else {
+        return null // Wrong delimiter.
+      }
+    }
+
+    // Read a group, one to four hex digits.
+    var value = 0
+    groupOffset = i
+    while (i < limit) {
+      val hexDigit = input[i].parseHexDigit()
+      if (hexDigit == -1) break
+      value = (value shl 4) + hexDigit
+      i++
+    }
+    val groupLength = i - groupOffset
+    if (groupLength == 0 || groupLength > 4) return null // Group is the wrong size.
+
+    // We've successfully read a group. Assign its value to our byte array.
+    address[b++] = (value.ushr(8) and 0xff).toByte()
+    address[b++] = (value and 0xff).toByte()
+  }
+
+  // All done. If compression happened, we need to move bytes to the right place in the
+  // address. Here's a sample:
+  //
+  //      input: "1111:2222:3333::7777:8888"
+  //     before: { 11, 11, 22, 22, 33, 33, 00, 00, 77, 77, 88, 88, 00, 00, 00, 00  }
+  //   compress: 6
+  //          b: 10
+  //      after: { 11, 11, 22, 22, 33, 33, 00, 00, 00, 00, 00, 00, 77, 77, 88, 88 }
+  //
+  if (b != address.size) {
+    if (compress == -1) return null // Address didn't have compression or enough groups.
+    System.arraycopy(address, compress, address, address.size - (b - compress), b - compress)
+    Arrays.fill(address, compress, compress + (address.size - b), 0.toByte())
+  }
+
+  return InetAddress.getByAddress(address)
+}
+
+/** Decodes an IPv4 address suffix of an IPv6 address, like 1111::5555:6666:192.168.0.1. */
+private fun decodeIpv4Suffix(
+  input: String,
+  pos: Int,
+  limit: Int,
+  address: ByteArray,
+  addressOffset: Int
+): Boolean {
+  var b = addressOffset
+
+  var i = pos
+  while (i < limit) {
+    if (b == address.size) return false // Too many groups.
+
+    // Read a delimiter.
+    if (b != addressOffset) {
+      if (input[i] != '.') return false // Wrong delimiter.
+      i++
+    }
+
+    // Read 1 or more decimal digits for a value in 0..255.
+    var value = 0
+    val groupOffset = i
+    while (i < limit) {
+      val c = input[i]
+      if (c < '0' || c > '9') break
+      if (value == 0 && groupOffset != i) return false // Reject unnecessary leading '0's.
+      value = value * 10 + c.toInt() - '0'.toInt()
+      if (value > 255) return false // Value out of range.
+      i++
+    }
+    val groupLength = i - groupOffset
+    if (groupLength == 0) return false // No digits.
+
+    // We've successfully read a byte.
+    address[b++] = value.toByte()
+  }
+
+  // Check for too few groups. We wanted exactly four.
+  return b == addressOffset + 4
+}
+
+/** Encodes an IPv6 address in canonical form according to RFC 5952. */
+private fun inet6AddressToAscii(address: ByteArray): String {
+  // Go through the address looking for the longest run of 0s. Each group is 2-bytes.
+  // A run must be longer than one group (section 4.2.2).
+  // If there are multiple equal runs, the first one must be used (section 4.2.3).
+  var longestRunOffset = -1
+  var longestRunLength = 0
+  run {
+    var i = 0
+    while (i < address.size) {
+      val currentRunOffset = i
+      while (i < 16 && address[i].toInt() == 0 && address[i + 1].toInt() == 0) {
+        i += 2
+      }
+      val currentRunLength = i - currentRunOffset
+      if (currentRunLength > longestRunLength && currentRunLength >= 4) {
+        longestRunOffset = currentRunOffset
+        longestRunLength = currentRunLength
+      }
+      i += 2
+    }
+  }
+
+  // Emit each 2-byte group in hex, separated by ':'. The longest run of zeroes is "::".
+  val result = Buffer()
+  var i = 0
+  while (i < address.size) {
+    if (i == longestRunOffset) {
+      result.writeByte(':'.toInt())
+      i += longestRunLength
+      if (i == 16) result.writeByte(':'.toInt())
+    } else {
+      if (i > 0) result.writeByte(':'.toInt())
+      val group = address[i] and 0xff shl 8 or (address[i + 1] and 0xff)
+      result.writeHexadecimalUnsignedLong(group.toLong())
+      i += 2
+    }
+  }
+  return result.readUtf8()
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.kt b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.kt
index cf9abd8524..caf6957ab8 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.kt
@@ -24,7 +24,7 @@ import okhttp3.Response
 import okhttp3.internal.userAgent
 import okio.GzipSource
 
-import okhttp3.internal.Util.hostHeader
+import okhttp3.internal.toHostHeader
 import okio.buffer
 
 /**
@@ -39,7 +39,7 @@ class BridgeInterceptor(private val cookieJar: CookieJar) : Interceptor {
     val userRequest = chain.request()
     val requestBuilder = userRequest.newBuilder()
 
-    val body = userRequest.body()
+    val body = userRequest.body
     if (body != null) {
       val contentType = body.contentType()
       if (contentType != null) {
@@ -57,7 +57,7 @@ class BridgeInterceptor(private val cookieJar: CookieJar) : Interceptor {
     }
 
     if (userRequest.header("Host") == null) {
-      requestBuilder.header("Host", hostHeader(userRequest.url(), false))
+      requestBuilder.header("Host", userRequest.url.toHostHeader())
     }
 
     if (userRequest.header("Connection") == null) {
@@ -72,7 +72,7 @@ class BridgeInterceptor(private val cookieJar: CookieJar) : Interceptor {
       requestBuilder.header("Accept-Encoding", "gzip")
     }
 
-    val cookies = cookieJar.loadForRequest(userRequest.url())
+    val cookies = cookieJar.loadForRequest(userRequest.url)
     if (cookies.isNotEmpty()) {
       requestBuilder.header("Cookie", cookieHeader(cookies))
     }
@@ -83,18 +83,18 @@ class BridgeInterceptor(private val cookieJar: CookieJar) : Interceptor {
 
     val networkResponse = chain.proceed(requestBuilder.build())
 
-    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers())
+    cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)
 
     val responseBuilder = networkResponse.newBuilder()
         .request(userRequest)
 
     if (transparentGzip &&
         "gzip".equals(networkResponse.header("Content-Encoding"), ignoreCase = true) &&
-        HttpHeaders.hasBody(networkResponse)) {
-      val responseBody = networkResponse.body()
+        networkResponse.promisesBody()) {
+      val responseBody = networkResponse.body
       if (responseBody != null) {
         val gzipSource = GzipSource(responseBody.source())
-        val strippedHeaders = networkResponse.headers().newBuilder()
+        val strippedHeaders = networkResponse.headers.newBuilder()
             .removeAll("Content-Encoding")
             .removeAll("Content-Length")
             .build()
@@ -107,11 +107,11 @@ class BridgeInterceptor(private val cookieJar: CookieJar) : Interceptor {
     return responseBuilder.build()
   }
 
-  /** Returns a 'Cookie' HTTP request header with all cookies, like `a=b; c=d`.  */
+  /** Returns a 'Cookie' HTTP request header with all cookies, like `a=b; c=d`. */
   private fun cookieHeader(cookies: List<Cookie>): String = buildString {
     cookies.forEachIndexed { index, cookie ->
       if (index > 0) append("; ")
-      append(cookie.name()).append('=').append(cookie.value())
+      append(cookie.name).append('=').append(cookie.value)
     }
   }
-}
\ No newline at end of file
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.kt b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.kt
index 8ed82671a1..474970e881 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.kt
@@ -17,12 +17,12 @@ package okhttp3.internal.http
 
 import okhttp3.Interceptor
 import okhttp3.Response
-import okhttp3.internal.Util
+import okhttp3.internal.EMPTY_RESPONSE
 import okio.buffer
 import java.io.IOException
 import java.net.ProtocolException
 
-/** This is the last interceptor in the chain. It makes a network call to the server.  */
+/** This is the last interceptor in the chain. It makes a network call to the server. */
 class CallServerInterceptor(private val forWebSocket: Boolean) : Interceptor {
 
   @Throws(IOException::class)
@@ -30,14 +30,14 @@ class CallServerInterceptor(private val forWebSocket: Boolean) : Interceptor {
     val realChain = chain as RealInterceptorChain
     val exchange = realChain.exchange()
     val request = realChain.request()
-    val requestBody = request.body()
+    val requestBody = request.body
     val sentRequestMillis = System.currentTimeMillis()
 
     exchange.writeRequestHeaders(request)
 
     var responseHeadersStarted = false
     var responseBuilder: Response.Builder? = null
-    if (HttpMethod.permitsRequestBody(request.method()) && requestBody != null) {
+    if (HttpMethod.permitsRequestBody(request.method) && requestBody != null) {
       // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
       // Continue" response before transmitting the request body. If we don't get that, return
       // what we did get (such as a 4xx response) without ever transmitting the request body.
@@ -61,7 +61,7 @@ class CallServerInterceptor(private val forWebSocket: Boolean) : Interceptor {
         }
       } else {
         exchange.noRequestBody()
-        if (!exchange.connection().isMultiplexed) {
+        if (!exchange.connection()!!.isMultiplexed) {
           // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
           // from being reused. Otherwise we're still obligated to transmit the request body to
           // leave the connection in a consistent state.
@@ -83,21 +83,21 @@ class CallServerInterceptor(private val forWebSocket: Boolean) : Interceptor {
     }
     var response = responseBuilder
         .request(request)
-        .handshake(exchange.connection().handshake())
+        .handshake(exchange.connection()!!.handshake())
         .sentRequestAtMillis(sentRequestMillis)
         .receivedResponseAtMillis(System.currentTimeMillis())
         .build()
-    var code = response.code()
+    var code = response.code
     if (code == 100) {
       // server sent a 100-continue even though we did not request one.
       // try again to read the actual response
       response = exchange.readResponseHeaders(false)!!
           .request(request)
-          .handshake(exchange.connection().handshake())
+          .handshake(exchange.connection()!!.handshake())
           .sentRequestAtMillis(sentRequestMillis)
           .receivedResponseAtMillis(System.currentTimeMillis())
           .build()
-      code = response.code()
+      code = response.code
     }
 
     exchange.responseHeadersEnd(response)
@@ -105,20 +105,20 @@ class CallServerInterceptor(private val forWebSocket: Boolean) : Interceptor {
     response = if (forWebSocket && code == 101) {
       // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
       response.newBuilder()
-          .body(Util.EMPTY_RESPONSE)
+          .body(EMPTY_RESPONSE)
           .build()
     } else {
       response.newBuilder()
           .body(exchange.openResponseBody(response))
           .build()
     }
-    if ("close".equals(response.request().header("Connection"), ignoreCase = true) ||
+    if ("close".equals(response.request.header("Connection"), ignoreCase = true) ||
         "close".equals(response.header("Connection"), ignoreCase = true)) {
       exchange.noNewExchangesOnConnection()
     }
-    if ((code == 204 || code == 205) && response.body()?.contentLength() ?: -1 > 0) {
+    if ((code == 204 || code == 205) && response.body?.contentLength() ?: -1L > 0L) {
       throw ProtocolException(
-          "HTTP $code had non-zero Content-Length: ${response.body()?.contentLength()}")
+          "HTTP $code had non-zero Content-Length: ${response.body?.contentLength()}")
     }
     return response
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/ExchangeCode.kt b/okhttp/src/main/java/okhttp3/internal/http/ExchangeCode.kt
index b0c3e2e77a..30bca16e89 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/ExchangeCode.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/ExchangeCode.kt
@@ -23,25 +23,25 @@ import okhttp3.internal.connection.RealConnection
 import okio.Sink
 import okio.Source
 
-/** Encodes HTTP requests and decodes HTTP responses.  */
+/** Encodes HTTP requests and decodes HTTP responses. */
 interface ExchangeCodec {
 
-  /** Returns the connection that carries this codec.  */
+  /** Returns the connection that carries this codec. */
   fun connection(): RealConnection?
 
-  /** Returns an output stream where the request body can be streamed.  */
+  /** Returns an output stream where the request body can be streamed. */
   @Throws(IOException::class)
   fun createRequestBody(request: Request, contentLength: Long): Sink
 
-  /** This should update the HTTP engine's sentRequestMillis field.  */
+  /** This should update the HTTP engine's sentRequestMillis field. */
   @Throws(IOException::class)
   fun writeRequestHeaders(request: Request)
 
-  /** Flush the request to the underlying socket.  */
+  /** Flush the request to the underlying socket. */
   @Throws(IOException::class)
   fun flushRequest()
 
-  /** Flush the request to the underlying socket and signal no more bytes will be transmitted.  */
+  /** Flush the request to the underlying socket and signal no more bytes will be transmitted. */
   @Throws(IOException::class)
   fun finishRequest()
 
@@ -60,7 +60,7 @@ interface ExchangeCodec {
   @Throws(IOException::class)
   fun openResponseBodySource(response: Response): Source
 
-  /** Returns the trailers after the HTTP response. May be empty.  */
+  /** Returns the trailers after the HTTP response. May be empty. */
   @Throws(IOException::class)
   fun trailers(): Headers
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpDate.kt b/okhttp/src/main/java/okhttp3/internal/http/HttpDate.kt
deleted file mode 100644
index cd879d078e..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpDate.kt
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http
-
-import okhttp3.internal.Util.UTC
-import java.text.DateFormat
-import java.text.ParsePosition
-import java.text.SimpleDateFormat
-import java.util.Locale
-import java.util.Date
-
-/**
- * Best-effort parser for HTTP dates.
- */
-object HttpDate {
-  /** The last four-digit year: "Fri, 31 Dec 9999 23:59:59 GMT".  */
-  const val MAX_DATE = 253402300799999L
-
-  /**
-   * Most websites serve cookies in the blessed format. Eagerly create the parser to ensure such
-   * cookies are on the fast path.
-   */
-  private val STANDARD_DATE_FORMAT = object : ThreadLocal<DateFormat>() {
-    override fun initialValue(): DateFormat {
-      // Date format specified by RFC 7231 section 7.1.1.1.
-      return SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US).apply {
-        isLenient = false
-        timeZone = UTC
-      }
-    }
-  }
-
-  /** If we fail to parse a date in a non-standard format, try each of these formats in sequence.  */
-  private val BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS = arrayOf(
-      // HTTP formats required by RFC2616 but with any timezone.
-      "EEE, dd MMM yyyy HH:mm:ss zzz", // RFC 822, updated by RFC 1123 with any TZ
-      "EEEE, dd-MMM-yy HH:mm:ss zzz", // RFC 850, obsoleted by RFC 1036 with any TZ.
-      "EEE MMM d HH:mm:ss yyyy", // ANSI C's asctime() format
-      // Alternative formats.
-      "EEE, dd-MMM-yyyy HH:mm:ss z",
-      "EEE, dd-MMM-yyyy HH-mm-ss z",
-      "EEE, dd MMM yy HH:mm:ss z",
-      "EEE dd-MMM-yyyy HH:mm:ss z",
-      "EEE dd MMM yyyy HH:mm:ss z",
-      "EEE dd-MMM-yyyy HH-mm-ss z",
-      "EEE dd-MMM-yy HH:mm:ss z",
-      "EEE dd MMM yy HH:mm:ss z",
-      "EEE,dd-MMM-yy HH:mm:ss z",
-      "EEE,dd-MMM-yyyy HH:mm:ss z",
-      "EEE, dd-MM-yyyy HH:mm:ss z",
-
-      /* RI bug 6641315 claims a cookie of this format was once served by www.yahoo.com */
-      "EEE MMM d yyyy HH:mm:ss z"
-  )
-
-  private val BROWSER_COMPATIBLE_DATE_FORMATS = arrayOfNulls<DateFormat>(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.size)
-
-  /** Returns the date for [value]. Returns null if the value couldn't be parsed.  */
-  @JvmStatic
-  fun parse(value: String): Date? {
-    if (value.isEmpty()) {
-      return null
-    }
-
-    val position = ParsePosition(0)
-    var result = STANDARD_DATE_FORMAT.get().parse(value, position)
-    if (position.index == value.length) {
-      // STANDARD_DATE_FORMAT must match exactly; all text must be consumed, e.g. no ignored
-      // non-standard trailing "+01:00". Those cases are covered below.
-      return result
-    }
-    synchronized(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS) {
-      for (i in 0 until BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.size) {
-        var format: DateFormat? = BROWSER_COMPATIBLE_DATE_FORMATS[i]
-        if (format == null) {
-          format = SimpleDateFormat(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS[i], Locale.US).apply {
-            // Set the timezone to use when interpreting formats that don't have a timezone. GMT is
-            // specified by RFC 7231.
-            timeZone = UTC
-          }
-          BROWSER_COMPATIBLE_DATE_FORMATS[i] = format
-        }
-        position.index = 0
-        result = format.parse(value, position)
-        if (position.index != 0) {
-          // Something was parsed. It's possible the entire string was not consumed but we ignore
-          // that. If any of the BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS ended in "'GMT'" we'd have
-          // to also check that position.getIndex() == value.length() otherwise parsing might have
-          // terminated early, ignoring things like "+01:00". Leaving this as != 0 means that any
-          // trailing junk is ignored.
-          return result
-        }
-      }
-    }
-    return null
-  }
-
-  /** Returns the string for [value].  */
-  @JvmStatic
-  fun format(value: Date): String {
-    return STANDARD_DATE_FORMAT.get().format(value)
-  }
-}
\ No newline at end of file
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
deleted file mode 100644
index 5e82d187a3..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
+++ /dev/null
@@ -1,401 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.EOFException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-import java.util.TreeSet;
-import okhttp3.Challenge;
-import okhttp3.Cookie;
-import okhttp3.CookieJar;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.platform.Platform;
-import okio.Buffer;
-import okio.ByteString;
-
-import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
-import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
-import static okhttp3.internal.Util.EMPTY_HEADERS;
-import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
-
-/** Headers and utilities for internal use by OkHttp. */
-public final class HttpHeaders {
-  private static final ByteString QUOTED_STRING_DELIMITERS = ByteString.encodeUtf8("\"\\");
-  private static final ByteString TOKEN_DELIMITERS = ByteString.encodeUtf8("\t ,=");
-
-  private HttpHeaders() {
-  }
-
-  public static long contentLength(Response response) {
-    return contentLength(response.headers());
-  }
-
-  public static long contentLength(Headers headers) {
-    return stringToLong(headers.get("Content-Length"));
-  }
-
-  private static long stringToLong(String s) {
-    if (s == null) return -1;
-    try {
-      return Long.parseLong(s);
-    } catch (NumberFormatException e) {
-      return -1;
-    }
-  }
-
-  /**
-   * Returns true if none of the Vary headers have changed between {@code cachedRequest} and {@code
-   * newRequest}.
-   */
-  public static boolean varyMatches(
-      Response cachedResponse, Headers cachedRequest, Request newRequest) {
-    for (String field : varyFields(cachedResponse)) {
-      if (!Objects.equals(cachedRequest.values(field), newRequest.headers(field))) return false;
-    }
-    return true;
-  }
-
-  /**
-   * Returns true if a Vary header contains an asterisk. Such responses cannot be cached.
-   */
-  public static boolean hasVaryAll(Response response) {
-    return hasVaryAll(response.headers());
-  }
-
-  /**
-   * Returns true if a Vary header contains an asterisk. Such responses cannot be cached.
-   */
-  public static boolean hasVaryAll(Headers responseHeaders) {
-    return varyFields(responseHeaders).contains("*");
-  }
-
-  private static Set<String> varyFields(Response response) {
-    return varyFields(response.headers());
-  }
-
-  /**
-   * Returns the names of the request headers that need to be checked for equality when caching.
-   */
-  public static Set<String> varyFields(Headers responseHeaders) {
-    Set<String> result = Collections.emptySet();
-    for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-      if (!"Vary".equalsIgnoreCase(responseHeaders.name(i))) continue;
-
-      String value = responseHeaders.value(i);
-      if (result.isEmpty()) {
-        result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
-      }
-      for (String varyField : value.split(",")) {
-        result.add(varyField.trim());
-      }
-    }
-    return result;
-  }
-
-  /**
-   * Returns the subset of the headers in {@code response}'s request that impact the content of
-   * response's body.
-   */
-  public static Headers varyHeaders(Response response) {
-    // Use the request headers sent over the network, since that's what the
-    // response varies on. Otherwise OkHttp-supplied headers like
-    // "Accept-Encoding: gzip" may be lost.
-    Headers requestHeaders = response.networkResponse().request().headers();
-    Headers responseHeaders = response.headers();
-    return varyHeaders(requestHeaders, responseHeaders);
-  }
-
-  /**
-   * Returns the subset of the headers in {@code requestHeaders} that impact the content of
-   * response's body.
-   */
-  public static Headers varyHeaders(Headers requestHeaders, Headers responseHeaders) {
-    Set<String> varyFields = varyFields(responseHeaders);
-    if (varyFields.isEmpty()) return EMPTY_HEADERS;
-
-    Headers.Builder result = new Headers.Builder();
-    for (int i = 0, size = requestHeaders.size(); i < size; i++) {
-      String fieldName = requestHeaders.name(i);
-      if (varyFields.contains(fieldName)) {
-        result.add(fieldName, requestHeaders.value(i));
-      }
-    }
-    return result.build();
-  }
-
-  /**
-   * Parse RFC 7235 challenges. This is awkward because we need to look ahead to know how to
-   * interpret a token.
-   *
-   * <p>For example, the first line has a parameter name/value pair and the second line has a single
-   * token68:
-   *
-   * <pre>   {@code
-   *
-   *   WWW-Authenticate: Digest foo=bar
-   *   WWW-Authenticate: Digest foo=
-   * }</pre>
-   *
-   * <p>Similarly, the first line has one challenge and the second line has two challenges:
-   *
-   * <pre>   {@code
-   *
-   *   WWW-Authenticate: Digest ,foo=bar
-   *   WWW-Authenticate: Digest ,foo
-   * }</pre>
-   */
-  public static List<Challenge> parseChallenges(Headers responseHeaders, String headerName) {
-    List<Challenge> result = new ArrayList<>();
-    for (int h = 0; h < responseHeaders.size(); h++) {
-      if (headerName.equalsIgnoreCase(responseHeaders.name(h))) {
-        Buffer header = new Buffer().writeUtf8(responseHeaders.value(h));
-        try {
-          parseChallengeHeader(result, header);
-        } catch (EOFException e) {
-          Platform.get().log(Platform.WARN, "Unable to parse challenge", e);
-        }
-      }
-    }
-    return result;
-  }
-
-  private static void parseChallengeHeader(List<Challenge> result, Buffer header)
-      throws EOFException {
-    String peek = null;
-
-    while (true) {
-      // Read a scheme name for this challenge if we don't have one already.
-      if (peek == null) {
-        skipWhitespaceAndCommas(header);
-        peek = readToken(header);
-        if (peek == null) return;
-      }
-
-      String schemeName = peek;
-
-      // Read a token68, a sequence of parameters, or nothing.
-      boolean commaPrefixed = skipWhitespaceAndCommas(header);
-      peek = readToken(header);
-      if (peek == null) {
-        if (!header.exhausted()) return; // Expected a token; got something else.
-        result.add(new Challenge(schemeName, Collections.emptyMap()));
-        return;
-      }
-
-      int eqCount = skipAll(header, (byte) '=');
-      boolean commaSuffixed = skipWhitespaceAndCommas(header);
-
-      // It's a token68 because there isn't a value after it.
-      if (!commaPrefixed && (commaSuffixed || header.exhausted())) {
-        result.add(new Challenge(schemeName, Collections.singletonMap(
-            null, peek + repeat('=', eqCount))));
-        peek = null;
-        continue;
-      }
-
-      // It's a series of parameter names and values.
-      Map<String, String> parameters = new LinkedHashMap<>();
-      eqCount += skipAll(header, (byte) '=');
-      while (true) {
-        if (peek == null) {
-          peek = readToken(header);
-          if (skipWhitespaceAndCommas(header)) break; // We peeked a scheme name followed by ','.
-          eqCount = skipAll(header, (byte) '=');
-        }
-        if (eqCount == 0) break; // We peeked a scheme name.
-        if (eqCount > 1) return; // Unexpected '=' characters.
-        if (skipWhitespaceAndCommas(header)) return; // Unexpected ','.
-
-        String parameterValue = !header.exhausted() && header.getByte(0) == '"'
-            ? readQuotedString(header)
-            : readToken(header);
-        if (parameterValue == null) return; // Expected a value.
-        String replaced = parameters.put(peek, parameterValue);
-        peek = null;
-        if (replaced != null) return; // Unexpected duplicate parameter.
-        if (!skipWhitespaceAndCommas(header) && !header.exhausted()) return; // Expected ',' or EOF.
-      }
-      result.add(new Challenge(schemeName, parameters));
-    }
-  }
-
-  /** Returns true if any commas were skipped. */
-  private static boolean skipWhitespaceAndCommas(Buffer buffer) throws EOFException {
-    boolean commaFound = false;
-    while (!buffer.exhausted()) {
-      byte b = buffer.getByte(0);
-      if (b == ',') {
-        // Consume ','.
-        buffer.readByte();
-        commaFound = true;
-      } else if (b == ' ' || b == '\t') {
-        // Consume space or tab.
-        buffer.readByte();
-      } else {
-        break;
-      }
-    }
-    return commaFound;
-  }
-
-  private static int skipAll(Buffer buffer, byte b) throws EOFException {
-    int count = 0;
-    while (!buffer.exhausted() && buffer.getByte(0) == b) {
-      count++;
-      buffer.readByte();
-    }
-    return count;
-  }
-
-  /**
-   * Reads a double-quoted string, unescaping quoted pairs like {@code \"} to the 2nd character in
-   * each sequence. Returns the unescaped string, or null if the buffer isn't prefixed with a
-   * double-quoted string.
-   */
-  private static String readQuotedString(Buffer buffer) throws EOFException {
-    if (buffer.readByte() != '\"') throw new IllegalArgumentException();
-    Buffer result = new Buffer();
-    while (true) {
-      long i = buffer.indexOfElement(QUOTED_STRING_DELIMITERS);
-      if (i == -1L) return null; // Unterminated quoted string.
-
-      if (buffer.getByte(i) == '"') {
-        result.write(buffer, i);
-        // Consume '"'.
-        buffer.readByte();
-        return result.readUtf8();
-      }
-
-      if (buffer.size() == i + 1L) return null; // Dangling escape.
-      result.write(buffer, i);
-      // Consume '\'.
-      buffer.readByte();
-      result.write(buffer, 1L); // The escaped character.
-    }
-  }
-
-  /**
-   * Consumes and returns a non-empty token, terminating at special characters in {@link
-   * #TOKEN_DELIMITERS}. Returns null if the buffer is empty or prefixed with a delimiter.
-   */
-  private static String readToken(Buffer buffer) {
-    try {
-      long tokenSize = buffer.indexOfElement(TOKEN_DELIMITERS);
-      if (tokenSize == -1L) tokenSize = buffer.size();
-
-      return tokenSize != 0L
-          ? buffer.readUtf8(tokenSize)
-          : null;
-    } catch (EOFException e) {
-      throw new AssertionError();
-    }
-  }
-
-  private static String repeat(char c, int count) {
-    char[] array = new char[count];
-    Arrays.fill(array, c);
-    return new String(array);
-  }
-
-  public static void receiveHeaders(CookieJar cookieJar, HttpUrl url, Headers headers) {
-    if (cookieJar == CookieJar.NO_COOKIES) return;
-
-    List<Cookie> cookies = Cookie.parseAll(url, headers);
-    if (cookies.isEmpty()) return;
-
-    cookieJar.saveFromResponse(url, cookies);
-  }
-
-  /** Returns true if the response must have a (possibly 0-length) body. See RFC 7231. */
-  public static boolean hasBody(Response response) {
-    // HEAD requests never yield a body regardless of the response headers.
-    if (response.request().method().equals("HEAD")) {
-      return false;
-    }
-
-    int responseCode = response.code();
-    if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
-        && responseCode != HTTP_NO_CONTENT
-        && responseCode != HTTP_NOT_MODIFIED) {
-      return true;
-    }
-
-    // If the Content-Length or Transfer-Encoding headers disagree with the response code, the
-    // response is malformed. For best compatibility, we honor the headers.
-    if (contentLength(response) != -1
-        || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      return true;
-    }
-
-    return false;
-  }
-
-  /**
-   * Returns the next index in {@code input} at or after {@code pos} that contains a character from
-   * {@code characters}. Returns the input length if none of the requested characters can be found.
-   */
-  public static int skipUntil(String input, int pos, String characters) {
-    for (; pos < input.length(); pos++) {
-      if (characters.indexOf(input.charAt(pos)) != -1) {
-        break;
-      }
-    }
-    return pos;
-  }
-
-  /**
-   * Returns the next non-whitespace character in {@code input} that is white space. Result is
-   * undefined if input contains newline characters.
-   */
-  public static int skipWhitespace(String input, int pos) {
-    for (; pos < input.length(); pos++) {
-      char c = input.charAt(pos);
-      if (c != ' ' && c != '\t') {
-        break;
-      }
-    }
-    return pos;
-  }
-
-  /**
-   * Returns {@code value} as a positive integer, or 0 if it is negative, or {@code defaultValue} if
-   * it cannot be parsed.
-   */
-  public static int parseSeconds(String value, int defaultValue) {
-    try {
-      long seconds = Long.parseLong(value);
-      if (seconds > Integer.MAX_VALUE) {
-        return Integer.MAX_VALUE;
-      } else if (seconds < 0) {
-        return 0;
-      } else {
-        return (int) seconds;
-      }
-    } catch (NumberFormatException e) {
-      return defaultValue;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt
new file mode 100644
index 0000000000..b9cf66e682
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.kt
@@ -0,0 +1,243 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@file:JvmName("HttpHeaders")
+
+package okhttp3.internal.http
+
+import okhttp3.Challenge
+import okhttp3.Cookie
+import okhttp3.CookieJar
+import okhttp3.Headers
+import okhttp3.HttpUrl
+import okhttp3.Response
+import okhttp3.internal.headersContentLength
+import okhttp3.internal.http.StatusLine.Companion.HTTP_CONTINUE
+import okhttp3.internal.platform.Platform
+import okhttp3.internal.skipAll
+import okio.Buffer
+import okio.ByteString.Companion.encodeUtf8
+import java.io.EOFException
+import java.net.HttpURLConnection.HTTP_NOT_MODIFIED
+import java.net.HttpURLConnection.HTTP_NO_CONTENT
+import java.util.Collections
+
+private val QUOTED_STRING_DELIMITERS = "\"\\".encodeUtf8()
+private val TOKEN_DELIMITERS = "\t ,=".encodeUtf8()
+
+/**
+ * Parse RFC 7235 challenges. This is awkward because we need to look ahead to know how to
+ * interpret a token.
+ *
+ * For example, the first line has a parameter name/value pair and the second line has a single
+ * token68:
+ *
+ * ```
+ * WWW-Authenticate: Digest foo=bar
+ * WWW-Authenticate: Digest foo=
+ * ```
+ *
+ * Similarly, the first line has one challenge and the second line has two challenges:
+ *
+ * ```
+ * WWW-Authenticate: Digest ,foo=bar
+ * WWW-Authenticate: Digest ,foo
+ * ```
+ */
+fun Headers.parseChallenges(headerName: String): List<Challenge> {
+  val result = mutableListOf<Challenge>()
+  for (h in 0 until size) {
+    if (headerName.equals(name(h), ignoreCase = true)) {
+      val header = Buffer().writeUtf8(value(h))
+      try {
+        header.readChallengeHeader(result)
+      } catch (e: EOFException) {
+        Platform.get().log(Platform.WARN, "Unable to parse challenge", e)
+      }
+    }
+  }
+  return result
+}
+
+@Throws(EOFException::class)
+private fun Buffer.readChallengeHeader(result: MutableList<Challenge>) {
+  var peek: String? = null
+
+  while (true) {
+    // Read a scheme name for this challenge if we don't have one already.
+    if (peek == null) {
+      skipCommasAndWhitespace()
+      peek = readToken()
+      if (peek == null) return
+    }
+
+    val schemeName = peek
+
+    // Read a token68, a sequence of parameters, or nothing.
+    val commaPrefixed = skipCommasAndWhitespace()
+    peek = readToken()
+    if (peek == null) {
+      if (!exhausted()) return // Expected a token; got something else.
+      result.add(Challenge(schemeName, emptyMap()))
+      return
+    }
+
+    var eqCount = skipAll('='.toByte())
+    val commaSuffixed = skipCommasAndWhitespace()
+
+    // It's a token68 because there isn't a value after it.
+    if (!commaPrefixed && (commaSuffixed || exhausted())) {
+      result.add(Challenge(schemeName,
+          Collections.singletonMap<String, String>(null, peek + "=".repeat(eqCount))))
+      peek = null
+      continue
+    }
+
+    // It's a series of parameter names and values.
+    val parameters = mutableMapOf<String?, String>()
+    eqCount += skipAll('='.toByte())
+    while (true) {
+      if (peek == null) {
+        peek = readToken()
+        if (skipCommasAndWhitespace()) break // We peeked a scheme name followed by ','.
+        eqCount = skipAll('='.toByte())
+      }
+      if (eqCount == 0) break // We peeked a scheme name.
+      if (eqCount > 1) return // Unexpected '=' characters.
+      if (skipCommasAndWhitespace()) return // Unexpected ','.
+
+      val parameterValue = when {
+        startsWith('"'.toByte()) -> readQuotedString()
+        else -> readToken()
+      } ?: return // Expected a value.
+
+      val replaced = parameters.put(peek, parameterValue)
+      peek = null
+      if (replaced != null) return // Unexpected duplicate parameter.
+      if (!skipCommasAndWhitespace() && !exhausted()) return // Expected ',' or EOF.
+    }
+    result.add(Challenge(schemeName, parameters))
+  }
+}
+
+/** Returns true if any commas were skipped. */
+private fun Buffer.skipCommasAndWhitespace(): Boolean {
+  var commaFound = false
+  loop@ while (!exhausted()) {
+    when (this[0]) {
+      ','.toByte() -> {
+        // Consume ','.
+        readByte()
+        commaFound = true
+      }
+
+      ' '.toByte(), '\t'.toByte() -> {
+        readByte()
+        // Consume space or tab.
+      }
+
+      else -> break@loop
+    }
+  }
+  return commaFound
+}
+
+private fun Buffer.startsWith(prefix: Byte) = !exhausted() && this[0] == prefix
+
+/**
+ * Reads a double-quoted string, unescaping quoted pairs like `\"` to the 2nd character in each
+ * sequence. Returns the unescaped string, or null if the buffer isn't prefixed with a
+ * double-quoted string.
+ */
+@Throws(EOFException::class)
+private fun Buffer.readQuotedString(): String? {
+  require(readByte() == '\"'.toByte())
+  val result = Buffer()
+  while (true) {
+    val i = indexOfElement(QUOTED_STRING_DELIMITERS)
+    if (i == -1L) return null // Unterminated quoted string.
+
+    if (this[i] == '"'.toByte()) {
+      result.write(this, i)
+      // Consume '"'.
+      readByte()
+      return result.readUtf8()
+    }
+
+    if (size == i + 1L) return null // Dangling escape.
+    result.write(this, i)
+    // Consume '\'.
+    readByte()
+    result.write(this, 1L) // The escaped character.
+  }
+}
+
+/**
+ * Consumes and returns a non-empty token, terminating at special characters in
+ * [TOKEN_DELIMITERS]. Returns null if the buffer is empty or prefixed with a delimiter.
+ */
+private fun Buffer.readToken(): String? {
+  var tokenSize = indexOfElement(TOKEN_DELIMITERS)
+  if (tokenSize == -1L) tokenSize = size
+
+  return when {
+    tokenSize != 0L -> readUtf8(tokenSize)
+    else -> null
+  }
+}
+
+fun CookieJar.receiveHeaders(url: HttpUrl, headers: Headers) {
+  if (this === CookieJar.NO_COOKIES) return
+
+  val cookies = Cookie.parseAll(url, headers)
+  if (cookies.isEmpty()) return
+
+  saveFromResponse(url, cookies)
+}
+
+/**
+ * Returns true if the response headers and status indicate that this response has a (possibly
+ * 0-length) body. See RFC 7231.
+ */
+fun Response.promisesBody(): Boolean {
+  // HEAD requests never yield a body regardless of the response headers.
+  if (request.method == "HEAD") {
+    return false
+  }
+
+  val responseCode = code
+  if ((responseCode < HTTP_CONTINUE || responseCode >= 200) &&
+      responseCode != HTTP_NO_CONTENT &&
+      responseCode != HTTP_NOT_MODIFIED) {
+    return true
+  }
+
+  // If the Content-Length or Transfer-Encoding headers disagree with the response code, the
+  // response is malformed. For best compatibility, we honor the headers.
+  if (headersContentLength() != -1L ||
+      "chunked".equals(header("Transfer-Encoding"), ignoreCase = true)) {
+    return true
+  }
+
+  return false
+}
+
+@Deprecated(
+    message = "No longer supported",
+    level = DeprecationLevel.ERROR,
+    replaceWith = ReplaceWith(expression = "response.promisesBody()"))
+fun hasBody(response: Response): Boolean {
+  return response.promisesBody()
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.kt b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.kt
index b4516822fd..a031cf3f5b 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.kt
@@ -16,29 +16,26 @@
 package okhttp3.internal.http
 
 object HttpMethod {
-  @JvmStatic
   fun invalidatesCache(method: String): Boolean = (method == "POST" ||
       method == "PATCH" ||
       method == "PUT" ||
       method == "DELETE" ||
       method == "MOVE") // WebDAV
 
-  @JvmStatic
+  @JvmStatic // Despite being 'internal', this method is called by popular 3rd party SDKs.
   fun requiresRequestBody(method: String): Boolean = (method == "POST" ||
       method == "PUT" ||
       method == "PATCH" ||
       method == "PROPPATCH" || // WebDAV
       method == "REPORT") // CalDAV/CardDAV (defined in WebDAV Versioning)
 
-  @JvmStatic
+  @JvmStatic // Despite being 'internal', this method is called by popular 3rd party SDKs.
   fun permitsRequestBody(method: String): Boolean = !(method == "GET" || method == "HEAD")
 
-  @JvmStatic
   fun redirectsWithBody(method: String): Boolean =
       // (WebDAV) redirects should also maintain the request body
       method == "PROPFIND"
 
-  @JvmStatic
   fun redirectsToGet(method: String): Boolean =
       // All requests but PROPFIND should redirect to a GET request.
       method != "PROPFIND"
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.kt b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.kt
index ec93ba8ab4..157324d662 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.kt
@@ -15,12 +15,12 @@
  */
 package okhttp3.internal.http
 
-import okhttp3.Interceptor
-import okhttp3.Request
 import okhttp3.Call
 import okhttp3.Connection
+import okhttp3.Interceptor
+import okhttp3.Request
 import okhttp3.Response
-import okhttp3.internal.Util.checkDuration
+import okhttp3.internal.checkDuration
 import okhttp3.internal.connection.Exchange
 import okhttp3.internal.connection.Transmitter
 import java.io.IOException
@@ -77,10 +77,7 @@ class RealInterceptorChain(
 
   fun transmitter(): Transmitter = transmitter
 
-  fun exchange(): Exchange {
-    if (exchange == null) throw IllegalStateException()
-    return exchange
-  }
+  fun exchange(): Exchange = exchange!!
 
   override fun call(): Call = call
 
@@ -97,15 +94,13 @@ class RealInterceptorChain(
     calls++
 
     // If we already have a stream, confirm that the incoming request will use it.
-    if (this.exchange != null && !this.exchange.connection().supportsUrl(request.url())) {
-      throw IllegalStateException("network interceptor " + interceptors[index - 1] +
-          " must retain the same host and port")
+    check(this.exchange == null || this.exchange.connection()!!.supportsUrl(request.url)) {
+      "network interceptor ${interceptors[index - 1]} must retain the same host and port"
     }
 
     // If we already have a stream, confirm that this is the only call to chain.proceed().
-    if (this.exchange != null && calls > 1) {
-      throw IllegalStateException("network interceptor " + interceptors[index - 1] +
-          " must call proceed() exactly once")
+    check(this.exchange == null || calls <= 1) {
+      "network interceptor ${interceptors[index - 1]} must call proceed() exactly once"
     }
 
     // Call the next interceptor in the chain.
@@ -118,15 +113,11 @@ class RealInterceptorChain(
         "interceptor $interceptor returned null")
 
     // Confirm that the next interceptor made its required call to chain.proceed().
-    if (exchange != null && index + 1 < interceptors.size && next.calls != 1) {
-      throw IllegalStateException("network interceptor " + interceptor +
-          " must call proceed() exactly once")
+    check(exchange == null || index + 1 >= interceptors.size || next.calls == 1) {
+      "network interceptor $interceptor must call proceed() exactly once"
     }
 
-    if (response.body() == null) {
-      throw IllegalStateException(
-          "interceptor $interceptor returned a response with no body")
-    }
+    check(response.body != null) { "interceptor $interceptor returned a response with no body" }
 
     return response
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.kt b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.kt
index f27f56be66..78a0d73980 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.kt
@@ -16,6 +16,7 @@
 package okhttp3.internal.http
 
 import okhttp3.MediaType
+import okhttp3.MediaType.Companion.toMediaTypeOrNull
 import okhttp3.ResponseBody
 import okio.BufferedSource
 
@@ -31,13 +32,7 @@ class RealResponseBody(
 
   override fun contentLength(): Long = contentLength
 
-  override fun contentType(): MediaType? {
-    return if (contentTypeString != null) {
-      MediaType.parse(contentTypeString)
-    } else {
-      null
-    }
-  }
+  override fun contentType(): MediaType? = contentTypeString?.toMediaTypeOrNull()
 
   override fun source(): BufferedSource = source
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.kt b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.kt
index 6b18e2bb90..068c86f50d 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.kt
@@ -15,10 +15,10 @@
  */
 package okhttp3.internal.http
 
-import java.net.HttpURLConnection
-import java.net.Proxy
 import okhttp3.HttpUrl
 import okhttp3.Request
+import java.net.HttpURLConnection
+import java.net.Proxy
 
 object RequestLine {
 
@@ -27,27 +27,21 @@ object RequestLine {
    * [HttpURLConnection.getHeaderFields], so it needs to be set even if the transport is
    * HTTP/2.
    */
-  @JvmStatic
-  fun get(request: Request, proxyType: Proxy.Type): String {
-    val result = StringBuilder()
-    result.append(request.method())
-    result.append(' ')
-
+  fun get(request: Request, proxyType: Proxy.Type) = buildString {
+    append(request.method)
+    append(' ')
     if (includeAuthorityInRequestLine(request, proxyType)) {
-      result.append(request.url())
+      append(request.url)
     } else {
-      result.append(requestPath(request.url()))
+      append(requestPath(request.url))
     }
-
-    result.append(" HTTP/1.1")
-    return result.toString()
+    append(" HTTP/1.1")
   }
 
   /**
    * Returns true if the request line should contain the full URL with host and port (like "GET
    * http://android.com/foo HTTP/1.1") or only the path (like "GET /foo HTTP/1.1").
    */
-  @JvmStatic
   private fun includeAuthorityInRequestLine(request: Request, proxyType: Proxy.Type): Boolean {
     return !request.isHttps && proxyType == Proxy.Type.HTTP
   }
@@ -56,10 +50,9 @@ object RequestLine {
    * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty, even if the request
    * URL is. Includes the query component if it exists.
    */
-  @JvmStatic
   fun requestPath(url: HttpUrl): String {
-    val path = url.encodedPath()
-    val query = url.encodedQuery()
+    val path = url.encodedPath
+    val query = url.encodedQuery
     return if (query != null) "$path?$query" else path
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.kt b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.kt
index c09fe9bd46..8f156b8eae 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.kt
@@ -15,24 +15,21 @@
  */
 package okhttp3.internal.http
 
-import java.io.FileNotFoundException
-import java.io.IOException
-import java.io.InterruptedIOException
-import java.net.ProtocolException
-import java.net.Proxy
-import java.net.SocketTimeoutException
-import java.security.cert.CertificateException
-import javax.net.ssl.SSLHandshakeException
-import javax.net.ssl.SSLPeerUnverifiedException
 import okhttp3.Interceptor
 import okhttp3.OkHttpClient
 import okhttp3.Request
 import okhttp3.Response
 import okhttp3.Route
-import okhttp3.internal.Internal
+import okhttp3.internal.closeQuietly
 import okhttp3.internal.connection.RouteException
 import okhttp3.internal.connection.Transmitter
+import okhttp3.internal.http.StatusLine.Companion.HTTP_PERM_REDIRECT
+import okhttp3.internal.http.StatusLine.Companion.HTTP_TEMP_REDIRECT
 import okhttp3.internal.http2.ConnectionShutdownException
+import okhttp3.internal.canReuseConnectionFor
+import java.io.FileNotFoundException
+import java.io.IOException
+import java.io.InterruptedIOException
 import java.net.HttpURLConnection.HTTP_CLIENT_TIMEOUT
 import java.net.HttpURLConnection.HTTP_MOVED_PERM
 import java.net.HttpURLConnection.HTTP_MOVED_TEMP
@@ -41,10 +38,12 @@ import java.net.HttpURLConnection.HTTP_PROXY_AUTH
 import java.net.HttpURLConnection.HTTP_SEE_OTHER
 import java.net.HttpURLConnection.HTTP_UNAUTHORIZED
 import java.net.HttpURLConnection.HTTP_UNAVAILABLE
-import okhttp3.internal.Util.closeQuietly
-import okhttp3.internal.Util.sameConnection
-import okhttp3.internal.http.StatusLine.Companion.HTTP_PERM_REDIRECT
-import okhttp3.internal.http.StatusLine.Companion.HTTP_TEMP_REDIRECT
+import java.net.ProtocolException
+import java.net.Proxy
+import java.net.SocketTimeoutException
+import java.security.cert.CertificateException
+import javax.net.ssl.SSLHandshakeException
+import javax.net.ssl.SSLPeerUnverifiedException
 
 /**
  * This interceptor recovers from failures and follows redirects as necessary. It may throw an
@@ -98,7 +97,7 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
             .build()
       }
 
-      val exchange = Internal.instance.exchange(response)
+      val exchange = response.exchange
       val route = exchange?.connection()?.route()
       val followUp = followUpRequest(response, route)
 
@@ -109,12 +108,12 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
         return response
       }
 
-      val followUpBody = followUp.body()
+      val followUpBody = followUp.body
       if (followUpBody != null && followUpBody.isOneShot()) {
         return response
       }
 
-      closeQuietly(response.body())
+      response.body?.closeQuietly()
       if (transmitter.hasExchange()) {
         exchange?.detachWithViolence()
       }
@@ -141,7 +140,7 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
     userRequest: Request
   ): Boolean {
     // The application layer has forbidden retries.
-    if (!client.retryOnConnectionFailure()) return false
+    if (!client.retryOnConnectionFailure) return false
 
     // We can't send the request body again.
     if (requestSendStarted && requestIsOneShot(e, userRequest)) return false
@@ -156,7 +155,7 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
   }
 
   private fun requestIsOneShot(e: IOException, userRequest: Request): Boolean {
-    val requestBody = userRequest.body()
+    val requestBody = userRequest.body
     return (requestBody != null && requestBody.isOneShot()) ||
         e is FileNotFoundException
   }
@@ -193,25 +192,25 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
   }
 
   /**
-   * Figures out the HTTP request to make in response to receiving `userResponse`. This will
+   * Figures out the HTTP request to make in response to receiving [userResponse]. This will
    * either add authentication headers, follow redirects or handle a client request timeout. If a
    * follow-up is either unnecessary or not applicable, this returns null.
    */
   @Throws(IOException::class)
   private fun followUpRequest(userResponse: Response, route: Route?): Request? {
-    val responseCode = userResponse.code()
+    val responseCode = userResponse.code
 
-    val method = userResponse.request().method()
+    val method = userResponse.request.method
     when (responseCode) {
       HTTP_PROXY_AUTH -> {
-        val selectedProxy = route?.proxy() ?: client.proxy()
-        if (selectedProxy?.type() != Proxy.Type.HTTP) {
+        val selectedProxy = route!!.proxy
+        if (selectedProxy.type() != Proxy.Type.HTTP) {
           throw ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy")
         }
-        return client.proxyAuthenticator().authenticate(route, userResponse)
+        return client.proxyAuthenticator.authenticate(route, userResponse)
       }
 
-      HTTP_UNAUTHORIZED -> return client.authenticator().authenticate(route, userResponse)
+      HTTP_UNAUTHORIZED -> return client.authenticator.authenticate(route, userResponse)
 
       HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT -> {
         // "If the 307 or 308 status code is received in response to a request other than GET
@@ -230,17 +229,17 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
         // 408's are rare in practice, but some servers like HAProxy use this response code. The
         // spec says that we may repeat the request without modifications. Modern browsers also
         // repeat the request (even non-idempotent ones.)
-        if (!client.retryOnConnectionFailure()) {
+        if (!client.retryOnConnectionFailure) {
           // The application layer has directed us not to retry the request.
           return null
         }
 
-        val requestBody = userResponse.request().body()
+        val requestBody = userResponse.request.body
         if (requestBody != null && requestBody.isOneShot()) {
           return null
         }
-        val priorResponse = userResponse.priorResponse()
-        if (priorResponse != null && priorResponse.code() == HTTP_CLIENT_TIMEOUT) {
+        val priorResponse = userResponse.priorResponse
+        if (priorResponse != null && priorResponse.code == HTTP_CLIENT_TIMEOUT) {
           // We attempted to retry and got another timeout. Give up.
           return null
         }
@@ -249,19 +248,19 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
           return null
         }
 
-        return userResponse.request()
+        return userResponse.request
       }
 
       HTTP_UNAVAILABLE -> {
-        val priorResponse = userResponse.priorResponse()
-        if (priorResponse != null && priorResponse.code() == HTTP_UNAVAILABLE) {
+        val priorResponse = userResponse.priorResponse
+        if (priorResponse != null && priorResponse.code == HTTP_UNAVAILABLE) {
           // We attempted to retry and got another timeout. Give up.
           return null
         }
 
         if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) {
           // specifically received an instruction to retry without delay
-          return userResponse.request()
+          return userResponse.request
         }
 
         return null
@@ -272,24 +271,24 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
 
   private fun buildRedirectRequest(userResponse: Response, method: String): Request? {
     // Does the client allow redirects?
-    if (!client.followRedirects()) return null
+    if (!client.followRedirects) return null
 
     val location = userResponse.header("Location") ?: return null
     // Don't follow redirects to unsupported protocols.
-    val url = userResponse.request().url().resolve(location) ?: return null
+    val url = userResponse.request.url.resolve(location) ?: return null
 
     // If configured, don't follow redirects between SSL and non-SSL.
-    val sameScheme = url.scheme() == userResponse.request().url().scheme()
-    if (!sameScheme && !client.followSslRedirects()) return null
+    val sameScheme = url.scheme == userResponse.request.url.scheme
+    if (!sameScheme && !client.followSslRedirects) return null
 
     // Most redirects don't include a request body.
-    val requestBuilder = userResponse.request().newBuilder()
+    val requestBuilder = userResponse.request.newBuilder()
     if (HttpMethod.permitsRequestBody(method)) {
       val maintainBody = HttpMethod.redirectsWithBody(method)
       if (HttpMethod.redirectsToGet(method)) {
         requestBuilder.method("GET", null)
       } else {
-        val requestBody = if (maintainBody) userResponse.request().body() else null
+        val requestBody = if (maintainBody) userResponse.request.body else null
         requestBuilder.method(method, requestBody)
       }
       if (!maintainBody) {
@@ -302,7 +301,7 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
     // When redirecting across hosts, drop all authentication headers. This
     // is potentially annoying to the application layer since they have no
     // way to retain them.
-    if (!sameConnection(userResponse.request().url(), url)) {
+    if (!userResponse.request.url.canReuseConnectionFor(url)) {
       requestBuilder.removeHeader("Authorization")
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http/StatusLine.kt b/okhttp/src/main/java/okhttp3/internal/http/StatusLine.kt
index 0006a2ff70..73679d04f2 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/StatusLine.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http/StatusLine.kt
@@ -45,12 +45,10 @@ class StatusLine(
     const val HTTP_PERM_REDIRECT = 308
     const val HTTP_CONTINUE = 100
 
-    @JvmStatic
     fun get(response: Response): StatusLine {
-      return StatusLine(response.protocol(), response.code(), response.message())
+      return StatusLine(response.protocol, response.code, response.message)
     }
 
-    @JvmStatic
     @Throws(IOException::class)
     fun parse(statusLine: String): StatusLine {
       // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
@@ -65,10 +63,10 @@ class StatusLine(
         }
         val httpMinorVersion = statusLine[7] - '0'
         codeStart = 9
-        if (httpMinorVersion == 0) {
-          protocol = Protocol.HTTP_1_0
+        protocol = if (httpMinorVersion == 0) {
+          Protocol.HTTP_1_0
         } else if (httpMinorVersion == 1) {
-          protocol = Protocol.HTTP_1_1
+          Protocol.HTTP_1_1
         } else {
           throw ProtocolException("Unexpected status line: $statusLine")
         }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/dates.kt b/okhttp/src/main/java/okhttp3/internal/http/dates.kt
new file mode 100644
index 0000000000..0b4675830d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/dates.kt
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http
+
+import okhttp3.internal.UTC
+import java.text.DateFormat
+import java.text.ParsePosition
+import java.text.SimpleDateFormat
+import java.util.Date
+import java.util.Locale
+
+/** The last four-digit year: "Fri, 31 Dec 9999 23:59:59 GMT". */
+internal const val MAX_DATE = 253402300799999L
+
+/**
+ * Most websites serve cookies in the blessed format. Eagerly create the parser to ensure such
+ * cookies are on the fast path.
+ */
+private val STANDARD_DATE_FORMAT = object : ThreadLocal<DateFormat>() {
+  override fun initialValue(): DateFormat {
+    // Date format specified by RFC 7231 section 7.1.1.1.
+    return SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US).apply {
+      isLenient = false
+      timeZone = UTC
+    }
+  }
+}
+
+/** If we fail to parse a date in a non-standard format, try each of these formats in sequence. */
+private val BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS = arrayOf(
+    // HTTP formats required by RFC2616 but with any timezone.
+    "EEE, dd MMM yyyy HH:mm:ss zzz", // RFC 822, updated by RFC 1123 with any TZ
+    "EEEE, dd-MMM-yy HH:mm:ss zzz", // RFC 850, obsoleted by RFC 1036 with any TZ.
+    "EEE MMM d HH:mm:ss yyyy", // ANSI C's asctime() format
+    // Alternative formats.
+    "EEE, dd-MMM-yyyy HH:mm:ss z",
+    "EEE, dd-MMM-yyyy HH-mm-ss z",
+    "EEE, dd MMM yy HH:mm:ss z",
+    "EEE dd-MMM-yyyy HH:mm:ss z",
+    "EEE dd MMM yyyy HH:mm:ss z",
+    "EEE dd-MMM-yyyy HH-mm-ss z",
+    "EEE dd-MMM-yy HH:mm:ss z",
+    "EEE dd MMM yy HH:mm:ss z",
+    "EEE,dd-MMM-yy HH:mm:ss z",
+    "EEE,dd-MMM-yyyy HH:mm:ss z",
+    "EEE, dd-MM-yyyy HH:mm:ss z",
+
+    /* RI bug 6641315 claims a cookie of this format was once served by www.yahoo.com */
+    "EEE MMM d yyyy HH:mm:ss z"
+)
+
+private val BROWSER_COMPATIBLE_DATE_FORMATS =
+    arrayOfNulls<DateFormat>(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.size)
+
+/** Returns the date for this string, or null if the value couldn't be parsed. */
+internal fun String.toHttpDateOrNull(): Date? {
+  if (isEmpty()) return null
+
+  val position = ParsePosition(0)
+  var result = STANDARD_DATE_FORMAT.get().parse(this, position)
+  if (position.index == length) {
+    // STANDARD_DATE_FORMAT must match exactly; all text must be consumed, e.g. no ignored
+    // non-standard trailing "+01:00". Those cases are covered below.
+    return result
+  }
+  synchronized(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS) {
+    for (i in 0 until BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.size) {
+      var format: DateFormat? = BROWSER_COMPATIBLE_DATE_FORMATS[i]
+      if (format == null) {
+        format = SimpleDateFormat(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS[i], Locale.US).apply {
+          // Set the timezone to use when interpreting formats that don't have a timezone. GMT is
+          // specified by RFC 7231.
+          timeZone = UTC
+        }
+        BROWSER_COMPATIBLE_DATE_FORMATS[i] = format
+      }
+      position.index = 0
+      result = format.parse(this, position)
+      if (position.index != 0) {
+        // Something was parsed. It's possible the entire string was not consumed but we ignore
+        // that. If any of the BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS ended in "'GMT'" we'd have
+        // to also check that position.getIndex() == value.length() otherwise parsing might have
+        // terminated early, ignoring things like "+01:00". Leaving this as != 0 means that any
+        // trailing junk is ignored.
+        return result
+      }
+    }
+  }
+  return null
+}
+
+/** Returns the string for this date. */
+internal fun Date.toHttpDateString(): String = STANDARD_DATE_FORMAT.get().format(this)
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1ExchangeCodec.kt b/okhttp/src/main/java/okhttp3/internal/http1/Http1ExchangeCodec.kt
index d76f779ec3..2f938073e5 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1ExchangeCodec.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1ExchangeCodec.kt
@@ -20,15 +20,18 @@ import okhttp3.HttpUrl
 import okhttp3.OkHttpClient
 import okhttp3.Request
 import okhttp3.Response
-import okhttp3.internal.Util
-import okhttp3.internal.Util.checkOffsetAndCount
-import okhttp3.internal.addHeaderLenient
+import okhttp3.internal.EMPTY_HEADERS
+import okhttp3.internal.checkOffsetAndCount
 import okhttp3.internal.connection.RealConnection
+import okhttp3.internal.discard
+import okhttp3.internal.headersContentLength
 import okhttp3.internal.http.ExchangeCodec
-import okhttp3.internal.http.HttpHeaders
 import okhttp3.internal.http.RequestLine
 import okhttp3.internal.http.StatusLine
 import okhttp3.internal.http.StatusLine.Companion.HTTP_CONTINUE
+import okhttp3.internal.http.promisesBody
+import okhttp3.internal.http.receiveHeaders
+import okhttp3.internal.skipAll
 import okio.Buffer
 import okio.BufferedSink
 import okio.BufferedSource
@@ -59,9 +62,9 @@ import java.util.concurrent.TimeUnit.MILLISECONDS
  * [newFixedLengthSource(0)][newFixedLengthSource] and may skip reading and closing that source.
  */
 class Http1ExchangeCodec(
-  /** The client that configures this stream. May be null for HTTPS proxy tunnels.  */
+  /** The client that configures this stream. May be null for HTTPS proxy tunnels. */
   private val client: OkHttpClient?,
-  /** The connection that carries this stream.  */
+  /** The connection that carries this stream. */
   private val realConnection: RealConnection?,
   private val source: BufferedSource,
   private val sink: BufferedSink
@@ -81,17 +84,15 @@ class Http1ExchangeCodec(
    */
   private var trailers: Headers? = null
 
-  /** Returns true if this connection is closed.  */
+  /** Returns true if this connection is closed. */
   val isClosed: Boolean
     get() = state == STATE_CLOSED
 
-  override fun connection(): RealConnection? {
-    return realConnection
-  }
+  override fun connection(): RealConnection? = realConnection
 
   override fun createRequestBody(request: Request, contentLength: Long): Sink {
     return when {
-      request.body() != null && request.body()!!.isDuplex() -> throw ProtocolException(
+      request.body != null && request.body.isDuplex() -> throw ProtocolException(
           "Duplex connections are not supported for HTTP/1")
       request.isChunked() -> newChunkedSink() // Stream a request body of unknown length.
       contentLength != -1L -> newKnownLengthSink() // Stream a request body of a known length.
@@ -108,33 +109,33 @@ class Http1ExchangeCodec(
   /**
    * Prepares the HTTP headers and sends them to the server.
    *
-   * For streaming requests with a body, headers must be prepared **before** the
-   * output stream has been written to. Otherwise the body would need to be buffered!
+   * For streaming requests with a body, headers must be prepared **before** the output stream has
+   * been written to. Otherwise the body would need to be buffered!
    *
-   * For non-streaming requests with a body, headers must be prepared **after** the
-   * output stream has been written to and closed. This ensures that the `Content-Length`
-   * header field receives the proper value.
+   * For non-streaming requests with a body, headers must be prepared **after** the output stream
+   * has been written to and closed. This ensures that the `Content-Length` header field receives
+   * the proper value.
    */
   override fun writeRequestHeaders(request: Request) {
     val requestLine = RequestLine.get(
-        request, realConnection!!.route().proxy().type())
-    writeRequest(request.headers(), requestLine)
+        request, realConnection!!.route().proxy.type())
+    writeRequest(request.headers, requestLine)
   }
 
   override fun reportedContentLength(response: Response): Long {
     return when {
-      !HttpHeaders.hasBody(response) -> 0L
+      !response.promisesBody() -> 0L
       response.isChunked() -> -1L
-      else -> HttpHeaders.contentLength(response)
+      else -> response.headersContentLength()
     }
   }
 
   override fun openResponseBodySource(response: Response): Source {
     return when {
-      !HttpHeaders.hasBody(response) -> newFixedLengthSource(0)
-      response.isChunked() -> newChunkedSource(response.request().url())
+      !response.promisesBody() -> newFixedLengthSource(0)
+      response.isChunked() -> newChunkedSource(response.request.url)
       else -> {
-        val contentLength = HttpHeaders.contentLength(response)
+        val contentLength = response.headersContentLength()
         if (contentLength != -1L) {
           newFixedLengthSource(contentLength)
         } else {
@@ -146,7 +147,7 @@ class Http1ExchangeCodec(
 
   override fun trailers(): Headers {
     check(state == STATE_CLOSED) { "too early; can't read the trailers yet" }
-    return trailers ?: Util.EMPTY_HEADERS
+    return trailers ?: EMPTY_HEADERS
   }
 
   override fun flushRequest() {
@@ -157,11 +158,11 @@ class Http1ExchangeCodec(
     sink.flush()
   }
 
-  /** Returns bytes of a request header for sending on an HTTP transport.  */
+  /** Returns bytes of a request header for sending on an HTTP transport. */
   fun writeRequest(headers: Headers, requestLine: String) {
     check(state == STATE_IDLE) { "state: $state" }
     sink.writeUtf8(requestLine).writeUtf8("\r\n")
-    for (i in 0 until headers.size()) {
+    for (i in 0 until headers.size) {
       sink.writeUtf8(headers.name(i))
           .writeUtf8(": ")
           .writeUtf8(headers.value(i))
@@ -172,7 +173,9 @@ class Http1ExchangeCodec(
   }
 
   override fun readResponseHeaders(expectContinue: Boolean): Response.Builder? {
-    check(state == STATE_OPEN_REQUEST_BODY || state == STATE_READ_RESPONSE_HEADERS) { "state: $state" }
+    check(state == STATE_OPEN_REQUEST_BODY || state == STATE_READ_RESPONSE_HEADERS) {
+      "state: $state"
+    }
 
     try {
       val statusLine = StatusLine.parse(readHeaderLine())
@@ -184,7 +187,9 @@ class Http1ExchangeCodec(
           .headers(readHeaders())
 
       return when {
-        expectContinue && statusLine.code == HTTP_CONTINUE -> null
+        expectContinue && statusLine.code == HTTP_CONTINUE -> {
+          null
+        }
         statusLine.code == HTTP_CONTINUE -> {
           state = STATE_READ_RESPONSE_HEADERS
           responseBuilder
@@ -196,7 +201,7 @@ class Http1ExchangeCodec(
       }
     } catch (e: EOFException) {
       // Provide more context if the server ends the stream before sending a response.
-      val address = if (realConnection != null) realConnection.route().address().url().redact() else "unknown"
+      val address = realConnection?.route()?.address?.url?.redact() ?: "unknown"
       throw IOException("unexpected end of stream on $address", e)
     }
   }
@@ -207,13 +212,13 @@ class Http1ExchangeCodec(
     return line
   }
 
-  /** Reads headers or trailers.  */
+  /** Reads headers or trailers. */
   private fun readHeaders(): Headers {
     val headers = Headers.Builder()
     // parse the result headers until the first blank line
     var line = readHeaderLine()
     while (line.isNotEmpty()) {
-      addHeaderLenient(headers, line)
+      headers.addLenient(line)
       line = readHeaderLine()
     }
     return headers.build()
@@ -267,14 +272,14 @@ class Http1ExchangeCodec(
    * before proceeding.
    */
   fun skipConnectBody(response: Response) {
-    val contentLength = HttpHeaders.contentLength(response)
+    val contentLength = response.headersContentLength()
     if (contentLength == -1L) return
     val body = newFixedLengthSource(contentLength)
-    Util.skipAll(body, Int.MAX_VALUE, MILLISECONDS)
+    body.skipAll(Int.MAX_VALUE, MILLISECONDS)
     body.close()
   }
 
-  /** An HTTP request body.  */
+  /** An HTTP request body. */
   private inner class KnownLengthSink : Sink {
     private val timeout = ForwardingTimeout(sink.timeout())
     private var closed: Boolean = false
@@ -366,7 +371,7 @@ class Http1ExchangeCodec(
     }
   }
 
-  /** An HTTP body with a fixed length specified in advance.  */
+  /** An HTTP body with a fixed length specified in advance. */
   private inner class FixedLengthSource internal constructor(private var bytesRemaining: Long) :
       AbstractSource() {
 
@@ -377,8 +382,8 @@ class Http1ExchangeCodec(
     }
 
     override fun read(sink: Buffer, byteCount: Long): Long {
-      if (byteCount < 0) throw IllegalArgumentException("byteCount < 0: $byteCount")
-      if (closed) throw IllegalStateException("closed")
+      require(byteCount >= 0L) { "byteCount < 0: $byteCount" }
+      check(!closed) { "closed" }
       if (bytesRemaining == 0L) return -1
 
       val read = super.read(sink, minOf(bytesRemaining, byteCount))
@@ -399,8 +404,8 @@ class Http1ExchangeCodec(
     override fun close() {
       if (closed) return
 
-      if (bytesRemaining != 0L && !Util.discard(this,
-              ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+      if (bytesRemaining != 0L &&
+          !discard(ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
         realConnection!!.noNewExchanges() // Unread bytes remain on the stream.
         responseBodyComplete()
       }
@@ -409,14 +414,14 @@ class Http1ExchangeCodec(
     }
   }
 
-  /** An HTTP body with alternating chunk sizes and chunk bodies.  */
+  /** An HTTP body with alternating chunk sizes and chunk bodies. */
   private inner class ChunkedSource internal constructor(private val url: HttpUrl) :
       AbstractSource() {
     private var bytesRemainingInChunk = NO_CHUNK_YET
     private var hasMoreChunks = true
 
     override fun read(sink: Buffer, byteCount: Long): Long {
-      require(byteCount >= 0) { "byteCount < 0: $byteCount" }
+      require(byteCount >= 0L) { "byteCount < 0: $byteCount" }
       check(!closed) { "closed" }
       if (!hasMoreChunks) return -1
 
@@ -443,10 +448,10 @@ class Http1ExchangeCodec(
       }
       try {
         bytesRemainingInChunk = source.readHexadecimalUnsignedLong()
-        val extensions = source.readUtf8LineStrict().trim { it <= ' ' }
-        if (bytesRemainingInChunk < 0 || extensions.isNotEmpty() && !extensions.startsWith(";")) {
-          throw ProtocolException(
-              "expected chunk size and optional extensions but was \"$bytesRemainingInChunk$extensions\"")
+        val extensions = source.readUtf8LineStrict().trim()
+        if (bytesRemainingInChunk < 0L || extensions.isNotEmpty() && !extensions.startsWith(";")) {
+          throw ProtocolException("expected chunk size and optional extensions" +
+              " but was \"$bytesRemainingInChunk$extensions\"")
         }
       } catch (e: NumberFormatException) {
         throw ProtocolException(e.message)
@@ -455,15 +460,15 @@ class Http1ExchangeCodec(
       if (bytesRemainingInChunk == 0L) {
         hasMoreChunks = false
         trailers = readHeaders()
-        HttpHeaders.receiveHeaders(client!!.cookieJar(), url, trailers)
+        client!!.cookieJar.receiveHeaders(url, trailers!!)
         responseBodyComplete()
       }
     }
 
     override fun close() {
       if (closed) return
-      if (hasMoreChunks && !Util.discard(this, ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS,
-              MILLISECONDS)) {
+      if (hasMoreChunks &&
+          !discard(ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
         realConnection!!.noNewExchanges() // Unread bytes remain on the stream.
         responseBodyComplete()
       }
@@ -471,12 +476,12 @@ class Http1ExchangeCodec(
     }
   }
 
-  /** An HTTP message body terminated by the end of the underlying stream.  */
+  /** An HTTP message body terminated by the end of the underlying stream. */
   private inner class UnknownLengthSource : AbstractSource() {
     private var inputExhausted: Boolean = false
 
     override fun read(sink: Buffer, byteCount: Long): Long {
-      require(byteCount >= 0) { "byteCount < 0: $byteCount" }
+      require(byteCount >= 0L) { "byteCount < 0: $byteCount" }
       check(!closed) { "closed" }
       if (inputExhausted) return -1
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.kt b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.kt
index ffde700bb1..292db0bba2 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.kt
@@ -40,6 +40,7 @@ import java.util.LinkedHashMap
  * entries are added to the array, starting in the last position moving forward. When the array
  * fills, it is doubled.
  */
+@Suppress("NAME_SHADOWING")
 object Hpack {
   private const val PREFIX_4_BITS = 0x0f
   private const val PREFIX_5_BITS = 0x1f
@@ -132,7 +133,7 @@ object Hpack {
     // Visible for testing.
     @JvmField var dynamicTable = arrayOfNulls<Header>(8)
     // Array is populated back to front, so new entries always have lowest index.
-    var nextHeaderIndex = dynamicTable.size - 1
+    private var nextHeaderIndex = dynamicTable.size - 1
     @JvmField var headerCount = 0
     @JvmField var dynamicTableByteCount = 0
 
@@ -161,7 +162,7 @@ object Hpack {
       dynamicTableByteCount = 0
     }
 
-    /** Returns the count of entries evicted.  */
+    /** Returns the count of entries evicted. */
     private fun evictToRecoverBytes(bytesToRecover: Int): Int {
       var bytesToRecover = bytesToRecover
       var entriesToEvict = 0
@@ -280,15 +281,15 @@ object Hpack {
 
     @Throws(IOException::class)
     private fun getName(index: Int): ByteString {
-      if (isStaticHeader(index)) {
-        return STATIC_HEADER_TABLE[index].name
+      return if (isStaticHeader(index)) {
+        STATIC_HEADER_TABLE[index].name
       } else {
         val dynamicTableIndex = dynamicTableIndex(index - STATIC_HEADER_TABLE.size)
         if (dynamicTableIndex < 0 || dynamicTableIndex >= dynamicTable.size) {
           throw IOException("Header index too large ${index + 1}")
         }
 
-        return dynamicTable[dynamicTableIndex]!!.name
+        dynamicTable[dynamicTableIndex]!!.name
       }
     }
 
@@ -296,7 +297,7 @@ object Hpack {
       return index >= 0 && index <= STATIC_HEADER_TABLE.size - 1
     }
 
-    /** index == -1 when new.  */
+    /** index == -1 when new. */
     private fun insertIntoDynamicTable(index: Int, entry: Header) {
       var index = index
       headerList.add(entry)
@@ -361,19 +362,19 @@ object Hpack {
       return result
     }
 
-    /** Reads a potentially Huffman encoded byte string.  */
+    /** Reads a potentially Huffman encoded byte string. */
     @Throws(IOException::class)
     fun readByteString(): ByteString {
       val firstByte = readByte()
       val huffmanDecode = firstByte and 0x80 == 0x80 // 1NNNNNNN
       val length = readInt(firstByte, PREFIX_7_BITS).toLong()
 
-      if (huffmanDecode) {
+      return if (huffmanDecode) {
         val decodeBuffer = Buffer()
         Huffman.decode(source, length, decodeBuffer)
-        return decodeBuffer.readByteString()
+        decodeBuffer.readByteString()
       } else {
-        return source.readByteString(length)
+        source.readByteString(length)
       }
     }
   }
@@ -404,7 +405,7 @@ object Hpack {
     // Visible for testing.
     @JvmField var dynamicTable = arrayOfNulls<Header>(8)
     // Array is populated back to front, so new entries always have lowest index.
-    var nextHeaderIndex = dynamicTable.size - 1
+    private var nextHeaderIndex = dynamicTable.size - 1
     @JvmField var headerCount = 0
     @JvmField var dynamicTableByteCount = 0
 
@@ -415,7 +416,7 @@ object Hpack {
       dynamicTableByteCount = 0
     }
 
-    /** Returns the count of entries evicted.  */
+    /** Returns the count of entries evicted. */
     private fun evictToRecoverBytes(bytesToRecover: Int): Int {
       var bytesToRecover = bytesToRecover
       var entriesToEvict = 0
@@ -462,7 +463,7 @@ object Hpack {
       dynamicTableByteCount += delta
     }
 
-    /** This does not use "never indexed" semantics for sensitive headers.  */
+    /** This does not use "never indexed" semantics for sensitive headers. */
     // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-6.2.3
     @Throws(IOException::class)
     fun writeHeaders(headerBlock: List<Header>) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2.kt
index a1b7186db2..571ab0fd9a 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2.kt
@@ -15,14 +15,14 @@
  */
 package okhttp3.internal.http2
 
-import okhttp3.internal.Util.format
+import okhttp3.internal.format
 import okio.ByteString.Companion.encodeUtf8
 
 object Http2 {
   @JvmField
   val CONNECTION_PREFACE = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n".encodeUtf8()
 
-  /** The initial max frame size, applied independently writing to, or reading from the peer.  */
+  /** The initial max frame size, applied independently writing to, or reading from the peer. */
   const val INITIAL_MAX_FRAME_SIZE = 0x4000 // 16384
 
   const val TYPE_DATA = 0x0
@@ -45,7 +45,7 @@ object Http2 {
   const val FLAG_PRIORITY = 0x20 // Used for headers.
   const val FLAG_COMPRESSED = 0x20 // Used for data.
 
-  /** Lookup table for valid frame types.  */
+  /** Lookup table for valid frame types. */
   private val FRAME_NAMES = arrayOf(
       "DATA", "HEADERS", "PRIORITY", "RST_STREAM", "SETTINGS", "PUSH_PROMISE", "PING", "GOAWAY",
       "WINDOW_UPDATE", "CONTINUATION"
@@ -105,7 +105,6 @@ object Http2 {
    * `<< 0x0000000f    12 HEADERS       END_HEADERS|END_STREAM
    * ```
    */
-  @JvmStatic
   fun frameLog(
     inbound: Boolean,
     streamId: Int,
@@ -125,15 +124,14 @@ object Http2 {
    * in binary.
    */
   // Visible for testing.
-  @JvmStatic
   fun formatFlags(type: Int, flags: Int): String {
     if (flags == 0) return ""
     when (type) {
       // Special case types that have 0 or 1 flag.
-      TYPE_SETTINGS, TYPE_PING -> return if (flags == FLAG_ACK) "ACK" else BINARY[flags]!!
-      TYPE_PRIORITY, TYPE_RST_STREAM, TYPE_GOAWAY, TYPE_WINDOW_UPDATE -> return BINARY[flags]!!
+      TYPE_SETTINGS, TYPE_PING -> return if (flags == FLAG_ACK) "ACK" else BINARY[flags]
+      TYPE_PRIORITY, TYPE_RST_STREAM, TYPE_GOAWAY, TYPE_WINDOW_UPDATE -> return BINARY[flags]
     }
-    val result = if (flags < FLAGS.size) FLAGS[flags]!! else BINARY[flags]!!
+    val result = if (flags < FLAGS.size) FLAGS[flags]!! else BINARY[flags]
     // Special case types that have overlap flag values.
     return when {
       type == TYPE_PUSH_PROMISE && flags and FLAG_END_PUSH_PROMISE != 0 -> {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
deleted file mode 100644
index 1ee08c2a01..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ /dev/null
@@ -1,945 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledThreadPoolExecutor;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.Headers;
-import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.Util;
-import okhttp3.internal.platform.Platform;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static okhttp3.internal.http2.ErrorCode.REFUSED_STREAM;
-import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.platform.Platform.INFO;
-
-/**
- * A socket connection to a remote peer. A connection hosts streams which can send and receive
- * data.
- *
- * <p>Many methods in this API are <strong>synchronous:</strong> the call is completed before the
- * method returns. This is typical for Java but atypical for HTTP/2. This is motivated by exception
- * transparency: an IOException that was triggered by a certain caller can be caught and handled by
- * that caller.
- */
-public final class Http2Connection implements Closeable {
-
-  // Internal state of this connection is guarded by 'this'. No blocking
-  // operations may be performed while holding this lock!
-  //
-  // Socket writes are guarded by frameWriter.
-  //
-  // Socket reads are unguarded but are only made by the reader thread.
-  //
-  // Certain operations (like SYN_STREAM) need to synchronize on both the
-  // frameWriter (to do blocking I/O) and this (to create streams). Such
-  // operations must synchronize on 'this' last. This ensures that we never
-  // wait for a blocking operation while holding 'this'.
-
-  static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
-
-  /**
-   * Shared executor to send notifications of incoming streams. This executor requires multiple
-   * threads because listeners are not required to return promptly.
-   */
-  private static final ExecutorService listenerExecutor = new ThreadPoolExecutor(0,
-      Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<>(),
-      Util.threadFactory("OkHttp Http2Connection", true));
-
-  /** True if this peer initiated the connection. */
-  final boolean client;
-
-  /**
-   * User code to run in response to incoming streams or settings. Calls to this are always invoked
-   * on {@link #listenerExecutor}.
-   */
-  final Listener listener;
-  final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
-  final String connectionName;
-  int lastGoodStreamId;
-  int nextStreamId;
-  boolean shutdown;
-
-  /** Asynchronously writes frames to the outgoing socket. */
-  private final ScheduledExecutorService writerExecutor;
-
-  /** Ensures push promise callbacks events are sent in order per stream. */
-  private final ExecutorService pushExecutor;
-
-  /** User code to run in response to push promise events. */
-  final PushObserver pushObserver;
-
-  /** True if we have sent a ping that is still awaiting a reply. */
-  private boolean awaitingPong;
-
-  /**
-   * The total number of bytes consumed by the application, but not yet acknowledged by sending a
-   * {@code WINDOW_UPDATE} frame on this connection.
-   */
-  // Visible for testing
-  long unacknowledgedBytesRead = 0;
-
-  /**
-   * Count of bytes that can be written on the connection before receiving a window update.
-   */
-  // Visible for testing
-  long bytesLeftInWriteWindow;
-
-  /** Settings we communicate to the peer. */
-  Settings okHttpSettings = new Settings();
-
-  /** Settings we receive from the peer. */
-  // TODO: MWS will need to guard on this setting before attempting to push.
-  final Settings peerSettings = new Settings();
-
-  boolean receivedInitialPeerSettings = false;
-  final Socket socket;
-  final Http2Writer writer;
-
-  // Visible for testing
-  final ReaderRunnable readerRunnable;
-
-  Http2Connection(Builder builder) {
-    pushObserver = builder.pushObserver;
-    client = builder.client;
-    listener = builder.listener;
-    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-5.1.1
-    nextStreamId = builder.client ? 1 : 2;
-    if (builder.client) {
-      nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
-    }
-
-    // Flow control was designed more for servers, or proxies than edge clients.
-    // If we are a client, set the flow control window to 16MiB.  This avoids
-    // thrashing window updates every 64KiB, yet small enough to avoid blowing
-    // up the heap.
-    if (builder.client) {
-      okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, OKHTTP_CLIENT_WINDOW_SIZE);
-    }
-
-    connectionName = builder.connectionName;
-
-    writerExecutor = new ScheduledThreadPoolExecutor(1,
-        Util.threadFactory(Util.format("OkHttp %s Writer", connectionName), false));
-    if (builder.pingIntervalMillis != 0) {
-      writerExecutor.scheduleAtFixedRate(new PingRunnable(false, 0, 0),
-          builder.pingIntervalMillis, builder.pingIntervalMillis, MILLISECONDS);
-    }
-
-    // Like newSingleThreadExecutor, except lazy creates the thread.
-    pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<>(),
-        Util.threadFactory(Util.format("OkHttp %s Push Observer", connectionName), true));
-    peerSettings.set(Settings.INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE);
-    peerSettings.set(Settings.MAX_FRAME_SIZE, Http2.INITIAL_MAX_FRAME_SIZE);
-    bytesLeftInWriteWindow = peerSettings.getInitialWindowSize();
-    socket = builder.socket;
-    writer = new Http2Writer(builder.sink, client);
-
-    readerRunnable = new ReaderRunnable(new Http2Reader(builder.source, client));
-  }
-
-  /**
-   * Returns the number of {@link Http2Stream#isOpen() open streams} on this connection.
-   */
-  public synchronized int openStreamCount() {
-    return streams.size();
-  }
-
-  synchronized Http2Stream getStream(int id) {
-    return streams.get(id);
-  }
-
-  synchronized Http2Stream removeStream(int streamId) {
-    Http2Stream stream = streams.remove(streamId);
-    notifyAll(); // The removed stream may be blocked on a connection-wide window update.
-    return stream;
-  }
-
-  public synchronized int maxConcurrentStreams() {
-    return peerSettings.getMaxConcurrentStreams(Integer.MAX_VALUE);
-  }
-
-  synchronized void updateConnectionFlowControl(long read) {
-    unacknowledgedBytesRead += read;
-    if (unacknowledgedBytesRead >= okHttpSettings.getInitialWindowSize() / 2) {
-      writeWindowUpdateLater(0, unacknowledgedBytesRead);
-      unacknowledgedBytesRead = 0;
-    }
-  }
-
-  /**
-   * Returns a new server-initiated stream.
-   *
-   * @param associatedStreamId the stream that triggered the sender to create this stream.
-   * @param out true to create an output stream that we can use to send data to the remote peer.
-   * Corresponds to {@code FLAG_FIN}.
-   */
-  public Http2Stream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
-      throws IOException {
-    if (client) throw new IllegalStateException("Client cannot push requests.");
-    return newStream(associatedStreamId, requestHeaders, out);
-  }
-
-  /**
-   * Returns a new locally-initiated stream.
-   * @param out true to create an output stream that we can use to send data to the remote peer.
-   * Corresponds to {@code FLAG_FIN}.
-   */
-  public Http2Stream newStream(List<Header> requestHeaders, boolean out) throws IOException {
-    return newStream(0, requestHeaders, out);
-  }
-
-  private Http2Stream newStream(
-      int associatedStreamId, List<Header> requestHeaders, boolean out) throws IOException {
-    boolean outFinished = !out;
-    boolean inFinished = false;
-    boolean flushHeaders;
-    Http2Stream stream;
-    int streamId;
-
-    synchronized (writer) {
-      synchronized (this) {
-        if (nextStreamId > Integer.MAX_VALUE / 2) {
-          shutdown(REFUSED_STREAM);
-        }
-        if (shutdown) {
-          throw new ConnectionShutdownException();
-        }
-        streamId = nextStreamId;
-        nextStreamId += 2;
-        stream = new Http2Stream(streamId, this, outFinished, inFinished, null);
-        flushHeaders = !out
-            || bytesLeftInWriteWindow == 0L
-            || stream.getBytesLeftInWriteWindow() == 0L;
-        if (stream.isOpen()) {
-          streams.put(streamId, stream);
-        }
-      }
-      if (associatedStreamId == 0) {
-        writer.headers(outFinished, streamId, requestHeaders);
-      } else if (client) {
-        throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
-      } else { // HTTP/2 has a PUSH_PROMISE frame.
-        writer.pushPromise(associatedStreamId, streamId, requestHeaders);
-      }
-    }
-
-    if (flushHeaders) {
-      writer.flush();
-    }
-
-    return stream;
-  }
-
-  void writeHeaders(int streamId, boolean outFinished, List<Header> alternating)
-      throws IOException {
-    writer.headers(outFinished, streamId, alternating);
-  }
-
-  /**
-   * Callers of this method are not thread safe, and sometimes on application threads. Most often,
-   * this method will be called to send a buffer worth of data to the peer.
-   *
-   * <p>Writes are subject to the write window of the stream and the connection. Until there is a
-   * window sufficient to send {@code byteCount}, the caller will block. For example, a user of
-   * {@code HttpURLConnection} who flushes more bytes to the output stream than the connection's
-   * write window will block.
-   *
-   * <p>Zero {@code byteCount} writes are not subject to flow control and will not block. The only
-   * use case for zero {@code byteCount} is closing a flushed output stream.
-   */
-  public void writeData(int streamId, boolean outFinished, Buffer buffer, long byteCount)
-      throws IOException {
-    if (byteCount == 0) { // Empty data frames are not flow-controlled.
-      writer.data(outFinished, streamId, buffer, 0);
-      return;
-    }
-
-    while (byteCount > 0) {
-      int toWrite;
-      synchronized (Http2Connection.this) {
-        try {
-          while (bytesLeftInWriteWindow <= 0) {
-            // Before blocking, confirm that the stream we're writing is still open. It's possible
-            // that the stream has since been closed (such as if this write timed out.)
-            if (!streams.containsKey(streamId)) {
-              throw new IOException("stream closed");
-            }
-            Http2Connection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
-          }
-        } catch (InterruptedException e) {
-          Thread.currentThread().interrupt(); // Retain interrupted status.
-          throw new InterruptedIOException();
-        }
-
-        toWrite = (int) Math.min(byteCount, bytesLeftInWriteWindow);
-        toWrite = Math.min(toWrite, writer.maxDataLength());
-        bytesLeftInWriteWindow -= toWrite;
-      }
-
-      byteCount -= toWrite;
-      writer.data(outFinished && byteCount == 0, streamId, buffer, toWrite);
-    }
-  }
-
-  void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
-    try {
-      writerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", connectionName, streamId) {
-        @Override public void execute() {
-          try {
-            writeSynReset(streamId, errorCode);
-          } catch (IOException e) {
-            failConnection(e);
-          }
-        }
-      });
-    } catch (RejectedExecutionException ignored) {
-      // This connection has been closed.
-    }
-  }
-
-  void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
-    writer.rstStream(streamId, statusCode);
-  }
-
-  void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
-    try {
-      writerExecutor.execute(
-          new NamedRunnable("OkHttp Window Update %s stream %d", connectionName, streamId) {
-            @Override public void execute() {
-              try {
-                writer.windowUpdate(streamId, unacknowledgedBytesRead);
-              } catch (IOException e) {
-                failConnection(e);
-              }
-            }
-          });
-    } catch (RejectedExecutionException ignored) {
-      // This connection has been closed.
-    }
-  }
-
-  final class PingRunnable extends NamedRunnable {
-    final boolean reply;
-    final int payload1;
-    final int payload2;
-
-    PingRunnable(boolean reply, int payload1, int payload2) {
-      super("OkHttp %s ping %08x%08x", connectionName, payload1, payload2);
-      this.reply = reply;
-      this.payload1 = payload1;
-      this.payload2 = payload2;
-    }
-
-    @Override public void execute() {
-      writePing(reply, payload1, payload2);
-    }
-  }
-
-  void writePing(boolean reply, int payload1, int payload2) {
-    if (!reply) {
-      boolean failedDueToMissingPong;
-      synchronized (this) {
-        failedDueToMissingPong = awaitingPong;
-        awaitingPong = true;
-      }
-      if (failedDueToMissingPong) {
-        failConnection(null);
-        return;
-      }
-    }
-
-    try {
-      writer.ping(reply, payload1, payload2);
-    } catch (IOException e) {
-      failConnection(e);
-    }
-  }
-
-  /** For testing: sends a ping and waits for a pong. */
-  void writePingAndAwaitPong() throws InterruptedException {
-    writePing(false, 0x4f4b6f6b /* "OKok" */, 0xf09f8da9 /* donut */);
-    awaitPong();
-  }
-
-  /** For testing: waits until {@code requiredPongCount} pings have been received from the peer. */
-  synchronized void awaitPong() throws InterruptedException {
-    while (awaitingPong) {
-      wait();
-    }
-  }
-
-  public void flush() throws IOException {
-    writer.flush();
-  }
-
-  /**
-   * Degrades this connection such that new streams can neither be created locally, nor accepted
-   * from the remote peer. Existing streams are not impacted. This is intended to permit an endpoint
-   * to gracefully stop accepting new requests without harming previously established streams.
-   */
-  public void shutdown(ErrorCode statusCode) throws IOException {
-    synchronized (writer) {
-      int lastGoodStreamId;
-      synchronized (this) {
-        if (shutdown) {
-          return;
-        }
-        shutdown = true;
-        lastGoodStreamId = this.lastGoodStreamId;
-      }
-      // TODO: propagate exception message into debugData.
-      // TODO: configure a timeout on the reader so that it doesn’t block forever.
-      writer.goAway(lastGoodStreamId, statusCode, Util.EMPTY_BYTE_ARRAY);
-    }
-  }
-
-  /**
-   * Closes this connection. This cancels all open streams and unanswered pings. It closes the
-   * underlying input and output streams and shuts down internal executor services.
-   */
-  @Override public void close() {
-    close(ErrorCode.NO_ERROR, ErrorCode.CANCEL, null);
-  }
-
-  void close(ErrorCode connectionCode, ErrorCode streamCode, @Nullable IOException cause) {
-    assert (!Thread.holdsLock(this));
-    try {
-      shutdown(connectionCode);
-    } catch (IOException ignored) {
-    }
-
-    Http2Stream[] streamsToClose = null;
-    synchronized (this) {
-      if (!streams.isEmpty()) {
-        streamsToClose = streams.values().toArray(new Http2Stream[0]);
-        streams.clear();
-      }
-    }
-
-    if (streamsToClose != null) {
-      for (Http2Stream stream : streamsToClose) {
-        try {
-          stream.close(streamCode, cause);
-        } catch (IOException ignored) {
-        }
-      }
-    }
-
-    // Close the writer to release its resources (such as deflaters).
-    try {
-      writer.close();
-    } catch (IOException ignored) {
-    }
-
-    // Close the socket to break out the reader thread, which will clean up after itself.
-    try {
-      socket.close();
-    } catch (IOException ignored) {
-    }
-
-    // Release the threads.
-    writerExecutor.shutdown();
-    pushExecutor.shutdown();
-  }
-
-  private void failConnection(@Nullable IOException e) {
-    close(ErrorCode.PROTOCOL_ERROR, ErrorCode.PROTOCOL_ERROR, e);
-  }
-
-  /**
-   * Sends any initial frames and starts reading frames from the remote peer. This should be called
-   * after {@link Builder#build} for all new connections.
-   */
-  public void start() throws IOException {
-    start(true);
-  }
-
-  /**
-   * @param sendConnectionPreface true to send connection preface frames. This should always be true
-   *     except for in tests that don't check for a connection preface.
-   */
-  void start(boolean sendConnectionPreface) throws IOException {
-    if (sendConnectionPreface) {
-      writer.connectionPreface();
-      writer.settings(okHttpSettings);
-      int windowSize = okHttpSettings.getInitialWindowSize();
-      if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) {
-        writer.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
-      }
-    }
-    new Thread(readerRunnable).start(); // Not a daemon thread.
-  }
-
-  /** Merges {@code settings} into this peer's settings and sends them to the remote peer. */
-  public void setSettings(Settings settings) throws IOException {
-    synchronized (writer) {
-      synchronized (this) {
-        if (shutdown) {
-          throw new ConnectionShutdownException();
-        }
-        okHttpSettings.merge(settings);
-      }
-      writer.settings(settings);
-    }
-  }
-
-  public synchronized boolean isShutdown() {
-    return shutdown;
-  }
-
-  public static class Builder {
-    Socket socket;
-    String connectionName;
-    BufferedSource source;
-    BufferedSink sink;
-    Listener listener = Listener.REFUSE_INCOMING_STREAMS;
-    PushObserver pushObserver = PushObserver.CANCEL;
-    boolean client;
-    int pingIntervalMillis;
-
-    /**
-     * @param client true if this peer initiated the connection; false if this peer accepted the
-     * connection.
-     */
-    public Builder(boolean client) {
-      this.client = client;
-    }
-
-    public Builder socket(Socket socket) throws IOException {
-      SocketAddress remoteSocketAddress = socket.getRemoteSocketAddress();
-      String connectionName = remoteSocketAddress instanceof InetSocketAddress
-          ? ((InetSocketAddress) remoteSocketAddress).getHostName()
-          : remoteSocketAddress.toString();
-      return socket(socket, connectionName,
-          Okio.buffer(Okio.source(socket)), Okio.buffer(Okio.sink(socket)));
-    }
-
-    public Builder socket(
-        Socket socket, String connectionName, BufferedSource source, BufferedSink sink) {
-      this.socket = socket;
-      this.connectionName = connectionName;
-      this.source = source;
-      this.sink = sink;
-      return this;
-    }
-
-    public Builder listener(Listener listener) {
-      this.listener = listener;
-      return this;
-    }
-
-    public Builder pushObserver(PushObserver pushObserver) {
-      this.pushObserver = pushObserver;
-      return this;
-    }
-
-    public Builder pingIntervalMillis(int pingIntervalMillis) {
-      this.pingIntervalMillis = pingIntervalMillis;
-      return this;
-    }
-
-    public Http2Connection build() {
-      return new Http2Connection(this);
-    }
-  }
-
-  /**
-   * Methods in this class must not lock FrameWriter.  If a method needs to write a frame, create an
-   * async task to do so.
-   */
-  class ReaderRunnable extends NamedRunnable implements Http2Reader.Handler {
-    final Http2Reader reader;
-
-    ReaderRunnable(Http2Reader reader) {
-      super("OkHttp %s", connectionName);
-      this.reader = reader;
-    }
-
-    @Override protected void execute() {
-      ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
-      ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
-      IOException errorException = null;
-      try {
-        reader.readConnectionPreface(this);
-        while (reader.nextFrame(false, this)) {
-        }
-        connectionErrorCode = ErrorCode.NO_ERROR;
-        streamErrorCode = ErrorCode.CANCEL;
-      } catch (IOException e) {
-        errorException = e;
-        connectionErrorCode = ErrorCode.PROTOCOL_ERROR;
-        streamErrorCode = ErrorCode.PROTOCOL_ERROR;
-      } finally {
-        close(connectionErrorCode, streamErrorCode, errorException);
-        Util.closeQuietly(reader);
-      }
-    }
-
-    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
-        throws IOException {
-      if (pushedStream(streamId)) {
-        pushDataLater(streamId, source, length, inFinished);
-        return;
-      }
-      Http2Stream dataStream = getStream(streamId);
-      if (dataStream == null) {
-        writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
-        updateConnectionFlowControl(length);
-        source.skip(length);
-        return;
-      }
-      dataStream.receiveData(source, length);
-      if (inFinished) {
-        dataStream.receiveHeaders(Util.EMPTY_HEADERS, true);
-      }
-    }
-
-    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock) {
-      if (pushedStream(streamId)) {
-        pushHeadersLater(streamId, headerBlock, inFinished);
-        return;
-      }
-      Http2Stream stream;
-      synchronized (Http2Connection.this) {
-        stream = getStream(streamId);
-
-        if (stream == null) {
-          // If we're shutdown, don't bother with this stream.
-          if (shutdown) return;
-
-          // If the stream ID is less than the last created ID, assume it's already closed.
-          if (streamId <= lastGoodStreamId) return;
-
-          // If the stream ID is in the client's namespace, assume it's already closed.
-          if (streamId % 2 == nextStreamId % 2) return;
-
-          // Create a stream.
-          Headers headers = Util.toHeaders(headerBlock);
-          final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this,
-              false, inFinished, headers);
-          lastGoodStreamId = streamId;
-          streams.put(streamId, newStream);
-          listenerExecutor.execute(new NamedRunnable(
-              "OkHttp %s stream %d", connectionName, streamId) {
-            @Override public void execute() {
-              try {
-                listener.onStream(newStream);
-              } catch (IOException e) {
-                Platform.get().log(
-                    INFO, "Http2Connection.Listener failure for " + connectionName, e);
-                try {
-                  newStream.close(ErrorCode.PROTOCOL_ERROR, e);
-                } catch (IOException ignored) {
-                }
-              }
-            }
-          });
-          return;
-        }
-      }
-
-      // Update an existing stream.
-      stream.receiveHeaders(Util.toHeaders(headerBlock), inFinished);
-    }
-
-    @Override public void rstStream(int streamId, ErrorCode errorCode) {
-      if (pushedStream(streamId)) {
-        pushResetLater(streamId, errorCode);
-        return;
-      }
-      Http2Stream rstStream = removeStream(streamId);
-      if (rstStream != null) {
-        rstStream.receiveRstStream(errorCode);
-      }
-    }
-
-    @Override public void settings(boolean clearPrevious, Settings newSettings) {
-      long delta = 0;
-      Http2Stream[] streamsToNotify = null;
-      synchronized (Http2Connection.this) {
-        int priorWriteWindowSize = peerSettings.getInitialWindowSize();
-        if (clearPrevious) peerSettings.clear();
-        peerSettings.merge(newSettings);
-        applyAndAckSettings(newSettings);
-        int peerInitialWindowSize = peerSettings.getInitialWindowSize();
-        if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
-          delta = peerInitialWindowSize - priorWriteWindowSize;
-          if (!receivedInitialPeerSettings) {
-            receivedInitialPeerSettings = true;
-          }
-          if (!streams.isEmpty()) {
-            streamsToNotify = streams.values().toArray(new Http2Stream[0]);
-          }
-        }
-        listenerExecutor.execute(new NamedRunnable("OkHttp %s settings", connectionName) {
-          @Override public void execute() {
-            listener.onSettings(Http2Connection.this);
-          }
-        });
-      }
-      if (streamsToNotify != null && delta != 0) {
-        for (Http2Stream stream : streamsToNotify) {
-          synchronized (stream) {
-            stream.addBytesToWriteWindow(delta);
-          }
-        }
-      }
-    }
-
-    private void applyAndAckSettings(final Settings peerSettings) {
-      try {
-        writerExecutor.execute(new NamedRunnable("OkHttp %s ACK Settings", connectionName) {
-          @Override public void execute() {
-            try {
-              writer.applyAndAckSettings(peerSettings);
-            } catch (IOException e) {
-              failConnection(e);
-            }
-          }
-        });
-      } catch (RejectedExecutionException ignored) {
-        // This connection has been closed.
-      }
-    }
-
-    @Override public void ackSettings() {
-      // TODO: If we don't get this callback after sending settings to the peer, SETTINGS_TIMEOUT.
-    }
-
-    @Override public void ping(boolean reply, int payload1, int payload2) {
-      if (reply) {
-        synchronized (Http2Connection.this) {
-          awaitingPong = false;
-          Http2Connection.this.notifyAll();
-        }
-      } else {
-        try {
-          // Send a reply to a client ping if this is a server and vice versa.
-          writerExecutor.execute(new PingRunnable(true, payload1, payload2));
-        } catch (RejectedExecutionException ignored) {
-          // This connection has been closed.
-        }
-      }
-    }
-
-    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-      if (debugData.size() > 0) { // TODO: log the debugData
-      }
-
-      // Copy the streams first. We don't want to hold a lock when we call receiveRstStream().
-      Http2Stream[] streamsCopy;
-      synchronized (Http2Connection.this) {
-        streamsCopy = streams.values().toArray(new Http2Stream[0]);
-        shutdown = true;
-      }
-
-      // Fail all streams created after the last good stream ID.
-      for (Http2Stream http2Stream : streamsCopy) {
-        if (http2Stream.getId() > lastGoodStreamId && http2Stream.isLocallyInitiated()) {
-          http2Stream.receiveRstStream(REFUSED_STREAM);
-          removeStream(http2Stream.getId());
-        }
-      }
-    }
-
-    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-      if (streamId == 0) {
-        synchronized (Http2Connection.this) {
-          bytesLeftInWriteWindow += windowSizeIncrement;
-          Http2Connection.this.notifyAll();
-        }
-      } else {
-        Http2Stream stream = getStream(streamId);
-        if (stream != null) {
-          synchronized (stream) {
-            stream.addBytesToWriteWindow(windowSizeIncrement);
-          }
-        }
-      }
-    }
-
-    @Override public void priority(int streamId, int streamDependency, int weight,
-        boolean exclusive) {
-      // TODO: honor priority.
-    }
-
-    @Override
-    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders) {
-      pushRequestLater(promisedStreamId, requestHeaders);
-    }
-
-    @Override public void alternateService(int streamId, String origin, ByteString protocol,
-        String host, int port, long maxAge) {
-      // TODO: register alternate service.
-    }
-  }
-
-  /** Even, positive numbered streams are pushed streams in HTTP/2. */
-  boolean pushedStream(int streamId) {
-    return streamId != 0 && (streamId & 1) == 0;
-  }
-
-  // Guarded by this.
-  final Set<Integer> currentPushRequests = new LinkedHashSet<>();
-
-  void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
-    synchronized (this) {
-      if (currentPushRequests.contains(streamId)) {
-        writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
-        return;
-      }
-      currentPushRequests.add(streamId);
-    }
-    try {
-      pushExecutorExecute(new NamedRunnable(
-          "OkHttp %s Push Request[%s]", connectionName, streamId) {
-        @Override public void execute() {
-          boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
-          try {
-            if (cancel) {
-              writer.rstStream(streamId, ErrorCode.CANCEL);
-              synchronized (Http2Connection.this) {
-                currentPushRequests.remove(streamId);
-              }
-            }
-          } catch (IOException ignored) {
-          }
-        }
-      });
-    } catch (RejectedExecutionException ignored) {
-      // This connection has been closed.
-    }
-  }
-
-  void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
-      final boolean inFinished) {
-    try {
-      pushExecutorExecute(new NamedRunnable(
-          "OkHttp %s Push Headers[%s]", connectionName, streamId) {
-        @Override public void execute() {
-          boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
-          try {
-            if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);
-            if (cancel || inFinished) {
-              synchronized (Http2Connection.this) {
-                currentPushRequests.remove(streamId);
-              }
-            }
-          } catch (IOException ignored) {
-          }
-        }
-      });
-    } catch (RejectedExecutionException ignored) {
-      // This connection has been closed.
-    }
-  }
-
-  /**
-   * Eagerly reads {@code byteCount} bytes from the source before launching a background task to
-   * process the data.  This avoids corrupting the stream.
-   */
-  void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
-      final boolean inFinished) throws IOException {
-    final Buffer buffer = new Buffer();
-    source.require(byteCount); // Eagerly read the frame before firing client thread.
-    source.read(buffer, byteCount);
-    if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Data[%s]", connectionName, streamId) {
-      @Override public void execute() {
-        try {
-          boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
-          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);
-          if (cancel || inFinished) {
-            synchronized (Http2Connection.this) {
-              currentPushRequests.remove(streamId);
-            }
-          }
-        } catch (IOException ignored) {
-        }
-      }
-    });
-  }
-
-  void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Reset[%s]", connectionName, streamId) {
-      @Override public void execute() {
-        pushObserver.onReset(streamId, errorCode);
-        synchronized (Http2Connection.this) {
-          currentPushRequests.remove(streamId);
-        }
-      }
-    });
-  }
-
-  private synchronized void pushExecutorExecute(NamedRunnable namedRunnable) {
-    if (!isShutdown()) {
-      pushExecutor.execute(namedRunnable);
-    }
-  }
-
-  /** Listener of streams and settings initiated by the peer. */
-  public abstract static class Listener {
-    public static final Listener REFUSE_INCOMING_STREAMS = new Listener() {
-      @Override public void onStream(Http2Stream stream) throws IOException {
-        stream.close(REFUSED_STREAM, null);
-      }
-    };
-
-    /**
-     * Handle a new stream from this connection's peer. Implementations should respond by either
-     * {@linkplain Http2Stream#writeHeaders replying to the stream} or {@linkplain
-     * Http2Stream#close closing it}. This response does not need to be synchronous.
-     */
-    public abstract void onStream(Http2Stream stream) throws IOException;
-
-    /**
-     * Notification that the connection's peer's settings may have changed. Implementations should
-     * take appropriate action to handle the updated settings.
-     *
-     * <p>It is the implementation's responsibility to handle concurrent calls to this method. A
-     * remote peer that sends multiple settings frames will trigger multiple calls to this method,
-     * and those calls are not necessarily serialized.
-     */
-    public void onSettings(Http2Connection connection) {
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
new file mode 100644
index 0000000000..663b6f4038
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.kt
@@ -0,0 +1,919 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2
+
+import okhttp3.internal.EMPTY_BYTE_ARRAY
+import okhttp3.internal.EMPTY_HEADERS
+import okhttp3.internal.closeQuietly
+import okhttp3.internal.connectionName
+import okhttp3.internal.execute
+import okhttp3.internal.format
+import okhttp3.internal.http2.ErrorCode.REFUSED_STREAM
+import okhttp3.internal.http2.Settings.Companion.DEFAULT_INITIAL_WINDOW_SIZE
+import okhttp3.internal.ignoreIoExceptions
+import okhttp3.internal.notifyAll
+import okhttp3.internal.platform.Platform
+import okhttp3.internal.platform.Platform.Companion.INFO
+import okhttp3.internal.threadFactory
+import okhttp3.internal.threadName
+import okhttp3.internal.toHeaders
+import okhttp3.internal.tryExecute
+import okhttp3.internal.wait
+import okio.Buffer
+import okio.BufferedSink
+import okio.BufferedSource
+import okio.ByteString
+import okio.buffer
+import okio.sink
+import okio.source
+import java.io.Closeable
+import java.io.IOException
+import java.io.InterruptedIOException
+import java.net.Socket
+import java.util.concurrent.LinkedBlockingQueue
+import java.util.concurrent.ScheduledThreadPoolExecutor
+import java.util.concurrent.SynchronousQueue
+import java.util.concurrent.ThreadPoolExecutor
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.TimeUnit.MILLISECONDS
+
+/**
+ * A socket connection to a remote peer. A connection hosts streams which can send and receive
+ * data.
+ *
+ * Many methods in this API are **synchronous:** the call is completed before the method returns.
+ * This is typical for Java but atypical for HTTP/2. This is motivated by exception transparency:
+ * an [IOException] that was triggered by a certain caller can be caught and handled by that caller.
+ */
+@Suppress("NAME_SHADOWING")
+class Http2Connection internal constructor(builder: Builder) : Closeable {
+
+  // Internal state of this connection is guarded by 'this'. No blocking operations may be
+  // performed while holding this lock!
+  //
+  // Socket writes are guarded by frameWriter.
+  //
+  // Socket reads are unguarded but are only made by the reader thread.
+  //
+  // Certain operations (like SYN_STREAM) need to synchronize on both the frameWriter (to do
+  // blocking I/O) and this (to create streams). Such operations must synchronize on 'this' last.
+  // This ensures that we never wait for a blocking operation while holding 'this'.
+
+  /** True if this peer initiated the connection. */
+  internal val client: Boolean = builder.client
+
+  /**
+   * User code to run in response to incoming streams or settings. Calls to this are always invoked
+   * on [listenerExecutor].
+   */
+  internal val listener: Listener = builder.listener
+  internal val streams = mutableMapOf<Int, Http2Stream>()
+  internal val connectionName: String = builder.connectionName
+  internal var lastGoodStreamId = 0
+
+  /** http://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-5.1.1 */
+  internal var nextStreamId = if (builder.client) 3 else 2
+
+  @get:Synchronized var isShutdown = false
+    internal set
+
+  /** Asynchronously writes frames to the outgoing socket. */
+  private val writerExecutor = ScheduledThreadPoolExecutor(1,
+      threadFactory(format("OkHttp %s Writer", connectionName), false))
+
+  /** Ensures push promise callbacks events are sent in order per stream. */
+  // Like newSingleThreadExecutor, except lazy creates the thread.
+  private val pushExecutor = ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS, LinkedBlockingQueue(),
+      threadFactory(format("OkHttp %s Push Observer", connectionName), true))
+
+  /** User code to run in response to push promise events. */
+  private val pushObserver: PushObserver = builder.pushObserver
+
+  /** True if we have sent a ping that is still awaiting a reply. */
+  private var awaitingPong = false
+
+  /** Settings we communicate to the peer. */
+  val okHttpSettings = Settings().apply {
+    // Flow control was designed more for servers, or proxies than edge clients. If we are a client,
+    // set the flow control window to 16MiB.  This avoids thrashing window updates every 64KiB, yet
+    // small enough to avoid blowing up the heap.
+    if (builder.client) {
+      set(Settings.INITIAL_WINDOW_SIZE, OKHTTP_CLIENT_WINDOW_SIZE)
+    }
+  }
+
+  /** Settings we receive from the peer. */
+  // TODO: MWS will need to guard on this setting before attempting to push.
+  val peerSettings = Settings().apply {
+    set(Settings.INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE)
+    set(Settings.MAX_FRAME_SIZE, Http2.INITIAL_MAX_FRAME_SIZE)
+  }
+
+  /**
+   * The total number of bytes consumed by the application, but not yet acknowledged by sending a
+   * `WINDOW_UPDATE` frame on this connection.
+   */
+  // Visible for testing
+  var unacknowledgedBytesRead = 0L
+    private set
+
+  /**
+   * Count of bytes that can be written on the connection before receiving a window update.
+   */
+  // Visible for testing
+  var bytesLeftInWriteWindow: Long = peerSettings.initialWindowSize.toLong()
+    internal set
+
+  internal var receivedInitialPeerSettings = false
+  internal val socket: Socket = builder.socket
+  val writer = Http2Writer(builder.sink, client)
+
+  // Visible for testing
+  val readerRunnable = ReaderRunnable(Http2Reader(builder.source, client))
+
+  // Guarded by this.
+  private val currentPushRequests = mutableSetOf<Int>()
+
+  init {
+    if (builder.pingIntervalMillis != 0) {
+      writerExecutor.scheduleAtFixedRate({
+        threadName("OkHttp $connectionName ping") {
+          writePing(false, 0, 0)
+        }
+      }, builder.pingIntervalMillis.toLong(), builder.pingIntervalMillis.toLong(), MILLISECONDS)
+    }
+  }
+
+  /**
+   * Returns the number of [open streams][Http2Stream.isOpen] on this connection.
+   */
+  @Synchronized fun openStreamCount(): Int = streams.size
+
+  @Synchronized fun getStream(id: Int): Http2Stream? = streams[id]
+
+  @Synchronized internal fun removeStream(streamId: Int): Http2Stream? {
+    val stream = streams.remove(streamId)
+
+    // The removed stream may be blocked on a connection-wide window update.
+    notifyAll()
+
+    return stream
+  }
+
+  @Synchronized fun maxConcurrentStreams(): Int =
+      peerSettings.getMaxConcurrentStreams(Integer.MAX_VALUE)
+
+  @Synchronized internal fun updateConnectionFlowControl(read: Long) {
+    unacknowledgedBytesRead += read
+    if (unacknowledgedBytesRead >= okHttpSettings.initialWindowSize / 2) {
+      writeWindowUpdateLater(0, unacknowledgedBytesRead)
+      unacknowledgedBytesRead = 0
+    }
+  }
+
+  /**
+   * Returns a new server-initiated stream.
+   *
+   * @param associatedStreamId the stream that triggered the sender to create this stream.
+   * @param out true to create an output stream that we can use to send data to the remote peer.
+   *     Corresponds to `FLAG_FIN`.
+   */
+  @Throws(IOException::class)
+  fun pushStream(
+    associatedStreamId: Int,
+    requestHeaders: List<Header>,
+    out: Boolean
+  ): Http2Stream {
+    check(!client) { "Client cannot push requests." }
+    return newStream(associatedStreamId, requestHeaders, out)
+  }
+
+  /**
+   * Returns a new locally-initiated stream.
+   *
+   * @param out true to create an output stream that we can use to send data to the remote peer.
+   *     Corresponds to `FLAG_FIN`.
+   */
+  @Throws(IOException::class)
+  fun newStream(
+    requestHeaders: List<Header>,
+    out: Boolean
+  ): Http2Stream {
+    return newStream(0, requestHeaders, out)
+  }
+
+  @Throws(IOException::class)
+  private fun newStream(
+    associatedStreamId: Int,
+    requestHeaders: List<Header>,
+    out: Boolean
+  ): Http2Stream {
+    val outFinished = !out
+    val inFinished = false
+    val flushHeaders: Boolean
+    val stream: Http2Stream
+    val streamId: Int
+
+    synchronized(writer) {
+      synchronized(this) {
+        if (nextStreamId > Integer.MAX_VALUE / 2) {
+          shutdown(REFUSED_STREAM)
+        }
+        if (isShutdown) {
+          throw ConnectionShutdownException()
+        }
+        streamId = nextStreamId
+        nextStreamId += 2
+        stream = Http2Stream(streamId, this, outFinished, inFinished, null)
+        flushHeaders = (!out || bytesLeftInWriteWindow == 0L || stream.bytesLeftInWriteWindow == 0L)
+        if (stream.isOpen) {
+          streams[streamId] = stream
+        }
+      }
+      if (associatedStreamId == 0) {
+        writer.headers(outFinished, streamId, requestHeaders)
+      } else {
+        require(!client) { "client streams shouldn't have associated stream IDs" }
+        // HTTP/2 has a PUSH_PROMISE frame.
+        writer.pushPromise(associatedStreamId, streamId, requestHeaders)
+      }
+    }
+
+    if (flushHeaders) {
+      writer.flush()
+    }
+
+    return stream
+  }
+
+  @Throws(IOException::class)
+  internal fun writeHeaders(
+    streamId: Int,
+    outFinished: Boolean,
+    alternating: List<Header>
+  ) {
+    writer.headers(outFinished, streamId, alternating)
+  }
+
+  /**
+   * Callers of this method are not thread safe, and sometimes on application threads. Most often,
+   * this method will be called to send a buffer worth of data to the peer.
+   *
+   * Writes are subject to the write window of the stream and the connection. Until there is a
+   * window sufficient to send [byteCount], the caller will block. For example, a user of
+   * `HttpURLConnection` who flushes more bytes to the output stream than the connection's write
+   * window will block.
+   *
+   * Zero [byteCount] writes are not subject to flow control and will not block. The only use case
+   * for zero [byteCount] is closing a flushed output stream.
+   */
+  @Throws(IOException::class)
+  fun writeData(
+    streamId: Int,
+    outFinished: Boolean,
+    buffer: Buffer?,
+    byteCount: Long
+  ) {
+    // Empty data frames are not flow-controlled.
+    if (byteCount == 0L) {
+      writer.data(outFinished, streamId, buffer, 0)
+      return
+    }
+
+    var byteCount = byteCount
+    while (byteCount > 0L) {
+      var toWrite: Int
+      synchronized(this@Http2Connection) {
+        try {
+          while (bytesLeftInWriteWindow <= 0L) {
+            // Before blocking, confirm that the stream we're writing is still open. It's possible
+            // that the stream has since been closed (such as if this write timed out.)
+            if (!streams.containsKey(streamId)) {
+              throw IOException("stream closed")
+            }
+            this@Http2Connection.wait() // Wait until we receive a WINDOW_UPDATE.
+          }
+        } catch (e: InterruptedException) {
+          Thread.currentThread().interrupt() // Retain interrupted status.
+          throw InterruptedIOException()
+        }
+
+        toWrite = minOf(byteCount, bytesLeftInWriteWindow).toInt()
+        toWrite = minOf(toWrite, writer.maxDataLength())
+        bytesLeftInWriteWindow -= toWrite.toLong()
+      }
+
+      byteCount -= toWrite.toLong()
+      writer.data(outFinished && byteCount == 0L, streamId, buffer, toWrite)
+    }
+  }
+
+  internal fun writeSynResetLater(
+    streamId: Int,
+    errorCode: ErrorCode
+  ) {
+    writerExecutor.tryExecute("OkHttp $connectionName stream $streamId") {
+      try {
+        writeSynReset(streamId, errorCode)
+      } catch (e: IOException) {
+        failConnection(e)
+      }
+    }
+  }
+
+  @Throws(IOException::class)
+  internal fun writeSynReset(
+    streamId: Int,
+    statusCode: ErrorCode
+  ) {
+    writer.rstStream(streamId, statusCode)
+  }
+
+  internal fun writeWindowUpdateLater(
+    streamId: Int,
+    unacknowledgedBytesRead: Long
+  ) {
+    writerExecutor.tryExecute("OkHttp Window Update $connectionName stream $streamId") {
+      try {
+        writer.windowUpdate(streamId, unacknowledgedBytesRead)
+      } catch (e: IOException) {
+        failConnection(e)
+      }
+    }
+  }
+
+  fun writePing(
+    reply: Boolean,
+    payload1: Int,
+    payload2: Int
+  ) {
+    if (!reply) {
+      val failedDueToMissingPong: Boolean
+      synchronized(this) {
+        failedDueToMissingPong = awaitingPong
+        awaitingPong = true
+      }
+      if (failedDueToMissingPong) {
+        failConnection(null)
+        return
+      }
+    }
+
+    try {
+      writer.ping(reply, payload1, payload2)
+    } catch (e: IOException) {
+      failConnection(e)
+    }
+  }
+
+  /** For testing: sends a ping and waits for a pong. */
+  @Throws(InterruptedException::class)
+  fun writePingAndAwaitPong() {
+    writePing(false, 0x4f4b6f6b /* "OKok" */, -0xf607257 /* donut */)
+    awaitPong()
+  }
+
+  /** For testing: waits until `requiredPongCount` pings have been received from the peer. */
+  @Synchronized @Throws(InterruptedException::class)
+  fun awaitPong() {
+    while (awaitingPong) {
+      wait()
+    }
+  }
+
+  @Throws(IOException::class)
+  fun flush() {
+    writer.flush()
+  }
+
+  /**
+   * Degrades this connection such that new streams can neither be created locally, nor accepted
+   * from the remote peer. Existing streams are not impacted. This is intended to permit an endpoint
+   * to gracefully stop accepting new requests without harming previously established streams.
+   */
+  @Throws(IOException::class)
+  fun shutdown(statusCode: ErrorCode) {
+    synchronized(writer) {
+      val lastGoodStreamId: Int
+      synchronized(this) {
+        if (isShutdown) {
+          return
+        }
+        isShutdown = true
+        lastGoodStreamId = this.lastGoodStreamId
+      }
+      // TODO: propagate exception message into debugData.
+      // TODO: configure a timeout on the reader so that it doesn’t block forever.
+      writer.goAway(lastGoodStreamId, statusCode, EMPTY_BYTE_ARRAY)
+    }
+  }
+
+  /**
+   * Closes this connection. This cancels all open streams and unanswered pings. It closes the
+   * underlying input and output streams and shuts down internal executor services.
+   */
+  override fun close() {
+    close(ErrorCode.NO_ERROR, ErrorCode.CANCEL, null)
+  }
+
+  internal fun close(
+    connectionCode: ErrorCode,
+    streamCode: ErrorCode,
+    cause: IOException?
+  ) {
+    assert(!Thread.holdsLock(this))
+    ignoreIoExceptions {
+      shutdown(connectionCode)
+    }
+
+    var streamsToClose: Array<Http2Stream>? = null
+    synchronized(this) {
+      if (streams.isNotEmpty()) {
+        streamsToClose = streams.values.toTypedArray()
+        streams.clear()
+      }
+    }
+
+    streamsToClose?.forEach { stream ->
+      ignoreIoExceptions {
+        stream.close(streamCode, cause)
+      }
+    }
+
+    // Close the writer to release its resources (such as deflaters).
+    ignoreIoExceptions {
+      writer.close()
+    }
+
+    // Close the socket to break out the reader thread, which will clean up after itself.
+    ignoreIoExceptions {
+      socket.close()
+    }
+
+    // Release the threads.
+    writerExecutor.shutdown()
+    pushExecutor.shutdown()
+  }
+
+  private fun failConnection(e: IOException?) {
+    close(ErrorCode.PROTOCOL_ERROR, ErrorCode.PROTOCOL_ERROR, e)
+  }
+
+  /**
+   * Sends any initial frames and starts reading frames from the remote peer. This should be called
+   * after [Builder.build] for all new connections.
+   *
+   * @param sendConnectionPreface true to send connection preface frames. This should always be true
+   *     except for in tests that don't check for a connection preface.
+   */
+  @Throws(IOException::class) @JvmOverloads
+  fun start(sendConnectionPreface: Boolean = true) {
+    if (sendConnectionPreface) {
+      writer.connectionPreface()
+      writer.settings(okHttpSettings)
+      val windowSize = okHttpSettings.initialWindowSize
+      if (windowSize != DEFAULT_INITIAL_WINDOW_SIZE) {
+        writer.windowUpdate(0, (windowSize - DEFAULT_INITIAL_WINDOW_SIZE).toLong())
+      }
+    }
+    Thread(readerRunnable, "OkHttp $connectionName").start() // Not a daemon thread.
+  }
+
+  /** Merges [settings] into this peer's settings and sends them to the remote peer. */
+  @Throws(IOException::class)
+  fun setSettings(settings: Settings) {
+    synchronized(writer) {
+      synchronized(this) {
+        if (isShutdown) {
+          throw ConnectionShutdownException()
+        }
+        okHttpSettings.merge(settings)
+      }
+      writer.settings(settings)
+    }
+  }
+
+  class Builder(
+    /** True if this peer initiated the connection; false if this peer accepted the connection. */
+    internal var client: Boolean
+  ) {
+    internal lateinit var socket: Socket
+    internal lateinit var connectionName: String
+    internal lateinit var source: BufferedSource
+    internal lateinit var sink: BufferedSink
+    internal var listener = Listener.REFUSE_INCOMING_STREAMS
+    internal var pushObserver = PushObserver.CANCEL
+    internal var pingIntervalMillis: Int = 0
+
+    @Throws(IOException::class) @JvmOverloads
+    fun socket(
+      socket: Socket,
+      connectionName: String = socket.connectionName(),
+      source: BufferedSource = socket.source().buffer(),
+      sink: BufferedSink = socket.sink().buffer()
+    ) = apply {
+      this.socket = socket
+      this.connectionName = connectionName
+      this.source = source
+      this.sink = sink
+    }
+
+    fun listener(listener: Listener) = apply {
+      this.listener = listener
+    }
+
+    fun pushObserver(pushObserver: PushObserver) = apply {
+      this.pushObserver = pushObserver
+    }
+
+    fun pingIntervalMillis(pingIntervalMillis: Int) = apply {
+      this.pingIntervalMillis = pingIntervalMillis
+    }
+
+    fun build(): Http2Connection {
+      return Http2Connection(this)
+    }
+  }
+
+  /**
+   * Methods in this class must not lock FrameWriter. If a method needs to write a frame, create an
+   * async task to do so.
+   */
+  inner class ReaderRunnable internal constructor(
+    internal val reader: Http2Reader
+  ) : Runnable, Http2Reader.Handler {
+    override fun run() {
+      var connectionErrorCode = ErrorCode.INTERNAL_ERROR
+      var streamErrorCode = ErrorCode.INTERNAL_ERROR
+      var errorException: IOException? = null
+      try {
+        reader.readConnectionPreface(this)
+        while (reader.nextFrame(false, this)) {
+        }
+        connectionErrorCode = ErrorCode.NO_ERROR
+        streamErrorCode = ErrorCode.CANCEL
+      } catch (e: IOException) {
+        errorException = e
+        connectionErrorCode = ErrorCode.PROTOCOL_ERROR
+        streamErrorCode = ErrorCode.PROTOCOL_ERROR
+      } finally {
+        close(connectionErrorCode, streamErrorCode, errorException)
+        reader.closeQuietly()
+      }
+    }
+
+    @Throws(IOException::class)
+    override fun data(
+      inFinished: Boolean,
+      streamId: Int,
+      source: BufferedSource,
+      length: Int
+    ) {
+      if (pushedStream(streamId)) {
+        pushDataLater(streamId, source, length, inFinished)
+        return
+      }
+      val dataStream = getStream(streamId)
+      if (dataStream == null) {
+        writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR)
+        updateConnectionFlowControl(length.toLong())
+        source.skip(length.toLong())
+        return
+      }
+      dataStream.receiveData(source, length)
+      if (inFinished) {
+        dataStream.receiveHeaders(EMPTY_HEADERS, true)
+      }
+    }
+
+    override fun headers(
+      inFinished: Boolean,
+      streamId: Int,
+      associatedStreamId: Int,
+      headerBlock: List<Header>
+    ) {
+      if (pushedStream(streamId)) {
+        pushHeadersLater(streamId, headerBlock, inFinished)
+        return
+      }
+      val stream: Http2Stream?
+      synchronized(this@Http2Connection) {
+        stream = getStream(streamId)
+
+        if (stream == null) {
+          // If we're shutdown, don't bother with this stream.
+          if (isShutdown) return
+
+          // If the stream ID is less than the last created ID, assume it's already closed.
+          if (streamId <= lastGoodStreamId) return
+
+          // If the stream ID is in the client's namespace, assume it's already closed.
+          if (streamId % 2 == nextStreamId % 2) return
+
+          // Create a stream.
+          val headers = headerBlock.toHeaders()
+          val newStream = Http2Stream(streamId, this@Http2Connection, false, inFinished, headers)
+          lastGoodStreamId = streamId
+          streams[streamId] = newStream
+          listenerExecutor.execute("OkHttp $connectionName stream $streamId") {
+            try {
+              listener.onStream(newStream)
+            } catch (e: IOException) {
+              Platform.get().log(INFO, "Http2Connection.Listener failure for $connectionName", e)
+              ignoreIoExceptions {
+                newStream.close(ErrorCode.PROTOCOL_ERROR, e)
+              }
+            }
+          }
+          return
+        }
+      }
+
+      // Update an existing stream.
+      stream!!.receiveHeaders(headerBlock.toHeaders(), inFinished)
+    }
+
+    override fun rstStream(streamId: Int, errorCode: ErrorCode) {
+      if (pushedStream(streamId)) {
+        pushResetLater(streamId, errorCode)
+        return
+      }
+      val rstStream = removeStream(streamId)
+      rstStream?.receiveRstStream(errorCode)
+    }
+
+    override fun settings(clearPrevious: Boolean, settings: Settings) {
+      var delta = 0L
+      var streamsToNotify: Array<Http2Stream>? = null
+      synchronized(this@Http2Connection) {
+        val priorWriteWindowSize = peerSettings.initialWindowSize
+        if (clearPrevious) peerSettings.clear()
+        peerSettings.merge(settings)
+        applyAndAckSettings(settings)
+        val peerInitialWindowSize = peerSettings.initialWindowSize
+        if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
+          delta = (peerInitialWindowSize - priorWriteWindowSize).toLong()
+          if (!receivedInitialPeerSettings) {
+            receivedInitialPeerSettings = true
+          }
+          if (streams.isNotEmpty()) {
+            streamsToNotify = streams.values.toTypedArray()
+          }
+        }
+        listenerExecutor.execute("OkHttp $connectionName settings") {
+          listener.onSettings(this@Http2Connection)
+        }
+      }
+      if (streamsToNotify != null && delta != 0L) {
+        for (stream in streamsToNotify!!) {
+          synchronized(stream) {
+            stream.addBytesToWriteWindow(delta)
+          }
+        }
+      }
+    }
+
+    private fun applyAndAckSettings(peerSettings: Settings) {
+      writerExecutor.tryExecute("OkHttp $connectionName ACK Settings") {
+        try {
+          writer.applyAndAckSettings(peerSettings)
+        } catch (e: IOException) {
+          failConnection(e)
+        }
+      }
+    }
+
+    override fun ackSettings() {
+      // TODO: If we don't get this callback after sending settings to the peer, SETTINGS_TIMEOUT.
+    }
+
+    override fun ping(
+      ack: Boolean,
+      payload1: Int,
+      payload2: Int
+    ) {
+      if (ack) {
+        synchronized(this@Http2Connection) {
+          awaitingPong = false
+          this@Http2Connection.notifyAll()
+        }
+      } else {
+        // Send a reply to a client ping if this is a server and vice versa.
+        writerExecutor.tryExecute("OkHttp $connectionName ping") {
+          writePing(true, payload1, payload2)
+        }
+      }
+    }
+
+    override fun goAway(
+      lastGoodStreamId: Int,
+      errorCode: ErrorCode,
+      debugData: ByteString
+    ) {
+      if (debugData.size > 0) {
+        // TODO: log the debugData
+      }
+
+      // Copy the streams first. We don't want to hold a lock when we call receiveRstStream().
+      val streamsCopy: Array<Http2Stream>
+      synchronized(this@Http2Connection) {
+        streamsCopy = streams.values.toTypedArray()
+        isShutdown = true
+      }
+
+      // Fail all streams created after the last good stream ID.
+      for (http2Stream in streamsCopy) {
+        if (http2Stream.id > lastGoodStreamId && http2Stream.isLocallyInitiated) {
+          http2Stream.receiveRstStream(REFUSED_STREAM)
+          removeStream(http2Stream.id)
+        }
+      }
+    }
+
+    override fun windowUpdate(streamId: Int, windowSizeIncrement: Long) {
+      if (streamId == 0) {
+        synchronized(this@Http2Connection) {
+          bytesLeftInWriteWindow += windowSizeIncrement
+          this@Http2Connection.notifyAll()
+        }
+      } else {
+        val stream = getStream(streamId)
+        if (stream != null) {
+          synchronized(stream) {
+            stream.addBytesToWriteWindow(windowSizeIncrement)
+          }
+        }
+      }
+    }
+
+    override fun priority(
+      streamId: Int,
+      streamDependency: Int,
+      weight: Int,
+      exclusive: Boolean
+    ) {
+      // TODO: honor priority.
+    }
+
+    override fun pushPromise(
+      streamId: Int,
+      promisedStreamId: Int,
+      requestHeaders: List<Header>
+    ) {
+      pushRequestLater(promisedStreamId, requestHeaders)
+    }
+
+    override fun alternateService(
+      streamId: Int,
+      origin: String,
+      protocol: ByteString,
+      host: String,
+      port: Int,
+      maxAge: Long
+    ) {
+      // TODO: register alternate service.
+    }
+  }
+
+  /** Even, positive numbered streams are pushed streams in HTTP/2. */
+  internal fun pushedStream(streamId: Int): Boolean = streamId != 0 && streamId and 1 == 0
+
+  internal fun pushRequestLater(streamId: Int, requestHeaders: List<Header>) {
+    synchronized(this) {
+      if (streamId in currentPushRequests) {
+        writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR)
+        return
+      }
+      currentPushRequests.add(streamId)
+    }
+    if (!isShutdown) {
+      pushExecutor.tryExecute("OkHttp $connectionName Push Request[$streamId]") {
+        val cancel = pushObserver.onRequest(streamId, requestHeaders)
+        ignoreIoExceptions {
+          if (cancel) {
+            writer.rstStream(streamId, ErrorCode.CANCEL)
+            synchronized(this@Http2Connection) {
+              currentPushRequests.remove(streamId)
+            }
+          }
+        }
+      }
+    }
+  }
+
+  internal fun pushHeadersLater(
+    streamId: Int,
+    requestHeaders: List<Header>,
+    inFinished: Boolean
+  ) {
+    if (!isShutdown) {
+      pushExecutor.tryExecute("OkHttp $connectionName Push Headers[$streamId]") {
+        val cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished)
+        ignoreIoExceptions {
+          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL)
+          if (cancel || inFinished) {
+            synchronized(this@Http2Connection) {
+              currentPushRequests.remove(streamId)
+            }
+          }
+        }
+      }
+    }
+  }
+
+  /**
+   * Eagerly reads `byteCount` bytes from the source before launching a background task to
+   * process the data.  This avoids corrupting the stream.
+   */
+  @Throws(IOException::class)
+  internal fun pushDataLater(
+    streamId: Int,
+    source: BufferedSource,
+    byteCount: Int,
+    inFinished: Boolean
+  ) {
+    val buffer = Buffer()
+    source.require(byteCount.toLong()) // Eagerly read the frame before firing client thread.
+    source.read(buffer, byteCount.toLong())
+    if (!isShutdown) {
+      pushExecutor.execute("OkHttp $connectionName Push Data[$streamId]") {
+        ignoreIoExceptions {
+          val cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished)
+          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL)
+          if (cancel || inFinished) {
+            synchronized(this@Http2Connection) {
+              currentPushRequests.remove(streamId)
+            }
+          }
+        }
+      }
+    }
+  }
+
+  internal fun pushResetLater(streamId: Int, errorCode: ErrorCode) {
+    if (!isShutdown) {
+      pushExecutor.execute("OkHttp $connectionName Push Reset[$streamId]") {
+        pushObserver.onReset(streamId, errorCode)
+        synchronized(this@Http2Connection) {
+          currentPushRequests.remove(streamId)
+        }
+      }
+    }
+  }
+
+  /** Listener of streams and settings initiated by the peer. */
+  abstract class Listener {
+    /**
+     * Handle a new stream from this connection's peer. Implementations should respond by either
+     * [replying to the stream][Http2Stream.writeHeaders] or [closing it][Http2Stream.close]. This
+     * response does not need to be synchronous.
+     */
+    @Throws(IOException::class)
+    abstract fun onStream(stream: Http2Stream)
+
+    /**
+     * Notification that the connection's peer's settings may have changed. Implementations should
+     * take appropriate action to handle the updated settings.
+     *
+     * It is the implementation's responsibility to handle concurrent calls to this method. A remote
+     * peer that sends multiple settings frames will trigger multiple calls to this method, and
+     * those calls are not necessarily serialized.
+     */
+    open fun onSettings(connection: Http2Connection) {}
+
+    companion object {
+      @JvmField
+      val REFUSE_INCOMING_STREAMS: Listener = object : Listener() {
+        @Throws(IOException::class)
+        override fun onStream(stream: Http2Stream) {
+          stream.close(REFUSED_STREAM, null)
+        }
+      }
+    }
+  }
+
+  companion object {
+    const val OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024
+
+    /**
+     * Shared executor to send notifications of incoming streams. This executor requires multiple
+     * threads because listeners are not required to return promptly.
+     */
+    private val listenerExecutor = ThreadPoolExecutor(0,
+        Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, SynchronousQueue(),
+        threadFactory("OkHttp Http2Connection", true))
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2ExchangeCodec.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2ExchangeCodec.kt
index 8b38796d40..23e51fad53 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2ExchangeCodec.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2ExchangeCodec.kt
@@ -21,12 +21,9 @@ import okhttp3.OkHttpClient
 import okhttp3.Protocol
 import okhttp3.Request
 import okhttp3.Response
-import okhttp3.internal.Internal
-import okhttp3.internal.Util
-import okhttp3.internal.addHeaderLenient
 import okhttp3.internal.connection.RealConnection
+import okhttp3.internal.headersContentLength
 import okhttp3.internal.http.ExchangeCodec
-import okhttp3.internal.http.HttpHeaders
 import okhttp3.internal.http.RequestLine
 import okhttp3.internal.http.StatusLine
 import okhttp3.internal.http.StatusLine.Companion.HTTP_CONTINUE
@@ -39,6 +36,7 @@ import okhttp3.internal.http2.Header.Companion.TARGET_PATH
 import okhttp3.internal.http2.Header.Companion.TARGET_PATH_UTF8
 import okhttp3.internal.http2.Header.Companion.TARGET_SCHEME
 import okhttp3.internal.http2.Header.Companion.TARGET_SCHEME_UTF8
+import okhttp3.internal.immutableListOf
 import okio.Sink
 import okio.Source
 import java.io.IOException
@@ -47,7 +45,7 @@ import java.util.ArrayList
 import java.util.Locale
 import java.util.concurrent.TimeUnit
 
-/** Encode requests and responses using HTTP/2 frames.  */
+/** Encode requests and responses using HTTP/2 frames. */
 class Http2ExchangeCodec(
   client: OkHttpClient,
   private val realConnection: RealConnection,
@@ -56,7 +54,7 @@ class Http2ExchangeCodec(
 ) : ExchangeCodec {
   @Volatile private var stream: Http2Stream? = null
 
-  private val protocol: Protocol = if (Protocol.H2_PRIOR_KNOWLEDGE in client.protocols()) {
+  private val protocol: Protocol = if (Protocol.H2_PRIOR_KNOWLEDGE in client.protocols) {
     Protocol.H2_PRIOR_KNOWLEDGE
   } else {
     Protocol.HTTP_2
@@ -76,7 +74,7 @@ class Http2ExchangeCodec(
   override fun writeRequestHeaders(request: Request) {
     if (stream != null) return
 
-    val hasRequestBody = request.body() != null
+    val hasRequestBody = request.body != null
     val requestHeaders = http2HeadersList(request)
     stream = connection.newStream(requestHeaders, hasRequestBody)
     // We may have been asked to cancel while creating the new stream and sending the request
@@ -100,7 +98,7 @@ class Http2ExchangeCodec(
   override fun readResponseHeaders(expectContinue: Boolean): Response.Builder? {
     val headers = stream!!.takeHeaders()
     val responseBuilder = readHttp2HeadersList(headers, protocol)
-    return if (expectContinue && Internal.instance.code(responseBuilder) == HTTP_CONTINUE) {
+    return if (expectContinue && responseBuilder.code == HTTP_CONTINUE) {
       null
     } else {
       responseBuilder
@@ -108,7 +106,7 @@ class Http2ExchangeCodec(
   }
 
   override fun reportedContentLength(response: Response): Long {
-    return HttpHeaders.contentLength(response)
+    return response.headersContentLength()
   }
 
   override fun openResponseBodySource(response: Response): Source {
@@ -134,8 +132,8 @@ class Http2ExchangeCodec(
     private const val ENCODING = "encoding"
     private const val UPGRADE = "upgrade"
 
-    /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3.  */
-    private val HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
+    /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
+    private val HTTP_2_SKIPPED_REQUEST_HEADERS = immutableListOf(
         CONNECTION,
         HOST,
         KEEP_ALIVE,
@@ -148,7 +146,7 @@ class Http2ExchangeCodec(
         TARGET_PATH_UTF8,
         TARGET_SCHEME_UTF8,
         TARGET_AUTHORITY_UTF8)
-    private val HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
+    private val HTTP_2_SKIPPED_RESPONSE_HEADERS = immutableListOf(
         CONNECTION,
         HOST,
         KEEP_ALIVE,
@@ -159,17 +157,17 @@ class Http2ExchangeCodec(
         UPGRADE)
 
     fun http2HeadersList(request: Request): List<Header> {
-      val headers = request.headers()
-      val result = ArrayList<Header>(headers.size() + 4)
-      result.add(Header(TARGET_METHOD, request.method()))
-      result.add(Header(TARGET_PATH, RequestLine.requestPath(request.url())))
+      val headers = request.headers
+      val result = ArrayList<Header>(headers.size + 4)
+      result.add(Header(TARGET_METHOD, request.method))
+      result.add(Header(TARGET_PATH, RequestLine.requestPath(request.url)))
       val host = request.header("Host")
       if (host != null) {
         result.add(Header(TARGET_AUTHORITY, host)) // Optional.
       }
-      result.add(Header(TARGET_SCHEME, request.url().scheme()))
+      result.add(Header(TARGET_SCHEME, request.url.scheme))
 
-      for (i in 0 until headers.size()) {
+      for (i in 0 until headers.size) {
         // header names must be lowercase.
         val name = headers.name(i).toLowerCase(Locale.US)
         if (name !in HTTP_2_SKIPPED_REQUEST_HEADERS ||
@@ -180,17 +178,17 @@ class Http2ExchangeCodec(
       return result
     }
 
-    /** Returns headers for a name value block containing an HTTP/2 response.  */
+    /** Returns headers for a name value block containing an HTTP/2 response. */
     fun readHttp2HeadersList(headerBlock: Headers, protocol: Protocol): Response.Builder {
       var statusLine: StatusLine? = null
       val headersBuilder = Headers.Builder()
-      for (i in 0 until headerBlock.size()) {
+      for (i in 0 until headerBlock.size) {
         val name = headerBlock.name(i)
         val value = headerBlock.value(i)
         if (name == RESPONSE_STATUS_UTF8) {
           statusLine = StatusLine.parse("HTTP/1.1 $value")
-        } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
-          addHeaderLenient(headersBuilder, name, value)
+        } else if (name !in HTTP_2_SKIPPED_RESPONSE_HEADERS) {
+          headersBuilder.addLenient(name, value)
         }
       }
       if (statusLine == null) throw ProtocolException("Expected ':status' header not present")
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.kt
index 2cb73dd312..cb7ee57358 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.kt
@@ -15,7 +15,7 @@
  */
 package okhttp3.internal.http2
 
-import okhttp3.internal.Util.format
+import okhttp3.internal.format
 import okhttp3.internal.and
 import okhttp3.internal.http2.Http2.CONNECTION_PREFACE
 import okhttp3.internal.http2.Http2.FLAG_ACK
@@ -54,8 +54,8 @@ import java.util.logging.Logger
  * This implementation assumes we do not send an increased [frame][Settings.getMaxFrameSize] to the
  * peer. Hence, we expect all frames to have a max length of [Http2.INITIAL_MAX_FRAME_SIZE].
  */
-internal class Http2Reader(
-  /** Creates a frame reader with max header table size of 4096.  */
+class Http2Reader(
+  /** Creates a frame reader with max header table size of 4096. */
   private val source: BufferedSource,
   private val client: Boolean
 ) : Closeable {
@@ -339,7 +339,7 @@ internal class Http2Reader(
         // TODO: test case for empty continuation header?
       }
 
-      val read = source.read(sink, Math.min(byteCount, left.toLong()))
+      val read = source.read(sink, minOf(byteCount, left.toLong()))
       if (read == -1L) return -1L
       left -= read.toInt()
       return read
@@ -389,7 +389,7 @@ internal class Http2Reader(
 
     fun settings(clearPrevious: Boolean, settings: Settings)
 
-    /** HTTP/2 only.  */
+    /** HTTP/2 only. */
     fun ackSettings()
 
     /**
@@ -491,7 +491,7 @@ internal class Http2Reader(
   }
 
   companion object {
-    val logger = Logger.getLogger(Http2::class.java.name)
+    val logger: Logger = Logger.getLogger(Http2::class.java.name)
 
     @Throws(IOException::class)
     fun lengthWithoutPadding(length: Int, flags: Int, padding: Int): Int {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt
index fbefa17d06..045150fed3 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.kt
@@ -16,7 +16,9 @@
 package okhttp3.internal.http2
 
 import okhttp3.Headers
-import okhttp3.internal.Util
+import okhttp3.internal.EMPTY_HEADERS
+import okhttp3.internal.notifyAll
+import okhttp3.internal.toHeaderList
 import okhttp3.internal.wait
 import okio.AsyncTimeout
 import okio.Buffer
@@ -30,7 +32,8 @@ import java.io.InterruptedIOException
 import java.net.SocketTimeoutException
 import java.util.ArrayDeque
 
-/** A logical bidirectional stream.  */
+/** A logical bidirectional stream. */
+@Suppress("NAME_SHADOWING")
 class Http2Stream internal constructor(
   val id: Int,
   val connection: Http2Connection,
@@ -60,7 +63,7 @@ class Http2Stream internal constructor(
   /** Received headers yet to be [taken][takeHeaders], or [read][FramingSource.read]. */
   private val headersQueue = ArrayDeque<Headers>()
 
-  /** True if response headers have been sent or received.  */
+  /** True if response headers have been sent or received. */
   private var hasResponseHeaders: Boolean = false
 
   internal val source = FramingSource(
@@ -116,7 +119,7 @@ class Http2Stream internal constructor(
       return true
     }
 
-  /** Returns true if this stream was created by this peer.  */
+  /** Returns true if this stream was created by this peer. */
   val isLocallyInitiated: Boolean
     get() {
       val streamIsClient = (id and 1) == 1
@@ -156,7 +159,7 @@ class Http2Stream internal constructor(
     check(source.finished && source.receiveBuffer.exhausted() && source.readBuffer.exhausted()) {
       "too early; can't read the trailers yet"
     }
-    return source.trailers ?: Util.EMPTY_HEADERS
+    return source.trailers ?: EMPTY_HEADERS
   }
 
   /**
@@ -196,7 +199,7 @@ class Http2Stream internal constructor(
   fun enqueueTrailers(trailers: Headers) {
     synchronized(this) {
       check(!sink.finished) { "already finished" }
-      require(trailers.size() != 0) { "trailers.size() == 0" }
+      require(trailers.size != 0) { "trailers.size() == 0" }
       this.sink.trailers = trailers
     }
   }
@@ -205,7 +208,7 @@ class Http2Stream internal constructor(
 
   fun writeTimeout(): Timeout = writeTimeout
 
-  /** Returns a source that reads data from the peer.  */
+  /** Returns a source that reads data from the peer. */
   fun getSource(): Source = source
 
   /**
@@ -245,7 +248,7 @@ class Http2Stream internal constructor(
     connection.writeSynResetLater(id, errorCode)
   }
 
-  /** Returns true if this stream was closed.  */
+  /** Returns true if this stream was closed. */
   private fun closeInternal(errorCode: ErrorCode, errorException: IOException?): Boolean {
     assert(!Thread.holdsLock(this))
     synchronized(this) {
@@ -257,7 +260,7 @@ class Http2Stream internal constructor(
       }
       this.errorCode = errorCode
       this.errorException = errorException
-      (this as Object).notifyAll()
+      notifyAll()
     }
     connection.removeStream(id)
     return true
@@ -287,7 +290,7 @@ class Http2Stream internal constructor(
         this.source.finished = true
       }
       open = isOpen
-      (this as Object).notifyAll()
+      notifyAll()
     }
     if (!open) {
       connection.removeStream(id)
@@ -297,7 +300,7 @@ class Http2Stream internal constructor(
   @Synchronized fun receiveRstStream(errorCode: ErrorCode) {
     if (this.errorCode == null) {
       this.errorCode = errorCode
-      (this as Object).notifyAll()
+      notifyAll()
     }
   }
 
@@ -307,7 +310,7 @@ class Http2Stream internal constructor(
    * readers.
    */
   inner class FramingSource internal constructor(
-    /** Maximum number of bytes to buffer before reporting a flow control error.  */
+    /** Maximum number of bytes to buffer before reporting a flow control error. */
     private val maxByteCount: Long,
 
     /**
@@ -316,10 +319,10 @@ class Http2Stream internal constructor(
      */
     internal var finished: Boolean
   ) : Source {
-    /** Buffer to receive data from the network into. Only accessed by the reader thread.  */
+    /** Buffer to receive data from the network into. Only accessed by the reader thread. */
     val receiveBuffer = Buffer()
 
-    /** Buffer with readable data. Guarded by Http2Stream.this.  */
+    /** Buffer with readable data. Guarded by Http2Stream.this. */
     val readBuffer = Buffer()
 
     /**
@@ -328,7 +331,7 @@ class Http2Stream internal constructor(
      */
     var trailers: Headers? = null
 
-    /** True if the caller has closed this stream.  */
+    /** True if the caller has closed this stream. */
     internal var closed: Boolean = false
 
     @Throws(IOException::class)
@@ -352,7 +355,7 @@ class Http2Stream internal constructor(
 
             if (closed) {
               throw IOException("stream closed")
-            } else if (readBuffer.size > 0) {
+            } else if (readBuffer.size > 0L) {
               // Prepare to read bytes. Start by moving them to the caller's buffer.
               readBytesDelivered = readBuffer.read(sink, minOf(byteCount, readBuffer.size))
               unacknowledgedBytesRead += readBytesDelivered
@@ -439,7 +442,7 @@ class Http2Stream internal constructor(
           val wasEmpty = readBuffer.size == 0L
           readBuffer.writeAll(receiveBuffer)
           if (wasEmpty) {
-            (this@Http2Stream as Object).notifyAll()
+            this@Http2Stream.notifyAll()
           }
         }
       }
@@ -454,7 +457,7 @@ class Http2Stream internal constructor(
         closed = true
         bytesDiscarded = readBuffer.size
         readBuffer.clear()
-        (this@Http2Stream as Object).notifyAll() // TODO(jwilson): Unnecessary?
+        this@Http2Stream.notifyAll() // TODO(jwilson): Unnecessary?
       }
       if (bytesDiscarded > 0L) {
         updateConnectionFlowControl(bytesDiscarded)
@@ -482,7 +485,7 @@ class Http2Stream internal constructor(
     }
   }
 
-  /** A sink that writes outgoing data frames of a stream. This class is not thread safe.  */
+  /** A sink that writes outgoing data frames of a stream. This class is not thread safe. */
   internal inner class FramingSink(
     /** True if either side has cleanly shut down this stream. We shall send no more bytes. */
     var finished: Boolean = false
@@ -494,7 +497,7 @@ class Http2Stream internal constructor(
      */
     private val sendBuffer = Buffer()
 
-    /** Trailers to send at the end of the stream.  */
+    /** Trailers to send at the end of the stream. */
     var trailers: Headers? = null
 
     var closed: Boolean = false
@@ -570,7 +573,7 @@ class Http2Stream internal constructor(
             while (sendBuffer.size > 0L) {
               emitFrame(false)
             }
-            connection.writeHeaders(id, true, Util.toHeaderBlock(trailers!!))
+            connection.writeHeaders(id, true, trailers!!.toHeaderList())
           }
 
           hasData -> {
@@ -600,7 +603,7 @@ class Http2Stream internal constructor(
   fun addBytesToWriteWindow(delta: Long) {
     bytesLeftInWriteWindow += delta
     if (delta > 0L) {
-      (this@Http2Stream as Object).notifyAll()
+      this@Http2Stream.notifyAll()
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.kt
index ce5f8f096b..64221e7667 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.kt
@@ -15,7 +15,7 @@
  */
 package okhttp3.internal.http2
 
-import okhttp3.internal.Util.format
+import okhttp3.internal.format
 import okhttp3.internal.http2.Http2.CONNECTION_PREFACE
 import okhttp3.internal.http2.Http2.FLAG_ACK
 import okhttp3.internal.http2.Http2.FLAG_END_HEADERS
@@ -40,7 +40,8 @@ import java.io.IOException
 import java.util.logging.Level.FINE
 import java.util.logging.Logger
 
-/** Writes HTTP/2 transport frames.  */
+/** Writes HTTP/2 transport frames. */
+@Suppress("NAME_SHADOWING")
 class Http2Writer(
   private val sink: BufferedSink,
   private val client: Boolean
@@ -61,7 +62,7 @@ class Http2Writer(
     sink.flush()
   }
 
-  /** Applies `peerSettings` and then sends a settings ACK.  */
+  /** Applies `peerSettings` and then sends a settings ACK. */
   @Synchronized @Throws(IOException::class)
   fun applyAndAckSettings(peerSettings: Settings) {
     if (closed) throw IOException("closed")
@@ -100,7 +101,7 @@ class Http2Writer(
     hpackWriter.writeHeaders(requestHeaders)
 
     val byteCount = hpackBuffer.size
-    val length = Math.min((maxFrameSize - 4).toLong(), byteCount).toInt()
+    val length = minOf(maxFrameSize - 4L, byteCount).toInt()
     frameHeader(
         streamId = streamId,
         length = length + 4,
@@ -134,7 +135,7 @@ class Http2Writer(
     sink.flush()
   }
 
-  /** The maximum size of bytes that may be sent in a single call to [data].  */
+  /** The maximum size of bytes that may be sent in a single call to [data]. */
   fun maxDataLength(): Int = maxFrameSize
 
   /**
@@ -165,7 +166,7 @@ class Http2Writer(
     }
   }
 
-  /** Write okhttp's settings to the peer.  */
+  /** Write okhttp's settings to the peer. */
   @Synchronized @Throws(IOException::class)
   fun settings(settings: Settings) {
     if (closed) throw IOException("closed")
@@ -272,8 +273,8 @@ class Http2Writer(
   @Throws(IOException::class)
   private fun writeContinuationFrames(streamId: Int, byteCount: Long) {
     var byteCount = byteCount
-    while (byteCount > 0) {
-      val length = Math.min(maxFrameSize.toLong(), byteCount)
+    while (byteCount > 0L) {
+      val length = minOf(maxFrameSize.toLong(), byteCount)
       byteCount -= length
       frameHeader(
           streamId = streamId,
@@ -295,7 +296,7 @@ class Http2Writer(
     hpackWriter.writeHeaders(headerBlock)
 
     val byteCount = hpackBuffer.size
-    val length = Math.min(maxFrameSize.toLong(), byteCount)
+    val length = minOf(maxFrameSize.toLong(), byteCount)
     var flags = if (byteCount == length) FLAG_END_HEADERS else 0
     if (outFinished) flags = flags or FLAG_END_STREAM
     frameHeader(
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.kt b/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.kt
index ff7cff2757..c4b5f64380 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.kt
@@ -68,7 +68,7 @@ interface PushObserver {
   @Throws(IOException::class)
   fun onData(streamId: Int, source: BufferedSource, byteCount: Int, last: Boolean): Boolean
 
-  /** Indicates the reason why this stream was canceled.  */
+  /** Indicates the reason why this stream was canceled. */
   fun onReset(streamId: Int, errorCode: ErrorCode)
 
   companion object {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Settings.kt b/okhttp/src/main/java/okhttp3/internal/http2/Settings.kt
index b60ab386b3..91315d3570 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Settings.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Settings.kt
@@ -21,13 +21,13 @@ package okhttp3.internal.http2
  */
 class Settings {
 
-  /** Bitfield of which flags that values.  */
+  /** Bitfield of which flags that values. */
   private var set: Int = 0
 
-  /** Flag values.  */
+  /** Flag values. */
   private val values = IntArray(COUNT)
 
-  /** Returns -1 if unset.  */
+  /** Returns -1 if unset. */
   val headerTableSize: Int
     get() {
       val bit = 1 shl HEADER_TABLE_SIZE
@@ -56,16 +56,16 @@ class Settings {
     return this
   }
 
-  /** Returns true if a value has been assigned for the setting `id`.  */
+  /** Returns true if a value has been assigned for the setting `id`. */
   fun isSet(id: Int): Boolean {
     val bit = 1 shl id
     return set and bit != 0
   }
 
-  /** Returns the value for the setting `id`, or 0 if unset.  */
+  /** Returns the value for the setting `id`, or 0 if unset. */
   operator fun get(id: Int): Int = values[id]
 
-  /** Returns the number of settings that have values assigned.  */
+  /** Returns the number of settings that have values assigned. */
   fun size(): Int = Integer.bitCount(set)
 
   // TODO: honor this setting.
@@ -107,20 +107,20 @@ class Settings {
      */
     const val DEFAULT_INITIAL_WINDOW_SIZE = 65535
 
-    /** HTTP/2: Size in bytes of the table used to decode the sender's header blocks.  */
+    /** HTTP/2: Size in bytes of the table used to decode the sender's header blocks. */
     const val HEADER_TABLE_SIZE = 1
-    /** HTTP/2: The peer must not send a PUSH_PROMISE frame when this is 0.  */
+    /** HTTP/2: The peer must not send a PUSH_PROMISE frame when this is 0. */
     const val ENABLE_PUSH = 2
-    /** Sender's maximum number of concurrent streams.  */
+    /** Sender's maximum number of concurrent streams. */
     const val MAX_CONCURRENT_STREAMS = 4
-    /** HTTP/2: Size in bytes of the largest frame payload the sender will accept.  */
+    /** HTTP/2: Size in bytes of the largest frame payload the sender will accept. */
     const val MAX_FRAME_SIZE = 5
-    /** HTTP/2: Advisory only. Size in bytes of the largest header list the sender will accept.  */
+    /** HTTP/2: Advisory only. Size in bytes of the largest header list the sender will accept. */
     const val MAX_HEADER_LIST_SIZE = 6
-    /** Window size in bytes.  */
+    /** Window size in bytes. */
     const val INITIAL_WINDOW_SIZE = 7
 
-    /** Total number of settings.  */
+    /** Total number of settings. */
     const val COUNT = 10
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.kt b/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.kt
index 814c2add07..54ae7d8c0f 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.kt
+++ b/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.kt
@@ -17,5 +17,5 @@ package okhttp3.internal.http2
 
 import java.io.IOException
 
-/** Thrown when an HTTP/2 stream is canceled without damage to the socket that carries it.  */
+/** Thrown when an HTTP/2 stream is canceled without damage to the socket that carries it. */
 class StreamResetException(@JvmField val errorCode: ErrorCode) : IOException("stream was reset: $errorCode")
diff --git a/okhttp/src/main/java/okhttp3/internal/InternalKt.kt b/okhttp/src/main/java/okhttp3/internal/internal.kt
similarity index 63%
rename from okhttp/src/main/java/okhttp3/internal/InternalKt.kt
rename to okhttp/src/main/java/okhttp3/internal/internal.kt
index 11daa2f171..4b6acc336c 100644
--- a/okhttp/src/main/java/okhttp3/internal/InternalKt.kt
+++ b/okhttp/src/main/java/okhttp3/internal/internal.kt
@@ -13,7 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-@file:Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN")
+
+/** Exposes Kotlin-internal APIs to Java test code and code in other modules. */
+@file:JvmName("Internal")
 
 package okhttp3.internal
 
@@ -41,32 +43,3 @@ fun cacheGet(cache: Cache, request: Request) = cache.get(request)
 
 fun applyConnectionSpec(connectionSpec: ConnectionSpec, sslSocket: SSLSocket, isFallback: Boolean) =
     connectionSpec.apply(sslSocket, isFallback)
-
-/**
- * Lock and wait a duration in nanoseconds. Unlike [java.lang.Object.wait] this interprets 0 as
- * "don't wait" instead of "wait forever".
- */
-@Throws(InterruptedException::class)
-fun Any.waitNanos(nanos: Long) {
-  val ms = nanos / 1_000_000L
-  val ns = nanos - (ms * 1_000_000L)
-  synchronized(this) {
-    this.waitMillis(ms, ns.toInt())
-  }
-}
-
-fun Any.wait() = (this as Object).wait()
-
-/**
- * Lock and wait a duration in milliseconds and nanos.
- * Unlike [java.lang.Object.wait] this interprets 0 as "don't wait" instead of "wait forever".
- */
-fun Any.waitMillis(timeout: Long, nanos: Int = 0) {
-  if (timeout > 0 || nanos > 0) {
-    (this as Object).wait(timeout, nanos)
-  }
-}
-
-fun Any.notify() = (this as Object).notify()
-
-fun Any.notifyAll() = (this as Object).notifyAll()
diff --git a/okhttp/src/main/java/okhttp3/internal/io/FileSystem.kt b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.kt
index 830e93c111..f97ab68eac 100644
--- a/okhttp/src/main/java/okhttp3/internal/io/FileSystem.kt
+++ b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.kt
@@ -42,7 +42,7 @@ import java.io.IOException
 interface FileSystem {
 
   companion object {
-    /** The host machine's local file system.  */
+    /** The host machine's local file system. */
     @JvmField
     val SYSTEM: FileSystem = object : FileSystem {
       @Throws(FileNotFoundException::class)
@@ -50,13 +50,13 @@ interface FileSystem {
 
       @Throws(FileNotFoundException::class)
       override fun sink(file: File): Sink {
-          try {
-              return file.sink()
-          } catch (_: FileNotFoundException) {
-              // Maybe the parent directory doesn't exist? Try creating it first.
-              file.parentFile.mkdirs()
-              return file.sink()
-          }
+        return try {
+          file.sink()
+        } catch (_: FileNotFoundException) {
+          // Maybe the parent directory doesn't exist? Try creating it first.
+          file.parentFile.mkdirs()
+          file.sink()
+        }
       }
 
       @Throws(FileNotFoundException::class)
@@ -105,7 +105,7 @@ interface FileSystem {
     }
   }
 
-  /** Reads from [file].  */
+  /** Reads from [file]. */
   @Throws(FileNotFoundException::class)
   fun source(file: File): Source
 
@@ -123,17 +123,17 @@ interface FileSystem {
   @Throws(FileNotFoundException::class)
   fun appendingSink(file: File): Sink
 
-  /** Deletes [file] if it exists. Throws if the file exists and cannot be deleted.  */
+  /** Deletes [file] if it exists. Throws if the file exists and cannot be deleted. */
   @Throws(IOException::class)
   fun delete(file: File)
 
-  /** Returns true if [file] exists on the file system.  */
+  /** Returns true if [file] exists on the file system. */
   fun exists(file: File): Boolean
 
-  /** Returns the number of bytes stored in [file], or 0 if it does not exist.  */
+  /** Returns the number of bytes stored in [file], or 0 if it does not exist. */
   fun size(file: File): Long
 
-  /** Renames [from] to [to]. Throws if the file cannot be renamed.  */
+  /** Renames [from] to [to]. Throws if the file cannot be renamed. */
   @Throws(IOException::class)
   fun rename(from: File, to: File)
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
index 7898227973..331850b07c 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
@@ -16,9 +16,12 @@
 package okhttp3.internal.platform
 
 import android.os.Build
-import android.util.Log
 import okhttp3.Protocol
-import okhttp3.internal.Util
+import okhttp3.internal.platform.android.CloseGuard
+import okhttp3.internal.platform.android.ConscryptSocketAdapter
+import okhttp3.internal.platform.android.DeferredSocketAdapter
+import okhttp3.internal.platform.android.StandardAndroidSocketAdapter
+import okhttp3.internal.platform.android.androidLog
 import okhttp3.internal.tls.BasicTrustRootIndex
 import okhttp3.internal.tls.CertificateChainCleaner
 import okhttp3.internal.tls.TrustRootIndex
@@ -27,51 +30,23 @@ import java.lang.reflect.InvocationTargetException
 import java.lang.reflect.Method
 import java.net.InetSocketAddress
 import java.net.Socket
-import java.nio.charset.StandardCharsets.UTF_8
-import java.security.NoSuchAlgorithmException
 import java.security.cert.Certificate
 import java.security.cert.TrustAnchor
 import java.security.cert.X509Certificate
-import javax.net.ssl.SSLContext
 import javax.net.ssl.SSLPeerUnverifiedException
 import javax.net.ssl.SSLSocket
 import javax.net.ssl.SSLSocketFactory
 import javax.net.ssl.X509TrustManager
 
-/** Android 5+.  */
-class AndroidPlatform(
-  private val sslParametersClass: Class<*>,
-  private val sslSocketClass: Class<*>,
-  private val setUseSessionTickets: Method,
-  private val setHostname: Method,
-  private val getAlpnSelectedProtocol: Method,
-  private val setAlpnProtocols: Method
-) : Platform() {
-  private val closeGuard = CloseGuard.get()
-
-  // Not a real Android runtime; probably RoboVM or MoE
-  // Try to load TLS 1.2 explicitly.
-  // fallback to TLS
-  override fun newSSLContext(): SSLContext {
-    val tryTls12: Boolean = try {
-      Build.VERSION.SDK_INT in 16..21
-    } catch (e: NoClassDefFoundError) {
-      true
-    }
-
-    if (tryTls12) {
-      try {
-        return SSLContext.getInstance("TLSv1.2")
-      } catch (e: NoSuchAlgorithmException) {
-      }
-    }
+/** Android 5+. */
+class AndroidPlatform : Platform() {
+  private val socketAdapters = listOfNotNull(
+      StandardAndroidSocketAdapter.buildIfSupported(),
+      ConscryptSocketAdapter.buildIfSupported(),
+      DeferredSocketAdapter("com.google.android.gms.org.conscrypt")
+  ).filter { it.isSupported() }
 
-    try {
-      return SSLContext.getInstance("TLS")
-    } catch (e: NoSuchAlgorithmException) {
-      throw IllegalStateException("No TLS provider", e)
-    }
-  }
+  private val closeGuard = CloseGuard.get()
 
   @Throws(IOException::class)
   override fun connectSocket(
@@ -81,9 +56,6 @@ class AndroidPlatform(
   ) {
     try {
       socket.connect(address, connectTimeout)
-    } catch (e: AssertionError) {
-      if (Util.isAndroidGetsocknameError(e)) throw IOException(e)
-      throw e
     } catch (e: ClassCastException) {
       // On android 8.0, socket.connect throws a ClassCastException due to a bug
       // see https://issuetracker.google.com/issues/63649622
@@ -95,87 +67,26 @@ class AndroidPlatform(
     }
   }
 
-  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {
-    var context: Any? =
-        readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters")
-    if (context == null) {
-      // If that didn't work, try the Google Play Services SSL provider before giving up. This
-      // must be loaded by the SSLSocketFactory's class loader.
-      try {
-        val gmsSslParametersClass = Class.forName(
-            "com.google.android.gms.org.conscrypt.SSLParametersImpl", false,
-            sslSocketFactory.javaClass.classLoader)
-        context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass,
-            "sslParameters")
-      } catch (e: ClassNotFoundException) {
-        return super.trustManager(sslSocketFactory)
-      }
-    }
-
-    val x509TrustManager = readFieldOrNull(
-        context!!, X509TrustManager::class.java, "x509TrustManager")
-    return x509TrustManager ?: readFieldOrNull(context, X509TrustManager::class.java,
-        "trustManager")
-  }
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? =
+      socketAdapters.find { it.matchesSocketFactory(sslSocketFactory) }
+          ?.trustManager(sslSocketFactory)
 
   override fun configureTlsExtensions(
     sslSocket: SSLSocket,
     hostname: String?,
     protocols: List<Protocol>
   ) {
-    if (!sslSocketClass.isInstance(sslSocket)) {
-      return // No TLS extensions if the socket class is custom.
-    }
-    try {
-      // Enable SNI and session tickets.
-      if (hostname != null) {
-        setUseSessionTickets.invoke(sslSocket, true)
-        // This is SSLParameters.setServerNames() in API 24+.
-        setHostname.invoke(sslSocket, hostname)
-      }
-
-      // Enable ALPN.
-      setAlpnProtocols.invoke(sslSocket, concatLengthPrefixed(protocols))
-    } catch (e: IllegalAccessException) {
-      throw AssertionError(e)
-    } catch (e: InvocationTargetException) {
-      throw AssertionError(e)
-    }
+    // No TLS extensions if the socket class is custom.
+    socketAdapters.find { it.matchesSocket(sslSocket) }
+        ?.configureTlsExtensions(sslSocket, hostname, protocols)
   }
 
-  override fun getSelectedProtocol(socket: SSLSocket): String? {
-    return if (sslSocketClass.isInstance(socket))
-      try {
-        val alpnResult = getAlpnSelectedProtocol.invoke(socket) as ByteArray?
-        if (alpnResult != null) String(alpnResult, UTF_8) else null
-      } catch (e: IllegalAccessException) {
-        throw AssertionError(e)
-      } catch (e: InvocationTargetException) {
-        throw AssertionError(e)
-      }
-    else {
-      null // No TLS extensions if the socket class is custom.
-    }
-  }
+  override fun getSelectedProtocol(sslSocket: SSLSocket) =
+      // No TLS extensions if the socket class is custom.
+      socketAdapters.find { it.matchesSocket(sslSocket) }?.getSelectedProtocol(sslSocket)
 
   override fun log(level: Int, message: String, t: Throwable?) {
-    var logMessage = message
-    val logLevel = if (level == WARN) Log.WARN else Log.DEBUG
-    if (t != null) logMessage = logMessage + '\n'.toString() + Log.getStackTraceString(t)
-
-    // Split by line, then ensure each line can fit into Log's maximum length.
-    var i = 0
-    val length = logMessage.length
-    while (i < length) {
-      var newline = logMessage.indexOf('\n', i)
-      newline = if (newline != -1) newline else length
-      do {
-        val end = Math.min(newline, i + MAX_LOG_LENGTH)
-        Log.println(logLevel, "OkHttp", logMessage.substring(i, end))
-        i = end
-      } while (i < newline)
-      i++
-    }
+    androidLog(level, message, t)
   }
 
   override fun getStackTraceForCloseable(closer: String): Any? = closeGuard.createAndOpen(closer)
@@ -194,9 +105,9 @@ class AndroidPlatform(
       val getInstanceMethod = networkPolicyClass.getMethod("getInstance")
       val networkSecurityPolicy = getInstanceMethod.invoke(null)
       api24IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy)
-    } catch (e: ClassNotFoundException) {
+    } catch (_: ClassNotFoundException) {
       super.isCleartextTrafficPermitted(hostname)
-    } catch (e: NoSuchMethodException) {
+    } catch (_: NoSuchMethodException) {
       super.isCleartextTrafficPermitted(hostname)
     } catch (e: IllegalAccessException) {
       throw AssertionError("unable to determine cleartext support", e)
@@ -216,7 +127,7 @@ class AndroidPlatform(
     val isCleartextTrafficPermittedMethod = networkPolicyClass
         .getMethod("isCleartextTrafficPermitted", String::class.java)
     isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy, hostname) as Boolean
-  } catch (e: NoSuchMethodException) {
+  } catch (_: NoSuchMethodException) {
     api23IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy)
   }
 
@@ -229,7 +140,7 @@ class AndroidPlatform(
     val isCleartextTrafficPermittedMethod = networkPolicyClass
         .getMethod("isCleartextTrafficPermitted")
     isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy) as Boolean
-  } catch (e: NoSuchMethodException) {
+  } catch (_: NoSuchMethodException) {
     super.isCleartextTrafficPermitted(hostname)
   }
 
@@ -242,7 +153,7 @@ class AndroidPlatform(
             "checkServerTrusted", Array<X509Certificate>::class.java, String::class.java,
             String::class.java)
         AndroidCertificateChainCleaner(extensions, checkServerTrusted)
-      } catch (e: Exception) {
+      } catch (_: Exception) {
         super.buildCertificateChainCleaner(trustManager)
       }
 
@@ -288,67 +199,9 @@ class AndroidPlatform(
     override fun hashCode(): Int = 0
   }
 
-  /**
-   * Provides access to the internal dalvik.system.CloseGuard class. Android uses this in
-   * combination with android.os.StrictMode to report on leaked java.io.Closeable's. Available since
-   * Android API 11.
-   */
-  internal class CloseGuard(
-    private val getMethod: Method?,
-    private val openMethod: Method?,
-    private val warnIfOpenMethod: Method?
-  ) {
-
-    fun createAndOpen(closer: String): Any? {
-      if (getMethod != null) {
-        try {
-          val closeGuardInstance = getMethod.invoke(null)
-          openMethod!!.invoke(closeGuardInstance, closer)
-          return closeGuardInstance
-        } catch (ignored: Exception) {
-        }
-      }
-      return null
-    }
-
-    fun warnIfOpen(closeGuardInstance: Any?): Boolean {
-      var reported = false
-      if (closeGuardInstance != null) {
-        try {
-          warnIfOpenMethod!!.invoke(closeGuardInstance)
-          reported = true
-        } catch (ignored: Exception) {
-        }
-      }
-      return reported
-    }
-
-    companion object {
-      fun get(): CloseGuard {
-        var getMethod: Method?
-        var openMethod: Method?
-        var warnIfOpenMethod: Method?
-
-        try {
-          val closeGuardClass = Class.forName("dalvik.system.CloseGuard")
-          getMethod = closeGuardClass.getMethod("get")
-          openMethod = closeGuardClass.getMethod("open", String::class.java)
-          warnIfOpenMethod = closeGuardClass.getMethod("warnIfOpen")
-        } catch (ignored: Exception) {
-          getMethod = null
-          openMethod = null
-          warnIfOpenMethod = null
-        }
-
-        return CloseGuard(getMethod, openMethod, warnIfOpenMethod)
-      }
-    }
-  }
-
   /**
    * A trust manager for Android applications that customize the trust manager.
    *
-   *
    * This class exploits knowledge of Android implementation details. This class is potentially
    * much faster to initialize than [BasicTrustRootIndex] because it doesn't need to load and
    * index trusted CA certificates.
@@ -357,7 +210,6 @@ class AndroidPlatform(
     private val trustManager: X509TrustManager,
     private val findByIssuerAndSignatureMethod: Method
   ) : TrustRootIndex {
-
     override fun findByIssuerAndSignature(cert: X509Certificate): X509Certificate? {
       return try {
         val trustAnchor = findByIssuerAndSignatureMethod.invoke(
@@ -365,40 +217,25 @@ class AndroidPlatform(
         trustAnchor.trustedCert
       } catch (e: IllegalAccessException) {
         throw AssertionError("unable to get issues and signature", e)
-      } catch (e: InvocationTargetException) {
+      } catch (_: InvocationTargetException) {
         null
       }
     }
   }
 
   companion object {
-    private const val MAX_LOG_LENGTH = 4000
+    val isSupported: Boolean = try {
+      // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
+      Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl")
 
-    fun buildIfSupported(): Platform? {
-      // Attempt to find Android 5+ APIs.
-      val sslParametersClass: Class<*>
-      val sslSocketClass: Class<*>
-      try {
-        sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl")
-        sslSocketClass = Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl")
-      } catch (ignored: ClassNotFoundException) {
-        return null // Not an Android runtime.
-      }
+      // Fail Fast
+      check(Build.VERSION.SDK_INT >= 21) { "Expected Android API level 21+ but was ${Build.VERSION.SDK_INT}" }
 
-      if (Build.VERSION.SDK_INT >= 21) {
-        try {
-          val setUseSessionTickets = sslSocketClass.getDeclaredMethod(
-              "setUseSessionTickets", Boolean::class.javaPrimitiveType)
-          val setHostname = sslSocketClass.getMethod("setHostname", String::class.java)
-          val getAlpnSelectedProtocol = sslSocketClass.getMethod("getAlpnSelectedProtocol")
-          val setAlpnProtocols = sslSocketClass.getMethod("setAlpnProtocols", ByteArray::class.java)
-          return AndroidPlatform(sslParametersClass, sslSocketClass, setUseSessionTickets,
-              setHostname, getAlpnSelectedProtocol, setAlpnProtocols)
-        } catch (ignored: NoSuchMethodException) {
-        }
-      }
-      throw IllegalStateException(
-          "Expected Android API level 21+ but was " + Build.VERSION.SDK_INT)
+      true
+    } catch (_: ClassNotFoundException) {
+      false
     }
+
+    fun buildIfSupported(): Platform? = if (isSupported) AndroidPlatform() else null
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt
index 1fc29ba06c..a5f9911c21 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt
@@ -16,6 +16,7 @@
 package okhttp3.internal.platform
 
 import okhttp3.Protocol
+import okhttp3.internal.readFieldOrNull
 import org.conscrypt.Conscrypt
 import java.security.Provider
 import javax.net.ssl.SSLContext
@@ -29,13 +30,9 @@ import javax.net.ssl.X509TrustManager
  * Requires org.conscrypt:conscrypt-openjdk-uber >= 2.1.0 on the classpath.
  */
 class ConscryptPlatform private constructor() : Platform() {
-  private val provider: Provider
-    get() {
-      // n.b. We should consider defaulting to OpenJDK 11 trust manager
-      // https://groups.google.com/forum/#!topic/conscrypt/3vYzbesjOb4
-
-      return Conscrypt.newProviderBuilder().provideTrustManager(true).build()
-    }
+  // n.b. We should consider defaulting to OpenJDK 11 trust manager
+  // https://groups.google.com/forum/#!topic/conscrypt/3vYzbesjOb4
+  private val provider: Provider = Conscrypt.newProviderBuilder().provideTrustManager(true).build()
 
   // See release notes https://groups.google.com/forum/#!forum/conscrypt
   // for version differences
@@ -85,11 +82,11 @@ class ConscryptPlatform private constructor() : Platform() {
     }
   }
 
-  override fun getSelectedProtocol(socket: SSLSocket): String? =
-      if (Conscrypt.isConscrypt(socket)) {
-        Conscrypt.getApplicationProtocol(socket)
+  override fun getSelectedProtocol(sslSocket: SSLSocket): String? =
+      if (Conscrypt.isConscrypt(sslSocket)) {
+        Conscrypt.getApplicationProtocol(sslSocket)
       } else {
-        super.getSelectedProtocol(socket)
+        super.getSelectedProtocol(sslSocket)
       }
 
   override fun configureSslSocketFactory(socketFactory: SSLSocketFactory) {
@@ -106,20 +103,20 @@ class ConscryptPlatform private constructor() : Platform() {
   }
 
   companion object {
-    @JvmStatic
-    fun buildIfSupported(): ConscryptPlatform? = try {
+    val isSupported: Boolean = try {
       // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
       Class.forName("org.conscrypt.Conscrypt\$Version")
 
       when {
-        Conscrypt.isAvailable() && atLeastVersion(2, 1, 0) -> ConscryptPlatform()
-        else -> null
+        Conscrypt.isAvailable() && atLeastVersion(2, 1, 0) -> true
+        else -> false
       }
     } catch (e: ClassNotFoundException) {
-      null
+      false
     }
 
-    @JvmStatic @JvmOverloads
+    fun buildIfSupported(): ConscryptPlatform? = if (isSupported) ConscryptPlatform() else null
+
     fun atLeastVersion(major: Int, minor: Int = 0, patch: Int = 0): Boolean {
       val conscryptVersion = Conscrypt.version()
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt
index 249f8b80df..92e8d1c96e 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt
@@ -22,7 +22,7 @@ import java.lang.reflect.Method
 import java.lang.reflect.Proxy
 import javax.net.ssl.SSLSocket
 
-/** OpenJDK 8 with `org.mortbay.jetty.alpn:alpn-boot` in the boot class path.  */
+/** OpenJDK 8 with `org.mortbay.jetty.alpn:alpn-boot` in the boot class path. */
 class Jdk8WithJettyBootPlatform(
   private val putMethod: Method,
   private val getMethod: Method,
@@ -80,12 +80,12 @@ class Jdk8WithJettyBootPlatform(
    * dependency on those interfaces.
    */
   private class AlpnProvider internal constructor(
-    /** This peer's supported protocols.  */
+    /** This peer's supported protocols. */
     private val protocols: List<String>
   ) : InvocationHandler {
-    /** Set when remote peer notifies ALPN is unsupported.  */
+    /** Set when remote peer notifies ALPN is unsupported. */
     internal var unsupported: Boolean = false
-    /** The protocol the server selected.  */
+    /** The protocol the server selected. */
     internal var selected: String? = null
 
     @Throws(Throwable::class)
@@ -106,7 +106,7 @@ class Jdk8WithJettyBootPlatform(
         // Pick the first known protocol the peer advertises.
         for (i in 0..peerProtocols.size) {
           val protocol = peerProtocols[i] as String
-          if (protocols.contains(protocol)) {
+          if (protocol in protocols) {
             selected = protocol
             return selected
           }
@@ -123,14 +123,13 @@ class Jdk8WithJettyBootPlatform(
   }
 
   companion object {
-    @JvmStatic
     fun buildIfSupported(): Platform? {
       val jvmVersion = System.getProperty("java.specification.version", "unknown")
       try {
         // 1.8, 9, 10, 11, 12 etc
         val version = jvmVersion.toInt()
         if (version >= 9) return null
-      } catch (nfe: NumberFormatException) {
+      } catch (_: NumberFormatException) {
         // expected on >= JDK 9
       }
 
@@ -146,8 +145,8 @@ class Jdk8WithJettyBootPlatform(
         val removeMethod = alpnClass.getMethod("remove", SSLSocket::class.java)
         return Jdk8WithJettyBootPlatform(
             putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass)
-      } catch (ignored: ClassNotFoundException) {
-      } catch (ignored: NoSuchMethodException) {
+      } catch (_: ClassNotFoundException) {
+      } catch (_: NoSuchMethodException) {
       }
 
       return null
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.kt
index 7305b90fb4..6d6e1d1fcc 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.kt
@@ -23,7 +23,7 @@ import javax.net.ssl.SSLSocketFactory
 import javax.net.ssl.X509TrustManager
 import okhttp3.Protocol
 
-/** OpenJDK 9+.  */
+/** OpenJDK 9+. */
 class Jdk9Platform(
   @JvmField val setProtocolMethod: Method,
   @JvmField val getProtocolMethod: Method
@@ -49,11 +49,9 @@ class Jdk9Platform(
   }
 
   override fun getSelectedProtocol(socket: SSLSocket): String? = try {
-    val protocol = getProtocolMethod.invoke(socket) as String?
-
     // SSLSocket.getApplicationProtocol returns "" if application protocols values will not
     // be used. Observed if you didn't specify SSLParameters.setApplicationProtocols
-    when (protocol) {
+    when (val protocol = getProtocolMethod.invoke(socket) as String?) {
       null, "" -> null
       else -> protocol
     }
@@ -73,7 +71,6 @@ class Jdk9Platform(
   }
 
   companion object {
-    @JvmStatic
     fun buildIfSupported(): Jdk9Platform? =
         try {
           // Find JDK 9 methods
@@ -82,7 +79,7 @@ class Jdk9Platform(
           val getProtocolMethod = SSLSocket::class.java.getMethod("getApplicationProtocol")
 
           Jdk9Platform(setProtocolMethod, getProtocolMethod)
-        } catch (ignored: NoSuchMethodException) {
+        } catch (_: NoSuchMethodException) {
           // pre JDK 9
           null
         }
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/OpenJSSEPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/OpenJSSEPlatform.kt
new file mode 100644
index 0000000000..bf80f22120
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/OpenJSSEPlatform.kt
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform
+
+import okhttp3.Protocol
+import java.security.KeyStore
+import java.security.Provider
+import javax.net.ssl.SSLContext
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.TrustManagerFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Platform using OpenJSSE (https://github.com/openjsse/openjsse) if installed as the first
+ * Security Provider.
+ *
+ * Requires org.openjsse:openjsse >= 1.1.0 on the classpath.
+ */
+class OpenJSSEPlatform private constructor() : Platform() {
+  private val provider: Provider = org.openjsse.net.ssl.OpenJSSE()
+
+  // Selects TLSv1.3 so we are specific about our intended version ranges (not just 1.3)
+  // and because it's a common pattern for VMs to have differences between supported and
+  // defaulted versions for TLS based on what is requested.
+  override fun newSSLContext(): SSLContext =
+      SSLContext.getInstance("TLSv1.3", provider)
+
+  override fun platformTrustManager(): X509TrustManager {
+    val factory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm(), provider)
+    factory.init(null as KeyStore?)
+    val trustManagers = factory.trustManagers!!
+    check(trustManagers.size == 1 && trustManagers[0] is X509TrustManager) {
+      "Unexpected default trust managers: ${trustManagers.contentToString()}"
+    }
+    return trustManagers[0] as X509TrustManager
+  }
+
+  public override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? =
+      throw UnsupportedOperationException(
+          "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported with OpenJSSE")
+
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  ) {
+    if (sslSocket is org.openjsse.javax.net.ssl.SSLSocket) {
+      val sslParameters = sslSocket.sslParameters
+
+      if (sslParameters is org.openjsse.javax.net.ssl.SSLParameters) {
+        // Enable ALPN.
+        val names = alpnProtocolNames(protocols)
+        sslParameters.applicationProtocols = names.toTypedArray()
+
+        sslSocket.sslParameters = sslParameters
+      }
+    } else {
+      super.configureTlsExtensions(sslSocket, hostname, protocols)
+    }
+  }
+
+  override fun getSelectedProtocol(sslSocket: SSLSocket): String? =
+      if (sslSocket is org.openjsse.javax.net.ssl.SSLSocket) {
+        when (val protocol = sslSocket.applicationProtocol) {
+          // Handles both un-configured and none selected.
+          null, "" -> null
+          else -> protocol
+        }
+      } else {
+        super.getSelectedProtocol(sslSocket)
+      }
+
+  companion object {
+    val isSupported: Boolean = try {
+      // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
+      Class.forName("org.openjsse.net.ssl.OpenJSSE")
+
+      true
+    } catch (_: ClassNotFoundException) {
+      false
+    }
+
+    fun buildIfSupported(): OpenJSSEPlatform? = if (isSupported) OpenJSSEPlatform() else null
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
index f99405ba56..99607dfa35 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
@@ -18,6 +18,7 @@ package okhttp3.internal.platform
 
 import okhttp3.OkHttpClient
 import okhttp3.Protocol
+import okhttp3.internal.readFieldOrNull
 import okhttp3.internal.tls.BasicCertificateChainCleaner
 import okhttp3.internal.tls.BasicTrustRootIndex
 import okhttp3.internal.tls.CertificateChainCleaner
@@ -73,7 +74,7 @@ import javax.net.ssl.X509TrustManager
  */
 open class Platform {
 
-  /** Prefix used on custom headers.  */
+  /** Prefix used on custom headers. */
   fun getPrefix() = "OkHttp"
 
   open fun newSSLContext(): SSLContext = SSLContext.getInstance("TLS")
@@ -118,8 +119,8 @@ open class Platform {
   open fun afterHandshake(sslSocket: SSLSocket) {
   }
 
-  /** Returns the negotiated protocol, or null if no protocol was negotiated.  */
-  open fun getSelectedProtocol(socket: SSLSocket): String? = null
+  /** Returns the negotiated protocol, or null if no protocol was negotiated. */
+  open fun getSelectedProtocol(sslSocket: SSLSocket): String? = null
 
   @Throws(IOException::class)
   open fun connectSocket(socket: Socket, address: InetSocketAddress, connectTimeout: Int) {
@@ -193,15 +194,19 @@ open class Platform {
     fun alpnProtocolNames(protocols: List<Protocol>) =
         protocols.filter { it != Protocol.HTTP_1_0 }.map { it.toString() }
 
-    @JvmStatic
-    val isConscryptPreferred: Boolean
+    private val isConscryptPreferred: Boolean
       get() {
         val preferredProvider = Security.getProviders()[0].name
         return "Conscrypt" == preferredProvider
       }
 
-    /** Attempt to match the host runtime to a capable Platform implementation.  */
-    @JvmStatic
+    private val isOpenJSSEPreferred: Boolean
+      get() {
+        val preferredProvider = Security.getProviders()[0].name
+        return "OpenJSSE" == preferredProvider
+      }
+
+    /** Attempt to match the host runtime to a capable Platform implementation. */
     private fun findPlatform(): Platform {
       val android = AndroidPlatform.buildIfSupported()
 
@@ -217,6 +222,14 @@ open class Platform {
         }
       }
 
+      if (isOpenJSSEPreferred) {
+        val openJSSE = OpenJSSEPlatform.buildIfSupported()
+
+        if (openJSSE != null) {
+          return openJSSE
+        }
+      }
+
       val jdk9 = Jdk9Platform.buildIfSupported()
 
       if (jdk9 != null) {
@@ -233,7 +246,6 @@ open class Platform {
      * Returns the concatenation of 8-bit, length prefixed protocol names.
      * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
      */
-    @JvmStatic
     fun concatLengthPrefixed(protocols: List<Protocol>): ByteArray {
       val result = Buffer()
       for (protocol in alpnProtocolNames(protocols)) {
@@ -242,30 +254,5 @@ open class Platform {
       }
       return result.readByteArray()
     }
-
-    @JvmStatic
-    fun <T> readFieldOrNull(instance: Any, fieldType: Class<T>, fieldName: String): T? {
-      var c: Class<*> = instance.javaClass
-      while (c != Any::class.java) {
-        try {
-          val field = c.getDeclaredField(fieldName)
-          field.isAccessible = true
-          val value = field.get(instance)
-          return if (!fieldType.isInstance(value)) null else fieldType.cast(value)
-        } catch (ignored: NoSuchFieldException) {
-        }
-
-        c = c.superclass
-      }
-
-      // Didn't find the field we wanted. As a last gasp attempt,
-      // try to find the value on a delegate.
-      if (fieldName != "delegate") {
-        val delegate = readFieldOrNull(instance, Any::class.java, "delegate")
-        if (delegate != null) return readFieldOrNull(delegate, fieldType, fieldName)
-      }
-
-      return null
-    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/AndroidSocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/AndroidSocketAdapter.kt
new file mode 100644
index 0000000000..4ac9e4c0cf
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/AndroidSocketAdapter.kt
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.Protocol
+import okhttp3.internal.platform.AndroidPlatform
+import okhttp3.internal.platform.Platform
+import java.lang.reflect.InvocationTargetException
+import java.lang.reflect.Method
+import java.nio.charset.StandardCharsets
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Modern reflection based SocketAdapter for Conscrypt class SSLSockets.
+ */
+open class AndroidSocketAdapter(private val sslSocketClass: Class<in SSLSocket>) :
+    SocketAdapter {
+  private val setUseSessionTickets: Method =
+      sslSocketClass.getDeclaredMethod("setUseSessionTickets", Boolean::class.javaPrimitiveType)
+  private val setHostname = sslSocketClass.getMethod("setHostname", String::class.java)
+  private val getAlpnSelectedProtocol = sslSocketClass.getMethod("getAlpnSelectedProtocol")
+  private val setAlpnProtocols =
+      sslSocketClass.getMethod("setAlpnProtocols", ByteArray::class.java)
+
+  override fun isSupported(): Boolean = AndroidPlatform.isSupported
+
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? = null
+
+  override fun matchesSocket(sslSocket: SSLSocket): Boolean = sslSocketClass.isInstance(sslSocket)
+
+  override fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean = false
+
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  ) {
+    // No TLS extensions if the socket class is custom.
+    if (matchesSocket(sslSocket)) {
+      try {
+        // Enable SNI and session tickets.
+        if (hostname != null) {
+          setUseSessionTickets.invoke(sslSocket, true)
+          // This is SSLParameters.setServerNames() in API 24+.
+          setHostname.invoke(sslSocket, hostname)
+        }
+
+        // Enable ALPN.
+        setAlpnProtocols.invoke(sslSocket,
+            Platform.concatLengthPrefixed(protocols))
+      } catch (e: IllegalAccessException) {
+        throw AssertionError(e)
+      } catch (e: InvocationTargetException) {
+        throw AssertionError(e)
+      }
+    }
+  }
+
+  override fun getSelectedProtocol(sslSocket: SSLSocket): String? {
+    // No TLS extensions if the socket class is custom.
+    if (!matchesSocket(sslSocket)) {
+      return null
+    }
+
+    return try {
+      val alpnResult = getAlpnSelectedProtocol.invoke(sslSocket) as ByteArray?
+      if (alpnResult != null) String(alpnResult, StandardCharsets.UTF_8) else null
+    } catch (e: IllegalAccessException) {
+      throw AssertionError(e)
+    } catch (e: InvocationTargetException) {
+      throw AssertionError(e)
+    }
+  }
+
+  companion object {
+    fun buildIfSupported(packageName: String): SocketAdapter? {
+      return try {
+        @Suppress("UNCHECKED_CAST")
+        val sslSocketClass = Class.forName("$packageName.OpenSSLSocketImpl") as Class<in SSLSocket>
+
+        AndroidSocketAdapter(sslSocketClass)
+      } catch (e: Exception) {
+        androidLog(Platform.WARN, "unable to load android socket classes", e)
+        null
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/CloseGuard.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/CloseGuard.kt
new file mode 100644
index 0000000000..b3930aafd7
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/CloseGuard.kt
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import java.lang.reflect.Method
+
+/**
+ * Provides access to the internal dalvik.system.CloseGuard class. Android uses this in
+ * combination with android.os.StrictMode to report on leaked java.io.Closeable's. Available since
+ * Android API 11.
+ */
+internal class CloseGuard(
+  private val getMethod: Method?,
+  private val openMethod: Method?,
+  private val warnIfOpenMethod: Method?
+) {
+
+  fun createAndOpen(closer: String): Any? {
+    if (getMethod != null) {
+      try {
+        val closeGuardInstance = getMethod.invoke(null)
+        openMethod!!.invoke(closeGuardInstance, closer)
+        return closeGuardInstance
+      } catch (_: Exception) {
+      }
+    }
+    return null
+  }
+
+  fun warnIfOpen(closeGuardInstance: Any?): Boolean {
+    var reported = false
+    if (closeGuardInstance != null) {
+      try {
+        warnIfOpenMethod!!.invoke(closeGuardInstance)
+        reported = true
+      } catch (_: Exception) {
+      }
+    }
+    return reported
+  }
+
+  companion object {
+    fun get(): CloseGuard {
+      var getMethod: Method?
+      var openMethod: Method?
+      var warnIfOpenMethod: Method?
+
+      try {
+        val closeGuardClass = Class.forName("dalvik.system.CloseGuard")
+        getMethod = closeGuardClass.getMethod("get")
+        openMethod = closeGuardClass.getMethod("open", String::class.java)
+        warnIfOpenMethod = closeGuardClass.getMethod("warnIfOpen")
+      } catch (_: Exception) {
+        getMethod = null
+        openMethod = null
+        warnIfOpenMethod = null
+      }
+
+      return CloseGuard(getMethod, openMethod, warnIfOpenMethod)
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/ConscryptSocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/ConscryptSocketAdapter.kt
new file mode 100644
index 0000000000..11f574b544
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/ConscryptSocketAdapter.kt
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.Protocol
+import okhttp3.internal.platform.ConscryptPlatform
+import okhttp3.internal.platform.Platform
+import org.conscrypt.Conscrypt
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Simple non-reflection SocketAdapter for Conscrypt.
+ */
+object ConscryptSocketAdapter : SocketAdapter {
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? = null
+
+  override fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean = false
+
+  override fun matchesSocket(sslSocket: SSLSocket): Boolean = Conscrypt.isConscrypt(sslSocket)
+
+  override fun isSupported(): Boolean = ConscryptPlatform.isSupported
+
+  override fun getSelectedProtocol(sslSocket: SSLSocket): String? =
+      when {
+        matchesSocket(sslSocket) -> Conscrypt.getApplicationProtocol(sslSocket)
+        else -> null // No TLS extensions if the socket class is custom.
+      }
+
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  ) {
+    // No TLS extensions if the socket class is custom.
+    if (matchesSocket(sslSocket)) {
+      // Enable SNI and session tickets.
+      if (hostname != null) {
+        Conscrypt.setUseSessionTickets(sslSocket, true)
+        Conscrypt.setHostname(sslSocket, hostname)
+      }
+
+      // Enable ALPN.
+      val names = Platform.alpnProtocolNames(protocols)
+      Conscrypt.setApplicationProtocols(sslSocket, names.toTypedArray())
+    }
+  }
+
+  fun buildIfSupported(): SocketAdapter? =
+      if (ConscryptPlatform.isSupported) ConscryptSocketAdapter else null
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt
new file mode 100644
index 0000000000..87d1277f2e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/DeferredSocketAdapter.kt
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.Protocol
+import okhttp3.internal.platform.Platform
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Deferred implementation of SocketAdapter that can only work by observing the socket
+ * and initializing on first use.
+ */
+class DeferredSocketAdapter(private val socketPackage: String) : SocketAdapter {
+  private var initialized = false
+  private var delegate: SocketAdapter? = null
+
+  override fun isSupported(): Boolean {
+    return true
+  }
+
+  override fun matchesSocket(sslSocket: SSLSocket): Boolean {
+    return sslSocket.javaClass.name.startsWith(socketPackage)
+  }
+
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  ) {
+    getDelegate(sslSocket)?.configureTlsExtensions(sslSocket, hostname, protocols)
+  }
+
+  override fun getSelectedProtocol(sslSocket: SSLSocket): String? {
+    return getDelegate(sslSocket)?.getSelectedProtocol(sslSocket)
+  }
+
+  @Synchronized private fun getDelegate(actualSSLSocketClass: SSLSocket): SocketAdapter? {
+    if (!initialized) {
+      try {
+        var possibleClass: Class<in SSLSocket> = actualSSLSocketClass.javaClass
+        while (possibleClass.name != "$socketPackage.OpenSSLSocketImpl") {
+          possibleClass = possibleClass.superclass
+
+          if (possibleClass == null) {
+            throw AssertionError(
+                "No OpenSSLSocketImpl superclass of socket of type $actualSSLSocketClass")
+          }
+        }
+
+        delegate = AndroidSocketAdapter(possibleClass)
+      } catch (e: Exception) {
+        Platform.get()
+            .log(Platform.WARN, "Failed to initialize DeferredSocketAdapter $socketPackage", e)
+      }
+
+      initialized = true
+    }
+
+    return delegate
+  }
+
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {
+    // not supported with modern Android and opt-in Gms Provider
+    return null
+  }
+
+  override fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean {
+    return false
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/SocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/SocketAdapter.kt
new file mode 100644
index 0000000000..5555f1c695
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/SocketAdapter.kt
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.Protocol
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+interface SocketAdapter {
+  open fun isSupported(): Boolean
+  fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager?
+  fun matchesSocket(sslSocket: SSLSocket): Boolean
+  fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean
+
+  open fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  )
+
+  open fun getSelectedProtocol(sslSocket: SSLSocket): String?
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/StandardAndroidSocketAdapter.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/StandardAndroidSocketAdapter.kt
new file mode 100644
index 0000000000..4974b23080
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/StandardAndroidSocketAdapter.kt
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.internal.platform.Platform
+import okhttp3.internal.readFieldOrNull
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Base Android reflection based SocketAdapter for the built in Android SSLSocket.
+ */
+class StandardAndroidSocketAdapter(
+  sslSocketClass: Class<in SSLSocket>,
+  private val sslSocketFactoryClass: Class<in SSLSocketFactory>,
+  private val paramClass: Class<*>
+) : AndroidSocketAdapter(
+    sslSocketClass) {
+
+  override fun matchesSocketFactory(sslSocketFactory: SSLSocketFactory): Boolean =
+      sslSocketFactoryClass.isInstance(sslSocketFactory)
+
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {
+    val context: Any? =
+        readFieldOrNull(sslSocketFactory, paramClass,
+            "sslParameters")
+    val x509TrustManager = readFieldOrNull(
+        context!!, X509TrustManager::class.java, "x509TrustManager")
+    return x509TrustManager ?: readFieldOrNull(context,
+        X509TrustManager::class.java,
+        "trustManager")
+  }
+
+  companion object {
+    @Suppress("UNCHECKED_CAST")
+    fun buildIfSupported(packageName: String = "com.android.org.conscrypt"): SocketAdapter? {
+      return try {
+        val sslSocketClass = Class.forName("$packageName.OpenSSLSocketImpl") as Class<in SSLSocket>
+        val sslSocketFactoryClass =
+            Class.forName("$packageName.OpenSSLSocketFactoryImpl") as Class<in SSLSocketFactory>
+        val paramsClass = Class.forName("$packageName.SSLParametersImpl")
+
+        StandardAndroidSocketAdapter(sslSocketClass, sslSocketFactoryClass, paramsClass)
+      } catch (e: Exception) {
+        androidLog(Platform.WARN, "unable to load android socket classes", e)
+        null
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt b/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt
new file mode 100644
index 0000000000..4a3bf12e42
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/android/util.kt
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import android.util.Log
+import okhttp3.internal.platform.Platform
+
+private const val MAX_LOG_LENGTH = 4000
+
+internal fun androidLog(level: Int, message: String, t: Throwable?) {
+  var logMessage = message
+  val logLevel = if (level == Platform.WARN) Log.WARN else Log.DEBUG
+  if (t != null) logMessage = logMessage + '\n'.toString() + Log.getStackTraceString(t)
+
+  // Split by line, then ensure each line can fit into Log's maximum length.
+  var i = 0
+  val length = logMessage.length
+  while (i < length) {
+    var newline = logMessage.indexOf('\n', i)
+    newline = if (newline != -1) newline else length
+    do {
+      val end = minOf(newline, i + MAX_LOG_LENGTH)
+      Log.println(logLevel, "OkHttp", logMessage.substring(i, end))
+      i = end
+    } while (i < newline)
+    i++
+  }
+}
\ No newline at end of file
diff --git a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
deleted file mode 100644
index 74fbd89b79..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
+++ /dev/null
@@ -1,340 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.publicsuffix;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InterruptedIOException;
-import java.net.IDN;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicBoolean;
-import okhttp3.internal.platform.Platform;
-import okio.BufferedSource;
-import okio.GzipSource;
-import okio.Okio;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-/**
- * A database of public suffixes provided by
- * <a href="https://publicsuffix.org/">publicsuffix.org</a>.
- */
-public final class PublicSuffixDatabase {
-  public static final String PUBLIC_SUFFIX_RESOURCE = "publicsuffixes.gz";
-
-  private static final byte[] WILDCARD_LABEL = new byte[]{'*'};
-  private static final String[] EMPTY_RULE = new String[0];
-  private static final String[] PREVAILING_RULE = new String[]{"*"};
-
-  private static final byte EXCEPTION_MARKER = '!';
-
-  private static final PublicSuffixDatabase instance = new PublicSuffixDatabase();
-
-  /** True after we've attempted to read the list for the first time. */
-  private final AtomicBoolean listRead = new AtomicBoolean(false);
-
-  /** Used for concurrent threads reading the list for the first time. */
-  private final CountDownLatch readCompleteLatch = new CountDownLatch(1);
-
-  // The lists are held as a large array of UTF-8 bytes. This is to avoid allocating lots of strings
-  // that will likely never be used. Each rule is separated by '\n'. Please see the
-  // PublicSuffixListGenerator class for how these lists are generated.
-  // Guarded by this.
-  private byte[] publicSuffixListBytes;
-  private byte[] publicSuffixExceptionListBytes;
-
-  public static PublicSuffixDatabase get() {
-    return instance;
-  }
-
-  /**
-   * Returns the effective top-level domain plus one (eTLD+1) by referencing the public suffix list.
-   * Returns null if the domain is a public suffix or a private address.
-   *
-   * <p>Here are some examples: <pre>{@code
-   * assertEquals("google.com", getEffectiveTldPlusOne("google.com"));
-   * assertEquals("google.com", getEffectiveTldPlusOne("www.google.com"));
-   * assertNull(getEffectiveTldPlusOne("com"));
-   * assertNull(getEffectiveTldPlusOne("localhost"));
-   * assertNull(getEffectiveTldPlusOne("mymacbook"));
-   * }</pre>
-   *
-   * @param domain A canonicalized domain. An International Domain Name (IDN) should be punycode
-   *    encoded.
-   */
-  public String getEffectiveTldPlusOne(String domain) {
-    if (domain == null) throw new NullPointerException("domain == null");
-
-    // We use UTF-8 in the list so we need to convert to Unicode.
-    String unicodeDomain = IDN.toUnicode(domain);
-    String[] domainLabels = unicodeDomain.split("\\.");
-    String[] rule = findMatchingRule(domainLabels);
-    if (domainLabels.length == rule.length && rule[0].charAt(0) != EXCEPTION_MARKER) {
-      // The domain is a public suffix.
-      return null;
-    }
-
-    int firstLabelOffset;
-    if (rule[0].charAt(0) == EXCEPTION_MARKER) {
-      // Exception rules hold the effective TLD plus one.
-      firstLabelOffset = domainLabels.length - rule.length;
-    } else {
-      // Otherwise the rule is for a public suffix, so we must take one more label.
-      firstLabelOffset = domainLabels.length - (rule.length + 1);
-    }
-
-    StringBuilder effectiveTldPlusOne = new StringBuilder();
-    String[] punycodeLabels = domain.split("\\.");
-    for (int i = firstLabelOffset; i < punycodeLabels.length; i++) {
-      effectiveTldPlusOne.append(punycodeLabels[i]).append('.');
-    }
-    effectiveTldPlusOne.deleteCharAt(effectiveTldPlusOne.length() - 1);
-
-    return effectiveTldPlusOne.toString();
-  }
-
-  private String[] findMatchingRule(String[] domainLabels) {
-    if (!listRead.get() && listRead.compareAndSet(false, true)) {
-      readTheListUninterruptibly();
-    } else {
-      try {
-        readCompleteLatch.await();
-      } catch (InterruptedException ignored) {
-        Thread.currentThread().interrupt(); // Retain interrupted status.
-      }
-    }
-
-    synchronized (this) {
-      if (publicSuffixListBytes == null) {
-        throw new IllegalStateException("Unable to load " + PUBLIC_SUFFIX_RESOURCE + " resource "
-            + "from the classpath.");
-      }
-    }
-
-    // Break apart the domain into UTF-8 labels, i.e. foo.bar.com turns into [foo, bar, com].
-    byte[][] domainLabelsUtf8Bytes = new byte[domainLabels.length][];
-    for (int i = 0; i < domainLabels.length; i++) {
-      domainLabelsUtf8Bytes[i] = domainLabels[i].getBytes(UTF_8);
-    }
-
-    // Start by looking for exact matches. We start at the leftmost label. For example, foo.bar.com
-    // will look like: [foo, bar, com], [bar, com], [com]. The longest matching rule wins.
-    String exactMatch = null;
-    for (int i = 0; i < domainLabelsUtf8Bytes.length; i++) {
-      String rule = binarySearchBytes(publicSuffixListBytes, domainLabelsUtf8Bytes, i);
-      if (rule != null) {
-        exactMatch = rule;
-        break;
-      }
-    }
-
-    // In theory, wildcard rules are not restricted to having the wildcard in the leftmost position.
-    // In practice, wildcards are always in the leftmost position. For now, this implementation
-    // cheats and does not attempt every possible permutation. Instead, it only considers wildcards
-    // in the leftmost position. We assert this fact when we generate the public suffix file. If
-    // this assertion ever fails we'll need to refactor this implementation.
-    String wildcardMatch = null;
-    if (domainLabelsUtf8Bytes.length > 1) {
-      byte[][] labelsWithWildcard = domainLabelsUtf8Bytes.clone();
-      for (int labelIndex = 0; labelIndex < labelsWithWildcard.length - 1; labelIndex++) {
-        labelsWithWildcard[labelIndex] = WILDCARD_LABEL;
-        String rule = binarySearchBytes(publicSuffixListBytes, labelsWithWildcard, labelIndex);
-        if (rule != null) {
-          wildcardMatch = rule;
-          break;
-        }
-      }
-    }
-
-    // Exception rules only apply to wildcard rules, so only try it if we matched a wildcard.
-    String exception = null;
-    if (wildcardMatch != null) {
-      for (int labelIndex = 0; labelIndex < domainLabelsUtf8Bytes.length - 1; labelIndex++) {
-        String rule = binarySearchBytes(
-            publicSuffixExceptionListBytes, domainLabelsUtf8Bytes, labelIndex);
-        if (rule != null) {
-          exception = rule;
-          break;
-        }
-      }
-    }
-
-    if (exception != null) {
-      // Signal we've identified an exception rule.
-      exception = "!" + exception;
-      return exception.split("\\.");
-    } else if (exactMatch == null && wildcardMatch == null) {
-      return PREVAILING_RULE;
-    }
-
-    String[] exactRuleLabels = exactMatch != null
-        ? exactMatch.split("\\.")
-        : EMPTY_RULE;
-
-    String[] wildcardRuleLabels = wildcardMatch != null
-        ? wildcardMatch.split("\\.")
-        : EMPTY_RULE;
-
-    return exactRuleLabels.length > wildcardRuleLabels.length
-        ? exactRuleLabels
-        : wildcardRuleLabels;
-  }
-
-  private static String binarySearchBytes(byte[] bytesToSearch, byte[][] labels, int labelIndex) {
-    int low = 0;
-    int high = bytesToSearch.length;
-    String match = null;
-    while (low < high) {
-      int mid = (low + high) / 2;
-      // Search for a '\n' that marks the start of a value. Don't go back past the start of the
-      // array.
-      while (mid > -1 && bytesToSearch[mid] != '\n') {
-        mid--;
-      }
-      mid++;
-
-      // Now look for the ending '\n'.
-      int end = 1;
-      while (bytesToSearch[mid + end] != '\n') {
-        end++;
-      }
-      int publicSuffixLength = (mid + end) - mid;
-
-      // Compare the bytes. Note that the file stores UTF-8 encoded bytes, so we must compare the
-      // unsigned bytes.
-      int compareResult;
-      int currentLabelIndex = labelIndex;
-      int currentLabelByteIndex = 0;
-      int publicSuffixByteIndex = 0;
-
-      boolean expectDot = false;
-      while (true) {
-        int byte0;
-        if (expectDot) {
-          byte0 = '.';
-          expectDot = false;
-        } else {
-          byte0 = labels[currentLabelIndex][currentLabelByteIndex] & 0xff;
-        }
-
-        int byte1 = bytesToSearch[mid + publicSuffixByteIndex] & 0xff;
-
-        compareResult = byte0 - byte1;
-        if (compareResult != 0) break;
-
-        publicSuffixByteIndex++;
-        currentLabelByteIndex++;
-        if (publicSuffixByteIndex == publicSuffixLength) break;
-
-        if (labels[currentLabelIndex].length == currentLabelByteIndex) {
-          // We've exhausted our current label. Either there are more labels to compare, in which
-          // case we expect a dot as the next character. Otherwise, we've checked all our labels.
-          if (currentLabelIndex == labels.length - 1) {
-            break;
-          } else {
-            currentLabelIndex++;
-            currentLabelByteIndex = -1;
-            expectDot = true;
-          }
-        }
-      }
-
-      if (compareResult < 0) {
-        high = mid - 1;
-      } else if (compareResult > 0) {
-        low = mid + end + 1;
-      } else {
-        // We found a match, but are the lengths equal?
-        int publicSuffixBytesLeft = publicSuffixLength - publicSuffixByteIndex;
-        int labelBytesLeft = labels[currentLabelIndex].length - currentLabelByteIndex;
-        for (int i = currentLabelIndex + 1; i < labels.length; i++) {
-          labelBytesLeft += labels[i].length;
-        }
-
-        if (labelBytesLeft < publicSuffixBytesLeft) {
-          high = mid - 1;
-        } else if (labelBytesLeft > publicSuffixBytesLeft) {
-          low = mid + end + 1;
-        } else {
-          // Found a match.
-          match = new String(bytesToSearch, mid, publicSuffixLength, UTF_8);
-          break;
-        }
-      }
-    }
-    return match;
-  }
-
-  /**
-   * Reads the public suffix list treating the operation as uninterruptible. We always want to read
-   * the list otherwise we'll be left in a bad state. If the thread was interrupted prior to this
-   * operation, it will be re-interrupted after the list is read.
-   */
-  private void readTheListUninterruptibly() {
-    boolean interrupted = false;
-    try {
-      while (true) {
-        try {
-          readTheList();
-          return;
-        } catch (InterruptedIOException e) {
-          Thread.interrupted(); // Temporarily clear the interrupted state.
-          interrupted = true;
-        } catch (IOException e) {
-          Platform.get().log(Platform.WARN, "Failed to read public suffix list", e);
-          return;
-        }
-      }
-    } finally {
-      if (interrupted) {
-        Thread.currentThread().interrupt(); // Retain interrupted status.
-      }
-    }
-  }
-
-  private void readTheList() throws IOException {
-    byte[] publicSuffixListBytes;
-    byte[] publicSuffixExceptionListBytes;
-
-    InputStream resource = PublicSuffixDatabase.class.getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
-    if (resource == null) return;
-
-    try (BufferedSource bufferedSource = Okio.buffer(new GzipSource(Okio.source(resource)))) {
-      int totalBytes = bufferedSource.readInt();
-      publicSuffixListBytes = new byte[totalBytes];
-      bufferedSource.readFully(publicSuffixListBytes);
-
-      int totalExceptionBytes = bufferedSource.readInt();
-      publicSuffixExceptionListBytes = new byte[totalExceptionBytes];
-      bufferedSource.readFully(publicSuffixExceptionListBytes);
-    }
-
-    synchronized (this) {
-      this.publicSuffixListBytes = publicSuffixListBytes;
-      this.publicSuffixExceptionListBytes = publicSuffixExceptionListBytes;
-    }
-
-    readCompleteLatch.countDown();
-  }
-
-  /** Visible for testing. */
-  void setListBytes(byte[] publicSuffixListBytes, byte[] publicSuffixExceptionListBytes) {
-    this.publicSuffixListBytes = publicSuffixListBytes;
-    this.publicSuffixExceptionListBytes = publicSuffixExceptionListBytes;
-    listRead.set(true);
-    readCompleteLatch.countDown();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.kt b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.kt
new file mode 100644
index 0000000000..9021066066
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.kt
@@ -0,0 +1,329 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.publicsuffix
+
+import okhttp3.internal.and
+import okhttp3.internal.platform.Platform
+import okio.GzipSource
+import okio.buffer
+import okio.source
+import java.io.IOException
+import java.io.InterruptedIOException
+import java.net.IDN
+import java.nio.charset.StandardCharsets.UTF_8
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.atomic.AtomicBoolean
+
+/**
+ * A database of public suffixes provided by [publicsuffix.org][publicsuffix_org].
+ *
+ * [publicsuffix_org]: https://publicsuffix.org/
+ */
+class PublicSuffixDatabase {
+
+  /** True after we've attempted to read the list for the first time. */
+  private val listRead = AtomicBoolean(false)
+
+  /** Used for concurrent threads reading the list for the first time. */
+  private val readCompleteLatch = CountDownLatch(1)
+
+  // The lists are held as a large array of UTF-8 bytes. This is to avoid allocating lots of strings
+  // that will likely never be used. Each rule is separated by '\n'. Please see the
+  // PublicSuffixListGenerator class for how these lists are generated.
+  // Guarded by this.
+  private lateinit var publicSuffixListBytes: ByteArray
+  private lateinit var publicSuffixExceptionListBytes: ByteArray
+
+  /**
+   * Returns the effective top-level domain plus one (eTLD+1) by referencing the public suffix list.
+   * Returns null if the domain is a public suffix or a private address.
+   *
+   * Here are some examples:
+   *
+   * ```
+   * assertEquals("google.com", getEffectiveTldPlusOne("google.com"));
+   * assertEquals("google.com", getEffectiveTldPlusOne("www.google.com"));
+   * assertNull(getEffectiveTldPlusOne("com"));
+   * assertNull(getEffectiveTldPlusOne("localhost"));
+   * assertNull(getEffectiveTldPlusOne("mymacbook"));
+   * ```
+   *
+   * @param domain A canonicalized domain. An International Domain Name (IDN) should be punycode
+   *     encoded.
+   */
+  fun getEffectiveTldPlusOne(domain: String): String? {
+    // We use UTF-8 in the list so we need to convert to Unicode.
+    val unicodeDomain = IDN.toUnicode(domain)
+    val domainLabels = unicodeDomain.split('.')
+    val rule = findMatchingRule(domainLabels)
+    if (domainLabels.size == rule.size && rule[0][0] != EXCEPTION_MARKER) {
+      return null // The domain is a public suffix.
+    }
+
+    val firstLabelOffset = if (rule[0][0] == EXCEPTION_MARKER) {
+      // Exception rules hold the effective TLD plus one.
+      domainLabels.size - rule.size
+    } else {
+      // Otherwise the rule is for a public suffix, so we must take one more label.
+      domainLabels.size - (rule.size + 1)
+    }
+
+    return domain.split('.').asSequence().drop(firstLabelOffset).joinToString(".")
+  }
+
+  private fun findMatchingRule(domainLabels: List<String>): List<String> {
+    if (!listRead.get() && listRead.compareAndSet(false, true)) {
+      readTheListUninterruptibly()
+    } else {
+      try {
+        readCompleteLatch.await()
+      } catch (_: InterruptedException) {
+        Thread.currentThread().interrupt() // Retain interrupted status.
+      }
+    }
+
+    check(::publicSuffixListBytes.isInitialized) {
+      "Unable to load $PUBLIC_SUFFIX_RESOURCE resource from the classpath."
+    }
+
+    // Break apart the domain into UTF-8 labels, i.e. foo.bar.com turns into [foo, bar, com].
+    val domainLabelsUtf8Bytes = Array(domainLabels.size) { i -> domainLabels[i].toByteArray(UTF_8) }
+
+    // Start by looking for exact matches. We start at the leftmost label. For example, foo.bar.com
+    // will look like: [foo, bar, com], [bar, com], [com]. The longest matching rule wins.
+    var exactMatch: String? = null
+    for (i in domainLabelsUtf8Bytes.indices) {
+      val rule = publicSuffixListBytes.binarySearch(domainLabelsUtf8Bytes, i)
+      if (rule != null) {
+        exactMatch = rule
+        break
+      }
+    }
+
+    // In theory, wildcard rules are not restricted to having the wildcard in the leftmost position.
+    // In practice, wildcards are always in the leftmost position. For now, this implementation
+    // cheats and does not attempt every possible permutation. Instead, it only considers wildcards
+    // in the leftmost position. We assert this fact when we generate the public suffix file. If
+    // this assertion ever fails we'll need to refactor this implementation.
+    var wildcardMatch: String? = null
+    if (domainLabelsUtf8Bytes.size > 1) {
+      val labelsWithWildcard = domainLabelsUtf8Bytes.clone()
+      for (labelIndex in 0 until labelsWithWildcard.size - 1) {
+        labelsWithWildcard[labelIndex] = WILDCARD_LABEL
+        val rule = publicSuffixListBytes.binarySearch(labelsWithWildcard, labelIndex)
+        if (rule != null) {
+          wildcardMatch = rule
+          break
+        }
+      }
+    }
+
+    // Exception rules only apply to wildcard rules, so only try it if we matched a wildcard.
+    var exception: String? = null
+    if (wildcardMatch != null) {
+      for (labelIndex in 0 until domainLabelsUtf8Bytes.size - 1) {
+        val rule = publicSuffixExceptionListBytes.binarySearch(
+            domainLabelsUtf8Bytes, labelIndex)
+        if (rule != null) {
+          exception = rule
+          break
+        }
+      }
+    }
+
+    if (exception != null) {
+      // Signal we've identified an exception rule.
+      exception = "!$exception"
+      return exception.split('.')
+    } else if (exactMatch == null && wildcardMatch == null) {
+      return PREVAILING_RULE
+    }
+
+    val exactRuleLabels = exactMatch?.split('.') ?: listOf()
+    val wildcardRuleLabels = wildcardMatch?.split('.') ?: listOf()
+
+    return if (exactRuleLabels.size > wildcardRuleLabels.size) {
+      exactRuleLabels
+    } else {
+      wildcardRuleLabels
+    }
+  }
+
+  /**
+   * Reads the public suffix list treating the operation as uninterruptible. We always want to read
+   * the list otherwise we'll be left in a bad state. If the thread was interrupted prior to this
+   * operation, it will be re-interrupted after the list is read.
+   */
+  private fun readTheListUninterruptibly() {
+    var interrupted = false
+    try {
+      while (true) {
+        try {
+          readTheList()
+          return
+        } catch (_: InterruptedIOException) {
+          Thread.interrupted() // Temporarily clear the interrupted state.
+          interrupted = true
+        } catch (e: IOException) {
+          Platform.get().log(Platform.WARN, "Failed to read public suffix list", e)
+          return
+        }
+      }
+    } finally {
+      if (interrupted) {
+        Thread.currentThread().interrupt() // Retain interrupted status.
+      }
+    }
+  }
+
+  @Throws(IOException::class)
+  private fun readTheList() {
+    var publicSuffixListBytes: ByteArray? = null
+    var publicSuffixExceptionListBytes: ByteArray? = null
+
+    val resource =
+        PublicSuffixDatabase::class.java.getResourceAsStream(PUBLIC_SUFFIX_RESOURCE) ?: return
+
+    GzipSource(resource.source()).buffer().use { bufferedSource ->
+      val totalBytes = bufferedSource.readInt()
+      publicSuffixListBytes = bufferedSource.readByteArray(totalBytes.toLong())
+
+      val totalExceptionBytes = bufferedSource.readInt()
+      publicSuffixExceptionListBytes = bufferedSource.readByteArray(totalExceptionBytes.toLong())
+    }
+
+    synchronized(this) {
+      this.publicSuffixListBytes = publicSuffixListBytes!!
+      this.publicSuffixExceptionListBytes = publicSuffixExceptionListBytes!!
+    }
+
+    readCompleteLatch.countDown()
+  }
+
+  /** Visible for testing. */
+  fun setListBytes(
+    publicSuffixListBytes: ByteArray,
+    publicSuffixExceptionListBytes: ByteArray
+  ) {
+    this.publicSuffixListBytes = publicSuffixListBytes
+    this.publicSuffixExceptionListBytes = publicSuffixExceptionListBytes
+    listRead.set(true)
+    readCompleteLatch.countDown()
+  }
+
+  companion object {
+    const val PUBLIC_SUFFIX_RESOURCE = "publicsuffixes.gz"
+
+    private val WILDCARD_LABEL = byteArrayOf('*'.toByte())
+    private val PREVAILING_RULE = listOf("*")
+
+    private const val EXCEPTION_MARKER = '!'
+
+    private val instance = PublicSuffixDatabase()
+
+    fun get(): PublicSuffixDatabase {
+      return instance
+    }
+
+    private fun ByteArray.binarySearch(
+      labels: Array<ByteArray>,
+      labelIndex: Int
+    ): String? {
+      var low = 0
+      var high = size
+      var match: String? = null
+      while (low < high) {
+        var mid = (low + high) / 2
+        // Search for a '\n' that marks the start of a value. Don't go back past the start of the
+        // array.
+        while (mid > -1 && this[mid] != '\n'.toByte()) {
+          mid--
+        }
+        mid++
+
+        // Now look for the ending '\n'.
+        var end = 1
+        while (this[mid + end] != '\n'.toByte()) {
+          end++
+        }
+        val publicSuffixLength = mid + end - mid
+
+        // Compare the bytes. Note that the file stores UTF-8 encoded bytes, so we must compare the
+        // unsigned bytes.
+        var compareResult: Int
+        var currentLabelIndex = labelIndex
+        var currentLabelByteIndex = 0
+        var publicSuffixByteIndex = 0
+
+        var expectDot = false
+        while (true) {
+          val byte0: Int
+          if (expectDot) {
+            byte0 = '.'.toInt()
+            expectDot = false
+          } else {
+            byte0 = labels[currentLabelIndex][currentLabelByteIndex] and 0xff
+          }
+
+          val byte1 = this[mid + publicSuffixByteIndex] and 0xff
+
+          compareResult = byte0 - byte1
+          if (compareResult != 0) break
+
+          publicSuffixByteIndex++
+          currentLabelByteIndex++
+          if (publicSuffixByteIndex == publicSuffixLength) break
+
+          if (labels[currentLabelIndex].size == currentLabelByteIndex) {
+            // We've exhausted our current label. Either there are more labels to compare, in which
+            // case we expect a dot as the next character. Otherwise, we've checked all our labels.
+            if (currentLabelIndex == labels.size - 1) {
+              break
+            } else {
+              currentLabelIndex++
+              currentLabelByteIndex = -1
+              expectDot = true
+            }
+          }
+        }
+
+        if (compareResult < 0) {
+          high = mid - 1
+        } else if (compareResult > 0) {
+          low = mid + end + 1
+        } else {
+          // We found a match, but are the lengths equal?
+          val publicSuffixBytesLeft = publicSuffixLength - publicSuffixByteIndex
+          var labelBytesLeft = labels[currentLabelIndex].size - currentLabelByteIndex
+          for (i in currentLabelIndex + 1 until labels.size) {
+            labelBytesLeft += labels[i].size
+          }
+
+          if (labelBytesLeft < publicSuffixBytesLeft) {
+            high = mid - 1
+          } else if (labelBytesLeft > publicSuffixBytesLeft) {
+            low = mid + end + 1
+          } else {
+            // Found a match.
+            match = String(this, mid, publicSuffixLength, UTF_8)
+            break
+          }
+        }
+      }
+      return match
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.kt b/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.kt
index 3ebe3551f4..ef3cebe94f 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.kt
+++ b/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.kt
@@ -18,8 +18,8 @@ package okhttp3.internal.tls
 import java.security.GeneralSecurityException
 import java.security.cert.Certificate
 import java.security.cert.X509Certificate
-import java.util.Deque
 import java.util.ArrayDeque
+import java.util.Deque
 import javax.net.ssl.SSLPeerUnverifiedException
 
 /**
@@ -45,7 +45,7 @@ class BasicCertificateChainCleaner(
   @Throws(SSLPeerUnverifiedException::class)
   override fun clean(chain: List<Certificate>, hostname: String): List<Certificate> {
     val queue: Deque<Certificate> = ArrayDeque<Certificate>(chain)
-    val result = ArrayList<Certificate>()
+    val result = mutableListOf<Certificate>()
     result.add(queue.removeFirst())
     var foundTrustedCertificate = false
 
@@ -93,7 +93,7 @@ class BasicCertificateChainCleaner(
     throw SSLPeerUnverifiedException("Certificate chain too long: $result")
   }
 
-  /** Returns true if [toVerify] was signed by [signingCert]'s public key.  */
+  /** Returns true if [toVerify] was signed by [signingCert]'s public key. */
   private fun verifySignature(toVerify: X509Certificate, signingCert: X509Certificate): Boolean {
     if (toVerify.issuerDN != signingCert.subjectDN) {
       return false
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.kt b/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.kt
index 2b93613b87..4730e78d42 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.kt
+++ b/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.kt
@@ -18,7 +18,7 @@ package okhttp3.internal.tls
 import java.security.cert.X509Certificate
 import javax.security.auth.x500.X500Principal
 
-/** A simple index that of trusted root certificates that have been loaded into memory.  */
+/** A simple index that of trusted root certificates that have been loaded into memory. */
 class BasicTrustRootIndex(vararg caCerts: X509Certificate) : TrustRootIndex {
   private val subjectToCaCerts: Map<X500Principal, Set<X509Certificate>>
 
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.kt b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.kt
index 7296afa1a5..43f225a662 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.kt
+++ b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.kt
@@ -38,12 +38,10 @@ abstract class CertificateChainCleaner {
   abstract fun clean(chain: List<Certificate>, hostname: String): List<Certificate>
 
   companion object {
-    @JvmStatic
     fun get(trustManager: X509TrustManager): CertificateChainCleaner {
       return Platform.get().buildCertificateChainCleaner(trustManager)
     }
 
-    @JvmStatic
     fun get(vararg caCerts: X509Certificate): CertificateChainCleaner {
       return BasicCertificateChainCleaner(BasicTrustRootIndex(*caCerts))
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.kt b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.kt
index 0ca5172837..df3ee9b1c4 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.kt
+++ b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.kt
@@ -16,7 +16,7 @@
  */
 package okhttp3.internal.tls
 
-import okhttp3.internal.Util.verifyAsIpAddress
+import okhttp3.internal.canParseAsIpAddress
 import java.security.cert.CertificateParsingException
 import java.security.cert.X509Certificate
 import java.util.Locale
@@ -29,6 +29,7 @@ import javax.net.ssl.SSLSession
  *
  * [rfc_2818]: http://www.ietf.org/rfc/rfc2818.txt
  */
+@Suppress("NAME_SHADOWING")
 object OkHostnameVerifier : HostnameVerifier {
   private const val ALT_DNS_NAME = 2
   private const val ALT_IPA_NAME = 7
@@ -43,19 +44,19 @@ object OkHostnameVerifier : HostnameVerifier {
 
   fun verify(host: String, certificate: X509Certificate): Boolean {
     return when {
-      verifyAsIpAddress(host) -> verifyIpAddress(host, certificate)
+      host.canParseAsIpAddress() -> verifyIpAddress(host, certificate)
       else -> verifyHostname(host, certificate)
     }
   }
 
-  /** Returns true if `certificate` matches `ipAddress`.  */
+  /** Returns true if [certificate] matches [ipAddress]. */
   private fun verifyIpAddress(ipAddress: String, certificate: X509Certificate): Boolean {
     return getSubjectAltNames(certificate, ALT_IPA_NAME).any {
       ipAddress.equals(it, ignoreCase = true)
     }
   }
 
-  /** Returns true if `certificate` matches `hostname`.  */
+  /** Returns true if [certificate] matches [hostname]. */
   private fun verifyHostname(hostname: String, certificate: X509Certificate): Boolean {
     val hostname = hostname.toLowerCase(Locale.US)
     return getSubjectAltNames(certificate, ALT_DNS_NAME).any {
@@ -70,7 +71,7 @@ object OkHostnameVerifier : HostnameVerifier {
    * @param pattern domain name pattern from certificate. May be a wildcard pattern such as
    *     `*.android.com`.
    */
-  fun verifyHostname(hostname: String?, pattern: String?): Boolean {
+  private fun verifyHostname(hostname: String?, pattern: String?): Boolean {
     var hostname = hostname
     var pattern = pattern
     // Basic sanity checks
@@ -159,8 +160,8 @@ object OkHostnameVerifier : HostnameVerifier {
   }
 
   fun allSubjectAltNames(certificate: X509Certificate): List<String> {
-    val altIpaNames = getSubjectAltNames(certificate, OkHostnameVerifier.ALT_IPA_NAME)
-    val altDnsNames = getSubjectAltNames(certificate, OkHostnameVerifier.ALT_DNS_NAME)
+    val altIpaNames = getSubjectAltNames(certificate, ALT_IPA_NAME)
+    val altDnsNames = getSubjectAltNames(certificate, ALT_DNS_NAME)
     return altIpaNames + altDnsNames
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.kt b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.kt
index 3586029bb4..8331d2cf46 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.kt
+++ b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.kt
@@ -18,6 +18,6 @@ package okhttp3.internal.tls
 import java.security.cert.X509Certificate
 
 interface TrustRootIndex {
-  /** Returns the trusted CA certificate that signed [cert].  */
+  /** Returns the trusted CA certificate that signed [cert]. */
   fun findByIssuerAndSignature(cert: X509Certificate): X509Certificate?
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
deleted file mode 100644
index d056ad67e2..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ /dev/null
@@ -1,615 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.net.SocketTimeoutException;
-import java.util.ArrayDeque;
-import java.util.Collections;
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledFuture;
-import java.util.concurrent.ScheduledThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.EventListener;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.WebSocket;
-import okhttp3.WebSocketListener;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.connection.Exchange;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static okhttp3.internal.Util.closeQuietly;
-import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_CLIENT_GOING_AWAY;
-import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_MESSAGE_MAX;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
-import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
-
-public final class RealWebSocket implements WebSocket, WebSocketReader.FrameCallback {
-  private static final List<Protocol> ONLY_HTTP1 = Collections.singletonList(Protocol.HTTP_1_1);
-
-  /**
-   * The maximum number of bytes to enqueue. Rather than enqueueing beyond this limit we tear down
-   * the web socket! It's possible that we're writing faster than the peer can read.
-   */
-  private static final long MAX_QUEUE_SIZE = 16 * 1024 * 1024; // 16 MiB.
-
-  /**
-   * The maximum amount of time after the client calls {@link #close} to wait for a graceful
-   * shutdown. If the server doesn't respond the websocket will be canceled.
-   */
-  private static final long CANCEL_AFTER_CLOSE_MILLIS = 60 * 1000;
-
-  /** The application's original request unadulterated by web socket headers. */
-  private final Request originalRequest;
-
-  final WebSocketListener listener;
-  private final Random random;
-  private final long pingIntervalMillis;
-  private final String key;
-
-  /** Non-null for client web sockets. These can be canceled. */
-  private Call call;
-
-  /** This runnable processes the outgoing queues. Call {@link #runWriter()} to after enqueueing. */
-  private final Runnable writerRunnable;
-
-  /** Null until this web socket is connected. Only accessed by the reader thread. */
-  private WebSocketReader reader;
-
-  // All mutable web socket state is guarded by this.
-
-  /** Null until this web socket is connected. Note that messages may be enqueued before that. */
-  private WebSocketWriter writer;
-
-  /** Null until this web socket is connected. Used for writes, pings, and close timeouts. */
-  private ScheduledExecutorService executor;
-
-  /**
-   * The streams held by this web socket. This is non-null until all incoming messages have been
-   * read and all outgoing messages have been written. It is closed when both reader and writer are
-   * exhausted, or if there is any failure.
-   */
-  private Streams streams;
-
-  /** Outgoing pongs in the order they should be written. */
-  private final ArrayDeque<ByteString> pongQueue = new ArrayDeque<>();
-
-  /** Outgoing messages and close frames in the order they should be written. */
-  private final ArrayDeque<Object> messageAndCloseQueue = new ArrayDeque<>();
-
-  /** The total size in bytes of enqueued but not yet transmitted messages. */
-  private long queueSize;
-
-  /** True if we've enqueued a close frame. No further message frames will be enqueued. */
-  private boolean enqueuedClose;
-
-  /**
-   * When executed this will cancel this websocket. This future itself should be canceled if that is
-   * unnecessary because the web socket is already closed or canceled.
-   */
-  private ScheduledFuture<?> cancelFuture;
-
-  /** The close code from the peer, or -1 if this web socket has not yet read a close frame. */
-  private int receivedCloseCode = -1;
-
-  /** The close reason from the peer, or null if this web socket has not yet read a close frame. */
-  private String receivedCloseReason;
-
-  /** True if this web socket failed and the listener has been notified. */
-  private boolean failed;
-
-  /** Total number of pings sent by this web socket. */
-  private int sentPingCount;
-
-  /** Total number of pings received by this web socket. */
-  private int receivedPingCount;
-
-  /** Total number of pongs received by this web socket. */
-  private int receivedPongCount;
-
-  /** True if we have sent a ping that is still awaiting a reply. */
-  private boolean awaitingPong;
-
-  public RealWebSocket(Request request, WebSocketListener listener, Random random,
-      long pingIntervalMillis) {
-    if (!"GET".equals(request.method())) {
-      throw new IllegalArgumentException("Request must be GET: " + request.method());
-    }
-    this.originalRequest = request;
-    this.listener = listener;
-    this.random = random;
-    this.pingIntervalMillis = pingIntervalMillis;
-
-    byte[] nonce = new byte[16];
-    random.nextBytes(nonce);
-    this.key = ByteString.of(nonce).base64();
-
-    this.writerRunnable = () -> {
-      try {
-        while (writeOneFrame()) {
-        }
-      } catch (IOException e) {
-        failWebSocket(e, null);
-      }
-    };
-  }
-
-  @Override public Request request() {
-    return originalRequest;
-  }
-
-  @Override public synchronized long queueSize() {
-    return queueSize;
-  }
-
-  @Override public void cancel() {
-    call.cancel();
-  }
-
-  public void connect(OkHttpClient client) {
-    client = client.newBuilder()
-        .eventListener(EventListener.NONE)
-        .protocols(ONLY_HTTP1)
-        .build();
-    final Request request = originalRequest.newBuilder()
-        .header("Upgrade", "websocket")
-        .header("Connection", "Upgrade")
-        .header("Sec-WebSocket-Key", key)
-        .header("Sec-WebSocket-Version", "13")
-        .build();
-    call = Internal.instance.newWebSocketCall(client, request);
-    call.enqueue(new Callback() {
-      @Override public void onResponse(Call call, Response response) {
-        Exchange exchange = Internal.instance.exchange(response);
-        Streams streams;
-        try {
-          checkUpgradeSuccess(response, exchange);
-          streams = exchange.newWebSocketStreams();
-        } catch (IOException e) {
-          if (exchange != null) exchange.webSocketUpgradeFailed();
-          failWebSocket(e, response);
-          closeQuietly(response);
-          return;
-        }
-
-        // Process all web socket messages.
-        try {
-          String name = "OkHttp WebSocket " + request.url().redact();
-          initReaderAndWriter(name, streams);
-          listener.onOpen(RealWebSocket.this, response);
-          loopReader();
-        } catch (Exception e) {
-          failWebSocket(e, null);
-        }
-      }
-
-      @Override public void onFailure(Call call, IOException e) {
-        failWebSocket(e, null);
-      }
-    });
-  }
-
-  void checkUpgradeSuccess(Response response, @Nullable Exchange exchange) throws IOException {
-    if (response.code() != 101) {
-      throw new ProtocolException("Expected HTTP 101 response but was '"
-          + response.code() + " " + response.message() + "'");
-    }
-
-    String headerConnection = response.header("Connection");
-    if (!"Upgrade".equalsIgnoreCase(headerConnection)) {
-      throw new ProtocolException("Expected 'Connection' header value 'Upgrade' but was '"
-          + headerConnection + "'");
-    }
-
-    String headerUpgrade = response.header("Upgrade");
-    if (!"websocket".equalsIgnoreCase(headerUpgrade)) {
-      throw new ProtocolException(
-          "Expected 'Upgrade' header value 'websocket' but was '" + headerUpgrade + "'");
-    }
-
-    String headerAccept = response.header("Sec-WebSocket-Accept");
-    String acceptExpected = ByteString.encodeUtf8(key + WebSocketProtocol.ACCEPT_MAGIC)
-        .sha1().base64();
-    if (!acceptExpected.equals(headerAccept)) {
-      throw new ProtocolException("Expected 'Sec-WebSocket-Accept' header value '"
-          + acceptExpected + "' but was '" + headerAccept + "'");
-    }
-
-    if (exchange == null) {
-      throw new ProtocolException("Web Socket exchange missing: bad interceptor?");
-    }
-  }
-
-  public void initReaderAndWriter(String name, Streams streams) throws IOException {
-    synchronized (this) {
-      this.streams = streams;
-      this.writer = new WebSocketWriter(streams.client, streams.sink, random);
-      this.executor = new ScheduledThreadPoolExecutor(1, Util.threadFactory(name, false));
-      if (pingIntervalMillis != 0) {
-        executor.scheduleAtFixedRate(
-            new PingRunnable(), pingIntervalMillis, pingIntervalMillis, MILLISECONDS);
-      }
-      if (!messageAndCloseQueue.isEmpty()) {
-        runWriter(); // Send messages that were enqueued before we were connected.
-      }
-    }
-
-    reader = new WebSocketReader(streams.client, streams.source, this);
-  }
-
-  /** Receive frames until there are no more. Invoked only by the reader thread. */
-  public void loopReader() throws IOException {
-    while (receivedCloseCode == -1) {
-      // This method call results in one or more onRead* methods being called on this thread.
-      reader.processNextFrame();
-    }
-  }
-
-  /**
-   * For testing: receive a single frame and return true if there are more frames to read. Invoked
-   * only by the reader thread.
-   */
-  boolean processNextFrame() throws IOException {
-    try {
-      reader.processNextFrame();
-      return receivedCloseCode == -1;
-    } catch (Exception e) {
-      failWebSocket(e, null);
-      return false;
-    }
-  }
-
-  /**
-   * For testing: wait until the web socket's executor has terminated.
-   */
-  void awaitTermination(int timeout, TimeUnit timeUnit) throws InterruptedException {
-    executor.awaitTermination(timeout, timeUnit);
-  }
-
-  /**
-   * For testing: force this web socket to release its threads.
-   */
-  void tearDown() throws InterruptedException {
-    if (cancelFuture != null) {
-      cancelFuture.cancel(false);
-    }
-    executor.shutdown();
-    executor.awaitTermination(10, TimeUnit.SECONDS);
-  }
-
-  synchronized int sentPingCount() {
-    return sentPingCount;
-  }
-
-  synchronized int receivedPingCount() {
-    return receivedPingCount;
-  }
-
-  synchronized int receivedPongCount() {
-    return receivedPongCount;
-  }
-
-  @Override public void onReadMessage(String text) throws IOException {
-    listener.onMessage(this, text);
-  }
-
-  @Override public void onReadMessage(ByteString bytes) throws IOException {
-    listener.onMessage(this, bytes);
-  }
-
-  @Override public synchronized void onReadPing(ByteString payload) {
-    // Don't respond to pings after we've failed or sent the close frame.
-    if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty())) return;
-
-    pongQueue.add(payload);
-    runWriter();
-    receivedPingCount++;
-  }
-
-  @Override public synchronized void onReadPong(ByteString buffer) {
-    // This API doesn't expose pings.
-    receivedPongCount++;
-    awaitingPong = false;
-  }
-
-  @Override public void onReadClose(int code, String reason) {
-    if (code == -1) throw new IllegalArgumentException();
-
-    Streams toClose = null;
-    synchronized (this) {
-      if (receivedCloseCode != -1) throw new IllegalStateException("already closed");
-      receivedCloseCode = code;
-      receivedCloseReason = reason;
-      if (enqueuedClose && messageAndCloseQueue.isEmpty()) {
-        toClose = this.streams;
-        this.streams = null;
-        if (cancelFuture != null) cancelFuture.cancel(false);
-        this.executor.shutdown();
-      }
-    }
-
-    try {
-      listener.onClosing(this, code, reason);
-
-      if (toClose != null) {
-        listener.onClosed(this, code, reason);
-      }
-    } finally {
-      closeQuietly(toClose);
-    }
-  }
-
-  // Writer methods to enqueue frames. They'll be sent asynchronously by the writer thread.
-
-  @Override public boolean send(String text) {
-    if (text == null) throw new NullPointerException("text == null");
-    return send(ByteString.encodeUtf8(text), OPCODE_TEXT);
-  }
-
-  @Override public boolean send(ByteString bytes) {
-    if (bytes == null) throw new NullPointerException("bytes == null");
-    return send(bytes, OPCODE_BINARY);
-  }
-
-  private synchronized boolean send(ByteString data, int formatOpcode) {
-    // Don't send new frames after we've failed or enqueued a close frame.
-    if (failed || enqueuedClose) return false;
-
-    // If this frame overflows the buffer, reject it and close the web socket.
-    if (queueSize + data.size() > MAX_QUEUE_SIZE) {
-      close(CLOSE_CLIENT_GOING_AWAY, null);
-      return false;
-    }
-
-    // Enqueue the message frame.
-    queueSize += data.size();
-    messageAndCloseQueue.add(new Message(formatOpcode, data));
-    runWriter();
-    return true;
-  }
-
-  synchronized boolean pong(ByteString payload) {
-    // Don't send pongs after we've failed or sent the close frame.
-    if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty())) return false;
-
-    pongQueue.add(payload);
-    runWriter();
-    return true;
-  }
-
-  @Override public boolean close(int code, String reason) {
-    return close(code, reason, CANCEL_AFTER_CLOSE_MILLIS);
-  }
-
-  synchronized boolean close(int code, String reason, long cancelAfterCloseMillis) {
-    validateCloseCode(code);
-
-    ByteString reasonBytes = null;
-    if (reason != null) {
-      reasonBytes = ByteString.encodeUtf8(reason);
-      if (reasonBytes.size() > CLOSE_MESSAGE_MAX) {
-        throw new IllegalArgumentException("reason.size() > " + CLOSE_MESSAGE_MAX + ": " + reason);
-      }
-    }
-
-    if (failed || enqueuedClose) return false;
-
-    // Immediately prevent further frames from being enqueued.
-    enqueuedClose = true;
-
-    // Enqueue the close frame.
-    messageAndCloseQueue.add(new Close(code, reasonBytes, cancelAfterCloseMillis));
-    runWriter();
-    return true;
-  }
-
-  private void runWriter() {
-    assert (Thread.holdsLock(this));
-
-    if (executor != null) {
-      executor.execute(writerRunnable);
-    }
-  }
-
-  /**
-   * Attempts to remove a single frame from a queue and send it. This prefers to write urgent pongs
-   * before less urgent messages and close frames. For example it's possible that a caller will
-   * enqueue messages followed by pongs, but this sends pongs followed by messages. Pongs are always
-   * written in the order they were enqueued.
-   *
-   * <p>If a frame cannot be sent - because there are none enqueued or because the web socket is not
-   * connected - this does nothing and returns false. Otherwise this returns true and the caller
-   * should immediately invoke this method again until it returns false.
-   *
-   * <p>This method may only be invoked by the writer thread. There may be only thread invoking this
-   * method at a time.
-   */
-  boolean writeOneFrame() throws IOException {
-    WebSocketWriter writer;
-    ByteString pong;
-    Object messageOrClose = null;
-    int receivedCloseCode = -1;
-    String receivedCloseReason = null;
-    Streams streamsToClose = null;
-
-    synchronized (RealWebSocket.this) {
-      if (failed) {
-        return false; // Failed web socket.
-      }
-
-      writer = this.writer;
-      pong = pongQueue.poll();
-      if (pong == null) {
-        messageOrClose = messageAndCloseQueue.poll();
-        if (messageOrClose instanceof Close) {
-          receivedCloseCode = this.receivedCloseCode;
-          receivedCloseReason = this.receivedCloseReason;
-          if (receivedCloseCode != -1) {
-            streamsToClose = this.streams;
-            this.streams = null;
-            this.executor.shutdown();
-          } else {
-            // When we request a graceful close also schedule a cancel of the websocket.
-            cancelFuture = executor.schedule(new CancelRunnable(),
-                ((Close) messageOrClose).cancelAfterCloseMillis, MILLISECONDS);
-          }
-        } else if (messageOrClose == null) {
-          return false; // The queue is exhausted.
-        }
-      }
-    }
-
-    try {
-      if (pong != null) {
-        writer.writePong(pong);
-
-      } else if (messageOrClose instanceof Message) {
-        ByteString data = ((Message) messageOrClose).data;
-        BufferedSink sink = Okio.buffer(writer.newMessageSink(
-            ((Message) messageOrClose).formatOpcode, data.size()));
-        sink.write(data);
-        sink.close();
-        synchronized (this) {
-          queueSize -= data.size();
-        }
-
-      } else if (messageOrClose instanceof Close) {
-        Close close = (Close) messageOrClose;
-        writer.writeClose(close.code, close.reason);
-
-        // We closed the writer: now both reader and writer are closed.
-        if (streamsToClose != null) {
-          listener.onClosed(this, receivedCloseCode, receivedCloseReason);
-        }
-
-      } else {
-        throw new AssertionError();
-      }
-
-      return true;
-    } finally {
-      closeQuietly(streamsToClose);
-    }
-  }
-
-  private final class PingRunnable implements Runnable {
-    PingRunnable() {
-    }
-
-    @Override public void run() {
-      writePingFrame();
-    }
-  }
-
-  void writePingFrame() {
-    WebSocketWriter writer;
-    int failedPing;
-    synchronized (this) {
-      if (failed) return;
-      writer = this.writer;
-      failedPing = awaitingPong ? sentPingCount : -1;
-      sentPingCount++;
-      awaitingPong = true;
-    }
-
-    if (failedPing != -1) {
-      failWebSocket(new SocketTimeoutException("sent ping but didn't receive pong within "
-          + pingIntervalMillis + "ms (after " + (failedPing - 1) + " successful ping/pongs)"),
-          null);
-      return;
-    }
-
-    try {
-      writer.writePing(ByteString.EMPTY);
-    } catch (IOException e) {
-      failWebSocket(e, null);
-    }
-  }
-
-  public void failWebSocket(Exception e, @Nullable Response response) {
-    Streams streamsToClose;
-    synchronized (this) {
-      if (failed) return; // Already failed.
-      failed = true;
-      streamsToClose = this.streams;
-      this.streams = null;
-      if (cancelFuture != null) cancelFuture.cancel(false);
-      if (executor != null) executor.shutdown();
-    }
-
-    try {
-      listener.onFailure(this, e, response);
-    } finally {
-      closeQuietly(streamsToClose);
-    }
-  }
-
-  static final class Message {
-    final int formatOpcode;
-    final ByteString data;
-
-    Message(int formatOpcode, ByteString data) {
-      this.formatOpcode = formatOpcode;
-      this.data = data;
-    }
-  }
-
-  static final class Close {
-    final int code;
-    final ByteString reason;
-    final long cancelAfterCloseMillis;
-
-    Close(int code, ByteString reason, long cancelAfterCloseMillis) {
-      this.code = code;
-      this.reason = reason;
-      this.cancelAfterCloseMillis = cancelAfterCloseMillis;
-    }
-  }
-
-  public abstract static class Streams implements Closeable {
-    public final boolean client;
-    public final BufferedSource source;
-    public final BufferedSink sink;
-
-    public Streams(boolean client, BufferedSource source, BufferedSink sink) {
-      this.client = client;
-      this.source = source;
-      this.sink = sink;
-    }
-  }
-
-  final class CancelRunnable implements Runnable {
-    @Override public void run() {
-      cancel();
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt
new file mode 100644
index 0000000000..c7feccef49
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.kt
@@ -0,0 +1,576 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws
+
+import okhttp3.Call
+import okhttp3.Callback
+import okhttp3.EventListener
+import okhttp3.OkHttpClient
+import okhttp3.Protocol
+import okhttp3.RealCall
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.WebSocket
+import okhttp3.WebSocketListener
+import okhttp3.internal.closeQuietly
+import okhttp3.internal.connection.Exchange
+import okhttp3.internal.threadFactory
+import okhttp3.internal.ws.WebSocketProtocol.CLOSE_CLIENT_GOING_AWAY
+import okhttp3.internal.ws.WebSocketProtocol.CLOSE_MESSAGE_MAX
+import okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY
+import okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT
+import okhttp3.internal.ws.WebSocketProtocol.validateCloseCode
+import okio.BufferedSink
+import okio.BufferedSource
+import okio.ByteString
+import okio.ByteString.Companion.encodeUtf8
+import okio.ByteString.Companion.toByteString
+import okio.buffer
+import java.io.Closeable
+import java.io.IOException
+import java.net.ProtocolException
+import java.net.SocketTimeoutException
+import java.util.ArrayDeque
+import java.util.Random
+import java.util.concurrent.ScheduledExecutorService
+import java.util.concurrent.ScheduledFuture
+import java.util.concurrent.ScheduledThreadPoolExecutor
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.TimeUnit.MILLISECONDS
+
+class RealWebSocket(
+  /** The application's original request unadulterated by web socket headers. */
+  private val originalRequest: Request,
+  internal val listener: WebSocketListener,
+  private val random: Random,
+  private val pingIntervalMillis: Long
+) : WebSocket, WebSocketReader.FrameCallback {
+  private val key: String
+
+  /** Non-null for client web sockets. These can be canceled. */
+  private var call: Call? = null
+
+  /** This runnable processes the outgoing queues. Call [runWriter] to after enqueueing. */
+  private val writerRunnable: Runnable
+
+  /** Null until this web socket is connected. Only accessed by the reader thread. */
+  private var reader: WebSocketReader? = null
+
+  // All mutable web socket state is guarded by this.
+
+  /** Null until this web socket is connected. Note that messages may be enqueued before that. */
+  private var writer: WebSocketWriter? = null
+
+  /** Null until this web socket is connected. Used for writes, pings, and close timeouts. */
+  private var executor: ScheduledExecutorService? = null
+
+  /**
+   * The streams held by this web socket. This is non-null until all incoming messages have been
+   * read and all outgoing messages have been written. It is closed when both reader and writer are
+   * exhausted, or if there is any failure.
+   */
+  private var streams: Streams? = null
+
+  /** Outgoing pongs in the order they should be written. */
+  private val pongQueue = ArrayDeque<ByteString>()
+
+  /** Outgoing messages and close frames in the order they should be written. */
+  private val messageAndCloseQueue = ArrayDeque<Any>()
+
+  /** The total size in bytes of enqueued but not yet transmitted messages. */
+  private var queueSize = 0L
+
+  /** True if we've enqueued a close frame. No further message frames will be enqueued. */
+  private var enqueuedClose = false
+
+  /**
+   * When executed this will cancel this web socket. This future itself should be canceled if that
+   * is unnecessary because the web socket is already closed or canceled.
+   */
+  private var cancelFuture: ScheduledFuture<*>? = null
+
+  /** The close code from the peer, or -1 if this web socket has not yet read a close frame. */
+  private var receivedCloseCode = -1
+
+  /** The close reason from the peer, or null if this web socket has not yet read a close frame. */
+  private var receivedCloseReason: String? = null
+
+  /** True if this web socket failed and the listener has been notified. */
+  private var failed = false
+
+  /** Total number of pings sent by this web socket. */
+  private var sentPingCount = 0
+
+  /** Total number of pings received by this web socket. */
+  private var receivedPingCount = 0
+
+  /** Total number of pongs received by this web socket. */
+  private var receivedPongCount = 0
+
+  /** True if we have sent a ping that is still awaiting a reply. */
+  private var awaitingPong = false
+
+  init {
+    require("GET" == originalRequest.method) {
+      "Request must be GET: ${originalRequest.method}"
+    }
+
+    this.key = ByteArray(16).apply { random.nextBytes(this) }.toByteString().base64()
+    this.writerRunnable = Runnable {
+      try {
+        while (writeOneFrame()) {
+        }
+      } catch (e: IOException) {
+        failWebSocket(e, null)
+      }
+    }
+  }
+
+  override fun request(): Request = originalRequest
+
+  @Synchronized override fun queueSize(): Long = queueSize
+
+  override fun cancel() {
+    call!!.cancel()
+  }
+
+  fun connect(client: OkHttpClient) {
+    val webSocketClient = client.newBuilder()
+        .eventListener(EventListener.NONE)
+        .protocols(ONLY_HTTP1)
+        .build()
+    val request = originalRequest.newBuilder()
+        .header("Upgrade", "websocket")
+        .header("Connection", "Upgrade")
+        .header("Sec-WebSocket-Key", key)
+        .header("Sec-WebSocket-Version", "13")
+        .build()
+    call = RealCall.newRealCall(webSocketClient, request, forWebSocket = true)
+    call!!.enqueue(object : Callback {
+      override fun onResponse(call: Call, response: Response) {
+        val exchange = response.exchange
+        val streams: Streams
+        try {
+          checkUpgradeSuccess(response, exchange)
+          streams = exchange!!.newWebSocketStreams()
+        } catch (e: IOException) {
+          exchange?.webSocketUpgradeFailed()
+          failWebSocket(e, response)
+          response.closeQuietly()
+          return
+        }
+
+        // Process all web socket messages.
+        try {
+          val name = "OkHttp WebSocket ${request.url.redact()}"
+          initReaderAndWriter(name, streams)
+          listener.onOpen(this@RealWebSocket, response)
+          loopReader()
+        } catch (e: Exception) {
+          failWebSocket(e, null)
+        }
+      }
+
+      override fun onFailure(call: Call, e: IOException) {
+        failWebSocket(e, null)
+      }
+    })
+  }
+
+  @Throws(IOException::class)
+  internal fun checkUpgradeSuccess(response: Response, exchange: Exchange?) {
+    if (response.code != 101) {
+      throw ProtocolException(
+          "Expected HTTP 101 response but was '${response.code} ${response.message}'")
+    }
+
+    val headerConnection = response.header("Connection")
+    if (!"Upgrade".equals(headerConnection, ignoreCase = true)) {
+      throw ProtocolException(
+          "Expected 'Connection' header value 'Upgrade' but was '$headerConnection'")
+    }
+
+    val headerUpgrade = response.header("Upgrade")
+    if (!"websocket".equals(headerUpgrade, ignoreCase = true)) {
+      throw ProtocolException(
+          "Expected 'Upgrade' header value 'websocket' but was '$headerUpgrade'")
+    }
+
+    val headerAccept = response.header("Sec-WebSocket-Accept")
+    val acceptExpected = (key + WebSocketProtocol.ACCEPT_MAGIC).encodeUtf8().sha1().base64()
+    if (acceptExpected != headerAccept) {
+      throw ProtocolException(
+          "Expected 'Sec-WebSocket-Accept' header value '$acceptExpected' but was '$headerAccept'")
+    }
+
+    if (exchange == null) {
+      throw ProtocolException("Web Socket exchange missing: bad interceptor?")
+    }
+  }
+
+  @Throws(IOException::class)
+  fun initReaderAndWriter(name: String, streams: Streams) {
+    synchronized(this) {
+      this.streams = streams
+      this.writer = WebSocketWriter(streams.client, streams.sink, random)
+      this.executor = ScheduledThreadPoolExecutor(1, threadFactory(name, false))
+      if (pingIntervalMillis != 0L) {
+        executor!!.scheduleAtFixedRate(
+            PingRunnable(), pingIntervalMillis, pingIntervalMillis, MILLISECONDS)
+      }
+      if (messageAndCloseQueue.isNotEmpty()) {
+        runWriter() // Send messages that were enqueued before we were connected.
+      }
+    }
+
+    reader = WebSocketReader(streams.client, streams.source, this)
+  }
+
+  /** Receive frames until there are no more. Invoked only by the reader thread. */
+  @Throws(IOException::class)
+  fun loopReader() {
+    while (receivedCloseCode == -1) {
+      // This method call results in one or more onRead* methods being called on this thread.
+      reader!!.processNextFrame()
+    }
+  }
+
+  /**
+   * For testing: receive a single frame and return true if there are more frames to read. Invoked
+   * only by the reader thread.
+   */
+  @Throws(IOException::class)
+  fun processNextFrame(): Boolean {
+    return try {
+      reader!!.processNextFrame()
+      receivedCloseCode == -1
+    } catch (e: Exception) {
+      failWebSocket(e, null)
+      false
+    }
+  }
+
+  /** For testing: wait until the web socket's executor has terminated. */
+  @Throws(InterruptedException::class)
+  fun awaitTermination(timeout: Int, timeUnit: TimeUnit) {
+    executor!!.awaitTermination(timeout.toLong(), timeUnit)
+  }
+
+  /** For testing: force this web socket to release its threads. */
+  @Throws(InterruptedException::class)
+  fun tearDown() {
+    if (cancelFuture != null) {
+      cancelFuture!!.cancel(false)
+    }
+    executor!!.shutdown()
+    executor!!.awaitTermination(10, TimeUnit.SECONDS)
+  }
+
+  @Synchronized fun sentPingCount(): Int = sentPingCount
+
+  @Synchronized fun receivedPingCount(): Int = receivedPingCount
+
+  @Synchronized fun receivedPongCount(): Int = receivedPongCount
+
+  @Throws(IOException::class)
+  override fun onReadMessage(text: String) {
+    listener.onMessage(this, text)
+  }
+
+  @Throws(IOException::class)
+  override fun onReadMessage(bytes: ByteString) {
+    listener.onMessage(this, bytes)
+  }
+
+  @Synchronized override fun onReadPing(payload: ByteString) {
+    // Don't respond to pings after we've failed or sent the close frame.
+    if (failed || enqueuedClose && messageAndCloseQueue.isEmpty()) return
+
+    pongQueue.add(payload)
+    runWriter()
+    receivedPingCount++
+  }
+
+  @Synchronized override fun onReadPong(payload: ByteString) {
+    // This API doesn't expose pings.
+    receivedPongCount++
+    awaitingPong = false
+  }
+
+  override fun onReadClose(code: Int, reason: String) {
+    require(code != -1)
+
+    var toClose: Streams? = null
+    synchronized(this) {
+      check(receivedCloseCode == -1) { "already closed" }
+      receivedCloseCode = code
+      receivedCloseReason = reason
+      if (enqueuedClose && messageAndCloseQueue.isEmpty()) {
+        toClose = this.streams
+        this.streams = null
+        if (cancelFuture != null) cancelFuture!!.cancel(false)
+        this.executor!!.shutdown()
+      }
+    }
+
+    try {
+      listener.onClosing(this, code, reason)
+
+      if (toClose != null) {
+        listener.onClosed(this, code, reason)
+      }
+    } finally {
+      toClose?.closeQuietly()
+    }
+  }
+
+  // Writer methods to enqueue frames. They'll be sent asynchronously by the writer thread.
+
+  override fun send(text: String): Boolean {
+    return send(text.encodeUtf8(), OPCODE_TEXT)
+  }
+
+  override fun send(bytes: ByteString): Boolean {
+    return send(bytes, OPCODE_BINARY)
+  }
+
+  @Synchronized private fun send(data: ByteString, formatOpcode: Int): Boolean {
+    // Don't send new frames after we've failed or enqueued a close frame.
+    if (failed || enqueuedClose) return false
+
+    // If this frame overflows the buffer, reject it and close the web socket.
+    if (queueSize + data.size > MAX_QUEUE_SIZE) {
+      close(CLOSE_CLIENT_GOING_AWAY, null)
+      return false
+    }
+
+    // Enqueue the message frame.
+    queueSize += data.size.toLong()
+    messageAndCloseQueue.add(Message(formatOpcode, data))
+    runWriter()
+    return true
+  }
+
+  @Synchronized fun pong(payload: ByteString): Boolean {
+    // Don't send pongs after we've failed or sent the close frame.
+    if (failed || enqueuedClose && messageAndCloseQueue.isEmpty()) return false
+
+    pongQueue.add(payload)
+    runWriter()
+    return true
+  }
+
+  override fun close(code: Int, reason: String?): Boolean {
+    return close(code, reason, CANCEL_AFTER_CLOSE_MILLIS)
+  }
+
+  @Synchronized fun close(
+    code: Int,
+    reason: String?,
+    cancelAfterCloseMillis: Long
+  ): Boolean {
+    validateCloseCode(code)
+
+    var reasonBytes: ByteString? = null
+    if (reason != null) {
+      reasonBytes = reason.encodeUtf8()
+      require(reasonBytes.size <= CLOSE_MESSAGE_MAX) {
+        "reason.size() > $CLOSE_MESSAGE_MAX: $reason"
+      }
+    }
+
+    if (failed || enqueuedClose) return false
+
+    // Immediately prevent further frames from being enqueued.
+    enqueuedClose = true
+
+    // Enqueue the close frame.
+    messageAndCloseQueue.add(Close(code, reasonBytes, cancelAfterCloseMillis))
+    runWriter()
+    return true
+  }
+
+  private fun runWriter() {
+    assert(Thread.holdsLock(this))
+    executor?.execute(writerRunnable)
+  }
+
+  /**
+   * Attempts to remove a single frame from a queue and send it. This prefers to write urgent pongs
+   * before less urgent messages and close frames. For example it's possible that a caller will
+   * enqueue messages followed by pongs, but this sends pongs followed by messages. Pongs are always
+   * written in the order they were enqueued.
+   *
+   * If a frame cannot be sent - because there are none enqueued or because the web socket is not
+   * connected - this does nothing and returns false. Otherwise this returns true and the caller
+   * should immediately invoke this method again until it returns false.
+   *
+   * This method may only be invoked by the writer thread. There may be only thread invoking this
+   * method at a time.
+   */
+  @Throws(IOException::class)
+  internal fun writeOneFrame(): Boolean {
+    val writer: WebSocketWriter?
+    val pong: ByteString?
+    var messageOrClose: Any? = null
+    var receivedCloseCode = -1
+    var receivedCloseReason: String? = null
+    var streamsToClose: Streams? = null
+
+    synchronized(this@RealWebSocket) {
+      if (failed) {
+        return false // Failed web socket.
+      }
+
+      writer = this.writer
+      pong = pongQueue.poll()
+      if (pong == null) {
+        messageOrClose = messageAndCloseQueue.poll()
+        if (messageOrClose is Close) {
+          receivedCloseCode = this.receivedCloseCode
+          receivedCloseReason = this.receivedCloseReason
+          if (receivedCloseCode != -1) {
+            streamsToClose = this.streams
+            this.streams = null
+            this.executor!!.shutdown()
+          } else {
+            // When we request a graceful close also schedule a cancel of the web socket.
+            cancelFuture = executor!!.schedule(CancelRunnable(),
+                (messageOrClose as Close).cancelAfterCloseMillis, MILLISECONDS)
+          }
+        } else if (messageOrClose == null) {
+          return false // The queue is exhausted.
+        }
+      }
+    }
+
+    try {
+      if (pong != null) {
+        writer!!.writePong(pong)
+      } else if (messageOrClose is Message) {
+        val data = (messageOrClose as Message).data
+        val sink = writer!!.newMessageSink(
+            (messageOrClose as Message).formatOpcode, data.size.toLong()).buffer()
+        sink.write(data)
+        sink.close()
+        synchronized(this) {
+          queueSize -= data.size.toLong()
+        }
+      } else if (messageOrClose is Close) {
+        val close = messageOrClose as Close
+        writer!!.writeClose(close.code, close.reason)
+
+        // We closed the writer: now both reader and writer are closed.
+        if (streamsToClose != null) {
+          listener.onClosed(this, receivedCloseCode, receivedCloseReason!!)
+        }
+      } else {
+        throw AssertionError()
+      }
+
+      return true
+    } finally {
+      streamsToClose?.closeQuietly()
+    }
+  }
+
+  private inner class PingRunnable : Runnable {
+    override fun run() {
+      writePingFrame()
+    }
+  }
+
+  internal fun writePingFrame() {
+    val writer: WebSocketWriter?
+    val failedPing: Int
+    synchronized(this) {
+      if (failed) return
+      writer = this.writer
+      failedPing = if (awaitingPong) sentPingCount else -1
+      sentPingCount++
+      awaitingPong = true
+    }
+
+    if (failedPing != -1) {
+      failWebSocket(SocketTimeoutException("sent ping but didn't receive pong within " +
+          "${pingIntervalMillis}ms (after ${failedPing - 1} successful ping/pongs)"), null)
+      return
+    }
+
+    try {
+      writer!!.writePing(ByteString.EMPTY)
+    } catch (e: IOException) {
+      failWebSocket(e, null)
+    }
+  }
+
+  fun failWebSocket(e: Exception, response: Response?) {
+    val streamsToClose: Streams?
+    synchronized(this) {
+      if (failed) return // Already failed.
+      failed = true
+      streamsToClose = this.streams
+      this.streams = null
+      cancelFuture?.cancel(false)
+      executor?.shutdown()
+    }
+
+    try {
+      listener.onFailure(this, e, response)
+    } finally {
+      streamsToClose?.closeQuietly()
+    }
+  }
+
+  internal class Message(
+    val formatOpcode: Int,
+    val data: ByteString
+  )
+
+  internal class Close(
+    val code: Int,
+    val reason: ByteString?,
+    val cancelAfterCloseMillis: Long
+  )
+
+  abstract class Streams(
+    val client: Boolean,
+    val source: BufferedSource,
+    val sink: BufferedSink
+  ) : Closeable
+
+  internal inner class CancelRunnable : Runnable {
+    override fun run() {
+      cancel()
+    }
+  }
+
+  companion object {
+    private val ONLY_HTTP1 = listOf(Protocol.HTTP_1_1)
+
+    /**
+     * The maximum number of bytes to enqueue. Rather than enqueueing beyond this limit we tear down
+     * the web socket! It's possible that we're writing faster than the peer can read.
+     */
+    private const val MAX_QUEUE_SIZE = 16L * 1024 * 1024 // 16 MiB.
+
+    /**
+     * The maximum amount of time after the client calls [close] to wait for a graceful shutdown. If
+     * the server doesn't respond the web socket will be canceled.
+     */
+    private const val CANCEL_AFTER_CLOSE_MILLIS = 60L * 1000
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.kt b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.kt
index f379aee7c3..58bdda788d 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.kt
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.kt
@@ -19,7 +19,7 @@ import okio.Buffer
 import okio.ByteString.Companion.encodeUtf8
 
 object WebSocketProtocol {
-  /** Magic value which must be appended to the key in a response header.  */
+  /** Magic value which must be appended to the key in a response header. */
   internal const val ACCEPT_MAGIC = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
 
   /*
@@ -34,17 +34,17 @@ object WebSocketProtocol {
   +-+-+-+-+-------+  +-+-------------+
   */
 
-  /** Byte 0 flag for whether this is the final fragment in a message.  */
+  /** Byte 0 flag for whether this is the final fragment in a message. */
   internal const val B0_FLAG_FIN = 128
-  /** Byte 0 reserved flag 1. Must be 0 unless negotiated otherwise.  */
+  /** Byte 0 reserved flag 1. Must be 0 unless negotiated otherwise. */
   internal const val B0_FLAG_RSV1 = 64
-  /** Byte 0 reserved flag 2. Must be 0 unless negotiated otherwise.  */
+  /** Byte 0 reserved flag 2. Must be 0 unless negotiated otherwise. */
   internal const val B0_FLAG_RSV2 = 32
-  /** Byte 0 reserved flag 3. Must be 0 unless negotiated otherwise.  */
+  /** Byte 0 reserved flag 3. Must be 0 unless negotiated otherwise. */
   internal const val B0_FLAG_RSV3 = 16
-  /** Byte 0 mask for the frame opcode.  */
+  /** Byte 0 mask for the frame opcode. */
   internal const val B0_MASK_OPCODE = 15
-  /** Flag in the opcode which indicates a control frame.  */
+  /** Flag in the opcode which indicates a control frame. */
   internal const val OPCODE_FLAG_CONTROL = 8
 
   /**
@@ -76,13 +76,13 @@ object WebSocketProtocol {
    * special values [PAYLOAD_SHORT] or [PAYLOAD_LONG].
    */
   internal const val PAYLOAD_BYTE_MAX = 125L
-  /** Maximum length of close message in bytes.  */
+  /** Maximum length of close message in bytes. */
   internal const val CLOSE_MESSAGE_MAX = PAYLOAD_BYTE_MAX - 2
   /**
    * Value for [B1_MASK_LENGTH] which indicates the next two bytes are the unsigned length.
    */
   internal const val PAYLOAD_SHORT = 126
-  /** Maximum length of a frame payload to be denoted as [PAYLOAD_SHORT].  */
+  /** Maximum length of a frame payload to be denoted as [PAYLOAD_SHORT]. */
   internal const val PAYLOAD_SHORT_MAX = 0xffffL
   /**
    * Value for [B1_MASK_LENGTH] which indicates the next eight bytes are the unsigned
@@ -90,12 +90,11 @@ object WebSocketProtocol {
    */
   internal const val PAYLOAD_LONG = 127
 
-  /** Used when an unchecked exception was thrown in a listener.  */
+  /** Used when an unchecked exception was thrown in a listener. */
   internal const val CLOSE_CLIENT_GOING_AWAY = 1001
-  /** Used when an empty close frame was received (i.e., without a status code).  */
+  /** Used when an empty close frame was received (i.e., without a status code). */
   internal const val CLOSE_NO_STATUS_CODE = 1005
 
-  @JvmStatic
   fun toggleMask(cursor: Buffer.UnsafeCursor, key: ByteArray) {
     var keyIndex = 0
     val keyLength = key.size
@@ -120,27 +119,22 @@ object WebSocketProtocol {
     } while (cursor.next() != -1)
   }
 
-  @JvmStatic
   fun closeCodeExceptionMessage(code: Int): String? {
     return if (code < 1000 || code >= 5000) {
       "Code must be in range [1000,5000): $code"
-    } else if (code in 1004..1006 || code in 1012..2999) {
+    } else if (code in 1004..1006 || code in 1015..2999) {
       "Code $code is reserved and may not be used."
     } else {
       null
     }
   }
 
-  @JvmStatic
   fun validateCloseCode(code: Int) {
     val message = closeCodeExceptionMessage(code)
-    if (message != null) {
-      throw IllegalArgumentException(message)
-    }
+    require(message == null) { message!! }
   }
 
-  @JvmStatic
   fun acceptHeader(key: String): String {
-    return (key + WebSocketProtocol.ACCEPT_MAGIC).encodeUtf8().sha1().base64()
+    return (key + ACCEPT_MAGIC).encodeUtf8().sha1().base64()
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
deleted file mode 100644
index 6d5d22e67d..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
+++ /dev/null
@@ -1,264 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.concurrent.TimeUnit;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-
-import static java.lang.Integer.toHexString;
-import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
-import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV1;
-import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV2;
-import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV3;
-import static okhttp3.internal.ws.WebSocketProtocol.B0_MASK_OPCODE;
-import static okhttp3.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
-import static okhttp3.internal.ws.WebSocketProtocol.B1_MASK_LENGTH;
-import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_NO_STATUS_CODE;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_FLAG_CONTROL;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
-import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
-
-/**
- * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame reader.
- *
- * <p>This class is not thread safe.
- */
-final class WebSocketReader {
-  public interface FrameCallback {
-    void onReadMessage(String text) throws IOException;
-    void onReadMessage(ByteString bytes) throws IOException;
-    void onReadPing(ByteString buffer);
-    void onReadPong(ByteString buffer);
-    void onReadClose(int code, String reason);
-  }
-
-  final boolean isClient;
-  final BufferedSource source;
-  final FrameCallback frameCallback;
-
-  boolean closed;
-
-  // Stateful data about the current frame.
-  int opcode;
-  long frameLength;
-  boolean isFinalFrame;
-  boolean isControlFrame;
-
-  private final Buffer controlFrameBuffer = new Buffer();
-  private final Buffer messageFrameBuffer = new Buffer();
-
-  private final byte[] maskKey;
-  private final Buffer.UnsafeCursor maskCursor;
-
-  WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
-    if (source == null) throw new NullPointerException("source == null");
-    if (frameCallback == null) throw new NullPointerException("frameCallback == null");
-    this.isClient = isClient;
-    this.source = source;
-    this.frameCallback = frameCallback;
-
-    // Masks are only a concern for server writers.
-    maskKey = isClient ? null : new byte[4];
-    maskCursor = isClient ? null : new Buffer.UnsafeCursor();
-  }
-
-  /**
-   * Process the next protocol frame.
-   *
-   * <ul>
-   *     <li>If it is a control frame this will result in a single call to {@link FrameCallback}.
-   *     <li>If it is a message frame this will result in a single call to {@link
-   *         FrameCallback#onReadMessage}. If the message spans multiple frames, each interleaved
-   *         control frame will result in a corresponding call to {@link FrameCallback}.
-   * </ul>
-   */
-  void processNextFrame() throws IOException {
-    readHeader();
-    if (isControlFrame) {
-      readControlFrame();
-    } else {
-      readMessageFrame();
-    }
-  }
-
-  private void readHeader() throws IOException {
-    if (closed) throw new IOException("closed");
-
-    // Disable the timeout to read the first byte of a new frame.
-    int b0;
-    long timeoutBefore = source.timeout().timeoutNanos();
-    source.timeout().clearTimeout();
-    try {
-      b0 = source.readByte() & 0xff;
-    } finally {
-      source.timeout().timeout(timeoutBefore, TimeUnit.NANOSECONDS);
-    }
-
-    opcode = b0 & B0_MASK_OPCODE;
-    isFinalFrame = (b0 & B0_FLAG_FIN) != 0;
-    isControlFrame = (b0 & OPCODE_FLAG_CONTROL) != 0;
-
-    // Control frames must be final frames (cannot contain continuations).
-    if (isControlFrame && !isFinalFrame) {
-      throw new ProtocolException("Control frames must be final.");
-    }
-
-    boolean reservedFlag1 = (b0 & B0_FLAG_RSV1) != 0;
-    boolean reservedFlag2 = (b0 & B0_FLAG_RSV2) != 0;
-    boolean reservedFlag3 = (b0 & B0_FLAG_RSV3) != 0;
-    if (reservedFlag1 || reservedFlag2 || reservedFlag3) {
-      // Reserved flags are for extensions which we currently do not support.
-      throw new ProtocolException("Reserved flags are unsupported.");
-    }
-
-    int b1 = source.readByte() & 0xff;
-
-    boolean isMasked = (b1 & B1_FLAG_MASK) != 0;
-    if (isMasked == isClient) {
-      // Masked payloads must be read on the server. Unmasked payloads must be read on the client.
-      throw new ProtocolException(isClient
-          ? "Server-sent frames must not be masked."
-          : "Client-sent frames must be masked.");
-    }
-
-    // Get frame length, optionally reading from follow-up bytes if indicated by special values.
-    frameLength = b1 & B1_MASK_LENGTH;
-    if (frameLength == PAYLOAD_SHORT) {
-      frameLength = source.readShort() & 0xffffL; // Value is unsigned.
-    } else if (frameLength == PAYLOAD_LONG) {
-      frameLength = source.readLong();
-      if (frameLength < 0) {
-        throw new ProtocolException(
-            "Frame length 0x" + Long.toHexString(frameLength) + " > 0x7FFFFFFFFFFFFFFF");
-      }
-    }
-
-    if (isControlFrame && frameLength > PAYLOAD_BYTE_MAX) {
-      throw new ProtocolException("Control frame must be less than " + PAYLOAD_BYTE_MAX + "B.");
-    }
-
-    if (isMasked) {
-      // Read the masking key as bytes so that they can be used directly for unmasking.
-      source.readFully(maskKey);
-    }
-  }
-
-  private void readControlFrame() throws IOException {
-    if (frameLength > 0) {
-      source.readFully(controlFrameBuffer, frameLength);
-
-      if (!isClient) {
-        controlFrameBuffer.readAndWriteUnsafe(maskCursor);
-        maskCursor.seek(0);
-        toggleMask(maskCursor, maskKey);
-        maskCursor.close();
-      }
-    }
-
-    switch (opcode) {
-      case OPCODE_CONTROL_PING:
-        frameCallback.onReadPing(controlFrameBuffer.readByteString());
-        break;
-      case OPCODE_CONTROL_PONG:
-        frameCallback.onReadPong(controlFrameBuffer.readByteString());
-        break;
-      case OPCODE_CONTROL_CLOSE:
-        int code = CLOSE_NO_STATUS_CODE;
-        String reason = "";
-        long bufferSize = controlFrameBuffer.size();
-        if (bufferSize == 1) {
-          throw new ProtocolException("Malformed close payload length of 1.");
-        } else if (bufferSize != 0) {
-          code = controlFrameBuffer.readShort();
-          reason = controlFrameBuffer.readUtf8();
-          String codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code);
-          if (codeExceptionMessage != null) throw new ProtocolException(codeExceptionMessage);
-        }
-        frameCallback.onReadClose(code, reason);
-        closed = true;
-        break;
-      default:
-        throw new ProtocolException("Unknown control opcode: " + toHexString(opcode));
-    }
-  }
-
-  private void readMessageFrame() throws IOException {
-    int opcode = this.opcode;
-    if (opcode != OPCODE_TEXT && opcode != OPCODE_BINARY) {
-      throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
-    }
-
-    readMessage();
-
-    if (opcode == OPCODE_TEXT) {
-      frameCallback.onReadMessage(messageFrameBuffer.readUtf8());
-    } else {
-      frameCallback.onReadMessage(messageFrameBuffer.readByteString());
-    }
-  }
-
-  /** Read headers and process any control frames until we reach a non-control frame. */
-  private void readUntilNonControlFrame() throws IOException {
-    while (!closed) {
-      readHeader();
-      if (!isControlFrame) {
-        break;
-      }
-      readControlFrame();
-    }
-  }
-
-  /**
-   * Reads a message body into across one or more frames. Control frames that occur between
-   * fragments will be processed. If the message payload is masked this will unmask as it's being
-   * processed.
-   */
-  private void readMessage() throws IOException {
-    while (true) {
-      if (closed) throw new IOException("closed");
-
-      if (frameLength > 0) {
-        source.readFully(messageFrameBuffer, frameLength);
-
-        if (!isClient) {
-          messageFrameBuffer.readAndWriteUnsafe(maskCursor);
-          maskCursor.seek(messageFrameBuffer.size() - frameLength);
-          toggleMask(maskCursor, maskKey);
-          maskCursor.close();
-        }
-      }
-
-      if (isFinalFrame) break; // We are exhausted and have no continuations.
-
-      readUntilNonControlFrame();
-      if (opcode != OPCODE_CONTINUATION) {
-        throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
-      }
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.kt b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.kt
new file mode 100644
index 0000000000..17abe3dcdd
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.kt
@@ -0,0 +1,267 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws
+
+import okhttp3.internal.and
+import okhttp3.internal.toHexString
+import okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN
+import okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV1
+import okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV2
+import okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV3
+import okhttp3.internal.ws.WebSocketProtocol.B0_MASK_OPCODE
+import okhttp3.internal.ws.WebSocketProtocol.B1_FLAG_MASK
+import okhttp3.internal.ws.WebSocketProtocol.B1_MASK_LENGTH
+import okhttp3.internal.ws.WebSocketProtocol.CLOSE_NO_STATUS_CODE
+import okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY
+import okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION
+import okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE
+import okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING
+import okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG
+import okhttp3.internal.ws.WebSocketProtocol.OPCODE_FLAG_CONTROL
+import okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT
+import okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX
+import okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG
+import okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT
+import okhttp3.internal.ws.WebSocketProtocol.toggleMask
+import okio.Buffer
+import okio.BufferedSource
+import okio.ByteString
+import java.io.IOException
+import java.net.ProtocolException
+import java.util.concurrent.TimeUnit
+
+/**
+ * An [RFC 6455][rfc_6455]-compatible WebSocket frame reader.
+ *
+ * This class is not thread safe.
+ *
+ * [rfc_6455]: http://tools.ietf.org/html/rfc6455
+ */
+internal class WebSocketReader(
+  private val isClient: Boolean,
+  val source: BufferedSource,
+  private val frameCallback: FrameCallback
+) {
+
+  var closed = false
+
+  // Stateful data about the current frame.
+  private var opcode = 0
+  private var frameLength = 0L
+  private var isFinalFrame = false
+  private var isControlFrame = false
+
+  private val controlFrameBuffer = Buffer()
+  private val messageFrameBuffer = Buffer()
+
+  // Masks are only a concern for server writers.
+  private val maskKey: ByteArray? = if (isClient) null else ByteArray(4)
+  private val maskCursor: Buffer.UnsafeCursor? = if (isClient) null else Buffer.UnsafeCursor()
+
+  interface FrameCallback {
+    @Throws(IOException::class)
+    fun onReadMessage(text: String)
+
+    @Throws(IOException::class)
+    fun onReadMessage(bytes: ByteString)
+
+    fun onReadPing(payload: ByteString)
+    fun onReadPong(payload: ByteString)
+    fun onReadClose(code: Int, reason: String)
+  }
+
+  /**
+   * Process the next protocol frame.
+   *
+   *  * If it is a control frame this will result in a single call to [FrameCallback].
+   *  * If it is a message frame this will result in a single call to [FrameCallback.onReadMessage].
+   *    If the message spans multiple frames, each interleaved control frame will result in a
+   *    corresponding call to [FrameCallback].
+   */
+  @Throws(IOException::class)
+  fun processNextFrame() {
+    readHeader()
+    if (isControlFrame) {
+      readControlFrame()
+    } else {
+      readMessageFrame()
+    }
+  }
+
+  @Throws(IOException::class, ProtocolException::class)
+  private fun readHeader() {
+    if (closed) throw IOException("closed")
+
+    // Disable the timeout to read the first byte of a new frame.
+    val b0: Int
+    val timeoutBefore = source.timeout().timeoutNanos()
+    source.timeout().clearTimeout()
+    try {
+      b0 = source.readByte() and 0xff
+    } finally {
+      source.timeout().timeout(timeoutBefore, TimeUnit.NANOSECONDS)
+    }
+
+    opcode = b0 and B0_MASK_OPCODE
+    isFinalFrame = b0 and B0_FLAG_FIN != 0
+    isControlFrame = b0 and OPCODE_FLAG_CONTROL != 0
+
+    // Control frames must be final frames (cannot contain continuations).
+    if (isControlFrame && !isFinalFrame) {
+      throw ProtocolException("Control frames must be final.")
+    }
+
+    val reservedFlag1 = b0 and B0_FLAG_RSV1 != 0
+    val reservedFlag2 = b0 and B0_FLAG_RSV2 != 0
+    val reservedFlag3 = b0 and B0_FLAG_RSV3 != 0
+    if (reservedFlag1 || reservedFlag2 || reservedFlag3) {
+      // Reserved flags are for extensions which we currently do not support.
+      throw ProtocolException("Reserved flags are unsupported.")
+    }
+
+    val b1 = source.readByte() and 0xff
+
+    val isMasked = b1 and B1_FLAG_MASK != 0
+    if (isMasked == isClient) {
+      // Masked payloads must be read on the server. Unmasked payloads must be read on the client.
+      throw ProtocolException(if (isClient) {
+        "Server-sent frames must not be masked."
+      } else {
+        "Client-sent frames must be masked."
+      })
+    }
+
+    // Get frame length, optionally reading from follow-up bytes if indicated by special values.
+    frameLength = (b1 and B1_MASK_LENGTH).toLong()
+    if (frameLength == PAYLOAD_SHORT.toLong()) {
+      frameLength = (source.readShort() and 0xffff).toLong() // Value is unsigned.
+    } else if (frameLength == PAYLOAD_LONG.toLong()) {
+      frameLength = source.readLong()
+      if (frameLength < 0L) {
+        throw ProtocolException(
+            "Frame length 0x${frameLength.toHexString()} > 0x7FFFFFFFFFFFFFFF")
+      }
+    }
+
+    if (isControlFrame && frameLength > PAYLOAD_BYTE_MAX) {
+      throw ProtocolException("Control frame must be less than ${PAYLOAD_BYTE_MAX}B.")
+    }
+
+    if (isMasked) {
+      // Read the masking key as bytes so that they can be used directly for unmasking.
+      source.readFully(maskKey!!)
+    }
+  }
+
+  @Throws(IOException::class)
+  private fun readControlFrame() {
+    if (frameLength > 0L) {
+      source.readFully(controlFrameBuffer, frameLength)
+
+      if (!isClient) {
+        controlFrameBuffer.readAndWriteUnsafe(maskCursor!!)
+        maskCursor.seek(0)
+        toggleMask(maskCursor, maskKey!!)
+        maskCursor.close()
+      }
+    }
+
+    when (opcode) {
+      OPCODE_CONTROL_PING -> {
+        frameCallback.onReadPing(controlFrameBuffer.readByteString())
+      }
+      OPCODE_CONTROL_PONG -> {
+        frameCallback.onReadPong(controlFrameBuffer.readByteString())
+      }
+      OPCODE_CONTROL_CLOSE -> {
+        var code = CLOSE_NO_STATUS_CODE
+        var reason = ""
+        val bufferSize = controlFrameBuffer.size
+        if (bufferSize == 1L) {
+          throw ProtocolException("Malformed close payload length of 1.")
+        } else if (bufferSize != 0L) {
+          code = controlFrameBuffer.readShort().toInt()
+          reason = controlFrameBuffer.readUtf8()
+          val codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code)
+          if (codeExceptionMessage != null) throw ProtocolException(codeExceptionMessage)
+        }
+        frameCallback.onReadClose(code, reason)
+        closed = true
+      }
+      else -> {
+        throw ProtocolException("Unknown control opcode: " + opcode.toHexString())
+      }
+    }
+  }
+
+  @Throws(IOException::class)
+  private fun readMessageFrame() {
+    val opcode = this.opcode
+    if (opcode != OPCODE_TEXT && opcode != OPCODE_BINARY) {
+      throw ProtocolException("Unknown opcode: ${opcode.toHexString()}")
+    }
+
+    readMessage()
+
+    if (opcode == OPCODE_TEXT) {
+      frameCallback.onReadMessage(messageFrameBuffer.readUtf8())
+    } else {
+      frameCallback.onReadMessage(messageFrameBuffer.readByteString())
+    }
+  }
+
+  /** Read headers and process any control frames until we reach a non-control frame. */
+  @Throws(IOException::class)
+  private fun readUntilNonControlFrame() {
+    while (!closed) {
+      readHeader()
+      if (!isControlFrame) {
+        break
+      }
+      readControlFrame()
+    }
+  }
+
+  /**
+   * Reads a message body into across one or more frames. Control frames that occur between
+   * fragments will be processed. If the message payload is masked this will unmask as it's being
+   * processed.
+   */
+  @Throws(IOException::class)
+  private fun readMessage() {
+    while (true) {
+      if (closed) throw IOException("closed")
+
+      if (frameLength > 0L) {
+        source.readFully(messageFrameBuffer, frameLength)
+
+        if (!isClient) {
+          messageFrameBuffer.readAndWriteUnsafe(maskCursor!!)
+          maskCursor.seek(messageFrameBuffer.size - frameLength)
+          toggleMask(maskCursor, maskKey!!)
+          maskCursor.close()
+        }
+      }
+
+      if (isFinalFrame) break // We are exhausted and have no continuations.
+
+      readUntilNonControlFrame()
+      if (opcode != OPCODE_CONTINUATION) {
+        throw ProtocolException("Expected continuation opcode. Got: ${opcode.toHexString()}")
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
deleted file mode 100644
index bbd63b3507..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
+++ /dev/null
@@ -1,257 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.IOException;
-import java.util.Random;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-import okio.Sink;
-import okio.Timeout;
-
-import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
-import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
-import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
-import static okhttp3.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
-
-/**
- * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
- *
- * <p>This class is not thread safe.
- */
-final class WebSocketWriter {
-  final boolean isClient;
-  final Random random;
-
-  final BufferedSink sink;
-  /** The {@link Buffer} of {@link #sink}. Write to this and then flush/emit {@link #sink}. */
-  final Buffer sinkBuffer;
-  boolean writerClosed;
-
-  final Buffer buffer = new Buffer();
-  final FrameSink frameSink = new FrameSink();
-
-  boolean activeWriter;
-
-  private final byte[] maskKey;
-  private final Buffer.UnsafeCursor maskCursor;
-
-  WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
-    if (sink == null) throw new NullPointerException("sink == null");
-    if (random == null) throw new NullPointerException("random == null");
-    this.isClient = isClient;
-    this.sink = sink;
-    this.sinkBuffer = sink.buffer();
-    this.random = random;
-
-    // Masks are only a concern for client writers.
-    maskKey = isClient ? new byte[4] : null;
-    maskCursor = isClient ? new Buffer.UnsafeCursor() : null;
-  }
-
-  /** Send a ping with the supplied {@code payload}. */
-  void writePing(ByteString payload) throws IOException {
-    writeControlFrame(OPCODE_CONTROL_PING, payload);
-  }
-
-  /** Send a pong with the supplied {@code payload}. */
-  void writePong(ByteString payload) throws IOException {
-    writeControlFrame(OPCODE_CONTROL_PONG, payload);
-  }
-
-  /**
-   * Send a close frame with optional code and reason.
-   *
-   * @param code Status code as defined by <a
-   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
-   * @param reason Reason for shutting down or {@code null}.
-   */
-  void writeClose(int code, ByteString reason) throws IOException {
-    ByteString payload = ByteString.EMPTY;
-    if (code != 0 || reason != null) {
-      if (code != 0) {
-        validateCloseCode(code);
-      }
-      Buffer buffer = new Buffer();
-      buffer.writeShort(code);
-      if (reason != null) {
-        buffer.write(reason);
-      }
-      payload = buffer.readByteString();
-    }
-
-    try {
-      writeControlFrame(OPCODE_CONTROL_CLOSE, payload);
-    } finally {
-      writerClosed = true;
-    }
-  }
-
-  private void writeControlFrame(int opcode, ByteString payload) throws IOException {
-    if (writerClosed) throw new IOException("closed");
-
-    int length = payload.size();
-    if (length > PAYLOAD_BYTE_MAX) {
-      throw new IllegalArgumentException(
-          "Payload size must be less than or equal to " + PAYLOAD_BYTE_MAX);
-    }
-
-    int b0 = B0_FLAG_FIN | opcode;
-    sinkBuffer.writeByte(b0);
-
-    int b1 = length;
-    if (isClient) {
-      b1 |= B1_FLAG_MASK;
-      sinkBuffer.writeByte(b1);
-
-      random.nextBytes(maskKey);
-      sinkBuffer.write(maskKey);
-
-      if (length > 0) {
-        long payloadStart = sinkBuffer.size();
-        sinkBuffer.write(payload);
-
-        sinkBuffer.readAndWriteUnsafe(maskCursor);
-        maskCursor.seek(payloadStart);
-        toggleMask(maskCursor, maskKey);
-        maskCursor.close();
-      }
-    } else {
-      sinkBuffer.writeByte(b1);
-      sinkBuffer.write(payload);
-    }
-
-    sink.flush();
-  }
-
-  /**
-   * Stream a message payload as a series of frames. This allows control frames to be interleaved
-   * between parts of the message.
-   */
-  Sink newMessageSink(int formatOpcode, long contentLength) {
-    if (activeWriter) {
-      throw new IllegalStateException("Another message writer is active. Did you call close()?");
-    }
-    activeWriter = true;
-
-    // Reset FrameSink state for a new writer.
-    frameSink.formatOpcode = formatOpcode;
-    frameSink.contentLength = contentLength;
-    frameSink.isFirstFrame = true;
-    frameSink.closed = false;
-
-    return frameSink;
-  }
-
-  void writeMessageFrame(int formatOpcode, long byteCount, boolean isFirstFrame,
-      boolean isFinal) throws IOException {
-    if (writerClosed) throw new IOException("closed");
-
-    int b0 = isFirstFrame ? formatOpcode : OPCODE_CONTINUATION;
-    if (isFinal) {
-      b0 |= B0_FLAG_FIN;
-    }
-    sinkBuffer.writeByte(b0);
-
-    int b1 = 0;
-    if (isClient) {
-      b1 |= B1_FLAG_MASK;
-    }
-    if (byteCount <= PAYLOAD_BYTE_MAX) {
-      b1 |= (int) byteCount;
-      sinkBuffer.writeByte(b1);
-    } else if (byteCount <= PAYLOAD_SHORT_MAX) {
-      b1 |= PAYLOAD_SHORT;
-      sinkBuffer.writeByte(b1);
-      sinkBuffer.writeShort((int) byteCount);
-    } else {
-      b1 |= PAYLOAD_LONG;
-      sinkBuffer.writeByte(b1);
-      sinkBuffer.writeLong(byteCount);
-    }
-
-    if (isClient) {
-      random.nextBytes(maskKey);
-      sinkBuffer.write(maskKey);
-
-      if (byteCount > 0) {
-        long bufferStart = sinkBuffer.size();
-        sinkBuffer.write(buffer, byteCount);
-
-        sinkBuffer.readAndWriteUnsafe(maskCursor);
-        maskCursor.seek(bufferStart);
-        toggleMask(maskCursor, maskKey);
-        maskCursor.close();
-      }
-    } else {
-      sinkBuffer.write(buffer, byteCount);
-    }
-
-    sink.emit();
-  }
-
-  final class FrameSink implements Sink {
-    int formatOpcode;
-    long contentLength;
-    boolean isFirstFrame;
-    boolean closed;
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (closed) throw new IOException("closed");
-
-      buffer.write(source, byteCount);
-
-      // Determine if this is a buffered write which we can defer until close() flushes.
-      boolean deferWrite = isFirstFrame
-          && contentLength != -1
-          && buffer.size() > contentLength - 8192 /* segment size */;
-
-      long emitCount = buffer.completeSegmentByteCount();
-      if (emitCount > 0 && !deferWrite) {
-        writeMessageFrame(formatOpcode, emitCount, isFirstFrame, false /* final */);
-        isFirstFrame = false;
-      }
-    }
-
-    @Override public void flush() throws IOException {
-      if (closed) throw new IOException("closed");
-
-      writeMessageFrame(formatOpcode, buffer.size(), isFirstFrame, false /* final */);
-      isFirstFrame = false;
-    }
-
-    @Override public Timeout timeout() {
-      return sink.timeout();
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) throw new IOException("closed");
-
-      writeMessageFrame(formatOpcode, buffer.size(), isFirstFrame, true /* final */);
-      closed = true;
-      activeWriter = false;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.kt b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.kt
new file mode 100644
index 0000000000..60d88210dd
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.kt
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws
+
+import okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN
+import okhttp3.internal.ws.WebSocketProtocol.B1_FLAG_MASK
+import okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION
+import okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE
+import okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PING
+import okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_PONG
+import okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX
+import okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG
+import okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT
+import okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX
+import okhttp3.internal.ws.WebSocketProtocol.toggleMask
+import okhttp3.internal.ws.WebSocketProtocol.validateCloseCode
+import okio.Buffer
+import okio.BufferedSink
+import okio.ByteString
+import okio.Sink
+import okio.Timeout
+import java.io.IOException
+import java.util.Random
+
+/**
+ * An [RFC 6455][rfc_6455]-compatible WebSocket frame writer.
+ *
+ * This class is not thread safe.
+ *
+ * [rfc_6455]: http://tools.ietf.org/html/rfc6455
+ */
+internal class WebSocketWriter(
+  private val isClient: Boolean,
+  val sink: BufferedSink,
+  val random: Random
+) {
+
+  /** The [Buffer] of [sink]. Write to this and then flush/emit [sink]. */
+  private val sinkBuffer: Buffer = sink.buffer
+  private var writerClosed = false
+
+  val buffer = Buffer()
+  private val frameSink = FrameSink()
+
+  var activeWriter: Boolean = false
+
+  // Masks are only a concern for client writers.
+  private val maskKey: ByteArray? = if (isClient) ByteArray(4) else null
+  private val maskCursor: Buffer.UnsafeCursor? = if (isClient) Buffer.UnsafeCursor() else null
+
+  /** Send a ping with the supplied [payload]. */
+  @Throws(IOException::class)
+  fun writePing(payload: ByteString) {
+    writeControlFrame(OPCODE_CONTROL_PING, payload)
+  }
+
+  /** Send a pong with the supplied [payload]. */
+  @Throws(IOException::class)
+  fun writePong(payload: ByteString) {
+    writeControlFrame(OPCODE_CONTROL_PONG, payload)
+  }
+
+  /**
+   * Send a close frame with optional code and reason.
+   *
+   * @param code Status code as defined by
+   *     [Section 7.4 of RFC 6455](http://tools.ietf.org/html/rfc6455#section-7.4) or `0`.
+   * @param reason Reason for shutting down or `null`.
+   */
+  @Throws(IOException::class)
+  fun writeClose(code: Int, reason: ByteString?) {
+    var payload = ByteString.EMPTY
+    if (code != 0 || reason != null) {
+      if (code != 0) {
+        validateCloseCode(code)
+      }
+      payload = Buffer().run {
+        writeShort(code)
+        if (reason != null) {
+          write(reason)
+        }
+        readByteString()
+      }
+    }
+
+    try {
+      writeControlFrame(OPCODE_CONTROL_CLOSE, payload)
+    } finally {
+      writerClosed = true
+    }
+  }
+
+  @Throws(IOException::class)
+  private fun writeControlFrame(opcode: Int, payload: ByteString) {
+    if (writerClosed) throw IOException("closed")
+
+    val length = payload.size
+    require(length <= PAYLOAD_BYTE_MAX) {
+      "Payload size must be less than or equal to $PAYLOAD_BYTE_MAX"
+    }
+
+    val b0 = B0_FLAG_FIN or opcode
+    sinkBuffer.writeByte(b0)
+
+    var b1 = length
+    if (isClient) {
+      b1 = b1 or B1_FLAG_MASK
+      sinkBuffer.writeByte(b1)
+
+      random.nextBytes(maskKey!!)
+      sinkBuffer.write(maskKey)
+
+      if (length > 0) {
+        val payloadStart = sinkBuffer.size
+        sinkBuffer.write(payload)
+
+        sinkBuffer.readAndWriteUnsafe(maskCursor!!)
+        maskCursor.seek(payloadStart)
+        toggleMask(maskCursor, maskKey)
+        maskCursor.close()
+      }
+    } else {
+      sinkBuffer.writeByte(b1)
+      sinkBuffer.write(payload)
+    }
+
+    sink.flush()
+  }
+
+  /**
+   * Stream a message payload as a series of frames. This allows control frames to be interleaved
+   * between parts of the message.
+   */
+  fun newMessageSink(formatOpcode: Int, contentLength: Long): Sink {
+    check(!activeWriter) { "Another message writer is active. Did you call close()?" }
+    activeWriter = true
+
+    // Reset FrameSink state for a new writer.
+    frameSink.formatOpcode = formatOpcode
+    frameSink.contentLength = contentLength
+    frameSink.isFirstFrame = true
+    frameSink.closed = false
+
+    return frameSink
+  }
+
+  @Throws(IOException::class)
+  fun writeMessageFrame(
+    formatOpcode: Int,
+    byteCount: Long,
+    isFirstFrame: Boolean,
+    isFinal: Boolean
+  ) {
+    if (writerClosed) throw IOException("closed")
+
+    var b0 = if (isFirstFrame) formatOpcode else OPCODE_CONTINUATION
+    if (isFinal) {
+      b0 = b0 or B0_FLAG_FIN
+    }
+    sinkBuffer.writeByte(b0)
+
+    var b1 = 0
+    if (isClient) {
+      b1 = b1 or B1_FLAG_MASK
+    }
+    when {
+      byteCount <= PAYLOAD_BYTE_MAX -> {
+        b1 = b1 or byteCount.toInt()
+        sinkBuffer.writeByte(b1)
+      }
+      byteCount <= PAYLOAD_SHORT_MAX -> {
+        b1 = b1 or PAYLOAD_SHORT
+        sinkBuffer.writeByte(b1)
+        sinkBuffer.writeShort(byteCount.toInt())
+      }
+      else -> {
+        b1 = b1 or PAYLOAD_LONG
+        sinkBuffer.writeByte(b1)
+        sinkBuffer.writeLong(byteCount)
+      }
+    }
+
+    if (isClient) {
+      random.nextBytes(maskKey!!)
+      sinkBuffer.write(maskKey)
+
+      if (byteCount > 0L) {
+        val bufferStart = sinkBuffer.size
+        sinkBuffer.write(buffer, byteCount)
+
+        sinkBuffer.readAndWriteUnsafe(maskCursor!!)
+        maskCursor.seek(bufferStart)
+        toggleMask(maskCursor, maskKey)
+        maskCursor.close()
+      }
+    } else {
+      sinkBuffer.write(buffer, byteCount)
+    }
+
+    sink.emit()
+  }
+
+  internal inner class FrameSink : Sink {
+    var formatOpcode = 0
+    var contentLength = 0L
+    var isFirstFrame = false
+    var closed = false
+
+    @Throws(IOException::class)
+    override fun write(source: Buffer, byteCount: Long) {
+      if (closed) throw IOException("closed")
+
+      buffer.write(source, byteCount)
+
+      // Determine if this is a buffered write which we can defer until close() flushes.
+      val deferWrite = isFirstFrame &&
+          contentLength != -1L &&
+          buffer.size > contentLength - 8192 /* segment size */
+
+      val emitCount = buffer.completeSegmentByteCount()
+      if (emitCount > 0L && !deferWrite) {
+        writeMessageFrame(formatOpcode, emitCount, isFirstFrame, isFinal = false)
+        isFirstFrame = false
+      }
+    }
+
+    @Throws(IOException::class)
+    override fun flush() {
+      if (closed) throw IOException("closed")
+
+      writeMessageFrame(formatOpcode, buffer.size, isFirstFrame, isFinal = false)
+      isFirstFrame = false
+    }
+
+    override fun timeout(): Timeout = sink.timeout()
+
+    @Throws(IOException::class)
+    override fun close() {
+      if (closed) throw IOException("closed")
+
+      writeMessageFrame(formatOpcode, buffer.size, isFirstFrame, isFinal = true)
+      closed = true
+      activeWriter = false
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/package-info.java b/okhttp/src/main/java/okhttp3/package-info.java
deleted file mode 100644
index 725b054363..0000000000
--- a/okhttp/src/main/java/okhttp3/package-info.java
+++ /dev/null
@@ -1,3 +0,0 @@
-/** An HTTP+HTTP/2 client for Android and Java applications. */
-@okhttp3.internal.annotations.EverythingIsNonNull
-package okhttp3;
diff --git a/okhttp/src/test/java/okhttp3/AddressTest.java b/okhttp/src/test/java/okhttp3/AddressTest.java
index 9d3bf4165b..6453d93fa3 100644
--- a/okhttp/src/test/java/okhttp3/AddressTest.java
+++ b/okhttp/src/test/java/okhttp3/AddressTest.java
@@ -18,18 +18,18 @@
 import java.net.Proxy;
 import java.util.List;
 import javax.net.SocketFactory;
-import okhttp3.internal.Util;
 import okhttp3.internal.http.RecordingProxySelector;
 import org.junit.Test;
 
+import static okhttp3.internal.Util.immutableListOf;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class AddressTest {
   private Dns dns = Dns.SYSTEM;
   private SocketFactory socketFactory = SocketFactory.getDefault();
   private Authenticator authenticator = Authenticator.NONE;
-  private List<Protocol> protocols = Util.immutableList(Protocol.HTTP_1_1);
-  private List<ConnectionSpec> connectionSpecs = Util.immutableList(ConnectionSpec.MODERN_TLS);
+  private List<Protocol> protocols = immutableListOf(Protocol.HTTP_1_1);
+  private List<ConnectionSpec> connectionSpecs = immutableListOf(ConnectionSpec.MODERN_TLS);
   private RecordingProxySelector proxySelector = new RecordingProxySelector();
 
   @Test public void equalsAndHashcode() throws Exception {
diff --git a/okhttp/src/test/java/okhttp3/CacheTest.java b/okhttp/src/test/java/okhttp3/CacheTest.java
index e39fb55e1a..29090ec1a2 100644
--- a/okhttp/src/test/java/okhttp3/CacheTest.java
+++ b/okhttp/src/test/java/okhttp3/CacheTest.java
@@ -34,12 +34,13 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.HostnameVerifier;
-import okhttp3.internal.InternalKtKt;
+import okhttp3.internal.Internal;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.internal.platform.Platform;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -51,7 +52,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 
-import static okhttp3.internal.InternalKtKt.cacheGet;
+import static okhttp3.internal.Internal.cacheGet;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -65,6 +66,7 @@
   @Rule public MockWebServer server2 = new MockWebServer();
   @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+  @Rule public final PlatformRule platform = new PlatformRule();
 
   private final HandshakeCertificates handshakeCertificates = localhost();
   private OkHttpClient client;
@@ -72,9 +74,11 @@
   private final CookieManager cookieManager = new CookieManager();
 
   @Before public void setUp() throws Exception {
+    platform.assumeNotOpenJSSE();
+
     server.setProtocolNegotiationEnabled(false);
     cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-    client = clientTestRule.client.newBuilder()
+    client = clientTestRule.newClientBuilder()
         .cache(cache)
         .cookieJar(new JavaNetCookieJar(cookieManager))
         .build();
@@ -82,7 +86,10 @@
 
   @After public void tearDown() throws Exception {
     ResponseCache.setDefault(null);
-    cache.delete();
+
+    if (cache != null) {
+      cache.delete();
+    }
   }
 
   /**
@@ -779,7 +786,7 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
 
   private RequestBody requestBodyOrNull(String requestMethod) {
     return (requestMethod.equals("POST") || requestMethod.equals("PUT"))
-        ? RequestBody.create(MediaType.get("text/plain"), "foo")
+        ? RequestBody.create("foo", MediaType.get("text/plain"))
         : null;
   }
 
@@ -867,7 +874,7 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
     Request request = new Request.Builder()
         .url(url)
-        .put(RequestBody.create(MediaType.get("text/plain"), "foo"))
+        .put(RequestBody.create("foo", MediaType.get("text/plain")))
         .build();
     Response invalidate = client.newCall(request).execute();
     assertThat(invalidate.body().string()).isEqualTo("");
@@ -1109,7 +1116,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
   }
 
   @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
-    TestUtil.ensureAllConnectionsReleased(client);
+    clientTestRule.ensureAllConnectionsReleased();
 
     server.enqueue(new MockResponse()
         .addHeader("ETag: v1")
@@ -1992,7 +1999,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
     Headers.Builder headers = new Headers.Builder()
         .add("Cache-Control: max-age=120");
-    InternalKtKt.addHeaderLenient(headers, ": A");
+    Internal.addHeaderLenient(headers, ": A");
     server.enqueue(new MockResponse()
         .setHeaders(headers.build())
         .setBody("body"));
@@ -2449,6 +2456,34 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("α");
   }
 
+  @Test public void conditionalHitHeadersCombined() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Etag", "a")
+        .addHeader("Cache-Control: max-age=0")
+        .addHeader("A: a1")
+        .addHeader("B: b2")
+        .addHeader("B: b3")
+        .setBody("abcd"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+        .addHeader("B: b4")
+        .addHeader("B: b5")
+        .addHeader("C: c6"));
+
+    Response response1 = get(server.url("/"));
+    assertThat(response1.body().string()).isEqualTo("abcd");
+    assertThat(response1.headers()).isEqualTo(Headers.of("Etag", "a", "Cache-Control", "max-age=0",
+        "A", "a1", "B", "b2", "B", "b3", "Content-Length", "4"));
+
+    // The original 'A' header is retained because the network response doesn't have one.
+    // The original 'B' headers are replaced by the network response.
+    // The network's 'C' header is added.
+    Response response2 = get(server.url("/"));
+    assertThat(response2.body().string()).isEqualTo("abcd");
+    assertThat(response2.headers()).isEqualTo(Headers.of("Etag", "a", "Cache-Control", "max-age=0",
+        "A", "a1", "Content-Length", "4", "B", "b4", "B", "b5", "C", "c6"));
+  }
+
   private Response get(HttpUrl url) throws IOException {
     Request request = new Request.Builder()
         .url(url)
diff --git a/okhttp/src/test/java/okhttp3/CallKotlinTest.kt b/okhttp/src/test/java/okhttp3/CallKotlinTest.kt
new file mode 100644
index 0000000000..df7e3f2f89
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/CallKotlinTest.kt
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.mockwebserver.MockResponse
+import okhttp3.mockwebserver.MockWebServer
+import okhttp3.testing.PlatformRule
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TestRule
+import org.junit.rules.Timeout
+import java.util.concurrent.TimeUnit
+
+class CallKotlinTest {
+  @JvmField @Rule val platform = PlatformRule()
+  @JvmField @Rule val timeout: TestRule = Timeout(30_000, TimeUnit.MILLISECONDS)
+  @JvmField @Rule val server = MockWebServer()
+  @JvmField @Rule val clientTestRule = OkHttpClientTestRule()
+
+  private lateinit var client: OkHttpClient
+
+  @Before fun setUp() {
+    client = clientTestRule.newClient()
+  }
+
+  @Test
+  fun legalToExecuteTwiceCloning() {
+    server.enqueue(MockResponse().setBody("abc"))
+    server.enqueue(MockResponse().setBody("def"))
+
+    val request = Request.Builder()
+        .url(server.url("/"))
+        .build()
+
+    val call = client.newCall(request)
+    val response1 = call.execute()
+
+    val cloned = call.clone()
+    val response2 = cloned.execute()
+
+    assertThat("abc").isEqualTo(response1.body!!.string())
+    assertThat("def").isEqualTo(response2.body!!.string())
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/CallTest.java b/okhttp/src/test/java/okhttp3/CallTest.java
index 0463d461f6..cfe907a53b 100644
--- a/okhttp/src/test/java/okhttp3/CallTest.java
+++ b/okhttp/src/test/java/okhttp3/CallTest.java
@@ -71,6 +71,7 @@
 import okhttp3.mockwebserver.QueueDispatcher;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okhttp3.tls.HeldCertificate;
 import okio.Buffer;
@@ -91,8 +92,7 @@
 import static java.util.Arrays.asList;
 import static okhttp3.CipherSuite.TLS_DH_anon_WITH_AES_128_GCM_SHA256;
 import static okhttp3.TestUtil.awaitGarbageCollection;
-import static okhttp3.internal.InternalKtKt.addHeaderLenient;
-import static okhttp3.internal.platform.PlatformTest.getJvmSpecVersion;
+import static okhttp3.internal.Internal.addHeaderLenient;
 import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.data.Offset.offset;
@@ -110,16 +110,19 @@
 
   private RecordingEventListener listener = new RecordingEventListener();
   private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client = clientTestRule.client.newBuilder()
-      .eventListener(listener)
-      .build();
+  private OkHttpClient client;
   private RecordingCallback callback = new RecordingCallback();
   private TestLogHandler logHandler = new TestLogHandler();
   private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
   private Logger logger = Logger.getLogger(OkHttpClient.class.getName());
 
-  @Before public void setUp() throws Exception {
+  @Before public void setUp() {
+    platform.assumeNotOpenJSSE();
+
     logger.addHandler(logHandler);
+    client = clientTestRule.newClientBuilder()
+        .eventListener(listener)
+        .build();
   }
 
   @After public void tearDown() throws Exception {
@@ -220,7 +223,7 @@
     server.enqueue(new MockResponse());
 
     try {
-      new Request.Builder().method("GET", RequestBody.create(MediaType.get("text/plain"), "abc"));
+      new Request.Builder().method("GET", RequestBody.create("abc", MediaType.get("text/plain")));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -314,7 +317,7 @@
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "def"))
+        .post(RequestBody.create("def", MediaType.get("text/plain")))
         .build();
 
     executeSynchronously(request)
@@ -344,7 +347,7 @@
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .method("POST", RequestBody.create(null, new byte[0]))
+        .method("POST", RequestBody.create(new byte[0], null))
         .build();
 
     executeSynchronously(request)
@@ -403,7 +406,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .method("POST", RequestBody.create(null, body))
+        .method("POST", RequestBody.create(body, null))
         .build();
 
     String credential = Credentials.basic("jesse", "secret");
@@ -516,7 +519,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .method("DELETE", RequestBody.create(MediaType.get("text/plain"), "def"))
+        .method("DELETE", RequestBody.create("def", MediaType.get("text/plain")))
         .build();
 
     executeSynchronously(request)
@@ -533,7 +536,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .put(RequestBody.create(MediaType.get("text/plain"), "def"))
+        .put(RequestBody.create("def", MediaType.get("text/plain")))
         .build();
 
     executeSynchronously(request)
@@ -563,7 +566,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .patch(RequestBody.create(MediaType.get("text/plain"), "def"))
+        .patch(RequestBody.create("def", MediaType.get("text/plain")))
         .build();
 
     executeSynchronously(request)
@@ -593,7 +596,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .method("CUSTOM", RequestBody.create(MediaType.get("text/plain"), "def"))
+        .method("CUSTOM", RequestBody.create("def", MediaType.get("text/plain")))
         .build();
 
     executeSynchronously(request)
@@ -613,7 +616,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .method("POST", RequestBody.create(null, "abc"))
+        .method("POST", RequestBody.create("abc", null))
         .build();
 
     executeSynchronously(request).assertCode(200);
@@ -994,7 +997,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
   /** https://github.com/square/okhttp/issues/1801 */
   @Test public void asyncCallEngineInitialized() throws Exception {
-    OkHttpClient c = clientTestRule.client.newBuilder()
+    OkHttpClient c = client.newBuilder()
         .addInterceptor(chain -> { throw new IOException(); })
         .build();
     Request request = new Request.Builder().url(server.url("/")).build();
@@ -1315,7 +1318,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     // The _anon_ suites became unsupported in "1.8.0_201" and "11.0.2".
     assumeFalse(System.getProperty("java.version", "unknown").matches("1\\.8\\.0_1\\d\\d"));
-    assumeFalse(System.getProperty("java.version", "unknown").matches("11"));
 
     server.enqueue(new MockResponse());
 
@@ -1396,8 +1398,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void matchingPinnedCertificate() throws Exception {
-    // TODO https://github.com/square/okhttp/issues/4703
-    assumeFalse(getJvmSpecVersion().equals("11"));
+    // Fails on 11.0.1 https://github.com/square/okhttp/issues/4703
 
     enableTls();
     server.enqueue(new MockResponse());
@@ -1448,7 +1449,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "def"))
+        .post(RequestBody.create("def", MediaType.get("text/plain")))
         .build();
     client.newCall(request).enqueue(callback);
 
@@ -1475,7 +1476,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request2 = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "body!"))
+        .post(RequestBody.create("body!", MediaType.get("text/plain")))
         .build();
     Response response2 = client.newCall(request2).execute();
     assertThat(response2.body().string()).isEqualTo("def");
@@ -1793,7 +1794,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Response response = client.newCall(new Request.Builder()
         .url(server.url("/page1"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "Request Body"))
+        .post(RequestBody.create("Request Body", MediaType.get("text/plain")))
         .build()).execute();
     assertThat(response.body().string()).isEqualTo("Page 2");
 
@@ -1847,7 +1848,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "Hello"))
+        .post(RequestBody.create("Hello", MediaType.get("text/plain")))
         .build();
     Response response = client.newCall(request).execute();
 
@@ -2021,7 +2022,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     // when
     Response response = client.newCall(new Request.Builder()
         .url(server.url("/page1"))
-        .method("PROPFIND", RequestBody.create(MediaType.get("text/plain"), "Request Body"))
+        .method("PROPFIND", RequestBody.create("Request Body", MediaType.get("text/plain")))
         .build()).execute();
 
     // then
@@ -2680,7 +2681,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .post(RequestBody.create("abc", MediaType.get("text/plain")))
         .build();
 
     executeSynchronously(request)
@@ -2696,7 +2697,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), ""))
+        .post(RequestBody.create("", MediaType.get("text/plain")))
         .build();
 
     executeSynchronously(request)
@@ -2720,7 +2721,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .post(RequestBody.create("abc", MediaType.get("text/plain")))
         .build();
 
     Call call = client.newCall(request);
@@ -2745,7 +2746,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .post(RequestBody.create("abc", MediaType.get("text/plain")))
         .build();
 
     executeSynchronously(request)
@@ -2771,7 +2772,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .post(RequestBody.create("abc", MediaType.get("text/plain")))
         .build();
 
     Call call = client.newCall(request);
@@ -2798,7 +2799,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .post(RequestBody.create("abc", MediaType.get("text/plain")))
         .build());
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
@@ -2820,7 +2821,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .post(RequestBody.create("abc", MediaType.get("text/plain")))
         .build());
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
@@ -2841,7 +2842,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .post(RequestBody.create("abc", MediaType.get("text/plain")))
         .build());
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
@@ -3369,7 +3370,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .post(RequestBody.create("abc", MediaType.get("text/plain")))
         .build();
 
     executeSynchronously(request);
@@ -3490,7 +3491,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     server.enqueue(new MockResponse()
         .setBody("This gets leaked."));
 
-    client = clientTestRule.client.newBuilder()
+    client = clientTestRule.newClientBuilder()
         .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
         .build();
 
@@ -3519,7 +3520,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     server.enqueue(new MockResponse()
         .setBody("This gets leaked."));
 
-    client = clientTestRule.client.newBuilder()
+    client = clientTestRule.newClientBuilder()
         .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
         .build();
 
@@ -3761,7 +3762,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
               }
             };
             return response.newBuilder()
-                .body(ResponseBody.create(null, -1L, Okio.buffer(closeTrackingSource)))
+                .body(ResponseBody.create(Okio.buffer(closeTrackingSource), null, -1L))
                 .build();
           }
         })
diff --git a/okhttp/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp/src/test/java/okhttp3/CertificateChainCleanerTest.java
index a2185a9348..45625df17a 100644
--- a/okhttp/src/test/java/okhttp3/CertificateChainCleanerTest.java
+++ b/okhttp/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -37,22 +37,22 @@
     HeldCertificate rootB = new HeldCertificate.Builder()
         .serialNumber(2L)
         .build();
-    assertThat(CertificateChainCleaner.get(rootB.certificate(), rootA.certificate())).isEqualTo(
-        CertificateChainCleaner.get(rootA.certificate(), rootB.certificate()));
+    assertThat(CertificateChainCleaner.Companion.get(rootB.certificate(), rootA.certificate()))
+        .isEqualTo(CertificateChainCleaner.Companion.get(rootA.certificate(), rootB.certificate()));
   }
 
   @Test public void equalsFromTrustManager() {
     HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder().build();
     X509TrustManager x509TrustManager = handshakeCertificates.trustManager();
-    assertThat(CertificateChainCleaner.get(x509TrustManager)).isEqualTo(
-        CertificateChainCleaner.get(x509TrustManager));
+    assertThat(CertificateChainCleaner.Companion.get(x509TrustManager)).isEqualTo(
+        CertificateChainCleaner.Companion.get(x509TrustManager));
   }
 
   @Test public void normalizeSingleSelfSignedCertificate() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
         .serialNumber(1L)
         .build();
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
+    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(root.certificate());
     assertThat(cleaner.clean(list(root), "hostname")).isEqualTo(list(root));
   }
 
@@ -60,7 +60,7 @@
     HeldCertificate root = new HeldCertificate.Builder()
         .serialNumber(1L)
         .build();
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get();
+    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get();
 
     try {
       cleaner.clean(list(root), "hostname");
@@ -82,7 +82,7 @@
         .signedBy(certA)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
+    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(root.certificate());
     assertThat(cleaner.clean(list(certB, certA, root), "hostname")).isEqualTo(
         list(certB, certA, root));
   }
@@ -100,7 +100,7 @@
         .signedBy(certA)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
+    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(root.certificate());
     // Root is added!
     assertThat(cleaner.clean(list(certB, certA), "hostname")).isEqualTo(
         list(certB, certA, root));
@@ -123,7 +123,7 @@
         .signedBy(certB)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
+    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(root.certificate());
     assertThat(cleaner.clean(list(certC, certA, root, certB), "hostname")).isEqualTo(
         list(certC, certB, certA, root));
   }
@@ -145,7 +145,7 @@
         .signedBy(certB)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
+    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(root.certificate());
     assertThat(cleaner.clean(list(certC, certA, certB), "hostname")).isEqualTo(
         list(certC, certB, certA, root));
   }
@@ -166,7 +166,7 @@
         .serialNumber(4L)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
+    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(root.certificate());
     assertThat(cleaner.clean(list(certB, certUnnecessary, certA, root), "hostname")).isEqualTo(
         list(certB, certA, root));
   }
@@ -188,7 +188,7 @@
         .signedBy(certA)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(
+    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(
         selfSigned.certificate(), trusted.certificate());
     assertThat(cleaner.clean(list(certB, certA), "hostname")).isEqualTo(
         list(certB, certA, trusted, selfSigned));
@@ -215,7 +215,7 @@
         .serialNumber(4L)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(trusted.certificate());
+    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(trusted.certificate());
     assertThat(cleaner.clean(list(certificate, intermediateCa), "hostname")).isEqualTo(
         list(certificate, intermediateCa, trusted));
     assertThat(cleaner.clean(list(certificate, intermediateCa, trusted), "hostname")).isEqualTo(
@@ -230,7 +230,7 @@
     }
 
     X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate();
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(root);
     assertThat(cleaner.clean(certificates, "hostname")).isEqualTo(certificates);
     assertThat(cleaner.clean(certificates.subList(0, 9), "hostname")).isEqualTo(
         certificates);
@@ -244,7 +244,7 @@
     }
 
     X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate();
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(root);
     try {
       cleaner.clean(certificates, "hostname");
       fail();
diff --git a/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt b/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt
index 8c55f3901f..8de9cea1de 100644
--- a/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt
+++ b/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt
@@ -16,6 +16,7 @@
 package okhttp3
 
 import okhttp3.CertificatePinner.Companion.newPin
+import okhttp3.CertificatePinner.Companion.toSha1ByteString
 import okhttp3.tls.HeldCertificate
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Test
@@ -25,10 +26,10 @@ class CertificatePinnerKotlinTest {
   @Test
   fun successfulCheckSha1Pin() {
     val certificatePinner = CertificatePinner.Builder()
-        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate()).base64())
+        .add("example.com", "sha1/" + certA1.certificate.toSha1ByteString().base64())
         .build()
 
-    certificatePinner.check("example.com", certA1.certificate())
+    certificatePinner.check("example.com", listOf(certA1.certificate))
   }
 
   @Test fun successfulFindMatchingPins() {
@@ -113,16 +114,16 @@ class CertificatePinnerKotlinTest {
     internal var certA1: HeldCertificate = HeldCertificate.Builder()
         .serialNumber(100L)
         .build()
-    internal var certA1Sha256Pin = CertificatePinner.pin(certA1.certificate())
+    internal var certA1Sha256Pin = CertificatePinner.pin(certA1.certificate)
 
-    internal var certB1 = HeldCertificate.Builder()
+    private var certB1 = HeldCertificate.Builder()
         .serialNumber(200L)
         .build()
-    internal var certB1Sha256Pin = CertificatePinner.pin(certB1.certificate())
+    internal var certB1Sha256Pin = CertificatePinner.pin(certB1.certificate)
 
-    internal var certC1 = HeldCertificate.Builder()
+    private var certC1 = HeldCertificate.Builder()
         .serialNumber(300L)
         .build()
-    internal var certC1Sha256Pin = CertificatePinner.pin(certC1.certificate())
+    internal var certC1Sha256Pin = CertificatePinner.pin(certC1.certificate)
   }
 }
diff --git a/okhttp/src/test/java/okhttp3/CipherSuiteTest.java b/okhttp/src/test/java/okhttp3/CipherSuiteTest.java
index 35d7843811..d70d7d4b17 100644
--- a/okhttp/src/test/java/okhttp3/CipherSuiteTest.java
+++ b/okhttp/src/test/java/okhttp3/CipherSuiteTest.java
@@ -21,7 +21,7 @@
 import static okhttp3.CipherSuite.TLS_RSA_EXPORT_WITH_RC4_40_MD5;
 import static okhttp3.CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA256;
 import static okhttp3.CipherSuite.forJavaName;
-import static okhttp3.internal.InternalKtKt.applyConnectionSpec;
+import static okhttp3.internal.Internal.applyConnectionSpec;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.fail;
diff --git a/okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java b/okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java
index 48ad1cf99a..0895bbe11c 100644
--- a/okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java
+++ b/okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java
@@ -21,15 +21,16 @@
 import java.net.Proxy;
 import java.util.Collections;
 import java.util.List;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.HostnameVerifier;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okhttp3.tls.HeldCertificate;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -51,7 +52,6 @@
   private List<InetAddress> serverIps;
 
   @Before public void setUp() throws Exception {
-    platform.assumeNotConscrypt();
     platform.assumeHttp2Support();
 
     rootCa = new HeldCertificate.Builder()
@@ -81,11 +81,11 @@
         .addTrustedCertificate(rootCa.certificate())
         .build();
 
-    client = new OkHttpClient.Builder().dns(dns)
+    client = clientTestRule.newClientBuilder()
+        .dns(dns)
         .sslSocketFactory(
             handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .build();
-    clientTestRule.client = client;
 
     HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
         .heldCertificate(certificate)
@@ -152,6 +152,107 @@
     assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
+  /**
+   * This is an extraordinary test case. Here's what it's trying to simulate.
+   * - 2 requests happen concurrently to a host that can be coalesced onto a single connection.
+   * - Both request discover no existing connection. They both make a connection.
+   * - The first request "wins the race".
+   * - The second request discovers it "lost the race" and closes the connection it just opened.
+   * - The second request uses the coalesced connection from request1.
+   * - The coalesced connection is violently closed after servicing the first request.
+   * - The second request discovers the coalesced connection is unhealthy just after acquiring it.
+   */
+  @Test public void coalescedConnectionDestroyedAfterAcquire() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    dns.set("san.com", Dns.SYSTEM.lookup(server.getHostName()).subList(0, 1));
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+
+    CountDownLatch latch1 = new CountDownLatch(1);
+    CountDownLatch latch2 = new CountDownLatch(1);
+    CountDownLatch latch3 = new CountDownLatch(1);
+    CountDownLatch latch4 = new CountDownLatch(1);
+    EventListener listener1 = new EventListener() {
+      @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
+          Proxy proxy) {
+        try {
+          // Wait for request2 to guarantee we make 2 separate connections to the server.
+          latch1.await();
+        } catch (InterruptedException e) {
+          throw new AssertionError(e);
+        }
+      }
+
+      @Override public void connectionAcquired(Call call, Connection connection) {
+        // We have the connection and it's in the pool. Let request2 proceed to make a connection.
+        latch2.countDown();
+      }
+    };
+
+    EventListener request2Listener = new EventListener() {
+      @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
+          Proxy proxy) {
+        // Let request1 proceed to make a connection.
+        latch1.countDown();
+        try {
+          // Wait until request1 makes the connection and puts it in the connection pool.
+          latch2.await();
+        } catch (InterruptedException e) {
+          throw new AssertionError(e);
+        }
+      }
+
+      @Override public void connectionAcquired(Call call, Connection connection) {
+        // We obtained the coalesced connection. Let request1 violently destroy it.
+        latch3.countDown();
+        try {
+          latch4.await();
+        } catch (InterruptedException e) {
+          throw new AssertionError(e);
+        }
+      }
+    };
+
+    // Get a reference to the connection so we can violently destroy it.
+    AtomicReference<Connection> connection = new AtomicReference<>();
+    OkHttpClient client1 = client.newBuilder()
+        .addNetworkInterceptor(chain -> {
+          connection.set(chain.connection());
+          return chain.proceed(chain.request());
+        })
+        .eventListener(listener1)
+        .build();
+
+    Request request = new Request.Builder().url(sanUrl).build();
+    Call call1 = client1.newCall(request);
+    call1.enqueue(new Callback() {
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try {
+          // Wait until request2 acquires the connection before we destroy it violently.
+          latch3.await();
+        } catch (InterruptedException e) {
+          throw new AssertionError(e);
+        }
+        assert200Http2Response(response, "san.com");
+        connection.get().socket().close();
+        latch4.countDown();
+      }
+
+      @Override public void onFailure(Call call, IOException e) {
+        fail();
+      }
+    });
+
+    OkHttpClient client2 = client.newBuilder()
+        .eventListener(request2Listener)
+        .build();
+    Call call2 = client2.newCall(request);
+    Response response = call2.execute();
+
+    assert200Http2Response(response, "san.com");
+  }
+
   /** If the existing connection matches a SAN but not a match for DNS then skip. */
   @Test public void skipsWhenDnsDontMatch() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(200));
@@ -302,24 +403,6 @@
     assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
-  /** Run against public external sites, doesn't run by default. */
-  @Ignore
-  @Test public void coalescesConnectionsToRealSites() throws IOException {
-    client = new OkHttpClient();
-
-    assert200Http2Response(execute("https://graph.facebook.com/robots.txt"), "graph.facebook.com");
-    assert200Http2Response(execute("https://www.facebook.com/robots.txt"), "m.facebook.com");
-    assert200Http2Response(execute("https://fb.com/robots.txt"), "m.facebook.com");
-    assert200Http2Response(execute("https://messenger.com/robots.txt"), "messenger.com");
-    assert200Http2Response(execute("https://m.facebook.com/robots.txt"), "m.facebook.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(3);
-  }
-
-  private Response execute(String url) throws IOException {
-    return execute(HttpUrl.get(url));
-  }
-
   private Response execute(HttpUrl url) throws IOException {
     return client.newCall(new Request.Builder().url(url).build()).execute();
   }
diff --git a/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
index 837dae460c..a3445d7813 100644
--- a/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
+++ b/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
@@ -19,17 +19,19 @@
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLException;
-import okhttp3.internal.Util;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
 import org.junit.rules.Timeout;
 
 import static java.util.Arrays.asList;
+import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
@@ -41,7 +43,11 @@
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client = clientTestRule.client;
+  private OkHttpClient client;
+
+  @Before public void setUp() {
+    client = clientTestRule.newClient();
+  }
 
   @Test public void connectionsAreReused() throws Exception {
     server.enqueue(new MockResponse().setBody("a"));
@@ -194,7 +200,7 @@
 
     Request requestB = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), "b"))
+        .post(RequestBody.create("b", MediaType.get("text/plain")))
         .build();
     Response responseB = client.newCall(requestB).execute();
     assertThat(responseB.body().string()).isEqualTo("b");
@@ -314,7 +320,7 @@
           responsesNotClosed.add(response);
           return response
               .newBuilder()
-              .body(ResponseBody.create(null, "unrelated response body!"))
+              .body(ResponseBody.create("unrelated response body!", null))
               .build();
         })
         .build();
@@ -339,7 +345,7 @@
     assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
 
     for (Response response : responsesNotClosed) {
-      Util.closeQuietly(response);
+      closeQuietly(response);
     }
   }
 
diff --git a/okhttp/src/test/java/okhttp3/ConnectionSpecTest.java b/okhttp/src/test/java/okhttp3/ConnectionSpecTest.java
index a42d05bc80..6663416032 100644
--- a/okhttp/src/test/java/okhttp3/ConnectionSpecTest.java
+++ b/okhttp/src/test/java/okhttp3/ConnectionSpecTest.java
@@ -21,11 +21,12 @@
 import java.util.concurrent.CopyOnWriteArraySet;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.testing.PlatformRule;
 import org.junit.Rule;
 import org.junit.Test;
 
 import static java.util.Arrays.asList;
-import static okhttp3.internal.InternalKtKt.applyConnectionSpec;
+import static okhttp3.internal.Internal.applyConnectionSpec;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
@@ -283,6 +284,8 @@
     assertThat(set.add(ConnectionSpec.CLEARTEXT)).isTrue();
     assertThat(set.add(allTlsVersions)).isTrue();
     assertThat(set.add(allCipherSuites)).isTrue();
+    allCipherSuites.hashCode();
+    assertThat(allCipherSuites.equals(null)).isFalse();
 
     assertThat(set.remove(ConnectionSpec.MODERN_TLS)).isTrue();
     assertThat(set.remove(ConnectionSpec.COMPATIBLE_TLS)).isTrue();
@@ -290,6 +293,8 @@
     assertThat(set.remove(allTlsVersions)).isTrue();
     assertThat(set.remove(allCipherSuites)).isTrue();
     assertThat(set).isEmpty();
+    allTlsVersions.hashCode();
+    assertThat(allTlsVersions.equals(null)).isFalse();
   }
 
   @Test public void allEnabledToString() throws Exception {
diff --git a/okhttp/src/test/java/okhttp3/ConscryptTest.kt b/okhttp/src/test/java/okhttp3/ConscryptTest.kt
index 7b42128fda..47381de1d0 100644
--- a/okhttp/src/test/java/okhttp3/ConscryptTest.kt
+++ b/okhttp/src/test/java/okhttp3/ConscryptTest.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
+ * Copyright (C) 2018 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,71 +15,64 @@
  */
 package okhttp3
 
+import okhttp3.TestUtil.assumeNetwork
 import okhttp3.internal.platform.ConscryptPlatform
 import okhttp3.internal.platform.Platform
+import okhttp3.testing.PlatformRule
 import org.assertj.core.api.Assertions.assertThat
 import org.conscrypt.Conscrypt
-import org.junit.After
 import org.junit.Assert.assertFalse
 import org.junit.Assert.assertTrue
-import org.junit.Assume
 import org.junit.Before
+import org.junit.Ignore
 import org.junit.Rule
 import org.junit.Test
-import java.net.InetAddress
-import java.net.UnknownHostException
 
 class ConscryptTest {
   @Suppress("RedundantVisibilityModifier")
   @JvmField
   @Rule public val platform = PlatformRule.conscrypt()
 
-  private lateinit var client: OkHttpClient
-
-  @Before
-  fun createClient() {
-    assertThat(Conscrypt.isConscrypt(Platform.get().platformTrustManager())).isTrue()
+  @JvmField @Rule val clientTestRule = OkHttpClientTestRule()
 
-    client = OkHttpClient()
-  }
+  private lateinit var client: OkHttpClient
 
-  @After
-  fun tearDown() {
-    TestUtil.ensureAllConnectionsReleased(client)
+  @Before fun setUp() {
+    platform.assumeConscrypt()
+    client = clientTestRule.newClient()
   }
 
-  private fun assumeNetwork() {
-    try {
-      InetAddress.getByName("www.google.com")
-    } catch (uhe: UnknownHostException) {
-      Assume.assumeNoException(uhe)
-    }
+  @Test
+  fun testTrustManager() {
+    assertThat(Conscrypt.isConscrypt(Platform.get().platformTrustManager())).isTrue()
   }
 
   @Test
+  @Ignore
   fun testMozilla() {
     assumeNetwork()
 
     val request = Request.Builder().url("https://mozilla.org/robots.txt").build()
 
-    val response = client.newCall(request).execute()
-
-    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_2)
-    assertThat(response.handshake()!!.tlsVersion()).isEqualTo(TlsVersion.TLS_1_3)
+    client.newCall(request).execute().use {
+      assertThat(it.protocol).isEqualTo(Protocol.HTTP_2)
+      assertThat(it.handshake!!.tlsVersion).isEqualTo(TlsVersion.TLS_1_3)
+    }
   }
 
   @Test
+  @Ignore
   fun testGoogle() {
     assumeNetwork()
 
     val request = Request.Builder().url("https://google.com/robots.txt").build()
 
-    val response = client.newCall(request).execute()
-
-    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_2)
-    if (response.handshake()!!.tlsVersion() != TlsVersion.TLS_1_3) {
-      System.err.println("Flaky TLSv1.3 with google")
-//    assertThat(response.handshake()!!.tlsVersion()).isEqualTo(TlsVersion.TLS_1_3)
+    client.newCall(request).execute().use {
+      assertThat(it.protocol).isEqualTo(Protocol.HTTP_2)
+      if (it.handshake!!.tlsVersion != TlsVersion.TLS_1_3) {
+        System.err.println("Flaky TLSv1.3 with google")
+//    assertThat(it.handshake()!!.tlsVersion).isEqualTo(TlsVersion.TLS_1_3)
+      }
     }
   }
 
@@ -91,12 +84,14 @@ class ConscryptTest {
 
   @Test
   fun testVersion() {
+    val version = Conscrypt.version()
+
     assertTrue(ConscryptPlatform.atLeastVersion(1, 4, 9))
-    assertTrue(ConscryptPlatform.atLeastVersion(2))
-    assertTrue(ConscryptPlatform.atLeastVersion(2, 1))
-    assertTrue(ConscryptPlatform.atLeastVersion(2, 1, 0))
-    assertFalse(ConscryptPlatform.atLeastVersion(2, 1, 1))
-    assertFalse(ConscryptPlatform.atLeastVersion(2, 2))
-    assertFalse(ConscryptPlatform.atLeastVersion(9))
+    assertTrue(ConscryptPlatform.atLeastVersion(version.major()))
+    assertTrue(ConscryptPlatform.atLeastVersion(version.major(), version.minor()))
+    assertTrue(ConscryptPlatform.atLeastVersion(version.major(), version.minor(), version.patch()))
+    assertFalse(ConscryptPlatform.atLeastVersion(version.major(), version.minor(), version.patch() + 1))
+    assertFalse(ConscryptPlatform.atLeastVersion(version.major(), version.minor() + 1))
+    assertFalse(ConscryptPlatform.atLeastVersion(version.major() + 1))
   }
 }
diff --git a/okhttp/src/test/java/okhttp3/CookieTest.java b/okhttp/src/test/java/okhttp3/CookieTest.java
index a1f591360f..bf2add65e3 100644
--- a/okhttp/src/test/java/okhttp3/CookieTest.java
+++ b/okhttp/src/test/java/okhttp3/CookieTest.java
@@ -21,11 +21,11 @@
 import java.util.List;
 import java.util.Objects;
 import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpDate;
 import org.junit.Test;
 
 import static java.util.Arrays.asList;
-import static okhttp3.internal.InternalKtKt.parseCookie;
+import static okhttp3.internal.Internal.parseCookie;
+import static okhttp3.internal.http.DatesKt.MAX_DATE;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
@@ -93,32 +93,35 @@
   }
 
   @Test public void maxAge() throws Exception {
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=1").expiresAt()).isEqualTo(51000L);
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=9223372036854724").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=9223372036854725").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=9223372036854726").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(parseCookie(9223372036854773807L, url, "a=b; Max-Age=1").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(parseCookie(9223372036854773807L, url, "a=b; Max-Age=2").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(parseCookie(9223372036854773807L, url, "a=b; Max-Age=3").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=10000000000000000000").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=1").expiresAt())
+        .isEqualTo(51000L);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=9223372036854724").expiresAt())
+        .isEqualTo(MAX_DATE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=9223372036854725").expiresAt())
+        .isEqualTo(MAX_DATE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=9223372036854726").expiresAt())
+        .isEqualTo(MAX_DATE);
+    assertThat(parseCookie(9223372036854773807L, url, "a=b; Max-Age=1").expiresAt())
+        .isEqualTo(MAX_DATE);
+    assertThat(parseCookie(9223372036854773807L, url, "a=b; Max-Age=2").expiresAt())
+        .isEqualTo(MAX_DATE);
+    assertThat(parseCookie(9223372036854773807L, url, "a=b; Max-Age=3").expiresAt())
+        .isEqualTo(MAX_DATE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=10000000000000000000").expiresAt())
+        .isEqualTo(MAX_DATE);
   }
 
   @Test public void maxAgeNonPositive() throws Exception {
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-1").expiresAt()).isEqualTo(Long.MIN_VALUE);
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=0").expiresAt()).isEqualTo(Long.MIN_VALUE);
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-9223372036854775808").expiresAt()).isEqualTo(
-        Long.MIN_VALUE);
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-9223372036854775809").expiresAt()).isEqualTo(
-        Long.MIN_VALUE);
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-10000000000000000000").expiresAt()).isEqualTo(
-        Long.MIN_VALUE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-1").expiresAt())
+        .isEqualTo(Long.MIN_VALUE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=0").expiresAt())
+        .isEqualTo(Long.MIN_VALUE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-9223372036854775808").expiresAt())
+        .isEqualTo(Long.MIN_VALUE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-9223372036854775809").expiresAt())
+        .isEqualTo(Long.MIN_VALUE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-10000000000000000000").expiresAt())
+        .isEqualTo(Long.MIN_VALUE);
   }
 
   @Test public void domainAndPath() throws Exception {
@@ -139,76 +142,75 @@
   }
 
   @Test public void expiresDate() throws Exception {
-    assertThat(new Date(
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT").expiresAt())).isEqualTo(
-        date("1970-01-01T00:00:00.000+0000"));
-    assertThat(new Date(
-        Cookie.parse(url, "a=b; Expires=Wed, 09 Jun 2021 10:18:14 GMT").expiresAt())).isEqualTo(
-        date("2021-06-09T10:18:14.000+0000"));
-    assertThat(new Date(
-        Cookie.parse(url, "a=b; Expires=Sun, 06 Nov 1994 08:49:37 GMT").expiresAt())).isEqualTo(
-        date("1994-11-06T08:49:37.000+0000"));
+    assertThat(new Date(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT")
+        .expiresAt())).isEqualTo(date("1970-01-01T00:00:00.000+0000"));
+    assertThat(new Date(Cookie.parse(url, "a=b; Expires=Wed, 09 Jun 2021 10:18:14 GMT")
+        .expiresAt())).isEqualTo(date("2021-06-09T10:18:14.000+0000"));
+    assertThat(new Date(Cookie.parse(url, "a=b; Expires=Sun, 06 Nov 1994 08:49:37 GMT")
+        .expiresAt())).isEqualTo(date("1994-11-06T08:49:37.000+0000"));
   }
 
   @Test public void awkwardDates() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 70 00:00:00 GMT").expiresAt()).isEqualTo(
-        0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 January 1970 00:00:00 GMT").expiresAt()).isEqualTo(
-        0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Janucember 1970 00:00:00 GMT").expiresAt()).isEqualTo(
-        0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 1 Jan 1970 00:00:00 GMT").expiresAt()).isEqualTo(
-        0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 0:00:00 GMT").expiresAt()).isEqualTo(
-        0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:0:00 GMT").expiresAt()).isEqualTo(
-        0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:0 GMT").expiresAt()).isEqualTo(
-        0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 Thu, 01 Jan 1970 GMT").expiresAt()).isEqualTo(
-        0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 01").expiresAt()).isEqualTo(0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 1").expiresAt()).isEqualTo(0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 70 00:00:00 GMT").expiresAt())
+        .isEqualTo(0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 January 1970 00:00:00 GMT").expiresAt())
+        .isEqualTo(0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Janucember 1970 00:00:00 GMT").expiresAt())
+        .isEqualTo(0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 1 Jan 1970 00:00:00 GMT").expiresAt())
+        .isEqualTo(0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 0:00:00 GMT").expiresAt())
+        .isEqualTo(0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:0:00 GMT").expiresAt())
+        .isEqualTo(0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:0 GMT").expiresAt())
+        .isEqualTo(0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 Thu, 01 Jan 1970 GMT").expiresAt())
+        .isEqualTo(0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 01").expiresAt())
+        .isEqualTo(0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 1").expiresAt())
+        .isEqualTo(0L);
   }
 
   @Test public void invalidYear() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1600 00:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 19999 00:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 00:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1600 00:00:00 GMT").expiresAt())
+        .isEqualTo(MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 19999 00:00:00 GMT").expiresAt())
+        .isEqualTo(MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 00:00:00 GMT").expiresAt())
+        .isEqualTo(MAX_DATE);
   }
 
   @Test public void invalidMonth() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Foo 1970 00:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Foocember 1970 00:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 1970 00:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Foo 1970 00:00:00 GMT").expiresAt())
+        .isEqualTo(MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Foocember 1970 00:00:00 GMT").expiresAt())
+        .isEqualTo(MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 1970 00:00:00 GMT").expiresAt())
+        .isEqualTo(MAX_DATE);
   }
 
   @Test public void invalidDayOfMonth() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 32 Jan 1970 00:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, Jan 1970 00:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 32 Jan 1970 00:00:00 GMT").expiresAt())
+        .isEqualTo(MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, Jan 1970 00:00:00 GMT").expiresAt())
+        .isEqualTo(MAX_DATE);
   }
 
   @Test public void invalidHour() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 24:00:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 24:00:00 GMT").expiresAt())
+        .isEqualTo(MAX_DATE);
   }
 
   @Test public void invalidMinute() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:60:00 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:60:00 GMT").expiresAt())
+        .isEqualTo(MAX_DATE);
   }
 
   @Test public void invalidSecond() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:60 GMT").expiresAt()).isEqualTo(
-        HttpDate.MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:60 GMT").expiresAt())
+        .isEqualTo(MAX_DATE);
   }
 
   @Test public void domainMatches() throws Exception {
@@ -389,7 +391,8 @@
   @Test public void maxAgeOrExpiresMakesCookiePersistent() throws Exception {
     assertThat(parseCookie(0L, url, "a=b").persistent()).isFalse();
     assertThat(parseCookie(0L, url, "a=b; Max-Age=1").persistent()).isTrue();
-    assertThat(parseCookie(0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT").persistent()).isTrue();
+    assertThat(parseCookie(0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT").persistent())
+        .isTrue();
   }
 
   @Test public void parseAll() throws Exception {
@@ -411,7 +414,7 @@
         .build();
     assertThat(cookie.name()).isEqualTo("a");
     assertThat(cookie.value()).isEqualTo("b");
-    assertThat(cookie.expiresAt()).isEqualTo(HttpDate.MAX_DATE);
+    assertThat(cookie.expiresAt()).isEqualTo(MAX_DATE);
     assertThat(cookie.domain()).isEqualTo("example.com");
     assertThat(cookie.path()).isEqualTo("/");
     assertThat(cookie.secure()).isFalse();
diff --git a/okhttp/src/test/java/okhttp3/CookiesTest.java b/okhttp/src/test/java/okhttp3/CookiesTest.java
index be8d238382..758a0936cc 100644
--- a/okhttp/src/test/java/okhttp3/CookiesTest.java
+++ b/okhttp/src/test/java/okhttp3/CookiesTest.java
@@ -30,6 +30,7 @@
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -44,7 +45,11 @@
   @Rule public final MockWebServer server = new MockWebServer();
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
-  private OkHttpClient client = clientTestRule.client;
+  private OkHttpClient client;
+
+  @Before public void setUp() {
+    client = clientTestRule.newClient();
+  }
 
   @Test
   public void testNetscapeResponse() throws Exception {
diff --git a/okhttp/src/test/java/okhttp3/DispatcherTest.java b/okhttp/src/test/java/okhttp3/DispatcherTest.java
index b7d0291113..2a7c9a06b6 100644
--- a/okhttp/src/test/java/okhttp3/DispatcherTest.java
+++ b/okhttp/src/test/java/okhttp3/DispatcherTest.java
@@ -20,15 +20,16 @@
   RecordingWebSocketListener webSocketListener = new RecordingWebSocketListener();
   Dispatcher dispatcher = new Dispatcher(executor);
   RecordingEventListener listener = new RecordingEventListener();
-  OkHttpClient client = clientTestRule.client.newBuilder()
-      .dispatcher(dispatcher)
-      .eventListener(listener)
-      .build();
+  OkHttpClient client;
 
   @Before public void setUp() throws Exception {
     dispatcher.setMaxRequests(20);
     dispatcher.setMaxRequestsPerHost(10);
     listener.forbidLock(dispatcher);
+    client = clientTestRule.newClientBuilder()
+        .dispatcher(dispatcher)
+        .eventListener(listener)
+        .build();
   }
 
   @Test public void maxRequestsZero() throws Exception {
diff --git a/okhttp/src/test/java/okhttp3/DuplexTest.java b/okhttp/src/test/java/okhttp3/DuplexTest.java
index 84a1ed3f9e..7453035a96 100644
--- a/okhttp/src/test/java/okhttp3/DuplexTest.java
+++ b/okhttp/src/test/java/okhttp3/DuplexTest.java
@@ -27,6 +27,7 @@
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
 import okhttp3.mockwebserver.internal.duplex.MockDuplexResponseBody;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -50,14 +51,14 @@
 
   private RecordingEventListener listener = new RecordingEventListener();
   private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client = clientTestRule.client
-      .newBuilder()
-      .eventListener(listener)
-      .build();
+  private OkHttpClient client;
 
-  @Before
-  public void checkHttp2() {
+  @Before public void setUp() {
+    platform.assumeNotOpenJSSE();
     platform.assumeHttp2Support();
+    client = clientTestRule.newClientBuilder()
+        .eventListener(listener)
+        .build();
   }
 
   @Test public void http1DoesntSupportDuplex() throws IOException {
@@ -242,7 +243,7 @@ public void checkHttp2() {
     mockDuplexResponseBody.awaitSuccess();
 
     assertThat(listener.recordedEventTypes()).containsExactly(
-        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "CallStart", "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd", "ConnectStart",
         "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
         "RequestHeadersStart", "RequestHeadersEnd", "RequestBodyStart", "ResponseHeadersStart",
         "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "RequestBodyEnd",
@@ -342,7 +343,7 @@ public void checkHttp2() {
     mockDuplexResponseBody.awaitSuccess();
 
     assertThat(listener.recordedEventTypes()).containsExactly(
-        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "CallStart", "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd", "ConnectStart",
         "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
         "RequestHeadersStart", "RequestHeadersEnd", "RequestBodyStart", "ResponseHeadersStart",
         "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "RequestHeadersStart",
diff --git a/okhttp/src/test/java/okhttp3/EventListenerTest.java b/okhttp/src/test/java/okhttp3/EventListenerTest.java
index 8b3947bf74..d5f23f6031 100644
--- a/okhttp/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp/src/test/java/okhttp3/EventListenerTest.java
@@ -42,12 +42,13 @@
 import okhttp3.RecordingEventListener.SecureConnectEnd;
 import okhttp3.RecordingEventListener.SecureConnectStart;
 import okhttp3.internal.DoubleInetAddressDns;
-import okhttp3.internal.Internal;
 import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.connection.RealConnectionPool;
 import okhttp3.logging.HttpLoggingInterceptor;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -81,15 +82,17 @@
   private final RecordingEventListener listener = new RecordingEventListener();
   private final HandshakeCertificates handshakeCertificates = localhost();
 
-  private OkHttpClient client = clientTestRule.client;
+  private OkHttpClient client;
   private SocksProxy socksProxy;
 
   @Before public void setUp() {
-    client = clientTestRule.client.newBuilder()
+    platform.assumeNotOpenJSSE();
+
+    client = clientTestRule.newClientBuilder()
         .eventListener(listener)
         .build();
 
-    listener.forbidLock(Internal.instance.realConnectionPool(client.connectionPool()));
+    listener.forbidLock(RealConnectionPool.Companion.get(client.connectionPool()));
     listener.forbidLock(client.dispatcher());
   }
 
@@ -111,7 +114,8 @@
     assertThat(response.body().string()).isEqualTo("abc");
     response.body().close();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
@@ -141,7 +145,8 @@
 
     completionLatch.await();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
@@ -162,7 +167,8 @@
       assertThat(expected.getMessage()).isIn("timeout", "Read timed out");
     }
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseFailed", "ConnectionReleased",
         "CallFailed");
@@ -190,7 +196,8 @@
       assertThat(expected.getMessage()).isEqualTo("unexpected end of stream");
     }
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseFailed", "ConnectionReleased", "CallFailed");
@@ -210,7 +217,8 @@
       assertThat(expected.getMessage()).isEqualTo("Canceled");
     }
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallFailed");
+    assertThat(listener.recordedEventTypes())
+        .containsExactly("CallStart", "ProxySelectStart", "ProxySelectEnd", "CallFailed");
   }
 
   private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throws IOException {
@@ -225,7 +233,8 @@ private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throw
     assumeThat(response, responseMatcher);
 
     assertThat(listener.recordedEventTypes()).containsExactly(
-        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "CallStart", "ProxySelectStart", "ProxySelectEnd",
+        "DnsStart", "DnsEnd", "ConnectStart",
         "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
         "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
         "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
@@ -249,7 +258,8 @@ private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throw
     Response response = call.execute();
     response.close();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "ConnectionAcquired",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "ConnectionAcquired",
         "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
         "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
   }
@@ -910,7 +920,8 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
     Response response = call.execute();
     response.body().close();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
@@ -927,7 +938,8 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
     Response response = call.execute();
     response.body().close();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
@@ -945,7 +957,8 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
     Response response = call.execute();
     response.body().close();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
@@ -1067,7 +1080,7 @@ private void writeChunk(BufferedSink sink) throws IOException {
     }
 
     assertThat(listener.recordedEventTypes()).containsExactly(
-        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "CallStart", "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd", "ConnectStart",
         "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
         "RequestBodyStart", "RequestFailed", "ConnectionReleased", "CallFailed");
   }
@@ -1075,7 +1088,7 @@ private void writeChunk(BufferedSink sink) throws IOException {
   @Test public void requestBodySuccessHttp1OverHttps() throws IOException {
     enableTlsWithTunnel(false);
     server.setProtocols(asList(Protocol.HTTP_1_1));
-    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
+    requestBodySuccess(RequestBody.create("Hello", MediaType.get("text/plain")), equalTo(5L),
         equalTo(19L));
   }
 
@@ -1084,12 +1097,12 @@ private void writeChunk(BufferedSink sink) throws IOException {
 
     enableTlsWithTunnel(false);
     server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
+    requestBodySuccess(RequestBody.create("Hello", MediaType.get("text/plain")), equalTo(5L),
         equalTo(19L));
   }
 
   @Test public void requestBodySuccessHttp() throws IOException {
-    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
+    requestBodySuccess(RequestBody.create("Hello", MediaType.get("text/plain")), equalTo(5L),
         equalTo(19L));
   }
 
@@ -1109,7 +1122,7 @@ private void writeChunk(BufferedSink sink) throws IOException {
   }
 
   @Test public void requestBodySuccessEmpty() throws IOException {
-    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), ""), equalTo(0L),
+    requestBodySuccess(RequestBody.create("", MediaType.get("text/plain")), equalTo(0L),
         equalTo(19L));
   }
 
@@ -1128,7 +1141,8 @@ private void writeChunk(BufferedSink sink) throws IOException {
     assertThat(response.body().string()).isEqualTo("abc");
     response.body().close();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
@@ -1168,7 +1182,8 @@ private void enableTlsWithTunnel(boolean tunnelProxy) {
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     call.execute();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
@@ -1188,10 +1203,12 @@ public void redirectUsingNewConnectionEventSequence() throws IOException {
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     call.execute();
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "DnsStart", "DnsEnd", "ConnectStart", "ConnectEnd",
+        "ResponseBodyEnd", "ConnectionReleased", "ProxySelectStart", "ProxySelectEnd",
+        "DnsStart", "DnsEnd", "ConnectStart", "ConnectEnd",
         "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
         "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
         "CallEnd");
@@ -1214,7 +1231,8 @@ public void redirectUsingNewConnectionEventSequence() throws IOException {
     Response response = call.execute();
     assertThat(response.body().string()).isEqualTo("b");
 
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
+        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
@@ -1232,7 +1250,7 @@ public void redirectUsingNewConnectionEventSequence() throws IOException {
             .protocol(Protocol.HTTP_1_1)
             .code(200)
             .message("OK")
-            .body(ResponseBody.create(null, "a"))
+            .body(ResponseBody.create("a", null))
             .build())
         .build();
 
@@ -1251,14 +1269,14 @@ public void redirectUsingNewConnectionEventSequence() throws IOException {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .post(RequestBody.create("abc", MediaType.get("text/plain")))
         .build();
 
     Call call = client.newCall(request);
     call.execute();
 
     assertThat(listener.recordedEventTypes()).containsExactly(
-        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "CallStart", "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd", "ConnectStart",
         "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
         "ResponseHeadersStart", "RequestBodyStart", "RequestBodyEnd", "ResponseHeadersEnd",
         "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
diff --git a/okhttp/src/test/java/okhttp3/HeadersKotlinTest.kt b/okhttp/src/test/java/okhttp3/HeadersKotlinTest.kt
new file mode 100644
index 0000000000..73b54ff1dd
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/HeadersKotlinTest.kt
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.Headers.Companion.headersOf
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import java.time.Instant
+import java.util.Date
+
+class HeadersKotlinTest {
+  @Test fun getOperator() {
+    val headers = headersOf("a", "b", "c", "d")
+    assertThat(headers["a"]).isEqualTo("b")
+    assertThat(headers["c"]).isEqualTo("d")
+    assertThat(headers["e"]).isNull()
+  }
+
+  @Test fun iteratorOperator() {
+    val headers = headersOf("a", "b", "c", "d")
+
+    val pairs = mutableListOf<Pair<String, String>>()
+    for ((name, value) in headers) {
+      pairs += name to value
+    }
+
+    assertThat(pairs).containsExactly("a" to "b", "c" to "d")
+  }
+
+  @Test fun builderGetOperator() {
+    val builder = Headers.Builder()
+    builder.add("a", "b")
+    builder.add("c", "d")
+    assertThat(builder["a"]).isEqualTo("b")
+    assertThat(builder["c"]).isEqualTo("d")
+    assertThat(builder["e"]).isNull()
+  }
+
+  @Test fun builderSetOperator() {
+    val builder = Headers.Builder()
+    builder["a"] = "b"
+    builder["c"] = "d"
+    builder["e"] = Date(0L)
+    builder["g"] = Instant.EPOCH
+    assertThat(builder.get("a")).isEqualTo("b")
+    assertThat(builder.get("c")).isEqualTo("d")
+    assertThat(builder.get("e")).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT")
+    assertThat(builder.get("g")).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT")
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/HeadersTest.java b/okhttp/src/test/java/okhttp3/HeadersTest.java
index b5e14f7dd7..4e10c46c12 100644
--- a/okhttp/src/test/java/okhttp3/HeadersTest.java
+++ b/okhttp/src/test/java/okhttp3/HeadersTest.java
@@ -22,7 +22,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import okhttp3.internal.Internal;
+import kotlin.TypeCastException;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http2.Header;
@@ -39,11 +39,7 @@
 import static org.junit.Assert.fail;
 
 public final class HeadersTest {
-  static {
-    Internal.initializeInstanceForTests();
-  }
-
-  @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
+  @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() {
     Headers headerBlock = Headers.of(
         ":status", "200 OK",
         ":version", "HTTP/1.1",
@@ -205,7 +201,7 @@
     try {
       Headers.of(Collections.singletonMap("User-Agent", null));
       fail();
-    } catch (NullPointerException expected) {
+    } catch (TypeCastException expected) {
     }
   }
 
diff --git a/okhttp/src/test/java/okhttp3/InterceptorTest.java b/okhttp/src/test/java/okhttp3/InterceptorTest.java
index 9ee8261d96..5428f06acd 100644
--- a/okhttp/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp/src/test/java/okhttp3/InterceptorTest.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.net.InetAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketTimeoutException;
@@ -38,6 +39,7 @@
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -48,9 +50,13 @@
   @Rule public MockWebServer server = new MockWebServer();
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
-  private OkHttpClient client = clientTestRule.client;
+  private OkHttpClient client;
   private RecordingCallback callback = new RecordingCallback();
 
+  @Before public void setUp() {
+    client = clientTestRule.newClient();
+  }
+
   @Test public void applicationInterceptorsCanShortCircuitResponses() throws Exception {
     server.shutdown(); // Accept no connections.
 
@@ -63,7 +69,7 @@
         .protocol(Protocol.HTTP_1_1)
         .code(200)
         .message("Intercepted!")
-        .body(ResponseBody.create(MediaType.get("text/plain; charset=utf-8"), "abc"))
+        .body(ResponseBody.create("abc", MediaType.get("text/plain; charset=utf-8")))
         .build();
 
     client = client.newBuilder()
@@ -82,7 +88,7 @@
         .protocol(Protocol.HTTP_1_1)
         .code(200)
         .message("Intercepted!")
-        .body(ResponseBody.create(MediaType.get("text/plain; charset=utf-8"), "abc"))
+        .body(ResponseBody.create("abc", MediaType.get("text/plain; charset=utf-8")))
         .build();
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -215,7 +221,7 @@
     Interceptor interceptor = chain -> {
       Request originalRequest = chain.request();
       MediaType mediaType = MediaType.get("text/plain");
-      RequestBody body = RequestBody.create(mediaType, "abc");
+      RequestBody body = RequestBody.create("abc", mediaType);
       return chain.proceed(originalRequest.newBuilder()
           .method("POST", body)
           .header("Content-Type", mediaType.toString())
@@ -260,7 +266,7 @@ private void rewriteRequestToServer(boolean network) throws Exception {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .addHeader("Original-Header", "foo")
-        .method("PUT", RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .method("PUT", RequestBody.create("abc", MediaType.get("text/plain")))
         .build();
 
     client.newCall(request).execute();
@@ -679,7 +685,8 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       return chain.proceed(chain.request());
     };
 
-    ServerSocket serverSocket = new ServerSocket(0, 1);
+    InetAddress localhost = InetAddress.getLoopbackAddress();
+    ServerSocket serverSocket = new ServerSocket(0, 1, localhost);
     // Fill backlog queue with this request so subsequent requests will be blocked.
     new Socket().connect(serverSocket.getLocalSocketAddress());
 
@@ -774,7 +781,7 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
     byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
     Request request1 = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.get("text/plain"), data))
+        .post(RequestBody.create(data, MediaType.get("text/plain")))
         .build();
     Call call = client.newCall(request1);
 
@@ -845,8 +852,8 @@ private Sink uppercase(BufferedSink original) {
   }
 
   static ResponseBody uppercase(ResponseBody original) throws IOException {
-    return ResponseBody.create(original.contentType(), original.contentLength(),
-        Okio.buffer(uppercase(original.source())));
+    return ResponseBody.create(Okio.buffer(uppercase(original.source())),
+        original.contentType(), original.contentLength());
   }
 
   private static Source uppercase(Source original) {
diff --git a/okhttp/src/test/java/okhttp3/KotlinSourceCompatibilityTest.kt b/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt
similarity index 74%
rename from okhttp/src/test/java/okhttp3/KotlinSourceCompatibilityTest.kt
rename to okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt
index 294036ae0a..36d1da59b5 100644
--- a/okhttp/src/test/java/okhttp3/KotlinSourceCompatibilityTest.kt
+++ b/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt
@@ -15,6 +15,17 @@
  */
 package okhttp3
 
+import okhttp3.Handshake.Companion.handshake
+import okhttp3.Headers.Companion.headersOf
+import okhttp3.Headers.Companion.toHeaders
+import okhttp3.HttpUrl.Companion.toHttpUrl
+import okhttp3.HttpUrl.Companion.toHttpUrlOrNull
+import okhttp3.MediaType.Companion.toMediaType
+import okhttp3.MediaType.Companion.toMediaTypeOrNull
+import okhttp3.RequestBody.Companion.toRequestBody
+import okhttp3.RequestBody.Companion.asRequestBody
+import okhttp3.ResponseBody.Companion.toResponseBody
+import okhttp3.ResponseBody.Companion.asResponseBody
 import okhttp3.internal.http2.Settings
 import okhttp3.internal.proxy.NullProxySelector
 import okhttp3.internal.tls.OkHostnameVerifier
@@ -70,36 +81,32 @@ import javax.net.ssl.X509TrustManager
 
 /**
  * Access every type, function, and property from Kotlin to defend against unexpected regressions in
- * source-compatibility.
- *
- * Unlike most tests we're only really interested in whether this test compiles: it's output is not
- * interesting. Do not simplify this code by removing unused declarations or unnecessary types;
- * doing so limits the utility of the test.
+ * modern 4.0.x kotlin source-compatibility.
  */
 @Suppress(
     "ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE",
-    "DEPRECATION",
-    "RedundantExplicitType",
-    "RedundantLambdaArrow",
     "UNUSED_ANONYMOUS_PARAMETER",
     "UNUSED_VALUE",
     "UNUSED_VARIABLE",
-    "VARIABLE_WITH_REDUNDANT_INITIALIZER"
+    "VARIABLE_WITH_REDUNDANT_INITIALIZER",
+    "RedundantLambdaArrow",
+    "RedundantExplicitType",
+    "IMPLICIT_NOTHING_AS_TYPE_PARAMETER"
 )
-class KotlinSourceCompatibilityTest {
+class KotlinSourceModernTest {
   @Test @Ignore
   fun address() {
     val address: Address = newAddress()
-    val url: HttpUrl = address.url()
-    val dns: Dns = address.dns()
-    val socketFactory: SocketFactory = address.socketFactory()
-    val proxyAuthenticator: Authenticator = address.proxyAuthenticator()
-    val protocols: List<Protocol> = address.protocols()
-    val connectionSpecs: List<ConnectionSpec> = address.connectionSpecs()
-    val proxySelector: ProxySelector = address.proxySelector()
-    val sslSocketFactory: SSLSocketFactory? = address.sslSocketFactory()
-    val hostnameVerifier: HostnameVerifier? = address.hostnameVerifier()
-    val certificatePinner: CertificatePinner? = address.certificatePinner()
+    val url: HttpUrl = address.url
+    val dns: Dns = address.dns
+    val socketFactory: SocketFactory = address.socketFactory
+    val proxyAuthenticator: Authenticator = address.proxyAuthenticator
+    val protocols: List<Protocol> = address.protocols
+    val connectionSpecs: List<ConnectionSpec> = address.connectionSpecs
+    val proxySelector: ProxySelector = address.proxySelector
+    val sslSocketFactory: SSLSocketFactory? = address.sslSocketFactory
+    val hostnameVerifier: HostnameVerifier? = address.hostnameVerifier
+    val certificatePinner: CertificatePinner? = address.certificatePinner
   }
 
   @Test @Ignore
@@ -107,7 +114,6 @@ class KotlinSourceCompatibilityTest {
     var authenticator: Authenticator = object : Authenticator {
       override fun authenticate(route: Route?, response: Response): Request? = TODO()
     }
-    authenticator = Authenticator { route: Route?, response: Response -> TODO() }
   }
 
   @Test @Ignore
@@ -123,7 +129,7 @@ class KotlinSourceCompatibilityTest {
     val maxSize: Long = cache.maxSize()
     cache.flush()
     cache.close()
-    val directory: File = cache.directory()
+    val directory: File = cache.directory
     val networkCount: Int = cache.networkCount()
     val hitCount: Int = cache.hitCount()
     val requestCount: Int = cache.requestCount()
@@ -132,19 +138,19 @@ class KotlinSourceCompatibilityTest {
   @Test @Ignore
   fun cacheControl() {
     val cacheControl: CacheControl = CacheControl.Builder().build()
-    val noCache: Boolean = cacheControl.noCache()
-    val noStore: Boolean = cacheControl.noStore()
-    val maxAgeSeconds: Int = cacheControl.maxAgeSeconds()
-    val sMaxAgeSeconds: Int = cacheControl.sMaxAgeSeconds()
-    val mustRevalidate: Boolean = cacheControl.mustRevalidate()
-    val maxStaleSeconds: Int = cacheControl.maxStaleSeconds()
-    val minFreshSeconds: Int = cacheControl.minFreshSeconds()
-    val onlyIfCached: Boolean = cacheControl.onlyIfCached()
-    val noTransform: Boolean = cacheControl.noTransform()
-    val immutable: Boolean = cacheControl.immutable()
+    val noCache: Boolean = cacheControl.noCache
+    val noStore: Boolean = cacheControl.noStore
+    val maxAgeSeconds: Int = cacheControl.maxAgeSeconds
+    val sMaxAgeSeconds: Int = cacheControl.sMaxAgeSeconds
+    val mustRevalidate: Boolean = cacheControl.mustRevalidate
+    val maxStaleSeconds: Int = cacheControl.maxStaleSeconds
+    val minFreshSeconds: Int = cacheControl.minFreshSeconds
+    val onlyIfCached: Boolean = cacheControl.onlyIfCached
+    val noTransform: Boolean = cacheControl.noTransform
+    val immutable: Boolean = cacheControl.immutable
     val forceCache: CacheControl = CacheControl.FORCE_CACHE
     val forceNetwork: CacheControl = CacheControl.FORCE_NETWORK
-    val parse: CacheControl = CacheControl.parse(Headers.of())
+    val parse: CacheControl = CacheControl.parse(headersOf())
   }
 
   @Test @Ignore
@@ -177,11 +183,11 @@ class KotlinSourceCompatibilityTest {
   @Test @Ignore
   fun certificatePinner() {
     val heldCertificate: HeldCertificate = HeldCertificate.Builder().build()
-    val certificate: X509Certificate = heldCertificate.certificate()
+    val certificate: X509Certificate = heldCertificate.certificate
     val certificatePinner: CertificatePinner = CertificatePinner.Builder().build()
     val certificates: List<Certificate> = listOf()
     certificatePinner.check("", listOf(certificate))
-    certificatePinner.check("", certificate, certificate)
+    certificatePinner.check("", arrayOf<Certificate>(certificate, certificate).toList())
     val pin: String = CertificatePinner.pin(certificate)
     val default: CertificatePinner = CertificatePinner.DEFAULT
   }
@@ -196,10 +202,10 @@ class KotlinSourceCompatibilityTest {
   fun challenge() {
     var challenge = Challenge("", mapOf<String?, String>("" to ""))
     challenge = Challenge("", "")
-    val scheme: String = challenge.scheme()
-    val authParams: Map<String?, String> = challenge.authParams()
-    val realm: String? = challenge.realm()
-    val charset: Charset = challenge.charset()
+    val scheme: String = challenge.scheme
+    val authParams: Map<String?, String> = challenge.authParams
+    val realm: String? = challenge.realm
+    val charset: Charset = challenge.charset
     val utf8: Challenge = challenge.withCharset(Charsets.UTF_8)
   }
 
@@ -207,7 +213,7 @@ class KotlinSourceCompatibilityTest {
   fun cipherSuite() {
     var cipherSuite: CipherSuite = CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
     cipherSuite = CipherSuite.forJavaName("")
-    val javaName: String = cipherSuite.javaName()
+    val javaName: String = cipherSuite.javaName
   }
 
   @Test @Ignore
@@ -235,9 +241,9 @@ class KotlinSourceCompatibilityTest {
     connectionSpec = ConnectionSpec.MODERN_TLS
     connectionSpec = ConnectionSpec.COMPATIBLE_TLS
     connectionSpec = ConnectionSpec.CLEARTEXT
-    val tlsVersions: List<TlsVersion>? = connectionSpec.tlsVersions()
-    val cipherSuites: List<CipherSuite>? = connectionSpec.cipherSuites()
-    val supportsTlsExtensions: Boolean = connectionSpec.supportsTlsExtensions()
+    val tlsVersions: List<TlsVersion>? = connectionSpec.tlsVersions
+    val cipherSuites: List<CipherSuite>? = connectionSpec.cipherSuites
+    val supportsTlsExtensions: Boolean = connectionSpec.supportsTlsExtensions
     val compatible: Boolean = connectionSpec.isCompatible(
         localhost().sslSocketFactory().createSocket() as SSLSocket)
   }
@@ -251,25 +257,24 @@ class KotlinSourceCompatibilityTest {
     builder = builder.allEnabledTlsVersions()
     builder = builder.tlsVersions(TlsVersion.TLS_1_3)
     builder = builder.tlsVersions("", "")
-    builder = builder.supportsTlsExtensions(false)
     val connectionSpec: ConnectionSpec = builder.build()
   }
 
   @Test @Ignore
   fun cookie() {
     val cookie: Cookie = Cookie.Builder().build()
-    val name: String = cookie.name()
-    val value: String = cookie.value()
-    val persistent: Boolean = cookie.persistent()
-    val expiresAt: Long = cookie.expiresAt()
-    val hostOnly: Boolean = cookie.hostOnly()
-    val domain: String = cookie.domain()
-    val path: String = cookie.path()
-    val httpOnly: Boolean = cookie.httpOnly()
-    val secure: Boolean = cookie.secure()
-    val matches: Boolean = cookie.matches(HttpUrl.get(""))
-    val parsedCookie: Cookie? = Cookie.parse(HttpUrl.get(""), "")
-    val cookies: List<Cookie> = Cookie.parseAll(HttpUrl.get(""), Headers.of())
+    val name: String = cookie.name
+    val value: String = cookie.value
+    val persistent: Boolean = cookie.persistent
+    val expiresAt: Long = cookie.expiresAt
+    val hostOnly: Boolean = cookie.hostOnly
+    val domain: String = cookie.domain
+    val path: String = cookie.path
+    val httpOnly: Boolean = cookie.httpOnly
+    val secure: Boolean = cookie.secure
+    val matches: Boolean = cookie.matches("".toHttpUrl())
+    val parsedCookie: Cookie? = Cookie.parse("".toHttpUrl(), "")
+    val cookies: List<Cookie> = Cookie.parseAll("".toHttpUrl(), headersOf())
   }
 
   @Test @Ignore
@@ -307,11 +312,8 @@ class KotlinSourceCompatibilityTest {
     dispatcher.maxRequests = 0
     val maxRequestsPerHost: Int = dispatcher.maxRequestsPerHost
     dispatcher.maxRequestsPerHost = 0
-    val executorService: ExecutorService = dispatcher.executorService()
-    dispatcher.setIdleCallback(object : Runnable {
-      override fun run() = TODO()
-    })
-    dispatcher.setIdleCallback { TODO() }
+    val executorService: ExecutorService = dispatcher.executorService
+    dispatcher.idleCallback = Runnable { ({ TODO() })() }
     val queuedCalls: List<Call> = dispatcher.queuedCalls()
     val runningCalls: List<Call> = dispatcher.runningCalls()
     val queuedCallsCount: Int = dispatcher.queuedCallsCount()
@@ -333,7 +335,6 @@ class KotlinSourceCompatibilityTest {
     var dns: Dns = object : Dns {
       override fun lookup(hostname: String): List<InetAddress> = TODO()
     }
-    dns = Dns { it: String -> TODO() }
 
     val system: Dns = Dns.SYSTEM
   }
@@ -395,13 +396,12 @@ class KotlinSourceCompatibilityTest {
     var builder: EventListener.Factory = object : EventListener.Factory {
       override fun create(call: Call): EventListener = TODO()
     }
-    builder = EventListener.Factory { it: Call -> TODO() }
   }
 
   @Test @Ignore
   fun formBody() {
     val formBody: FormBody = FormBody.Builder().build()
-    val size: Int = formBody.size()
+    val size: Int = formBody.size
     val encodedName: String = formBody.encodedName(0)
     val name: String = formBody.name(0)
     val encodedValue: String = formBody.encodedValue(0)
@@ -424,7 +424,7 @@ class KotlinSourceCompatibilityTest {
   @Test @Ignore
   fun handshake() {
     var handshake: Handshake =
-        Handshake.get((localhost().sslSocketFactory().createSocket() as SSLSocket).session)
+        (localhost().sslSocketFactory().createSocket() as SSLSocket).session.handshake()
     val listOfCertificates: List<Certificate> = listOf()
     handshake = Handshake.get(
         TlsVersion.TLS_1_3,
@@ -432,22 +432,22 @@ class KotlinSourceCompatibilityTest {
         listOfCertificates,
         listOfCertificates
     )
-    val tlsVersion: TlsVersion = handshake.tlsVersion()
-    val cipherSuite: CipherSuite = handshake.cipherSuite()
-    val peerCertificates: List<Certificate> = handshake.peerCertificates()
-    val peerPrincipal: Principal? = handshake.peerPrincipal()
-    val localCertificates: List<Certificate> = handshake.localCertificates()
-    val localPrincipal: Principal? = handshake.localPrincipal()
+    val tlsVersion: TlsVersion = handshake.tlsVersion
+    val cipherSuite: CipherSuite = handshake.cipherSuite
+    val peerCertificates: List<Certificate> = handshake.peerCertificates
+    val peerPrincipal: Principal? = handshake.peerPrincipal
+    val localCertificates: List<Certificate> = handshake.localCertificates
+    val localPrincipal: Principal? = handshake.localPrincipal
   }
 
   @Test @Ignore
   fun headers() {
-    var headers: Headers = Headers.of("", "")
-    headers = Headers.of(mapOf("" to ""))
+    var headers: Headers = headersOf("", "")
+    headers = mapOf("" to "").toHeaders()
     val get: String? = headers.get("")
     val date: Date? = headers.getDate("")
     val instant: Instant? = headers.getInstant("")
-    val size: Int = headers.size()
+    val size: Int = headers.size
     val name: String = headers.name(0)
     val value: String = headers.value(0)
     val names: Set<String> = headers.names()
@@ -463,7 +463,7 @@ class KotlinSourceCompatibilityTest {
     builder = builder.add("")
     builder = builder.add("", "")
     builder = builder.addUnsafeNonAscii("", "")
-    builder = builder.addAll(Headers.of())
+    builder = builder.addAll(headersOf())
     builder = builder.add("", Date(0L))
     builder = builder.add("", Instant.EPOCH)
     builder = builder.set("", "")
@@ -480,9 +480,7 @@ class KotlinSourceCompatibilityTest {
     interceptor = HttpLoggingInterceptor(HttpLoggingInterceptor.Logger.DEFAULT)
     interceptor.redactHeader("")
     interceptor.level = HttpLoggingInterceptor.Level.BASIC
-    interceptor.setLevel(HttpLoggingInterceptor.Level.BASIC)
     var level: HttpLoggingInterceptor.Level = interceptor.level
-    level = interceptor.getLevel()
     interceptor.intercept(newInterceptorChain())
   }
 
@@ -499,45 +497,44 @@ class KotlinSourceCompatibilityTest {
     var logger: HttpLoggingInterceptor.Logger = object : HttpLoggingInterceptor.Logger {
       override fun log(message: String) = TODO()
     }
-    logger = HttpLoggingInterceptor.Logger { TODO() }
     val default: HttpLoggingInterceptor.Logger = HttpLoggingInterceptor.Logger.DEFAULT
   }
 
   @Test @Ignore
   fun httpUrl() {
-    val httpUrl: HttpUrl = HttpUrl.get("")
+    val httpUrl: HttpUrl = "".toHttpUrl()
     val isHttps: Boolean = httpUrl.isHttps
-    val url: URL = httpUrl.url()
-    val uri: URI = httpUrl.uri()
-    val scheme: String = httpUrl.scheme()
-    val encodedUsername: String = httpUrl.encodedUsername()
-    val username: String = httpUrl.username()
-    val encodedPassword: String = httpUrl.encodedPassword()
-    val password: String = httpUrl.password()
-    val host: String = httpUrl.host()
-    val port: Int = httpUrl.port()
-    val pathSize: Int = httpUrl.pathSize()
-    val encodedPath: String = httpUrl.encodedPath()
-    val encodedPathSegments: List<String> = httpUrl.encodedPathSegments()
-    val pathSegments: List<String> = httpUrl.pathSegments()
-    val encodedQuery: String? = httpUrl.encodedQuery()
-    val query: String? = httpUrl.query()
-    val querySize: Int = httpUrl.querySize()
+    val url: URL = httpUrl.toUrl()
+    val uri: URI = httpUrl.toUri()
+    val scheme: String = httpUrl.scheme
+    val encodedUsername: String = httpUrl.encodedUsername
+    val username: String = httpUrl.username
+    val encodedPassword: String = httpUrl.encodedPassword
+    val password: String = httpUrl.password
+    val host: String = httpUrl.host
+    val port: Int = httpUrl.port
+    val pathSize: Int = httpUrl.pathSize
+    val encodedPath: String = httpUrl.encodedPath
+    val encodedPathSegments: List<String> = httpUrl.encodedPathSegments
+    val pathSegments: List<String> = httpUrl.pathSegments
+    val encodedQuery: String? = httpUrl.encodedQuery
+    val query: String? = httpUrl.query
+    val querySize: Int = httpUrl.querySize
     val queryParameter: String? = httpUrl.queryParameter("")
-    val queryParameterNames: Set<String> = httpUrl.queryParameterNames()
+    val queryParameterNames: Set<String> = httpUrl.queryParameterNames
     val queryParameterValues: List<String?> = httpUrl.queryParameterValues("")
     val queryParameterName: String = httpUrl.queryParameterName(0)
     val queryParameterValue: String? = httpUrl.queryParameterValue(0)
-    val encodedFragment: String? = httpUrl.encodedFragment()
-    val fragment: String? = httpUrl.fragment()
+    val encodedFragment: String? = httpUrl.encodedFragment
+    val fragment: String? = httpUrl.fragment
     val redact: String = httpUrl.redact()
     var builder: HttpUrl.Builder = httpUrl.newBuilder()
     var resolveBuilder: HttpUrl.Builder? = httpUrl.newBuilder("")
     val topPrivateDomain: String? = httpUrl.topPrivateDomain()
     val resolve: HttpUrl? = httpUrl.resolve("")
-    val getFromUrl: HttpUrl? = HttpUrl.get(URL(""))
-    val getFromUri: HttpUrl? = HttpUrl.get(URI(""))
-    val parse: HttpUrl? = HttpUrl.parse("")
+    val getFromUrl: HttpUrl? = URL("").toHttpUrlOrNull()
+    val getFromUri: HttpUrl? = URI("").toHttpUrlOrNull()
+    val parse: HttpUrl? = "".toHttpUrlOrNull()
     val defaultPort: Int = HttpUrl.defaultPort("")
   }
 
@@ -588,8 +585,8 @@ class KotlinSourceCompatibilityTest {
   @Test @Ignore
   fun handshakeCertificates() {
     val handshakeCertificates = HandshakeCertificates.Builder().build()
-    val keyManager: X509KeyManager = handshakeCertificates.keyManager()
-    val trustManager: X509TrustManager = handshakeCertificates.trustManager()
+    val keyManager: X509KeyManager = handshakeCertificates.keyManager
+    val trustManager: X509TrustManager = handshakeCertificates.trustManager
     val sslSocketFactory: SSLSocketFactory = handshakeCertificates.sslSocketFactory()
     val sslContext: SSLContext = handshakeCertificates.sslContext()
   }
@@ -598,8 +595,8 @@ class KotlinSourceCompatibilityTest {
   fun handshakeCertificatesBuilder() {
     var builder: HandshakeCertificates.Builder = HandshakeCertificates.Builder()
     val heldCertificate = HeldCertificate.Builder().build()
-    builder = builder.heldCertificate(heldCertificate, heldCertificate.certificate())
-    builder = builder.addTrustedCertificate(heldCertificate.certificate())
+    builder = builder.heldCertificate(heldCertificate, heldCertificate.certificate)
+    builder = builder.addTrustedCertificate(heldCertificate.certificate)
     builder = builder.addPlatformTrustedCertificates()
     val handshakeCertificates: HandshakeCertificates = builder.build()
   }
@@ -607,8 +604,8 @@ class KotlinSourceCompatibilityTest {
   @Test @Ignore
   fun heldCertificate() {
     val heldCertificate: HeldCertificate = HeldCertificate.Builder().build()
-    val certificate: X509Certificate = heldCertificate.certificate()
-    val keyPair: KeyPair = heldCertificate.keyPair()
+    val certificate: X509Certificate = heldCertificate.certificate
+    val keyPair: KeyPair = heldCertificate.keyPair
     val certificatePem: String = heldCertificate.certificatePem()
     val privateKeyPkcs8Pem: String = heldCertificate.privateKeyPkcs8Pem()
     val privateKeyPkcs1Pem: String = heldCertificate.privateKeyPkcs1Pem()
@@ -645,7 +642,7 @@ class KotlinSourceCompatibilityTest {
   @Test @Ignore
   fun javaNetCookieJar() {
     val cookieJar: JavaNetCookieJar = JavaNetCookieJar(newCookieHandler())
-    val httpUrl = HttpUrl.get("")
+    val httpUrl = "".toHttpUrl()
     val loadForRequest: List<Cookie> = cookieJar.loadForRequest(httpUrl)
     cookieJar.saveFromResponse(httpUrl, listOf(Cookie.Builder().build()))
   }
@@ -667,97 +664,87 @@ class KotlinSourceCompatibilityTest {
 
   @Test @Ignore
   fun mediaType() {
-    val mediaType: MediaType = MediaType.get("")
+    val mediaType: MediaType = "".toMediaType()
     val defaultCharset: Charset? = mediaType.charset()
     val charset: Charset? = mediaType.charset(Charsets.UTF_8)
-    val type: String = mediaType.type()
-    val subtype: String = mediaType.subtype()
-    val parse: MediaType? = MediaType.parse("")
+    val type: String = mediaType.type
+    val subtype: String = mediaType.subtype
+    val parse: MediaType? = "".toMediaTypeOrNull()
   }
 
   @Test @Ignore
   fun mockResponse() {
     var mockResponse: MockResponse = MockResponse()
-    var status: String = mockResponse.getStatus()
+    var status: String = mockResponse.status
     status = mockResponse.status
-    mockResponse = mockResponse.setStatus("")
     mockResponse.status = ""
     mockResponse = mockResponse.setResponseCode(0)
-    var headers: Headers = mockResponse.getHeaders()
-    headers = mockResponse.headers
-    var trailers: Headers = mockResponse.getTrailers()
-    trailers = mockResponse.trailers
+    var headers: Headers = mockResponse.headers
+    var trailers: Headers = mockResponse.trailers
     mockResponse = mockResponse.clearHeaders()
     mockResponse = mockResponse.addHeader("")
     mockResponse = mockResponse.addHeader("", "")
     mockResponse = mockResponse.addHeaderLenient("", Any())
     mockResponse = mockResponse.setHeader("", Any())
-    mockResponse = mockResponse.setHeaders(Headers.of())
-    mockResponse = mockResponse.setTrailers(Headers.of())
+    mockResponse.headers = headersOf()
+    mockResponse.trailers = headersOf()
     mockResponse = mockResponse.removeHeader("")
     var body: Buffer? = mockResponse.getBody()
-    body = mockResponse.body
     mockResponse = mockResponse.setBody(Buffer())
-    mockResponse.body = Buffer()
     mockResponse = mockResponse.setChunkedBody(Buffer(), 0)
     mockResponse = mockResponse.setChunkedBody("", 0)
-    var socketPolicy: SocketPolicy = mockResponse.getSocketPolicy()
-    socketPolicy = mockResponse.socketPolicy
-    mockResponse = mockResponse.setSocketPolicy(SocketPolicy.KEEP_OPEN)
-    var http2ErrorCode: Int = mockResponse.getHttp2ErrorCode()
-    http2ErrorCode = mockResponse.http2ErrorCode
-    mockResponse = mockResponse.setHttp2ErrorCode(0)
+    var socketPolicy: SocketPolicy = mockResponse.socketPolicy
+    mockResponse.socketPolicy = SocketPolicy.KEEP_OPEN
+    var http2ErrorCode: Int = mockResponse.http2ErrorCode
     mockResponse.http2ErrorCode = 0
     mockResponse = mockResponse.throttleBody(0L, 0L, TimeUnit.SECONDS)
-    var throttleBytesPerPeriod: Long = mockResponse.getThrottleBytesPerPeriod()
+    var throttleBytesPerPeriod: Long = mockResponse.throttleBytesPerPeriod
     throttleBytesPerPeriod = mockResponse.throttleBytesPerPeriod
     var throttlePeriod: Long = mockResponse.getThrottlePeriod(TimeUnit.SECONDS)
     mockResponse = mockResponse.setBodyDelay(0L, TimeUnit.SECONDS)
     val bodyDelay: Long = mockResponse.getBodyDelay(TimeUnit.SECONDS)
     mockResponse = mockResponse.setHeadersDelay(0L, TimeUnit.SECONDS)
     val headersDelay: Long = mockResponse.getHeadersDelay(TimeUnit.SECONDS)
-    mockResponse = mockResponse.withPush(PushPromise("", "", Headers.of(), MockResponse()))
-    var pushPromises: List<PushPromise> = mockResponse.getPushPromises()
+    mockResponse = mockResponse.withPush(PushPromise("", "", headersOf(), MockResponse()))
+    var pushPromises: List<PushPromise> = mockResponse.pushPromises
     pushPromises = mockResponse.pushPromises
     mockResponse = mockResponse.withSettings(Settings())
-    var settings: Settings = mockResponse.getSettings()
+    var settings: Settings = mockResponse.settings
     settings = mockResponse.settings
     mockResponse = mockResponse.withWebSocketUpgrade(object : WebSocketListener() {
     })
-    var webSocketListener: WebSocketListener = mockResponse.getWebSocketListener()
+    var webSocketListener: WebSocketListener? = mockResponse.webSocketListener
     webSocketListener = mockResponse.webSocketListener
   }
 
   @Test @Ignore
   fun mockWebServer() {
     val mockWebServer: MockWebServer = MockWebServer()
-    var port: Int = mockWebServer.getPort()
-    port = mockWebServer.port
-    var hostName: String = mockWebServer.getHostName()
+    var port: Int = mockWebServer.port
+    var hostName: String = mockWebServer.hostName
     hostName = mockWebServer.hostName
     val toProxyAddress: Proxy = mockWebServer.toProxyAddress()
-    mockWebServer.setServerSocketFactory(ServerSocketFactory.getDefault())
+    mockWebServer.serverSocketFactory = ServerSocketFactory.getDefault()
     val url: HttpUrl = mockWebServer.url("")
-    mockWebServer.setBodyLimit(0L)
-    mockWebServer.setProtocolNegotiationEnabled(false)
-    mockWebServer.setProtocols(listOf<Protocol>())
-    val protocols: List<Protocol> = mockWebServer.protocols()
-    mockWebServer.useHttps(SSLSocketFactory.getDefault() as SSLSocketFactory?, false)
+    mockWebServer.bodyLimit = 0L
+    mockWebServer.protocolNegotiationEnabled = false
+    mockWebServer.protocols = listOf()
+    val protocols: List<Protocol> = mockWebServer.protocols
+    mockWebServer.useHttps(SSLSocketFactory.getDefault() as SSLSocketFactory, false)
     mockWebServer.noClientAuth()
     mockWebServer.requestClientAuth()
     mockWebServer.requireClientAuth()
-    var request: RecordedRequest = mockWebServer.takeRequest()
-    request = mockWebServer.takeRequest(0L, TimeUnit.SECONDS)
-    var requestCount: Int = mockWebServer.getRequestCount()
-    requestCount = mockWebServer.requestCount
+    val request: RecordedRequest = mockWebServer.takeRequest()
+    val nullableRequest: RecordedRequest? = mockWebServer.takeRequest(0L, TimeUnit.SECONDS)
+    var requestCount: Int = mockWebServer.requestCount
     mockWebServer.enqueue(MockResponse())
     mockWebServer.start()
     mockWebServer.start(0)
     mockWebServer.start(InetAddress.getLocalHost(), 0)
     mockWebServer.shutdown()
-    var dispatcher: okhttp3.mockwebserver.Dispatcher = mockWebServer.getDispatcher()
+    var dispatcher: okhttp3.mockwebserver.Dispatcher = mockWebServer.dispatcher
     dispatcher = mockWebServer.dispatcher
-    mockWebServer.setDispatcher(QueueDispatcher())
+    mockWebServer.dispatcher = QueueDispatcher()
     mockWebServer.dispatcher = QueueDispatcher()
     mockWebServer.close()
   }
@@ -765,10 +752,10 @@ class KotlinSourceCompatibilityTest {
   @Test @Ignore
   fun multipartBody() {
     val multipartBody: MultipartBody = MultipartBody.Builder().build()
-    val type: MediaType = multipartBody.type()
-    val boundary: String = multipartBody.boundary()
-    val size: Int = multipartBody.size()
-    val parts: List<MultipartBody.Part> = multipartBody.parts()
+    val type: MediaType = multipartBody.type
+    val boundary: String = multipartBody.boundary
+    val size: Int = multipartBody.size
+    val parts: List<MultipartBody.Part> = multipartBody.parts
     val part: MultipartBody.Part = multipartBody.part(0)
     val contentType: MediaType? = multipartBody.contentType()
     val contentLength: Long = multipartBody.contentLength()
@@ -782,25 +769,25 @@ class KotlinSourceCompatibilityTest {
 
   @Test @Ignore
   fun multipartBodyPart() {
-    val requestBody: RequestBody = RequestBody.create(null, "")
+    val requestBody: RequestBody = "".toRequestBody(null)
     var part: MultipartBody.Part = MultipartBody.Part.create(null, requestBody)
-    part = MultipartBody.Part.create(Headers.of(), requestBody)
+    part = MultipartBody.Part.create(headersOf(), requestBody)
     part = MultipartBody.Part.create(requestBody)
     part = MultipartBody.Part.createFormData("", "")
     part = MultipartBody.Part.createFormData("", "", requestBody)
     part = MultipartBody.Part.createFormData("", null, requestBody)
-    val headers: Headers? = part.headers()
-    val body: RequestBody = part.body()
+    val headers: Headers? = part.headers
+    val body: RequestBody = part.body
   }
 
   @Test @Ignore
   fun multipartBodyBuilder() {
-    val requestBody = RequestBody.create(null, "")
+    val requestBody = "".toRequestBody(null)
     var builder: MultipartBody.Builder = MultipartBody.Builder()
     builder = MultipartBody.Builder("")
-    builder = builder.setType(MediaType.get(""))
+    builder = builder.setType("".toMediaType())
     builder = builder.addPart(requestBody)
-    builder = builder.addPart(Headers.of(), requestBody)
+    builder = builder.addPart(headersOf(), requestBody)
     builder = builder.addPart(null, requestBody)
     builder = builder.addFormDataPart("", "")
     builder = builder.addFormDataPart("", "", requestBody)
@@ -812,32 +799,32 @@ class KotlinSourceCompatibilityTest {
   @Test @Ignore
   fun okHttpClient() {
     val client: OkHttpClient = OkHttpClient()
-    val dispatcher: Dispatcher = client.dispatcher()
-    val proxy: Proxy? = client.proxy()
-    val protocols: List<Protocol> = client.protocols()
-    val connectionSpecs: List<ConnectionSpec> = client.connectionSpecs()
-    val interceptors: List<Interceptor> = client.interceptors()
-    val networkInterceptors: List<Interceptor> = client.networkInterceptors()
-    val eventListenerFactory: EventListener.Factory = client.eventListenerFactory()
-    val proxySelector: ProxySelector = client.proxySelector()
-    val cookieJar: CookieJar = client.cookieJar()
-    val cache: Cache? = client.cache()
-    val socketFactory: SocketFactory = client.socketFactory()
-    val sslSocketFactory: SSLSocketFactory = client.sslSocketFactory()
-    val hostnameVerifier: HostnameVerifier = client.hostnameVerifier()
-    val certificatePinner: CertificatePinner = client.certificatePinner()
-    val proxyAuthenticator: Authenticator = client.proxyAuthenticator()
-    val authenticator: Authenticator = client.authenticator()
-    val connectionPool: ConnectionPool = client.connectionPool()
-    val dns: Dns = client.dns()
-    val followSslRedirects: Boolean = client.followSslRedirects()
-    val followRedirects: Boolean = client.followRedirects()
-    val retryOnConnectionFailure: Boolean = client.retryOnConnectionFailure()
-    val callTimeoutMillis: Int = client.callTimeoutMillis()
-    val connectTimeoutMillis: Int = client.connectTimeoutMillis()
-    val readTimeoutMillis: Int = client.readTimeoutMillis()
-    val writeTimeoutMillis: Int = client.writeTimeoutMillis()
-    val pingIntervalMillis: Int = client.pingIntervalMillis()
+    val dispatcher: Dispatcher = client.dispatcher
+    val proxy: Proxy? = client.proxy
+    val protocols: List<Protocol> = client.protocols
+    val connectionSpecs: List<ConnectionSpec> = client.connectionSpecs
+    val interceptors: List<Interceptor> = client.interceptors
+    val networkInterceptors: List<Interceptor> = client.networkInterceptors
+    val eventListenerFactory: EventListener.Factory = client.eventListenerFactory
+    val proxySelector: ProxySelector = client.proxySelector
+    val cookieJar: CookieJar = client.cookieJar
+    val cache: Cache? = client.cache
+    val socketFactory: SocketFactory = client.socketFactory
+    val sslSocketFactory: SSLSocketFactory = client.sslSocketFactory
+    val hostnameVerifier: HostnameVerifier = client.hostnameVerifier
+    val certificatePinner: CertificatePinner = client.certificatePinner
+    val proxyAuthenticator: Authenticator = client.proxyAuthenticator
+    val authenticator: Authenticator = client.authenticator
+    val connectionPool: ConnectionPool = client.connectionPool
+    val dns: Dns = client.dns
+    val followSslRedirects: Boolean = client.followSslRedirects
+    val followRedirects: Boolean = client.followRedirects
+    val retryOnConnectionFailure: Boolean = client.retryOnConnectionFailure
+    val callTimeoutMillis: Int = client.callTimeoutMillis
+    val connectTimeoutMillis: Int = client.connectTimeoutMillis
+    val readTimeoutMillis: Int = client.readTimeoutMillis
+    val writeTimeoutMillis: Int = client.writeTimeoutMillis
+    val pingIntervalMillis: Int = client.pingIntervalMillis
     val call: Call = client.newCall(Request.Builder().build())
     val webSocket: WebSocket = client.newWebSocket(
         Request.Builder().build(),
@@ -865,7 +852,7 @@ class KotlinSourceCompatibilityTest {
     builder = builder.cache(Cache(File("/cache/"), Integer.MAX_VALUE.toLong()))
     builder = builder.dns(Dns.SYSTEM)
     builder = builder.socketFactory(SocketFactory.getDefault())
-    builder = builder.sslSocketFactory(localhost().sslSocketFactory(), localhost().trustManager())
+    builder = builder.sslSocketFactory(localhost().sslSocketFactory(), localhost().trustManager)
     builder = builder.hostnameVerifier(OkHostnameVerifier)
     builder = builder.certificatePinner(CertificatePinner.DEFAULT)
     builder = builder.authenticator(Authenticator.NONE)
@@ -891,8 +878,6 @@ class KotlinSourceCompatibilityTest {
     builder = builder.eventListenerFactory(object : EventListener.Factory {
       override fun create(call: Call): EventListener = TODO()
     })
-    builder = builder.eventListenerFactory(LoggingEventListener.Factory { s -> TODO() })
-    builder = builder.eventListenerFactory { it: Call -> TODO() }
     val client: OkHttpClient = builder.build()
   }
 
@@ -914,11 +899,11 @@ class KotlinSourceCompatibilityTest {
 
   @Test @Ignore
   fun pushPromise() {
-    val pushPromise: PushPromise = PushPromise("", "", Headers.of(), MockResponse())
-    val method: String = pushPromise.method()
-    val path: String = pushPromise.path()
-    val headers: Headers = pushPromise.headers()
-    val response: MockResponse = pushPromise.response()
+    val pushPromise: PushPromise = PushPromise("", "", headersOf(), MockResponse())
+    val method: String = pushPromise.method
+    val path: String = pushPromise.path
+    val headers: Headers = pushPromise.headers
+    val response: MockResponse = pushPromise.response
   }
 
   @Test @Ignore
@@ -933,7 +918,7 @@ class KotlinSourceCompatibilityTest {
     }
     queueDispatcher = QueueDispatcher()
     var mockResponse: MockResponse = queueDispatcher.dispatch(
-        RecordedRequest("", Headers.of(), listOf(), 0L, Buffer(), 0, Socket()))
+        RecordedRequest("", headersOf(), listOf(), 0L, Buffer(), 0, Socket()))
     mockResponse = queueDispatcher.peek()
     queueDispatcher.enqueueResponse(MockResponse())
     queueDispatcher.shutdown()
@@ -944,62 +929,50 @@ class KotlinSourceCompatibilityTest {
   @Test @Ignore
   fun recordedRequest() {
     var recordedRequest: RecordedRequest = RecordedRequest(
-        "", Headers.of(), listOf(), 0L, Buffer(), 0, Socket())
-    recordedRequest = RecordedRequest(null, null, null, 0L, null, 0, Socket())
-    var requestUrl: HttpUrl? = recordedRequest.getRequestUrl()
-    var requestLine: String? = recordedRequest.getRequestLine()
-    var method: String? = recordedRequest.getMethod()
-    var path: String? = recordedRequest.getPath()
-    var headers: Headers? = recordedRequest.getHeaders()
+        "", headersOf(), listOf(), 0L, Buffer(), 0, Socket())
+    recordedRequest = RecordedRequest("", headersOf(), listOf(), 0L, Buffer(), 0, Socket())
+    var requestUrl: HttpUrl? = recordedRequest.requestUrl
+    var requestLine: String = recordedRequest.requestLine
+    var method: String? = recordedRequest.method
+    var path: String? = recordedRequest.path
+    var headers: Headers = recordedRequest.headers
     val header: String? = recordedRequest.getHeader("")
-    var chunkSizes: List<Int>? = recordedRequest.getChunkSizes()
-    var bodySize: Long = recordedRequest.getBodySize()
-    var body: Buffer? = recordedRequest.getBody()
-    var utf8Body: String = recordedRequest.getUtf8Body()
-    var sequenceNumber: Int = recordedRequest.getSequenceNumber()
-    var tlsVersion: TlsVersion = recordedRequest.getTlsVersion()
-    var handshake: Handshake = recordedRequest.getHandshake()
-    requestUrl = recordedRequest.requestUrl
-    requestLine = recordedRequest.requestLine
-    method = recordedRequest.method
-    path = recordedRequest.path
-    headers = recordedRequest.headers
-    chunkSizes = recordedRequest.chunkSizes
-    bodySize = recordedRequest.bodySize
-    body = recordedRequest.body
-    utf8Body = recordedRequest.utf8Body
-    sequenceNumber = recordedRequest.sequenceNumber
-    tlsVersion = recordedRequest.tlsVersion
-    handshake = recordedRequest.handshake
+    var chunkSizes: List<Int> = recordedRequest.chunkSizes
+    var bodySize: Long = recordedRequest.bodySize
+    var body: Buffer = recordedRequest.body
+    var utf8Body: String = recordedRequest.body.readUtf8()
+    var sequenceNumber: Int = recordedRequest.sequenceNumber
+    var tlsVersion: TlsVersion? = recordedRequest.tlsVersion
+    var handshake: Handshake? = recordedRequest.handshake
   }
 
   @Test @Ignore
   fun request() {
     val request: Request = Request.Builder().build()
     val isHttps: Boolean = request.isHttps
-    val url: HttpUrl = request.url()
-    val method: String = request.method()
-    val headers: Headers = request.headers()
+    val url: HttpUrl = request.url
+    val method: String = request.method
+    val headers: Headers = request.headers
     val header: String? = request.header("")
     val headersForName: List<String> = request.headers("")
-    val body: RequestBody? = request.body()
+    val body: RequestBody? = request.body
     var tag: Any? = request.tag()
     tag = request.tag(Any::class.java)
     val builder: Request.Builder = request.newBuilder()
-    val cacheControl: CacheControl = request.cacheControl()
+    val cacheControl: CacheControl = request.cacheControl
   }
 
   @Test @Ignore
   fun requestBuilder() {
-    val requestBody = RequestBody.create(null, "")
+    val requestBody = "".toRequestBody(null)
     var builder = Request.Builder()
-    builder = builder.url(HttpUrl.get(""))
+    builder = builder.url("".toHttpUrl())
     builder = builder.url("")
     builder = builder.url(URL(""))
     builder = builder.header("", "")
     builder = builder.addHeader("", "")
     builder = builder.removeHeader("")
-    builder = builder.headers(Headers.of())
+    builder = builder.headers(headersOf())
     builder = builder.cacheControl(CacheControl.FORCE_CACHE)
     builder = builder.get()
     builder = builder.head()
@@ -1026,42 +999,42 @@ class KotlinSourceCompatibilityTest {
       override fun isOneShot(): Boolean = TODO()
       override fun writeTo(sink: BufferedSink) = TODO()
     }
-    requestBody = RequestBody.create(null, "")
-    requestBody = RequestBody.create(MediaType.parse(""), "")
-    requestBody = RequestBody.create(null, ByteString.EMPTY)
-    requestBody = RequestBody.create(MediaType.parse(""), ByteString.EMPTY)
-    requestBody = RequestBody.create(null, byteArrayOf(0, 1))
-    requestBody = RequestBody.create(MediaType.parse(""), byteArrayOf(0, 1))
-    requestBody = RequestBody.create(null, byteArrayOf(0, 1), 0, 2)
-    requestBody = RequestBody.create(MediaType.parse(""), byteArrayOf(0, 1), 0, 2)
-    requestBody = RequestBody.create(null, File(""))
-    requestBody = RequestBody.create(MediaType.parse(""), File(""))
+    requestBody = "".toRequestBody(null)
+    requestBody = "".toRequestBody("".toMediaTypeOrNull())
+    requestBody = ByteString.EMPTY.toRequestBody(null)
+    requestBody = ByteString.EMPTY.toRequestBody("".toMediaTypeOrNull())
+    requestBody = byteArrayOf(0, 1).toRequestBody(null, 0, 2)
+    requestBody = byteArrayOf(0, 1).toRequestBody("".toMediaTypeOrNull(), 0, 2)
+    requestBody = byteArrayOf(0, 1).toRequestBody(null, 0, 2)
+    requestBody = byteArrayOf(0, 1).toRequestBody("".toMediaTypeOrNull(), 0, 2)
+    requestBody = File("").asRequestBody(null)
+    requestBody = File("").asRequestBody("".toMediaTypeOrNull())
   }
 
   @Test @Ignore
   fun response() {
     val response: Response = Response.Builder().build()
-    val request: Request = response.request()
-    val protocol: Protocol = response.protocol()
-    val code: Int = response.code()
+    val request: Request = response.request
+    val protocol: Protocol = response.protocol
+    val code: Int = response.code
     val successful: Boolean = response.isSuccessful
-    val message: String = response.message()
-    val handshake: Handshake? = response.handshake()
+    val message: String = response.message
+    val handshake: Handshake? = response.handshake
     val headersForName: List<String> = response.headers("")
     val header: String? = response.header("")
-    val headers: Headers = response.headers()
+    val headers: Headers = response.headers
     val trailers: Headers = response.trailers()
     val peekBody: ResponseBody = response.peekBody(0L)
-    val body: ResponseBody? = response.body()
+    val body: ResponseBody? = response.body
     val builder: Response.Builder = response.newBuilder()
     val redirect: Boolean = response.isRedirect
-    val networkResponse: Response? = response.networkResponse()
-    val cacheResponse: Response? = response.cacheResponse()
-    val priorResponse: Response? = response.priorResponse()
+    val networkResponse: Response? = response.networkResponse
+    val cacheResponse: Response? = response.cacheResponse
+    val priorResponse: Response? = response.priorResponse
     val challenges: List<Challenge> = response.challenges()
-    val cacheControl: CacheControl = response.cacheControl()
-    val sentRequestAtMillis: Long = response.sentRequestAtMillis()
-    val receivedResponseAtMillis: Long = response.receivedResponseAtMillis()
+    val cacheControl: CacheControl = response.cacheControl
+    val sentRequestAtMillis: Long = response.sentRequestAtMillis
+    val receivedResponseAtMillis: Long = response.receivedResponseAtMillis
   }
 
   @Test @Ignore
@@ -1081,8 +1054,8 @@ class KotlinSourceCompatibilityTest {
     builder = builder.header("", "")
     builder = builder.addHeader("", "")
     builder = builder.removeHeader("")
-    builder = builder.headers(Headers.of())
-    builder = builder.body(ResponseBody.create(null, ""))
+    builder = builder.headers(headersOf())
+    builder = builder.body("".toResponseBody(null))
     builder = builder.body(null)
     builder = builder.networkResponse(Response.Builder().build())
     builder = builder.networkResponse(null)
@@ -1109,22 +1082,22 @@ class KotlinSourceCompatibilityTest {
     val charStream = responseBody.charStream()
     val string = responseBody.string()
     responseBody.close()
-    responseBody = ResponseBody.create(MediaType.get(""), "")
-    responseBody = ResponseBody.create(null, "")
-    responseBody = ResponseBody.create(MediaType.get(""), ByteString.EMPTY)
-    responseBody = ResponseBody.create(null, ByteString.EMPTY)
-    responseBody = ResponseBody.create(MediaType.get(""), byteArrayOf(0, 1))
-    responseBody = ResponseBody.create(null, byteArrayOf(0, 1))
-    responseBody = ResponseBody.create(MediaType.get(""), 0L, Buffer())
-    responseBody = ResponseBody.create(null, 0L, Buffer())
+    responseBody = "".toResponseBody("".toMediaType())
+    responseBody = "".toResponseBody(null)
+    responseBody = ByteString.EMPTY.toResponseBody("".toMediaType())
+    responseBody = ByteString.EMPTY.toResponseBody(null)
+    responseBody = byteArrayOf(0, 1).toResponseBody("".toMediaType())
+    responseBody = byteArrayOf(0, 1).toResponseBody(null)
+    responseBody = Buffer().asResponseBody("".toMediaType(), 0L)
+    responseBody = Buffer().asResponseBody(null, 0L)
   }
 
   @Test @Ignore
   fun route() {
     val route: Route = newRoute()
-    val address: Address = route.address()
-    val proxy: Proxy = route.proxy()
-    val inetSocketAddress: InetSocketAddress = route.socketAddress()
+    val address: Address = route.address
+    val proxy: Proxy = route.proxy
+    val inetSocketAddress: InetSocketAddress = route.socketAddress
     val requiresTunnel: Boolean = route.requiresTunnel()
   }
 
@@ -1136,7 +1109,7 @@ class KotlinSourceCompatibilityTest {
   @Test @Ignore
   fun tlsVersion() {
     var tlsVersion: TlsVersion = TlsVersion.TLS_1_3
-    val javaName: String = tlsVersion.javaName()
+    val javaName: String = tlsVersion.javaName
     tlsVersion = TlsVersion.forJavaName("")
   }
 
@@ -1226,4 +1199,4 @@ class KotlinSourceCompatibilityTest {
   private fun newRoute(): Route {
     return Route(newAddress(), Proxy.NO_PROXY, InetSocketAddress.createUnresolved("", 0))
   }
-}
\ No newline at end of file
+}
diff --git a/okhttp/src/test/java/okhttp3/MultipartBodyTest.java b/okhttp/src/test/java/okhttp3/MultipartBodyTest.java
index 00ae7bbdf5..8b05917ab3 100644
--- a/okhttp/src/test/java/okhttp3/MultipartBodyTest.java
+++ b/okhttp/src/test/java/okhttp3/MultipartBodyTest.java
@@ -43,7 +43,7 @@
         + "--123--\r\n";
 
     MultipartBody body = new MultipartBody.Builder("123")
-        .addPart(RequestBody.create(null, "Hello, World!"))
+        .addPart(RequestBody.create("Hello, World!", null))
         .build();
 
     assertThat(body.boundary()).isEqualTo("123");
@@ -75,9 +75,9 @@
         + "--123--\r\n";
 
     MultipartBody body = new MultipartBody.Builder("123")
-        .addPart(RequestBody.create(null, "Quick"))
-        .addPart(RequestBody.create(null, "Brown"))
-        .addPart(RequestBody.create(null, "Fox"))
+        .addPart(RequestBody.create("Quick", null))
+        .addPart(RequestBody.create("Brown", null))
+        .addPart(RequestBody.create("Fox", null))
         .build();
 
     assertThat(body.boundary()).isEqualTo("123");
@@ -129,14 +129,14 @@
                 .addPart(
                     Headers.of("Content-Disposition", "file; filename=\"file1.txt\""),
                     RequestBody.create(
-                        MediaType.get("text/plain"), "... contents of file1.txt ..."))
+                        "... contents of file1.txt ...", MediaType.get("text/plain")))
                 .addPart(
                     Headers.of(
                         "Content-Disposition", "file; filename=\"file2.gif\"",
                         "Content-Transfer-Encoding", "binary"),
                     RequestBody.create(
-                        MediaType.get("image/gif"),
-                        "... contents of file2.gif ...".getBytes(UTF_8)))
+                        "... contents of file2.gif ...".getBytes(UTF_8),
+                        MediaType.get("image/gif")))
                 .build())
         .build();
 
@@ -181,7 +181,7 @@
     MultipartBody body = new MultipartBody.Builder("AaB03x")
         .setType(MultipartBody.FORM)
         .addFormDataPart("field with spaces", "filename with spaces.txt",
-            RequestBody.create(MediaType.get("text/plain; charset=utf-8"), "okay"))
+            RequestBody.create("okay", MediaType.get("text/plain; charset=utf-8")))
         .addFormDataPart("field with \"", "\"")
         .addFormDataPart("field with %22", "%22")
         .addFormDataPart("field with \u007e", "Alpha")
@@ -224,9 +224,9 @@
         + "--123--\r\n";
 
     MultipartBody body = new MultipartBody.Builder("123")
-        .addPart(RequestBody.create(null, "Quick"))
+        .addPart(RequestBody.create("Quick", null))
         .addPart(new StreamingBody("Brown"))
-        .addPart(RequestBody.create(null, "Fox"))
+        .addPart(RequestBody.create("Fox", null))
         .build();
 
     assertThat(body.boundary()).isEqualTo("123");
@@ -244,7 +244,7 @@
     MultipartBody.Builder multipart = new MultipartBody.Builder();
     try {
       multipart.addPart(Headers.of("Content-Type", "text/plain"),
-          RequestBody.create(null, "Hello, World!"));
+          RequestBody.create("Hello, World!", null));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -254,7 +254,7 @@
     MultipartBody.Builder multipart = new MultipartBody.Builder();
     try {
       multipart.addPart(Headers.of("Content-Length", "13"),
-          RequestBody.create(null, "Hello, World!"));
+          RequestBody.create("Hello, World!", null));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -262,7 +262,7 @@
 
   @Test public void partAccessors() throws IOException {
     MultipartBody body = new MultipartBody.Builder()
-        .addPart(Headers.of("Foo", "Bar"), RequestBody.create(null, "Baz"))
+        .addPart(Headers.of("Foo", "Bar"), RequestBody.create("Baz", null))
         .build();
     assertThat(body.parts().size()).isEqualTo(1);
 
@@ -286,7 +286,7 @@
     MultipartBody body = new MultipartBody.Builder("AaB03x")
         .setType(MultipartBody.FORM)
         .addFormDataPart("attachment", "resumé.pdf",
-            RequestBody.create(MediaType.parse("application/pdf"), "Jesse’s Resumé"))
+            RequestBody.create("Jesse’s Resumé", MediaType.parse("application/pdf")))
         .build();
 
     Buffer buffer = new Buffer();
diff --git a/okhttp/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp/src/test/java/okhttp3/OkHttpClientTest.java
index 7c8b1ffee7..1e4c4b84c4 100644
--- a/okhttp/src/test/java/okhttp3/OkHttpClientTest.java
+++ b/okhttp/src/test/java/okhttp3/OkHttpClientTest.java
@@ -17,10 +17,15 @@
 
 import java.net.CookieHandler;
 import java.net.CookieManager;
+import java.net.Proxy;
 import java.net.ProxySelector;
 import java.net.ResponseCache;
+import java.util.AbstractList;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.internal.proxy.NullProxySelector;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.After;
@@ -28,12 +33,13 @@
 import org.junit.Test;
 
 import static java.util.Arrays.asList;
-import static okhttp3.TestUtil.defaultClient;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 public final class OkHttpClientTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
   private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
@@ -46,7 +52,7 @@
   }
 
   @Test public void durationDefaults() {
-    OkHttpClient client = defaultClient();
+    OkHttpClient client = clientTestRule.newClient();
     assertThat(client.callTimeoutMillis()).isEqualTo(0);
     assertThat(client.connectTimeoutMillis()).isEqualTo(10_000);
     assertThat(client.readTimeoutMillis()).isEqualTo(10_000);
@@ -92,7 +98,7 @@
 
   @Test public void clonedInterceptorsListsAreIndependent() throws Exception {
     Interceptor interceptor = chain -> chain.proceed(chain.request());
-    OkHttpClient original = defaultClient();
+    OkHttpClient original = clientTestRule.newClient();
     original.newBuilder()
         .addInterceptor(interceptor)
         .addNetworkInterceptor(interceptor)
@@ -106,19 +112,21 @@
    * clients.
    */
   @Test public void cloneSharesStatefulInstances() throws Exception {
-    OkHttpClient client = defaultClient();
+    OkHttpClient client = clientTestRule.newClient();
 
     // Values should be non-null.
     OkHttpClient a = client.newBuilder().build();
     assertThat(a.dispatcher()).isNotNull();
     assertThat(a.connectionPool()).isNotNull();
     assertThat(a.sslSocketFactory()).isNotNull();
+    assertThat(a.x509TrustManager()).isNotNull();
 
     // Multiple clients share the instances.
     OkHttpClient b = client.newBuilder().build();
     assertThat(b.dispatcher()).isSameAs(a.dispatcher());
     assertThat(b.connectionPool()).isSameAs(a.connectionPool());
     assertThat(b.sslSocketFactory()).isSameAs(a.sslSocketFactory());
+    assertThat(b.x509TrustManager()).isSameAs(a.x509TrustManager());
   }
 
   @Test public void setProtocolsRejectsHttp10() throws Exception {
@@ -131,8 +139,8 @@
   }
 
   @Test public void certificatePinnerEquality() {
-    OkHttpClient clientA = TestUtil.defaultClient();
-    OkHttpClient clientB = TestUtil.defaultClient();
+    OkHttpClient clientA = clientTestRule.newClient();
+    OkHttpClient clientB = clientTestRule.newClient();
     assertThat(clientB.certificatePinner()).isEqualTo(clientA.certificatePinner());
   }
 
@@ -213,8 +221,7 @@
 
     ProxySelector.setDefault(null);
 
-    OkHttpClient client = defaultClient().newBuilder()
-        .build();
+    OkHttpClient client = clientTestRule.newClient();
 
     Request request = new Request.Builder().url(server.url("/")).build();
     Response response = client.newCall(request).execute();
@@ -229,4 +236,69 @@
     } catch (IllegalArgumentException expected) {
     }
   }
+
+  @Test public void noSslSocketFactoryConfigured() throws Exception {
+    OkHttpClient client = new OkHttpClient.Builder()
+        .connectionSpecs(asList(ConnectionSpec.CLEARTEXT))
+        .build();
+    try {
+      client.sslSocketFactory();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void nullHostileProtocolList() {
+    List<Protocol> nullHostileProtocols = new AbstractList<Protocol>() {
+      @Override public boolean contains(Object o) {
+        if (o == null) throw new NullPointerException();
+        return super.contains(o);
+      }
+
+      @Override public int indexOf(Object o) {
+        if (o == null) throw new NullPointerException();
+        return super.indexOf(o);
+      }
+
+      @Override public Protocol get(int index) {
+        if (index != 0) throw new IndexOutOfBoundsException();
+        return Protocol.HTTP_1_1;
+      }
+
+      @Override public int size() {
+        return 1;
+      }
+    };
+
+    OkHttpClient client = new OkHttpClient.Builder()
+        .protocols(nullHostileProtocols)
+        .build();
+    assertEquals(asList(Protocol.HTTP_1_1), client.protocols());
+  }
+
+  @Test public void nullProtocolInList() {
+    List<Protocol> protocols = new ArrayList<>();
+    protocols.add(Protocol.HTTP_1_1);
+    protocols.add(null);
+    try {
+      new OkHttpClient.Builder().protocols(protocols);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected.getMessage()).isEqualTo(("protocols must not contain null"));
+    }
+  }
+
+  @Test public void testProxyDefaults() {
+    OkHttpClient client = new OkHttpClient.Builder().build();
+    assertThat(client.proxy()).isNull();
+    assertThat(client.proxySelector()).isNotInstanceOf(NullProxySelector.class);
+
+    client = new OkHttpClient.Builder().proxy(Proxy.NO_PROXY).build();
+    assertThat(client.proxy()).isSameAs(Proxy.NO_PROXY);
+    assertThat(client.proxySelector()).isInstanceOf(NullProxySelector.class);
+
+    client = new OkHttpClient.Builder().proxySelector(new FakeProxySelector()).build();
+    assertThat(client.proxy()).isNull();
+    assertThat(client.proxySelector()).isInstanceOf(FakeProxySelector.class);
+  }
 }
diff --git a/okhttp/src/test/java/okhttp3/OpenJSSETest.kt b/okhttp/src/test/java/okhttp3/OpenJSSETest.kt
new file mode 100644
index 0000000000..a992435760
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/OpenJSSETest.kt
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.TestUtil.assumeNetwork
+import okhttp3.internal.platform.OpenJSSEPlatform
+import okhttp3.mockwebserver.MockResponse
+import okhttp3.mockwebserver.MockWebServer
+import okhttp3.testing.PlatformRule
+import okhttp3.tls.HandshakeCertificates
+import okhttp3.tls.HeldCertificate
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Assert.assertEquals
+import org.junit.Before
+import org.junit.Ignore
+import org.junit.Rule
+import org.junit.Test
+import org.openjsse.sun.security.ssl.SSLSocketFactoryImpl
+import org.openjsse.sun.security.ssl.SSLSocketImpl
+import java.net.InetAddress
+
+class OpenJSSETest {
+  @JvmField @Rule var platform = PlatformRule()
+  @JvmField @Rule val clientTestRule = OkHttpClientTestRule()
+  @JvmField @Rule val server = MockWebServer()
+  lateinit var client: OkHttpClient
+
+  @Before
+  fun setUp() {
+    platform.assumeOpenJSSE()
+
+    client = clientTestRule.newClient()
+  }
+
+  @Test
+  fun testTlsv13Works() {
+    enableTls()
+
+    server.enqueue(MockResponse().setBody("abc"))
+
+    val request = Request.Builder().url(server.url("/")).build()
+
+    val response = client.newCall(request).execute()
+
+    response.use {
+      assertEquals(200, response.code)
+      assertEquals(TlsVersion.TLS_1_3, response.handshake?.tlsVersion)
+      assertEquals(Protocol.HTTP_2, response.protocol)
+
+      assertThat(response.exchange?.connection()?.socket()).isInstanceOf(SSLSocketImpl::class.java)
+    }
+  }
+
+  @Test
+  fun testSupportedProtocols() {
+    val factory = SSLSocketFactoryImpl()
+    val s = factory.createSocket() as SSLSocketImpl
+
+    assertEquals(listOf("TLSv1.3", "TLSv1.2", "TLSv1.1", "TLSv1"), s.enabledProtocols.toList())
+  }
+
+  @Test
+  @Ignore
+  fun testMozilla() {
+    assumeNetwork()
+
+    val request = Request.Builder().url("https://mozilla.org/robots.txt").build()
+
+    client.newCall(request).execute().use {
+      assertThat(it.protocol).isEqualTo(Protocol.HTTP_2)
+      assertThat(it.handshake!!.tlsVersion).isEqualTo(TlsVersion.TLS_1_3)
+    }
+  }
+
+  @Test
+  fun testBuildIfSupported() {
+    val actual = OpenJSSEPlatform.buildIfSupported()
+    assertThat(actual).isNotNull
+  }
+
+  private fun enableTls() {
+    // Generate a self-signed cert for the server to serve and the client to trust.
+    // can't use TlsUtil.localhost with a non OpenJSSE trust manager
+    val heldCertificate = HeldCertificate.Builder()
+        .commonName("localhost")
+        .addSubjectAlternativeName(InetAddress.getByName("localhost").canonicalHostName)
+        .build()
+    val handshakeCertificates = HandshakeCertificates.Builder()
+        .heldCertificate(heldCertificate)
+        .addTrustedCertificate(heldCertificate.certificate)
+        .build()
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager)
+        .build()
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false)
+  }
+}
\ No newline at end of file
diff --git a/okhttp/src/test/java/okhttp3/PublicInternalApiTest.java b/okhttp/src/test/java/okhttp3/PublicInternalApiTest.java
new file mode 100644
index 0000000000..7421931867
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/PublicInternalApiTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http.HttpMethod;
+import org.junit.Test;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+@SuppressWarnings("ALL") public class PublicInternalApiTest {
+  @Test public void permitsRequestBody() {
+    assertTrue(HttpMethod.permitsRequestBody("POST"));
+    assertFalse(HttpMethod.permitsRequestBody("GET"));
+  }
+
+  @Test public void requiresRequestBody() {
+    assertTrue(HttpMethod.requiresRequestBody("PUT"));
+    assertFalse(HttpMethod.requiresRequestBody("GET"));
+  }
+
+  @Test public void hasBody() {
+    Request request = new Request.Builder().url("http://example.com").build();
+    Response response = new Response.Builder().code(200)
+        .message("OK")
+        .request(request)
+        .protocol(Protocol.HTTP_2)
+        .build();
+    assertTrue(HttpHeaders.hasBody(response));
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/RecordingExecutor.kt b/okhttp/src/test/java/okhttp3/RecordingExecutor.kt
index c9ea6c8901..3b57f15640 100644
--- a/okhttp/src/test/java/okhttp3/RecordingExecutor.kt
+++ b/okhttp/src/test/java/okhttp3/RecordingExecutor.kt
@@ -16,7 +16,6 @@
 package okhttp3
 
 import org.assertj.core.api.Assertions.assertThat
-import java.util.ArrayList
 import java.util.concurrent.AbstractExecutorService
 import java.util.concurrent.RejectedExecutionException
 import java.util.concurrent.TimeUnit
@@ -25,7 +24,7 @@ internal class RecordingExecutor(
   private val dispatcherTest: DispatcherTest
 ) : AbstractExecutorService() {
   private var shutdown: Boolean = false
-  private val calls = ArrayList<RealCall.AsyncCall>()
+  private val calls = mutableListOf<RealCall.AsyncCall>()
 
   override fun execute(command: Runnable) {
     if (shutdown) throw RejectedExecutionException()
@@ -33,7 +32,7 @@ internal class RecordingExecutor(
   }
 
   fun assertJobs(vararg expectedUrls: String) {
-    val actualUrls = calls.map { it.request().url().toString() }
+    val actualUrls = calls.map { it.request().url.toString() }
     assertThat(actualUrls).containsExactly(*expectedUrls)
   }
 
@@ -41,7 +40,7 @@ internal class RecordingExecutor(
     val i = calls.iterator()
     while (i.hasNext()) {
       val call = i.next()
-      if (call.request().url().toString() == url) {
+      if (call.request().url.toString() == url) {
         i.remove()
         dispatcherTest.dispatcher.finished(call)
         return
diff --git a/okhttp/src/test/java/okhttp3/RequestTest.java b/okhttp/src/test/java/okhttp3/RequestTest.java
index 0442a0ad2d..9638b3ba40 100644
--- a/okhttp/src/test/java/okhttp3/RequestTest.java
+++ b/okhttp/src/test/java/okhttp3/RequestTest.java
@@ -31,7 +31,7 @@
 public final class RequestTest {
   @Test public void string() throws Exception {
     MediaType contentType = MediaType.get("text/plain; charset=utf-8");
-    RequestBody body = RequestBody.create(contentType, "abc".getBytes(UTF_8));
+    RequestBody body = RequestBody.create("abc".getBytes(UTF_8), contentType);
     assertThat(body.contentType()).isEqualTo(contentType);
     assertThat(body.contentLength()).isEqualTo(3);
     assertThat(bodyToHex(body)).isEqualTo("616263");
@@ -41,7 +41,7 @@
 
   @Test public void stringWithDefaultCharsetAdded() throws Exception {
     MediaType contentType = MediaType.get("text/plain");
-    RequestBody body = RequestBody.create(contentType, "\u0800");
+    RequestBody body = RequestBody.create("\u0800", contentType);
     assertThat(body.contentType()).isEqualTo(MediaType.get("text/plain; charset=utf-8"));
     assertThat(body.contentLength()).isEqualTo(3);
     assertThat(bodyToHex(body)).isEqualTo("e0a080");
@@ -49,7 +49,7 @@
 
   @Test public void stringWithNonDefaultCharsetSpecified() throws Exception {
     MediaType contentType = MediaType.get("text/plain; charset=utf-16be");
-    RequestBody body = RequestBody.create(contentType, "\u0800");
+    RequestBody body = RequestBody.create("\u0800", contentType);
     assertThat(body.contentType()).isEqualTo(contentType);
     assertThat(body.contentLength()).isEqualTo(2);
     assertThat(bodyToHex(body)).isEqualTo("0800");
@@ -57,7 +57,7 @@
 
   @Test public void byteArray() throws Exception {
     MediaType contentType = MediaType.get("text/plain");
-    RequestBody body = RequestBody.create(contentType, "abc".getBytes(UTF_8));
+    RequestBody body = RequestBody.create("abc".getBytes(UTF_8), contentType);
     assertThat(body.contentType()).isEqualTo(contentType);
     assertThat(body.contentLength()).isEqualTo(3);
     assertThat(bodyToHex(body)).isEqualTo("616263");
@@ -67,7 +67,7 @@
 
   @Test public void byteArrayRange() throws Exception {
     MediaType contentType = MediaType.get("text/plain");
-    RequestBody body = RequestBody.create(contentType, ".abcd".getBytes(UTF_8), 1, 3);
+    RequestBody body = RequestBody.create(".abcd".getBytes(UTF_8), contentType, 1, 3);
     assertThat(body.contentType()).isEqualTo(contentType);
     assertThat(body.contentLength()).isEqualTo(3);
     assertThat(bodyToHex(body)).isEqualTo("616263");
@@ -77,7 +77,7 @@
 
   @Test public void byteString() throws Exception {
     MediaType contentType = MediaType.get("text/plain");
-    RequestBody body = RequestBody.create(contentType, ByteString.encodeUtf8("Hello"));
+    RequestBody body = RequestBody.create(ByteString.encodeUtf8("Hello"), contentType);
     assertThat(body.contentType()).isEqualTo(contentType);
     assertThat(body.contentLength()).isEqualTo(5);
     assertThat(bodyToHex(body)).isEqualTo("48656c6c6f");
@@ -92,7 +92,7 @@
     writer.close();
 
     MediaType contentType = MediaType.get("text/plain");
-    RequestBody body = RequestBody.create(contentType, file);
+    RequestBody body = RequestBody.create(file, contentType);
     assertThat(body.contentType()).isEqualTo(contentType);
     assertThat(body.contentLength()).isEqualTo(3);
     assertThat(bodyToHex(body)).isEqualTo("616263");
@@ -103,7 +103,7 @@
   /** Common verbs used for apis such as GitHub, AWS, and Google Cloud. */
   @Test public void crudVerbs() throws IOException {
     MediaType contentType = MediaType.get("application/json");
-    RequestBody body = RequestBody.create(contentType, "{}");
+    RequestBody body = RequestBody.create("{}", contentType);
 
     Request get = new Request.Builder().url("http://localhost/api").get().build();
     assertThat(get.method()).isEqualTo("GET");
@@ -158,6 +158,7 @@
         .url("https://square.com")
         .build();
     assertThat(request.headers("Cache-Control")).containsExactly("no-cache");
+    assertThat(request.cacheControl().noCache()).isTrue();
   }
 
   @Test public void emptyCacheControlClearsAllCacheControlHeaders() {
diff --git a/okhttp/src/test/java/okhttp3/ResponseBodyTest.java b/okhttp/src/test/java/okhttp3/ResponseBodyTest.java
index cced85f93a..2ff9851268 100644
--- a/okhttp/src/test/java/okhttp3/ResponseBodyTest.java
+++ b/okhttp/src/test/java/okhttp3/ResponseBodyTest.java
@@ -330,6 +330,89 @@
     }
   }
 
+  @Test public void byteStringEmpty() throws IOException {
+    ResponseBody body = body("");
+    assertThat(body.byteString()).isEqualTo(ByteString.EMPTY);
+  }
+
+  @Test public void byteStringSeesBom() throws IOException {
+    ResponseBody body = body("efbbbf68656c6c6f");
+    ByteString actual = body.byteString();
+    ByteString expected = ByteString.decodeHex("efbbbf68656c6c6f");
+    assertThat(actual).isEqualTo(expected);
+  }
+
+  @Test public void byteStringClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    assertThat(body.byteString().size()).isEqualTo(5);
+    assertThat(closed.get()).isTrue();
+  }
+
+  @Test public void byteStringThrowsWhenLengthsDisagree() {
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 10;
+      }
+
+      @Override public BufferedSource source() {
+        return new Buffer().writeUtf8("hello");
+      }
+    };
+    try {
+      body.byteString();
+      fail();
+    } catch (IOException e) {
+      assertThat(e.getMessage()).isEqualTo(
+          "Content-Length (10) and stream length (5) disagree");
+    }
+  }
+
+  @Test public void byteStringThrowsMoreThanIntMaxValue() {
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return Integer.MAX_VALUE + 1L;
+      }
+
+      @Override public BufferedSource source() {
+        throw new AssertionError();
+      }
+    };
+    try {
+      body.byteString();
+      fail();
+    } catch (IOException e) {
+      assertThat(e.getMessage()).isEqualTo(
+          "Cannot buffer entire body for content length: 2147483648");
+    }
+  }
+
   @Test public void byteStreamEmpty() throws IOException {
     ResponseBody body = body("");
     InputStream bytes = body.byteStream();
@@ -399,7 +482,7 @@ static ResponseBody body(String hex) {
 
   static ResponseBody body(String hex, String charset) {
     MediaType mediaType = charset == null ? null : MediaType.get("any/thing; charset=" + charset);
-    return ResponseBody.create(mediaType, ByteString.decodeHex(hex));
+    return ResponseBody.create(ByteString.decodeHex(hex), mediaType);
   }
 
   static String exhaust(Reader reader) throws IOException {
diff --git a/okhttp/src/test/java/okhttp3/ResponseTest.java b/okhttp/src/test/java/okhttp3/ResponseTest.java
index 162d2d9a39..3fca5712a7 100644
--- a/okhttp/src/test/java/okhttp3/ResponseTest.java
+++ b/okhttp/src/test/java/okhttp3/ResponseTest.java
@@ -24,6 +24,7 @@
 import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.Assert.fail;
 
 public final class ResponseTest {
@@ -61,6 +62,16 @@
     assertThat(p2.string()).isEqualTo("ab");
   }
 
+  @Test public void negativeStatusCodeThrowsIllegalStateException() {
+    assertThatThrownBy(() -> newResponse(responseBody("set status code -1"), -1))
+        .isInstanceOf(IllegalStateException.class);
+  }
+
+  @Test public void zeroStatusCodeIsValid() {
+    Response response = newResponse(responseBody("set status code 0"), 0);
+    assertThat(response.code()).isEqualTo(0);
+  }
+
   /**
    * Returns a new response body that refuses to be read once it has been closed. This is true of
    * most {@link BufferedSource} instances, but not of {@link Buffer}.
@@ -85,16 +96,20 @@ private ResponseBody responseBody(String content) {
       }
     };
 
-    return ResponseBody.create(null, -1, Okio.buffer(source));
+    return ResponseBody.create(Okio.buffer(source), null, -1);
   }
 
   private Response newResponse(ResponseBody responseBody) {
+    return newResponse(responseBody, 200);
+  }
+
+  private Response newResponse(ResponseBody responseBody, int code) {
     return new Response.Builder()
         .request(new Request.Builder()
             .url("https://example.com/")
             .build())
         .protocol(Protocol.HTTP_1_1)
-        .code(200)
+        .code(code)
         .message("OK")
         .body(responseBody)
         .build();
diff --git a/okhttp/src/test/java/okhttp3/SocksProxy.java b/okhttp/src/test/java/okhttp3/SocksProxy.java
index 4675171798..dd3e932f1d 100644
--- a/okhttp/src/test/java/okhttp3/SocksProxy.java
+++ b/okhttp/src/test/java/okhttp3/SocksProxy.java
@@ -32,13 +32,14 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.Okio;
 
+import static okhttp3.internal.Util.closeQuietly;
+
 /**
  * A limited implementation of SOCKS Protocol Version 5, intended to be similar to MockWebServer.
  * See <a href="https://www.ietf.org/rfc/rfc1928.txt">RFC 1928</a>.
@@ -65,23 +66,24 @@
 
   public void play() throws IOException {
     serverSocket = new ServerSocket(0);
-    executor.execute(new NamedRunnable("SocksProxy %s", serverSocket.getLocalPort()) {
-      @Override protected void execute() {
-        try {
-          while (true) {
-            Socket socket = serverSocket.accept();
-            connectionCount.incrementAndGet();
-            service(socket);
-          }
-        } catch (SocketException e) {
-          logger.info(name + " done accepting connections: " + e.getMessage());
-        } catch (IOException e) {
-          logger.log(Level.WARNING, name + " failed unexpectedly", e);
-        } finally {
-          for (Socket socket : openSockets) {
-            Util.closeQuietly(socket);
-          }
+    executor.execute(() -> {
+      String threadName = "SocksProxy " + serverSocket.getLocalPort();
+      Thread.currentThread().setName(threadName);
+      try {
+        while (true) {
+          Socket socket = serverSocket.accept();
+          connectionCount.incrementAndGet();
+          service(socket);
+        }
+      } catch (SocketException e) {
+        logger.info(threadName + " done accepting connections: " + e.getMessage());
+      } catch (IOException e) {
+        logger.log(Level.WARNING, threadName + " failed unexpectedly", e);
+      } finally {
+        for (Socket socket : openSockets) {
+          closeQuietly(socket);
         }
+        Thread.currentThread().setName("SocksProxy");
       }
     });
   }
@@ -104,18 +106,20 @@ public void shutdown() throws Exception {
   }
 
   private void service(final Socket from) {
-    executor.execute(new NamedRunnable("SocksProxy %s", from.getRemoteSocketAddress()) {
-      @Override protected void execute() {
-        try {
-          BufferedSource fromSource = Okio.buffer(Okio.source(from));
-          BufferedSink fromSink = Okio.buffer(Okio.sink(from));
-          hello(fromSource, fromSink);
-          acceptCommand(from.getInetAddress(), fromSource, fromSink);
-          openSockets.add(from);
-        } catch (IOException e) {
-          logger.log(Level.WARNING, name + " failed", e);
-          Util.closeQuietly(from);
-        }
+    executor.execute(() -> {
+      String threadName = "SocksProxy " + from.getRemoteSocketAddress();
+      Thread.currentThread().setName(threadName);
+      try {
+        BufferedSource fromSource = Okio.buffer(Okio.source(from));
+        BufferedSink fromSink = Okio.buffer(Okio.sink(from));
+        hello(fromSource, fromSink);
+        acceptCommand(from.getInetAddress(), fromSource, fromSink);
+        openSockets.add(from);
+      } catch (IOException e) {
+        logger.log(Level.WARNING, threadName + " failed", e);
+        closeQuietly(from);
+      } finally {
+        Thread.currentThread().setName("SocksProxy");
       }
     });
   }
@@ -214,34 +218,36 @@ private void acceptCommand(InetAddress fromAddress, BufferedSource fromSource,
 
   private void transfer(final InetAddress fromAddress, final InetAddress toAddress,
       final BufferedSource source, final BufferedSink sink) {
-    executor.execute(new NamedRunnable("SocksProxy %s to %s", fromAddress, toAddress) {
-      @Override protected void execute() {
-        Buffer buffer = new Buffer();
-        try {
-          while (true) {
-            long byteCount = source.read(buffer, 8192L);
-            if (byteCount == -1L) break;
-            sink.write(buffer, byteCount);
-            sink.emit();
-          }
-        } catch (SocketException e) {
-          logger.info(name + " done: " + e.getMessage());
-        } catch (IOException e) {
-          logger.log(Level.WARNING, name + " failed", e);
+    executor.execute(() -> {
+      String threadName = "SocksProxy " + fromAddress + " to " + toAddress;
+      Thread.currentThread().setName(threadName);
+      Buffer buffer = new Buffer();
+      try {
+        while (true) {
+          long byteCount = source.read(buffer, 8192L);
+          if (byteCount == -1L) break;
+          sink.write(buffer, byteCount);
+          sink.emit();
         }
+      } catch (SocketException e) {
+        logger.info(threadName + " done: " + e.getMessage());
+      } catch (IOException e) {
+        logger.log(Level.WARNING, threadName + " failed", e);
+      }
 
-        try {
-          source.close();
-        } catch (IOException e) {
-          logger.log(Level.WARNING, name + " failed", e);
-        }
+      try {
+        source.close();
+      } catch (IOException e) {
+        logger.log(Level.WARNING, threadName + " failed", e);
+      }
 
-        try {
-          sink.close();
-        } catch (IOException e) {
-          logger.log(Level.WARNING, name + " failed", e);
-        }
+      try {
+        sink.close();
+      } catch (IOException e) {
+        logger.log(Level.WARNING, threadName + " failed", e);
       }
+
+      Thread.currentThread().setName("SocksProxy");
     });
   }
 }
diff --git a/okhttp/src/test/java/okhttp3/SocksProxyTest.java b/okhttp/src/test/java/okhttp3/SocksProxyTest.java
index 6768632b6f..89dd9cbed2 100644
--- a/okhttp/src/test/java/okhttp3/SocksProxyTest.java
+++ b/okhttp/src/test/java/okhttp3/SocksProxyTest.java
@@ -29,11 +29,11 @@
 import org.junit.Rule;
 import org.junit.Test;
 
-import static okhttp3.TestUtil.defaultClient;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class SocksProxyTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   private final SocksProxy socksProxy = new SocksProxy();
 
@@ -49,7 +49,7 @@
     server.enqueue(new MockResponse().setBody("abc"));
     server.enqueue(new MockResponse().setBody("def"));
 
-    OkHttpClient client = defaultClient().newBuilder()
+    OkHttpClient client = clientTestRule.newClientBuilder()
         .proxy(socksProxy.proxy())
         .build();
 
@@ -78,7 +78,7 @@
       }
     };
 
-    OkHttpClient client = defaultClient().newBuilder()
+    OkHttpClient client = clientTestRule.newClientBuilder()
         .proxySelector(proxySelector)
         .build();
 
@@ -93,7 +93,7 @@
     // This testcase will fail if the target is resolved locally instead of through the proxy.
     server.enqueue(new MockResponse().setBody("abc"));
 
-    OkHttpClient client = defaultClient().newBuilder()
+    OkHttpClient client = clientTestRule.newClientBuilder()
         .proxy(socksProxy.proxy())
         .build();
 
diff --git a/okhttp/src/test/java/okhttp3/URLConnectionTest.java b/okhttp/src/test/java/okhttp3/URLConnectionTest.java
index 104cd45815..656122295c 100644
--- a/okhttp/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp/src/test/java/okhttp3/URLConnectionTest.java
@@ -59,16 +59,17 @@
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.InternalKtKt;
+import okhttp3.internal.Internal;
 import okhttp3.internal.RecordingAuthenticator;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.Util;
 import okhttp3.internal.Version;
 import okhttp3.internal.platform.Platform;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.testing.Flaky;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -89,7 +90,8 @@
 import static java.util.Locale.US;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
-import static okhttp3.internal.InternalKtKt.addHeaderLenient;
+import static okhttp3.internal.Internal.addHeaderLenient;
+import static okhttp3.internal.Util.immutableListOf;
 import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
 import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
@@ -112,11 +114,12 @@
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client = clientTestRule.client;
+  private OkHttpClient client;
   private @Nullable Cache cache;
 
   @Before public void setUp() {
     server.setProtocolNegotiationEnabled(false);
+    client = clientTestRule.newClient();
   }
 
   @After public void tearDown() throws Exception {
@@ -611,7 +614,7 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
     assertContent("this response comes via SSL", response);
 
     RecordedRequest failHandshakeRequest = server.takeRequest();
-    assertThat(failHandshakeRequest.getRequestLine()).isNull();
+    assertThat(failHandshakeRequest.getRequestLine()).isEmpty();
 
     RecordedRequest fallbackRequest = server.takeRequest();
     assertThat(fallbackRequest.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
@@ -683,7 +686,10 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
    *
    * http://code.google.com/p/android/issues/detail?id=13178
    */
+  @Flaky
   @Test public void connectViaHttpsToUntrustedServer() throws Exception {
+    // Flaky https://github.com/square/okhttp/issues/5222
+
     server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()); // unused
 
@@ -691,7 +697,10 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
       getResponse(newRequest("/foo"));
       fail();
     } catch (SSLHandshakeException expected) {
-      assertThat(expected.getCause()).isInstanceOf(CertificateException.class);
+      // Allow conscrypt to fail in different ways
+      if (!platform.isConscrypt()) {
+        assertThat(expected.getCause()).isInstanceOf(CertificateException.class);
+      }
     }
     assertThat(server.getRequestCount()).isEqualTo(0);
   }
@@ -939,7 +948,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     client = client.newBuilder()
         .sslSocketFactory(
             handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS))
+        .connectionSpecs(immutableListOf(ConnectionSpec.MODERN_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .proxy(server.toProxyAddress())
         .build();
@@ -1597,7 +1606,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Response response = getResponse(new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(null, body))
+        .post(RequestBody.create(body, null))
         .build());
     assertThat(response.code()).isEqualTo(200);
     response.body().byteStream().close();
@@ -1715,7 +1724,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   private void assertMethodPermitsRequestBody(String requestMethod) {
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .method(requestMethod, RequestBody.create(null, "abc"))
+        .method(requestMethod, RequestBody.create("abc", null))
         .build();
     assertThat(request.method()).isEqualTo(requestMethod);
   }
@@ -1724,7 +1733,7 @@ private void assertMethodForbidsRequestBody(String requestMethod) {
     try {
       new Request.Builder()
           .url(server.url("/"))
-          .method(requestMethod, RequestBody.create(null, "abc"))
+          .method(requestMethod, RequestBody.create("abc", null))
           .build();
       fail();
     } catch (IllegalArgumentException expected) {
@@ -1853,7 +1862,7 @@ private void testSecureStreamingPost(TransferKind streamingMode) throws Exceptio
         .build();
     Response response = getResponse(new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(null, "ABCD"))
+        .post(RequestBody.create("ABCD", null))
         .build());
     assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
         "Successful auth!");
@@ -2291,7 +2300,7 @@ private void testResponseRedirectedWithPost(int redirectCode, TransferKind trans
 
     Response response = getResponse(new Request.Builder()
         .url(server.url("/page1"))
-        .post(RequestBody.create(MediaType.get("text/plain; charset=utf-8"), "ABCD"))
+        .post(RequestBody.create("ABCD", MediaType.get("text/plain; charset=utf-8")))
         .header("Transfer-Encoding", "identity")
         .build());
     assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
@@ -2371,7 +2380,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     Request.Builder requestBuilder = new Request.Builder()
         .url(server.url("/page1"));
     if (method.equals("POST")) {
-      requestBuilder.post(RequestBody.create(null, "ABCD"));
+      requestBuilder.post(RequestBody.create("ABCD", null));
     } else {
       requestBuilder.method(method, null);
     }
@@ -2488,7 +2497,7 @@ private void enqueueClientRequestTimeoutResponses() {
 
     Response response = getResponse(new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(null, "Hello"))
+        .post(RequestBody.create("Hello", null))
         .build());
 
     assertThat(response.code()).isEqualTo(200);
@@ -2820,7 +2829,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     try {
       new Request.Builder()
           .url(server.url("/"))
-          .method("GET", RequestBody.create(null, "abc"))
+          .method("GET", RequestBody.create("abc", null))
           .build();
       fail();
     } catch (IllegalArgumentException expected) {
@@ -2832,7 +2841,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
         .setBody("A"));
     Response response = getResponse(new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(null, "ABC"))
+        .post(RequestBody.create("ABC", null))
         .build());
     assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
         "A");
@@ -2884,7 +2893,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     try {
       new Request.Builder()
           .url(server.url("/"))
-          .method("HEAD", RequestBody.create(null, ""))
+          .method("HEAD", RequestBody.create("", null))
           .build();
       fail();
     } catch (IllegalArgumentException expected) {
@@ -2998,7 +3007,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     Response post = getResponse(new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(null, "body!"))
+        .post(RequestBody.create("body!", null))
         .build());
     assertContent("def", post);
 
@@ -3115,7 +3124,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
   @Test public void emptyResponseHeaderNameIsLenient() throws Exception {
     Headers.Builder headers = new Headers.Builder();
-    InternalKtKt.addHeaderLenient(headers, ":A");
+    Internal.addHeaderLenient(headers, ":A");
     server.enqueue(new MockResponse()
         .setHeaders(headers.build())
         .setBody("body"));
@@ -3357,7 +3366,7 @@ private void zeroLengthPayload(String method) throws Exception {
 
     Response response = getResponse(new Request.Builder()
         .url(server.url("/"))
-        .method(method, RequestBody.create(null, ""))
+        .method(method, RequestBody.create("", null))
         .build());
     assertContent("", response);
     RecordedRequest zeroLengthPayload = server.takeRequest();
@@ -3522,7 +3531,7 @@ private void zeroLengthPayload(String method) throws Exception {
 
     Response response = getResponse(new Request.Builder()
         .url(server.url("/"))
-        .delete(RequestBody.create(null, "BODY"))
+        .delete(RequestBody.create("BODY", null))
         .build());
     assertThat(response.code()).isEqualTo(200);
 
@@ -3632,7 +3641,7 @@ private void zeroLengthPayload(String method) throws Exception {
 
     assertContent("def", getResponse(new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(null, "123"))
+        .post(RequestBody.create("123", null))
         .build()));
 
     RecordedRequest request1 = server.takeRequest();
diff --git a/okhttp/src/test/java/okhttp3/WebPlatformUrlTest.java b/okhttp/src/test/java/okhttp3/WebPlatformUrlTest.java
index c12c6a417a..6e975910db 100644
--- a/okhttp/src/test/java/okhttp3/WebPlatformUrlTest.java
+++ b/okhttp/src/test/java/okhttp3/WebPlatformUrlTest.java
@@ -18,7 +18,6 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
-import okhttp3.internal.Util;
 import okio.BufferedSource;
 import okio.Okio;
 import org.junit.Test;
@@ -26,6 +25,7 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameter;
 
+import static okhttp3.internal.Util.immutableListOf;
 import static org.assertj.core.api.Assertions.assertThat;
 
 /** Runs the web platform URL tests against Java URL models. */
@@ -47,9 +47,8 @@
   @Parameter
   public WebPlatformUrlTestData testData;
 
-  private static final List<String> HTTP_URL_SCHEMES
-      = Util.immutableList("http", "https");
-  private static final List<String> KNOWN_FAILURES = Util.immutableList(
+  private static final List<String> HTTP_URL_SCHEMES = immutableListOf("http", "https");
+  private static final List<String> KNOWN_FAILURES = immutableListOf(
       "Parsing: <http://example\t.\norg> against <http://example.org/foo/bar>",
       "Parsing: <http://f:0/c> against <http://example.org/foo/bar>",
       "Parsing: <http://f:00000000000000/c> against <http://example.org/foo/bar>",
diff --git a/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java b/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
index 6d9dcef39f..bf8b54343a 100644
--- a/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
+++ b/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
@@ -23,7 +23,9 @@
 import java.util.concurrent.atomic.AtomicReference;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.testing.Flaky;
 import okio.BufferedSink;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -37,7 +39,11 @@
   @Rule public final MockWebServer server = new MockWebServer();
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
-  private OkHttpClient client = clientTestRule.client;
+  private OkHttpClient client;
+
+  @Before public void setUp() {
+    client = clientTestRule.newClient();
+  }
 
   @Test public void defaultConfigIsNoTimeout() throws Exception {
     Request request = new Request.Builder()
@@ -281,7 +287,10 @@ public void timeoutFollowingRedirectOnNewConnection() throws Exception {
     }
   }
 
+  @Flaky
   @Test public void noTimeout() throws Exception {
+    // Flaky https://github.com/square/okhttp/issues/5304
+
     server.enqueue(new MockResponse()
         .setHeadersDelay(250, TimeUnit.MILLISECONDS)
         .setBody(BIG_ENOUGH_BODY));
@@ -292,7 +301,7 @@ public void timeoutFollowingRedirectOnNewConnection() throws Exception {
         .build();
 
     Call call = client.newCall(request);
-    call.timeout().timeout(1000, TimeUnit.MILLISECONDS);
+    call.timeout().timeout(2000, TimeUnit.MILLISECONDS);
     Response response = call.execute();
     Thread.sleep(250);
     response.body().source().readUtf8();
diff --git a/okhttp/src/test/java/okhttp3/internal/UtilTest.java b/okhttp/src/test/java/okhttp3/internal/UtilTest.java
deleted file mode 100644
index cac32a9922..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/UtilTest.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class UtilTest {
-  @Test public void immutableMap() {
-    Map<String, String> map = new LinkedHashMap<>();
-    map.put("a", "A");
-    Map<String, String> immutableCopy = Util.immutableMap(map);
-    assertThat(Collections.singletonMap("a", "A")).isEqualTo(immutableCopy);
-    map.clear();
-    assertThat(Collections.singletonMap("a", "A")).isEqualTo(immutableCopy);
-    try {
-      immutableCopy.clear();
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/UtilTest.kt b/okhttp/src/test/java/okhttp3/internal/UtilTest.kt
new file mode 100644
index 0000000000..6e9d05f7ac
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/internal/UtilTest.kt
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Assert.fail
+import org.junit.Test
+import java.util.LinkedHashMap
+
+class UtilTest {
+  @Test fun immutableMap() {
+    val map = LinkedHashMap<String, String>()
+    map["a"] = "A"
+    val immutableCopy = map.toImmutableMap()
+    assertThat(mapOf("a" to "A")).isEqualTo(immutableCopy)
+    map.clear()
+    assertThat(mapOf("a" to "A")).isEqualTo(immutableCopy)
+    try {
+      (immutableCopy as MutableMap).clear()
+      fail()
+    } catch (_: UnsupportedOperationException) {
+    }
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java b/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
index 01b65d77cb..a37395f27b 100644
--- a/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
@@ -662,7 +662,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void constructorDoesNotAllowZeroCacheSize() throws Exception {
     try {
-      DiskLruCache.create(fileSystem, cacheDir, appVersion, 2, 0);
+      DiskLruCache.Companion.create(fileSystem, cacheDir, appVersion, 2, 0);
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -670,7 +670,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void constructorDoesNotAllowZeroValuesPerEntry() throws Exception {
     try {
-      DiskLruCache.create(fileSystem, cacheDir, appVersion, 0, 10);
+      DiskLruCache.Companion.create(fileSystem, cacheDir, appVersion, 0, 10);
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -978,7 +978,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   @Test public void openCreatesDirectoryIfNecessary() throws Exception {
     cache.close();
     File dir = tempDir.newFolder("testOpenCreatesDirectoryIfNecessary");
-    cache = DiskLruCache.create(fileSystem, dir, appVersion, 2, Integer.MAX_VALUE);
+    cache = DiskLruCache.Companion.create(fileSystem, dir, appVersion, 2, Integer.MAX_VALUE);
     set("a", "a", "a");
     assertThat(fileSystem.exists(new File(dir, "a.0"))).isTrue();
     assertThat(fileSystem.exists(new File(dir, "a.1"))).isTrue();
@@ -1643,6 +1643,25 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertAbsent("k1");
   }
 
+  @Test public void dontRemoveUnfinishedEntryWhenCreatingSnapshot() throws Exception {
+    DiskLruCache.Editor creator = cache.edit("k1");
+    setString(creator, 0, "ABC");
+    setString(creator, 1, "DE");
+
+    assertThat(creator.newSource(0)).isNull();
+    assertThat(creator.newSource(1)).isNull();
+
+    Iterator<DiskLruCache.Snapshot> snapshotWhileEditing = cache.snapshots();
+    assertThat(snapshotWhileEditing.hasNext()).isFalse(); // entry still is being created/edited
+    creator.commit();
+
+    Iterator<DiskLruCache.Snapshot> snapshotAfterCommit = cache.snapshots();
+
+    assertThat(snapshotAfterCommit.hasNext())
+        .withFailMessage("Entry has been removed during creation.")
+        .isTrue();
+  }
+
   private void assertJournalEquals(String... expectedBodyLines) throws Exception {
     List<String> expectedLines = new ArrayList<>();
     expectedLines.add(MAGIC);
diff --git a/okhttp/src/test/java/okhttp3/internal/cache2/RelayTest.java b/okhttp/src/test/java/okhttp3/internal/cache2/RelayTest.java
index 5e3911899f..c853cddeac 100644
--- a/okhttp/src/test/java/okhttp3/internal/cache2/RelayTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/cache2/RelayTest.java
@@ -56,7 +56,7 @@
     Buffer upstream = new Buffer();
     upstream.writeUtf8("abcdefghijklm");
 
-    Relay relay = Relay.edit(file, upstream, metadata, 1024);
+    Relay relay = Relay.Companion.edit(file, upstream, metadata, 1024);
     Source source = relay.newSource();
     Buffer sourceBuffer = new Buffer();
 
@@ -78,7 +78,7 @@
     Buffer upstream = new Buffer();
     upstream.writeUtf8("abcdefghijklm");
 
-    Relay relay = Relay.edit(file, upstream, metadata, 1024);
+    Relay relay = Relay.Companion.edit(file, upstream, metadata, 1024);
     BufferedSource source1 = Okio.buffer(relay.newSource());
     BufferedSource source2 = Okio.buffer(relay.newSource());
 
@@ -95,7 +95,7 @@
     Buffer upstream = new Buffer();
     upstream.writeUtf8("abcdefghij");
 
-    Relay relay = Relay.edit(file, upstream, metadata, 5);
+    Relay relay = Relay.Companion.edit(file, upstream, metadata, 5);
     BufferedSource source1 = Okio.buffer(relay.newSource());
     BufferedSource source2 = Okio.buffer(relay.newSource());
 
@@ -116,7 +116,7 @@
     Buffer upstream = new Buffer();
     upstream.writeUtf8("abcdefghijklmnopqrst");
 
-    Relay relay = Relay.edit(file, upstream, metadata, 5);
+    Relay relay = Relay.Companion.edit(file, upstream, metadata, 5);
     BufferedSource source1 = Okio.buffer(relay.newSource());
     BufferedSource source2 = Okio.buffer(relay.newSource());
 
@@ -137,7 +137,7 @@
     Buffer upstream = new Buffer();
     upstream.writeUtf8("abcdefghij");
 
-    Relay relay1 = Relay.edit(file, upstream, metadata, 5);
+    Relay relay1 = Relay.Companion.edit(file, upstream, metadata, 5);
     BufferedSource source1 = Okio.buffer(relay1.newSource());
     assertThat(source1.readUtf8(10)).isEqualTo("abcdefghij");
     assertThat(source1.exhausted()).isTrue();
@@ -147,7 +147,7 @@
     // Since relay1 is closed, new sources cannot be created.
     assertThat(relay1.newSource()).isNull();
 
-    Relay relay2 = Relay.read(file);
+    Relay relay2 = Relay.Companion.read(file);
     assertThat(relay2.metadata()).isEqualTo(metadata);
     BufferedSource source2 = Okio.buffer(relay2.newSource());
     assertThat(source2.readUtf8(10)).isEqualTo("abcdefghij");
@@ -165,14 +165,14 @@
     Buffer upstream = new Buffer();
     upstream.writeUtf8("abcdefghij");
 
-    Relay relay1 = Relay.edit(file, upstream, metadata, 5);
+    Relay relay1 = Relay.Companion.edit(file, upstream, metadata, 5);
     BufferedSource source1 = Okio.buffer(relay1.newSource());
     assertThat(source1.readUtf8(10)).isEqualTo("abcdefghij");
     source1.close(); // Not exhausted!
     assertThat(relay1.isClosed()).isTrue();
 
     try {
-      Relay.read(file);
+      Relay.Companion.read(file);
       fail();
     } catch (IOException expected) {
       assertThat(expected.getMessage()).isEqualTo("unreadable cache file");
@@ -185,7 +185,7 @@
     Buffer upstream = new Buffer();
     upstream.writeUtf8("abcde");
 
-    Relay relay = Relay.edit(file, upstream, metadata, 1024);
+    Relay relay = Relay.Companion.edit(file, upstream, metadata, 1024);
     Source source1 = relay.newSource();
     Source source2 = relay.newSource();
 
@@ -202,7 +202,7 @@
     Pipe pipe = new Pipe(1024);
     BufferedSink sink = Okio.buffer(pipe.sink());
 
-    Relay relay = Relay.edit(file, pipe.source(), metadata, 5);
+    Relay relay = Relay.Companion.edit(file, pipe.source(), metadata, 5);
 
     Future<ByteString> future1 = executor.submit(sourceReader(relay.newSource()));
     Future<ByteString> future2 = executor.submit(sourceReader(relay.newSource()));
diff --git a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
index 8140a62d32..e9908f89f2 100644
--- a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
@@ -29,7 +29,6 @@
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Route;
-import okhttp3.internal.Internal;
 import okhttp3.internal.RecordingOkAuthenticator;
 import org.junit.Test;
 
@@ -44,10 +43,6 @@
   private final Address addressC = newAddress("c");
   private final Route routeC1 = newRoute(addressC);
 
-  static {
-    Internal.initializeInstanceForTests();
-  }
-
   @Test public void connectionsEvictedWhenIdleLongEnough() throws Exception {
     RealConnectionPool pool = new RealConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
     pool.setCleanupRunning(true); // Prevent the cleanup runnable from being started.
@@ -82,7 +77,7 @@
 
   @Test public void inUseConnectionsNotEvicted() throws Exception {
     ConnectionPool poolApi = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    RealConnectionPool pool = Internal.instance.realConnectionPool(poolApi);
+    RealConnectionPool pool = RealConnectionPool.Companion.get(poolApi);
     pool.setCleanupRunning(true); // Prevent the cleanup runnable from being started.
 
     RealConnection c1 = newConnection(pool, routeA1, 50L);
@@ -170,7 +165,7 @@
 
   @Test public void leakedAllocation() throws Exception {
     ConnectionPool poolApi = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    RealConnectionPool pool = Internal.instance.realConnectionPool(poolApi);
+    RealConnectionPool pool = RealConnectionPool.Companion.get(poolApi);
     pool.setCleanupRunning(true); // Prevent the cleanup runnable from being started.
 
     RealConnection c1 = newConnection(pool, routeA1, 0L);
@@ -178,15 +173,36 @@
 
     awaitGarbageCollection();
     assertThat(pool.cleanup(100L)).isEqualTo(0L);
-    assertThat(c1.transmitters).isEmpty();
+    assertThat(c1.getTransmitters()).isEmpty();
 
     // Can't allocate once a leak has been detected.
-    assertThat(c1.noNewExchanges).isTrue();
+    assertThat(c1.getNoNewExchanges()).isTrue();
+  }
+
+  @Test public void interruptStopsThread() throws Exception {
+    RealConnectionPool pool = new RealConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
+    RealConnection c1 = newConnection(pool, routeA1, Long.MAX_VALUE);
+
+    assertThat(pool.getCleanupRunning()).isTrue();
+
+    Thread.sleep(100);
+
+    Thread[] threads = new Thread[Thread.activeCount() * 2];
+    Thread.enumerate(threads);
+    for (Thread t: threads) {
+      if (t != null && t.getName().equals("OkHttp ConnectionPool")) {
+        t.interrupt();
+      }
+    }
+
+    Thread.sleep(100);
+
+    assertThat(pool.getCleanupRunning()).isFalse();
   }
 
   /** Use a helper method so there's no hidden reference remaining on the stack. */
   private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
-    synchronized (Internal.instance.realConnectionPool(pool)) {
+    synchronized (RealConnectionPool.Companion.get(pool)) {
       OkHttpClient client = new OkHttpClient.Builder()
           .connectionPool(pool)
           .build();
@@ -198,7 +214,8 @@ private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection conne
   }
 
   private RealConnection newConnection(RealConnectionPool pool, Route route, long idleAtNanos) {
-    RealConnection result = RealConnection.testConnection(pool, route, new Socket(), idleAtNanos);
+    RealConnection result = RealConnection.Companion.newTestConnection(
+        pool, route, new Socket(), idleAtNanos);
     synchronized (pool) {
       pool.put(result);
     }
diff --git a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
index ed3c8d304a..6fa893e07d 100644
--- a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
@@ -21,7 +21,6 @@
 import javax.net.ssl.SSLSocket;
 import okhttp3.ConnectionSpec;
 import okhttp3.TlsVersion;
-import okhttp3.internal.Internal;
 import okhttp3.tls.HandshakeCertificates;
 import org.junit.Test;
 
@@ -30,10 +29,6 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class ConnectionSpecSelectorTest {
-  static {
-    Internal.initializeInstanceForTests();
-  }
-
   public static final SSLHandshakeException RETRYABLE_EXCEPTION = new SSLHandshakeException(
       "Simulated handshake exception");
 
diff --git a/okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java b/okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
index 8d2c3aa667..a901295c4b 100644
--- a/okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
@@ -36,23 +36,26 @@
 import okhttp3.ConnectionSpec;
 import okhttp3.EventListener;
 import okhttp3.FakeDns;
+import okhttp3.OkHttpClientTestRule;
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Route;
-import okhttp3.TestUtil;
-import okhttp3.internal.Util;
 import okhttp3.internal.http.RecordingProxySelector;
 import okhttp3.tls.HandshakeCertificates;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 
 import static java.net.Proxy.NO_PROXY;
+import static okhttp3.internal.Util.immutableListOf;
 import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class RouteSelectorTest {
-  public final List<ConnectionSpec> connectionSpecs = Util.immutableList(
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+
+  public final List<ConnectionSpec> connectionSpecs = immutableListOf(
       ConnectionSpec.MODERN_TLS,
       ConnectionSpec.COMPATIBLE_TLS,
       ConnectionSpec.CLEARTEXT);
@@ -81,7 +84,7 @@
   private RouteDatabase routeDatabase = new RouteDatabase();
 
   @Before public void setUp() throws Exception {
-    call = TestUtil.defaultClient().newCall(new Request.Builder()
+    call = clientTestRule.newClient().newCall(new Request.Builder()
         .url("https://" + uriHost + ":" + uriPort + "/")
         .build());
     socketFactory = SocketFactory.getDefault();
@@ -422,19 +425,19 @@
   @Test public void getHostString() throws Exception {
     // Name proxy specification.
     InetSocketAddress socketAddress = InetSocketAddress.createUnresolved("host", 1234);
-    assertThat(RouteSelector.getSocketHost(socketAddress)).isEqualTo("host");
+    assertThat(RouteSelector.Companion.getSocketHost(socketAddress)).isEqualTo("host");
     socketAddress = InetSocketAddress.createUnresolved("127.0.0.1", 1234);
-    assertThat(RouteSelector.getSocketHost(socketAddress)).isEqualTo("127.0.0.1");
+    assertThat(RouteSelector.Companion.getSocketHost(socketAddress)).isEqualTo("127.0.0.1");
 
     // InetAddress proxy specification.
     socketAddress = new InetSocketAddress(InetAddress.getByName("localhost"), 1234);
-    assertThat(RouteSelector.getSocketHost(socketAddress)).isEqualTo("127.0.0.1");
+    assertThat(RouteSelector.Companion.getSocketHost(socketAddress)).isEqualTo("127.0.0.1");
     socketAddress = new InetSocketAddress(
         InetAddress.getByAddress(new byte[] {127, 0, 0, 1}), 1234);
-    assertThat(RouteSelector.getSocketHost(socketAddress)).isEqualTo("127.0.0.1");
+    assertThat(RouteSelector.Companion.getSocketHost(socketAddress)).isEqualTo("127.0.0.1");
     socketAddress = new InetSocketAddress(
         InetAddress.getByAddress("foobar", new byte[] {127, 0, 0, 1}), 1234);
-    assertThat(RouteSelector.getSocketHost(socketAddress)).isEqualTo("127.0.0.1");
+    assertThat(RouteSelector.Companion.getSocketHost(socketAddress)).isEqualTo("127.0.0.1");
   }
 
   @Test public void routeToString() throws Exception {
diff --git a/okhttp/src/test/java/okhttp3/internal/http/CancelTest.java b/okhttp/src/test/java/okhttp3/internal/http/CancelTest.java
index 6f11d320b7..05abf5e904 100644
--- a/okhttp/src/test/java/okhttp3/internal/http/CancelTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http/CancelTest.java
@@ -63,7 +63,7 @@
             return serverSocket;
           }
         });
-    client = clientTestRule.client.newBuilder()
+    client = clientTestRule.newClientBuilder()
         .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
           @Override protected Socket configureSocket(Socket socket) throws IOException {
             socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
diff --git a/okhttp/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java b/okhttp/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
index 73f9471fac..6a55aba932 100644
--- a/okhttp/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
+++ b/okhttp/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
@@ -21,12 +21,13 @@
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.Util;
+
+import static okhttp3.internal.Util.immutableListOf;
 
 public final class ExternalHttp2Example {
   public static void main(String[] args) throws Exception {
     OkHttpClient client = new OkHttpClient.Builder()
-        .protocols(Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1))
+        .protocols(immutableListOf(Protocol.HTTP_2, Protocol.HTTP_1_1))
         .build();
 
     Call call = client.newCall(new Request.Builder()
diff --git a/okhttp/src/test/java/okhttp3/internal/http/HttpDateTest.java b/okhttp/src/test/java/okhttp3/internal/http/HttpDateTest.java
deleted file mode 100644
index 3d9860da64..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/http/HttpDateTest.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.util.Date;
-import java.util.TimeZone;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class HttpDateTest {
-
-  private TimeZone originalDefault;
-
-  @Before
-  public void setUp() throws Exception {
-    originalDefault = TimeZone.getDefault();
-    // The default timezone should affect none of these tests: HTTP specified GMT, so we set it to
-    // something else.
-    TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles"));
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    TimeZone.setDefault(originalDefault);
-  }
-
-  @Test public void parseStandardFormats() throws Exception {
-    // RFC 822, updated by RFC 1123 with GMT.
-    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT").getTime()).isEqualTo(0L);
-    assertThat(HttpDate.parse("Fri, 06 Jun 2014 12:30:30 GMT").getTime()).isEqualTo(1402057830000L);
-
-    // RFC 850, obsoleted by RFC 1036 with GMT.
-    assertThat(HttpDate.parse("Thursday, 01-Jan-70 00:00:00 GMT").getTime()).isEqualTo(0L);
-    assertThat(HttpDate.parse("Friday, 06-Jun-14 12:30:30 GMT").getTime()).isEqualTo(1402057830000L);
-
-    // ANSI C's asctime(): should use GMT, not platform default.
-    assertThat(HttpDate.parse("Thu Jan 1 00:00:00 1970").getTime()).isEqualTo(0L);
-    assertThat(HttpDate.parse("Fri Jun 6 12:30:30 2014").getTime()).isEqualTo(1402057830000L);
-  }
-
-  @Test public void format() throws Exception {
-    assertThat(HttpDate.format(new Date(0))).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT");
-    assertThat(HttpDate.format(new Date(1402057830000L))).isEqualTo(
-        "Fri, 06 Jun 2014 12:30:30 GMT");
-  }
-
-  @Test public void parseNonStandardStrings() throws Exception {
-    // RFC 822, updated by RFC 1123 with any TZ
-    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT-01:00").getTime()).isEqualTo(3600000L);
-    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00 PST").getTime()).isEqualTo(28800000L);
-    // Ignore trailing junk
-    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT JUNK").getTime()).isEqualTo(0L);
-    // Missing timezones treated as bad.
-    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00")).isNull();
-    // Missing seconds treated as bad.
-    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00 GMT")).isNull();
-    // Extra spaces treated as bad.
-    assertThat(HttpDate.parse("Thu,  01 Jan 1970 00:00 GMT")).isNull();
-    // Missing leading zero treated as bad.
-    assertThat(HttpDate.parse("Thu, 1 Jan 1970 00:00 GMT")).isNull();
-
-    // RFC 850, obsoleted by RFC 1036 with any TZ.
-    assertThat(HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 GMT-01:00").getTime()).isEqualTo(
-        3600000L);
-    assertThat(HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST").getTime()).isEqualTo(28800000L);
-    // Ignore trailing junk
-    assertThat(HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST JUNK").getTime()).isEqualTo(
-        28800000L);
-
-    // ANSI C's asctime() format
-    // This format ignores the timezone entirely even if it is present and uses GMT.
-    assertThat(HttpDate.parse("Fri Jun 6 12:30:30 2014 PST").getTime()).isEqualTo(1402057830000L);
-    // Ignore trailing junk.
-    assertThat(HttpDate.parse("Fri Jun 6 12:30:30 2014 JUNK").getTime()).isEqualTo(1402057830000L);
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/http/HttpDateTest.kt b/okhttp/src/test/java/okhttp3/internal/http/HttpDateTest.kt
new file mode 100644
index 0000000000..a1c5dbd541
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/internal/http/HttpDateTest.kt
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.After
+import org.junit.Before
+import org.junit.Test
+import java.util.Date
+import java.util.TimeZone
+
+class HttpDateTest {
+
+  private lateinit var originalDefault: TimeZone
+
+  @Before
+  @Throws(Exception::class)
+  fun setUp() {
+    originalDefault = TimeZone.getDefault()
+    // The default timezone should affect none of these tests: HTTP specified GMT, so we set it to
+    // something else.
+    TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles"))
+  }
+
+  @After
+  @Throws(Exception::class)
+  fun tearDown() {
+    TimeZone.setDefault(originalDefault)
+  }
+
+  @Test @Throws(Exception::class)
+  fun parseStandardFormats() {
+    // RFC 822, updated by RFC 1123 with GMT.
+    assertThat("Thu, 01 Jan 1970 00:00:00 GMT".toHttpDateOrNull()!!.time).isEqualTo(0L)
+    assertThat("Fri, 06 Jun 2014 12:30:30 GMT".toHttpDateOrNull()!!.time).isEqualTo(1402057830000L)
+
+    // RFC 850, obsoleted by RFC 1036 with GMT.
+    assertThat("Thursday, 01-Jan-70 00:00:00 GMT".toHttpDateOrNull()!!.time).isEqualTo(0L)
+    assertThat("Friday, 06-Jun-14 12:30:30 GMT".toHttpDateOrNull()!!.time).isEqualTo(1402057830000L)
+
+    // ANSI C's asctime(): should use GMT, not platform default.
+    assertThat("Thu Jan 1 00:00:00 1970".toHttpDateOrNull()!!.time).isEqualTo(0L)
+    assertThat("Fri Jun 6 12:30:30 2014".toHttpDateOrNull()!!.time).isEqualTo(1402057830000L)
+  }
+
+  @Test @Throws(Exception::class)
+  fun format() {
+    assertThat(Date(0L).toHttpDateString()).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT")
+    assertThat(Date(1402057830000L).toHttpDateString()).isEqualTo("Fri, 06 Jun 2014 12:30:30 GMT")
+  }
+
+  @Test @Throws(Exception::class)
+  fun parseNonStandardStrings() {
+    // RFC 822, updated by RFC 1123 with any TZ
+    assertThat("Thu, 01 Jan 1970 00:00:00 GMT-01:00".toHttpDateOrNull()!!.time).isEqualTo(3600000L)
+    assertThat("Thu, 01 Jan 1970 00:00:00 PST".toHttpDateOrNull()!!.time).isEqualTo(28800000L)
+    // Ignore trailing junk
+    assertThat("Thu, 01 Jan 1970 00:00:00 GMT JUNK".toHttpDateOrNull()!!.time).isEqualTo(0L)
+    // Missing timezones treated as bad.
+    assertThat("Thu, 01 Jan 1970 00:00:00".toHttpDateOrNull()).isNull()
+    // Missing seconds treated as bad.
+    assertThat("Thu, 01 Jan 1970 00:00 GMT".toHttpDateOrNull()).isNull()
+    // Extra spaces treated as bad.
+    assertThat("Thu,  01 Jan 1970 00:00 GMT".toHttpDateOrNull()).isNull()
+    // Missing leading zero treated as bad.
+    assertThat("Thu, 1 Jan 1970 00:00 GMT".toHttpDateOrNull()).isNull()
+
+    // RFC 850, obsoleted by RFC 1036 with any TZ.
+    assertThat("Thursday, 01-Jan-1970 00:00:00 GMT-01:00".toHttpDateOrNull()!!.time)
+        .isEqualTo(3600000L)
+    assertThat("Thursday, 01-Jan-1970 00:00:00 PST".toHttpDateOrNull()!!.time)
+        .isEqualTo(28800000L)
+    // Ignore trailing junk
+    assertThat("Thursday, 01-Jan-1970 00:00:00 PST JUNK".toHttpDateOrNull()!!.time)
+        .isEqualTo(28800000L)
+
+    // ANSI C's asctime() format
+    // This format ignores the timezone entirely even if it is present and uses GMT.
+    assertThat("Fri Jun 6 12:30:30 2014 PST".toHttpDateOrNull()!!.time).isEqualTo(1402057830000L)
+    // Ignore trailing junk.
+    assertThat("Fri Jun 6 12:30:30 2014 JUNK".toHttpDateOrNull()!!.time).isEqualTo(1402057830000L)
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/internal/http/StatusLineTest.java b/okhttp/src/test/java/okhttp3/internal/http/StatusLineTest.java
index 08e002de7e..b8b49828f8 100644
--- a/okhttp/src/test/java/okhttp3/internal/http/StatusLineTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http/StatusLineTest.java
@@ -28,7 +28,8 @@
     String message = "Temporary Redirect";
     int version = 1;
     int code = 200;
-    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code + " " + message);
+    StatusLine statusLine = StatusLine.Companion.parse(
+        "HTTP/1." + version + " " + code + " " + message);
     assertThat(statusLine.message).isEqualTo(message);
     assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_1);
     assertThat(statusLine.code).isEqualTo(code);
@@ -37,7 +38,7 @@
   @Test public void emptyMessage() throws IOException {
     int version = 1;
     int code = 503;
-    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code + " ");
+    StatusLine statusLine = StatusLine.Companion.parse("HTTP/1." + version + " " + code + " ");
     assertThat(statusLine.message).isEqualTo("");
     assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_1);
     assertThat(statusLine.code).isEqualTo(code);
@@ -50,7 +51,7 @@
   @Test public void emptyMessageAndNoLeadingSpace() throws IOException {
     int version = 1;
     int code = 503;
-    StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code);
+    StatusLine statusLine = StatusLine.Companion.parse("HTTP/1." + version + " " + code);
     assertThat(statusLine.message).isEqualTo("");
     assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_1);
     assertThat(statusLine.code).isEqualTo(code);
@@ -58,7 +59,7 @@
 
   // https://github.com/square/okhttp/issues/386
   @Test public void shoutcast() throws IOException {
-    StatusLine statusLine = StatusLine.parse("ICY 200 OK");
+    StatusLine statusLine = StatusLine.Companion.parse("ICY 200 OK");
     assertThat(statusLine.message).isEqualTo("OK");
     assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_0);
     assertThat(statusLine.code).isEqualTo(200);
@@ -109,7 +110,7 @@
 
   private void assertInvalid(String statusLine) throws IOException {
     try {
-      StatusLine.parse(statusLine);
+      StatusLine.Companion.parse(statusLine);
       fail();
     } catch (ProtocolException expected) {
     }
diff --git a/okhttp/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java b/okhttp/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
index 86364052f6..dab57bb7e0 100644
--- a/okhttp/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
@@ -50,7 +50,7 @@
   private static final int SOCKET_BUFFER_SIZE = 256 * 1024;
 
   private MockWebServer server;
-  private OkHttpClient client = clientTestRule.client;
+  private OkHttpClient client;
 
   @Before public void setUp() throws Exception {
     // Sockets on some platforms can have large buffers that mean writes do not block when
@@ -65,7 +65,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
             return serverSocket;
           }
         });
-    client = clientTestRule.client.newBuilder()
+    client = clientTestRule.newClientBuilder()
         .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
           @Override
           protected Socket configureSocket(Socket socket) throws IOException {
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/FrameLogTest.java b/okhttp/src/test/java/okhttp3/internal/http2/FrameLogTest.java
index 4ab9ca9340..71c26860d9 100644
--- a/okhttp/src/test/java/okhttp3/internal/http2/FrameLogTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/FrameLogTest.java
@@ -30,7 +30,6 @@
 import static okhttp3.internal.http2.Http2.TYPE_PING;
 import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
 import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
-import static okhttp3.internal.http2.Http2.frameLog;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public final class FrameLogTest {
@@ -89,7 +88,7 @@
    */
   @Test public void allFormattedFlagsWithValidBits() {
     List<String> formattedFlags = new ArrayList<>(0x40); // Highest valid flag is 0x20.
-    for (byte i = 0; i < 0x40; i++) formattedFlags.add(Http2.formatFlags(TYPE_HEADERS, i));
+    for (byte i = 0; i < 0x40; i++) formattedFlags.add(Http2.INSTANCE.formatFlags(TYPE_HEADERS, i));
 
     assertThat(formattedFlags).containsExactly(
         "",
@@ -158,4 +157,8 @@
         "00111111"
     );
   }
+
+  private String frameLog(boolean inbound, int streamId, int length, int type, int flags) {
+    return Http2.INSTANCE.frameLog(inbound, streamId, length, type, flags);
+  }
 }
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index b48830cd8f..f8d5fb82ca 100644
--- a/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -47,7 +47,6 @@
 import static java.util.Arrays.asList;
 import static okhttp3.TestUtil.headerEntries;
 import static okhttp3.TestUtil.repeat;
-import static okhttp3.internal.Internal.initializeInstanceForTests;
 import static okhttp3.internal.Util.EMPTY_BYTE_ARRAY;
 import static okhttp3.internal.Util.EMPTY_HEADERS;
 import static okhttp3.internal.http2.Http2Connection.Listener.REFUSE_INCOMING_STREAMS;
@@ -67,10 +66,6 @@
 
   @Rule public final TestRule timeout = new Timeout(5_000, TimeUnit.MILLISECONDS);
 
-  @Before public void setup() {
-    initializeInstanceForTests();
-  }
-
   @After public void tearDown() throws Exception {
     peer.close();
   }
@@ -119,7 +114,7 @@
     // This stream was created *after* the connection settings were adjusted.
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
 
-    assertThat(connection.peerSettings.getInitialWindowSize()).isEqualTo(3368);
+    assertThat(connection.getPeerSettings().getInitialWindowSize()).isEqualTo(3368);
     // New Stream is has the most recent initial window size.
     assertThat(stream.getBytesLeftInWriteWindow()).isEqualTo(3368);
   }
@@ -132,8 +127,8 @@
     Http2Connection connection = connectWithSettings(client, settings);
 
     // Verify the peer's settings were read and applied.
-    assertThat(connection.peerSettings.getHeaderTableSize()).isEqualTo(0);
-    Http2Writer writer = connection.writer;
+    assertThat(connection.getPeerSettings().getHeaderTableSize()).isEqualTo(0);
+    Http2Writer writer = connection.getWriter();
     assertThat(writer.getHpackWriter().dynamicTableByteCount).isEqualTo(0);
     assertThat(writer.getHpackWriter().headerTableSizeSetting).isEqualTo(0);
   }
@@ -146,7 +141,7 @@
     Http2Connection connection = connectWithSettings(client, settings);
 
     // verify the peer's settings were read and applied.
-    assertThat(connection.peerSettings.getEnablePush(true)).isFalse();
+    assertThat(connection.getPeerSettings().getEnablePush(true)).isFalse();
   }
 
   @Test public void peerIncreasesMaxFrameSize() throws Exception {
@@ -157,8 +152,8 @@
     Http2Connection connection = connectWithSettings(true, settings);
 
     // verify the peer's settings were read and applied.
-    assertThat(connection.peerSettings.getMaxFrameSize(-1)).isEqualTo(newMaxFrameSize);
-    assertThat(connection.writer.maxDataLength()).isEqualTo(newMaxFrameSize);
+    assertThat(connection.getPeerSettings().getMaxFrameSize(-1)).isEqualTo(newMaxFrameSize);
+    assertThat(connection.getWriter().maxDataLength()).isEqualTo(newMaxFrameSize);
   }
 
   /**
@@ -234,7 +229,7 @@
     InFrame frame3 = peer.takeFrame();
     assertThat(frame3.type).isEqualTo(Http2.TYPE_RST_STREAM);
 
-    assertThat(connection.unacknowledgedBytesRead).isEqualTo(2048);
+    assertThat(connection.getUnacknowledgedBytesRead()).isEqualTo(2048);
   }
 
   @Test public void receiveGoAwayHttp2() throws Exception {
@@ -310,7 +305,7 @@
 
     // Play it back.
     Http2Connection connection = connect(peer);
-    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
+    connection.getOkHttpSettings().set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertThat(stream.getUnacknowledgedBytesRead()).isEqualTo(0);
     assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
@@ -892,7 +887,7 @@
     Http2Connection connection = connect(peer, IGNORE, listener);
 
     synchronized (connection) {
-      assertThat(connection.peerSettings.getMaxConcurrentStreams(-1)).isEqualTo(10);
+      assertThat(connection.getPeerSettings().getMaxConcurrentStreams(-1)).isEqualTo(10);
     }
     maxConcurrentStreamsUpdated.await();
     assertThat(maxConcurrentStreams.get()).isEqualTo(10);
@@ -922,10 +917,10 @@
     assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_SETTINGS);
     assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
     synchronized (connection) {
-      assertThat(connection.peerSettings.getHeaderTableSize()).isEqualTo(10000);
-      assertThat(connection.peerSettings.getInitialWindowSize()).isEqualTo(40000);
-      assertThat(connection.peerSettings.getMaxFrameSize(-1)).isEqualTo(50000);
-      assertThat(connection.peerSettings.getMaxConcurrentStreams(-1)).isEqualTo(60000);
+      assertThat(connection.getPeerSettings().getHeaderTableSize()).isEqualTo(10000);
+      assertThat(connection.getPeerSettings().getInitialWindowSize()).isEqualTo(40000);
+      assertThat(connection.getPeerSettings().getMaxFrameSize(-1)).isEqualTo(50000);
+      assertThat(connection.getPeerSettings().getMaxConcurrentStreams(-1)).isEqualTo(60000);
     }
   }
 
@@ -947,14 +942,14 @@
     // fake a settings frame with clear flag set.
     Settings settings2 = new Settings();
     settings2.set(MAX_CONCURRENT_STREAMS, 60000);
-    connection.readerRunnable.settings(true, settings2);
+    connection.getReaderRunnable().settings(true, settings2);
 
     synchronized (connection) {
-      assertThat(connection.peerSettings.getHeaderTableSize()).isEqualTo(-1);
-      assertThat(connection.peerSettings.getInitialWindowSize()).isEqualTo(
+      assertThat(connection.getPeerSettings().getHeaderTableSize()).isEqualTo(-1);
+      assertThat(connection.getPeerSettings().getInitialWindowSize()).isEqualTo(
           (long) DEFAULT_INITIAL_WINDOW_SIZE);
-      assertThat(connection.peerSettings.getMaxFrameSize(-1)).isEqualTo(-1);
-      assertThat(connection.peerSettings.getMaxConcurrentStreams(-1)).isEqualTo(60000);
+      assertThat(connection.getPeerSettings().getMaxFrameSize(-1)).isEqualTo(-1);
+      assertThat(connection.getPeerSettings().getMaxConcurrentStreams(-1)).isEqualTo(60000);
     }
   }
 
@@ -1329,7 +1324,7 @@
     Http2Connection connection = connect(peer);
     connection.newStream(headerEntries("a", "android"), false);
     synchronized (connection) {
-      if (connection.shutdown) {
+      if (connection.isShutdown()) {
         throw new ConnectionShutdownException();
       }
     }
@@ -1640,7 +1635,7 @@
 
     // Play it back.
     Http2Connection connection = connect(peer);
-    connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
+    connection.getOkHttpSettings().set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     assertThat(stream.getUnacknowledgedBytesRead()).isEqualTo(0);
     assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
@@ -1754,13 +1749,13 @@
     out1.flush();
 
     // Check that we've filled the window for both the stream and also the connection.
-    assertThat(connection.bytesLeftInWriteWindow).isEqualTo(0);
+    assertThat(connection.getBytesLeftInWriteWindow()).isEqualTo(0);
     assertThat(connection.getStream(3).getBytesLeftInWriteWindow()).isEqualTo(0);
 
     // receiving a window update on the connection will unblock new streams.
-    connection.readerRunnable.windowUpdate(0, 3);
+    connection.getReaderRunnable().windowUpdate(0, 3);
 
-    assertThat(connection.bytesLeftInWriteWindow).isEqualTo(3);
+    assertThat(connection.getBytesLeftInWriteWindow()).isEqualTo(3);
     assertThat(connection.getStream(3).getBytesLeftInWriteWindow()).isEqualTo(0);
 
     // Another stream should be able to send data even though 1 is blocked.
@@ -1769,7 +1764,7 @@
     out2.writeUtf8("foo");
     out2.flush();
 
-    assertThat(connection.bytesLeftInWriteWindow).isEqualTo(0);
+    assertThat(connection.getBytesLeftInWriteWindow()).isEqualTo(0);
     assertThat(connection.getStream(3).getBytesLeftInWriteWindow()).isEqualTo(0);
     assertThat(connection.getStream(5).getBytesLeftInWriteWindow()).isEqualTo(
         (long) (DEFAULT_INITIAL_WINDOW_SIZE - 3));
@@ -1847,7 +1842,7 @@ private Http2Connection connectWithSettings(boolean client, Settings settings) t
   }
 
   private Http2Connection connect(MockHttp2Peer peer) throws Exception {
-    return connect(peer, IGNORE, REFUSE_INCOMING_STREAMS);
+    return connect(peer, IGNORE, Http2Connection.Listener.REFUSE_INCOMING_STREAMS);
   }
 
   /** Builds a new connection to {@code peer} with settings acked. */
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 953e9ba66a..7a05f6b43d 100644
--- a/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -35,14 +35,15 @@
 import okhttp3.Cache;
 import okhttp3.Call;
 import okhttp3.Callback;
+import okhttp3.Connection;
 import okhttp3.Cookie;
 import okhttp3.Credentials;
+import okhttp3.EventListener;
 import okhttp3.Headers;
 import okhttp3.Interceptor;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.OkHttpClientTestRule;
-import okhttp3.PlatformRule;
 import okhttp3.Protocol;
 import okhttp3.RecordingCookieJar;
 import okhttp3.RecordingHostnameVerifier;
@@ -62,6 +63,8 @@
 import okhttp3.mockwebserver.QueueDispatcher;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.testing.Flaky;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -72,7 +75,9 @@
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
 import org.junit.rules.TemporaryFolder;
+import org.junit.rules.TestRule;
 import org.junit.rules.Timeout;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -82,6 +87,7 @@
 import static java.util.Arrays.asList;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.internal.Util.discard;
 import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.data.Offset.offset;
@@ -91,7 +97,11 @@
 
 /** Test how HTTP/2 interacts with HTTP features. */
 @RunWith(Parameterized.class)
+@Flaky
 public final class HttpOverHttp2Test {
+  // Flaky https://github.com/square/okhttp/issues/4632
+  // Flaky https://github.com/square/okhttp/issues/4633
+
   private static final Logger http2Logger = Logger.getLogger(Http2.class.getName());
   private static final HandshakeCertificates handshakeCertificates = localhost();
 
@@ -100,11 +110,12 @@
     return asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_2);
   }
 
-  @Rule public final PlatformRule platform = new PlatformRule();
+  private PlatformRule platform = new PlatformRule();
+  @Rule public final TestRule chain =
+      RuleChain.outerRule(platform).around(new Timeout(5, SECONDS));
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
   @Rule public final MockWebServer server = new MockWebServer();
   @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-  @Rule public final Timeout timeout = new Timeout(5, SECONDS);
 
   private OkHttpClient client;
   private Cache cache;
@@ -114,42 +125,31 @@
   private Protocol protocol;
 
   public HttpOverHttp2Test(Protocol protocol) {
-    this.client = protocol == Protocol.HTTP_2 ? buildHttp2Client() : buildH2PriorKnowledgeClient();
-    this.scheme = protocol == Protocol.HTTP_2 ? "https" : "http";
     this.protocol = protocol;
   }
 
-  @Before
-  public void checkHttp2() {
+  @Before public void setUp() {
+    platform.assumeNotOpenJSSE();
+
     if (protocol == Protocol.HTTP_2) {
       platform.assumeHttp2Support();
-    }
-  }
-
-  private OkHttpClient buildH2PriorKnowledgeClient() {
-    return clientTestRule.client.newBuilder()
-        .protocols(asList(Protocol.H2_PRIOR_KNOWLEDGE))
-        .build();
-  }
-
-  private OkHttpClient buildHttp2Client() {
-    return clientTestRule.client.newBuilder()
-        .protocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-  }
-
-  @Before public void setUp() {
-    if (protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
-      server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE));
-    } else {
       server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+      client = clientTestRule.newClientBuilder()
+          .protocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
+          .sslSocketFactory(
+              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+          .hostnameVerifier(new RecordingHostnameVerifier())
+          .build();
+      scheme = "https";
+    } else {
+      server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE));
+      client = clientTestRule.newClientBuilder()
+          .protocols(asList(Protocol.H2_PRIOR_KNOWLEDGE))
+          .build();
+      scheme = "http";
     }
 
     cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-
     http2Logger.addHandler(http2Handler);
     previousLevel = http2Logger.getLevel();
     http2Logger.setLevel(Level.FINE);
@@ -328,7 +328,7 @@ private OkHttpClient buildHttp2Client() {
     // Cancel the call and discard what we've buffered for the response body. This should free up
     // the connection flow-control window so new requests can proceed.
     call1.cancel();
-    assertThat(Util.discard(response1.body().source(), 1, TimeUnit.SECONDS))
+    assertThat(discard(response1.body().source(), 1, TimeUnit.SECONDS))
         .overridingErrorMessage("Call should not have completed successfully.")
         .isFalse();
 
@@ -605,16 +605,16 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .build();
     Call call1 = client1
         .newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
+            .url(server.url("/"))
+            .build());
 
     OkHttpClient client2 = client.newBuilder()
         .readTimeout(200, MILLISECONDS)
         .build();
     Call call2 = client2
         .newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
+            .url(server.url("/"))
+            .build());
 
     Response response1 = call1.execute();
     assertThat(response1.body().string()).isEqualTo("A");
@@ -909,26 +909,26 @@ private void waitForDataFrames(int dataLength) throws Exception {
     QueueDispatcher dispatcher =
         new RespondAfterCancelDispatcher(responseDequeuedLatches, requestCanceledLatches);
     dispatcher.enqueueResponse(new MockResponse()
-            .setBodyDelay(10, TimeUnit.SECONDS)
-            .setBody("abc"));
+        .setBodyDelay(10, TimeUnit.SECONDS)
+        .setBody("abc"));
     dispatcher.enqueueResponse(new MockResponse()
-            .setBodyDelay(10, TimeUnit.SECONDS)
-            .setBody("def"));
+        .setBodyDelay(10, TimeUnit.SECONDS)
+        .setBody("def"));
     dispatcher.enqueueResponse(new MockResponse()
-            .setBody("ghi"));
+        .setBody("ghi"));
     server.setDispatcher(dispatcher);
 
     client = client.newBuilder()
-            .dns(new DoubleInetAddressDns())
-            .build();
+        .dns(new DoubleInetAddressDns())
+        .build();
 
     callAndCancel(0, responseDequeuedLatches.get(0), requestCanceledLatches.get(0));
     callAndCancel(1, responseDequeuedLatches.get(1), requestCanceledLatches.get(1));
 
     // Make a third request to ensure the connection is reused.
     Call call = client.newCall(new Request.Builder()
-            .url(server.url("/"))
-            .build());
+        .url(server.url("/"))
+        .build());
     Response response = call.execute();
     assertThat(response.body().string()).isEqualTo("ghi");
     assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
@@ -1233,7 +1233,13 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
         (long) 1);
   }
 
+  @Flaky
   @Test public void missingPongsFailsConnection() throws Exception {
+    if (protocol == Protocol.HTTP_2) {
+      // https://github.com/square/okhttp/issues/5221
+      platform.expectFailureFromJdkVersion(12);
+    }
+
     // Ping every 500 ms, starting at 500 ms.
     client = client.newBuilder()
         .readTimeout(10, TimeUnit.SECONDS) // Confirm we fail before the read timeout.
@@ -1270,7 +1276,7 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
   }
 
   private String firstFrame(List<String> logs, String type) {
-    for (String log: logs) {
+    for (String log : logs) {
       if (log.contains(type)) {
         return log;
       }
@@ -1280,7 +1286,7 @@ private String firstFrame(List<String> logs, String type) {
 
   private int countFrames(List<String> logs, String message) {
     int result = 0;
-    for (String log: logs) {
+    for (String log : logs) {
       if (log.equals(message)) {
         result++;
       }
@@ -1406,7 +1412,9 @@ private int countFrames(List<String> logs, String message) {
     assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
+  @Flaky
   @Test public void responseHeadersAfterGoaway() throws Exception {
+    // Flaky https://github.com/square/okhttp/issues/4836
     server.enqueue(new MockResponse()
         .setHeadersDelay(1, SECONDS)
         .setBody("ABC"));
@@ -1419,6 +1427,7 @@ private int countFrames(List<String> logs, String message) {
       @Override public void onResponse(Call call, Response response) throws IOException {
         bodies.add(response.body().string());
       }
+
       @Override public void onFailure(Call call, IOException e) {
         System.out.println(e);
       }
@@ -1576,4 +1585,39 @@ private Buffer gzip(String bytes) throws IOException {
       }
     }
   }
+
+  /** https://github.com/square/okhttp/issues/4875 */
+  @Test
+  public void shutdownAfterLateCoalescing() throws Exception {
+    CountDownLatch latch = new CountDownLatch(2);
+
+    Callback callback = new Callback() {
+      @Override public void onResponse(Call call, Response response) {
+        fail();
+      }
+
+      @Override public void onFailure(Call call, IOException e) {
+        latch.countDown();
+      }
+    };
+
+    client = client.newBuilder().eventListener(new EventListener() {
+      int callCount;
+
+      @Override public void connectionAcquired(Call call, Connection connection) {
+        try {
+          if (callCount++ == 1) {
+            server.shutdown();
+          }
+        } catch (IOException e) {
+          fail();
+        }
+      }
+    }).build();
+
+    client.newCall(new Request.Builder().url(server.url("")).build()).enqueue(callback);
+    client.newCall(new Request.Builder().url(server.url("")).build()).enqueue(callback);
+
+    latch.await();
+  }
 }
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java b/okhttp/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
index 1ade5b1dde..a773bf1948 100644
--- a/okhttp/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
@@ -37,6 +37,8 @@
 import okio.ByteString;
 import okio.Okio;
 
+import static okhttp3.internal.Util.closeQuietly;
+
 /** Replays prerecorded outgoing frames and records incoming frames. */
 public final class MockHttp2Peer implements Closeable {
   private static final Logger logger = Logger.getLogger(MockHttp2Peer.class.getName());
@@ -114,7 +116,7 @@ public void play() throws IOException {
       try {
         readAndWriteFrames();
       } catch (IOException e) {
-        Util.closeQuietly(MockHttp2Peer.this);
+        closeQuietly(MockHttp2Peer.this);
         logger.info(MockHttp2Peer.this + " done: " + e.getMessage());
       }
     });
@@ -181,8 +183,12 @@ public Socket openSocket() throws IOException {
 
   @Override public synchronized void close() throws IOException {
     executor.shutdown();
-    Util.closeQuietly(socket);
-    Util.closeQuietly(serverSocket);
+    if (socket != null) {
+      closeQuietly(socket);
+    }
+    if (serverSocket != null) {
+      closeQuietly(serverSocket);
+    }
   }
 
   @Override public String toString() {
diff --git a/okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java b/okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
index 95046f2237..e738f07814 100644
--- a/okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
@@ -15,7 +15,7 @@
  */
 package okhttp3.internal.platform;
 
-import okhttp3.PlatformRule;
+import okhttp3.testing.PlatformRule;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -31,13 +31,13 @@ public void testBuildsWithJettyBoot() {
     assumeTrue(System.getProperty("java.specification.version").equals("1.8"));
     platform.assumeJettyBootEnabled();
 
-    assertThat(Jdk8WithJettyBootPlatform.buildIfSupported()).isNotNull();
+    assertThat(Jdk8WithJettyBootPlatform.Companion.buildIfSupported()).isNotNull();
   }
 
   @Test
   public void testNotBuildWithOther() {
     assumeFalse(System.getProperty("java.specification.version").equals("1.8"));
 
-    assertThat(Jdk8WithJettyBootPlatform.buildIfSupported()).isNull();
+    assertThat(Jdk8WithJettyBootPlatform.Companion.buildIfSupported()).isNull();
   }
 }
diff --git a/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java b/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
index ff00d8d654..12e085e18c 100644
--- a/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
@@ -16,7 +16,7 @@
 package okhttp3.internal.platform;
 
 import java.lang.reflect.Method;
-import okhttp3.PlatformRule;
+import okhttp3.testing.PlatformRule;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -27,12 +27,12 @@
 
   @Test
   public void buildsWhenJdk9() {
-    assertThat(Jdk9Platform.buildIfSupported()).isNotNull();
+    assertThat(Jdk9Platform.Companion.buildIfSupported()).isNotNull();
   }
 
   @Test
   public void findsAlpnMethods() {
-    Jdk9Platform platform = Jdk9Platform.buildIfSupported();
+    Jdk9Platform platform = Jdk9Platform.Companion.buildIfSupported();
 
     assertThat(platform.getProtocolMethod.getName()).isEqualTo("getApplicationProtocol");
     assertThat(platform.setProtocolMethod.getName()).isEqualTo("setApplicationProtocols");
diff --git a/okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java b/okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java
index fe399a1f16..f2dc6ef4c9 100644
--- a/okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java
@@ -15,7 +15,7 @@
  */
 package okhttp3.internal.platform;
 
-import okhttp3.PlatformRule;
+import okhttp3.testing.PlatformRule;
 import org.junit.Rule;
 import org.junit.Test;
 
diff --git a/okhttp/src/test/java/okhttp3/internal/platform/android/AndroidSocketAdapterTest.kt b/okhttp/src/test/java/okhttp3/internal/platform/android/AndroidSocketAdapterTest.kt
new file mode 100644
index 0000000000..d9d6017336
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/internal/platform/android/AndroidSocketAdapterTest.kt
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform.android
+
+import okhttp3.DelegatingSSLSocket
+import okhttp3.DelegatingSSLSocketFactory
+import okhttp3.Protocol.HTTP_1_1
+import okhttp3.Protocol.HTTP_2
+import org.conscrypt.Conscrypt
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertNotNull
+import org.junit.Assert.assertNull
+import org.junit.Assert.assertTrue
+import org.junit.Assume.assumeFalse
+import org.junit.Assume.assumeTrue
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+import java.security.Provider
+import javax.net.ssl.SSLContext
+import javax.net.ssl.SSLSocket
+
+@RunWith(Parameterized::class)
+class AndroidSocketAdapterTest(private val adapter: SocketAdapter) {
+  private val provider: Provider = Conscrypt.newProviderBuilder().provideTrustManager(true).build()
+  val context: SSLContext = SSLContext.getInstance("TLS", provider)
+
+  init {
+    context.init(null, null, null)
+  }
+
+  @Test
+  fun testMatchesSupportedSocket() {
+    val socketFactory = context.socketFactory
+
+    val sslSocket = socketFactory.createSocket() as SSLSocket
+    assertTrue(adapter.matchesSocket(sslSocket))
+
+    adapter.configureTlsExtensions(sslSocket, "example.com", listOf(HTTP_2, HTTP_1_1))
+    // not connected
+    assertNull(adapter.getSelectedProtocol(sslSocket))
+  }
+
+  @Test
+  fun testMatchesSupportedAndroidSocketFactory() {
+    assumeTrue(adapter is StandardAndroidSocketAdapter)
+
+    assertTrue(adapter.matchesSocketFactory(context.socketFactory))
+    assertNotNull(adapter.trustManager(context.socketFactory))
+  }
+
+  @Test
+  fun testDoesntMatchSupportedCustomSocketFactory() {
+    assumeFalse(adapter is StandardAndroidSocketAdapter)
+
+    assertFalse(adapter.matchesSocketFactory(context.socketFactory))
+    assertNull(adapter.trustManager(context.socketFactory))
+  }
+
+  @Test
+  fun testCustomSocket() {
+    val socketFactory = DelegatingSSLSocketFactory(context.socketFactory)
+
+    assertFalse(adapter.matchesSocketFactory(socketFactory))
+
+    val sslSocket =
+        object : DelegatingSSLSocket(context.socketFactory.createSocket() as SSLSocket) {}
+    assertFalse(adapter.matchesSocket(sslSocket))
+
+    adapter.configureTlsExtensions(sslSocket, "example.com", listOf(HTTP_2, HTTP_1_1))
+    // not connected
+    assertNull(adapter.getSelectedProtocol(sslSocket))
+  }
+
+  companion object {
+    @JvmStatic
+    @Parameterized.Parameters(name = "{0}")
+    fun data(): Collection<SocketAdapter> {
+      return listOf(
+          ConscryptSocketAdapter,
+          DeferredSocketAdapter("org.conscrypt"),
+          AndroidSocketAdapter.buildIfSupported("org.conscrypt")!!,
+          StandardAndroidSocketAdapter.buildIfSupported("org.conscrypt")!!
+      )
+    }
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
index 70d44bbe28..46a107e46f 100644
--- a/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
@@ -17,13 +17,13 @@
 
 import java.io.IOException;
 import java.io.InputStream;
-import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.GzipSource;
 import okio.Okio;
 import org.junit.Test;
 
+import static okhttp3.internal.HostnamesKt.toCanonicalHost;
 import static okhttp3.internal.publicsuffix.PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
@@ -269,19 +269,19 @@ private void checkPublicSuffix(String domain, String registrablePart) {
       try {
         publicSuffixDatabase.getEffectiveTldPlusOne(null);
         fail();
-      } catch (NullPointerException expected) {
+      } catch (IllegalArgumentException expected) {
       }
       return;
     }
 
-    String canonicalDomain = Util.canonicalizeHost(domain);
+    String canonicalDomain = toCanonicalHost(domain);
     if (canonicalDomain == null) return;
 
     String result = publicSuffixDatabase.getEffectiveTldPlusOne(canonicalDomain);
     if (registrablePart == null) {
       assertThat(result).isNull();
     } else {
-      assertThat(result).isEqualTo(Util.canonicalizeHost(registrablePart));
+      assertThat(result).isEqualTo(toCanonicalHost(registrablePart));
     }
   }
 }
diff --git a/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
index 50b1f8703a..f79f8d074a 100644
--- a/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
+++ b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
@@ -82,7 +82,8 @@ public static void main(String... args) throws IOException {
         throw new RuntimeException("Unable to create resource directory!");
       }
 
-      Sink fileSink = Okio.sink(new File(resources, PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE));
+      Sink fileSink = Okio.sink(new File(resources,
+          PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE));
       try (BufferedSink sink = Okio.buffer(new GzipSink(fileSink))) {
         sink.writeInt(totalRuleBytes);
         for (ByteString domain : sortedRules) {
diff --git a/okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
index 06cd8b5265..b9223ff838 100644
--- a/okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
@@ -30,7 +30,7 @@
 import okhttp3.Call;
 import okhttp3.CertificatePinner;
 import okhttp3.OkHttpClient;
-import okhttp3.PlatformRule;
+import okhttp3.OkHttpClientTestRule;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
 import okhttp3.Response;
@@ -38,28 +38,26 @@
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okhttp3.tls.HeldCertificate;
 import org.junit.Rule;
 import org.junit.Test;
 
-import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.internal.platform.PlatformTest.getJvmSpecVersion;
 import static okhttp3.tls.internal.TlsUtil.newKeyManager;
 import static okhttp3.tls.internal.TlsUtil.newTrustManager;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeFalse;
 
 public final class CertificatePinnerChainValidationTest {
   @Rule public final PlatformRule platform = new PlatformRule();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   @Rule public final MockWebServer server = new MockWebServer();
 
   /** The pinner should pull the root certificate from the trust manager. */
   @Test public void pinRootNotPresentInChain() throws Exception {
-    // TODO https://github.com/square/okhttp/issues/4703
-    assumeFalse(getJvmSpecVersion().equals("11"));
+    // Fails on 11.0.1 https://github.com/square/okhttp/issues/4703
 
     HeldCertificate rootCa = new HeldCertificate.Builder()
         .serialNumber(1L)
@@ -83,7 +81,7 @@
     HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
         .addTrustedCertificate(rootCa.certificate())
         .build();
-    OkHttpClient client = defaultClient().newBuilder()
+    OkHttpClient client = clientTestRule.newClientBuilder()
         .sslSocketFactory(
             handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
@@ -118,8 +116,7 @@
 
   /** The pinner should accept an intermediate from the server's chain. */
   @Test public void pinIntermediatePresentInChain() throws Exception {
-    // TODO https://github.com/square/okhttp/issues/4703
-    assumeFalse(getJvmSpecVersion().equals("11"));
+    // Fails on 11.0.1 https://github.com/square/okhttp/issues/4703
 
     HeldCertificate rootCa = new HeldCertificate.Builder()
         .serialNumber(1L)
@@ -143,7 +140,7 @@
     HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
         .addTrustedCertificate(rootCa.certificate())
         .build();
-    OkHttpClient client = defaultClient().newBuilder()
+    OkHttpClient client = clientTestRule.newClientBuilder()
         .sslSocketFactory(
             handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
@@ -183,7 +180,7 @@
 
   @Test public void unrelatedPinnedLeafCertificateInChain() throws Exception {
     // https://github.com/square/okhttp/issues/4729
-    assumeFalse(getJvmSpecVersion().matches("1[123]"));
+    platform.expectFailureOnConscryptPlatform();
 
     // Start with a trusted root CA certificate.
     HeldCertificate rootCa = new HeldCertificate.Builder()
@@ -212,7 +209,7 @@
     HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
         .addTrustedCertificate(rootCa.certificate())
         .build();
-    OkHttpClient client = defaultClient().newBuilder()
+    OkHttpClient client = clientTestRule.newClientBuilder()
         .sslSocketFactory(
             handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
@@ -261,7 +258,7 @@
 
   @Test public void unrelatedPinnedIntermediateCertificateInChain() throws Exception {
     // https://github.com/square/okhttp/issues/4729
-    assumeFalse(getJvmSpecVersion().matches("1[123]"));
+    platform.expectFailureOnConscryptPlatform();
 
     // Start with two root CA certificates, one is good and the other is compromised.
     HeldCertificate rootCa = new HeldCertificate.Builder()
@@ -291,7 +288,7 @@
         .addTrustedCertificate(rootCa.certificate())
         .addTrustedCertificate(compromisedRootCa.certificate())
         .build();
-    OkHttpClient client = defaultClient().newBuilder()
+    OkHttpClient client = clientTestRule.newClientBuilder()
         .sslSocketFactory(
             handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
@@ -352,7 +349,7 @@ private SSLSocketFactory newServerSocketFactory(HeldCertificate heldCertificate,
     X509KeyManager x509KeyManager = newKeyManager(keystoreType, heldCertificate, intermediates);
     X509TrustManager trustManager = newTrustManager(keystoreType, Collections.emptyList());
     SSLContext sslContext = Platform.get().newSSLContext();
-    sslContext.init(new KeyManager[] { x509KeyManager }, new TrustManager[] { trustManager },
+    sslContext.init(new KeyManager[] {x509KeyManager}, new TrustManager[] {trustManager},
         new SecureRandom());
     return sslContext.getSocketFactory();
   }
diff --git a/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
index c978db94f6..25a3c66d13 100644
--- a/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
@@ -31,11 +31,13 @@
 import javax.security.auth.x500.X500Principal;
 import okhttp3.Call;
 import okhttp3.OkHttpClient;
-import okhttp3.PlatformRule;
+import okhttp3.OkHttpClientTestRule;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.testing.PlatformRule;
+import okhttp3.testing.PlatformVersion;
 import okhttp3.tls.HandshakeCertificates;
 import okhttp3.tls.HeldCertificate;
 import org.junit.Before;
@@ -43,17 +45,15 @@
 import org.junit.Test;
 
 import static java.util.Arrays.asList;
-import static okhttp3.PlatformRule.getPlatformSystemProperty;
-import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.internal.platform.PlatformTest.getJvmSpecVersion;
+import static okhttp3.testing.PlatformRule.getPlatformSystemProperty;
 import static okhttp3.tls.internal.TlsUtil.newKeyManager;
 import static okhttp3.tls.internal.TlsUtil.newTrustManager;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeFalse;
 
 public final class ClientAuthTest {
   @Rule public final PlatformRule platform = new PlatformRule();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
   @Rule public final MockWebServer server = new MockWebServer();
 
   private HeldCertificate serverRootCa;
@@ -65,7 +65,7 @@
 
   @Before
   public void setUp() {
-    platform.assumeNotConscrypt();
+    platform.assumeNotOpenJSSE();
 
     serverRootCa = new HeldCertificate.Builder()
         .serialNumber(1L)
@@ -181,9 +181,8 @@ public void setUp() {
   }
 
   @Test public void missingClientAuthFailsForNeeds() throws Exception {
-    // TODO https://github.com/square/okhttp/issues/4598
+    // Fails with 11.0.1 https://github.com/square/okhttp/issues/4598
     // StreamReset stream was reset: PROT...
-    assumeFalse(getJvmSpecVersion().equals("11"));
 
     OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
 
@@ -199,10 +198,10 @@ public void setUp() {
       fail();
     } catch (SSLHandshakeException expected) {
     } catch (SSLException expected) {
-      String jvmVersion = System.getProperty("java.specification.version");
-      assertThat(jvmVersion).matches("1[123]");
+      assertThat(PlatformVersion.INSTANCE.getMajorVersion()).isGreaterThanOrEqualTo(11);
     } catch (SocketException expected) {
-      assertThat(getPlatformSystemProperty()).isEqualTo("jdk9");
+      assertThat(getPlatformSystemProperty()).isIn(PlatformRule.JDK9_PROPERTY,
+          PlatformRule.CONSCRYPT_PROPERTY);
     }
   }
 
@@ -231,9 +230,8 @@ public void setUp() {
   }
 
   @Test public void invalidClientAuthFails() throws Throwable {
-    // TODO https://github.com/square/okhttp/issues/4598
+    // Fails with https://github.com/square/okhttp/issues/4598
     // StreamReset stream was reset: PROT...
-    assumeFalse(getJvmSpecVersion().matches("1[123]"));
 
     HeldCertificate clientCert2 = new HeldCertificate.Builder()
         .serialNumber(4L)
@@ -255,10 +253,10 @@ public void setUp() {
     } catch (SSLHandshakeException expected) {
     } catch (SSLException expected) {
       // javax.net.ssl.SSLException: readRecord
-      String jvmVersion = System.getProperty("java.specification.version");
-      assertThat(jvmVersion).matches("1[123]");
+      assertThat(PlatformVersion.INSTANCE.getMajorVersion()).isGreaterThanOrEqualTo(11);
     } catch (SocketException expected) {
-      assertThat(getPlatformSystemProperty()).isEqualTo("jdk9");
+      assertThat(getPlatformSystemProperty()).isIn(PlatformRule.JDK9_PROPERTY,
+          PlatformRule.CONSCRYPT_PROPERTY);
     }
   }
 
@@ -272,7 +270,7 @@ private OkHttpClient buildClient(
     }
 
     HandshakeCertificates handshakeCertificates = builder.build();
-    return defaultClient().newBuilder()
+    return clientTestRule.newClientBuilder()
         .sslSocketFactory(
             handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .build();
diff --git a/okhttp/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java b/okhttp/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
index 9a878f1c41..75764ee116 100644
--- a/okhttp/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
@@ -518,28 +518,28 @@
 
   @Test public void verifyAsIpAddress() {
     // IPv4
-    assertThat(Util.verifyAsIpAddress("127.0.0.1")).isTrue();
-    assertThat(Util.verifyAsIpAddress("1.2.3.4")).isTrue();
+    assertThat(Util.canParseAsIpAddress("127.0.0.1")).isTrue();
+    assertThat(Util.canParseAsIpAddress("1.2.3.4")).isTrue();
 
     // IPv6
-    assertThat(Util.verifyAsIpAddress("::1")).isTrue();
-    assertThat(Util.verifyAsIpAddress("2001:db8::1")).isTrue();
-    assertThat(Util.verifyAsIpAddress("::192.168.0.1")).isTrue();
-    assertThat(Util.verifyAsIpAddress("::ffff:192.168.0.1")).isTrue();
-    assertThat(Util.verifyAsIpAddress("FEDC:BA98:7654:3210:FEDC:BA98:7654:3210")).isTrue();
-    assertThat(Util.verifyAsIpAddress("1080:0:0:0:8:800:200C:417A")).isTrue();
-    assertThat(Util.verifyAsIpAddress("1080::8:800:200C:417A")).isTrue();
-    assertThat(Util.verifyAsIpAddress("FF01::101")).isTrue();
-    assertThat(Util.verifyAsIpAddress("0:0:0:0:0:0:13.1.68.3")).isTrue();
-    assertThat(Util.verifyAsIpAddress("0:0:0:0:0:FFFF:129.144.52.38")).isTrue();
-    assertThat(Util.verifyAsIpAddress("::13.1.68.3")).isTrue();
-    assertThat(Util.verifyAsIpAddress("::FFFF:129.144.52.38")).isTrue();
+    assertThat(Util.canParseAsIpAddress("::1")).isTrue();
+    assertThat(Util.canParseAsIpAddress("2001:db8::1")).isTrue();
+    assertThat(Util.canParseAsIpAddress("::192.168.0.1")).isTrue();
+    assertThat(Util.canParseAsIpAddress("::ffff:192.168.0.1")).isTrue();
+    assertThat(Util.canParseAsIpAddress("FEDC:BA98:7654:3210:FEDC:BA98:7654:3210")).isTrue();
+    assertThat(Util.canParseAsIpAddress("1080:0:0:0:8:800:200C:417A")).isTrue();
+    assertThat(Util.canParseAsIpAddress("1080::8:800:200C:417A")).isTrue();
+    assertThat(Util.canParseAsIpAddress("FF01::101")).isTrue();
+    assertThat(Util.canParseAsIpAddress("0:0:0:0:0:0:13.1.68.3")).isTrue();
+    assertThat(Util.canParseAsIpAddress("0:0:0:0:0:FFFF:129.144.52.38")).isTrue();
+    assertThat(Util.canParseAsIpAddress("::13.1.68.3")).isTrue();
+    assertThat(Util.canParseAsIpAddress("::FFFF:129.144.52.38")).isTrue();
 
     // Hostnames
-    assertThat(Util.verifyAsIpAddress("go")).isFalse();
-    assertThat(Util.verifyAsIpAddress("localhost")).isFalse();
-    assertThat(Util.verifyAsIpAddress("squareup.com")).isFalse();
-    assertThat(Util.verifyAsIpAddress("www.nintendo.co.jp")).isFalse();
+    assertThat(Util.canParseAsIpAddress("go")).isFalse();
+    assertThat(Util.canParseAsIpAddress("localhost")).isFalse();
+    assertThat(Util.canParseAsIpAddress("squareup.com")).isFalse();
+    assertThat(Util.canParseAsIpAddress("www.nintendo.co.jp")).isFalse();
   }
 
   private X509Certificate certificate(String certificate) throws Exception {
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index 044643cd4b..6fcf0f1da2 100644
--- a/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -56,8 +56,8 @@
   @After public void tearDown() throws Exception {
     client.listener.assertExhausted();
     server.listener.assertExhausted();
-    server.source.close();
-    client.source.close();
+    server.getSource().close();
+    client.getSource().close();
     server.webSocket.tearDown();
     client.webSocket.tearDown();
   }
@@ -135,7 +135,7 @@
   }
 
   @Test public void emptyCloseInitiatesShutdown() throws IOException {
-    server.sink.write(ByteString.decodeHex("8800")).emit(); // Close without code.
+    server.getSink().write(ByteString.decodeHex("8800")).emit(); // Close without code.
     client.processNextFrame();
     client.listener.assertClosing(1005, "");
 
@@ -207,7 +207,7 @@
   }
 
   @Test public void protocolErrorBeforeCloseSendsFailure() throws IOException {
-    server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
+    server.getSink().write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
 
     client.processNextFrame(); // Detects error, send close, close connection.
     assertThat(client.closed).isTrue();
@@ -224,7 +224,7 @@
     assertThat(client.closed).isFalse();
 
     // Manually write an invalid masked close frame.
-    server.sink.write(ByteString.decodeHex("888760b420bb635c68de0cd84f")).emit();
+    server.getSink().write(ByteString.decodeHex("888760b420bb635c68de0cd84f")).emit();
 
     client.processNextFrame();// Detects error, disconnects immediately since close already sent.
     assertThat(client.closed).isTrue();
@@ -241,7 +241,7 @@
 
     // Not closed until close reply is received.
     assertThat(client.closed).isFalse();
-    server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
+    server.getSink().write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
 
     client.processNextFrame(); // Detects error, disconnects immediately since close already sent.
     assertThat(client.closed).isTrue();
@@ -253,7 +253,7 @@
   }
 
   @Test public void networkErrorReportedAsFailure() throws IOException {
-    server.sink.close();
+    server.getSink().close();
     client.processNextFrame();
     client.listener.assertFailure(EOFException.class);
   }
@@ -266,7 +266,7 @@
 
   @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
   @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {
-    client.sink.close();
+    client.getSink().close();
     client.closeThrows = true;
 
     client.webSocket.close(1000, "Bye!");
@@ -381,8 +381,8 @@ public boolean processNextFrame() throws IOException {
     }
 
     @Override public void close() throws IOException {
-      source.close();
-      sink.close();
+      getSource().close();
+      getSink().close();
       if (closed) {
         throw new AssertionError("Already closed");
       }
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
index c1d110858c..2006f235e4 100644
--- a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
@@ -27,6 +27,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Logger;
 import okhttp3.OkHttpClient;
+import okhttp3.OkHttpClientTestRule;
 import okhttp3.Protocol;
 import okhttp3.RecordingEventListener;
 import okhttp3.RecordingHostnameVerifier;
@@ -40,45 +41,59 @@
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.testing.Flaky;
+import okhttp3.testing.PlatformRule;
 import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.ByteString;
 import org.junit.After;
+import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 
 import static java.util.Arrays.asList;
-import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.TestUtil.ensureAllConnectionsReleased;
 import static okhttp3.TestUtil.repeat;
 import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.data.Offset.offset;
 import static org.junit.Assert.fail;
 
+@Flaky
 public final class WebSocketHttpTest {
+  // Flaky https://github.com/square/okhttp/issues/4515
+  // Flaky https://github.com/square/okhttp/issues/4953
+
   @Rule public final MockWebServer webServer = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+  @Rule public final PlatformRule platform = new PlatformRule();
 
   private final HandshakeCertificates handshakeCertificates = localhost();
   private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
   private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
   private final Random random = new Random(0);
-  private OkHttpClient client = defaultClient().newBuilder()
-      .writeTimeout(500, TimeUnit.MILLISECONDS)
-      .readTimeout(500, TimeUnit.MILLISECONDS)
-      .addInterceptor(chain -> {
-        Response response = chain.proceed(chain.request());
-        // Ensure application interceptors never see a null body.
-        assertThat(response.body()).isNotNull();
-        return response;
-      })
-      .build();
+  private OkHttpClient client;
+
+  @Before public void setUp() {
+    platform.assumeNotOpenJSSE();
+
+    client = clientTestRule.newClientBuilder()
+        .writeTimeout(500, TimeUnit.MILLISECONDS)
+        .readTimeout(500, TimeUnit.MILLISECONDS)
+        .addInterceptor(chain -> {
+          Response response = chain.proceed(chain.request());
+          // Ensure application interceptors never see a null body.
+          assertThat(response.body()).isNotNull();
+          return response;
+        })
+        .build();
+  }
 
   @After public void tearDown() {
     clientListener.assertExhausted();
 
     // TODO: assert all connections are released once leaks are fixed
+    clientTestRule.abandonClient();
   }
 
   @Test public void textMessage() {
@@ -116,8 +131,7 @@
     try {
       webSocket.send((String) null);
       fail();
-    } catch (NullPointerException e) {
-      assertThat(e.getMessage()).isEqualTo("text == null");
+    } catch (IllegalArgumentException expected) {
     }
 
     closeWebSockets(webSocket, server);
@@ -132,8 +146,7 @@
     try {
       webSocket.send((ByteString) null);
       fail();
-    } catch (NullPointerException e) {
-      assertThat(e.getMessage()).isEqualTo("bytes == null");
+    } catch (IllegalArgumentException expected) {
     }
 
     closeWebSockets(webSocket, server);
@@ -245,8 +258,8 @@
     server.close(1001, "bye");
     clientListener.assertClosed(1001, "bye");
     clientListener.assertExhausted();
-    serverListener.assertClosing(1000,  "");
-    serverListener.assertClosed(1000,  "");
+    serverListener.assertClosing(1000, "");
+    serverListener.assertClosed(1000, "");
     serverListener.assertExhausted();
   }
 
@@ -302,8 +315,6 @@
 
     clientListener.assertFailure(101, null, ProtocolException.class,
         "Expected 'Connection' header value 'Upgrade' but was 'null'");
-
-    ensureAllConnectionsReleased(client);
   }
 
   @Test public void wrongConnectionHeader() throws IOException {
@@ -577,8 +588,8 @@
     }
 
     long elapsedUntilPong3 = System.nanoTime() - startNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3)).isCloseTo((double) 1500, offset(
-        250d));
+    assertThat(TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3))
+        .isCloseTo(1500L, offset(250L));
 
     // The client pinged the server 3 times, and it has ponged back 3 times.
     assertThat(webSocket.sentPingCount()).isEqualTo(3);
@@ -642,8 +653,8 @@
     latch.countDown();
 
     long elapsedUntilFailure = System.nanoTime() - openAtNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 1000, offset(
-        250d));
+    assertThat(TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure))
+        .isCloseTo(1000L, offset(250L));
   }
 
   /** https://github.com/square/okhttp/issues/2788 */
@@ -656,14 +667,14 @@
 
     // Initiate a close on the client, which will schedule a hard cancel in 500 ms.
     long closeAtNanos = System.nanoTime();
-    webSocket.close(1000, "goodbye", 500);
+    webSocket.close(1000, "goodbye", 500L);
     serverListener.assertClosing(1000, "goodbye");
 
     // Confirm that the hard cancel occurred after 500 ms.
     clientListener.assertFailure();
     long elapsedUntilFailure = System.nanoTime() - closeAtNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 500, offset(
-        250d));
+    assertThat(TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure))
+        .isCloseTo(500L, offset(250L));
 
     // Close the server and confirm it saw what we expected.
     server.close(1000, null);
@@ -766,7 +777,7 @@ private MockResponse upgradeResponse(RecordedRequest request) {
         .setStatus("HTTP/1.1 101 Switching Protocols")
         .setHeader("Connection", "Upgrade")
         .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", WebSocketProtocol.acceptHeader(key));
+        .setHeader("Sec-WebSocket-Accept", WebSocketProtocol.INSTANCE.acceptHeader(key));
   }
 
   private void websocketScheme(String scheme) {
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index 97514efa44..02995e30df 100644
--- a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -298,8 +298,9 @@
     data.write(ByteString.decodeHex("880203ec")); // Close with code 1004
     data.write(ByteString.decodeHex("880203ed")); // Close with code 1005
     data.write(ByteString.decodeHex("880203ee")); // Close with code 1006
-    for (int i = 1012; i <= 2999; i++) {
-      data.write(ByteString.decodeHex("8802" + Util.format("%04X", i))); // Close with code 'i'
+    for (int i = 1015; i <= 2999; i++) {
+      data.write(ByteString.decodeHex(
+          "8802" + Util.format("%04X", i))); // Close with code 'i'
     }
 
     int count = 0;
@@ -311,7 +312,7 @@
         assertThat(e.getMessage()).matches("Code \\d+ is reserved and may not be used.");
       }
     }
-    assertThat(count).isEqualTo(1991);
+    assertThat(count).isEqualTo(1988);
   }
 
   private byte[] binaryData(int length) {
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
index 175df0ea7a..0d3cbe9171 100644
--- a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -75,7 +75,7 @@
     int length = 5;
     byte[] bytes = binaryData(length);
 
-    RequestBody body = RequestBody.create(null, bytes);
+    RequestBody body = RequestBody.create(bytes, null);
     BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
     body.writeTo(sink);
     sink.close();
@@ -89,7 +89,7 @@
     int length = 12345;
     byte[] bytes = binaryData(length);
 
-    RequestBody body = RequestBody.create(null, bytes);
+    RequestBody body = RequestBody.create(bytes, null);
     BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
     body.writeTo(sink);
     sink.close();
diff --git a/samples/crawler/build.gradle b/samples/crawler/build.gradle
index d9f72bd9c2..7bcfa55a08 100644
--- a/samples/crawler/build.gradle
+++ b/samples/crawler/build.gradle
@@ -2,3 +2,7 @@ dependencies {
   implementation project(':okhttp')
   implementation deps.jsoup
 }
+
+tasks.withType(JavaCompile) {
+  options.warnings = false
+}
\ No newline at end of file
diff --git a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
index 95ba357def..36d7971e80 100644
--- a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
+++ b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
@@ -31,7 +31,6 @@
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.NamedRunnable;
 import org.jsoup.Jsoup;
 import org.jsoup.nodes.Document;
 import org.jsoup.nodes.Element;
@@ -52,13 +51,11 @@ public Crawler(OkHttpClient client) {
   private void parallelDrainQueue(int threadCount) {
     ExecutorService executor = Executors.newFixedThreadPool(threadCount);
     for (int i = 0; i < threadCount; i++) {
-      executor.execute(new NamedRunnable("Crawler %s", i) {
-        @Override protected void execute() {
-          try {
-            drainQueue();
-          } catch (Exception e) {
-            e.printStackTrace();
-          }
+      executor.execute(() -> {
+        try {
+          drainQueue();
+        } catch (Exception e) {
+          e.printStackTrace();
         }
       });
     }
diff --git a/samples/guide/README.md b/samples/guide/README.md
new file mode 100644
index 0000000000..43787700f1
--- /dev/null
+++ b/samples/guide/README.md
@@ -0,0 +1,2 @@
+Samples
+=======
diff --git a/samples/guide/build.gradle b/samples/guide/build.gradle
index 7f2ef89506..f7864f3c93 100644
--- a/samples/guide/build.gradle
+++ b/samples/guide/build.gradle
@@ -4,3 +4,7 @@ dependencies {
   implementation project(':okhttp-tls')
   implementation deps.moshi
 }
+
+tasks.withType(JavaCompile) {
+  options.warnings = false
+}
diff --git a/samples/guide/docs/images/logo-square.png b/samples/guide/docs/images/logo-square.png
new file mode 100644
index 0000000000..788b301adb
Binary files /dev/null and b/samples/guide/docs/images/logo-square.png differ
diff --git a/samples/guide/src/main/java/okhttp3/guide/PostExample.java b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
index ddaacb6c5e..d505beba3a 100644
--- a/samples/guide/src/main/java/okhttp3/guide/PostExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
@@ -13,7 +13,7 @@
   OkHttpClient client = new OkHttpClient();
 
   String post(String url, String json) throws IOException {
-    RequestBody body = RequestBody.create(JSON, json);
+    RequestBody body = RequestBody.create(json, JSON);
     Request request = new Request.Builder()
         .url(url)
         .post(body)
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
index 0e52cddd26..a59259b504 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
@@ -34,7 +34,7 @@ public void run() throws Exception {
 
     Request request = new Request.Builder()
         .url("https://api.github.com/markdown/raw")
-        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
+        .post(RequestBody.create(file, MEDIA_TYPE_MARKDOWN))
         .build();
 
     try (Response response = client.newCall(request).execute()) {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
index 60534d7de2..aa7ea2974f 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
@@ -40,7 +40,9 @@ public void run() throws Exception {
         .setType(MultipartBody.FORM)
         .addFormDataPart("title", "Square Logo")
         .addFormDataPart("image", "logo-square.png",
-            RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png")))
+            RequestBody.create(
+                new File("docs/images/logo-square.png"),
+                MEDIA_TYPE_PNG))
         .build();
 
     Request request = new Request.Builder()
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostString.java b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
index 6c8ea4f9e3..05766fe38e 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostString.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
@@ -39,7 +39,7 @@ public void run() throws Exception {
 
     Request request = new Request.Builder()
         .url("https://api.github.com/markdown/raw")
-        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
+        .post(RequestBody.create(postBody, MEDIA_TYPE_MARKDOWN))
         .build();
 
     try (Response response = client.newCall(request).execute()) {
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
index 6c9f71279f..8111761dbf 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
@@ -26,6 +26,7 @@
 import okhttp3.Connection;
 import okhttp3.EventListener;
 import okhttp3.Handshake;
+import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.Request;
@@ -97,6 +98,14 @@ private void printEvent(String name) {
       System.out.printf("%04d %.3f %s%n", callId, elapsedNanos / 1000000000d, name);
     }
 
+    @Override public void proxySelectStart(Call call, HttpUrl url) {
+      printEvent("proxySelectStart");
+    }
+
+    @Override public void proxySelectEnd(Call call, HttpUrl url, List<Proxy> proxies) {
+      printEvent("proxySelectEnd");
+    }
+
     @Override public void callStart(Call call) {
       printEvent("callStart");
     }
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
index c88895b794..ea0b1fb619 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
@@ -24,6 +24,7 @@
 import okhttp3.Connection;
 import okhttp3.EventListener;
 import okhttp3.Handshake;
+import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.Request;
@@ -76,6 +77,14 @@ private void printEvent(String name) {
       printEvent("callStart");
     }
 
+    @Override public void proxySelectStart(Call call, HttpUrl url) {
+      printEvent("proxySelectStart");
+    }
+
+    @Override public void proxySelectEnd(Call call, HttpUrl url, List<Proxy> proxies) {
+      printEvent("proxySelectEnd");
+    }
+
     @Override public void dnsStart(Call call, String domainName) {
       printEvent("dnsStart");
     }
diff --git a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
index 5473f67011..c069a8f7a5 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
@@ -52,7 +52,7 @@ public void run() throws Exception {
     Map<String, String> requestBody = new LinkedHashMap<>();
     requestBody.put("longUrl", "https://publicobject.com/2014/12/04/html-formatting-javadocs/");
     RequestBody jsonRequestBody = RequestBody.create(
-        MEDIA_TYPE_JSON, mapJsonAdapter.toJson(requestBody));
+        mapJsonAdapter.toJson(requestBody), MEDIA_TYPE_JSON);
     Request request = new Request.Builder()
         .url("https://www.googleapis.com/urlshortener/v1/url?key=" + GOOGLE_API_KEY)
         .post(jsonRequestBody)
diff --git a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
index 288fadb7ce..f0407db87f 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
@@ -1,10 +1,10 @@
 package okhttp3.recipes;
 
 import java.util.concurrent.TimeUnit;
-import okhttp3.WebSocket;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
 import okio.ByteString;
 
diff --git a/samples/guide/src/test/kotlin/okhttp3/AllMainsTest.kt b/samples/guide/src/test/kotlin/okhttp3/AllMainsTest.kt
new file mode 100644
index 0000000000..21c932c464
--- /dev/null
+++ b/samples/guide/src/test/kotlin/okhttp3/AllMainsTest.kt
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import org.junit.Ignore
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+import java.io.File
+import java.lang.reflect.InvocationTargetException
+
+@RunWith(Parameterized::class)
+@Ignore
+class AllMainsTest(val className: String) {
+  @Test
+  fun runMain() {
+    val mainMethod = Class.forName(className).methods.find { it.name == "main" }
+    try {
+      mainMethod?.invoke(null, arrayOf<String>())
+    } catch (ite: InvocationTargetException) {
+      if (!expectedFailure(className, ite.cause!!)) {
+        throw ite.cause!!
+      }
+    }
+  }
+
+  private fun expectedFailure(className: String, cause: Throwable): Boolean {
+    return when (className) {
+      "okhttp3.recipes.CheckHandshake" -> true // by design
+      "okhttp3.recipes.RequestBodyCompression" -> true // expired token
+      else -> false
+    }
+  }
+
+  companion object {
+    private val prefix = if (File("samples").exists()) "" else "../../"
+
+    @JvmStatic
+    @Parameterized.Parameters(name = "{0}")
+    fun data(): List<String> {
+      val mainFiles = mainFiles()
+      return mainFiles.map {
+        it.path.substring("$prefix/samples/guide/src/main/java".length, it.path.length - 5)
+            .replace('/', '.')
+      }.sorted()
+    }
+
+    private fun mainFiles(): List<File> {
+      return File("$prefix/samples/guide/src/main/java/okhttp3").listFiles()?.flatMap {
+        it?.listFiles()?.toList().orEmpty()
+      }.orEmpty()
+    }
+  }
+}
diff --git a/samples/static-server/build.gradle b/samples/static-server/build.gradle
index 1b1bb519c6..7b03c052c1 100644
--- a/samples/static-server/build.gradle
+++ b/samples/static-server/build.gradle
@@ -1,5 +1,9 @@
 apply plugin: 'com.github.johnrengelman.shadow'
 
+tasks.withType(JavaCompile) {
+  options.warnings = false
+}
+
 jar {
   manifest {
     attributes 'Main-Class': 'okhttp3.sample.SampleServer'
diff --git a/settings.gradle b/settings.gradle
index 367bee6364..8b742d82cb 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,6 +1,16 @@
+rootProject.name = 'okhttp-parent'
+
 include ':mockwebserver'
+
+if (properties.containsKey('android.injected.invoked.from.ide') ||
+        System.getenv('ANDROID_SDK_ROOT') != null) {
+  // Currently incompatible with Intellij, use with Android Studio and from CLI with explicit flag
+  include ':android-test'
+}
+
 include ':okcurl'
 include ':okhttp'
+include ':okhttp-brotli'
 include ':okhttp-dnsoverhttps'
 include ':okhttp-hpacktests'
 include ':okhttp-logging-interceptor'
diff --git a/website/index.html b/website/index.html
deleted file mode 100644
index 02c69c6c9c..0000000000
--- a/website/index.html
+++ /dev/null
@@ -1,228 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-  <head>
-    <meta charset="utf-8">
-    <title>OkHttp</title>
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <meta name="description" content="An HTTP &amp; HTTP/2 client for Android and Java applications">
-    <link href="static/bootstrap-combined.min.css" rel="stylesheet">
-    <link href="static/app.css" rel="stylesheet">
-    <link href="static/app-theme.css" rel="stylesheet">
-    <link href="https://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
-    <!--[if lt IE 9]><script src="static/html5shiv.min.js"></script><![endif]-->
-  </head>
-  <body data-target=".content-nav">
-    <header>
-      <div class="container">
-        <div class="row">
-          <div class="span5">
-            <h1>OkHttp</h1>
-          </div>
-          <div class="span7">
-            <menu>
-              <ul>
-                <li><a href="#download" class="menu download">Download <span class="version-tag">Latest</span></a></li>
-                <li><a href="https://github.com/square/okhttp" data-title="View GitHub Project" class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
-                <li><a href="https://square.github.io/" data-title="Square Open Source Portal" class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
-              </ul>
-            </menu>
-          </div>
-        </div>
-      </div>
-    </header>
-    <section id="subtitle">
-      <div class="container">
-        <div class="row">
-          <div class="span12">
-            <h2>An <strong>HTTP &amp; HTTP/2</strong> client for Android and Java applications</h2>
-          </div>
-        </div>
-      </div>
-    </section>
-    <section id="body">
-      <div class="container">
-        <div class="row">
-          <div class="span9">
-            <h3 id="overview">Overview</h3>
-            <p>HTTP is the way modern applications network. It’s how we exchange data &amp; media.
-                Doing HTTP efficiently makes your stuff load faster and saves bandwidth.</p>
-
-            <p>OkHttp is an HTTP client that’s efficient by default:</p>
-            <ul>
-                <li>HTTP/2 support allows all requests to the same host to share a socket.</li>
-                <li>Connection pooling reduces request latency (if HTTP/2 isn’t available).</li>
-                <li>Transparent GZIP shrinks download sizes.</li>
-                <li>Response caching avoids the network completely for repeat requests.</li>
-            </ul>
-
-            <p>OkHttp perseveres when the network is troublesome: it will silently recover from
-                common connection problems. If your service has multiple IP addresses OkHttp will
-                attempt alternate addresses if the first connect fails. This is necessary for IPv4+IPv6
-                and for services hosted in redundant data centers. OkHttp supports modern TLS
-                features (TLS 1.3, ALPN, certificate pinning). It can be configured to fall back for
-                broad connectivity.</p>
-
-            <p>Using OkHttp is easy. Its request/response API is designed with fluent builders and
-                immutability. It supports both synchronous blocking calls and async calls with
-                callbacks.</p>
-
-            <p>OkHttp supports Android 5.0+ (API level 21+) and Java 8+.</p>
-
-            <h3 id="examples">Examples</h3>
-            <h4>Get a URL</h4>
-            <p>This program downloads a URL and prints its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/GetExample.java">Full source</a>.
-<pre class="prettyprint">
-OkHttpClient client = new OkHttpClient();
-
-String run(String url) throws IOException {
-  Request request = new Request.Builder()
-      .url(url)
-      .build();
-
-  try (Response response = client.newCall(request).execute()) {
-    return response.body().string();
-  }
-}
-</pre>
-            <h4>Post to a Server</h4>
-            <p>This program posts data to a service. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/PostExample.java">Full source</a>.
-
-<pre class="prettyprint">
-public static final MediaType JSON
-    = MediaType.get("application/json; charset=utf-8");
-
-OkHttpClient client = new OkHttpClient();
-
-String post(String url, String json) throws IOException {
-  RequestBody body = RequestBody.create(JSON, json);
-  Request request = new Request.Builder()
-      .url(url)
-      .post(body)
-      .build();
-  try (Response response = client.newCall(request).execute()) {
-    return response.body().string();
-  }
-}
-</pre>
-
-            <h3 id="download">Download</h3>
-            <p><a href="https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
-            <p>You'll also need <a href="https://github.com/square/okio">Okio</a>, which OkHttp
-                uses for fast I/O and resizable buffers. Download the
-                <a href="https://search.maven.org/remote_content?g=com.squareup.okio&a=okio&v=LATEST">latest JAR</a>.
-            <p>The source code to OkHttp, its samples, and this website is <a href="https://github.com/square/okhttp">available on GitHub</a>.</p>
-
-            <h4>Maven</h4>
-            <pre class="prettyprint">&lt;dependency>
-  &lt;groupId>com.squareup.okhttp3&lt;/groupId>
-  &lt;artifactId>okhttp&lt;/artifactId>
-  &lt;version><span class="version pln"><em>(insert latest version)</em></span>&lt;/version>
-&lt;/dependency></pre>
-
-            <h4>Gradle</h4>
-            <pre class="prettyprint">implementation 'com.squareup.okhttp3:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
-
-            <h3 id="contributing">Contributing</h3>
-            <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
-            <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>./gradlew check</code>.</p>
-
-            <p>Some general advice</p>
-            <ul>
-                <li>Don’t change public API lightly, avoid if possible, and include your reasoning in the PR if essential. It causes pain for developers who use OkHttp and sometimes runtime errors.</li>
-                <li>Favour a working external library if appropriate. There are many examples of OkHttp libraries that can sit on top or hook in via existing APIs.</li>
-                <li>Get working code on a personal branch with tests before you submit a PR.</li>
-                <li>OkHttp is a small and light dependency. Don't introduce new dependencies or major new functionality.</li>
-                <li>OkHttp targets the intersection of RFC correct and widely implemented. Incorrect implementations that are very widely implemented e.g. a bug in Apache, Nginx, Google, Firefox should also be handled.</li>
-            </ul>
-
-            <p>Before your code can be accepted into the project you must also sign the <a href="https://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
-
-            <h3 id="license">License</h3>
-            <pre>Copyright 2016 Square, Inc.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-   http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.</pre>
-          </div>
-          <div class="span3">
-            <div class="content-nav" data-spy="affix" data-offset-top="80">
-              <ul class="nav nav-tabs nav-stacked primary">
-                <li><a href="#overview">Overview</a></li>
-                <li><a href="#examples">Examples</a></li>
-                <li><a href="#download">Download</a></li>
-                <li><a href="#contributing">Contributing</a></li>
-                <li><a href="#license">License</a></li>
-              </ul>
-              <ul class="nav nav-pills nav-stacked secondary">
-                <li><a href="https://github.com/square/okhttp/wiki">Wiki</a></li>
-                <li><a href="3.x/okhttp/">Javadoc</a></li>
-                <li><a href="https://stackoverflow.com/questions/tagged/okhttp?sort=active">StackOverflow</a></li>
-              </ul>
-            </div>
-          </div>
-        </div>
-        <div class="row">
-          <div class="span12 logo">
-            <a href="https://squareup.com"><img src="static/logo-square.png" alt="Square, Inc."/></a>
-          </div>
-        </div>
-      </div>
-    </section>
-    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
-    <script src="static/bootstrap.min.js"></script>
-    <script src="static/jquery.smooth-scroll.min.js"></script>
-    <script src="static/jquery-maven-artifact.min.js"></script>
-    <script src="static/prettify.js"></script>
-    <script type="text/javascript">
-      $(function() {
-        // Syntax highlight code blocks.
-        prettyPrint();
-
-        // Spy on scroll position for real-time updating of current section.
-        $('body').scrollspy();
-
-        // Use smooth-scroll for internal links.
-        $('a').smoothScroll();
-
-        // Enable tooltips on the header nav image items.
-        $('.menu').tooltip({
-          placement: 'bottom',
-          trigger: 'hover',
-          container: 'body',
-          delay: {
-            show: 500,
-            hide: 0
-          }
-        });
-
-        // Look up the latest version of the library.
-        $.fn.artifactVersion({
-          'groupId': 'com.squareup.okhttp3',
-          'artifactId': 'okhttp'
-        }, function(version, url) {
-          $('.version').text(version);
-          $('.version-tag').text('v' + version);
-          $('.version-href').attr('href', url);
-        });
-      });
-
-      var _gaq = _gaq || [];
-      _gaq.push(['_setAccount', 'UA-40704740-2']);
-      _gaq.push(['_trackPageview']);
-
-      (function() {
-        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
-        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
-        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
-      })();
-    </script>
-  </body>
-</html>
diff --git a/website/static/app-theme.css b/website/static/app-theme.css
deleted file mode 100644
index d7d00c4a93..0000000000
--- a/website/static/app-theme.css
+++ /dev/null
@@ -1,51 +0,0 @@
-/* http://www.colorhexa.com/487fb9 */
-
-/*** Primary ***/
-
-header,
-#subtitle,
-a.dl {
-  background-color: #48b7b9;
-}
-
-.content-nav li.active a,
-.content-nav li.active a:hover {
-  border-left-color: #48b7b9;
-}
-
-/*** One step left on the monochromatic scale ***/
-
-header menu li a:hover,
-a.dl:hover {
-  background-color: #40a6a7;
-}
-a {
-  color: #40a6a7;
-}
-
-/*** Three steps left on the monochromatic scale ***/
-
-a:hover {
-  color: #328183;
-}
-
-
-/****************************************************************\
- **** Syntax highlighting styles ********************************
-\****************************************************************/
-
-.pln { color: #000; }
-.str { color: #399395; }
-.kwd { color: #666; }
-.com { color: #399395; }
-.typ { color: #222; }
-.lit { color: #666; }
-.pun { color: #888; }
-.opn { color: #888; }
-.clo { color: #888; }
-.tag { color: #399395; }
-.atn { color: #606; }
-.atv { color: #080; }
-.dec { color: #606; }
-.var { color: #606; }
-.fun { color: #f00; }
diff --git a/website/static/app.css b/website/static/app.css
deleted file mode 100644
index e3574b739d..0000000000
--- a/website/static/app.css
+++ /dev/null
@@ -1,188 +0,0 @@
-html, body {
-  font-family: 'Roboto', sans-serif;
-  font-size: 15px;
-}
-body {
-  background-color: #f6f6f6;
-  padding-bottom: 50px;
-  padding-top: 80px;
-}
-
-header {
-  min-height: 80px;
-  color: #f6f6f6;
-  position: fixed;
-  top: 0;
-  left: 0;
-  width: 100%;
-  z-index: 99;
-}
-header h1 {
-  margin: 10px 0;
-  font-size: 50px;
-  line-height: 60px;
-  font-weight: 100;
-  text-rendering: auto;
-}
-header menu {
-  margin: 20px 0 0;
-  padding: 0;
-  height: 40px;
-}
-header menu ul {
-  margin: 0;
-  padding: 0;
-  float: right;
-}
-header menu li {
-  list-style: none;
-  float: left;
-  margin: 0;
-  padding: 0;
-}
-header menu li a {
-  display: inline-block;
-  height: 40px;
-  font-size: 17px;
-  line-height: 40px;
-  padding: 0 20px;
-  color: #f6f6f6;
-}
-header menu li a:hover {
-  color: #f6f6f6;
-  text-decoration: none;
-}
-header menu li a img {
-  margin: 0;
-  padding: 5px 0;
-  vertical-align: bottom;
-  width: 30px;
-  height: 30px;
-}
-
-#subtitle {
-  position: absolute;
-  top: 80px;
-  left: 0;
-  width: 100%;
-}
-h2 {
-  font-weight: 200;
-  font-size: 26px;
-  line-height: 30px;
-  padding: 15px 0;
-  margin: 0;
-  color: #eee;
-}
-h2 strong {
-  font-weight: 300;
-}
-
-a.dl {
-  font-weight: 300;
-  font-size: 30px;
-  line-height: 40px;
-  padding: 3px 10px;
-  display: inline-block;
-  border-radius: 6px;
-  color: #f0f0f0;
-  margin: 5px 0;
-}
-a.dl:hover {
-  color: #f0f0f0;
-  text-decoration: none;
-}
-
-.content-nav {
-  margin-top: 130px;
-  width: 220px;
-}
-.content-nav.affix {
-  top: 0;
-}
-.content-nav li.active a, .content-nav li.active a:hover {
-  background-color: transparent;
-  color: #555;
-  border-left-width: 2px;
-}
-.content-nav .secondary a {
-  color: #aaa;
-}
-.content-nav .secondary a:hover {
-  color: #888;
-}
-
-h3 {
-  font-weight: 300;
-  font-style: italic;
-  color: #888;
-  font-size: 20px;
-  padding-top: 115px;
-  margin-top: 0;
-}
-
-h4 {
-  font-weight: 400;
-  text-transform: uppercase;
-  color: #888;
-  font-size: 15px;
-  padding-top: 20px;
-}
-
-p.license {
-  font-family: fixed-width;
-}
-
-.row .logo {
-  text-align: center;
-  margin-top: 150px;
-}
-.row .logo img {
-  height: 30px;
-}
-
-pre, code {
-  color: #666;
-}
-code {
-  border: 0;
-  background-color: transparent;
-}
-
-/* Widescreen desktop. */
-@media (min-width: 1200px) {
-  .content-nav {
-    width: 270px;
-  }
-}
-
-/* Smaller width browser, tablets. */
-@media (max-width: 979px) {
-  .content-nav {
-    width: 166px;
-  }
-}
-
-/* One-column mobile display. */
-@media (max-width: 767px) {
-  header {
-    position: absolute;
-    top: 0;
-    left: 0;
-    width: 100%;
-    padding-left: 20px;
-  }
-  header menu {
-    display: none;
-  }
-  #subtitle {
-    position: absolute;
-    top: 80px;
-    left: 0;
-    width: 100%;
-    padding-left: 20px;
-  }
-  .content-nav {
-    display: none;
-  }
-}
\ No newline at end of file
diff --git a/website/static/bootstrap-combined.min.css b/website/static/bootstrap-combined.min.css
deleted file mode 100644
index 1334dfa697..0000000000
--- a/website/static/bootstrap-combined.min.css
+++ /dev/null
@@ -1,18 +0,0 @@
-/*!
- * Bootstrap v2.3.1
- *
- * Copyright 2012 Twitter, Inc
- * Licensed under the Apache License v2.0
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Designed and built with all the love in the world @twitter by @mdo and @fat.
- */.clearfix{*zoom:1}.clearfix:before,.clearfix:after{display:table;line-height:0;content:""}.clearfix:after{clear:both}.hide-text{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.input-block-level{display:block;width:100%;min-height:30px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}article,aside,details,figcaption,figure,footer,header,hgroup,nav,section{display:block}audio,canvas,video{display:inline-block;*display:inline;*zoom:1}audio:not([controls]){display:none}html{font-size:100%;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}a:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}a:hover,a:active{outline:0}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{width:auto\9;height:auto;max-width:100%;vertical-align:middle;border:0;-ms-interpolation-mode:bicubic}#map_canvas img,.google-maps img{max-width:none}button,input,select,textarea{margin:0;font-size:100%;vertical-align:middle}button,input{*overflow:visible;line-height:normal}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}button,html input[type="button"],input[type="reset"],input[type="submit"]{cursor:pointer;-webkit-appearance:button}label,select,button,input[type="button"],input[type="reset"],input[type="submit"],input[type="radio"],input[type="checkbox"]{cursor:pointer}input[type="search"]{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;-webkit-appearance:textfield}input[type="search"]::-webkit-search-decoration,input[type="search"]::-webkit-search-cancel-button{-webkit-appearance:none}textarea{overflow:auto;vertical-align:top}@media print{*{color:#000!important;text-shadow:none!important;background:transparent!important;box-shadow:none!important}a,a:visited{text-decoration:underline}a[href]:after{content:" (" attr(href) ")"}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100%!important}@page{margin:.5cm}p,h2,h3{orphans:3;widows:3}h2,h3{page-break-after:avoid}}body{margin:0;font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:14px;line-height:20px;color:#333;background-color:#fff}a{color:#08c;text-decoration:none}a:hover,a:focus{color:#005580;text-decoration:underline}.img-rounded{-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.img-polaroid{padding:4px;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.2);-webkit-box-shadow:0 1px 3px rgba(0,0,0,0.1);-moz-box-shadow:0 1px 3px rgba(0,0,0,0.1);box-shadow:0 1px 3px rgba(0,0,0,0.1)}.img-circle{-webkit-border-radius:500px;-moz-border-radius:500px;border-radius:500px}.row{margin-left:-20px;*zoom:1}.row:before,.row:after{display:table;line-height:0;content:""}.row:after{clear:both}[class*="span"]{float:left;min-height:1px;margin-left:20px}.container,.navbar-static-top .container,.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:940px}.span12{width:940px}.span11{width:860px}.span10{width:780px}.span9{width:700px}.span8{width:620px}.span7{width:540px}.span6{width:460px}.span5{width:380px}.span4{width:300px}.span3{width:220px}.span2{width:140px}.span1{width:60px}.offset12{margin-left:980px}.offset11{margin-left:900px}.offset10{margin-left:820px}.offset9{margin-left:740px}.offset8{margin-left:660px}.offset7{margin-left:580px}.offset6{margin-left:500px}.offset5{margin-left:420px}.offset4{margin-left:340px}.offset3{margin-left:260px}.offset2{margin-left:180px}.offset1{margin-left:100px}.row-fluid{width:100%;*zoom:1}.row-fluid:before,.row-fluid:after{display:table;line-height:0;content:""}.row-fluid:after{clear:both}.row-fluid [class*="span"]{display:block;float:left;width:100%;min-height:30px;margin-left:2.127659574468085%;*margin-left:2.074468085106383%;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.row-fluid [class*="span"]:first-child{margin-left:0}.row-fluid .controls-row [class*="span"]+[class*="span"]{margin-left:2.127659574468085%}.row-fluid .span12{width:100%;*width:99.94680851063829%}.row-fluid .span11{width:91.48936170212765%;*width:91.43617021276594%}.row-fluid .span10{width:82.97872340425532%;*width:82.92553191489361%}.row-fluid .span9{width:74.46808510638297%;*width:74.41489361702126%}.row-fluid .span8{width:65.95744680851064%;*width:65.90425531914893%}.row-fluid .span7{width:57.44680851063829%;*width:57.39361702127659%}.row-fluid .span6{width:48.93617021276595%;*width:48.88297872340425%}.row-fluid .span5{width:40.42553191489362%;*width:40.37234042553192%}.row-fluid .span4{width:31.914893617021278%;*width:31.861702127659576%}.row-fluid .span3{width:23.404255319148934%;*width:23.351063829787233%}.row-fluid .span2{width:14.893617021276595%;*width:14.840425531914894%}.row-fluid .span1{width:6.382978723404255%;*width:6.329787234042553%}.row-fluid .offset12{margin-left:104.25531914893617%;*margin-left:104.14893617021275%}.row-fluid .offset12:first-child{margin-left:102.12765957446808%;*margin-left:102.02127659574467%}.row-fluid .offset11{margin-left:95.74468085106382%;*margin-left:95.6382978723404%}.row-fluid .offset11:first-child{margin-left:93.61702127659574%;*margin-left:93.51063829787232%}.row-fluid .offset10{margin-left:87.23404255319149%;*margin-left:87.12765957446807%}.row-fluid .offset10:first-child{margin-left:85.1063829787234%;*margin-left:84.99999999999999%}.row-fluid .offset9{margin-left:78.72340425531914%;*margin-left:78.61702127659572%}.row-fluid .offset9:first-child{margin-left:76.59574468085106%;*margin-left:76.48936170212764%}.row-fluid .offset8{margin-left:70.2127659574468%;*margin-left:70.10638297872339%}.row-fluid .offset8:first-child{margin-left:68.08510638297872%;*margin-left:67.9787234042553%}.row-fluid .offset7{margin-left:61.70212765957446%;*margin-left:61.59574468085106%}.row-fluid .offset7:first-child{margin-left:59.574468085106375%;*margin-left:59.46808510638297%}.row-fluid .offset6{margin-left:53.191489361702125%;*margin-left:53.085106382978715%}.row-fluid .offset6:first-child{margin-left:51.063829787234035%;*margin-left:50.95744680851063%}.row-fluid .offset5{margin-left:44.68085106382979%;*margin-left:44.57446808510638%}.row-fluid .offset5:first-child{margin-left:42.5531914893617%;*margin-left:42.4468085106383%}.row-fluid .offset4{margin-left:36.170212765957444%;*margin-left:36.06382978723405%}.row-fluid .offset4:first-child{margin-left:34.04255319148936%;*margin-left:33.93617021276596%}.row-fluid .offset3{margin-left:27.659574468085104%;*margin-left:27.5531914893617%}.row-fluid .offset3:first-child{margin-left:25.53191489361702%;*margin-left:25.425531914893618%}.row-fluid .offset2{margin-left:19.148936170212764%;*margin-left:19.04255319148936%}.row-fluid .offset2:first-child{margin-left:17.02127659574468%;*margin-left:16.914893617021278%}.row-fluid .offset1{margin-left:10.638297872340425%;*margin-left:10.53191489361702%}.row-fluid .offset1:first-child{margin-left:8.51063829787234%;*margin-left:8.404255319148938%}[class*="span"].hide,.row-fluid [class*="span"].hide{display:none}[class*="span"].pull-right,.row-fluid [class*="span"].pull-right{float:right}.container{margin-right:auto;margin-left:auto;*zoom:1}.container:before,.container:after{display:table;line-height:0;content:""}.container:after{clear:both}.container-fluid{padding-right:20px;padding-left:20px;*zoom:1}.container-fluid:before,.container-fluid:after{display:table;line-height:0;content:""}.container-fluid:after{clear:both}p{margin:0 0 10px}.lead{margin-bottom:20px;font-size:21px;font-weight:200;line-height:30px}small{font-size:85%}strong{font-weight:bold}em{font-style:italic}cite{font-style:normal}.muted{color:#999}a.muted:hover,a.muted:focus{color:#808080}.text-warning{color:#c09853}a.text-warning:hover,a.text-warning:focus{color:#a47e3c}.text-error{color:#b94a48}a.text-error:hover,a.text-error:focus{color:#953b39}.text-info{color:#3a87ad}a.text-info:hover,a.text-info:focus{color:#2d6987}.text-success{color:#468847}a.text-success:hover,a.text-success:focus{color:#356635}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}h1,h2,h3,h4,h5,h6{margin:10px 0;font-family:inherit;font-weight:bold;line-height:20px;color:inherit;text-rendering:optimizelegibility}h1 small,h2 small,h3 small,h4 small,h5 small,h6 small{font-weight:normal;line-height:1;color:#999}h1,h2,h3{line-height:40px}h1{font-size:38.5px}h2{font-size:31.5px}h3{font-size:24.5px}h4{font-size:17.5px}h5{font-size:14px}h6{font-size:11.9px}h1 small{font-size:24.5px}h2 small{font-size:17.5px}h3 small{font-size:14px}h4 small{font-size:14px}.page-header{padding-bottom:9px;margin:20px 0 30px;border-bottom:1px solid #eee}ul,ol{padding:0;margin:0 0 10px 25px}ul ul,ul ol,ol ol,ol ul{margin-bottom:0}li{line-height:20px}ul.unstyled,ol.unstyled{margin-left:0;list-style:none}ul.inline,ol.inline{margin-left:0;list-style:none}ul.inline>li,ol.inline>li{display:inline-block;*display:inline;padding-right:5px;padding-left:5px;*zoom:1}dl{margin-bottom:20px}dt,dd{line-height:20px}dt{font-weight:bold}dd{margin-left:10px}.dl-horizontal{*zoom:1}.dl-horizontal:before,.dl-horizontal:after{display:table;line-height:0;content:""}.dl-horizontal:after{clear:both}.dl-horizontal dt{float:left;width:160px;overflow:hidden;clear:left;text-align:right;text-overflow:ellipsis;white-space:nowrap}.dl-horizontal dd{margin-left:180px}hr{margin:20px 0;border:0;border-top:1px solid #eee;border-bottom:1px solid #fff}abbr[title],abbr[data-original-title]{cursor:help;border-bottom:1px dotted #999}abbr.initialism{font-size:90%;text-transform:uppercase}blockquote{padding:0 0 0 15px;margin:0 0 20px;border-left:5px solid #eee}blockquote p{margin-bottom:0;font-size:17.5px;font-weight:300;line-height:1.25}blockquote small{display:block;line-height:20px;color:#999}blockquote small:before{content:'\2014 \00A0'}blockquote.pull-right{float:right;padding-right:15px;padding-left:0;border-right:5px solid #eee;border-left:0}blockquote.pull-right p,blockquote.pull-right small{text-align:right}blockquote.pull-right small:before{content:''}blockquote.pull-right small:after{content:'\00A0 \2014'}q:before,q:after,blockquote:before,blockquote:after{content:""}address{display:block;margin-bottom:20px;font-style:normal;line-height:20px}code,pre{padding:0 3px 2px;font-family:Monaco,Menlo,Consolas,"Courier New",monospace;font-size:12px;color:#333;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}code{padding:2px 4px;color:#d14;white-space:nowrap;background-color:#f7f7f9;border:1px solid #e1e1e8}pre{display:block;padding:9.5px;margin:0 0 10px;font-size:13px;line-height:20px;word-break:break-all;word-wrap:break-word;white-space:pre;white-space:pre-wrap;background-color:#f5f5f5;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.15);-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}pre.prettyprint{margin-bottom:20px}pre code{padding:0;color:inherit;white-space:pre;white-space:pre-wrap;background-color:transparent;border:0}.pre-scrollable{max-height:340px;overflow-y:scroll}form{margin:0 0 20px}fieldset{padding:0;margin:0;border:0}legend{display:block;width:100%;padding:0;margin-bottom:20px;font-size:21px;line-height:40px;color:#333;border:0;border-bottom:1px solid #e5e5e5}legend small{font-size:15px;color:#999}label,input,button,select,textarea{font-size:14px;font-weight:normal;line-height:20px}input,button,select,textarea{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif}label{display:block;margin-bottom:5px}select,textarea,input[type="text"],input[type="password"],input[type="datetime"],input[type="datetime-local"],input[type="date"],input[type="month"],input[type="time"],input[type="week"],input[type="number"],input[type="email"],input[type="url"],input[type="search"],input[type="tel"],input[type="color"],.uneditable-input{display:inline-block;height:20px;padding:4px 6px;margin-bottom:10px;font-size:14px;line-height:20px;color:#555;vertical-align:middle;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}input,textarea,.uneditable-input{width:206px}textarea{height:auto}textarea,input[type="text"],input[type="password"],input[type="datetime"],input[type="datetime-local"],input[type="date"],input[type="month"],input[type="time"],input[type="week"],input[type="number"],input[type="email"],input[type="url"],input[type="search"],input[type="tel"],input[type="color"],.uneditable-input{background-color:#fff;border:1px solid #ccc;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-webkit-transition:border linear .2s,box-shadow linear .2s;-moz-transition:border linear .2s,box-shadow linear .2s;-o-transition:border linear .2s,box-shadow linear .2s;transition:border linear .2s,box-shadow linear .2s}textarea:focus,input[type="text"]:focus,input[type="password"]:focus,input[type="datetime"]:focus,input[type="datetime-local"]:focus,input[type="date"]:focus,input[type="month"]:focus,input[type="time"]:focus,input[type="week"]:focus,input[type="number"]:focus,input[type="email"]:focus,input[type="url"]:focus,input[type="search"]:focus,input[type="tel"]:focus,input[type="color"]:focus,.uneditable-input:focus{border-color:rgba(82,168,236,0.8);outline:0;outline:thin dotted \9;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(82,168,236,0.6);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(82,168,236,0.6);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(82,168,236,0.6)}input[type="radio"],input[type="checkbox"]{margin:4px 0 0;margin-top:1px \9;*margin-top:0;line-height:normal}input[type="file"],input[type="image"],input[type="submit"],input[type="reset"],input[type="button"],input[type="radio"],input[type="checkbox"]{width:auto}select,input[type="file"]{height:30px;*margin-top:4px;line-height:30px}select{width:220px;background-color:#fff;border:1px solid #ccc}select[multiple],select[size]{height:auto}select:focus,input[type="file"]:focus,input[type="radio"]:focus,input[type="checkbox"]:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.uneditable-input,.uneditable-textarea{color:#999;cursor:not-allowed;background-color:#fcfcfc;border-color:#ccc;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.025);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.025);box-shadow:inset 0 1px 2px rgba(0,0,0,0.025)}.uneditable-input{overflow:hidden;white-space:nowrap}.uneditable-textarea{width:auto;height:auto}input:-moz-placeholder,textarea:-moz-placeholder{color:#999}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#999}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder{color:#999}.radio,.checkbox{min-height:20px;padding-left:20px}.radio input[type="radio"],.checkbox input[type="checkbox"]{float:left;margin-left:-20px}.controls>.radio:first-child,.controls>.checkbox:first-child{padding-top:5px}.radio.inline,.checkbox.inline{display:inline-block;padding-top:5px;margin-bottom:0;vertical-align:middle}.radio.inline+.radio.inline,.checkbox.inline+.checkbox.inline{margin-left:10px}.input-mini{width:60px}.input-small{width:90px}.input-medium{width:150px}.input-large{width:210px}.input-xlarge{width:270px}.input-xxlarge{width:530px}input[class*="span"],select[class*="span"],textarea[class*="span"],.uneditable-input[class*="span"],.row-fluid input[class*="span"],.row-fluid select[class*="span"],.row-fluid textarea[class*="span"],.row-fluid .uneditable-input[class*="span"]{float:none;margin-left:0}.input-append input[class*="span"],.input-append .uneditable-input[class*="span"],.input-prepend input[class*="span"],.input-prepend .uneditable-input[class*="span"],.row-fluid input[class*="span"],.row-fluid select[class*="span"],.row-fluid textarea[class*="span"],.row-fluid .uneditable-input[class*="span"],.row-fluid .input-prepend [class*="span"],.row-fluid .input-append [class*="span"]{display:inline-block}input,textarea,.uneditable-input{margin-left:0}.controls-row [class*="span"]+[class*="span"]{margin-left:20px}input.span12,textarea.span12,.uneditable-input.span12{width:926px}input.span11,textarea.span11,.uneditable-input.span11{width:846px}input.span10,textarea.span10,.uneditable-input.span10{width:766px}input.span9,textarea.span9,.uneditable-input.span9{width:686px}input.span8,textarea.span8,.uneditable-input.span8{width:606px}input.span7,textarea.span7,.uneditable-input.span7{width:526px}input.span6,textarea.span6,.uneditable-input.span6{width:446px}input.span5,textarea.span5,.uneditable-input.span5{width:366px}input.span4,textarea.span4,.uneditable-input.span4{width:286px}input.span3,textarea.span3,.uneditable-input.span3{width:206px}input.span2,textarea.span2,.uneditable-input.span2{width:126px}input.span1,textarea.span1,.uneditable-input.span1{width:46px}.controls-row{*zoom:1}.controls-row:before,.controls-row:after{display:table;line-height:0;content:""}.controls-row:after{clear:both}.controls-row [class*="span"],.row-fluid .controls-row [class*="span"]{float:left}.controls-row .checkbox[class*="span"],.controls-row .radio[class*="span"]{padding-top:5px}input[disabled],select[disabled],textarea[disabled],input[readonly],select[readonly],textarea[readonly]{cursor:not-allowed;background-color:#eee}input[type="radio"][disabled],input[type="checkbox"][disabled],input[type="radio"][readonly],input[type="checkbox"][readonly]{background-color:transparent}.control-group.warning .control-label,.control-group.warning .help-block,.control-group.warning .help-inline{color:#c09853}.control-group.warning .checkbox,.control-group.warning .radio,.control-group.warning input,.control-group.warning select,.control-group.warning textarea{color:#c09853}.control-group.warning input,.control-group.warning select,.control-group.warning textarea{border-color:#c09853;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.control-group.warning input:focus,.control-group.warning select:focus,.control-group.warning textarea:focus{border-color:#a47e3c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #dbc59e;-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #dbc59e;box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #dbc59e}.control-group.warning .input-prepend .add-on,.control-group.warning .input-append .add-on{color:#c09853;background-color:#fcf8e3;border-color:#c09853}.control-group.error .control-label,.control-group.error .help-block,.control-group.error .help-inline{color:#b94a48}.control-group.error .checkbox,.control-group.error .radio,.control-group.error input,.control-group.error select,.control-group.error textarea{color:#b94a48}.control-group.error input,.control-group.error select,.control-group.error textarea{border-color:#b94a48;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.control-group.error input:focus,.control-group.error select:focus,.control-group.error textarea:focus{border-color:#953b39;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #d59392;-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #d59392;box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #d59392}.control-group.error .input-prepend .add-on,.control-group.error .input-append .add-on{color:#b94a48;background-color:#f2dede;border-color:#b94a48}.control-group.success .control-label,.control-group.success .help-block,.control-group.success .help-inline{color:#468847}.control-group.success .checkbox,.control-group.success .radio,.control-group.success input,.control-group.success select,.control-group.success textarea{color:#468847}.control-group.success input,.control-group.success select,.control-group.success textarea{border-color:#468847;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.control-group.success input:focus,.control-group.success select:focus,.control-group.success textarea:focus{border-color:#356635;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7aba7b;-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7aba7b;box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7aba7b}.control-group.success .input-prepend .add-on,.control-group.success .input-append .add-on{color:#468847;background-color:#dff0d8;border-color:#468847}.control-group.info .control-label,.control-group.info .help-block,.control-group.info .help-inline{color:#3a87ad}.control-group.info .checkbox,.control-group.info .radio,.control-group.info input,.control-group.info select,.control-group.info textarea{color:#3a87ad}.control-group.info input,.control-group.info select,.control-group.info textarea{border-color:#3a87ad;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.control-group.info input:focus,.control-group.info select:focus,.control-group.info textarea:focus{border-color:#2d6987;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7ab5d3;-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7ab5d3;box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #7ab5d3}.control-group.info .input-prepend .add-on,.control-group.info .input-append .add-on{color:#3a87ad;background-color:#d9edf7;border-color:#3a87ad}input:focus:invalid,textarea:focus:invalid,select:focus:invalid{color:#b94a48;border-color:#ee5f5b}input:focus:invalid:focus,textarea:focus:invalid:focus,select:focus:invalid:focus{border-color:#e9322d;-webkit-box-shadow:0 0 6px #f8b9b7;-moz-box-shadow:0 0 6px #f8b9b7;box-shadow:0 0 6px #f8b9b7}.form-actions{padding:19px 20px 20px;margin-top:20px;margin-bottom:20px;background-color:#f5f5f5;border-top:1px solid #e5e5e5;*zoom:1}.form-actions:before,.form-actions:after{display:table;line-height:0;content:""}.form-actions:after{clear:both}.help-block,.help-inline{color:#595959}.help-block{display:block;margin-bottom:10px}.help-inline{display:inline-block;*display:inline;padding-left:5px;vertical-align:middle;*zoom:1}.input-append,.input-prepend{display:inline-block;margin-bottom:10px;font-size:0;white-space:nowrap;vertical-align:middle}.input-append input,.input-prepend input,.input-append select,.input-prepend select,.input-append .uneditable-input,.input-prepend .uneditable-input,.input-append .dropdown-menu,.input-prepend .dropdown-menu,.input-append .popover,.input-prepend .popover{font-size:14px}.input-append input,.input-prepend input,.input-append select,.input-prepend select,.input-append .uneditable-input,.input-prepend .uneditable-input{position:relative;margin-bottom:0;*margin-left:0;vertical-align:top;-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.input-append input:focus,.input-prepend input:focus,.input-append select:focus,.input-prepend select:focus,.input-append .uneditable-input:focus,.input-prepend .uneditable-input:focus{z-index:2}.input-append .add-on,.input-prepend .add-on{display:inline-block;width:auto;height:20px;min-width:16px;padding:4px 5px;font-size:14px;font-weight:normal;line-height:20px;text-align:center;text-shadow:0 1px 0 #fff;background-color:#eee;border:1px solid #ccc}.input-append .add-on,.input-prepend .add-on,.input-append .btn,.input-prepend .btn,.input-append .btn-group>.dropdown-toggle,.input-prepend .btn-group>.dropdown-toggle{vertical-align:top;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.input-append .active,.input-prepend .active{background-color:#a9dba9;border-color:#46a546}.input-prepend .add-on,.input-prepend .btn{margin-right:-1px}.input-prepend .add-on:first-child,.input-prepend .btn:first-child{-webkit-border-radius:4px 0 0 4px;-moz-border-radius:4px 0 0 4px;border-radius:4px 0 0 4px}.input-append input,.input-append select,.input-append .uneditable-input{-webkit-border-radius:4px 0 0 4px;-moz-border-radius:4px 0 0 4px;border-radius:4px 0 0 4px}.input-append input+.btn-group .btn:last-child,.input-append select+.btn-group .btn:last-child,.input-append .uneditable-input+.btn-group .btn:last-child{-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.input-append .add-on,.input-append .btn,.input-append .btn-group{margin-left:-1px}.input-append .add-on:last-child,.input-append .btn:last-child,.input-append .btn-group:last-child>.dropdown-toggle{-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.input-prepend.input-append input,.input-prepend.input-append select,.input-prepend.input-append .uneditable-input{-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.input-prepend.input-append input+.btn-group .btn,.input-prepend.input-append select+.btn-group .btn,.input-prepend.input-append .uneditable-input+.btn-group .btn{-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.input-prepend.input-append .add-on:first-child,.input-prepend.input-append .btn:first-child{margin-right:-1px;-webkit-border-radius:4px 0 0 4px;-moz-border-radius:4px 0 0 4px;border-radius:4px 0 0 4px}.input-prepend.input-append .add-on:last-child,.input-prepend.input-append .btn:last-child{margin-left:-1px;-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.input-prepend.input-append .btn-group:first-child{margin-left:0}input.search-query{padding-right:14px;padding-right:4px \9;padding-left:14px;padding-left:4px \9;margin-bottom:0;-webkit-border-radius:15px;-moz-border-radius:15px;border-radius:15px}.form-search .input-append .search-query,.form-search .input-prepend .search-query{-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.form-search .input-append .search-query{-webkit-border-radius:14px 0 0 14px;-moz-border-radius:14px 0 0 14px;border-radius:14px 0 0 14px}.form-search .input-append .btn{-webkit-border-radius:0 14px 14px 0;-moz-border-radius:0 14px 14px 0;border-radius:0 14px 14px 0}.form-search .input-prepend .search-query{-webkit-border-radius:0 14px 14px 0;-moz-border-radius:0 14px 14px 0;border-radius:0 14px 14px 0}.form-search .input-prepend .btn{-webkit-border-radius:14px 0 0 14px;-moz-border-radius:14px 0 0 14px;border-radius:14px 0 0 14px}.form-search input,.form-inline input,.form-horizontal input,.form-search textarea,.form-inline textarea,.form-horizontal textarea,.form-search select,.form-inline select,.form-horizontal select,.form-search .help-inline,.form-inline .help-inline,.form-horizontal .help-inline,.form-search .uneditable-input,.form-inline .uneditable-input,.form-horizontal .uneditable-input,.form-search .input-prepend,.form-inline .input-prepend,.form-horizontal .input-prepend,.form-search .input-append,.form-inline .input-append,.form-horizontal .input-append{display:inline-block;*display:inline;margin-bottom:0;vertical-align:middle;*zoom:1}.form-search .hide,.form-inline .hide,.form-horizontal .hide{display:none}.form-search label,.form-inline label,.form-search .btn-group,.form-inline .btn-group{display:inline-block}.form-search .input-append,.form-inline .input-append,.form-search .input-prepend,.form-inline .input-prepend{margin-bottom:0}.form-search .radio,.form-search .checkbox,.form-inline .radio,.form-inline .checkbox{padding-left:0;margin-bottom:0;vertical-align:middle}.form-search .radio input[type="radio"],.form-search .checkbox input[type="checkbox"],.form-inline .radio input[type="radio"],.form-inline .checkbox input[type="checkbox"]{float:left;margin-right:3px;margin-left:0}.control-group{margin-bottom:10px}legend+.control-group{margin-top:20px;-webkit-margin-top-collapse:separate}.form-horizontal .control-group{margin-bottom:20px;*zoom:1}.form-horizontal .control-group:before,.form-horizontal .control-group:after{display:table;line-height:0;content:""}.form-horizontal .control-group:after{clear:both}.form-horizontal .control-label{float:left;width:160px;padding-top:5px;text-align:right}.form-horizontal .controls{*display:inline-block;*padding-left:20px;margin-left:180px;*margin-left:0}.form-horizontal .controls:first-child{*padding-left:180px}.form-horizontal .help-block{margin-bottom:0}.form-horizontal input+.help-block,.form-horizontal select+.help-block,.form-horizontal textarea+.help-block,.form-horizontal .uneditable-input+.help-block,.form-horizontal .input-prepend+.help-block,.form-horizontal .input-append+.help-block{margin-top:10px}.form-horizontal .form-actions{padding-left:180px}table{max-width:100%;background-color:transparent;border-collapse:collapse;border-spacing:0}.table{width:100%;margin-bottom:20px}.table th,.table td{padding:8px;line-height:20px;text-align:left;vertical-align:top;border-top:1px solid #ddd}.table th{font-weight:bold}.table thead th{vertical-align:bottom}.table caption+thead tr:first-child th,.table caption+thead tr:first-child td,.table colgroup+thead tr:first-child th,.table colgroup+thead tr:first-child td,.table thead:first-child tr:first-child th,.table thead:first-child tr:first-child td{border-top:0}.table tbody+tbody{border-top:2px solid #ddd}.table .table{background-color:#fff}.table-condensed th,.table-condensed td{padding:4px 5px}.table-bordered{border:1px solid #ddd;border-collapse:separate;*border-collapse:collapse;border-left:0;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.table-bordered th,.table-bordered td{border-left:1px solid #ddd}.table-bordered caption+thead tr:first-child th,.table-bordered caption+tbody tr:first-child th,.table-bordered caption+tbody tr:first-child td,.table-bordered colgroup+thead tr:first-child th,.table-bordered colgroup+tbody tr:first-child th,.table-bordered colgroup+tbody tr:first-child td,.table-bordered thead:first-child tr:first-child th,.table-bordered tbody:first-child tr:first-child th,.table-bordered tbody:first-child tr:first-child td{border-top:0}.table-bordered thead:first-child tr:first-child>th:first-child,.table-bordered tbody:first-child tr:first-child>td:first-child,.table-bordered tbody:first-child tr:first-child>th:first-child{-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-topleft:4px}.table-bordered thead:first-child tr:first-child>th:last-child,.table-bordered tbody:first-child tr:first-child>td:last-child,.table-bordered tbody:first-child tr:first-child>th:last-child{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-moz-border-radius-topright:4px}.table-bordered thead:last-child tr:last-child>th:first-child,.table-bordered tbody:last-child tr:last-child>td:first-child,.table-bordered tbody:last-child tr:last-child>th:first-child,.table-bordered tfoot:last-child tr:last-child>td:first-child,.table-bordered tfoot:last-child tr:last-child>th:first-child{-webkit-border-bottom-left-radius:4px;border-bottom-left-radius:4px;-moz-border-radius-bottomleft:4px}.table-bordered thead:last-child tr:last-child>th:last-child,.table-bordered tbody:last-child tr:last-child>td:last-child,.table-bordered tbody:last-child tr:last-child>th:last-child,.table-bordered tfoot:last-child tr:last-child>td:last-child,.table-bordered tfoot:last-child tr:last-child>th:last-child{-webkit-border-bottom-right-radius:4px;border-bottom-right-radius:4px;-moz-border-radius-bottomright:4px}.table-bordered tfoot+tbody:last-child tr:last-child td:first-child{-webkit-border-bottom-left-radius:0;border-bottom-left-radius:0;-moz-border-radius-bottomleft:0}.table-bordered tfoot+tbody:last-child tr:last-child td:last-child{-webkit-border-bottom-right-radius:0;border-bottom-right-radius:0;-moz-border-radius-bottomright:0}.table-bordered caption+thead tr:first-child th:first-child,.table-bordered caption+tbody tr:first-child td:first-child,.table-bordered colgroup+thead tr:first-child th:first-child,.table-bordered colgroup+tbody tr:first-child td:first-child{-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-topleft:4px}.table-bordered caption+thead tr:first-child th:last-child,.table-bordered caption+tbody tr:first-child td:last-child,.table-bordered colgroup+thead tr:first-child th:last-child,.table-bordered colgroup+tbody tr:first-child td:last-child{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-moz-border-radius-topright:4px}.table-striped tbody>tr:nth-child(odd)>td,.table-striped tbody>tr:nth-child(odd)>th{background-color:#f9f9f9}.table-hover tbody tr:hover>td,.table-hover tbody tr:hover>th{background-color:#f5f5f5}table td[class*="span"],table th[class*="span"],.row-fluid table td[class*="span"],.row-fluid table th[class*="span"]{display:table-cell;float:none;margin-left:0}.table td.span1,.table th.span1{float:none;width:44px;margin-left:0}.table td.span2,.table th.span2{float:none;width:124px;margin-left:0}.table td.span3,.table th.span3{float:none;width:204px;margin-left:0}.table td.span4,.table th.span4{float:none;width:284px;margin-left:0}.table td.span5,.table th.span5{float:none;width:364px;margin-left:0}.table td.span6,.table th.span6{float:none;width:444px;margin-left:0}.table td.span7,.table th.span7{float:none;width:524px;margin-left:0}.table td.span8,.table th.span8{float:none;width:604px;margin-left:0}.table td.span9,.table th.span9{float:none;width:684px;margin-left:0}.table td.span10,.table th.span10{float:none;width:764px;margin-left:0}.table td.span11,.table th.span11{float:none;width:844px;margin-left:0}.table td.span12,.table th.span12{float:none;width:924px;margin-left:0}.table tbody tr.success>td{background-color:#dff0d8}.table tbody tr.error>td{background-color:#f2dede}.table tbody tr.warning>td{background-color:#fcf8e3}.table tbody tr.info>td{background-color:#d9edf7}.table-hover tbody tr.success:hover>td{background-color:#d0e9c6}.table-hover tbody tr.error:hover>td{background-color:#ebcccc}.table-hover tbody tr.warning:hover>td{background-color:#faf2cc}.table-hover tbody tr.info:hover>td{background-color:#c4e3f3}[class^="icon-"],[class*=" icon-"]{display:inline-block;width:14px;height:14px;margin-top:1px;*margin-right:.3em;line-height:14px;vertical-align:text-top;background-image:url("../img/glyphicons-halflings.png");background-position:14px 14px;background-repeat:no-repeat}.icon-white,.nav-pills>.active>a>[class^="icon-"],.nav-pills>.active>a>[class*=" icon-"],.nav-list>.active>a>[class^="icon-"],.nav-list>.active>a>[class*=" icon-"],.navbar-inverse .nav>.active>a>[class^="icon-"],.navbar-inverse .nav>.active>a>[class*=" icon-"],.dropdown-menu>li>a:hover>[class^="icon-"],.dropdown-menu>li>a:focus>[class^="icon-"],.dropdown-menu>li>a:hover>[class*=" icon-"],.dropdown-menu>li>a:focus>[class*=" icon-"],.dropdown-menu>.active>a>[class^="icon-"],.dropdown-menu>.active>a>[class*=" icon-"],.dropdown-submenu:hover>a>[class^="icon-"],.dropdown-submenu:focus>a>[class^="icon-"],.dropdown-submenu:hover>a>[class*=" icon-"],.dropdown-submenu:focus>a>[class*=" icon-"]{background-image:url("../img/glyphicons-halflings-white.png")}.icon-glass{background-position:0 0}.icon-music{background-position:-24px 0}.icon-search{background-position:-48px 0}.icon-envelope{background-position:-72px 0}.icon-heart{background-position:-96px 0}.icon-star{background-position:-120px 0}.icon-star-empty{background-position:-144px 0}.icon-user{background-position:-168px 0}.icon-film{background-position:-192px 0}.icon-th-large{background-position:-216px 0}.icon-th{background-position:-240px 0}.icon-th-list{background-position:-264px 0}.icon-ok{background-position:-288px 0}.icon-remove{background-position:-312px 0}.icon-zoom-in{background-position:-336px 0}.icon-zoom-out{background-position:-360px 0}.icon-off{background-position:-384px 0}.icon-signal{background-position:-408px 0}.icon-cog{background-position:-432px 0}.icon-trash{background-position:-456px 0}.icon-home{background-position:0 -24px}.icon-file{background-position:-24px -24px}.icon-time{background-position:-48px -24px}.icon-road{background-position:-72px -24px}.icon-download-alt{background-position:-96px -24px}.icon-download{background-position:-120px -24px}.icon-upload{background-position:-144px -24px}.icon-inbox{background-position:-168px -24px}.icon-play-circle{background-position:-192px -24px}.icon-repeat{background-position:-216px -24px}.icon-refresh{background-position:-240px -24px}.icon-list-alt{background-position:-264px -24px}.icon-lock{background-position:-287px -24px}.icon-flag{background-position:-312px -24px}.icon-headphones{background-position:-336px -24px}.icon-volume-off{background-position:-360px -24px}.icon-volume-down{background-position:-384px -24px}.icon-volume-up{background-position:-408px -24px}.icon-qrcode{background-position:-432px -24px}.icon-barcode{background-position:-456px -24px}.icon-tag{background-position:0 -48px}.icon-tags{background-position:-25px -48px}.icon-book{background-position:-48px -48px}.icon-bookmark{background-position:-72px -48px}.icon-print{background-position:-96px -48px}.icon-camera{background-position:-120px -48px}.icon-font{background-position:-144px -48px}.icon-bold{background-position:-167px -48px}.icon-italic{background-position:-192px -48px}.icon-text-height{background-position:-216px -48px}.icon-text-width{background-position:-240px -48px}.icon-align-left{background-position:-264px -48px}.icon-align-center{background-position:-288px -48px}.icon-align-right{background-position:-312px -48px}.icon-align-justify{background-position:-336px -48px}.icon-list{background-position:-360px -48px}.icon-indent-left{background-position:-384px -48px}.icon-indent-right{background-position:-408px -48px}.icon-facetime-video{background-position:-432px -48px}.icon-picture{background-position:-456px -48px}.icon-pencil{background-position:0 -72px}.icon-map-marker{background-position:-24px -72px}.icon-adjust{background-position:-48px -72px}.icon-tint{background-position:-72px -72px}.icon-edit{background-position:-96px -72px}.icon-share{background-position:-120px -72px}.icon-check{background-position:-144px -72px}.icon-move{background-position:-168px -72px}.icon-step-backward{background-position:-192px -72px}.icon-fast-backward{background-position:-216px -72px}.icon-backward{background-position:-240px -72px}.icon-play{background-position:-264px -72px}.icon-pause{background-position:-288px -72px}.icon-stop{background-position:-312px -72px}.icon-forward{background-position:-336px -72px}.icon-fast-forward{background-position:-360px -72px}.icon-step-forward{background-position:-384px -72px}.icon-eject{background-position:-408px -72px}.icon-chevron-left{background-position:-432px -72px}.icon-chevron-right{background-position:-456px -72px}.icon-plus-sign{background-position:0 -96px}.icon-minus-sign{background-position:-24px -96px}.icon-remove-sign{background-position:-48px -96px}.icon-ok-sign{background-position:-72px -96px}.icon-question-sign{background-position:-96px -96px}.icon-info-sign{background-position:-120px -96px}.icon-screenshot{background-position:-144px -96px}.icon-remove-circle{background-position:-168px -96px}.icon-ok-circle{background-position:-192px -96px}.icon-ban-circle{background-position:-216px -96px}.icon-arrow-left{background-position:-240px -96px}.icon-arrow-right{background-position:-264px -96px}.icon-arrow-up{background-position:-289px -96px}.icon-arrow-down{background-position:-312px -96px}.icon-share-alt{background-position:-336px -96px}.icon-resize-full{background-position:-360px -96px}.icon-resize-small{background-position:-384px -96px}.icon-plus{background-position:-408px -96px}.icon-minus{background-position:-433px -96px}.icon-asterisk{background-position:-456px -96px}.icon-exclamation-sign{background-position:0 -120px}.icon-gift{background-position:-24px -120px}.icon-leaf{background-position:-48px -120px}.icon-fire{background-position:-72px -120px}.icon-eye-open{background-position:-96px -120px}.icon-eye-close{background-position:-120px -120px}.icon-warning-sign{background-position:-144px -120px}.icon-plane{background-position:-168px -120px}.icon-calendar{background-position:-192px -120px}.icon-random{width:16px;background-position:-216px -120px}.icon-comment{background-position:-240px -120px}.icon-magnet{background-position:-264px -120px}.icon-chevron-up{background-position:-288px -120px}.icon-chevron-down{background-position:-313px -119px}.icon-retweet{background-position:-336px -120px}.icon-shopping-cart{background-position:-360px -120px}.icon-folder-close{width:16px;background-position:-384px -120px}.icon-folder-open{width:16px;background-position:-408px -120px}.icon-resize-vertical{background-position:-432px -119px}.icon-resize-horizontal{background-position:-456px -118px}.icon-hdd{background-position:0 -144px}.icon-bullhorn{background-position:-24px -144px}.icon-bell{background-position:-48px -144px}.icon-certificate{background-position:-72px -144px}.icon-thumbs-up{background-position:-96px -144px}.icon-thumbs-down{background-position:-120px -144px}.icon-hand-right{background-position:-144px -144px}.icon-hand-left{background-position:-168px -144px}.icon-hand-up{background-position:-192px -144px}.icon-hand-down{background-position:-216px -144px}.icon-circle-arrow-right{background-position:-240px -144px}.icon-circle-arrow-left{background-position:-264px -144px}.icon-circle-arrow-up{background-position:-288px -144px}.icon-circle-arrow-down{background-position:-312px -144px}.icon-globe{background-position:-336px -144px}.icon-wrench{background-position:-360px -144px}.icon-tasks{background-position:-384px -144px}.icon-filter{background-position:-408px -144px}.icon-briefcase{background-position:-432px -144px}.icon-fullscreen{background-position:-456px -144px}.dropup,.dropdown{position:relative}.dropdown-toggle{*margin-bottom:-3px}.dropdown-toggle:active,.open .dropdown-toggle{outline:0}.caret{display:inline-block;width:0;height:0;vertical-align:top;border-top:4px solid #000;border-right:4px solid transparent;border-left:4px solid transparent;content:""}.dropdown .caret{margin-top:8px;margin-left:2px}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:2px 0 0;list-style:none;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.2);*border-right-width:2px;*border-bottom-width:2px;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;-webkit-box-shadow:0 5px 10px rgba(0,0,0,0.2);-moz-box-shadow:0 5px 10px rgba(0,0,0,0.2);box-shadow:0 5px 10px rgba(0,0,0,0.2);-webkit-background-clip:padding-box;-moz-background-clip:padding;background-clip:padding-box}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{*width:100%;height:1px;margin:9px 1px;*margin:-5px 0 5px;overflow:hidden;background-color:#e5e5e5;border-bottom:1px solid #fff}.dropdown-menu>li>a{display:block;padding:3px 20px;clear:both;font-weight:normal;line-height:20px;color:#333;white-space:nowrap}.dropdown-menu>li>a:hover,.dropdown-menu>li>a:focus,.dropdown-submenu:hover>a,.dropdown-submenu:focus>a{color:#fff;text-decoration:none;background-color:#0081c2;background-image:-moz-linear-gradient(top,#08c,#0077b3);background-image:-webkit-gradient(linear,0 0,0 100%,from(#08c),to(#0077b3));background-image:-webkit-linear-gradient(top,#08c,#0077b3);background-image:-o-linear-gradient(top,#08c,#0077b3);background-image:linear-gradient(to bottom,#08c,#0077b3);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff0088cc',endColorstr='#ff0077b3',GradientType=0)}.dropdown-menu>.active>a,.dropdown-menu>.active>a:hover,.dropdown-menu>.active>a:focus{color:#fff;text-decoration:none;background-color:#0081c2;background-image:-moz-linear-gradient(top,#08c,#0077b3);background-image:-webkit-gradient(linear,0 0,0 100%,from(#08c),to(#0077b3));background-image:-webkit-linear-gradient(top,#08c,#0077b3);background-image:-o-linear-gradient(top,#08c,#0077b3);background-image:linear-gradient(to bottom,#08c,#0077b3);background-repeat:repeat-x;outline:0;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff0088cc',endColorstr='#ff0077b3',GradientType=0)}.dropdown-menu>.disabled>a,.dropdown-menu>.disabled>a:hover,.dropdown-menu>.disabled>a:focus{color:#999}.dropdown-menu>.disabled>a:hover,.dropdown-menu>.disabled>a:focus{text-decoration:none;cursor:default;background-color:transparent;background-image:none;filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.open{*z-index:1000}.open>.dropdown-menu{display:block}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{border-top:0;border-bottom:4px solid #000;content:""}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:1px}.dropdown-submenu{position:relative}.dropdown-submenu>.dropdown-menu{top:0;left:100%;margin-top:-6px;margin-left:-1px;-webkit-border-radius:0 6px 6px 6px;-moz-border-radius:0 6px 6px 6px;border-radius:0 6px 6px 6px}.dropdown-submenu:hover>.dropdown-menu{display:block}.dropup .dropdown-submenu>.dropdown-menu{top:auto;bottom:0;margin-top:0;margin-bottom:-2px;-webkit-border-radius:5px 5px 5px 0;-moz-border-radius:5px 5px 5px 0;border-radius:5px 5px 5px 0}.dropdown-submenu>a:after{display:block;float:right;width:0;height:0;margin-top:5px;margin-right:-10px;border-color:transparent;border-left-color:#ccc;border-style:solid;border-width:5px 0 5px 5px;content:" "}.dropdown-submenu:hover>a:after{border-left-color:#fff}.dropdown-submenu.pull-left{float:none}.dropdown-submenu.pull-left>.dropdown-menu{left:-100%;margin-left:10px;-webkit-border-radius:6px 0 6px 6px;-moz-border-radius:6px 0 6px 6px;border-radius:6px 0 6px 6px}.dropdown .dropdown-menu .nav-header{padding-right:20px;padding-left:20px}.typeahead{z-index:1051;margin-top:2px;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.well{min-height:20px;padding:19px;margin-bottom:20px;background-color:#f5f5f5;border:1px solid #e3e3e3;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);box-shadow:inset 0 1px 1px rgba(0,0,0,0.05)}.well blockquote{border-color:#ddd;border-color:rgba(0,0,0,0.15)}.well-large{padding:24px;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.well-small{padding:9px;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.fade{opacity:0;-webkit-transition:opacity .15s linear;-moz-transition:opacity .15s linear;-o-transition:opacity .15s linear;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{position:relative;height:0;overflow:hidden;-webkit-transition:height .35s ease;-moz-transition:height .35s ease;-o-transition:height .35s ease;transition:height .35s ease}.collapse.in{height:auto}.close{float:right;font-size:20px;font-weight:bold;line-height:20px;color:#000;text-shadow:0 1px 0 #fff;opacity:.2;filter:alpha(opacity=20)}.close:hover,.close:focus{color:#000;text-decoration:none;cursor:pointer;opacity:.4;filter:alpha(opacity=40)}button.close{padding:0;cursor:pointer;background:transparent;border:0;-webkit-appearance:none}.btn{display:inline-block;*display:inline;padding:4px 12px;margin-bottom:0;*margin-left:.3em;font-size:14px;line-height:20px;color:#333;text-align:center;text-shadow:0 1px 1px rgba(255,255,255,0.75);vertical-align:middle;cursor:pointer;background-color:#f5f5f5;*background-color:#e6e6e6;background-image:-moz-linear-gradient(top,#fff,#e6e6e6);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fff),to(#e6e6e6));background-image:-webkit-linear-gradient(top,#fff,#e6e6e6);background-image:-o-linear-gradient(top,#fff,#e6e6e6);background-image:linear-gradient(to bottom,#fff,#e6e6e6);background-repeat:repeat-x;border:1px solid #ccc;*border:0;border-color:#e6e6e6 #e6e6e6 #bfbfbf;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);border-bottom-color:#b3b3b3;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffffff',endColorstr='#ffe6e6e6',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);*zoom:1;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05)}.btn:hover,.btn:focus,.btn:active,.btn.active,.btn.disabled,.btn[disabled]{color:#333;background-color:#e6e6e6;*background-color:#d9d9d9}.btn:active,.btn.active{background-color:#ccc \9}.btn:first-child{*margin-left:0}.btn:hover,.btn:focus{color:#333;text-decoration:none;background-position:0 -15px;-webkit-transition:background-position .1s linear;-moz-transition:background-position .1s linear;-o-transition:background-position .1s linear;transition:background-position .1s linear}.btn:focus{outline:thin dotted #333;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn.active,.btn:active{background-image:none;outline:0;-webkit-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05)}.btn.disabled,.btn[disabled]{cursor:default;background-image:none;opacity:.65;filter:alpha(opacity=65);-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none}.btn-large{padding:11px 19px;font-size:17.5px;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.btn-large [class^="icon-"],.btn-large [class*=" icon-"]{margin-top:4px}.btn-small{padding:2px 10px;font-size:11.9px;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.btn-small [class^="icon-"],.btn-small [class*=" icon-"]{margin-top:0}.btn-mini [class^="icon-"],.btn-mini [class*=" icon-"]{margin-top:-1px}.btn-mini{padding:0 6px;font-size:10.5px;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.btn-block{display:block;width:100%;padding-right:0;padding-left:0;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.btn-block+.btn-block{margin-top:5px}input[type="submit"].btn-block,input[type="reset"].btn-block,input[type="button"].btn-block{width:100%}.btn-primary.active,.btn-warning.active,.btn-danger.active,.btn-success.active,.btn-info.active,.btn-inverse.active{color:rgba(255,255,255,0.75)}.btn-primary{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#006dcc;*background-color:#04c;background-image:-moz-linear-gradient(top,#08c,#04c);background-image:-webkit-gradient(linear,0 0,0 100%,from(#08c),to(#04c));background-image:-webkit-linear-gradient(top,#08c,#04c);background-image:-o-linear-gradient(top,#08c,#04c);background-image:linear-gradient(to bottom,#08c,#04c);background-repeat:repeat-x;border-color:#04c #04c #002a80;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff0088cc',endColorstr='#ff0044cc',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-primary:hover,.btn-primary:focus,.btn-primary:active,.btn-primary.active,.btn-primary.disabled,.btn-primary[disabled]{color:#fff;background-color:#04c;*background-color:#003bb3}.btn-primary:active,.btn-primary.active{background-color:#039 \9}.btn-warning{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#faa732;*background-color:#f89406;background-image:-moz-linear-gradient(top,#fbb450,#f89406);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fbb450),to(#f89406));background-image:-webkit-linear-gradient(top,#fbb450,#f89406);background-image:-o-linear-gradient(top,#fbb450,#f89406);background-image:linear-gradient(to bottom,#fbb450,#f89406);background-repeat:repeat-x;border-color:#f89406 #f89406 #ad6704;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fffbb450',endColorstr='#fff89406',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-warning:hover,.btn-warning:focus,.btn-warning:active,.btn-warning.active,.btn-warning.disabled,.btn-warning[disabled]{color:#fff;background-color:#f89406;*background-color:#df8505}.btn-warning:active,.btn-warning.active{background-color:#c67605 \9}.btn-danger{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#da4f49;*background-color:#bd362f;background-image:-moz-linear-gradient(top,#ee5f5b,#bd362f);background-image:-webkit-gradient(linear,0 0,0 100%,from(#ee5f5b),to(#bd362f));background-image:-webkit-linear-gradient(top,#ee5f5b,#bd362f);background-image:-o-linear-gradient(top,#ee5f5b,#bd362f);background-image:linear-gradient(to bottom,#ee5f5b,#bd362f);background-repeat:repeat-x;border-color:#bd362f #bd362f #802420;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffee5f5b',endColorstr='#ffbd362f',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-danger:hover,.btn-danger:focus,.btn-danger:active,.btn-danger.active,.btn-danger.disabled,.btn-danger[disabled]{color:#fff;background-color:#bd362f;*background-color:#a9302a}.btn-danger:active,.btn-danger.active{background-color:#942a25 \9}.btn-success{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#5bb75b;*background-color:#51a351;background-image:-moz-linear-gradient(top,#62c462,#51a351);background-image:-webkit-gradient(linear,0 0,0 100%,from(#62c462),to(#51a351));background-image:-webkit-linear-gradient(top,#62c462,#51a351);background-image:-o-linear-gradient(top,#62c462,#51a351);background-image:linear-gradient(to bottom,#62c462,#51a351);background-repeat:repeat-x;border-color:#51a351 #51a351 #387038;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff62c462',endColorstr='#ff51a351',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-success:hover,.btn-success:focus,.btn-success:active,.btn-success.active,.btn-success.disabled,.btn-success[disabled]{color:#fff;background-color:#51a351;*background-color:#499249}.btn-success:active,.btn-success.active{background-color:#408140 \9}.btn-info{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#49afcd;*background-color:#2f96b4;background-image:-moz-linear-gradient(top,#5bc0de,#2f96b4);background-image:-webkit-gradient(linear,0 0,0 100%,from(#5bc0de),to(#2f96b4));background-image:-webkit-linear-gradient(top,#5bc0de,#2f96b4);background-image:-o-linear-gradient(top,#5bc0de,#2f96b4);background-image:linear-gradient(to bottom,#5bc0de,#2f96b4);background-repeat:repeat-x;border-color:#2f96b4 #2f96b4 #1f6377;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5bc0de',endColorstr='#ff2f96b4',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-info:hover,.btn-info:focus,.btn-info:active,.btn-info.active,.btn-info.disabled,.btn-info[disabled]{color:#fff;background-color:#2f96b4;*background-color:#2a85a0}.btn-info:active,.btn-info.active{background-color:#24748c \9}.btn-inverse{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#363636;*background-color:#222;background-image:-moz-linear-gradient(top,#444,#222);background-image:-webkit-gradient(linear,0 0,0 100%,from(#444),to(#222));background-image:-webkit-linear-gradient(top,#444,#222);background-image:-o-linear-gradient(top,#444,#222);background-image:linear-gradient(to bottom,#444,#222);background-repeat:repeat-x;border-color:#222 #222 #000;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff444444',endColorstr='#ff222222',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.btn-inverse:hover,.btn-inverse:focus,.btn-inverse:active,.btn-inverse.active,.btn-inverse.disabled,.btn-inverse[disabled]{color:#fff;background-color:#222;*background-color:#151515}.btn-inverse:active,.btn-inverse.active{background-color:#080808 \9}button.btn,input[type="submit"].btn{*padding-top:3px;*padding-bottom:3px}button.btn::-moz-focus-inner,input[type="submit"].btn::-moz-focus-inner{padding:0;border:0}button.btn.btn-large,input[type="submit"].btn.btn-large{*padding-top:7px;*padding-bottom:7px}button.btn.btn-small,input[type="submit"].btn.btn-small{*padding-top:3px;*padding-bottom:3px}button.btn.btn-mini,input[type="submit"].btn.btn-mini{*padding-top:1px;*padding-bottom:1px}.btn-link,.btn-link:active,.btn-link[disabled]{background-color:transparent;background-image:none;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none}.btn-link{color:#08c;cursor:pointer;border-color:transparent;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.btn-link:hover,.btn-link:focus{color:#005580;text-decoration:underline;background-color:transparent}.btn-link[disabled]:hover,.btn-link[disabled]:focus{color:#333;text-decoration:none}.btn-group{position:relative;display:inline-block;*display:inline;*margin-left:.3em;font-size:0;white-space:nowrap;vertical-align:middle;*zoom:1}.btn-group:first-child{*margin-left:0}.btn-group+.btn-group{margin-left:5px}.btn-toolbar{margin-top:10px;margin-bottom:10px;font-size:0}.btn-toolbar>.btn+.btn,.btn-toolbar>.btn-group+.btn,.btn-toolbar>.btn+.btn-group{margin-left:5px}.btn-group>.btn{position:relative;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.btn-group>.btn+.btn{margin-left:-1px}.btn-group>.btn,.btn-group>.dropdown-menu,.btn-group>.popover{font-size:14px}.btn-group>.btn-mini{font-size:10.5px}.btn-group>.btn-small{font-size:11.9px}.btn-group>.btn-large{font-size:17.5px}.btn-group>.btn:first-child{margin-left:0;-webkit-border-bottom-left-radius:4px;border-bottom-left-radius:4px;-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-bottomleft:4px;-moz-border-radius-topleft:4px}.btn-group>.btn:last-child,.btn-group>.dropdown-toggle{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-webkit-border-bottom-right-radius:4px;border-bottom-right-radius:4px;-moz-border-radius-topright:4px;-moz-border-radius-bottomright:4px}.btn-group>.btn.large:first-child{margin-left:0;-webkit-border-bottom-left-radius:6px;border-bottom-left-radius:6px;-webkit-border-top-left-radius:6px;border-top-left-radius:6px;-moz-border-radius-bottomleft:6px;-moz-border-radius-topleft:6px}.btn-group>.btn.large:last-child,.btn-group>.large.dropdown-toggle{-webkit-border-top-right-radius:6px;border-top-right-radius:6px;-webkit-border-bottom-right-radius:6px;border-bottom-right-radius:6px;-moz-border-radius-topright:6px;-moz-border-radius-bottomright:6px}.btn-group>.btn:hover,.btn-group>.btn:focus,.btn-group>.btn:active,.btn-group>.btn.active{z-index:2}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.btn+.dropdown-toggle{*padding-top:5px;padding-right:8px;*padding-bottom:5px;padding-left:8px;-webkit-box-shadow:inset 1px 0 0 rgba(255,255,255,0.125),inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 1px 0 0 rgba(255,255,255,0.125),inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 1px 0 0 rgba(255,255,255,0.125),inset 0 1px 0 rgba(255,255,255,0.2),0 1px 2px rgba(0,0,0,0.05)}.btn-group>.btn-mini+.dropdown-toggle{*padding-top:2px;padding-right:5px;*padding-bottom:2px;padding-left:5px}.btn-group>.btn-small+.dropdown-toggle{*padding-top:5px;*padding-bottom:4px}.btn-group>.btn-large+.dropdown-toggle{*padding-top:7px;padding-right:12px;*padding-bottom:7px;padding-left:12px}.btn-group.open .dropdown-toggle{background-image:none;-webkit-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05);box-shadow:inset 0 2px 4px rgba(0,0,0,0.15),0 1px 2px rgba(0,0,0,0.05)}.btn-group.open .btn.dropdown-toggle{background-color:#e6e6e6}.btn-group.open .btn-primary.dropdown-toggle{background-color:#04c}.btn-group.open .btn-warning.dropdown-toggle{background-color:#f89406}.btn-group.open .btn-danger.dropdown-toggle{background-color:#bd362f}.btn-group.open .btn-success.dropdown-toggle{background-color:#51a351}.btn-group.open .btn-info.dropdown-toggle{background-color:#2f96b4}.btn-group.open .btn-inverse.dropdown-toggle{background-color:#222}.btn .caret{margin-top:8px;margin-left:0}.btn-large .caret{margin-top:6px}.btn-large .caret{border-top-width:5px;border-right-width:5px;border-left-width:5px}.btn-mini .caret,.btn-small .caret{margin-top:8px}.dropup .btn-large .caret{border-bottom-width:5px}.btn-primary .caret,.btn-warning .caret,.btn-danger .caret,.btn-info .caret,.btn-success .caret,.btn-inverse .caret{border-top-color:#fff;border-bottom-color:#fff}.btn-group-vertical{display:inline-block;*display:inline;*zoom:1}.btn-group-vertical>.btn{display:block;float:none;max-width:100%;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.btn-group-vertical>.btn+.btn{margin-top:-1px;margin-left:0}.btn-group-vertical>.btn:first-child{-webkit-border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;border-radius:4px 4px 0 0}.btn-group-vertical>.btn:last-child{-webkit-border-radius:0 0 4px 4px;-moz-border-radius:0 0 4px 4px;border-radius:0 0 4px 4px}.btn-group-vertical>.btn-large:first-child{-webkit-border-radius:6px 6px 0 0;-moz-border-radius:6px 6px 0 0;border-radius:6px 6px 0 0}.btn-group-vertical>.btn-large:last-child{-webkit-border-radius:0 0 6px 6px;-moz-border-radius:0 0 6px 6px;border-radius:0 0 6px 6px}.alert{padding:8px 35px 8px 14px;margin-bottom:20px;text-shadow:0 1px 0 rgba(255,255,255,0.5);background-color:#fcf8e3;border:1px solid #fbeed5;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.alert,.alert h4{color:#c09853}.alert h4{margin:0}.alert .close{position:relative;top:-2px;right:-21px;line-height:20px}.alert-success{color:#468847;background-color:#dff0d8;border-color:#d6e9c6}.alert-success h4{color:#468847}.alert-danger,.alert-error{color:#b94a48;background-color:#f2dede;border-color:#eed3d7}.alert-danger h4,.alert-error h4{color:#b94a48}.alert-info{color:#3a87ad;background-color:#d9edf7;border-color:#bce8f1}.alert-info h4{color:#3a87ad}.alert-block{padding-top:14px;padding-bottom:14px}.alert-block>p,.alert-block>ul{margin-bottom:0}.alert-block p+p{margin-top:5px}.nav{margin-bottom:20px;margin-left:0;list-style:none}.nav>li>a{display:block}.nav>li>a:hover,.nav>li>a:focus{text-decoration:none;background-color:#eee}.nav>li>a>img{max-width:none}.nav>.pull-right{float:right}.nav-header{display:block;padding:3px 15px;font-size:11px;font-weight:bold;line-height:20px;color:#999;text-shadow:0 1px 0 rgba(255,255,255,0.5);text-transform:uppercase}.nav li+.nav-header{margin-top:9px}.nav-list{padding-right:15px;padding-left:15px;margin-bottom:0}.nav-list>li>a,.nav-list .nav-header{margin-right:-15px;margin-left:-15px;text-shadow:0 1px 0 rgba(255,255,255,0.5)}.nav-list>li>a{padding:3px 15px}.nav-list>.active>a,.nav-list>.active>a:hover,.nav-list>.active>a:focus{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.2);background-color:#08c}.nav-list [class^="icon-"],.nav-list [class*=" icon-"]{margin-right:2px}.nav-list .divider{*width:100%;height:1px;margin:9px 1px;*margin:-5px 0 5px;overflow:hidden;background-color:#e5e5e5;border-bottom:1px solid #fff}.nav-tabs,.nav-pills{*zoom:1}.nav-tabs:before,.nav-pills:before,.nav-tabs:after,.nav-pills:after{display:table;line-height:0;content:""}.nav-tabs:after,.nav-pills:after{clear:both}.nav-tabs>li,.nav-pills>li{float:left}.nav-tabs>li>a,.nav-pills>li>a{padding-right:12px;padding-left:12px;margin-right:2px;line-height:14px}.nav-tabs{border-bottom:1px solid #ddd}.nav-tabs>li{margin-bottom:-1px}.nav-tabs>li>a{padding-top:8px;padding-bottom:8px;line-height:20px;border:1px solid transparent;-webkit-border-radius:4px 4px 0 0;-moz-border-radius:4px 4px 0 0;border-radius:4px 4px 0 0}.nav-tabs>li>a:hover,.nav-tabs>li>a:focus{border-color:#eee #eee #ddd}.nav-tabs>.active>a,.nav-tabs>.active>a:hover,.nav-tabs>.active>a:focus{color:#555;cursor:default;background-color:#fff;border:1px solid #ddd;border-bottom-color:transparent}.nav-pills>li>a{padding-top:8px;padding-bottom:8px;margin-top:2px;margin-bottom:2px;-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px}.nav-pills>.active>a,.nav-pills>.active>a:hover,.nav-pills>.active>a:focus{color:#fff;background-color:#08c}.nav-stacked>li{float:none}.nav-stacked>li>a{margin-right:0}.nav-tabs.nav-stacked{border-bottom:0}.nav-tabs.nav-stacked>li>a{border:1px solid #ddd;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.nav-tabs.nav-stacked>li:first-child>a{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-topright:4px;-moz-border-radius-topleft:4px}.nav-tabs.nav-stacked>li:last-child>a{-webkit-border-bottom-right-radius:4px;border-bottom-right-radius:4px;-webkit-border-bottom-left-radius:4px;border-bottom-left-radius:4px;-moz-border-radius-bottomright:4px;-moz-border-radius-bottomleft:4px}.nav-tabs.nav-stacked>li>a:hover,.nav-tabs.nav-stacked>li>a:focus{z-index:2;border-color:#ddd}.nav-pills.nav-stacked>li>a{margin-bottom:3px}.nav-pills.nav-stacked>li:last-child>a{margin-bottom:1px}.nav-tabs .dropdown-menu{-webkit-border-radius:0 0 6px 6px;-moz-border-radius:0 0 6px 6px;border-radius:0 0 6px 6px}.nav-pills .dropdown-menu{-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.nav .dropdown-toggle .caret{margin-top:6px;border-top-color:#08c;border-bottom-color:#08c}.nav .dropdown-toggle:hover .caret,.nav .dropdown-toggle:focus .caret{border-top-color:#005580;border-bottom-color:#005580}.nav-tabs .dropdown-toggle .caret{margin-top:8px}.nav .active .dropdown-toggle .caret{border-top-color:#fff;border-bottom-color:#fff}.nav-tabs .active .dropdown-toggle .caret{border-top-color:#555;border-bottom-color:#555}.nav>.dropdown.active>a:hover,.nav>.dropdown.active>a:focus{cursor:pointer}.nav-tabs .open .dropdown-toggle,.nav-pills .open .dropdown-toggle,.nav>li.dropdown.open.active>a:hover,.nav>li.dropdown.open.active>a:focus{color:#fff;background-color:#999;border-color:#999}.nav li.dropdown.open .caret,.nav li.dropdown.open.active .caret,.nav li.dropdown.open a:hover .caret,.nav li.dropdown.open a:focus .caret{border-top-color:#fff;border-bottom-color:#fff;opacity:1;filter:alpha(opacity=100)}.tabs-stacked .open>a:hover,.tabs-stacked .open>a:focus{border-color:#999}.tabbable{*zoom:1}.tabbable:before,.tabbable:after{display:table;line-height:0;content:""}.tabbable:after{clear:both}.tab-content{overflow:auto}.tabs-below>.nav-tabs,.tabs-right>.nav-tabs,.tabs-left>.nav-tabs{border-bottom:0}.tab-content>.tab-pane,.pill-content>.pill-pane{display:none}.tab-content>.active,.pill-content>.active{display:block}.tabs-below>.nav-tabs{border-top:1px solid #ddd}.tabs-below>.nav-tabs>li{margin-top:-1px;margin-bottom:0}.tabs-below>.nav-tabs>li>a{-webkit-border-radius:0 0 4px 4px;-moz-border-radius:0 0 4px 4px;border-radius:0 0 4px 4px}.tabs-below>.nav-tabs>li>a:hover,.tabs-below>.nav-tabs>li>a:focus{border-top-color:#ddd;border-bottom-color:transparent}.tabs-below>.nav-tabs>.active>a,.tabs-below>.nav-tabs>.active>a:hover,.tabs-below>.nav-tabs>.active>a:focus{border-color:transparent #ddd #ddd #ddd}.tabs-left>.nav-tabs>li,.tabs-right>.nav-tabs>li{float:none}.tabs-left>.nav-tabs>li>a,.tabs-right>.nav-tabs>li>a{min-width:74px;margin-right:0;margin-bottom:3px}.tabs-left>.nav-tabs{float:left;margin-right:19px;border-right:1px solid #ddd}.tabs-left>.nav-tabs>li>a{margin-right:-1px;-webkit-border-radius:4px 0 0 4px;-moz-border-radius:4px 0 0 4px;border-radius:4px 0 0 4px}.tabs-left>.nav-tabs>li>a:hover,.tabs-left>.nav-tabs>li>a:focus{border-color:#eee #ddd #eee #eee}.tabs-left>.nav-tabs .active>a,.tabs-left>.nav-tabs .active>a:hover,.tabs-left>.nav-tabs .active>a:focus{border-color:#ddd transparent #ddd #ddd;*border-right-color:#fff}.tabs-right>.nav-tabs{float:right;margin-left:19px;border-left:1px solid #ddd}.tabs-right>.nav-tabs>li>a{margin-left:-1px;-webkit-border-radius:0 4px 4px 0;-moz-border-radius:0 4px 4px 0;border-radius:0 4px 4px 0}.tabs-right>.nav-tabs>li>a:hover,.tabs-right>.nav-tabs>li>a:focus{border-color:#eee #eee #eee #ddd}.tabs-right>.nav-tabs .active>a,.tabs-right>.nav-tabs .active>a:hover,.tabs-right>.nav-tabs .active>a:focus{border-color:#ddd #ddd #ddd transparent;*border-left-color:#fff}.nav>.disabled>a{color:#999}.nav>.disabled>a:hover,.nav>.disabled>a:focus{text-decoration:none;cursor:default;background-color:transparent}.navbar{*position:relative;*z-index:2;margin-bottom:20px;overflow:visible}.navbar-inner{min-height:40px;padding-right:20px;padding-left:20px;background-color:#fafafa;background-image:-moz-linear-gradient(top,#fff,#f2f2f2);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fff),to(#f2f2f2));background-image:-webkit-linear-gradient(top,#fff,#f2f2f2);background-image:-o-linear-gradient(top,#fff,#f2f2f2);background-image:linear-gradient(to bottom,#fff,#f2f2f2);background-repeat:repeat-x;border:1px solid #d4d4d4;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffffff',endColorstr='#fff2f2f2',GradientType=0);*zoom:1;-webkit-box-shadow:0 1px 4px rgba(0,0,0,0.065);-moz-box-shadow:0 1px 4px rgba(0,0,0,0.065);box-shadow:0 1px 4px rgba(0,0,0,0.065)}.navbar-inner:before,.navbar-inner:after{display:table;line-height:0;content:""}.navbar-inner:after{clear:both}.navbar .container{width:auto}.nav-collapse.collapse{height:auto;overflow:visible}.navbar .brand{display:block;float:left;padding:10px 20px 10px;margin-left:-20px;font-size:20px;font-weight:200;color:#777;text-shadow:0 1px 0 #fff}.navbar .brand:hover,.navbar .brand:focus{text-decoration:none}.navbar-text{margin-bottom:0;line-height:40px;color:#777}.navbar-link{color:#777}.navbar-link:hover,.navbar-link:focus{color:#333}.navbar .divider-vertical{height:40px;margin:0 9px;border-right:1px solid #fff;border-left:1px solid #f2f2f2}.navbar .btn,.navbar .btn-group{margin-top:5px}.navbar .btn-group .btn,.navbar .input-prepend .btn,.navbar .input-append .btn,.navbar .input-prepend .btn-group,.navbar .input-append .btn-group{margin-top:0}.navbar-form{margin-bottom:0;*zoom:1}.navbar-form:before,.navbar-form:after{display:table;line-height:0;content:""}.navbar-form:after{clear:both}.navbar-form input,.navbar-form select,.navbar-form .radio,.navbar-form .checkbox{margin-top:5px}.navbar-form input,.navbar-form select,.navbar-form .btn{display:inline-block;margin-bottom:0}.navbar-form input[type="image"],.navbar-form input[type="checkbox"],.navbar-form input[type="radio"]{margin-top:3px}.navbar-form .input-append,.navbar-form .input-prepend{margin-top:5px;white-space:nowrap}.navbar-form .input-append input,.navbar-form .input-prepend input{margin-top:0}.navbar-search{position:relative;float:left;margin-top:5px;margin-bottom:0}.navbar-search .search-query{padding:4px 14px;margin-bottom:0;font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:13px;font-weight:normal;line-height:1;-webkit-border-radius:15px;-moz-border-radius:15px;border-radius:15px}.navbar-static-top{position:static;margin-bottom:0}.navbar-static-top .navbar-inner{-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.navbar-fixed-top,.navbar-fixed-bottom{position:fixed;right:0;left:0;z-index:1030;margin-bottom:0}.navbar-fixed-top .navbar-inner,.navbar-static-top .navbar-inner{border-width:0 0 1px}.navbar-fixed-bottom .navbar-inner{border-width:1px 0 0}.navbar-fixed-top .navbar-inner,.navbar-fixed-bottom .navbar-inner{padding-right:0;padding-left:0;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.navbar-static-top .container,.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:940px}.navbar-fixed-top{top:0}.navbar-fixed-top .navbar-inner,.navbar-static-top .navbar-inner{-webkit-box-shadow:0 1px 10px rgba(0,0,0,0.1);-moz-box-shadow:0 1px 10px rgba(0,0,0,0.1);box-shadow:0 1px 10px rgba(0,0,0,0.1)}.navbar-fixed-bottom{bottom:0}.navbar-fixed-bottom .navbar-inner{-webkit-box-shadow:0 -1px 10px rgba(0,0,0,0.1);-moz-box-shadow:0 -1px 10px rgba(0,0,0,0.1);box-shadow:0 -1px 10px rgba(0,0,0,0.1)}.navbar .nav{position:relative;left:0;display:block;float:left;margin:0 10px 0 0}.navbar .nav.pull-right{float:right;margin-right:0}.navbar .nav>li{float:left}.navbar .nav>li>a{float:none;padding:10px 15px 10px;color:#777;text-decoration:none;text-shadow:0 1px 0 #fff}.navbar .nav .dropdown-toggle .caret{margin-top:8px}.navbar .nav>li>a:focus,.navbar .nav>li>a:hover{color:#333;text-decoration:none;background-color:transparent}.navbar .nav>.active>a,.navbar .nav>.active>a:hover,.navbar .nav>.active>a:focus{color:#555;text-decoration:none;background-color:#e5e5e5;-webkit-box-shadow:inset 0 3px 8px rgba(0,0,0,0.125);-moz-box-shadow:inset 0 3px 8px rgba(0,0,0,0.125);box-shadow:inset 0 3px 8px rgba(0,0,0,0.125)}.navbar .btn-navbar{display:none;float:right;padding:7px 10px;margin-right:5px;margin-left:5px;color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#ededed;*background-color:#e5e5e5;background-image:-moz-linear-gradient(top,#f2f2f2,#e5e5e5);background-image:-webkit-gradient(linear,0 0,0 100%,from(#f2f2f2),to(#e5e5e5));background-image:-webkit-linear-gradient(top,#f2f2f2,#e5e5e5);background-image:-o-linear-gradient(top,#f2f2f2,#e5e5e5);background-image:linear-gradient(to bottom,#f2f2f2,#e5e5e5);background-repeat:repeat-x;border-color:#e5e5e5 #e5e5e5 #bfbfbf;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff2f2f2',endColorstr='#ffe5e5e5',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.075);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.075);box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.075)}.navbar .btn-navbar:hover,.navbar .btn-navbar:focus,.navbar .btn-navbar:active,.navbar .btn-navbar.active,.navbar .btn-navbar.disabled,.navbar .btn-navbar[disabled]{color:#fff;background-color:#e5e5e5;*background-color:#d9d9d9}.navbar .btn-navbar:active,.navbar .btn-navbar.active{background-color:#ccc \9}.navbar .btn-navbar .icon-bar{display:block;width:18px;height:2px;background-color:#f5f5f5;-webkit-border-radius:1px;-moz-border-radius:1px;border-radius:1px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,0.25);-moz-box-shadow:0 1px 0 rgba(0,0,0,0.25);box-shadow:0 1px 0 rgba(0,0,0,0.25)}.btn-navbar .icon-bar+.icon-bar{margin-top:3px}.navbar .nav>li>.dropdown-menu:before{position:absolute;top:-7px;left:9px;display:inline-block;border-right:7px solid transparent;border-bottom:7px solid #ccc;border-left:7px solid transparent;border-bottom-color:rgba(0,0,0,0.2);content:''}.navbar .nav>li>.dropdown-menu:after{position:absolute;top:-6px;left:10px;display:inline-block;border-right:6px solid transparent;border-bottom:6px solid #fff;border-left:6px solid transparent;content:''}.navbar-fixed-bottom .nav>li>.dropdown-menu:before{top:auto;bottom:-7px;border-top:7px solid #ccc;border-bottom:0;border-top-color:rgba(0,0,0,0.2)}.navbar-fixed-bottom .nav>li>.dropdown-menu:after{top:auto;bottom:-6px;border-top:6px solid #fff;border-bottom:0}.navbar .nav li.dropdown>a:hover .caret,.navbar .nav li.dropdown>a:focus .caret{border-top-color:#333;border-bottom-color:#333}.navbar .nav li.dropdown.open>.dropdown-toggle,.navbar .nav li.dropdown.active>.dropdown-toggle,.navbar .nav li.dropdown.open.active>.dropdown-toggle{color:#555;background-color:#e5e5e5}.navbar .nav li.dropdown>.dropdown-toggle .caret{border-top-color:#777;border-bottom-color:#777}.navbar .nav li.dropdown.open>.dropdown-toggle .caret,.navbar .nav li.dropdown.active>.dropdown-toggle .caret,.navbar .nav li.dropdown.open.active>.dropdown-toggle .caret{border-top-color:#555;border-bottom-color:#555}.navbar .pull-right>li>.dropdown-menu,.navbar .nav>li>.dropdown-menu.pull-right{right:0;left:auto}.navbar .pull-right>li>.dropdown-menu:before,.navbar .nav>li>.dropdown-menu.pull-right:before{right:12px;left:auto}.navbar .pull-right>li>.dropdown-menu:after,.navbar .nav>li>.dropdown-menu.pull-right:after{right:13px;left:auto}.navbar .pull-right>li>.dropdown-menu .dropdown-menu,.navbar .nav>li>.dropdown-menu.pull-right .dropdown-menu{right:100%;left:auto;margin-right:-1px;margin-left:0;-webkit-border-radius:6px 0 6px 6px;-moz-border-radius:6px 0 6px 6px;border-radius:6px 0 6px 6px}.navbar-inverse .navbar-inner{background-color:#1b1b1b;background-image:-moz-linear-gradient(top,#222,#111);background-image:-webkit-gradient(linear,0 0,0 100%,from(#222),to(#111));background-image:-webkit-linear-gradient(top,#222,#111);background-image:-o-linear-gradient(top,#222,#111);background-image:linear-gradient(to bottom,#222,#111);background-repeat:repeat-x;border-color:#252525;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff222222',endColorstr='#ff111111',GradientType=0)}.navbar-inverse .brand,.navbar-inverse .nav>li>a{color:#999;text-shadow:0 -1px 0 rgba(0,0,0,0.25)}.navbar-inverse .brand:hover,.navbar-inverse .nav>li>a:hover,.navbar-inverse .brand:focus,.navbar-inverse .nav>li>a:focus{color:#fff}.navbar-inverse .brand{color:#999}.navbar-inverse .navbar-text{color:#999}.navbar-inverse .nav>li>a:focus,.navbar-inverse .nav>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .nav .active>a,.navbar-inverse .nav .active>a:hover,.navbar-inverse .nav .active>a:focus{color:#fff;background-color:#111}.navbar-inverse .navbar-link{color:#999}.navbar-inverse .navbar-link:hover,.navbar-inverse .navbar-link:focus{color:#fff}.navbar-inverse .divider-vertical{border-right-color:#222;border-left-color:#111}.navbar-inverse .nav li.dropdown.open>.dropdown-toggle,.navbar-inverse .nav li.dropdown.active>.dropdown-toggle,.navbar-inverse .nav li.dropdown.open.active>.dropdown-toggle{color:#fff;background-color:#111}.navbar-inverse .nav li.dropdown>a:hover .caret,.navbar-inverse .nav li.dropdown>a:focus .caret{border-top-color:#fff;border-bottom-color:#fff}.navbar-inverse .nav li.dropdown>.dropdown-toggle .caret{border-top-color:#999;border-bottom-color:#999}.navbar-inverse .nav li.dropdown.open>.dropdown-toggle .caret,.navbar-inverse .nav li.dropdown.active>.dropdown-toggle .caret,.navbar-inverse .nav li.dropdown.open.active>.dropdown-toggle .caret{border-top-color:#fff;border-bottom-color:#fff}.navbar-inverse .navbar-search .search-query{color:#fff;background-color:#515151;border-color:#111;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1),0 1px 0 rgba(255,255,255,0.15);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1),0 1px 0 rgba(255,255,255,0.15);box-shadow:inset 0 1px 2px rgba(0,0,0,0.1),0 1px 0 rgba(255,255,255,0.15);-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none}.navbar-inverse .navbar-search .search-query:-moz-placeholder{color:#ccc}.navbar-inverse .navbar-search .search-query:-ms-input-placeholder{color:#ccc}.navbar-inverse .navbar-search .search-query::-webkit-input-placeholder{color:#ccc}.navbar-inverse .navbar-search .search-query:focus,.navbar-inverse .navbar-search .search-query.focused{padding:5px 15px;color:#333;text-shadow:0 1px 0 #fff;background-color:#fff;border:0;outline:0;-webkit-box-shadow:0 0 3px rgba(0,0,0,0.15);-moz-box-shadow:0 0 3px rgba(0,0,0,0.15);box-shadow:0 0 3px rgba(0,0,0,0.15)}.navbar-inverse .btn-navbar{color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#0e0e0e;*background-color:#040404;background-image:-moz-linear-gradient(top,#151515,#040404);background-image:-webkit-gradient(linear,0 0,0 100%,from(#151515),to(#040404));background-image:-webkit-linear-gradient(top,#151515,#040404);background-image:-o-linear-gradient(top,#151515,#040404);background-image:linear-gradient(to bottom,#151515,#040404);background-repeat:repeat-x;border-color:#040404 #040404 #000;border-color:rgba(0,0,0,0.1) rgba(0,0,0,0.1) rgba(0,0,0,0.25);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff151515',endColorstr='#ff040404',GradientType=0);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.navbar-inverse .btn-navbar:hover,.navbar-inverse .btn-navbar:focus,.navbar-inverse .btn-navbar:active,.navbar-inverse .btn-navbar.active,.navbar-inverse .btn-navbar.disabled,.navbar-inverse .btn-navbar[disabled]{color:#fff;background-color:#040404;*background-color:#000}.navbar-inverse .btn-navbar:active,.navbar-inverse .btn-navbar.active{background-color:#000 \9}.breadcrumb{padding:8px 15px;margin:0 0 20px;list-style:none;background-color:#f5f5f5;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.breadcrumb>li{display:inline-block;*display:inline;text-shadow:0 1px 0 #fff;*zoom:1}.breadcrumb>li>.divider{padding:0 5px;color:#ccc}.breadcrumb>.active{color:#999}.pagination{margin:20px 0}.pagination ul{display:inline-block;*display:inline;margin-bottom:0;margin-left:0;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;*zoom:1;-webkit-box-shadow:0 1px 2px rgba(0,0,0,0.05);-moz-box-shadow:0 1px 2px rgba(0,0,0,0.05);box-shadow:0 1px 2px rgba(0,0,0,0.05)}.pagination ul>li{display:inline}.pagination ul>li>a,.pagination ul>li>span{float:left;padding:4px 12px;line-height:20px;text-decoration:none;background-color:#fff;border:1px solid #ddd;border-left-width:0}.pagination ul>li>a:hover,.pagination ul>li>a:focus,.pagination ul>.active>a,.pagination ul>.active>span{background-color:#f5f5f5}.pagination ul>.active>a,.pagination ul>.active>span{color:#999;cursor:default}.pagination ul>.disabled>span,.pagination ul>.disabled>a,.pagination ul>.disabled>a:hover,.pagination ul>.disabled>a:focus{color:#999;cursor:default;background-color:transparent}.pagination ul>li:first-child>a,.pagination ul>li:first-child>span{border-left-width:1px;-webkit-border-bottom-left-radius:4px;border-bottom-left-radius:4px;-webkit-border-top-left-radius:4px;border-top-left-radius:4px;-moz-border-radius-bottomleft:4px;-moz-border-radius-topleft:4px}.pagination ul>li:last-child>a,.pagination ul>li:last-child>span{-webkit-border-top-right-radius:4px;border-top-right-radius:4px;-webkit-border-bottom-right-radius:4px;border-bottom-right-radius:4px;-moz-border-radius-topright:4px;-moz-border-radius-bottomright:4px}.pagination-centered{text-align:center}.pagination-right{text-align:right}.pagination-large ul>li>a,.pagination-large ul>li>span{padding:11px 19px;font-size:17.5px}.pagination-large ul>li:first-child>a,.pagination-large ul>li:first-child>span{-webkit-border-bottom-left-radius:6px;border-bottom-left-radius:6px;-webkit-border-top-left-radius:6px;border-top-left-radius:6px;-moz-border-radius-bottomleft:6px;-moz-border-radius-topleft:6px}.pagination-large ul>li:last-child>a,.pagination-large ul>li:last-child>span{-webkit-border-top-right-radius:6px;border-top-right-radius:6px;-webkit-border-bottom-right-radius:6px;border-bottom-right-radius:6px;-moz-border-radius-topright:6px;-moz-border-radius-bottomright:6px}.pagination-mini ul>li:first-child>a,.pagination-small ul>li:first-child>a,.pagination-mini ul>li:first-child>span,.pagination-small ul>li:first-child>span{-webkit-border-bottom-left-radius:3px;border-bottom-left-radius:3px;-webkit-border-top-left-radius:3px;border-top-left-radius:3px;-moz-border-radius-bottomleft:3px;-moz-border-radius-topleft:3px}.pagination-mini ul>li:last-child>a,.pagination-small ul>li:last-child>a,.pagination-mini ul>li:last-child>span,.pagination-small ul>li:last-child>span{-webkit-border-top-right-radius:3px;border-top-right-radius:3px;-webkit-border-bottom-right-radius:3px;border-bottom-right-radius:3px;-moz-border-radius-topright:3px;-moz-border-radius-bottomright:3px}.pagination-small ul>li>a,.pagination-small ul>li>span{padding:2px 10px;font-size:11.9px}.pagination-mini ul>li>a,.pagination-mini ul>li>span{padding:0 6px;font-size:10.5px}.pager{margin:20px 0;text-align:center;list-style:none;*zoom:1}.pager:before,.pager:after{display:table;line-height:0;content:""}.pager:after{clear:both}.pager li{display:inline}.pager li>a,.pager li>span{display:inline-block;padding:5px 14px;background-color:#fff;border:1px solid #ddd;-webkit-border-radius:15px;-moz-border-radius:15px;border-radius:15px}.pager li>a:hover,.pager li>a:focus{text-decoration:none;background-color:#f5f5f5}.pager .next>a,.pager .next>span{float:right}.pager .previous>a,.pager .previous>span{float:left}.pager .disabled>a,.pager .disabled>a:hover,.pager .disabled>a:focus,.pager .disabled>span{color:#999;cursor:default;background-color:#fff}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{opacity:0}.modal-backdrop,.modal-backdrop.fade.in{opacity:.8;filter:alpha(opacity=80)}.modal{position:fixed;top:10%;left:50%;z-index:1050;width:560px;margin-left:-280px;background-color:#fff;border:1px solid #999;border:1px solid rgba(0,0,0,0.3);*border:1px solid #999;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;outline:0;-webkit-box-shadow:0 3px 7px rgba(0,0,0,0.3);-moz-box-shadow:0 3px 7px rgba(0,0,0,0.3);box-shadow:0 3px 7px rgba(0,0,0,0.3);-webkit-background-clip:padding-box;-moz-background-clip:padding-box;background-clip:padding-box}.modal.fade{top:-25%;-webkit-transition:opacity .3s linear,top .3s ease-out;-moz-transition:opacity .3s linear,top .3s ease-out;-o-transition:opacity .3s linear,top .3s ease-out;transition:opacity .3s linear,top .3s ease-out}.modal.fade.in{top:10%}.modal-header{padding:9px 15px;border-bottom:1px solid #eee}.modal-header .close{margin-top:2px}.modal-header h3{margin:0;line-height:30px}.modal-body{position:relative;max-height:400px;padding:15px;overflow-y:auto}.modal-form{margin-bottom:0}.modal-footer{padding:14px 15px 15px;margin-bottom:0;text-align:right;background-color:#f5f5f5;border-top:1px solid #ddd;-webkit-border-radius:0 0 6px 6px;-moz-border-radius:0 0 6px 6px;border-radius:0 0 6px 6px;*zoom:1;-webkit-box-shadow:inset 0 1px 0 #fff;-moz-box-shadow:inset 0 1px 0 #fff;box-shadow:inset 0 1px 0 #fff}.modal-footer:before,.modal-footer:after{display:table;line-height:0;content:""}.modal-footer:after{clear:both}.modal-footer .btn+.btn{margin-bottom:0;margin-left:5px}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.tooltip{position:absolute;z-index:1030;display:block;font-size:11px;line-height:1.4;opacity:0;filter:alpha(opacity=0);visibility:visible}.tooltip.in{opacity:.8;filter:alpha(opacity=80)}.tooltip.top{padding:5px 0;margin-top:-3px}.tooltip.right{padding:0 5px;margin-left:3px}.tooltip.bottom{padding:5px 0;margin-top:3px}.tooltip.left{padding:0 5px;margin-left:-3px}.tooltip-inner{max-width:200px;padding:8px;color:#fff;text-align:center;text-decoration:none;background-color:#000;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.tooltip-arrow{position:absolute;width:0;height:0;border-color:transparent;border-style:solid}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-top-color:#000;border-width:5px 5px 0}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-right-color:#000;border-width:5px 5px 5px 0}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-left-color:#000;border-width:5px 0 5px 5px}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-bottom-color:#000;border-width:0 5px 5px}.popover{position:absolute;top:0;left:0;z-index:1010;display:none;max-width:276px;padding:1px;text-align:left;white-space:normal;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.2);-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;-webkit-box-shadow:0 5px 10px rgba(0,0,0,0.2);-moz-box-shadow:0 5px 10px rgba(0,0,0,0.2);box-shadow:0 5px 10px rgba(0,0,0,0.2);-webkit-background-clip:padding-box;-moz-background-clip:padding;background-clip:padding-box}.popover.top{margin-top:-10px}.popover.right{margin-left:10px}.popover.bottom{margin-top:10px}.popover.left{margin-left:-10px}.popover-title{padding:8px 14px;margin:0;font-size:14px;font-weight:normal;line-height:18px;background-color:#f7f7f7;border-bottom:1px solid #ebebeb;-webkit-border-radius:5px 5px 0 0;-moz-border-radius:5px 5px 0 0;border-radius:5px 5px 0 0}.popover-title:empty{display:none}.popover-content{padding:9px 14px}.popover .arrow,.popover .arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.popover .arrow{border-width:11px}.popover .arrow:after{border-width:10px;content:""}.popover.top .arrow{bottom:-11px;left:50%;margin-left:-11px;border-top-color:#999;border-top-color:rgba(0,0,0,0.25);border-bottom-width:0}.popover.top .arrow:after{bottom:1px;margin-left:-10px;border-top-color:#fff;border-bottom-width:0}.popover.right .arrow{top:50%;left:-11px;margin-top:-11px;border-right-color:#999;border-right-color:rgba(0,0,0,0.25);border-left-width:0}.popover.right .arrow:after{bottom:-10px;left:1px;border-right-color:#fff;border-left-width:0}.popover.bottom .arrow{top:-11px;left:50%;margin-left:-11px;border-bottom-color:#999;border-bottom-color:rgba(0,0,0,0.25);border-top-width:0}.popover.bottom .arrow:after{top:1px;margin-left:-10px;border-bottom-color:#fff;border-top-width:0}.popover.left .arrow{top:50%;right:-11px;margin-top:-11px;border-left-color:#999;border-left-color:rgba(0,0,0,0.25);border-right-width:0}.popover.left .arrow:after{right:1px;bottom:-10px;border-left-color:#fff;border-right-width:0}.thumbnails{margin-left:-20px;list-style:none;*zoom:1}.thumbnails:before,.thumbnails:after{display:table;line-height:0;content:""}.thumbnails:after{clear:both}.row-fluid .thumbnails{margin-left:0}.thumbnails>li{float:left;margin-bottom:20px;margin-left:20px}.thumbnail{display:block;padding:4px;line-height:20px;border:1px solid #ddd;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;-webkit-box-shadow:0 1px 3px rgba(0,0,0,0.055);-moz-box-shadow:0 1px 3px rgba(0,0,0,0.055);box-shadow:0 1px 3px rgba(0,0,0,0.055);-webkit-transition:all .2s ease-in-out;-moz-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out}a.thumbnail:hover,a.thumbnail:focus{border-color:#08c;-webkit-box-shadow:0 1px 4px rgba(0,105,214,0.25);-moz-box-shadow:0 1px 4px rgba(0,105,214,0.25);box-shadow:0 1px 4px rgba(0,105,214,0.25)}.thumbnail>img{display:block;max-width:100%;margin-right:auto;margin-left:auto}.thumbnail .caption{padding:9px;color:#555}.media,.media-body{overflow:hidden;*overflow:visible;zoom:1}.media,.media .media{margin-top:15px}.media:first-child{margin-top:0}.media-object{display:block}.media-heading{margin:0 0 5px}.media>.pull-left{margin-right:10px}.media>.pull-right{margin-left:10px}.media-list{margin-left:0;list-style:none}.label,.badge{display:inline-block;padding:2px 4px;font-size:11.844px;font-weight:bold;line-height:14px;color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,0.25);white-space:nowrap;vertical-align:baseline;background-color:#999}.label{-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.badge{padding-right:9px;padding-left:9px;-webkit-border-radius:9px;-moz-border-radius:9px;border-radius:9px}.label:empty,.badge:empty{display:none}a.label:hover,a.label:focus,a.badge:hover,a.badge:focus{color:#fff;text-decoration:none;cursor:pointer}.label-important,.badge-important{background-color:#b94a48}.label-important[href],.badge-important[href]{background-color:#953b39}.label-warning,.badge-warning{background-color:#f89406}.label-warning[href],.badge-warning[href]{background-color:#c67605}.label-success,.badge-success{background-color:#468847}.label-success[href],.badge-success[href]{background-color:#356635}.label-info,.badge-info{background-color:#3a87ad}.label-info[href],.badge-info[href]{background-color:#2d6987}.label-inverse,.badge-inverse{background-color:#333}.label-inverse[href],.badge-inverse[href]{background-color:#1a1a1a}.btn .label,.btn .badge{position:relative;top:-1px}.btn-mini .label,.btn-mini .badge{top:0}@-webkit-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-moz-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-ms-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-o-keyframes progress-bar-stripes{from{background-position:0 0}to{background-position:40px 0}}@keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}.progress{height:20px;margin-bottom:20px;overflow:hidden;background-color:#f7f7f7;background-image:-moz-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:-webkit-gradient(linear,0 0,0 100%,from(#f5f5f5),to(#f9f9f9));background-image:-webkit-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:-o-linear-gradient(top,#f5f5f5,#f9f9f9);background-image:linear-gradient(to bottom,#f5f5f5,#f9f9f9);background-repeat:repeat-x;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff5f5f5',endColorstr='#fff9f9f9',GradientType=0);-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);box-shadow:inset 0 1px 2px rgba(0,0,0,0.1)}.progress .bar{float:left;width:0;height:100%;font-size:12px;color:#fff;text-align:center;text-shadow:0 -1px 0 rgba(0,0,0,0.25);background-color:#0e90d2;background-image:-moz-linear-gradient(top,#149bdf,#0480be);background-image:-webkit-gradient(linear,0 0,0 100%,from(#149bdf),to(#0480be));background-image:-webkit-linear-gradient(top,#149bdf,#0480be);background-image:-o-linear-gradient(top,#149bdf,#0480be);background-image:linear-gradient(to bottom,#149bdf,#0480be);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff149bdf',endColorstr='#ff0480be',GradientType=0);-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-moz-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;-webkit-transition:width .6s ease;-moz-transition:width .6s ease;-o-transition:width .6s ease;transition:width .6s ease}.progress .bar+.bar{-webkit-box-shadow:inset 1px 0 0 rgba(0,0,0,0.15),inset 0 -1px 0 rgba(0,0,0,0.15);-moz-box-shadow:inset 1px 0 0 rgba(0,0,0,0.15),inset 0 -1px 0 rgba(0,0,0,0.15);box-shadow:inset 1px 0 0 rgba(0,0,0,0.15),inset 0 -1px 0 rgba(0,0,0,0.15)}.progress-striped .bar{background-color:#149bdf;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);-webkit-background-size:40px 40px;-moz-background-size:40px 40px;-o-background-size:40px 40px;background-size:40px 40px}.progress.active .bar{-webkit-animation:progress-bar-stripes 2s linear infinite;-moz-animation:progress-bar-stripes 2s linear infinite;-ms-animation:progress-bar-stripes 2s linear infinite;-o-animation:progress-bar-stripes 2s linear infinite;animation:progress-bar-stripes 2s linear infinite}.progress-danger .bar,.progress .bar-danger{background-color:#dd514c;background-image:-moz-linear-gradient(top,#ee5f5b,#c43c35);background-image:-webkit-gradient(linear,0 0,0 100%,from(#ee5f5b),to(#c43c35));background-image:-webkit-linear-gradient(top,#ee5f5b,#c43c35);background-image:-o-linear-gradient(top,#ee5f5b,#c43c35);background-image:linear-gradient(to bottom,#ee5f5b,#c43c35);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffee5f5b',endColorstr='#ffc43c35',GradientType=0)}.progress-danger.progress-striped .bar,.progress-striped .bar-danger{background-color:#ee5f5b;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.progress-success .bar,.progress .bar-success{background-color:#5eb95e;background-image:-moz-linear-gradient(top,#62c462,#57a957);background-image:-webkit-gradient(linear,0 0,0 100%,from(#62c462),to(#57a957));background-image:-webkit-linear-gradient(top,#62c462,#57a957);background-image:-o-linear-gradient(top,#62c462,#57a957);background-image:linear-gradient(to bottom,#62c462,#57a957);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff62c462',endColorstr='#ff57a957',GradientType=0)}.progress-success.progress-striped .bar,.progress-striped .bar-success{background-color:#62c462;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.progress-info .bar,.progress .bar-info{background-color:#4bb1cf;background-image:-moz-linear-gradient(top,#5bc0de,#339bb9);background-image:-webkit-gradient(linear,0 0,0 100%,from(#5bc0de),to(#339bb9));background-image:-webkit-linear-gradient(top,#5bc0de,#339bb9);background-image:-o-linear-gradient(top,#5bc0de,#339bb9);background-image:linear-gradient(to bottom,#5bc0de,#339bb9);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff5bc0de',endColorstr='#ff339bb9',GradientType=0)}.progress-info.progress-striped .bar,.progress-striped .bar-info{background-color:#5bc0de;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.progress-warning .bar,.progress .bar-warning{background-color:#faa732;background-image:-moz-linear-gradient(top,#fbb450,#f89406);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fbb450),to(#f89406));background-image:-webkit-linear-gradient(top,#fbb450,#f89406);background-image:-o-linear-gradient(top,#fbb450,#f89406);background-image:linear-gradient(to bottom,#fbb450,#f89406);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fffbb450',endColorstr='#fff89406',GradientType=0)}.progress-warning.progress-striped .bar,.progress-striped .bar-warning{background-color:#fbb450;background-image:-webkit-gradient(linear,0 100%,100% 0,color-stop(0.25,rgba(255,255,255,0.15)),color-stop(0.25,transparent),color-stop(0.5,transparent),color-stop(0.5,rgba(255,255,255,0.15)),color-stop(0.75,rgba(255,255,255,0.15)),color-stop(0.75,transparent),to(transparent));background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-moz-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,0.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,0.15) 50%,rgba(255,255,255,0.15) 75%,transparent 75%,transparent)}.accordion{margin-bottom:20px}.accordion-group{margin-bottom:2px;border:1px solid #e5e5e5;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.accordion-heading{border-bottom:0}.accordion-heading .accordion-toggle{display:block;padding:8px 15px}.accordion-toggle{cursor:pointer}.accordion-inner{padding:9px 15px;border-top:1px solid #e5e5e5}.carousel{position:relative;margin-bottom:20px;line-height:1}.carousel-inner{position:relative;width:100%;overflow:hidden}.carousel-inner>.item{position:relative;display:none;-webkit-transition:.6s ease-in-out left;-moz-transition:.6s ease-in-out left;-o-transition:.6s ease-in-out left;transition:.6s ease-in-out left}.carousel-inner>.item>img,.carousel-inner>.item>a>img{display:block;line-height:1}.carousel-inner>.active,.carousel-inner>.next,.carousel-inner>.prev{display:block}.carousel-inner>.active{left:0}.carousel-inner>.next,.carousel-inner>.prev{position:absolute;top:0;width:100%}.carousel-inner>.next{left:100%}.carousel-inner>.prev{left:-100%}.carousel-inner>.next.left,.carousel-inner>.prev.right{left:0}.carousel-inner>.active.left{left:-100%}.carousel-inner>.active.right{left:100%}.carousel-control{position:absolute;top:40%;left:15px;width:40px;height:40px;margin-top:-20px;font-size:60px;font-weight:100;line-height:30px;color:#fff;text-align:center;background:#222;border:3px solid #fff;-webkit-border-radius:23px;-moz-border-radius:23px;border-radius:23px;opacity:.5;filter:alpha(opacity=50)}.carousel-control.right{right:15px;left:auto}.carousel-control:hover,.carousel-control:focus{color:#fff;text-decoration:none;opacity:.9;filter:alpha(opacity=90)}.carousel-indicators{position:absolute;top:15px;right:15px;z-index:5;margin:0;list-style:none}.carousel-indicators li{display:block;float:left;width:10px;height:10px;margin-left:5px;text-indent:-999px;background-color:#ccc;background-color:rgba(255,255,255,0.25);border-radius:5px}.carousel-indicators .active{background-color:#fff}.carousel-caption{position:absolute;right:0;bottom:0;left:0;padding:15px;background:#333;background:rgba(0,0,0,0.75)}.carousel-caption h4,.carousel-caption p{line-height:20px;color:#fff}.carousel-caption h4{margin:0 0 5px}.carousel-caption p{margin-bottom:0}.hero-unit{padding:60px;margin-bottom:30px;font-size:18px;font-weight:200;line-height:30px;color:inherit;background-color:#eee;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.hero-unit h1{margin-bottom:0;font-size:60px;line-height:1;letter-spacing:-1px;color:inherit}.hero-unit li{line-height:30px}.pull-right{float:right}.pull-left{float:left}.hide{display:none}.show{display:block}.invisible{visibility:hidden}.affix{position:fixed}
-/*!
- * Bootstrap Responsive v2.3.1
- *
- * Copyright 2012 Twitter, Inc
- * Licensed under the Apache License v2.0
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Designed and built with all the love in the world @twitter by @mdo and @fat.
- */.clearfix{*zoom:1}.clearfix:before,.clearfix:after{display:table;line-height:0;content:""}.clearfix:after{clear:both}.hide-text{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.input-block-level{display:block;width:100%;min-height:30px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}@-ms-viewport{width:device-width}.hidden{display:none;visibility:hidden}.visible-phone{display:none!important}.visible-tablet{display:none!important}.hidden-desktop{display:none!important}.visible-desktop{display:inherit!important}@media(min-width:768px) and (max-width:979px){.hidden-desktop{display:inherit!important}.visible-desktop{display:none!important}.visible-tablet{display:inherit!important}.hidden-tablet{display:none!important}}@media(max-width:767px){.hidden-desktop{display:inherit!important}.visible-desktop{display:none!important}.visible-phone{display:inherit!important}.hidden-phone{display:none!important}}.visible-print{display:none!important}@media print{.visible-print{display:inherit!important}.hidden-print{display:none!important}}@media(min-width:1200px){.row{margin-left:-30px;*zoom:1}.row:before,.row:after{display:table;line-height:0;content:""}.row:after{clear:both}[class*="span"]{float:left;min-height:1px;margin-left:30px}.container,.navbar-static-top .container,.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:1170px}.span12{width:1170px}.span11{width:1070px}.span10{width:970px}.span9{width:870px}.span8{width:770px}.span7{width:670px}.span6{width:570px}.span5{width:470px}.span4{width:370px}.span3{width:270px}.span2{width:170px}.span1{width:70px}.offset12{margin-left:1230px}.offset11{margin-left:1130px}.offset10{margin-left:1030px}.offset9{margin-left:930px}.offset8{margin-left:830px}.offset7{margin-left:730px}.offset6{margin-left:630px}.offset5{margin-left:530px}.offset4{margin-left:430px}.offset3{margin-left:330px}.offset2{margin-left:230px}.offset1{margin-left:130px}.row-fluid{width:100%;*zoom:1}.row-fluid:before,.row-fluid:after{display:table;line-height:0;content:""}.row-fluid:after{clear:both}.row-fluid [class*="span"]{display:block;float:left;width:100%;min-height:30px;margin-left:2.564102564102564%;*margin-left:2.5109110747408616%;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.row-fluid [class*="span"]:first-child{margin-left:0}.row-fluid .controls-row [class*="span"]+[class*="span"]{margin-left:2.564102564102564%}.row-fluid .span12{width:100%;*width:99.94680851063829%}.row-fluid .span11{width:91.45299145299145%;*width:91.39979996362975%}.row-fluid .span10{width:82.90598290598291%;*width:82.8527914166212%}.row-fluid .span9{width:74.35897435897436%;*width:74.30578286961266%}.row-fluid .span8{width:65.81196581196582%;*width:65.75877432260411%}.row-fluid .span7{width:57.26495726495726%;*width:57.21176577559556%}.row-fluid .span6{width:48.717948717948715%;*width:48.664757228587014%}.row-fluid .span5{width:40.17094017094017%;*width:40.11774868157847%}.row-fluid .span4{width:31.623931623931625%;*width:31.570740134569924%}.row-fluid .span3{width:23.076923076923077%;*width:23.023731587561375%}.row-fluid .span2{width:14.52991452991453%;*width:14.476723040552828%}.row-fluid .span1{width:5.982905982905983%;*width:5.929714493544281%}.row-fluid .offset12{margin-left:105.12820512820512%;*margin-left:105.02182214948171%}.row-fluid .offset12:first-child{margin-left:102.56410256410257%;*margin-left:102.45771958537915%}.row-fluid .offset11{margin-left:96.58119658119658%;*margin-left:96.47481360247316%}.row-fluid .offset11:first-child{margin-left:94.01709401709402%;*margin-left:93.91071103837061%}.row-fluid .offset10{margin-left:88.03418803418803%;*margin-left:87.92780505546462%}.row-fluid .offset10:first-child{margin-left:85.47008547008548%;*margin-left:85.36370249136206%}.row-fluid .offset9{margin-left:79.48717948717949%;*margin-left:79.38079650845607%}.row-fluid .offset9:first-child{margin-left:76.92307692307693%;*margin-left:76.81669394435352%}.row-fluid .offset8{margin-left:70.94017094017094%;*margin-left:70.83378796144753%}.row-fluid .offset8:first-child{margin-left:68.37606837606839%;*margin-left:68.26968539734497%}.row-fluid .offset7{margin-left:62.393162393162385%;*margin-left:62.28677941443899%}.row-fluid .offset7:first-child{margin-left:59.82905982905982%;*margin-left:59.72267685033642%}.row-fluid .offset6{margin-left:53.84615384615384%;*margin-left:53.739770867430444%}.row-fluid .offset6:first-child{margin-left:51.28205128205128%;*margin-left:51.175668303327875%}.row-fluid .offset5{margin-left:45.299145299145295%;*margin-left:45.1927623204219%}.row-fluid .offset5:first-child{margin-left:42.73504273504273%;*margin-left:42.62865975631933%}.row-fluid .offset4{margin-left:36.75213675213675%;*margin-left:36.645753773413354%}.row-fluid .offset4:first-child{margin-left:34.18803418803419%;*margin-left:34.081651209310785%}.row-fluid .offset3{margin-left:28.205128205128204%;*margin-left:28.0987452264048%}.row-fluid .offset3:first-child{margin-left:25.641025641025642%;*margin-left:25.53464266230224%}.row-fluid .offset2{margin-left:19.65811965811966%;*margin-left:19.551736679396257%}.row-fluid .offset2:first-child{margin-left:17.094017094017094%;*margin-left:16.98763411529369%}.row-fluid .offset1{margin-left:11.11111111111111%;*margin-left:11.004728132387708%}.row-fluid .offset1:first-child{margin-left:8.547008547008547%;*margin-left:8.440625568285142%}input,textarea,.uneditable-input{margin-left:0}.controls-row [class*="span"]+[class*="span"]{margin-left:30px}input.span12,textarea.span12,.uneditable-input.span12{width:1156px}input.span11,textarea.span11,.uneditable-input.span11{width:1056px}input.span10,textarea.span10,.uneditable-input.span10{width:956px}input.span9,textarea.span9,.uneditable-input.span9{width:856px}input.span8,textarea.span8,.uneditable-input.span8{width:756px}input.span7,textarea.span7,.uneditable-input.span7{width:656px}input.span6,textarea.span6,.uneditable-input.span6{width:556px}input.span5,textarea.span5,.uneditable-input.span5{width:456px}input.span4,textarea.span4,.uneditable-input.span4{width:356px}input.span3,textarea.span3,.uneditable-input.span3{width:256px}input.span2,textarea.span2,.uneditable-input.span2{width:156px}input.span1,textarea.span1,.uneditable-input.span1{width:56px}.thumbnails{margin-left:-30px}.thumbnails>li{margin-left:30px}.row-fluid .thumbnails{margin-left:0}}@media(min-width:768px) and (max-width:979px){.row{margin-left:-20px;*zoom:1}.row:before,.row:after{display:table;line-height:0;content:""}.row:after{clear:both}[class*="span"]{float:left;min-height:1px;margin-left:20px}.container,.navbar-static-top .container,.navbar-fixed-top .container,.navbar-fixed-bottom .container{width:724px}.span12{width:724px}.span11{width:662px}.span10{width:600px}.span9{width:538px}.span8{width:476px}.span7{width:414px}.span6{width:352px}.span5{width:290px}.span4{width:228px}.span3{width:166px}.span2{width:104px}.span1{width:42px}.offset12{margin-left:764px}.offset11{margin-left:702px}.offset10{margin-left:640px}.offset9{margin-left:578px}.offset8{margin-left:516px}.offset7{margin-left:454px}.offset6{margin-left:392px}.offset5{margin-left:330px}.offset4{margin-left:268px}.offset3{margin-left:206px}.offset2{margin-left:144px}.offset1{margin-left:82px}.row-fluid{width:100%;*zoom:1}.row-fluid:before,.row-fluid:after{display:table;line-height:0;content:""}.row-fluid:after{clear:both}.row-fluid [class*="span"]{display:block;float:left;width:100%;min-height:30px;margin-left:2.7624309392265194%;*margin-left:2.709239449864817%;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.row-fluid [class*="span"]:first-child{margin-left:0}.row-fluid .controls-row [class*="span"]+[class*="span"]{margin-left:2.7624309392265194%}.row-fluid .span12{width:100%;*width:99.94680851063829%}.row-fluid .span11{width:91.43646408839778%;*width:91.38327259903608%}.row-fluid .span10{width:82.87292817679558%;*width:82.81973668743387%}.row-fluid .span9{width:74.30939226519337%;*width:74.25620077583166%}.row-fluid .span8{width:65.74585635359117%;*width:65.69266486422946%}.row-fluid .span7{width:57.18232044198895%;*width:57.12912895262725%}.row-fluid .span6{width:48.61878453038674%;*width:48.56559304102504%}.row-fluid .span5{width:40.05524861878453%;*width:40.00205712942283%}.row-fluid .span4{width:31.491712707182323%;*width:31.43852121782062%}.row-fluid .span3{width:22.92817679558011%;*width:22.87498530621841%}.row-fluid .span2{width:14.3646408839779%;*width:14.311449394616199%}.row-fluid .span1{width:5.801104972375691%;*width:5.747913483013988%}.row-fluid .offset12{margin-left:105.52486187845304%;*margin-left:105.41847889972962%}.row-fluid .offset12:first-child{margin-left:102.76243093922652%;*margin-left:102.6560479605031%}.row-fluid .offset11{margin-left:96.96132596685082%;*margin-left:96.8549429881274%}.row-fluid .offset11:first-child{margin-left:94.1988950276243%;*margin-left:94.09251204890089%}.row-fluid .offset10{margin-left:88.39779005524862%;*margin-left:88.2914070765252%}.row-fluid .offset10:first-child{margin-left:85.6353591160221%;*margin-left:85.52897613729868%}.row-fluid .offset9{margin-left:79.8342541436464%;*margin-left:79.72787116492299%}.row-fluid .offset9:first-child{margin-left:77.07182320441989%;*margin-left:76.96544022569647%}.row-fluid .offset8{margin-left:71.2707182320442%;*margin-left:71.16433525332079%}.row-fluid .offset8:first-child{margin-left:68.50828729281768%;*margin-left:68.40190431409427%}.row-fluid .offset7{margin-left:62.70718232044199%;*margin-left:62.600799341718584%}.row-fluid .offset7:first-child{margin-left:59.94475138121547%;*margin-left:59.838368402492065%}.row-fluid .offset6{margin-left:54.14364640883978%;*margin-left:54.037263430116376%}.row-fluid .offset6:first-child{margin-left:51.38121546961326%;*margin-left:51.27483249088986%}.row-fluid .offset5{margin-left:45.58011049723757%;*margin-left:45.47372751851417%}.row-fluid .offset5:first-child{margin-left:42.81767955801105%;*margin-left:42.71129657928765%}.row-fluid .offset4{margin-left:37.01657458563536%;*margin-left:36.91019160691196%}.row-fluid .offset4:first-child{margin-left:34.25414364640884%;*margin-left:34.14776066768544%}.row-fluid .offset3{margin-left:28.45303867403315%;*margin-left:28.346655695309746%}.row-fluid .offset3:first-child{margin-left:25.69060773480663%;*margin-left:25.584224756083227%}.row-fluid .offset2{margin-left:19.88950276243094%;*margin-left:19.783119783707537%}.row-fluid .offset2:first-child{margin-left:17.12707182320442%;*margin-left:17.02068884448102%}.row-fluid .offset1{margin-left:11.32596685082873%;*margin-left:11.219583872105325%}.row-fluid .offset1:first-child{margin-left:8.56353591160221%;*margin-left:8.457152932878806%}input,textarea,.uneditable-input{margin-left:0}.controls-row [class*="span"]+[class*="span"]{margin-left:20px}input.span12,textarea.span12,.uneditable-input.span12{width:710px}input.span11,textarea.span11,.uneditable-input.span11{width:648px}input.span10,textarea.span10,.uneditable-input.span10{width:586px}input.span9,textarea.span9,.uneditable-input.span9{width:524px}input.span8,textarea.span8,.uneditable-input.span8{width:462px}input.span7,textarea.span7,.uneditable-input.span7{width:400px}input.span6,textarea.span6,.uneditable-input.span6{width:338px}input.span5,textarea.span5,.uneditable-input.span5{width:276px}input.span4,textarea.span4,.uneditable-input.span4{width:214px}input.span3,textarea.span3,.uneditable-input.span3{width:152px}input.span2,textarea.span2,.uneditable-input.span2{width:90px}input.span1,textarea.span1,.uneditable-input.span1{width:28px}}@media(max-width:767px){body{padding-right:20px;padding-left:20px}.navbar-fixed-top,.navbar-fixed-bottom,.navbar-static-top{margin-right:-20px;margin-left:-20px}.container-fluid{padding:0}.dl-horizontal dt{float:none;width:auto;clear:none;text-align:left}.dl-horizontal dd{margin-left:0}.container{width:auto}.row-fluid{width:100%}.row,.thumbnails{margin-left:0}.thumbnails>li{float:none;margin-left:0}[class*="span"],.uneditable-input[class*="span"],.row-fluid [class*="span"]{display:block;float:none;width:100%;margin-left:0;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.span12,.row-fluid .span12{width:100%;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.row-fluid [class*="offset"]:first-child{margin-left:0}.input-large,.input-xlarge,.input-xxlarge,input[class*="span"],select[class*="span"],textarea[class*="span"],.uneditable-input{display:block;width:100%;min-height:30px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.input-prepend input,.input-append input,.input-prepend input[class*="span"],.input-append input[class*="span"]{display:inline-block;width:auto}.controls-row [class*="span"]+[class*="span"]{margin-left:0}.modal{position:fixed;top:20px;right:20px;left:20px;width:auto;margin:0}.modal.fade{top:-100px}.modal.fade.in{top:20px}}@media(max-width:480px){.nav-collapse{-webkit-transform:translate3d(0,0,0)}.page-header h1 small{display:block;line-height:20px}input[type="checkbox"],input[type="radio"]{border:1px solid #ccc}.form-horizontal .control-label{float:none;width:auto;padding-top:0;text-align:left}.form-horizontal .controls{margin-left:0}.form-horizontal .control-list{padding-top:0}.form-horizontal .form-actions{padding-right:10px;padding-left:10px}.media .pull-left,.media .pull-right{display:block;float:none;margin-bottom:10px}.media-object{margin-right:0;margin-left:0}.modal{top:10px;right:10px;left:10px}.modal-header .close{padding:10px;margin:-10px}.carousel-caption{position:static}}@media(max-width:979px){body{padding-top:0}.navbar-fixed-top,.navbar-fixed-bottom{position:static}.navbar-fixed-top{margin-bottom:20px}.navbar-fixed-bottom{margin-top:20px}.navbar-fixed-top .navbar-inner,.navbar-fixed-bottom .navbar-inner{padding:5px}.navbar .container{width:auto;padding:0}.navbar .brand{padding-right:10px;padding-left:10px;margin:0 0 0 -5px}.nav-collapse{clear:both}.nav-collapse .nav{float:none;margin:0 0 10px}.nav-collapse .nav>li{float:none}.nav-collapse .nav>li>a{margin-bottom:2px}.nav-collapse .nav>.divider-vertical{display:none}.nav-collapse .nav .nav-header{color:#777;text-shadow:none}.nav-collapse .nav>li>a,.nav-collapse .dropdown-menu a{padding:9px 15px;font-weight:bold;color:#777;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px}.nav-collapse .btn{padding:4px 10px 4px;font-weight:normal;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.nav-collapse .dropdown-menu li+li a{margin-bottom:2px}.nav-collapse .nav>li>a:hover,.nav-collapse .nav>li>a:focus,.nav-collapse .dropdown-menu a:hover,.nav-collapse .dropdown-menu a:focus{background-color:#f2f2f2}.navbar-inverse .nav-collapse .nav>li>a,.navbar-inverse .nav-collapse .dropdown-menu a{color:#999}.navbar-inverse .nav-collapse .nav>li>a:hover,.navbar-inverse .nav-collapse .nav>li>a:focus,.navbar-inverse .nav-collapse .dropdown-menu a:hover,.navbar-inverse .nav-collapse .dropdown-menu a:focus{background-color:#111}.nav-collapse.in .btn-group{padding:0;margin-top:5px}.nav-collapse .dropdown-menu{position:static;top:auto;left:auto;display:none;float:none;max-width:none;padding:0;margin:0 15px;background-color:transparent;border:0;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none}.nav-collapse .open>.dropdown-menu{display:block}.nav-collapse .dropdown-menu:before,.nav-collapse .dropdown-menu:after{display:none}.nav-collapse .dropdown-menu .divider{display:none}.nav-collapse .nav>li>.dropdown-menu:before,.nav-collapse .nav>li>.dropdown-menu:after{display:none}.nav-collapse .navbar-form,.nav-collapse .navbar-search{float:none;padding:10px 15px;margin:10px 0;border-top:1px solid #f2f2f2;border-bottom:1px solid #f2f2f2;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1);-moz-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1);box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1)}.navbar-inverse .nav-collapse .navbar-form,.navbar-inverse .nav-collapse .navbar-search{border-top-color:#111;border-bottom-color:#111}.navbar .nav-collapse .nav.pull-right{float:none;margin-left:0}.nav-collapse,.nav-collapse.collapse{height:0;overflow:hidden}.navbar .btn-navbar{display:block}.navbar-static .navbar-inner{padding-right:10px;padding-left:10px}}@media(min-width:980px){.nav-collapse.collapse{height:auto!important;overflow:visible!important}}
diff --git a/website/static/bootstrap.min.js b/website/static/bootstrap.min.js
deleted file mode 100644
index 95c5ac5ee6..0000000000
--- a/website/static/bootstrap.min.js
+++ /dev/null
@@ -1,6 +0,0 @@
-/*!
-* Bootstrap.js by @fat & @mdo
-* Copyright 2012 Twitter, Inc.
-* http://www.apache.org/licenses/LICENSE-2.0.txt
-*/
-!function(e){"use strict";e(function(){e.support.transition=function(){var e=function(){var e=document.createElement("bootstrap"),t={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"},n;for(n in t)if(e.style[n]!==undefined)return t[n]}();return e&&{end:e}}()})}(window.jQuery),!function(e){"use strict";var t='[data-dismiss="alert"]',n=function(n){e(n).on("click",t,this.close)};n.prototype.close=function(t){function s(){i.trigger("closed").remove()}var n=e(this),r=n.attr("data-target"),i;r||(r=n.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,"")),i=e(r),t&&t.preventDefault(),i.length||(i=n.hasClass("alert")?n:n.parent()),i.trigger(t=e.Event("close"));if(t.isDefaultPrevented())return;i.removeClass("in"),e.support.transition&&i.hasClass("fade")?i.on(e.support.transition.end,s):s()};var r=e.fn.alert;e.fn.alert=function(t){return this.each(function(){var r=e(this),i=r.data("alert");i||r.data("alert",i=new n(this)),typeof t=="string"&&i[t].call(r)})},e.fn.alert.Constructor=n,e.fn.alert.noConflict=function(){return e.fn.alert=r,this},e(document).on("click.alert.data-api",t,n.prototype.close)}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.button.defaults,n)};t.prototype.setState=function(e){var t="disabled",n=this.$element,r=n.data(),i=n.is("input")?"val":"html";e+="Text",r.resetText||n.data("resetText",n[i]()),n[i](r[e]||this.options[e]),setTimeout(function(){e=="loadingText"?n.addClass(t).attr(t,t):n.removeClass(t).removeAttr(t)},0)},t.prototype.toggle=function(){var e=this.$element.closest('[data-toggle="buttons-radio"]');e&&e.find(".active").removeClass("active"),this.$element.toggleClass("active")};var n=e.fn.button;e.fn.button=function(n){return this.each(function(){var r=e(this),i=r.data("button"),s=typeof n=="object"&&n;i||r.data("button",i=new t(this,s)),n=="toggle"?i.toggle():n&&i.setState(n)})},e.fn.button.defaults={loadingText:"loading..."},e.fn.button.Constructor=t,e.fn.button.noConflict=function(){return e.fn.button=n,this},e(document).on("click.button.data-api","[data-toggle^=button]",function(t){var n=e(t.target);n.hasClass("btn")||(n=n.closest(".btn")),n.button("toggle")})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.$indicators=this.$element.find(".carousel-indicators"),this.options=n,this.options.pause=="hover"&&this.$element.on("mouseenter",e.proxy(this.pause,this)).on("mouseleave",e.proxy(this.cycle,this))};t.prototype={cycle:function(t){return t||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(e.proxy(this.next,this),this.options.interval)),this},getActiveIndex:function(){return this.$active=this.$element.find(".item.active"),this.$items=this.$active.parent().children(),this.$items.index(this.$active)},to:function(t){var n=this.getActiveIndex(),r=this;if(t>this.$items.length-1||t<0)return;return this.sliding?this.$element.one("slid",function(){r.to(t)}):n==t?this.pause().cycle():this.slide(t>n?"next":"prev",e(this.$items[t]))},pause:function(t){return t||(this.paused=!0),this.$element.find(".next, .prev").length&&e.support.transition.end&&(this.$element.trigger(e.support.transition.end),this.cycle(!0)),clearInterval(this.interval),this.interval=null,this},next:function(){if(this.sliding)return;return this.slide("next")},prev:function(){if(this.sliding)return;return this.slide("prev")},slide:function(t,n){var r=this.$element.find(".item.active"),i=n||r[t](),s=this.interval,o=t=="next"?"left":"right",u=t=="next"?"first":"last",a=this,f;this.sliding=!0,s&&this.pause(),i=i.length?i:this.$element.find(".item")[u](),f=e.Event("slide",{relatedTarget:i[0],direction:o});if(i.hasClass("active"))return;this.$indicators.length&&(this.$indicators.find(".active").removeClass("active"),this.$element.one("slid",function(){var t=e(a.$indicators.children()[a.getActiveIndex()]);t&&t.addClass("active")}));if(e.support.transition&&this.$element.hasClass("slide")){this.$element.trigger(f);if(f.isDefaultPrevented())return;i.addClass(t),i[0].offsetWidth,r.addClass(o),i.addClass(o),this.$element.one(e.support.transition.end,function(){i.removeClass([t,o].join(" ")).addClass("active"),r.removeClass(["active",o].join(" ")),a.sliding=!1,setTimeout(function(){a.$element.trigger("slid")},0)})}else{this.$element.trigger(f);if(f.isDefaultPrevented())return;r.removeClass("active"),i.addClass("active"),this.sliding=!1,this.$element.trigger("slid")}return s&&this.cycle(),this}};var n=e.fn.carousel;e.fn.carousel=function(n){return this.each(function(){var r=e(this),i=r.data("carousel"),s=e.extend({},e.fn.carousel.defaults,typeof n=="object"&&n),o=typeof n=="string"?n:s.slide;i||r.data("carousel",i=new t(this,s)),typeof n=="number"?i.to(n):o?i[o]():s.interval&&i.pause().cycle()})},e.fn.carousel.defaults={interval:5e3,pause:"hover"},e.fn.carousel.Constructor=t,e.fn.carousel.noConflict=function(){return e.fn.carousel=n,this},e(document).on("click.carousel.data-api","[data-slide], [data-slide-to]",function(t){var n=e(this),r,i=e(n.attr("data-target")||(r=n.attr("href"))&&r.replace(/.*(?=#[^\s]+$)/,"")),s=e.extend({},i.data(),n.data()),o;i.carousel(s),(o=n.attr("data-slide-to"))&&i.data("carousel").pause().to(o).cycle(),t.preventDefault()})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.collapse.defaults,n),this.options.parent&&(this.$parent=e(this.options.parent)),this.options.toggle&&this.toggle()};t.prototype={constructor:t,dimension:function(){var e=this.$element.hasClass("width");return e?"width":"height"},show:function(){var t,n,r,i;if(this.transitioning||this.$element.hasClass("in"))return;t=this.dimension(),n=e.camelCase(["scroll",t].join("-")),r=this.$parent&&this.$parent.find("> .accordion-group > .in");if(r&&r.length){i=r.data("collapse");if(i&&i.transitioning)return;r.collapse("hide"),i||r.data("collapse",null)}this.$element[t](0),this.transition("addClass",e.Event("show"),"shown"),e.support.transition&&this.$element[t](this.$element[0][n])},hide:function(){var t;if(this.transitioning||!this.$element.hasClass("in"))return;t=this.dimension(),this.reset(this.$element[t]()),this.transition("removeClass",e.Event("hide"),"hidden"),this.$element[t](0)},reset:function(e){var t=this.dimension();return this.$element.removeClass("collapse")[t](e||"auto")[0].offsetWidth,this.$element[e!==null?"addClass":"removeClass"]("collapse"),this},transition:function(t,n,r){var i=this,s=function(){n.type=="show"&&i.reset(),i.transitioning=0,i.$element.trigger(r)};this.$element.trigger(n);if(n.isDefaultPrevented())return;this.transitioning=1,this.$element[t]("in"),e.support.transition&&this.$element.hasClass("collapse")?this.$element.one(e.support.transition.end,s):s()},toggle:function(){this[this.$element.hasClass("in")?"hide":"show"]()}};var n=e.fn.collapse;e.fn.collapse=function(n){return this.each(function(){var r=e(this),i=r.data("collapse"),s=e.extend({},e.fn.collapse.defaults,r.data(),typeof n=="object"&&n);i||r.data("collapse",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.collapse.defaults={toggle:!0},e.fn.collapse.Constructor=t,e.fn.collapse.noConflict=function(){return e.fn.collapse=n,this},e(document).on("click.collapse.data-api","[data-toggle=collapse]",function(t){var n=e(this),r,i=n.attr("data-target")||t.preventDefault()||(r=n.attr("href"))&&r.replace(/.*(?=#[^\s]+$)/,""),s=e(i).data("collapse")?"toggle":n.data();n[e(i).hasClass("in")?"addClass":"removeClass"]("collapsed"),e(i).collapse(s)})}(window.jQuery),!function(e){"use strict";function r(){e(t).each(function(){i(e(this)).removeClass("open")})}function i(t){var n=t.attr("data-target"),r;n||(n=t.attr("href"),n=n&&/#/.test(n)&&n.replace(/.*(?=#[^\s]*$)/,"")),r=n&&e(n);if(!r||!r.length)r=t.parent();return r}var t="[data-toggle=dropdown]",n=function(t){var n=e(t).on("click.dropdown.data-api",this.toggle);e("html").on("click.dropdown.data-api",function(){n.parent().removeClass("open")})};n.prototype={constructor:n,toggle:function(t){var n=e(this),s,o;if(n.is(".disabled, :disabled"))return;return s=i(n),o=s.hasClass("open"),r(),o||s.toggleClass("open"),n.focus(),!1},keydown:function(n){var r,s,o,u,a,f;if(!/(38|40|27)/.test(n.keyCode))return;r=e(this),n.preventDefault(),n.stopPropagation();if(r.is(".disabled, :disabled"))return;u=i(r),a=u.hasClass("open");if(!a||a&&n.keyCode==27)return n.which==27&&u.find(t).focus(),r.click();s=e("[role=menu] li:not(.divider):visible a",u);if(!s.length)return;f=s.index(s.filter(":focus")),n.keyCode==38&&f>0&&f--,n.keyCode==40&&f<s.length-1&&f++,~f||(f=0),s.eq(f).focus()}};var s=e.fn.dropdown;e.fn.dropdown=function(t){return this.each(function(){var r=e(this),i=r.data("dropdown");i||r.data("dropdown",i=new n(this)),typeof t=="string"&&i[t].call(r)})},e.fn.dropdown.Constructor=n,e.fn.dropdown.noConflict=function(){return e.fn.dropdown=s,this},e(document).on("click.dropdown.data-api",r).on("click.dropdown.data-api",".dropdown form",function(e){e.stopPropagation()}).on("click.dropdown-menu",function(e){e.stopPropagation()}).on("click.dropdown.data-api",t,n.prototype.toggle).on("keydown.dropdown.data-api",t+", [role=menu]",n.prototype.keydown)}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.options=n,this.$element=e(t).delegate('[data-dismiss="modal"]',"click.dismiss.modal",e.proxy(this.hide,this)),this.options.remote&&this.$element.find(".modal-body").load(this.options.remote)};t.prototype={constructor:t,toggle:function(){return this[this.isShown?"hide":"show"]()},show:function(){var t=this,n=e.Event("show");this.$element.trigger(n);if(this.isShown||n.isDefaultPrevented())return;this.isShown=!0,this.escape(),this.backdrop(function(){var n=e.support.transition&&t.$element.hasClass("fade");t.$element.parent().length||t.$element.appendTo(document.body),t.$element.show(),n&&t.$element[0].offsetWidth,t.$element.addClass("in").attr("aria-hidden",!1),t.enforceFocus(),n?t.$element.one(e.support.transition.end,function(){t.$element.focus().trigger("shown")}):t.$element.focus().trigger("shown")})},hide:function(t){t&&t.preventDefault();var n=this;t=e.Event("hide"),this.$element.trigger(t);if(!this.isShown||t.isDefaultPrevented())return;this.isShown=!1,this.escape(),e(document).off("focusin.modal"),this.$element.removeClass("in").attr("aria-hidden",!0),e.support.transition&&this.$element.hasClass("fade")?this.hideWithTransition():this.hideModal()},enforceFocus:function(){var t=this;e(document).on("focusin.modal",function(e){t.$element[0]!==e.target&&!t.$element.has(e.target).length&&t.$element.focus()})},escape:function(){var e=this;this.isShown&&this.options.keyboard?this.$element.on("keyup.dismiss.modal",function(t){t.which==27&&e.hide()}):this.isShown||this.$element.off("keyup.dismiss.modal")},hideWithTransition:function(){var t=this,n=setTimeout(function(){t.$element.off(e.support.transition.end),t.hideModal()},500);this.$element.one(e.support.transition.end,function(){clearTimeout(n),t.hideModal()})},hideModal:function(){var e=this;this.$element.hide(),this.backdrop(function(){e.removeBackdrop(),e.$element.trigger("hidden")})},removeBackdrop:function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},backdrop:function(t){var n=this,r=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var i=e.support.transition&&r;this.$backdrop=e('<div class="modal-backdrop '+r+'" />').appendTo(document.body),this.$backdrop.click(this.options.backdrop=="static"?e.proxy(this.$element[0].focus,this.$element[0]):e.proxy(this.hide,this)),i&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in");if(!t)return;i?this.$backdrop.one(e.support.transition.end,t):t()}else!this.isShown&&this.$backdrop?(this.$backdrop.removeClass("in"),e.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one(e.support.transition.end,t):t()):t&&t()}};var n=e.fn.modal;e.fn.modal=function(n){return this.each(function(){var r=e(this),i=r.data("modal"),s=e.extend({},e.fn.modal.defaults,r.data(),typeof n=="object"&&n);i||r.data("modal",i=new t(this,s)),typeof n=="string"?i[n]():s.show&&i.show()})},e.fn.modal.defaults={backdrop:!0,keyboard:!0,show:!0},e.fn.modal.Constructor=t,e.fn.modal.noConflict=function(){return e.fn.modal=n,this},e(document).on("click.modal.data-api",'[data-toggle="modal"]',function(t){var n=e(this),r=n.attr("href"),i=e(n.attr("data-target")||r&&r.replace(/.*(?=#[^\s]+$)/,"")),s=i.data("modal")?"toggle":e.extend({remote:!/#/.test(r)&&r},i.data(),n.data());t.preventDefault(),i.modal(s).one("hide",function(){n.focus()})})}(window.jQuery),!function(e){"use strict";var t=function(e,t){this.init("tooltip",e,t)};t.prototype={constructor:t,init:function(t,n,r){var i,s,o,u,a;this.type=t,this.$element=e(n),this.options=this.getOptions(r),this.enabled=!0,o=this.options.trigger.split(" ");for(a=o.length;a--;)u=o[a],u=="click"?this.$element.on("click."+this.type,this.options.selector,e.proxy(this.toggle,this)):u!="manual"&&(i=u=="hover"?"mouseenter":"focus",s=u=="hover"?"mouseleave":"blur",this.$element.on(i+"."+this.type,this.options.selector,e.proxy(this.enter,this)),this.$element.on(s+"."+this.type,this.options.selector,e.proxy(this.leave,this)));this.options.selector?this._options=e.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},getOptions:function(t){return t=e.extend({},e.fn[this.type].defaults,this.$element.data(),t),t.delay&&typeof t.delay=="number"&&(t.delay={show:t.delay,hide:t.delay}),t},enter:function(t){var n=e.fn[this.type].defaults,r={},i;this._options&&e.each(this._options,function(e,t){n[e]!=t&&(r[e]=t)},this),i=e(t.currentTarget)[this.type](r).data(this.type);if(!i.options.delay||!i.options.delay.show)return i.show();clearTimeout(this.timeout),i.hoverState="in",this.timeout=setTimeout(function(){i.hoverState=="in"&&i.show()},i.options.delay.show)},leave:function(t){var n=e(t.currentTarget)[this.type](this._options).data(this.type);this.timeout&&clearTimeout(this.timeout);if(!n.options.delay||!n.options.delay.hide)return n.hide();n.hoverState="out",this.timeout=setTimeout(function(){n.hoverState=="out"&&n.hide()},n.options.delay.hide)},show:function(){var t,n,r,i,s,o,u=e.Event("show");if(this.hasContent()&&this.enabled){this.$element.trigger(u);if(u.isDefaultPrevented())return;t=this.tip(),this.setContent(),this.options.animation&&t.addClass("fade"),s=typeof this.options.placement=="function"?this.options.placement.call(this,t[0],this.$element[0]):this.options.placement,t.detach().css({top:0,left:0,display:"block"}),this.options.container?t.appendTo(this.options.container):t.insertAfter(this.$element),n=this.getPosition(),r=t[0].offsetWidth,i=t[0].offsetHeight;switch(s){case"bottom":o={top:n.top+n.height,left:n.left+n.width/2-r/2};break;case"top":o={top:n.top-i,left:n.left+n.width/2-r/2};break;case"left":o={top:n.top+n.height/2-i/2,left:n.left-r};break;case"right":o={top:n.top+n.height/2-i/2,left:n.left+n.width}}this.applyPlacement(o,s),this.$element.trigger("shown")}},applyPlacement:function(e,t){var n=this.tip(),r=n[0].offsetWidth,i=n[0].offsetHeight,s,o,u,a;n.offset(e).addClass(t).addClass("in"),s=n[0].offsetWidth,o=n[0].offsetHeight,t=="top"&&o!=i&&(e.top=e.top+i-o,a=!0),t=="bottom"||t=="top"?(u=0,e.left<0&&(u=e.left*-2,e.left=0,n.offset(e),s=n[0].offsetWidth,o=n[0].offsetHeight),this.replaceArrow(u-r+s,s,"left")):this.replaceArrow(o-i,o,"top"),a&&n.offset(e)},replaceArrow:function(e,t,n){this.arrow().css(n,e?50*(1-e/t)+"%":"")},setContent:function(){var e=this.tip(),t=this.getTitle();e.find(".tooltip-inner")[this.options.html?"html":"text"](t),e.removeClass("fade in top bottom left right")},hide:function(){function i(){var t=setTimeout(function(){n.off(e.support.transition.end).detach()},500);n.one(e.support.transition.end,function(){clearTimeout(t),n.detach()})}var t=this,n=this.tip(),r=e.Event("hide");this.$element.trigger(r);if(r.isDefaultPrevented())return;return n.removeClass("in"),e.support.transition&&this.$tip.hasClass("fade")?i():n.detach(),this.$element.trigger("hidden"),this},fixTitle:function(){var e=this.$element;(e.attr("title")||typeof e.attr("data-original-title")!="string")&&e.attr("data-original-title",e.attr("title")||"").attr("title","")},hasContent:function(){return this.getTitle()},getPosition:function(){var t=this.$element[0];return e.extend({},typeof t.getBoundingClientRect=="function"?t.getBoundingClientRect():{width:t.offsetWidth,height:t.offsetHeight},this.$element.offset())},getTitle:function(){var e,t=this.$element,n=this.options;return e=t.attr("data-original-title")||(typeof n.title=="function"?n.title.call(t[0]):n.title),e},tip:function(){return this.$tip=this.$tip||e(this.options.template)},arrow:function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},validate:function(){this.$element[0].parentNode||(this.hide(),this.$element=null,this.options=null)},enable:function(){this.enabled=!0},disable:function(){this.enabled=!1},toggleEnabled:function(){this.enabled=!this.enabled},toggle:function(t){var n=t?e(t.currentTarget)[this.type](this._options).data(this.type):this;n.tip().hasClass("in")?n.hide():n.show()},destroy:function(){this.hide().$element.off("."+this.type).removeData(this.type)}};var n=e.fn.tooltip;e.fn.tooltip=function(n){return this.each(function(){var r=e(this),i=r.data("tooltip"),s=typeof n=="object"&&n;i||r.data("tooltip",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.tooltip.Constructor=t,e.fn.tooltip.defaults={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1},e.fn.tooltip.noConflict=function(){return e.fn.tooltip=n,this}}(window.jQuery),!function(e){"use strict";var t=function(e,t){this.init("popover",e,t)};t.prototype=e.extend({},e.fn.tooltip.Constructor.prototype,{constructor:t,setContent:function(){var e=this.tip(),t=this.getTitle(),n=this.getContent();e.find(".popover-title")[this.options.html?"html":"text"](t),e.find(".popover-content")[this.options.html?"html":"text"](n),e.removeClass("fade top bottom left right in")},hasContent:function(){return this.getTitle()||this.getContent()},getContent:function(){var e,t=this.$element,n=this.options;return e=(typeof n.content=="function"?n.content.call(t[0]):n.content)||t.attr("data-content"),e},tip:function(){return this.$tip||(this.$tip=e(this.options.template)),this.$tip},destroy:function(){this.hide().$element.off("."+this.type).removeData(this.type)}});var n=e.fn.popover;e.fn.popover=function(n){return this.each(function(){var r=e(this),i=r.data("popover"),s=typeof n=="object"&&n;i||r.data("popover",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.popover.Constructor=t,e.fn.popover.defaults=e.extend({},e.fn.tooltip.defaults,{placement:"right",trigger:"click",content:"",template:'<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),e.fn.popover.noConflict=function(){return e.fn.popover=n,this}}(window.jQuery),!function(e){"use strict";function t(t,n){var r=e.proxy(this.process,this),i=e(t).is("body")?e(window):e(t),s;this.options=e.extend({},e.fn.scrollspy.defaults,n),this.$scrollElement=i.on("scroll.scroll-spy.data-api",r),this.selector=(this.options.target||(s=e(t).attr("href"))&&s.replace(/.*(?=#[^\s]+$)/,"")||"")+" .nav li > a",this.$body=e("body"),this.refresh(),this.process()}t.prototype={constructor:t,refresh:function(){var t=this,n;this.offsets=e([]),this.targets=e([]),n=this.$body.find(this.selector).map(function(){var n=e(this),r=n.data("target")||n.attr("href"),i=/^#\w/.test(r)&&e(r);return i&&i.length&&[[i.position().top+(!e.isWindow(t.$scrollElement.get(0))&&t.$scrollElement.scrollTop()),r]]||null}).sort(function(e,t){return e[0]-t[0]}).each(function(){t.offsets.push(this[0]),t.targets.push(this[1])})},process:function(){var e=this.$scrollElement.scrollTop()+this.options.offset,t=this.$scrollElement[0].scrollHeight||this.$body[0].scrollHeight,n=t-this.$scrollElement.height(),r=this.offsets,i=this.targets,s=this.activeTarget,o;if(e>=n)return s!=(o=i.last()[0])&&this.activate(o);for(o=r.length;o--;)s!=i[o]&&e>=r[o]&&(!r[o+1]||e<=r[o+1])&&this.activate(i[o])},activate:function(t){var n,r;this.activeTarget=t,e(this.selector).parent(".active").removeClass("active"),r=this.selector+'[data-target="'+t+'"],'+this.selector+'[href="'+t+'"]',n=e(r).parent("li").addClass("active"),n.parent(".dropdown-menu").length&&(n=n.closest("li.dropdown").addClass("active")),n.trigger("activate")}};var n=e.fn.scrollspy;e.fn.scrollspy=function(n){return this.each(function(){var r=e(this),i=r.data("scrollspy"),s=typeof n=="object"&&n;i||r.data("scrollspy",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.scrollspy.Constructor=t,e.fn.scrollspy.defaults={offset:10},e.fn.scrollspy.noConflict=function(){return e.fn.scrollspy=n,this},e(window).on("load",function(){e('[data-spy="scroll"]').each(function(){var t=e(this);t.scrollspy(t.data())})})}(window.jQuery),!function(e){"use strict";var t=function(t){this.element=e(t)};t.prototype={constructor:t,show:function(){var t=this.element,n=t.closest("ul:not(.dropdown-menu)"),r=t.attr("data-target"),i,s,o;r||(r=t.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,""));if(t.parent("li").hasClass("active"))return;i=n.find(".active:last a")[0],o=e.Event("show",{relatedTarget:i}),t.trigger(o);if(o.isDefaultPrevented())return;s=e(r),this.activate(t.parent("li"),n),this.activate(s,s.parent(),function(){t.trigger({type:"shown",relatedTarget:i})})},activate:function(t,n,r){function o(){i.removeClass("active").find("> .dropdown-menu > .active").removeClass("active"),t.addClass("active"),s?(t[0].offsetWidth,t.addClass("in")):t.removeClass("fade"),t.parent(".dropdown-menu")&&t.closest("li.dropdown").addClass("active"),r&&r()}var i=n.find("> .active"),s=r&&e.support.transition&&i.hasClass("fade");s?i.one(e.support.transition.end,o):o(),i.removeClass("in")}};var n=e.fn.tab;e.fn.tab=function(n){return this.each(function(){var r=e(this),i=r.data("tab");i||r.data("tab",i=new t(this)),typeof n=="string"&&i[n]()})},e.fn.tab.Constructor=t,e.fn.tab.noConflict=function(){return e.fn.tab=n,this},e(document).on("click.tab.data-api",'[data-toggle="tab"], [data-toggle="pill"]',function(t){t.preventDefault(),e(this).tab("show")})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.typeahead.defaults,n),this.matcher=this.options.matcher||this.matcher,this.sorter=this.options.sorter||this.sorter,this.highlighter=this.options.highlighter||this.highlighter,this.updater=this.options.updater||this.updater,this.source=this.options.source,this.$menu=e(this.options.menu),this.shown=!1,this.listen()};t.prototype={constructor:t,select:function(){var e=this.$menu.find(".active").attr("data-value");return this.$element.val(this.updater(e)).change(),this.hide()},updater:function(e){return e},show:function(){var t=e.extend({},this.$element.position(),{height:this.$element[0].offsetHeight});return this.$menu.insertAfter(this.$element).css({top:t.top+t.height,left:t.left}).show(),this.shown=!0,this},hide:function(){return this.$menu.hide(),this.shown=!1,this},lookup:function(t){var n;return this.query=this.$element.val(),!this.query||this.query.length<this.options.minLength?this.shown?this.hide():this:(n=e.isFunction(this.source)?this.source(this.query,e.proxy(this.process,this)):this.source,n?this.process(n):this)},process:function(t){var n=this;return t=e.grep(t,function(e){return n.matcher(e)}),t=this.sorter(t),t.length?this.render(t.slice(0,this.options.items)).show():this.shown?this.hide():this},matcher:function(e){return~e.toLowerCase().indexOf(this.query.toLowerCase())},sorter:function(e){var t=[],n=[],r=[],i;while(i=e.shift())i.toLowerCase().indexOf(this.query.toLowerCase())?~i.indexOf(this.query)?n.push(i):r.push(i):t.push(i);return t.concat(n,r)},highlighter:function(e){var t=this.query.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&");return e.replace(new RegExp("("+t+")","ig"),function(e,t){return"<strong>"+t+"</strong>"})},render:function(t){var n=this;return t=e(t).map(function(t,r){return t=e(n.options.item).attr("data-value",r),t.find("a").html(n.highlighter(r)),t[0]}),t.first().addClass("active"),this.$menu.html(t),this},next:function(t){var n=this.$menu.find(".active").removeClass("active"),r=n.next();r.length||(r=e(this.$menu.find("li")[0])),r.addClass("active")},prev:function(e){var t=this.$menu.find(".active").removeClass("active"),n=t.prev();n.length||(n=this.$menu.find("li").last()),n.addClass("active")},listen:function(){this.$element.on("focus",e.proxy(this.focus,this)).on("blur",e.proxy(this.blur,this)).on("keypress",e.proxy(this.keypress,this)).on("keyup",e.proxy(this.keyup,this)),this.eventSupported("keydown")&&this.$element.on("keydown",e.proxy(this.keydown,this)),this.$menu.on("click",e.proxy(this.click,this)).on("mouseenter","li",e.proxy(this.mouseenter,this)).on("mouseleave","li",e.proxy(this.mouseleave,this))},eventSupported:function(e){var t=e in this.$element;return t||(this.$element.setAttribute(e,"return;"),t=typeof this.$element[e]=="function"),t},move:function(e){if(!this.shown)return;switch(e.keyCode){case 9:case 13:case 27:e.preventDefault();break;case 38:e.preventDefault(),this.prev();break;case 40:e.preventDefault(),this.next()}e.stopPropagation()},keydown:function(t){this.suppressKeyPressRepeat=~e.inArray(t.keyCode,[40,38,9,13,27]),this.move(t)},keypress:function(e){if(this.suppressKeyPressRepeat)return;this.move(e)},keyup:function(e){switch(e.keyCode){case 40:case 38:case 16:case 17:case 18:break;case 9:case 13:if(!this.shown)return;this.select();break;case 27:if(!this.shown)return;this.hide();break;default:this.lookup()}e.stopPropagation(),e.preventDefault()},focus:function(e){this.focused=!0},blur:function(e){this.focused=!1,!this.mousedover&&this.shown&&this.hide()},click:function(e){e.stopPropagation(),e.preventDefault(),this.select(),this.$element.focus()},mouseenter:function(t){this.mousedover=!0,this.$menu.find(".active").removeClass("active"),e(t.currentTarget).addClass("active")},mouseleave:function(e){this.mousedover=!1,!this.focused&&this.shown&&this.hide()}};var n=e.fn.typeahead;e.fn.typeahead=function(n){return this.each(function(){var r=e(this),i=r.data("typeahead"),s=typeof n=="object"&&n;i||r.data("typeahead",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.typeahead.defaults={source:[],items:8,menu:'<ul class="typeahead dropdown-menu"></ul>',item:'<li><a href="#"></a></li>',minLength:1},e.fn.typeahead.Constructor=t,e.fn.typeahead.noConflict=function(){return e.fn.typeahead=n,this},e(document).on("focus.typeahead.data-api",'[data-provide="typeahead"]',function(t){var n=e(this);if(n.data("typeahead"))return;n.typeahead(n.data())})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.options=e.extend({},e.fn.affix.defaults,n),this.$window=e(window).on("scroll.affix.data-api",e.proxy(this.checkPosition,this)).on("click.affix.data-api",e.proxy(function(){setTimeout(e.proxy(this.checkPosition,this),1)},this)),this.$element=e(t),this.checkPosition()};t.prototype.checkPosition=function(){if(!this.$element.is(":visible"))return;var t=e(document).height(),n=this.$window.scrollTop(),r=this.$element.offset(),i=this.options.offset,s=i.bottom,o=i.top,u="affix affix-top affix-bottom",a;typeof i!="object"&&(s=o=i),typeof o=="function"&&(o=i.top()),typeof s=="function"&&(s=i.bottom()),a=this.unpin!=null&&n+this.unpin<=r.top?!1:s!=null&&r.top+this.$element.height()>=t-s?"bottom":o!=null&&n<=o?"top":!1;if(this.affixed===a)return;this.affixed=a,this.unpin=a=="bottom"?r.top-n:null,this.$element.removeClass(u).addClass("affix"+(a?"-"+a:""))};var n=e.fn.affix;e.fn.affix=function(n){return this.each(function(){var r=e(this),i=r.data("affix"),s=typeof n=="object"&&n;i||r.data("affix",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.affix.Constructor=t,e.fn.affix.defaults={offset:0},e.fn.affix.noConflict=function(){return e.fn.affix=n,this},e(window).on("load",function(){e('[data-spy="affix"]').each(function(){var t=e(this),n=t.data();n.offset=n.offset||{},n.offsetBottom&&(n.offset.bottom=n.offsetBottom),n.offsetTop&&(n.offset.top=n.offsetTop),t.affix(n)})})}(window.jQuery);
\ No newline at end of file
diff --git a/website/static/html5shiv.min.js b/website/static/html5shiv.min.js
deleted file mode 100644
index 784f221caf..0000000000
--- a/website/static/html5shiv.min.js
+++ /dev/null
@@ -1,8 +0,0 @@
-/*
- HTML5 Shiv v3.6.2pre | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
-*/
-(function(l,f){function m(){var a=e.elements;return"string"==typeof a?a.split(" "):a}function i(a){var b=n[a[o]];b||(b={},h++,a[o]=h,n[h]=b);return b}function p(a,b,c){b||(b=f);if(g)return b.createElement(a);c||(c=i(b));b=c.cache[a]?c.cache[a].cloneNode():r.test(a)?(c.cache[a]=c.createElem(a)).cloneNode():c.createElem(a);return b.canHaveChildren&&!s.test(a)?c.frag.appendChild(b):b}function t(a,b){if(!b.cache)b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag();
-a.createElement=function(c){return!e.shivMethods?b.createElem(c):p(c,a,b)};a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+m().join().replace(/\w+/g,function(a){b.createElem(a);b.frag.createElement(a);return'c("'+a+'")'})+");return n}")(e,b.frag)}function q(a){a||(a=f);var b=i(a);if(e.shivCSS&&!j&&!b.hasCSS){var c,d=a;c=d.createElement("p");d=d.getElementsByTagName("head")[0]||d.documentElement;c.innerHTML="x<style>article,aside,figcaption,figure,footer,header,hgroup,nav,section{display:block}mark{background:#FF0;color:#000}</style>";
-c=d.insertBefore(c.lastChild,d.firstChild);b.hasCSS=!!c}g||t(a,b);return a}var k=l.html5||{},s=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,r=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,j,o="_html5shiv",h=0,n={},g;(function(){try{var a=f.createElement("a");a.innerHTML="<xyz></xyz>";j="hidden"in a;var b;if(!(b=1==a.childNodes.length)){f.createElement("a");var c=f.createDocumentFragment();b="undefined"==typeof c.cloneNode||
-"undefined"==typeof c.createDocumentFragment||"undefined"==typeof c.createElement}g=b}catch(d){g=j=!0}})();var e={elements:k.elements||"abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video",version:"3.6.2pre",shivCSS:!1!==k.shivCSS,supportsUnknownElements:g,shivMethods:!1!==k.shivMethods,type:"default",shivDocument:q,createElement:p,createDocumentFragment:function(a,b){a||(a=f);if(g)return a.createDocumentFragment();
-for(var b=b||i(a),c=b.frag.cloneNode(),d=0,e=m(),h=e.length;d<h;d++)c.createElement(e[d]);return c}};l.html5=e;q(f)})(this,document);
diff --git a/website/static/icon-github.png b/website/static/icon-github.png
deleted file mode 100644
index a9c6940069..0000000000
Binary files a/website/static/icon-github.png and /dev/null differ
diff --git a/website/static/jquery-maven-artifact.min.js b/website/static/jquery-maven-artifact.min.js
deleted file mode 100644
index 6e134dd857..0000000000
--- a/website/static/jquery-maven-artifact.min.js
+++ /dev/null
@@ -1,7 +0,0 @@
-/**
- * jQuery Maven Artifact Plugin
- *
- * Version: 2.0.0
- * Author: Jake Wharton
- * License: Apache 2.0
- */(function(e){function n(e,t){var n=e.groupId.replace(/\./g,"/"),r="https://repo1.maven.org/maven2/"+n+"/"+e.artifactId+"/"+t+"/"+e.artifactId+"-"+t;return typeof e.classifier!="undefined"&&(r+="-"+e.classifier),r+="."+e.packaging,r}function r(e){var t={groupId:"g",artifactId:"a",packaging:"p",classifier:"l"},n="";for(var r in t)t.hasOwnProperty(r)&&e.hasOwnProperty(r)&&(n!==""&&(n+="+AND+"),n+=t[r]+':"'+e[r]+'"');return n}var t={packaging:"jar"};e.fn.artifactVersion=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="https://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;var r=t[0].latestVersion||t[0].v,o=n(i,r);s(r,o)})},e.fn.artifactVersions=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="https://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&rows=10&core=gav&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;t.sort(function(e,t){return e.v>t.v?-1:1});var r=[];for(var o=0;o<t.length;o++){var u=t[o].v;r.push({name:u,url:n(i,u)})}s(r)})}})(jQuery);
diff --git a/website/static/jquery.smooth-scroll.min.js b/website/static/jquery.smooth-scroll.min.js
deleted file mode 100644
index 2af596ee83..0000000000
--- a/website/static/jquery.smooth-scroll.min.js
+++ /dev/null
@@ -1,7 +0,0 @@
-/*!
- * Smooth Scroll - v1.4.10 - 2013-03-02
- * https://github.com/kswedberg/jquery-smooth-scroll
- * Copyright (c) 2013 Karl Swedberg
- * Licensed MIT (https://github.com/kswedberg/jquery-smooth-scroll/blob/master/LICENSE-MIT)
- */
-(function(l){function t(l){return l.replace(/(:|\.)/g,"\\$1")}var e="1.4.10",o={exclude:[],excludeWithin:[],offset:0,direction:"top",scrollElement:null,scrollTarget:null,beforeScroll:function(){},afterScroll:function(){},easing:"swing",speed:400,autoCoefficent:2},r=function(t){var e=[],o=!1,r=t.dir&&"left"==t.dir?"scrollLeft":"scrollTop";return this.each(function(){if(this!=document&&this!=window){var t=l(this);t[r]()>0?e.push(this):(t[r](1),o=t[r]()>0,o&&e.push(this),t[r](0))}}),e.length||this.each(function(){"BODY"===this.nodeName&&(e=[this])}),"first"===t.el&&e.length>1&&(e=[e[0]]),e};l.fn.extend({scrollable:function(l){var t=r.call(this,{dir:l});return this.pushStack(t)},firstScrollable:function(l){var t=r.call(this,{el:"first",dir:l});return this.pushStack(t)},smoothScroll:function(e){e=e||{};var o=l.extend({},l.fn.smoothScroll.defaults,e),r=l.smoothScroll.filterPath(location.pathname);return this.unbind("click.smoothscroll").bind("click.smoothscroll",function(e){var n=this,s=l(this),c=o.exclude,i=o.excludeWithin,a=0,f=0,h=!0,u={},d=location.hostname===n.hostname||!n.hostname,m=o.scrollTarget||(l.smoothScroll.filterPath(n.pathname)||r)===r,p=t(n.hash);if(o.scrollTarget||d&&m&&p){for(;h&&c.length>a;)s.is(t(c[a++]))&&(h=!1);for(;h&&i.length>f;)s.closest(i[f++]).length&&(h=!1)}else h=!1;h&&(e.preventDefault(),l.extend(u,o,{scrollTarget:o.scrollTarget||p,link:n}),l.smoothScroll(u))}),this}}),l.smoothScroll=function(t,e){var o,r,n,s,c=0,i="offset",a="scrollTop",f={},h={};"number"==typeof t?(o=l.fn.smoothScroll.defaults,n=t):(o=l.extend({},l.fn.smoothScroll.defaults,t||{}),o.scrollElement&&(i="position","static"==o.scrollElement.css("position")&&o.scrollElement.css("position","relative"))),o=l.extend({link:null},o),a="left"==o.direction?"scrollLeft":a,o.scrollElement?(r=o.scrollElement,c=r[a]()):r=l("html, body").firstScrollable(),o.beforeScroll.call(r,o),n="number"==typeof t?t:e||l(o.scrollTarget)[i]()&&l(o.scrollTarget)[i]()[o.direction]||0,f[a]=n+c+o.offset,s=o.speed,"auto"===s&&(s=f[a]||r.scrollTop(),s/=o.autoCoefficent),h={duration:s,easing:o.easing,complete:function(){o.afterScroll.call(o.link,o)}},o.step&&(h.step=o.step),r.length?r.stop().animate(f,h):o.afterScroll.call(o.link,o)},l.smoothScroll.version=e,l.smoothScroll.filterPath=function(l){return l.replace(/^\//,"").replace(/(index|default).[a-zA-Z]{3,4}$/,"").replace(/\/$/,"")},l.fn.smoothScroll.defaults=o})(jQuery);
\ No newline at end of file
diff --git a/website/static/prettify.js b/website/static/prettify.js
deleted file mode 100644
index 7b990496dd..0000000000
--- a/website/static/prettify.js
+++ /dev/null
@@ -1,30 +0,0 @@
-!function(){var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;
-(function(){function S(a){function d(e){var b=e.charCodeAt(0);if(b!==92)return b;var a=e.charAt(1);return(b=r[a])?b:"0"<=a&&a<="7"?parseInt(e.substring(1),8):a==="u"||a==="x"?parseInt(e.substring(2),16):e.charCodeAt(1)}function g(e){if(e<32)return(e<16?"\\x0":"\\x")+e.toString(16);e=String.fromCharCode(e);return e==="\\"||e==="-"||e==="]"||e==="^"?"\\"+e:e}function b(e){var b=e.substring(1,e.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),e=[],a=
-b[0]==="^",c=["["];a&&c.push("^");for(var a=a?1:0,f=b.length;a<f;++a){var h=b[a];if(/\\[bdsw]/i.test(h))c.push(h);else{var h=d(h),l;a+2<f&&"-"===b[a+1]?(l=d(b[a+2]),a+=2):l=h;e.push([h,l]);l<65||h>122||(l<65||h>90||e.push([Math.max(65,h)|32,Math.min(l,90)|32]),l<97||h>122||e.push([Math.max(97,h)&-33,Math.min(l,122)&-33]))}}e.sort(function(e,a){return e[0]-a[0]||a[1]-e[1]});b=[];f=[];for(a=0;a<e.length;++a)h=e[a],h[0]<=f[1]+1?f[1]=Math.max(f[1],h[1]):b.push(f=h);for(a=0;a<b.length;++a)h=b[a],c.push(g(h[0])),
-h[1]>h[0]&&(h[1]+1>h[0]&&c.push("-"),c.push(g(h[1])));c.push("]");return c.join("")}function s(e){for(var a=e.source.match(/\[(?:[^\\\]]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),c=a.length,d=[],f=0,h=0;f<c;++f){var l=a[f];l==="("?++h:"\\"===l.charAt(0)&&(l=+l.substring(1))&&(l<=h?d[l]=-1:a[f]=g(l))}for(f=1;f<d.length;++f)-1===d[f]&&(d[f]=++x);for(h=f=0;f<c;++f)l=a[f],l==="("?(++h,d[h]||(a[f]="(?:")):"\\"===l.charAt(0)&&(l=+l.substring(1))&&l<=h&&
-(a[f]="\\"+d[l]);for(f=0;f<c;++f)"^"===a[f]&&"^"!==a[f+1]&&(a[f]="");if(e.ignoreCase&&m)for(f=0;f<c;++f)l=a[f],e=l.charAt(0),l.length>=2&&e==="["?a[f]=b(l):e!=="\\"&&(a[f]=l.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return a.join("")}for(var x=0,m=!1,j=!1,k=0,c=a.length;k<c;++k){var i=a[k];if(i.ignoreCase)j=!0;else if(/[a-z]/i.test(i.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){m=!0;j=!1;break}}for(var r={b:8,t:9,n:10,v:11,
-f:12,r:13},n=[],k=0,c=a.length;k<c;++k){i=a[k];if(i.global||i.multiline)throw Error(""+i);n.push("(?:"+s(i)+")")}return RegExp(n.join("|"),j?"gi":"g")}function T(a,d){function g(a){var c=a.nodeType;if(c==1){if(!b.test(a.className)){for(c=a.firstChild;c;c=c.nextSibling)g(c);c=a.nodeName.toLowerCase();if("br"===c||"li"===c)s[j]="\n",m[j<<1]=x++,m[j++<<1|1]=a}}else if(c==3||c==4)c=a.nodeValue,c.length&&(c=d?c.replace(/\r\n?/g,"\n"):c.replace(/[\t\n\r ]+/g," "),s[j]=c,m[j<<1]=x,x+=c.length,m[j++<<1|1]=
-a)}var b=/(?:^|\s)nocode(?:\s|$)/,s=[],x=0,m=[],j=0;g(a);return{a:s.join("").replace(/\n$/,""),d:m}}function H(a,d,g,b){d&&(a={a:d,e:a},g(a),b.push.apply(b,a.g))}function U(a){for(var d=void 0,g=a.firstChild;g;g=g.nextSibling)var b=g.nodeType,d=b===1?d?a:g:b===3?V.test(g.nodeValue)?a:d:d;return d===a?void 0:d}function C(a,d){function g(a){for(var j=a.e,k=[j,"pln"],c=0,i=a.a.match(s)||[],r={},n=0,e=i.length;n<e;++n){var z=i[n],w=r[z],t=void 0,f;if(typeof w==="string")f=!1;else{var h=b[z.charAt(0)];
-if(h)t=z.match(h[1]),w=h[0];else{for(f=0;f<x;++f)if(h=d[f],t=z.match(h[1])){w=h[0];break}t||(w="pln")}if((f=w.length>=5&&"lang-"===w.substring(0,5))&&!(t&&typeof t[1]==="string"))f=!1,w="src";f||(r[z]=w)}h=c;c+=z.length;if(f){f=t[1];var l=z.indexOf(f),B=l+f.length;t[2]&&(B=z.length-t[2].length,l=B-f.length);w=w.substring(5);H(j+h,z.substring(0,l),g,k);H(j+h+l,f,I(w,f),k);H(j+h+B,z.substring(B),g,k)}else k.push(j+h,w)}a.g=k}var b={},s;(function(){for(var g=a.concat(d),j=[],k={},c=0,i=g.length;c<i;++c){var r=
-g[c],n=r[3];if(n)for(var e=n.length;--e>=0;)b[n.charAt(e)]=r;r=r[1];n=""+r;k.hasOwnProperty(n)||(j.push(r),k[n]=q)}j.push(/[\S\s]/);s=S(j)})();var x=d.length;return g}function v(a){var d=[],g=[];a.tripleQuotedStrings?d.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,q,"'\""]):a.multiLineStrings?d.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
-q,"'\"`"]):d.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,q,"\"'"]);a.verbatimStrings&&g.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,q]);var b=a.hashComments;b&&(a.cStyleComments?(b>1?d.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,"#"]):d.push(["com",/^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\b|[^\n\r]*)/,q,"#"]),g.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h(?:h|pp|\+\+)?|[a-z]\w*)>/,q])):d.push(["com",
-/^#[^\n\r]*/,q,"#"]));a.cStyleComments&&(g.push(["com",/^\/\/[^\n\r]*/,q]),g.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,q]));if(b=a.regexLiterals){var s=(b=b>1?"":"\n\r")?".":"[\\S\\s]";g.push(["lang-regex",RegExp("^(?:^^\\.?|[+-]|[!=]=?=?|\\#|%=?|&&?=?|\\(|\\*=?|[+\\-]=|->|\\/=?|::?|<<?=?|>>?>?=?|,|;|\\?|@|\\[|~|{|\\^\\^?=?|\\|\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*("+("/(?=[^/*"+b+"])(?:[^/\\x5B\\x5C"+b+"]|\\x5C"+s+"|\\x5B(?:[^\\x5C\\x5D"+b+"]|\\x5C"+
-s+")*(?:\\x5D|$))+/")+")")])}(b=a.types)&&g.push(["typ",b]);b=(""+a.keywords).replace(/^ | $/g,"");b.length&&g.push(["kwd",RegExp("^(?:"+b.replace(/[\s,]+/g,"|")+")\\b"),q]);d.push(["pln",/^\s+/,q," \r\n\t\u00a0"]);b="^.[^\\s\\w.$@'\"`/\\\\]*";a.regexLiterals&&(b+="(?!s*/)");g.push(["lit",/^@[$_a-z][\w$@]*/i,q],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,q],["pln",/^[$_a-z][\w$@]*/i,q],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,q,"0123456789"],["pln",/^\\[\S\s]?/,
-q],["pun",RegExp(b),q]);return C(d,g)}function J(a,d,g){function b(a){var c=a.nodeType;if(c==1&&!x.test(a.className))if("br"===a.nodeName)s(a),a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)b(a);else if((c==3||c==4)&&g){var d=a.nodeValue,i=d.match(m);if(i)c=d.substring(0,i.index),a.nodeValue=c,(d=d.substring(i.index+i[0].length))&&a.parentNode.insertBefore(j.createTextNode(d),a.nextSibling),s(a),c||a.parentNode.removeChild(a)}}function s(a){function b(a,c){var d=
-c?a.cloneNode(!1):a,e=a.parentNode;if(e){var e=b(e,1),g=a.nextSibling;e.appendChild(d);for(var i=g;i;i=g)g=i.nextSibling,e.appendChild(i)}return d}for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),d;(d=a.parentNode)&&d.nodeType===1;)a=d;c.push(a)}for(var x=/(?:^|\s)nocode(?:\s|$)/,m=/\r\n?|\n/,j=a.ownerDocument,k=j.createElement("li");a.firstChild;)k.appendChild(a.firstChild);for(var c=[k],i=0;i<c.length;++i)b(c[i]);d===(d|0)&&c[0].setAttribute("value",d);var r=j.createElement("ol");
-r.className="linenums";for(var d=Math.max(0,d-1|0)||0,i=0,n=c.length;i<n;++i)k=c[i],k.className="L"+(i+d)%10,k.firstChild||k.appendChild(j.createTextNode("\u00a0")),r.appendChild(k);a.appendChild(r)}function p(a,d){for(var g=d.length;--g>=0;){var b=d[g];F.hasOwnProperty(b)?D.console&&console.warn("cannot override language handler %s",b):F[b]=a}}function I(a,d){if(!a||!F.hasOwnProperty(a))a=/^\s*</.test(d)?"default-markup":"default-code";return F[a]}function K(a){var d=a.h;try{var g=T(a.c,a.i),b=g.a;
-a.a=b;a.d=g.d;a.e=0;I(d,b)(a);var s=/\bMSIE\s(\d+)/.exec(navigator.userAgent),s=s&&+s[1]<=8,d=/\n/g,x=a.a,m=x.length,g=0,j=a.d,k=j.length,b=0,c=a.g,i=c.length,r=0;c[i]=m;var n,e;for(e=n=0;e<i;)c[e]!==c[e+2]?(c[n++]=c[e++],c[n++]=c[e++]):e+=2;i=n;for(e=n=0;e<i;){for(var p=c[e],w=c[e+1],t=e+2;t+2<=i&&c[t+1]===w;)t+=2;c[n++]=p;c[n++]=w;e=t}c.length=n;var f=a.c,h;if(f)h=f.style.display,f.style.display="none";try{for(;b<k;){var l=j[b+2]||m,B=c[r+2]||m,t=Math.min(l,B),A=j[b+1],G;if(A.nodeType!==1&&(G=x.substring(g,
-t))){s&&(G=G.replace(d,"\r"));A.nodeValue=G;var L=A.ownerDocument,o=L.createElement("span");o.className=c[r+1];var v=A.parentNode;v.replaceChild(o,A);o.appendChild(A);g<l&&(j[b+1]=A=L.createTextNode(x.substring(t,l)),v.insertBefore(A,o.nextSibling))}g=t;g>=l&&(b+=2);g>=B&&(r+=2)}}finally{if(f)f.style.display=h}}catch(u){D.console&&console.log(u&&u.stack||u)}}var D=window,y=["break,continue,do,else,for,if,return,while"],E=[[y,"auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
-"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],M=[E,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],N=[E,"abstract,assert,boolean,byte,extends,final,finally,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"],
-O=[N,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,internal,into,is,let,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var,virtual,where"],E=[E,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],P=[y,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
-Q=[y,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],W=[y,"as,assert,const,copy,drop,enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,pub,pure,ref,self,static,struct,true,trait,type,unsafe,use"],y=[y,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],R=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)\b/,
-V=/\S/,X=v({keywords:[M,O,E,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",P,Q,y],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),F={};p(X,["default-code"]);p(C([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",
-/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);p(C([["pln",/^\s+/,q," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,q,"\"'"]],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],
-["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",/^style\s*=\s*([^\s"'>]+)/i]]),["in.tag"]);p(C([],[["atv",/^[\S\s]+/]]),["uq.val"]);p(v({keywords:M,hashComments:!0,cStyleComments:!0,types:R}),["c","cc","cpp","cxx","cyc","m"]);p(v({keywords:"null,true,false"}),["json"]);p(v({keywords:O,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:R}),
-["cs"]);p(v({keywords:N,cStyleComments:!0}),["java"]);p(v({keywords:y,hashComments:!0,multiLineStrings:!0}),["bash","bsh","csh","sh"]);p(v({keywords:P,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),["cv","py","python"]);p(v({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:2}),["perl","pl","pm"]);p(v({keywords:Q,
-hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb","ruby"]);p(v({keywords:E,cStyleComments:!0,regexLiterals:!0}),["javascript","js"]);p(v({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes",hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);p(v({keywords:W,cStyleComments:!0,multilineStrings:!0}),["rc","rs","rust"]);
-p(C([],[["str",/^[\S\s]+/]]),["regex"]);var Y=D.PR={createSimpleLexer:C,registerLangHandler:p,sourceDecorator:v,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ",prettyPrintOne:D.prettyPrintOne=function(a,d,g){var b=document.createElement("div");b.innerHTML="<pre>"+a+"</pre>";b=b.firstChild;g&&J(b,g,!0);K({h:d,j:g,c:b,i:1});
-return b.innerHTML},prettyPrint:D.prettyPrint=function(a,d){function g(){for(var b=D.PR_SHOULD_USE_CONTINUATION?c.now()+250:Infinity;i<p.length&&c.now()<b;i++){for(var d=p[i],j=h,k=d;k=k.previousSibling;){var m=k.nodeType,o=(m===7||m===8)&&k.nodeValue;if(o?!/^\??prettify\b/.test(o):m!==3||/\S/.test(k.nodeValue))break;if(o){j={};o.replace(/\b(\w+)=([\w%+\-.:]+)/g,function(a,b,c){j[b]=c});break}}k=d.className;if((j!==h||e.test(k))&&!v.test(k)){m=!1;for(o=d.parentNode;o;o=o.parentNode)if(f.test(o.tagName)&&
-o.className&&e.test(o.className)){m=!0;break}if(!m){d.className+=" prettyprinted";m=j.lang;if(!m){var m=k.match(n),y;if(!m&&(y=U(d))&&t.test(y.tagName))m=y.className.match(n);m&&(m=m[1])}if(w.test(d.tagName))o=1;else var o=d.currentStyle,u=s.defaultView,o=(o=o?o.whiteSpace:u&&u.getComputedStyle?u.getComputedStyle(d,q).getPropertyValue("white-space"):0)&&"pre"===o.substring(0,3);u=j.linenums;if(!(u=u==="true"||+u))u=(u=k.match(/\blinenums\b(?::(\d+))?/))?u[1]&&u[1].length?+u[1]:!0:!1;u&&J(d,u,o);r=
-{h:m,c:d,j:u,i:o};K(r)}}}i<p.length?setTimeout(g,250):"function"===typeof a&&a()}for(var b=d||document.body,s=b.ownerDocument||document,b=[b.getElementsByTagName("pre"),b.getElementsByTagName("code"),b.getElementsByTagName("xmp")],p=[],m=0;m<b.length;++m)for(var j=0,k=b[m].length;j<k;++j)p.push(b[m][j]);var b=q,c=Date;c.now||(c={now:function(){return+new Date}});var i=0,r,n=/\blang(?:uage)?-([\w.]+)(?!\S)/,e=/\bprettyprint\b/,v=/\bprettyprinted\b/,w=/pre|xmp/i,t=/^code$/i,f=/^(?:pre|code|xmp)$/i,
-h={};g()}};typeof define==="function"&&define.amd&&define("google-code-prettify",[],function(){return Y})})();}()
