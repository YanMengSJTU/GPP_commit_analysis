diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
index 5057a0de06..5a20e3045f 100644
--- a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
@@ -82,7 +82,8 @@
 
     List<Class<?>> expectedEvents = Arrays.asList(
         DnsStart.class, DnsEnd.class,
-        ConnectStart.class, ConnectEnd.class);
+        ConnectStart.class, ConnectEnd.class,
+        ConnectionFound.class);
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
@@ -100,7 +101,8 @@
     List<Class<?>> expectedEvents = Arrays.asList(
         DnsStart.class, DnsEnd.class,
         ConnectStart.class, SecureConnectStart.class,
-        SecureConnectEnd.class, ConnectEnd.class);
+        SecureConnectEnd.class, ConnectEnd.class,
+        ConnectionFound.class);
     assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
@@ -523,6 +525,84 @@
     assertFalse(recordedEvents.contains(SecureConnectEnd.class));
   }
 
+  @Test public void successfulConnectionFound() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    ConnectionFound connectionFound = listener.removeUpToEvent(ConnectionFound.class);
+    assertSame(call, connectionFound.call);
+    assertNotNull(connectionFound.connection);
+  }
+
+  @Test public void noConnectionFoundOnFollowUp() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location", "/foo"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    listener.removeUpToEvent(ConnectionFound.class);
+
+    List<Class<?>> remainingEvents = listener.recordedEventTypes();
+    assertFalse(remainingEvents.contains(ConnectionFound.class));
+  }
+
+  @Test public void pooledConnectionFound() throws IOException {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    // Seed the pool.
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals(200, response1.code());
+    response1.body().close();
+
+    ConnectionFound connectionFound1 = listener.removeUpToEvent(ConnectionFound.class);
+    listener.clearAllEvents();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(200, response2.code());
+    response2.body().close();
+
+    ConnectionFound connectionFound2 = listener.removeUpToEvent(ConnectionFound.class);
+    assertSame(connectionFound1.connection, connectionFound2.connection);
+  }
+
+  @Test public void multipleConnectionsFoundForSingleCall() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location", "/foo")
+        .addHeader("Connection", "Close"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    listener.removeUpToEvent(ConnectionFound.class);
+    listener.removeUpToEvent(ConnectionFound.class);
+  }
+
   private void enableTlsWithTunnel(boolean tunnelProxy) {
     client = client.newBuilder()
         .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
@@ -601,6 +681,16 @@ private void enableTlsWithTunnel(boolean tunnelProxy) {
     }
   }
 
+  static final class ConnectionFound {
+    final Call call;
+    final Connection connection;
+
+    ConnectionFound(Call call, Connection connection) {
+      this.call = call;
+      this.connection = connection;
+    }
+  }
+
   static final class RecordingEventListener extends EventListener {
     final Deque<Object> eventSequence = new ArrayDeque<>();
 
@@ -655,5 +745,9 @@ void clearAllEvents() {
         Protocol protocol, Throwable throwable) {
       eventSequence.offer(new ConnectEnd(call, inetSocketAddress, protocol, throwable));
     }
+
+    @Override public void connectionFound(Call call, Connection connection) {
+      eventSequence.offer(new ConnectionFound(call, connection));
+    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/EventListener.java b/okhttp/src/main/java/okhttp3/EventListener.java
index 4dfcfabbb7..d1126f7b70 100644
--- a/okhttp/src/main/java/okhttp3/EventListener.java
+++ b/okhttp/src/main/java/okhttp3/EventListener.java
@@ -122,6 +122,15 @@ public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
       @Nullable Protocol protocol, @Nullable Throwable throwable) {
   }
 
+  /**
+   * Invoked after a connection has been acquired for the {@code call}.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void connectionFound(Call call, Connection connection) {
+  }
+
   public void requestHeadersStart(Call call) {
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index fd5a8a953d..8ce0545dfd 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -106,10 +106,16 @@ public HttpCodec newStream(
     boolean connectionRetryEnabled = client.retryOnConnectionFailure();
 
     try {
+      RealConnection existingConnection = connection;
+
       RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
           writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
       HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);
 
+      if (existingConnection != connection) {
+        eventListener.connectionFound(call, connection);
+      }
+
       synchronized (connectionPool) {
         codec = resultCodec;
         return resultCodec;
