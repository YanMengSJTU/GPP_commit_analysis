diff --git a/build.gradle b/build.gradle
index 0cab1bb4e8..0cfe003303 100644
--- a/build.gradle
+++ b/build.gradle
@@ -59,6 +59,7 @@ allprojects {
   version = VERSION_NAME
 
   repositories {
+    maven {url 'http://maven.aliyun.com/nexus/content/groups/public/'}
     mavenCentral()
   }
 
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index d21e9df1b9..d9537c815f 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -15,6 +15,8 @@
  */
 package okhttp3;
 
+import com.google.errorprone.matchers.AnnotationHasArgumentWithValue;
+
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -35,22 +37,26 @@
  * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you supply your
  * own executor, it should be able to run {@linkplain #getMaxRequests the configured maximum} number
  * of calls concurrently.
+ * 异步请求执行时的规则
+ * 该类有一个线程池；可以自己配置，但是需要设定最大请求数
  */
 public final class Dispatcher {
+    /** 最大请求数 */
   private int maxRequests = 64;
+/** 每个主机的最大请求数 */
   private int maxRequestsPerHost = 5;
   private @Nullable Runnable idleCallback;
 
-  /** Executes calls. Created lazily. */
+  /** Executes calls. Created lazily. 懒加载*/
   private @Nullable ExecutorService executorService;
 
-  /** Ready async calls in the order they'll be run. */
+  /** Ready async calls in the order they'll be run. 准备执行的异步请求队列*/
   private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
 
-  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
+  /** Running asynchronous calls. Includes canceled calls that haven't finished yet.正在执行的异步请求队列 */
   private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
 
-  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
+  /** Running synchronous calls. Includes canceled calls that haven't finished yet. 正在执行的同步请求队列*/
   private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
 
   public Dispatcher(ExecutorService executorService) {
@@ -132,6 +138,7 @@ public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
 
   void enqueue(AsyncCall call) {
     synchronized (this) {
+        //将异步请求加入到准备执行的异步队列中
       readyAsyncCalls.add(call);
 
       // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to
@@ -141,6 +148,7 @@ void enqueue(AsyncCall call) {
         if (existingCall != null) call.reuseCallsPerHostFrom(existingCall);
       }
     }
+    //开始执行
     promoteAndExecute();
   }
 
@@ -185,6 +193,7 @@ private boolean promoteAndExecute() {
     List<AsyncCall> executableCalls = new ArrayList<>();
     boolean isRunning;
     synchronized (this) {
+        //遍历要执行的异步请求，将请求加入到正在执行的异步请求队列中
       for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
         AsyncCall asyncCall = i.next();
 
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index dbfc8cc8fb..5910ca9782 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -119,6 +119,7 @@
  *
  * <p>OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
  * remain idle.
+ * 构建者模式
  */
 public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
   static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index bb108764da..e51b12e76b 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -69,23 +69,28 @@ static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolea
     return originalRequest;
   }
 
+  //同步请求
   @Override public Response execute() throws IOException {
     synchronized (this) {
+      //一个请求只能执行一次
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
     transmitter.timeoutEnter();
     transmitter.callStart();
     try {
-      client.dispatcher().executed(this);
+        //同步请求的关键代码
+      client.dispatcher().executed(this);//将请求放到了同步请求队列中
       return getResponseWithInterceptorChain();
     } finally {
       client.dispatcher().finished(this);
     }
   }
 
+  //异步请求
   @Override public void enqueue(Callback responseCallback) {
     synchronized (this) {
+        //同样，一个请求只能执行一次
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
@@ -146,6 +151,7 @@ RealCall get() {
     /**
      * Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up
      * if the executor has been shut down by reporting the call as failed.
+     * 执行异步请求的方法
      */
     void executeOn(ExecutorService executorService) {
       assert (!Thread.holdsLock(client.dispatcher()));
@@ -165,10 +171,12 @@ void executeOn(ExecutorService executorService) {
       }
     }
 
+    /** 异步请求的执行，并获取返回结果的回调 */
     @Override protected void execute() {
       boolean signalledCallback = false;
       transmitter.timeoutEnter();
       try {
+          //执行各种拦截器，然后获取请求返回的结果
         Response response = getResponseWithInterceptorChain();
         signalledCallback = true;
         responseCallback.onResponse(RealCall.this, response);
@@ -199,6 +207,7 @@ String redactedUrl() {
     return originalRequest.url().redact();
   }
 
+  //添加或获取各种拦截器，然后执行proceed方法
   Response getResponseWithInterceptorChain() throws IOException {
     // Build a full stack of interceptors.
     List<Interceptor> interceptors = new ArrayList<>();
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java b/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java
index bc1cc1f87b..aee5030a84 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java
@@ -50,6 +50,7 @@
  * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
  * but not the other streams sharing its connection. But if the TLS handshake is still in progress
  * then canceling may break the entire connection.
+ * 应用层和网络层的桥梁，支持异步取消
  */
 public final class Transmitter {
   private final OkHttpClient client;
@@ -114,7 +115,7 @@ public void timeoutEarlyExit() {
 
   public void callStart() {
     this.callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
-    eventListener.callStart(call);
+    eventListener.callStart(call);//http请求调用的生命周期
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index c3d21611fb..daa75e3529 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -39,11 +39,12 @@ public CallServerInterceptor(boolean forWebSocket) {
     Request request = realChain.request();
 
     long sentRequestMillis = System.currentTimeMillis();
-
+//向服务端发起请求：发送headers
     exchange.writeRequestHeaders(request);
 
     boolean responseHeadersStarted = false;
     Response.Builder responseBuilder = null;
+    //如果Request请求的body不为空，需要包装RequestBody并发送
     if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
       // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
       // Continue" response before transmitting the request body. If we don't get that, return
@@ -81,7 +82,7 @@ public CallServerInterceptor(boolean forWebSocket) {
     } else {
       exchange.noRequestBody();
     }
-
+//完成请求
     if (request.body() == null || !request.body().isDuplex()) {
       exchange.finishRequest();
     }
@@ -93,7 +94,7 @@ public CallServerInterceptor(boolean forWebSocket) {
     if (responseBuilder == null) {
       responseBuilder = exchange.readResponseHeaders(false);
     }
-
+    //获取返回的结果
     Response response = responseBuilder
         .request(request)
         .handshake(exchange.connection().handshake())
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
index 431ce536bb..1c2d242098 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -136,6 +136,7 @@ public Response proceed(Request request, Transmitter transmitter, @Nullable Exch
     }
 
     // Call the next interceptor in the chain.
+    //遍历调用每个拦截器的intercept方法
     RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, exchange,
         index + 1, request, call, connectTimeout, readTimeout, writeTimeout);
     Interceptor interceptor = interceptors.get(index);
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 65da93ce23..0de3d8ae44 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -85,6 +85,7 @@ public RetryAndFollowUpInterceptor(OkHttpClient client) {
       Response response;
       boolean success = false;
       try {
+          //执行下一个拦截器的proceed方法
         response = realChain.proceed(request, transmitter, null);
         success = true;
       } catch (RouteException e) {
@@ -135,6 +136,7 @@ public RetryAndFollowUpInterceptor(OkHttpClient client) {
         exchange.detachWithViolence();
       }
 
+      //重连次数followUpCount超过20次的时候，停止重连
       if (++followUpCount > MAX_FOLLOW_UPS) {
         throw new ProtocolException("Too many follow-up requests: " + followUpCount);
       }
