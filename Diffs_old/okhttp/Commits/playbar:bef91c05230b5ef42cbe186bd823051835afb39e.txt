diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
index 8452b84634..17a7941961 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
@@ -19,9 +19,9 @@
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Headers;
+import okhttp3.NewWebSocket;
 import okhttp3.internal.Internal;
 import okhttp3.internal.http2.Settings;
-import okhttp3.WebSocketListener;
 import okio.Buffer;
 
 /** A scripted response to be replayed by the mock web server. */
@@ -45,7 +45,7 @@
 
   private List<PushPromise> promises = new ArrayList<>();
   private Settings settings;
-  private WebSocketListener webSocketListener;
+  private NewWebSocket.Listener webSocketListener;
 
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
@@ -284,7 +284,7 @@ public Settings getSettings() {
    * Attempts to perform a web socket upgrade on the connection. This will overwrite any previously
    * set status or body.
    */
-  public MockResponse withWebSocketUpgrade(WebSocketListener listener) {
+  public MockResponse withWebSocketUpgrade(NewWebSocket.Listener listener) {
     setStatus("HTTP/1.1 101 Switching Protocols");
     setHeader("Connection", "Upgrade");
     setHeader("Upgrade", "websocket");
@@ -293,7 +293,7 @@ public MockResponse withWebSocketUpgrade(WebSocketListener listener) {
     return this;
   }
 
-  public WebSocketListener getWebSocketListener() {
+  public NewWebSocket.Listener getWebSocketListener() {
     return webSocketListener;
   }
 
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 329a5a7352..75fde27f4f 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -69,7 +69,7 @@
 import okhttp3.internal.http2.Http2Stream;
 import okhttp3.internal.http2.Settings;
 import okhttp3.internal.platform.Platform;
-import okhttp3.internal.ws.RealWebSocket;
+import okhttp3.internal.ws.RealNewWebSocket;
 import okhttp3.internal.ws.WebSocketProtocol;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -676,14 +676,15 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
     replyExecutor.allowCoreThreadTimeOut(true);
 
     final CountDownLatch connectionClose = new CountDownLatch(1);
-    RealWebSocket webSocket =
-        new RealWebSocket(false /* is server */, source, sink, new SecureRandom(), replyExecutor,
-            response.getWebSocketListener(), fancyResponse, name) {
-          @Override protected void shutdown() {
-            connectionClose.countDown();
-          }
-        };
-
+    RealNewWebSocket.Streams streams = new RealNewWebSocket.Streams(false, source, sink) {
+      @Override public void close() {
+        connectionClose.countDown();
+      }
+    };
+    RealNewWebSocket webSocket = new RealNewWebSocket(fancyRequest,
+        response.getWebSocketListener(), new SecureRandom());
+    response.getWebSocketListener().onOpen(webSocket, fancyResponse);
+    webSocket.initReaderAndWriter(streams);
     webSocket.loopReader();
 
     // Even if messages are no longer being read we need to wait for the connection close signal.
diff --git a/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java b/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
index af9aed1499..87e99b552d 100644
--- a/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
+++ b/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
@@ -17,18 +17,12 @@
 
 import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 import okhttp3.internal.Version;
-import okio.BufferedSource;
 import okio.ByteString;
 
-import static okhttp3.WebSocket.BINARY;
-import static okhttp3.WebSocket.TEXT;
-
 /**
  * Exercises the web socket implementation against the <a
  * href="http://autobahn.ws/testsuite/">Autobahn Testsuite</a>.
@@ -42,9 +36,9 @@ public static void main(String... args) throws IOException {
 
   final OkHttpClient client = new OkHttpClient();
 
-  private WebSocketCall newWebSocket(String path) {
+  private NewWebSocket newWebSocket(String path, NewWebSocket.Listener listener) {
     Request request = new Request.Builder().url(HOST + path).build();
-    return client.newWebSocketCall(request);
+    return client.newWebSocket(request, listener);
   }
 
   public void run() throws IOException {
@@ -65,51 +59,30 @@ public void run() throws IOException {
   private void runTest(final long number, final long count) {
     final CountDownLatch latch = new CountDownLatch(1);
     final AtomicLong startNanos = new AtomicLong();
-    newWebSocket("/runCase?case=" + number + "&agent=okhttp") //
-        .enqueue(new WebSocketListener() {
-          private final ExecutorService sendExecutor = Executors.newSingleThreadExecutor();
-          private WebSocket webSocket;
-
-          @Override public void onOpen(WebSocket webSocket, Response response) {
-            this.webSocket = webSocket;
-
-            System.out.println("Executing test case " + number + "/" + count);
-            startNanos.set(System.nanoTime());
-          }
-
-          @Override public void onMessage(final ResponseBody message) throws IOException {
-            final RequestBody response;
-            if (message.contentType() == TEXT) {
-              response = RequestBody.create(TEXT, message.string());
-            } else {
-              BufferedSource source = message.source();
-              response = RequestBody.create(BINARY, source.readByteString());
-              source.close();
-            }
-            sendExecutor.execute(new Runnable() {
-              @Override public void run() {
-                try {
-                  webSocket.message(response);
-                } catch (IOException e) {
-                  e.printStackTrace(System.out);
-                }
-              }
-            });
-          }
-
-          @Override public void onPong(ByteString payload) {
-          }
-
-          @Override public void onClose(int code, String reason) {
-            sendExecutor.shutdown();
-            latch.countDown();
-          }
-
-          @Override public void onFailure(Throwable t, Response response) {
-            t.printStackTrace(System.out);
-            latch.countDown();
-          }
-        });
+    newWebSocket("/runCase?case=" + number + "&agent=okhttp", new NewWebSocket.Listener() {
+      @Override public void onOpen(NewWebSocket webSocket, Response response) {
+        System.out.println("Executing test case " + number + "/" + count);
+        startNanos.set(System.nanoTime());
+      }
+
+      @Override public void onMessage(final NewWebSocket webSocket, final ByteString bytes) {
+        webSocket.send(bytes);
+      }
+
+      @Override public void onMessage(final NewWebSocket webSocket, final String text) {
+        webSocket.send(text);
+      }
+
+      @Override public void onClosing(NewWebSocket webSocket, int code, String reason) {
+        webSocket.close(1000, null);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(NewWebSocket webSocket, Throwable t, Response response) {
+        t.printStackTrace(System.out);
+        latch.countDown();
+      }
+    });
     try {
       if (!latch.await(30, TimeUnit.SECONDS)) {
         throw new IllegalStateException("Timed out waiting for test " + number + " to finish.");
@@ -127,23 +100,17 @@ private long getTestCount() throws IOException {
     final CountDownLatch latch = new CountDownLatch(1);
     final AtomicLong countRef = new AtomicLong();
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    newWebSocket("/getCaseCount").enqueue(new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-      }
-
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        countRef.set(message.source().readDecimalLong());
-        message.close();
+    newWebSocket("/getCaseCount", new NewWebSocket.Listener() {
+      @Override public void onMessage(NewWebSocket webSocket, String text) {
+        countRef.set(Long.parseLong(text));
       }
 
-      @Override public void onPong(ByteString payload) {
-      }
-
-      @Override public void onClose(int code, String reason) {
+      @Override public void onClosing(NewWebSocket webSocket, int code, String reason) {
+        webSocket.close(1000, null);
         latch.countDown();
       }
 
-      @Override public void onFailure(Throwable t, Response response) {
+      @Override public void onFailure(NewWebSocket webSocket, Throwable t, Response response) {
         failureRef.set(t);
         latch.countDown();
       }
@@ -164,21 +131,13 @@ private long getTestCount() throws IOException {
 
   private void updateReports() {
     final CountDownLatch latch = new CountDownLatch(1);
-    newWebSocket("/updateReports?agent=" + Version.userAgent()).enqueue(new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-      }
-
-      @Override public void onMessage(ResponseBody message) throws IOException {
-      }
-
-      @Override public void onPong(ByteString payload) {
-      }
-
-      @Override public void onClose(int code, String reason) {
+    newWebSocket("/updateReports?agent=" + Version.userAgent(), new NewWebSocket.Listener() {
+      @Override public void onClosing(NewWebSocket webSocket, int code, String reason) {
+        webSocket.close(code, null);
         latch.countDown();
       }
 
-      @Override public void onFailure(Throwable t, Response response) {
+      @Override public void onFailure(NewWebSocket webSocket, Throwable t, Response response) {
         latch.countDown();
       }
     });
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
index 3410775b6c..b292bc056c 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
@@ -32,11 +32,11 @@
 public final class RecordedResponse {
   public final Request request;
   public final Response response;
-  public final WebSocket webSocket;
+  public final NewWebSocket webSocket;
   public final String body;
   public final IOException failure;
 
-  public RecordedResponse(Request request, Response response, WebSocket webSocket, String body,
+  public RecordedResponse(Request request, Response response, NewWebSocket webSocket, String body,
       IOException failure) {
     this.request = request;
     this.response = response;
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index 7782e38d34..adbf091782 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -3556,7 +3556,6 @@ private void zeroLengthPayload(String method)
     assertEquals(0, dispatcher.runningCallsCount());
   }
 
-  @Ignore // TODO: recover gracefully when a connection is shutdown.
   @Test public void streamedBodyIsRetriedOnHttp2Shutdown() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     server.enqueue(new MockResponse()
@@ -3574,6 +3573,9 @@ private void zeroLengthPayload(String method)
     HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     assertContent("abc", connection2);
 
+    // Ensure the GOAWAY frame has time to be read and processed.
+    Thread.sleep(500);
+
     OutputStream os = connection1.getOutputStream();
     os.write(new byte[] { '1', '2', '3' });
     os.close();
diff --git a/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java b/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java
deleted file mode 100644
index 261799a304..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java
+++ /dev/null
@@ -1,475 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Logger;
-import okhttp3.internal.tls.SslClient;
-import okhttp3.internal.ws.EmptyWebSocketListener;
-import okhttp3.internal.ws.RealWebSocket;
-import okhttp3.internal.ws.WebSocketRecorder;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okio.ByteString;
-import org.junit.After;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.WebSocket.BINARY;
-import static okhttp3.WebSocket.TEXT;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class WebSocketCallTest {
-  @Rule public final MockWebServer webServer = new MockWebServer();
-
-  private final SslClient sslClient = SslClient.localhost();
-  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
-  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
-  private final Random random = new Random(0);
-  private OkHttpClient client = defaultClient().newBuilder()
-      .addInterceptor(new Interceptor() {
-        @Override public Response intercept(Chain chain) throws IOException {
-          Response response = chain.proceed(chain.request());
-          assertNotNull(response.body()); // Ensure application interceptors never see a null body.
-          return response;
-        }
-      })
-      .build();
-
-  @After public void tearDown() {
-    clientListener.assertExhausted();
-  }
-
-  @Test public void textMessage() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-    serverListener.assertOpen();
-
-    client.message(RequestBody.create(TEXT, "Hello, WebSockets!"));
-    serverListener.assertTextMessage("Hello, WebSockets!");
-  }
-
-  @Test public void binaryMessage() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-    serverListener.assertOpen();
-
-    client.message(RequestBody.create(BINARY, "Hello!"));
-    serverListener.assertBinaryMessage(new byte[] {'H', 'e', 'l', 'l', 'o', '!'});
-  }
-
-  @Test public void nullMessageThrows() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-    try {
-      client.message(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertEquals("message == null", e.getMessage());
-    }
-  }
-
-  @Test public void missingContentTypeThrows() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-    try {
-      client.message(RequestBody.create(null, "Hey!"));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.",
-          e.getMessage());
-    }
-  }
-
-  @Test public void unknownContentTypeThrows() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-    try {
-      client.message(RequestBody.create(MediaType.parse("text/plain"), "Hey!"));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals(
-          "Unknown message content type: text/plain. Must use WebSocket.TEXT or WebSocket.BINARY.",
-          e.getMessage());
-    }
-  }
-
-  @Test public void pingPong() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-
-    client.ping(ByteString.encodeUtf8("Hello, WebSockets!"));
-    clientListener.assertPong(ByteString.encodeUtf8("Hello, WebSockets!"));
-  }
-
-  @Test public void nullPingPayloadThrows() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-    try {
-      client.ping(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertEquals("payload == null", e.getMessage());
-    }
-  }
-
-  @Test public void serverMessage() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    server.message(RequestBody.create(TEXT, "Hello, WebSockets!"));
-    clientListener.assertTextMessage("Hello, WebSockets!");
-  }
-
-  @Test public void writingOnReaderThreadThrows() throws IOException, InterruptedException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    Request request = new Request.Builder().get().url(webServer.url("/")).build();
-    RealWebSocketCall call = new RealWebSocketCall(client, request, random);
-
-    final AtomicInteger count = new AtomicInteger();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new WebSocketListener() {
-      private WebSocket webSocket;
-
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-        this.webSocket = webSocket;
-
-        try {
-          webSocket.close(1000, "");
-          fail();
-        } catch (IllegalStateException e) {
-          assertEquals("attempting to write from reader thread", e.getMessage());
-        } catch (IOException e) {
-          throw new AssertionError(e);
-        }
-
-        count.getAndIncrement();
-      }
-
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        try {
-          webSocket.message(RequestBody.create(TEXT, "hey"));
-          fail();
-        } catch (IllegalStateException e) {
-          assertEquals("attempting to write from reader thread", e.getMessage());
-        }
-
-        message.close();
-        count.getAndIncrement();
-      }
-
-      @Override public void onPong(ByteString payload) {
-        try {
-          webSocket.ping(ByteString.EMPTY);
-          fail();
-        } catch (IllegalStateException e) {
-          assertEquals("attempting to write from reader thread", e.getMessage());
-        } catch (IOException e) {
-          throw new AssertionError(e);
-        }
-
-        count.getAndIncrement();
-      }
-
-      @Override public void onClose(int code, String reason) {
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Throwable t, Response response) {
-        t.printStackTrace();
-      }
-    });
-
-    WebSocket server = serverListener.assertOpen();
-    server.message(RequestBody.create(TEXT, "hi"));
-    ((RealWebSocket) server).pong(ByteString.EMPTY);
-    server.close(1000, "");
-
-    assertTrue(latch.await(10, SECONDS));
-    // Verify we hit all three callbacks and attempted to write in them.
-    assertEquals(3, count.get());
-  }
-
-  @Test public void throwingOnOpenClosesAndFails() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-        throw e;
-      }
-    });
-    enqueueClientWebSocket();
-
-    serverListener.assertOpen();
-    serverListener.assertClose(1001, "");
-    clientListener.assertFailure(e);
-  }
-
-  @Ignore("AsyncCall currently lets runtime exceptions propagate.")
-  @Test public void throwingOnFailLogs() throws InterruptedException {
-    TestLogHandler logs = new TestLogHandler();
-    Logger logger = Logger.getLogger(OkHttpClient.class.getName());
-    logger.addHandler(logs);
-
-    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onFailure(Throwable t, Response response) {
-        throw e;
-      }
-    });
-
-    enqueueClientWebSocket();
-
-    assertEquals("", logs.take());
-    logger.removeHandler(logs);
-  }
-
-  @Test public void throwingOnMessageClosesAndFails() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onMessage(ResponseBody message) {
-        throw e;
-      }
-    });
-
-    server.message(RequestBody.create(TEXT, "Hello, WebSockets!"));
-    clientListener.assertFailure(e);
-    serverListener.assertClose(1001, "");
-  }
-
-  @Test public void throwingOnOnPongClosesAndFails() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-    serverListener.assertOpen();
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onPong(ByteString payload) {
-        throw e;
-      }
-    });
-
-    client.ping(ByteString.EMPTY);
-    clientListener.assertFailure(e);
-    serverListener.assertClose(1001, "");
-  }
-
-  @Test public void throwingOnCloseClosesNormallyAndFails() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onClose(int code, String reason) {
-        throw e;
-      }
-    });
-
-    server.close(1000, "bye");
-    clientListener.assertFailure(e);
-    serverListener.assertClose(1000, "bye");
-  }
-
-  @Test public void non101RetainsBody() throws IOException {
-    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
-    enqueueClientWebSocket();
-
-    clientListener.assertFailure(200, "Body", ProtocolException.class,
-        "Expected HTTP 101 response but was '200 OK'");
-  }
-
-  @Test public void notFound() throws IOException {
-    webServer.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
-    enqueueClientWebSocket();
-
-    clientListener.assertFailure(404, null, ProtocolException.class,
-        "Expected HTTP 101 response but was '404 Not Found'");
-  }
-
-  @Test public void clientTimeoutClosesBody() throws IOException {
-    webServer.enqueue(new MockResponse().setResponseCode(408));
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-
-    client.ping(ByteString.encodeUtf8("WebSockets are fun!"));
-    clientListener.assertPong(ByteString.encodeUtf8("WebSockets are fun!"));
-  }
-
-  @Test public void missingConnectionHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    enqueueClientWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Connection' header value 'Upgrade' but was 'null'");
-  }
-
-  @Test public void wrongConnectionHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Connection", "Downgrade")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    enqueueClientWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Connection' header value 'Upgrade' but was 'Downgrade'");
-  }
-
-  @Test public void missingUpgradeHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    enqueueClientWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Upgrade' header value 'websocket' but was 'null'");
-  }
-
-  @Test public void wrongUpgradeHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "Pepsi")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    enqueueClientWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Upgrade' header value 'websocket' but was 'Pepsi'");
-  }
-
-  @Test public void missingMagicHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "websocket"));
-    enqueueClientWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'null'");
-  }
-
-  @Test public void wrongMagicHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", "magic"));
-    enqueueClientWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
-  }
-
-  @Test public void wsScheme() throws IOException {
-    websocketScheme("ws");
-  }
-
-  @Test public void wsUppercaseScheme() throws IOException {
-    websocketScheme("WS");
-  }
-
-  @Test public void wssScheme() throws IOException {
-    webServer.useHttps(sslClient.socketFactory, false);
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    websocketScheme("wss");
-  }
-
-  @Test public void httpsScheme() throws IOException {
-    webServer.useHttps(sslClient.socketFactory, false);
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    websocketScheme("https");
-  }
-
-  private void websocketScheme(String scheme) throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    Request request = new Request.Builder()
-        .url(scheme + "://" + webServer.getHostName() + ":" + webServer.getPort() + "/")
-        .build();
-
-    enqueueClientWebSocket(request);
-    WebSocket webSocket = clientListener.assertOpen();
-    serverListener.assertOpen();
-
-    webSocket.message(RequestBody.create(TEXT, "abc"));
-    serverListener.assertTextMessage("abc");
-  }
-
-  private void enqueueClientWebSocket() {
-    enqueueClientWebSocket(new Request.Builder().get().url(webServer.url("/")).build());
-  }
-
-  private void enqueueClientWebSocket(Request request) {
-    WebSocketCall call = new RealWebSocketCall(client, request, random);
-    call.enqueue(clientListener);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/NewWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/WebSocketHttpTest.java
similarity index 94%
rename from okhttp-tests/src/test/java/okhttp3/NewWebSocketTest.java
rename to okhttp-tests/src/test/java/okhttp3/WebSocketHttpTest.java
index fc4f1bc74c..bd4ed9edf1 100644
--- a/okhttp-tests/src/test/java/okhttp3/NewWebSocketTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/WebSocketHttpTest.java
@@ -22,7 +22,6 @@
 import okhttp3.internal.tls.SslClient;
 import okhttp3.internal.ws.NewWebSocketRecorder;
 import okhttp3.internal.ws.RealNewWebSocket;
-import okhttp3.internal.ws.WebSocketRecorder;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okio.ByteString;
@@ -32,17 +31,16 @@
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.WebSocket.TEXT;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
 
-public final class NewWebSocketTest {
+public final class WebSocketHttpTest {
   @Rule public final MockWebServer webServer = new MockWebServer();
 
   private final SslClient sslClient = SslClient.localhost();
   private final NewWebSocketRecorder clientListener = new NewWebSocketRecorder("client");
-  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
+  private final NewWebSocketRecorder serverListener = new NewWebSocketRecorder("server");
   private final Random random = new Random(0);
   private OkHttpClient client = defaultClient().newBuilder()
       .addInterceptor(new Interceptor() {
@@ -111,9 +109,9 @@
     enqueueClientWebSocket();
 
     clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
+    NewWebSocket server = serverListener.assertOpen();
 
-    server.message(RequestBody.create(TEXT, "Hello, WebSockets!"));
+    server.send("Hello, WebSockets!");
     clientListener.assertTextMessage("Hello, WebSockets!");
   }
 
@@ -159,7 +157,7 @@
     enqueueClientWebSocket();
 
     clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
+    NewWebSocket server = serverListener.assertOpen();
 
     final RuntimeException e = new RuntimeException();
     clientListener.setNextEventDelegate(new NewWebSocket.Listener() {
@@ -168,7 +166,7 @@
       }
     });
 
-    server.message(RequestBody.create(TEXT, "Hello, WebSockets!"));
+    server.send("Hello, WebSockets!");
     clientListener.assertFailure(e);
     serverListener.assertExhausted();
   }
@@ -178,7 +176,7 @@
     enqueueClientWebSocket();
 
     clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
+    NewWebSocket server = serverListener.assertOpen();
 
     final RuntimeException e = new RuntimeException();
     clientListener.setNextEventDelegate(new NewWebSocket.Listener() {
@@ -214,12 +212,12 @@
     RealNewWebSocket client = enqueueClientWebSocket();
 
     clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
+    NewWebSocket server = serverListener.assertOpen();
 
     client.send("abc");
     serverListener.assertTextMessage("abc");
 
-    server.message(RequestBody.create(TEXT, "def"));
+    server.send("def");
     clientListener.assertTextMessage("def");
   }
 
@@ -340,8 +338,8 @@ private RealNewWebSocket enqueueClientWebSocket() {
   }
 
   private RealNewWebSocket enqueueClientWebSocket(Request request) {
-    RealNewWebSocket webSocket = new RealNewWebSocket(client, request, clientListener, random);
-    webSocket.connnect();
+    RealNewWebSocket webSocket = new RealNewWebSocket(request, clientListener, random);
+    webSocket.connect(client);
     return webSocket;
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index 610e0898ec..a782691f7d 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -245,8 +245,7 @@
     try {
       connection.newStream(headerEntries("c", "cola"), true);
       fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
+    } catch (ConnectionShutdownException expected) {
     }
     assertTrue(stream1.isOpen());
     assertFalse(stream2.isOpen());
@@ -1009,8 +1008,7 @@
     try {
       connection.newStream(headerEntries("c", "cola"), false);
       fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
+    } catch (ConnectionShutdownException expected) {
     }
     assertTrue(stream1.isOpen());
     assertFalse(stream2.isOpen());
@@ -1068,8 +1066,7 @@
     try {
       connection.ping();
       fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
+    } catch (ConnectionShutdownException expected) {
     }
 
     // verify the peer received what was expected
@@ -1094,8 +1091,7 @@
     try {
       connection.newStream(headerEntries("b", "banana"), false);
       fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
+    } catch (ConnectionShutdownException expected) {
     }
     BufferedSink sink = Okio.buffer(stream.getSink());
     try {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 41aa761c1f..4c2e05844b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -43,6 +43,7 @@
 import okhttp3.internal.RecordingOkAuthenticator;
 import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.Util;
+import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -854,6 +855,9 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
                   .build());
               Response response = call.execute();
               assertEquals("ABC", response.body().string());
+              // Wait until the GOAWAY has been processed.
+              RealConnection connection = (RealConnection) chain.connection();
+              while (connection.isHealthy(false)) ;
             }
             return chain.proceed(chain.request());
           }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/EmptyWebSocketListener.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/EmptyWebSocketListener.java
deleted file mode 100644
index f3ba32e464..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/EmptyWebSocketListener.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.IOException;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.WebSocket;
-import okhttp3.WebSocketListener;
-import okio.ByteString;
-
-public class EmptyWebSocketListener implements WebSocketListener {
-  @Override public void onOpen(WebSocket webSocket, Response response) {
-  }
-
-  @Override public void onMessage(ResponseBody message) throws IOException {
-  }
-
-  @Override public void onPong(ByteString payload) {
-  }
-
-  @Override public void onClose(int code, String reason) {
-  }
-
-  @Override public void onFailure(Throwable t, Response response) {
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/NewWebSocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/NewWebSocketRecorder.java
index 7f4ad50f68..68f53a2b52 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/NewWebSocketRecorder.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/NewWebSocketRecorder.java
@@ -21,8 +21,6 @@
 import java.util.concurrent.TimeUnit;
 import okhttp3.NewWebSocket;
 import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.WebSocket;
 import okhttp3.internal.Util;
 import okhttp3.internal.platform.Platform;
 import okio.ByteString;
@@ -142,16 +140,26 @@ public void assertBinaryMessage(byte[] payload) {
     assertEquals(new Message(ByteString.of(payload)), actual);
   }
 
+  public void assertPing(ByteString payload) {
+    Object actual = nextEvent();
+    assertEquals(new Ping(payload), actual);
+  }
+
   public void assertPong(ByteString payload) {
     Object actual = nextEvent();
     assertEquals(new Pong(payload), actual);
   }
 
-  public void assertClose(int code, String reason) {
+  public void assertClosing(int code, String reason) {
     Object actual = nextEvent();
     assertEquals(new Closing(code, reason), actual);
   }
 
+  public void assertClosed(int code, String reason) {
+    Object actual = nextEvent();
+    assertEquals(new Closed(code, reason), actual);
+  }
+
   public void assertExhausted() {
     assertTrue("Remaining events: " + events, events.isEmpty());
   }
@@ -200,6 +208,31 @@ public void assertFailure(int code, String body, Class<? extends IOException> cl
     assertEquals(message, failure.t.getMessage());
   }
 
+  /** Expose this recorder as a frame callback and shim in "ping" events. */
+  public WebSocketReader.FrameCallback asFrameCallback() {
+    return new WebSocketReader.FrameCallback() {
+      @Override public void onReadMessage(String text) throws IOException {
+        onMessage(null, text);
+      }
+
+      @Override public void onReadMessage(ByteString bytes) throws IOException {
+        onMessage(null, bytes);
+      }
+
+      @Override public void onReadPing(ByteString payload) {
+        events.add(new Ping(payload));
+      }
+
+      @Override public void onReadPong(ByteString payload) {
+        events.add(new Pong(payload));
+      }
+
+      @Override public void onReadClose(int code, String reason) {
+        onClosing(null, code, reason);
+      }
+    };
+  }
+
   static final class Open {
     final NewWebSocket webSocket;
     final Response response;
@@ -269,10 +302,31 @@ public Message(String string) {
     }
   }
 
+  static final class Ping {
+    public final ByteString payload;
+
+    public Ping(ByteString payload) {
+      this.payload = payload;
+    }
+
+    @Override public String toString() {
+      return "Ping[" + payload + "]";
+    }
+
+    @Override public int hashCode() {
+      return payload.hashCode();
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Ping
+          && ((Ping) other).payload.equals(payload);
+    }
+  }
+
   static final class Pong {
     public final ByteString payload;
 
-    Pong(ByteString payload) {
+    public Pong(ByteString payload) {
       this.payload = payload;
     }
 
@@ -284,12 +338,9 @@ public Message(String string) {
       return payload.hashCode();
     }
 
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Pong) {
-        Pong other = (Pong) obj;
-        return payload == null ? other.payload == null : payload.equals(other.payload);
-      }
-      return false;
+    @Override public boolean equals(Object other) {
+      return other instanceof Pong
+          && ((Pong) other).payload.equals(payload);
     }
   }
 
@@ -340,61 +391,4 @@ public Message(String string) {
           && ((Closed) other).reason.equals(reason);
     }
   }
-
-  /** Expose this recorder as a frame callback and shim in "ping" events. */
-  WebSocketReader.FrameCallback asFrameCallback() {
-    return new WebSocketReader.FrameCallback() {
-      @Override public void onReadMessage(ResponseBody body) throws IOException {
-        if (body.contentType().equals(WebSocket.TEXT)) {
-          String text = body.source().readUtf8();
-          onMessage(null, text);
-        } else if (body.contentType().equals(WebSocket.BINARY)) {
-          ByteString bytes = body.source().readByteString();
-          onMessage(null, bytes);
-        } else {
-          throw new IllegalArgumentException();
-        }
-      }
-
-      @Override public void onReadPing(ByteString payload) {
-        events.add(new Ping(payload));
-      }
-
-      @Override public void onReadPong(ByteString padload) {
-      }
-
-      @Override public void onReadClose(int code, String reason) {
-        onClosing(null, code, reason);
-      }
-    };
-  }
-
-  void assertPing(ByteString payload) {
-    Object actual = nextEvent();
-    assertEquals(new Ping(payload), actual);
-  }
-
-  static final class Ping {
-    public final ByteString buffer;
-
-    Ping(ByteString buffer) {
-      this.buffer = buffer;
-    }
-
-    @Override public String toString() {
-      return "Ping[" + buffer + "]";
-    }
-
-    @Override public int hashCode() {
-      return buffer.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Ping) {
-        Ping other = (Ping) obj;
-        return buffer == null ? other.buffer == null : buffer.equals(other.buffer);
-      }
-      return false;
-    }
-  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index 94c20d434b..580216b076 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -15,65 +15,58 @@
  */
 package okhttp3.internal.ws;
 
-import java.io.Closeable;
+import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
-import java.util.concurrent.Executor;
-import okhttp3.MediaType;
 import okhttp3.Protocol;
 import okhttp3.Request;
-import okhttp3.RequestBody;
 import okhttp3.Response;
-import okio.Buffer;
 import okio.BufferedSink;
-import okio.BufferedSource;
 import okio.ByteString;
 import okio.Okio;
-import okio.Sink;
-import okio.Source;
-import okio.Timeout;
+import okio.Pipe;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
-import static okhttp3.WebSocket.TEXT;
-import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
 
 public final class RealWebSocketTest {
   // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
   // zero effect on the behavior of the WebSocket API which is why tests are only written once
   // from the perspective of a single peer.
 
-  private final Executor clientExecutor = new SynchronousExecutor();
-  private RealWebSocket client;
+  private RealNewWebSocket client;
   private boolean clientConnectionCloseThrows;
   private boolean clientConnectionClosed;
-  private final MemorySocket client2Server = new MemorySocket();
-  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
+  private final Pipe client2Server = new Pipe(1024L);
+  private final BufferedSink client2ServerSink = Okio.buffer(client2Server.sink());
+  private final NewWebSocketRecorder clientListener = new NewWebSocketRecorder("client");
 
-  private final Executor serverExecutor = new SynchronousExecutor();
-  private RealWebSocket server;
+  private RealNewWebSocket server;
   private boolean serverConnectionClosed;
-  private final MemorySocket server2client = new MemorySocket();
-  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
+  private final Pipe server2client = new Pipe(1024L);
+  private final BufferedSink server2clientSink = Okio.buffer(server2client.sink());
+  private final NewWebSocketRecorder serverListener = new NewWebSocketRecorder("server");
 
-  @Before public void setUp() {
+  @Before public void setUp() throws IOException {
     Random random = new Random(0);
     String url = "http://example.com/websocket";
-    Response response = new Response.Builder()
+    final Response response = new Response.Builder()
         .code(101)
         .request(new Request.Builder().url(url).build())
         .protocol(Protocol.HTTP_1_1)
         .build();
 
-    client = new RealWebSocket(true, server2client.source(), client2Server.sink(), random,
-        clientExecutor, clientListener, response, url) {
-      @Override protected void shutdown() {
+    client = new RealNewWebSocket(response.request(), clientListener, random);
+    client.initReaderAndWriter(new RealNewWebSocket.Streams(
+        true, Okio.buffer(server2client.source()), client2ServerSink) {
+      @Override public void close() throws IOException {
+        source.close();
+        sink.close();
         if (clientConnectionClosed) {
           throw new AssertionError("Already closed");
         }
@@ -83,16 +76,20 @@
           throw new RuntimeException("Oops!");
         }
       }
-    };
-    server = new RealWebSocket(false, client2Server.source(), server2client.sink(), random,
-        serverExecutor, serverListener, response, url) {
-      @Override protected void shutdown() {
+    });
+
+    server = new RealNewWebSocket(response.request(), serverListener, random);
+    server.initReaderAndWriter(new RealNewWebSocket.Streams(
+        false, Okio.buffer(client2Server.source()), server2clientSink) {
+      @Override public void close() throws IOException {
+        source.close();
+        sink.close();
         if (serverConnectionClosed) {
           throw new AssertionError("Already closed");
         }
         serverConnectionClosed = true;
       }
-    };
+    });
   }
 
   @After public void tearDown() {
@@ -100,401 +97,202 @@
     serverListener.assertExhausted();
   }
 
-  @Test public void streamingMessage() throws IOException {
-    RequestBody message = new RequestBody() {
-      @Override public MediaType contentType() {
-        return TEXT;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("Hel").flush();
-        sink.writeUtf8("lo!").flush();
-        sink.close();
-      }
-    };
-    client.message(message);
-    server.processNextFrame();
-    serverListener.assertTextMessage("Hello!");
-  }
-
-  @Test public void streamingMessageCanInterleavePing() throws IOException {
-    RequestBody message = new RequestBody() {
-      @Override public MediaType contentType() {
-        return TEXT;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("Hel").flush();
-        client.ping(ByteString.encodeUtf8("Pong?"));
-        sink.writeUtf8("lo!").flush();
-        sink.close();
-      }
-    };
-
-    client.message(message);
-    server.processNextFrame();
-    serverListener.assertTextMessage("Hello!");
-    client.processNextFrame();
-    clientListener.assertPong(ByteString.encodeUtf8("Pong?"));
-  }
-
-  @Test public void pingWritesPong() throws IOException {
-    client.ping(ByteString.encodeUtf8("Hello!"));
-    server.processNextFrame(); // Read the ping, write the pong.
-    client.processNextFrame(); // Read the pong.
-    clientListener.assertPong(ByteString.encodeUtf8("Hello!"));
-  }
-
-  @Test public void unsolicitedPong() throws IOException {
-    client.pong(ByteString.encodeUtf8("Hello!"));
-    server.processNextFrame();
-    serverListener.assertPong(ByteString.encodeUtf8("Hello!"));
-  }
-
-  @Test public void nullPongPayloadThrows() throws IOException {
-    try {
-      client.pong(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertEquals("payload == null", e.getMessage());
-    }
-  }
-
   @Test public void close() throws IOException {
     client.close(1000, "Hello!");
     assertFalse(server.processNextFrame()); // This will trigger a close response.
-    serverListener.assertClose(1000, "Hello!");
+    serverListener.assertClosing(1000, "Hello!");
+    server.close(1000, "Goodbye!");
     assertFalse(client.processNextFrame());
-    clientListener.assertClose(1000, "Hello!");
+    clientListener.assertClosing(1000, "Goodbye!");
+    serverListener.assertClosed(1000, "Hello!");
+    clientListener.assertClosed(1000, "Goodbye!");
   }
 
-  @Test public void clientCloseThenMethodsThrow() throws IOException {
+  @Test public void clientCloseThenMethodsReturnFalse() throws IOException {
     client.close(1000, "Hello!");
 
-    try {
-      client.ping(ByteString.encodeUtf8("Pong?"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.close(1000, "Hello!");
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.message(RequestBody.create(TEXT, "Hello!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
+    assertFalse(client.close(1000, "Hello!"));
+    assertFalse(client.send("Hello!"));
   }
 
-  @Test public void socketClosedDuringPingKillsWebSocket() throws IOException {
-    client2Server.close();
+  @Test public void afterSocketClosedPingFailsWebSocket() throws IOException {
+    client2Server.source().close();
+    client.pong(ByteString.encodeUtf8("Ping!"));
+    clientListener.assertFailure(IOException.class, "source is closed");
 
-    try {
-      client.ping(ByteString.encodeUtf8("Ping!"));
-      fail();
-    } catch (IOException ignored) {
-    }
-
-    // A failed write prevents further use of the WebSocket instance.
-    try {
-      client.message(RequestBody.create(TEXT, "Hello!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("must call close()", e.getMessage());
-    }
-    try {
-      client.ping(ByteString.encodeUtf8("Ping!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("must call close()", e.getMessage());
-    }
+    assertFalse(client.send("Hello!"));
   }
 
   @Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {
-    client2Server.close();
+    client2Server.source().close();
 
-    try {
-      client.message(RequestBody.create(TEXT, "Hello!"));
-      fail();
-    } catch (IOException ignored) {
-    }
+    assertTrue(client.send("Hello!"));
+    clientListener.assertFailure(IOException.class, "source is closed");
 
     // A failed write prevents further use of the WebSocket instance.
-    try {
-      client.message(RequestBody.create(TEXT, "Hello!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("must call close()", e.getMessage());
-    }
-    try {
-      client.ping(ByteString.encodeUtf8("Ping!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("must call close()", e.getMessage());
-    }
+    assertFalse(client.send("Hello!"));
+    assertFalse(client.pong(ByteString.encodeUtf8("Ping!")));
   }
 
-  @Test public void serverCloseThenWritingPingThrows() throws IOException {
+  @Test public void serverCloseThenWritingPingSucceeds() throws IOException {
     server.close(1000, "Hello!");
     client.processNextFrame();
-    clientListener.assertClose(1000, "Hello!");
-
-    try {
-      client.ping(ByteString.encodeUtf8("Pong?"));
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
+    clientListener.assertClosing(1000, "Hello!");
+
+    assertTrue(client.pong(ByteString.encodeUtf8("Pong?")));
   }
 
-  @Test public void serverCloseThenWritingMessageThrows() throws IOException {
+  @Test public void clientCanWriteMessagesAfterServerClose() throws IOException {
     server.close(1000, "Hello!");
     client.processNextFrame();
-    clientListener.assertClose(1000, "Hello!");
-
-    try {
-      client.message(RequestBody.create(TEXT, "Hi!"));
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
+    clientListener.assertClosing(1000, "Hello!");
+
+    assertTrue(client.send("Hi!"));
+    server.processNextFrame();
+    serverListener.assertTextMessage("Hi!");
   }
 
   @Test public void serverCloseThenWritingCloseThrows() throws IOException {
     server.close(1000, "Hello!");
     client.processNextFrame();
-    clientListener.assertClose(1000, "Hello!");
-
-    try {
-      client.close(1000, "Bye!");
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-  }
-
-  @Test public void serverCloseWhileWritingThrows() throws IOException {
-    RequestBody message = new RequestBody() {
-      @Override public MediaType contentType() {
-        return TEXT;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        // Start writing data.
-        sink.writeUtf8("Hel").flush();
-
-        server.close(1000, "Hello!");
-        client.processNextFrame();
-        clientListener.assertClose(1000, "Hello!");
-
-        try {
-          sink.flush(); // No flushing.
-          fail();
-        } catch (IOException e) {
-          assertEquals("closed", e.getMessage());
-        }
-        try {
-          sink.close(); // No closing because this requires writing a frame.
-          fail();
-        } catch (IOException e) {
-          assertEquals("closed", e.getMessage());
-        }
-      }
-    };
-    client.message(message);
+    clientListener.assertClosing(1000, "Hello!");
+    assertTrue(client.close(1000, "Bye!"));
   }
 
   @Test public void clientCloseClosesConnection() throws IOException {
     client.close(1000, "Hello!");
     assertFalse(clientConnectionClosed);
-    server.processNextFrame(); // Read client close, send server close.
-    serverListener.assertClose(1000, "Hello!");
+    server.processNextFrame(); // Read client closing, send server close.
+    serverListener.assertClosing(1000, "Hello!");
 
-    client.processNextFrame(); // Read server close, close connection.
+    server.close(1000, "Goodbye!");
+    client.processNextFrame(); // Read server closing, close connection.
     assertTrue(clientConnectionClosed);
-    clientListener.assertClose(1000, "Hello!");
+    clientListener.assertClosing(1000, "Goodbye!");
+
+    // Server and client both finished closing, connection is closed.
+    serverListener.assertClosed(1000, "Hello!");
+    clientListener.assertClosed(1000, "Goodbye!");
   }
 
   @Test public void serverCloseClosesConnection() throws IOException {
     server.close(1000, "Hello!");
 
     client.processNextFrame(); // Read server close, send client close, close connection.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClose(1000, "Hello!");
+    assertFalse(clientConnectionClosed);
+    clientListener.assertClosing(1000, "Hello!");
 
+    client.close(1000, "Hello!");
     server.processNextFrame();
-    serverListener.assertClose(1000, "Hello!");
+    serverListener.assertClosing(1000, "Hello!");
+
+    clientListener.assertClosed(1000, "Hello!");
+    serverListener.assertClosed(1000, "Hello!");
   }
 
   @Test public void clientAndServerCloseClosesConnection() throws IOException {
     // Send close from both sides at the same time.
     server.close(1000, "Hello!");
-    client.close(1000, "Hi!");
-    assertFalse(clientConnectionClosed);
-
     client.processNextFrame(); // Read close, close connection close.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClose(1000, "Hello!");
 
+    assertFalse(clientConnectionClosed);
+    client.close(1000, "Hi!");
     server.processNextFrame();
-    serverListener.assertClose(1000, "Hi!");
+
+    clientListener.assertClosing(1000, "Hello!");
+    serverListener.assertClosing(1000, "Hi!");
+    clientListener.assertClosed(1000, "Hello!");
+    serverListener.assertClosed(1000, "Hi!");
+    assertTrue(clientConnectionClosed);
 
     serverListener.assertExhausted(); // Client should not have sent second close.
     clientListener.assertExhausted(); // Server should not have sent second close.
   }
 
   @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
-    server.message(RequestBody.create(TEXT, "Hello!"));
+    server.send("Hello!");
     server.close(1000, "Bye!");
     assertTrue(client.processNextFrame());
     clientListener.assertTextMessage("Hello!");
     assertFalse(client.processNextFrame());
-    clientListener.assertClose(1000, "Bye!");
+    clientListener.assertClosing(1000, "Bye!");
   }
 
-  @Test public void protocolErrorBeforeCloseSendsClose() {
-    server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
+  @Test public void protocolErrorBeforeCloseSendsFailure() throws IOException {
+    server2clientSink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
 
     client.processNextFrame(); // Detects error, send close, close connection.
     assertTrue(clientConnectionClosed);
     clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
     server.processNextFrame();
-    serverListener.assertClose(1002, "");
+    serverListener.assertFailure(EOFException.class, null);
   }
 
   @Test public void protocolErrorInCloseResponseClosesConnection() throws IOException {
     client.close(1000, "Hello");
+    server.processNextFrame();
     assertFalse(clientConnectionClosed); // Not closed until close reply is received.
 
     // Manually write an invalid masked close frame.
-    server2client.raw().write(ByteString.decodeHex("888760b420bb635c68de0cd84f"));
+    server2clientSink.write(ByteString.decodeHex("888760b420bb635c68de0cd84f")).emit();
 
     client.processNextFrame(); // Detects error, closes connection immediately since close already sent.
     assertTrue(clientConnectionClosed);
     clientListener.assertFailure(ProtocolException.class, "Server-sent frames must not be masked.");
 
-    server.processNextFrame();
-    serverListener.assertClose(1000, "Hello");
-
+    serverListener.assertClosing(1000, "Hello");
     serverListener.assertExhausted(); // Client should not have sent second close.
   }
 
   @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
     client.close(1000, "Hello!");
+    server.processNextFrame();
+
     assertFalse(clientConnectionClosed); // Not closed until close reply is received.
-    server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
+    server2clientSink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
 
     client.processNextFrame(); // Detects error, closes connection immediately since close already sent.
     assertTrue(clientConnectionClosed);
     clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
-    server.processNextFrame();
-    serverListener.assertClose(1000, "Hello!");
+    serverListener.assertClosing(1000, "Hello!");
 
     serverListener.assertExhausted(); // Client should not have sent second close.
   }
 
-  @Test public void networkErrorReportedAsCloseNotFailure() {
-    server2client.close();
+  @Test public void networkErrorReportedAsFailure() throws IOException {
+    server2clientSink.close();
     client.processNextFrame();
-    clientListener.assertClose(1006, "");
+    clientListener.assertFailure(EOFException.class, null);
   }
 
-  @Test public void closeThrowingClosesConnection() {
-    client2Server.close();
-
-    try {
-      client.close(1000, null);
-      fail();
-    } catch (IOException ignored) {
-    }
-    assertTrue(clientConnectionClosed);
+  @Test public void closeThrowingFailsConnection() throws IOException {
+    client2Server.source().close();
+    client.close(1000, null);
+    clientListener.assertFailure(IOException.class, "source is closed");
   }
 
-  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() {
-    client2Server.close();
+  @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
+  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {
+    client2ServerSink.close();
     clientConnectionCloseThrows = true;
 
-    try {
-      client.close(1000, "Bye!");
-      fail();
-    } catch (IOException e) {
-      assertNotEquals("Oops!", e.getMessage());
-    }
+    client.close(1000, "Bye!");
+    clientListener.assertFailure(IOException.class, "failure");
     assertTrue(clientConnectionClosed);
   }
 
-  @Test public void peerConnectionCloseThrowingDoesNotPropagate() throws IOException {
+  @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
+  @Test public void peerConnectionCloseThrowingPropagates() throws IOException {
     clientConnectionCloseThrows = true;
 
-    server.close(1000, "Bye!");
+    server.close(1000, "Bye from Server!");
     client.processNextFrame();
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClose(1000, "Bye!");
+    clientListener.assertClosing(1000, "Bye from Server!");
 
+    client.close(1000, "Bye from Client!");
     server.processNextFrame();
-    serverListener.assertClose(1000, "Bye!");
-  }
-
-  static final class MemorySocket implements Closeable {
-    private final Buffer buffer = new Buffer();
-    private boolean closed;
-
-    @Override public void close() {
-      closed = true;
-    }
-
-    Buffer raw() {
-      return buffer;
-    }
-
-    BufferedSource source() {
-      return Okio.buffer(new Source() {
-        @Override public long read(Buffer sink, long byteCount) throws IOException {
-          if (closed) throw new IOException("closed");
-          return buffer.read(sink, byteCount);
-        }
-
-        @Override public Timeout timeout() {
-          return Timeout.NONE;
-        }
-
-        @Override public void close() {
-          closed = true;
-        }
-      });
-    }
-
-    BufferedSink sink() {
-      return Okio.buffer(new Sink() {
-        @Override public void write(Buffer source, long byteCount) throws IOException {
-          if (closed) throw new IOException("closed");
-          buffer.write(source, byteCount);
-        }
-
-        @Override public void flush() {
-        }
-
-        @Override public Timeout timeout() {
-          return Timeout.NONE;
-        }
-
-        @Override public void close() {
-          closed = true;
-        }
-      });
-    }
-  }
-
-  static final class SynchronousExecutor implements Executor {
-    @Override public void execute(Runnable command) {
-      command.run();
-    }
+    serverListener.assertClosing(1000, "Bye from Client!");
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index f1ae34e51f..e88f132eea 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -19,24 +19,20 @@
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
-import java.util.concurrent.atomic.AtomicReference;
 import java.util.regex.Pattern;
-import okhttp3.ResponseBody;
 import okhttp3.internal.Util;
 import okio.Buffer;
-import okio.BufferedSource;
 import okio.ByteString;
 import org.junit.After;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class WebSocketReaderTest {
   private final Buffer data = new Buffer();
-  private final WebSocketRecorder callback = new WebSocketRecorder("client");
+  private final NewWebSocketRecorder callback = new NewWebSocketRecorder("client");
   private final Random random = new Random(0);
 
   // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
@@ -149,20 +145,11 @@
 
   @Test public void serverHelloTwoChunks() throws IOException {
     data.write(ByteString.decodeHex("818537fa213d7f9f4d")); // Hel
+    data.write(ByteString.decodeHex("5158")); // lo
 
-    final Buffer sink = new Buffer();
-    callback.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        BufferedSource source = message.source();
-        source.readFully(sink, 3); // Read "Hel"
-        data.write(ByteString.decodeHex("5158")); // lo
-        source.readFully(sink, 2); // Read "lo"
-        source.close();
-      }
-    });
     serverReader.processNextFrame();
 
-    assertEquals("Hello", sink.readUtf8());
+    callback.assertTextMessage("Hello");
   }
 
   @Test public void clientTwoFrameHello() throws IOException {
@@ -250,84 +237,6 @@
     }
   }
 
-  @Test public void noCloseErrors() throws IOException {
-    data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
-    callback.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onMessage(ResponseBody body) throws IOException {
-        body.source().readAll(new Buffer());
-      }
-    });
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("Listener failed to call close on message payload.", e.getMessage());
-    }
-  }
-
-  @Test public void closeExhaustsMessage() throws IOException {
-    data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
-    data.write(ByteString.decodeHex("810448657921")); // Hey!
-
-    final Buffer sink = new Buffer();
-    callback.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        message.source().read(sink, 3);
-        message.close();
-      }
-    });
-
-    clientReader.processNextFrame();
-    assertEquals("Hel", sink.readUtf8());
-
-    clientReader.processNextFrame();
-    callback.assertTextMessage("Hey!");
-  }
-
-  @Test public void closeExhaustsMessageOverControlFrames() throws IOException {
-    data.write(ByteString.decodeHex("010348656c")); // Hel
-    data.write(ByteString.decodeHex("8a00")); // Pong
-    data.write(ByteString.decodeHex("8a00")); // Pong
-    data.write(ByteString.decodeHex("80026c6f")); // lo
-    data.write(ByteString.decodeHex("810448657921")); // Hey!
-
-    final Buffer sink = new Buffer();
-    callback.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        message.source().read(sink, 2);
-        message.close();
-      }
-    });
-
-    clientReader.processNextFrame();
-    assertEquals("He", sink.readUtf8());
-    callback.assertPong(ByteString.EMPTY);
-    callback.assertPong(ByteString.EMPTY);
-
-    clientReader.processNextFrame();
-    callback.assertTextMessage("Hey!");
-  }
-
-  @Test public void closedMessageSourceThrows() throws IOException {
-    data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
-
-    final AtomicReference<Exception> exception = new AtomicReference<>();
-    callback.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        message.close();
-        try {
-          message.source().readAll(new Buffer());
-          fail();
-        } catch (IllegalStateException e) {
-          exception.set(e);
-        }
-      }
-    });
-    clientReader.processNextFrame();
-
-    assertNotNull(exception.get());
-  }
-
   @Test public void emptyPingCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("8900")); // Empty ping
     clientReader.processNextFrame();
@@ -343,7 +252,7 @@
   @Test public void emptyCloseCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("8800")); // Empty close
     clientReader.processNextFrame();
-    callback.assertClose(1005, "");
+    callback.assertClosing(1005, "");
   }
 
   @Test public void closeLengthOfOneThrows() throws IOException {
@@ -359,7 +268,7 @@
   @Test public void closeCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("880703e848656c6c6f")); // Close with code and reason
     clientReader.processNextFrame();
-    callback.assertClose(1000, "Hello");
+    callback.assertClosing(1000, "Hello");
   }
 
   @Test public void closeOutOfRangeThrows() throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
deleted file mode 100644
index 91510cdf56..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
+++ /dev/null
@@ -1,354 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.IOException;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import okhttp3.MediaType;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.WebSocket;
-import okhttp3.WebSocketListener;
-import okhttp3.internal.platform.Platform;
-import okio.Buffer;
-import okio.ByteString;
-
-import static okhttp3.WebSocket.BINARY;
-import static okhttp3.WebSocket.TEXT;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-
-public final class WebSocketRecorder implements WebSocketListener {
-  private final String name;
-  private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
-  private WebSocketListener delegate;
-
-  public WebSocketRecorder(String name) {
-    this.name = name;
-  }
-
-  /** Sets a delegate for handling the next callback to this listener. Cleared after invoked. */
-  public void setNextEventDelegate(WebSocketListener delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override public void onOpen(WebSocket webSocket, Response response) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onOpen", null);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onOpen(webSocket, response);
-    } else {
-      events.add(new Open(webSocket, response));
-    }
-  }
-
-  @Override public void onMessage(ResponseBody message) throws IOException {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onMessage", null);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onMessage(message);
-    } else {
-      Message event = new Message(message.contentType());
-      message.source().readAll(event.buffer);
-      message.close();
-      events.add(event);
-    }
-  }
-
-  @Override public void onPong(ByteString payload) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onPong", null);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onPong(payload);
-    } else {
-      events.add(new Pong(payload));
-    }
-  }
-
-  @Override public void onClose(int code, String reason) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onClose " + code, null);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onClose(code, reason);
-    } else {
-      events.add(new Close(code, reason));
-    }
-  }
-
-  @Override public void onFailure(Throwable t, Response response) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onFailure", t);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onFailure(t, response);
-    } else {
-      events.add(new Failure(t, response));
-    }
-  }
-
-  private Object nextEvent() {
-    try {
-      Object event = events.poll(10, TimeUnit.SECONDS);
-      if (event == null) {
-        throw new AssertionError("Timed out waiting for event.");
-      }
-      return event;
-    } catch (InterruptedException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  public void assertTextMessage(String payload) {
-    Message message = new Message(TEXT);
-    message.buffer.writeUtf8(payload);
-    Object actual = nextEvent();
-    assertEquals(message, actual);
-  }
-
-  public void assertBinaryMessage(byte[] payload) {
-    Message message = new Message(BINARY);
-    message.buffer.write(payload);
-    Object actual = nextEvent();
-    assertEquals(message, actual);
-  }
-
-  public void assertPong(ByteString payload) {
-    Object actual = nextEvent();
-    assertEquals(new Pong(payload), actual);
-  }
-
-  public void assertClose(int code, String reason) {
-    Object actual = nextEvent();
-    assertEquals(new Close(code, reason), actual);
-  }
-
-  public void assertExhausted() {
-    assertTrue("Remaining events: " + events, events.isEmpty());
-  }
-
-  public WebSocket assertOpen() {
-    Object event = nextEvent();
-    if (!(event instanceof Open)) {
-      throw new AssertionError("Expected Open but was " + event);
-    }
-    return ((Open) event).webSocket;
-  }
-
-  public void assertFailure(Throwable t) {
-    Object event = nextEvent();
-    if (!(event instanceof Failure)) {
-      throw new AssertionError("Expected Failure but was " + event);
-    }
-    Failure failure = (Failure) event;
-    assertNull(failure.response);
-    assertSame(t, failure.t);
-  }
-
-  public void assertFailure(Class<? extends IOException> cls, String message) {
-    Object event = nextEvent();
-    if (!(event instanceof Failure)) {
-      throw new AssertionError("Expected Failure but was " + event);
-    }
-    Failure failure = (Failure) event;
-    assertNull(failure.response);
-    assertEquals(cls, failure.t.getClass());
-    assertEquals(message, failure.t.getMessage());
-  }
-
-  public void assertFailure(int code, String body, Class<? extends IOException> cls, String message)
-      throws IOException {
-    Object event = nextEvent();
-    if (!(event instanceof Failure)) {
-      throw new AssertionError("Expected Failure but was " + event);
-    }
-    Failure failure = (Failure) event;
-    assertEquals(code, failure.response.code());
-    if (body != null) {
-      assertEquals(body, failure.response.body().string());
-    }
-    assertEquals(cls, failure.t.getClass());
-    assertEquals(message, failure.t.getMessage());
-  }
-
-  static final class Open {
-    final WebSocket webSocket;
-    final Response response;
-
-    Open(WebSocket webSocket, Response response) {
-      this.webSocket = webSocket;
-      this.response = response;
-    }
-
-    @Override public String toString() {
-      return "Open[" + response + "]";
-    }
-  }
-
-  static final class Failure {
-    final Throwable t;
-    final Response response;
-
-    Failure(Throwable t, Response response) {
-      this.t = t;
-      this.response = response;
-    }
-
-    @Override public String toString() {
-      if (response == null) {
-        return "Failure[" + t + "]";
-      }
-      return "Failure[" + response + "]";
-    }
-  }
-
-  static final class Message {
-    public final MediaType mediaType;
-    public final Buffer buffer = new Buffer();
-
-    Message(MediaType mediaType) {
-      this.mediaType = mediaType;
-    }
-
-    @Override public String toString() {
-      return "Message[" + mediaType + " " + buffer + "]";
-    }
-
-    @Override public int hashCode() {
-      return mediaType.hashCode() * 37 + buffer.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Message) {
-        Message other = (Message) obj;
-        return mediaType.equals(other.mediaType) && buffer.equals(other.buffer);
-      }
-      return false;
-    }
-  }
-
-  static final class Pong {
-    public final ByteString payload;
-
-    Pong(ByteString payload) {
-      this.payload = payload;
-    }
-
-    @Override public String toString() {
-      return "Pong[" + payload + "]";
-    }
-
-    @Override public int hashCode() {
-      return payload.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Pong) {
-        Pong other = (Pong) obj;
-        return payload == null ? other.payload == null : payload.equals(other.payload);
-      }
-      return false;
-    }
-  }
-
-  static final class Close {
-    public final int code;
-    public final String reason;
-
-    Close(int code, String reason) {
-      this.code = code;
-      this.reason = reason;
-    }
-
-    @Override public String toString() {
-      return "Close[" + code + " " + reason + "]";
-    }
-
-    @Override public int hashCode() {
-      return code * 37 + reason.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Close) {
-        Close other = (Close) obj;
-        return code == other.code && reason.equals(other.reason);
-      }
-      return false;
-    }
-  }
-
-  /** Expose this recorder as a frame callback and shim in "ping" events. */
-  WebSocketReader.FrameCallback asFrameCallback() {
-    return new WebSocketReader.FrameCallback() {
-      @Override public void onReadMessage(ResponseBody body) throws IOException {
-        onMessage(body);
-      }
-
-      @Override public void onReadPing(ByteString payload) {
-        events.add(new Ping(payload));
-      }
-
-      @Override public void onReadPong(ByteString padload) {
-        onPong(padload);
-      }
-
-      @Override public void onReadClose(int code, String reason) {
-        onClose(code, reason);
-      }
-    };
-  }
-
-  void assertPing(ByteString payload) {
-    Object actual = nextEvent();
-    assertEquals(new Ping(payload), actual);
-  }
-
-  static final class Ping {
-    public final ByteString buffer;
-
-    Ping(ByteString buffer) {
-      this.buffer = buffer;
-    }
-
-    @Override public String toString() {
-      return "Ping[" + buffer + "]";
-    }
-
-    @Override public int hashCode() {
-      return buffer.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Ping) {
-        Ping other = (Ping) obj;
-        return buffer == null ? other.buffer == null : buffer.equals(other.buffer);
-      }
-      return false;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 91160a56f1..a22e7e4484 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -117,8 +117,7 @@
  * <p>OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
  * remain idle.
  */
-public class OkHttpClient
-    implements Cloneable, Call.Factory, WebSocketCall.Factory, NewWebSocket.Factory {
+public class OkHttpClient implements Cloneable, Call.Factory, NewWebSocket.Factory {
   private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
       Protocol.HTTP_2, Protocol.HTTP_1_1);
 
@@ -391,19 +390,12 @@ public Dispatcher dispatcher() {
     return new RealCall(this, request, false /* for web socket */);
   }
 
-  /**
-   * Prepares the {@code request} to create a web socket at some point in the future.
-   */
-  @Override public WebSocketCall newWebSocketCall(Request request) {
-    return new RealWebSocketCall(this, request);
-  }
-
   /**
    * Uses {@code request} to connect a new web socket.
    */
   @Override public NewWebSocket newWebSocket(Request request, NewWebSocket.Listener listener) {
-    RealNewWebSocket webSocket = new RealNewWebSocket(this, request, listener, new SecureRandom());
-    webSocket.connnect();
+    RealNewWebSocket webSocket = new RealNewWebSocket(request, listener, new SecureRandom());
+    webSocket.connect(this);
     return webSocket;
   }
 
diff --git a/okhttp/src/main/java/okhttp3/RealWebSocketCall.java b/okhttp/src/main/java/okhttp3/RealWebSocketCall.java
deleted file mode 100644
index da65db1c4b..0000000000
--- a/okhttp/src/main/java/okhttp3/RealWebSocketCall.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.security.SecureRandom;
-import java.util.Collections;
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.LinkedBlockingDeque;
-import java.util.concurrent.ThreadPoolExecutor;
-import okhttp3.internal.Util;
-import okhttp3.internal.connection.StreamAllocation;
-import okhttp3.internal.ws.RealWebSocket;
-import okhttp3.internal.ws.WebSocketProtocol;
-import okio.ByteString;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-
-final class RealWebSocketCall implements WebSocketCall {
-  private static final List<Protocol> ONLY_HTTP1 = Collections.singletonList(Protocol.HTTP_1_1);
-
-  /** The application's original request unadulterated by web socket headers. */
-  private final Request originalRequest;
-  private final RealCall call;
-  private final Random random;
-  private final String key;
-
-  RealWebSocketCall(OkHttpClient client, Request request) {
-    this(client, request, new SecureRandom());
-  }
-
-  RealWebSocketCall(OkHttpClient client, Request request, Random random) {
-    if (!"GET".equals(request.method())) {
-      throw new IllegalArgumentException("Request must be GET: " + request.method());
-    }
-    this.random = random;
-
-    byte[] nonce = new byte[16];
-    random.nextBytes(nonce);
-    key = ByteString.of(nonce).base64();
-
-    client = client.newBuilder()
-        .readTimeout(0, SECONDS) // i.e., no timeout because this is a long-lived connection.
-        .writeTimeout(0, SECONDS) // i.e., no timeout because this is a long-lived connection.
-        .protocols(ONLY_HTTP1)
-        .build();
-
-    originalRequest = request;
-    request = request.newBuilder()
-        .header("Upgrade", "websocket")
-        .header("Connection", "Upgrade")
-        .header("Sec-WebSocket-Key", key)
-        .header("Sec-WebSocket-Version", "13")
-        .build();
-
-    call = new RealCall(client, request, true /* for web socket */);
-  }
-
-  @Override public void enqueue(final WebSocketListener listener) {
-    Callback responseCallback = new Callback() {
-      @Override public void onResponse(Call call, Response response) {
-        StreamWebSocket webSocket;
-        try {
-          webSocket = create(response, listener);
-        } catch (IOException e) {
-          listener.onFailure(e, response);
-          return;
-        }
-
-        webSocket.loopReader();
-      }
-
-      @Override public void onFailure(Call call, IOException e) {
-        listener.onFailure(e, null);
-      }
-    };
-    call.enqueue(responseCallback);
-  }
-
-  StreamWebSocket create(Response response, WebSocketListener listener) throws IOException {
-    if (response.code() != 101) {
-      throw new ProtocolException("Expected HTTP 101 response but was '"
-          + response.code()
-          + " "
-          + response.message()
-          + "'");
-    }
-
-    String headerConnection = response.header("Connection");
-    if (!"Upgrade".equalsIgnoreCase(headerConnection)) {
-      throw new ProtocolException(
-          "Expected 'Connection' header value 'Upgrade' but was '" + headerConnection + "'");
-    }
-    String headerUpgrade = response.header("Upgrade");
-    if (!"websocket".equalsIgnoreCase(headerUpgrade)) {
-      throw new ProtocolException(
-          "Expected 'Upgrade' header value 'websocket' but was '" + headerUpgrade + "'");
-    }
-    String headerAccept = response.header("Sec-WebSocket-Accept");
-    String acceptExpected = WebSocketProtocol.acceptHeader(key);
-    if (!acceptExpected.equals(headerAccept)) {
-      throw new ProtocolException("Expected 'Sec-WebSocket-Accept' header value '"
-          + acceptExpected
-          + "' but was '"
-          + headerAccept
-          + "'");
-    }
-
-    String name = response.request().url().redact().toString();
-    ThreadPoolExecutor replyExecutor =
-        new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-            Util.threadFactory(Util.format("OkHttp %s WebSocket Replier", name), true));
-    replyExecutor.allowCoreThreadTimeOut(true);
-
-    StreamAllocation streamAllocation = call.streamAllocation();
-    streamAllocation.noNewStreams(); // Web socket connections can't be re-used.
-    return new StreamWebSocket(streamAllocation, random, replyExecutor, listener, response, name);
-  }
-
-  @Override public Request request() {
-    return originalRequest;
-  }
-
-  @Override public void cancel() {
-    call.cancel();
-  }
-
-  @Override public boolean isExecuted() {
-    return call.isExecuted();
-  }
-
-  @Override public boolean isCanceled() {
-    return call.isCanceled();
-  }
-
-  @Override public WebSocketCall clone() {
-    return new RealWebSocketCall(call.client, originalRequest, random);
-  }
-
-  // Keep static so that the WebSocketCall instance can be garbage collected.
-  static final class StreamWebSocket extends RealWebSocket {
-    private final StreamAllocation streamAllocation;
-    private final ExecutorService executor;
-
-    StreamWebSocket(StreamAllocation streamAllocation, Random random, ExecutorService executor,
-        WebSocketListener listener, Response response, String name) {
-      super(true /* is client */, streamAllocation.connection().source,
-          streamAllocation.connection().sink, random, executor, listener, response, name);
-      this.streamAllocation = streamAllocation;
-      this.executor = executor;
-    }
-
-    @Override protected void shutdown() {
-      executor.shutdown();
-      streamAllocation.streamFinished(true, streamAllocation.codec());
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/WebSocket.java b/okhttp/src/main/java/okhttp3/WebSocket.java
deleted file mode 100644
index 35b02f2503..0000000000
--- a/okhttp/src/main/java/okhttp3/WebSocket.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import okio.ByteString;
-
-/** Blocking interface to connect and write to a web socket. This class is not thread safe. */
-public interface WebSocket {
-  /** A {@link MediaType} indicating UTF-8 text frames should be used when sending the message. */
-  MediaType TEXT = MediaType.parse("application/vnd.okhttp.websocket+text; charset=utf-8");
-  /** A {@link MediaType} indicating binary frames should be used when sending the message. */
-  MediaType BINARY = MediaType.parse("application/vnd.okhttp.websocket+binary");
-
-  /**
-   * Send a message to the server.
-   *
-   * @param message The message body. The {@linkplain RequestBody#contentType() content type} of
-   * must be either {@link #TEXT} or {@link #BINARY}.
-   * @throws IOException if unable to write the message. Clients must call {@link #close} when this
-   * happens to ensure resources are cleaned up.
-   * @throws IllegalStateException if this web socket was already closed.
-   */
-  void message(RequestBody message) throws IOException;
-
-  /**
-   * Send a ping to the server.
-   *
-   * @param payload Ping payload which must not exceed 125 bytes. Use {@link ByteString#EMPTY} for
-   * no payload.
-   * @throws IOException if unable to write the ping.  Clients must call {@link #close} when this
-   * happens to ensure resources are cleaned up.
-   * @throws IllegalStateException if this web socket was already closed.
-   */
-  void ping(ByteString payload) throws IOException;
-
-  /**
-   * Send a close indicator to the server.
-   *
-   * <p>The corresponding {@link WebSocketListener} will continue to get messages until its {@link
-   * WebSocketListener#onClose onClose()} method is called.
-   *
-   * <p>It is an error to call this method before calling close on an active writer. Calling this
-   * method more than once has no effect.
-   *
-   * @param code Status code as defined by <a
-   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
-   * @param reason Reason for shutting down or {@code null}.
-   * @throws IOException if unable to write the close message. Resources will still be freed.
-   * @throws IllegalStateException if this web socket was already closed.
-   */
-  void close(int code, String reason) throws IOException;
-}
diff --git a/okhttp/src/main/java/okhttp3/WebSocketCall.java b/okhttp/src/main/java/okhttp3/WebSocketCall.java
deleted file mode 100644
index 3dc18bcba4..0000000000
--- a/okhttp/src/main/java/okhttp3/WebSocketCall.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-public interface WebSocketCall extends Cloneable {
-  /** Returns the original request that initiated this call. */
-  Request request();
-
-  /**
-   * Schedules the request to be executed at some point in the future.
-   *
-   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
-   * immediately unless there are several other requests currently being executed.
-   *
-   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
-   * failure exception. If you {@link #cancel} a request before it completes the callback will not
-   * be invoked.
-   *
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  void enqueue(WebSocketListener listener);
-
-  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
-  void cancel();
-
-  /**
-   * Returns true if this call has been {@linkplain #enqueue(WebSocketListener) enqueued}. It is an
-   * error to enqueue a call more than once.
-   */
-  boolean isExecuted();
-
-  boolean isCanceled();
-
-  /**
-   * Create a new, identical call to this one which can be enqueued even if this call has already
-   * been.
-   */
-  WebSocketCall clone();
-
-  interface Factory {
-    WebSocketCall newWebSocketCall(Request request);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/WebSocketListener.java b/okhttp/src/main/java/okhttp3/WebSocketListener.java
deleted file mode 100644
index 8d853f7d93..0000000000
--- a/okhttp/src/main/java/okhttp3/WebSocketListener.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import okio.ByteString;
-
-/**
- * Listener for server-initiated messages on a connected {@link WebSocket}. All callbacks will be
- * called on a single thread.
- *
- * <h2>Lifecycle Rules</h2>
- * <ul>
- * <li>Either {@link #onOpen} or {@link #onFailure} will be called first depending on if the web
- * socket was successfully opened or if there was an error connecting to the server or parsing its
- * response.</li>
- * <li>After {@link #onOpen} is called, {@link #onFailure} can be called at any time. No more
- * callbacks will follow a call to {@link #onFailure}.</li>
- * <li>After {@link #onOpen} is called, {@link #onMessage} and {@link #onPong} will be called for
- * each message and pong frame, respectively. Note: {@link #onPong} may be called while {@link
- * #onMessage} is reading the message because pong frames may interleave in the message body.</li>
- * <li>After {@link #onOpen} is called, {@link #onClose} may be called once. No calls to {@link
- * #onMessage} or {@link #onPong} will follow a call to {@link #onClose}.</li>
- * <li>{@link #onFailure} will be called if any of the other callbacks throws an exception.</li>
- * </ul>
- */
-public interface WebSocketListener {
-  /**
-   * Called when the request has successfully been upgraded to a web socket. <b>Do not</b> use this
-   * callback to write to the web socket. Start a new thread or use another thread in your
-   * application.
-   */
-  void onOpen(WebSocket webSocket, Response response);
-
-  /**
-   * Called when a server message is received. The {@code type} indicates whether the {@code
-   * payload} should be interpreted as UTF-8 text or binary data.
-   *
-   * <p>Implementations <strong>must</strong> call {@code source.close()} before returning. This
-   * indicates completion of parsing the message payload and will consume any remaining bytes in the
-   * message.
-   *
-   * <p>The {@linkplain ResponseBody#contentType() content type} of {@code message} will be either
-   * {@link WebSocket#TEXT} or {@link WebSocket#BINARY} which indicates the format of the message.
-   */
-  void onMessage(ResponseBody message) throws IOException;
-
-  /**
-   * Called when a server pong is received. This is usually a result of calling {@link
-   * WebSocket#ping(ByteString)} but might also be unsolicited directly from the server.
-   */
-  void onPong(ByteString payload);
-
-  /**
-   * Called when the server sends a close message. This may have been initiated from a call to
-   * {@link WebSocket#close(int, String) close()} or as an unprompted message from the server.
-   * If you did not explicitly call {@link WebSocket#close(int, String) close()}, you do not need
-   * to do so in response to this callback. A matching close frame is automatically sent back to
-   * the server.
-   *
-   * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC-compliant</a>
-   * status code.
-   * @param reason Reason for close or an empty string.
-   */
-  void onClose(int code, String reason);
-
-  /**
-   * Called when the transport or protocol layer of this web socket errors during communication, or
-   * when another listener callback throws an exception. If the web socket was successfully
-   * {@linkplain #onOpen opened} before this callback, it will have been closed automatically and
-   * future interactions with it will throw {@link IOException}.
-   *
-   * @param response Non-null when the failure is because of an unexpected HTTP response (e.g.,
-   * failed upgrade, non-101 response code, etc.).
-   */
-  void onFailure(Throwable t, Response response);
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 73b2506f62..b78e3c54b1 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -28,6 +28,7 @@
 import okhttp3.internal.http1.Http1Codec;
 import okhttp3.internal.http2.ErrorCode;
 import okhttp3.internal.http2.Http2Codec;
+import okhttp3.internal.http2.ConnectionShutdownException;
 import okhttp3.internal.http2.StreamResetException;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -298,7 +299,8 @@ public void streamFailed(IOException e) {
           noNewStreams = true;
           route = null;
         }
-      } else if (connection != null && !connection.isMultiplexed()) {
+      } else if (connection != null && !connection.isMultiplexed()
+          || e instanceof ConnectionShutdownException) {
         noNewStreams = true;
 
         // If this route hasn't completed a call, avoid it for new connections.
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 2a7cd13822..792ddc9299 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -38,6 +38,7 @@
 import okhttp3.Route;
 import okhttp3.internal.connection.RouteException;
 import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http2.ConnectionShutdownException;
 
 import static java.net.HttpURLConnection.HTTP_CLIENT_TIMEOUT;
 import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
@@ -120,12 +121,15 @@ public StreamAllocation streamAllocation() {
         releaseConnection = false;
       } catch (RouteException e) {
         // The attempt to connect via a route failed. The request will not have been sent.
-        if (!recover(e.getLastConnectException(), true, request)) throw e.getLastConnectException();
+        if (!recover(e.getLastConnectException(), false, request)) {
+          throw e.getLastConnectException();
+        }
         releaseConnection = false;
         continue;
       } catch (IOException e) {
         // An attempt to communicate with a server failed. The request may have been sent.
-        if (!recover(e, false, request)) throw e;
+        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
+        if (!recover(e, requestSendStarted, request)) throw e;
         releaseConnection = false;
         continue;
       } finally {
@@ -198,19 +202,20 @@ private Address createAddress(HttpUrl url) {
   /**
    * Report and attempt to recover from a failure to communicate with a server. Returns true if
    * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only
-   * be recovered if the body is buffered.
+   * be recovered if the body is buffered or if the failure occurred before the request has been
+   * sent.
    */
-  private boolean recover(IOException e, boolean routeException, Request userRequest) {
+  private boolean recover(IOException e, boolean requestSendStarted, Request userRequest) {
     streamAllocation.streamFailed(e);
 
     // The application layer has forbidden retries.
     if (!client.retryOnConnectionFailure()) return false;
 
     // We can't send the request body again.
-    if (!routeException && userRequest.body() instanceof UnrepeatableRequestBody) return false;
+    if (requestSendStarted && userRequest.body() instanceof UnrepeatableRequestBody) return false;
 
     // This exception is fatal.
-    if (!isRecoverable(e, routeException)) return false;
+    if (!isRecoverable(e, requestSendStarted)) return false;
 
     // No more routes to attempt.
     if (!streamAllocation.hasMoreRoutes()) return false;
@@ -219,7 +224,7 @@ private boolean recover(IOException e, boolean routeException, Request userReque
     return true;
   }
 
-  private boolean isRecoverable(IOException e, boolean routeException) {
+  private boolean isRecoverable(IOException e, boolean requestSendStarted) {
     // If there was a protocol problem, don't recover.
     if (e instanceof ProtocolException) {
       return false;
@@ -228,7 +233,7 @@ private boolean isRecoverable(IOException e, boolean routeException) {
     // If there was an interruption don't recover, but if there was a timeout connecting to a route
     // we should try the next route (if there is one).
     if (e instanceof InterruptedIOException) {
-      return e instanceof SocketTimeoutException && routeException;
+      return e instanceof SocketTimeoutException && !requestSendStarted;
     }
 
     // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java b/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java
new file mode 100644
index 0000000000..00c4f2441c
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+
+/**
+ * Thrown when an HTTP/2 connection is shutdown (either explicitly or if the peer has sent a GOAWAY
+ * frame) and an attempt is made to use the connection.
+ */
+public final class ConnectionShutdownException extends IOException {
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index daf1b78671..2ca5e0cbac 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -216,7 +216,7 @@ private Http2Stream newStream(
     synchronized (writer) {
       synchronized (this) {
         if (shutdown) {
-          throw new IOException("shutdown");
+          throw new ConnectionShutdownException();
         }
         streamId = nextStreamId;
         nextStreamId += 2;
@@ -335,7 +335,7 @@ public Ping ping() throws IOException {
     int pingId;
     synchronized (this) {
       if (shutdown) {
-        throw new IOException("shutdown");
+        throw new ConnectionShutdownException();
       }
       pingId = nextPingId;
       nextPingId += 2;
@@ -488,7 +488,7 @@ public void setSettings(Settings settings) throws IOException {
     synchronized (writer) {
       synchronized (this) {
         if (shutdown) {
-          throw new IOException("shutdown");
+          throw new ConnectionShutdownException();
         }
         okHttpSettings.merge(settings);
         writer.settings(settings);
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealNewWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealNewWebSocket.java
index 380c9939a2..fb5888e259 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealNewWebSocket.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealNewWebSocket.java
@@ -33,8 +33,6 @@
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.WebSocket;
 import okhttp3.internal.Internal;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Util;
@@ -70,11 +68,16 @@
   private final Listener listener;
   private final Random random;
   private final String key;
-  private final Call call;
+
+  /** Non-null for client websockets. These can be canceled. */
+  private Call call;
 
   /** This runnable processes the outgoing queues. Call {@link #runWriter()} to after enqueueing. */
   private final NamedRunnable writerRunnable;
 
+  /** Null until this web socket is connected. Only accessed by the reader thread. */
+  private WebSocketReader reader;
+
   // All mutable web socket state is guarded by this.
 
   /**
@@ -83,7 +86,7 @@
    */
   private boolean writerRunning;
 
-  /** Null until this web Socket is connected. Note that messages may be enqueued before that. */
+  /** Null until this web socket is connected. Note that messages may be enqueued before that. */
   private WebSocketWriter writer;
 
   /**
@@ -114,7 +117,7 @@
   /** True if this web socket failed and the listener has been notified. */
   private boolean failed;
 
-  public RealNewWebSocket(OkHttpClient client, Request request, Listener listener, Random random) {
+  public RealNewWebSocket(Request request, Listener listener, Random random) {
     if (!"GET".equals(request.method())) {
       throw new IllegalArgumentException("Request must be GET: " + request.method());
     }
@@ -136,19 +139,6 @@ public RealNewWebSocket(OkHttpClient client, Request request, Listener listener,
         }
       }
     };
-
-    client = client.newBuilder()
-        .readTimeout(0, SECONDS) // i.e., no timeout because this is a long-lived connection.
-        .writeTimeout(0, SECONDS) // i.e., no timeout because this is a long-lived connection.
-        .protocols(ONLY_HTTP1)
-        .build();
-    request = request.newBuilder()
-        .header("Upgrade", "websocket")
-        .header("Connection", "Upgrade")
-        .header("Sec-WebSocket-Key", key)
-        .header("Sec-WebSocket-Version", "13")
-        .build();
-    this.call = Internal.instance.newWebSocketCall(client, request);
   }
 
   @Override public Request request() {
@@ -163,7 +153,19 @@ public RealNewWebSocket(OkHttpClient client, Request request, Listener listener,
     call.cancel();
   }
 
-  public void connnect() {
+  public void connect(OkHttpClient client) {
+    client = client.newBuilder()
+        .readTimeout(0, SECONDS) // i.e., no timeout because this is a long-lived connection.
+        .writeTimeout(0, SECONDS) // i.e., no timeout because this is a long-lived connection.
+        .protocols(ONLY_HTTP1)
+        .build();
+    Request request = originalRequest.newBuilder()
+        .header("Upgrade", "websocket")
+        .header("Connection", "Upgrade")
+        .header("Sec-WebSocket-Key", key)
+        .header("Sec-WebSocket-Version", "13")
+        .build();
+    call = Internal.instance.newWebSocketCall(client, request);
     call.enqueue(new Callback() {
       @Override public void onResponse(Call call, Response response) {
         try {
@@ -179,8 +181,11 @@ public void connnect() {
         streamAllocation.noNewStreams(); // Prevent connection pooling!
         Streams streams = new ClientStreams(streamAllocation);
 
+        // Process all websocket messages.
         try {
-          readWebsocket(streams, response);
+          listener.onOpen(RealNewWebSocket.this, response);
+          initReaderAndWriter(streams);
+          loopReader();
         } catch (Exception e) {
           failWebSocket(e, null);
         }
@@ -211,14 +216,15 @@ private void checkResponse(Response response) throws ProtocolException {
     }
 
     String headerAccept = response.header("Sec-WebSocket-Accept");
-    String acceptExpected = Util.shaBase64(key + WebSocketProtocol.ACCEPT_MAGIC);
+    String acceptExpected = ByteString.encodeUtf8(key + WebSocketProtocol.ACCEPT_MAGIC)
+        .sha1().base64();
     if (!acceptExpected.equals(headerAccept)) {
       throw new ProtocolException("Expected 'Sec-WebSocket-Accept' header value '"
           + acceptExpected + "' but was '" + headerAccept + "'");
     }
   }
 
-  void readWebsocket(Streams streams, Response response) throws IOException {
+  public void initReaderAndWriter(Streams streams) throws IOException {
     synchronized (this) {
       this.streams = streams;
       this.writer = new WebSocketWriter(streams.client, streams.sink, random);
@@ -227,31 +233,36 @@ void readWebsocket(Streams streams, Response response) throws IOException {
       }
     }
 
-    // Receive frames until there are no more.
-    WebSocketReader reader = new WebSocketReader(streams.client, streams.source, this);
-    listener.onOpen(this, response);
+    reader = new WebSocketReader(streams.client, streams.source, this);
+  }
+
+  /** Receive frames until there are no more. */
+  public void loopReader() throws IOException {
     while (receivedCloseCode == -1) {
       // This method call results in one or more onRead* methods being called on this thread.
       reader.processNextFrame();
     }
   }
 
-  @Override public void onReadMessage(ResponseBody body) throws IOException {
+  /** Receive a single frame and return true if there are more frames to read. */
+  boolean processNextFrame() throws IOException {
     try {
-      if (body.contentType().equals(WebSocket.TEXT)) {
-        String text = body.source().readUtf8();
-        listener.onMessage(this, text);
-      } else if (body.contentType().equals(WebSocket.BINARY)) {
-        ByteString bytes = body.source().readByteString();
-        listener.onMessage(this, bytes);
-      } else {
-        throw new IllegalArgumentException();
-      }
-    } finally {
-      Util.closeQuietly(body);
+      reader.processNextFrame();
+      return receivedCloseCode == -1;
+    } catch (Exception e) {
+      failWebSocket(e, null);
+      return false;
     }
   }
 
+  @Override public void onReadMessage(String text) throws IOException {
+    listener.onMessage(this, text);
+  }
+
+  @Override public void onReadMessage(ByteString bytes) throws IOException {
+    listener.onMessage(this, bytes);
+  }
+
   @Override public synchronized void onReadPing(final ByteString payload) {
     // Don't respond to pings after we've failed or sent the close frame.
     if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty())) return;
@@ -301,7 +312,7 @@ void readWebsocket(Streams streams, Response response) throws IOException {
     return send(bytes, OPCODE_BINARY);
   }
 
-  private synchronized boolean send(final ByteString data, final int formatOpcode) {
+  private synchronized boolean send(ByteString data, int formatOpcode) {
     // Don't send new frames after we've failed or enqueued a close frame.
     if (failed || enqueuedClose) return false;
 
@@ -318,6 +329,15 @@ private synchronized boolean send(final ByteString data, final int formatOpcode)
     return true;
   }
 
+  public synchronized boolean pong(ByteString payload) {
+    // Don't send pongs after we've failed or sent the close frame.
+    if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty())) return false;
+
+    pongQueue.add(payload);
+    runWriter();
+    return true;
+  }
+
   @Override public synchronized boolean close(final int code, final String reason) {
     // TODO(jwilson): confirm reason is well-formed. (<=123 bytes, etc.)
 
@@ -461,7 +481,7 @@ public Close(int code, String reason) {
     }
   }
 
-  abstract static class Streams implements Closeable {
+  public abstract static class Streams implements Closeable {
     final boolean client;
     final BufferedSource source;
     final BufferedSink sink;
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
deleted file mode 100644
index 8c360d8025..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicBoolean;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.WebSocket;
-import okhttp3.WebSocketListener;
-import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.Util;
-import okhttp3.internal.platform.Platform;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-
-import static okhttp3.internal.platform.Platform.INFO;
-import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_ABNORMAL_TERMINATION;
-import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_CLIENT_GOING_AWAY;
-import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_PROTOCOL_EXCEPTION;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
-import static okhttp3.internal.ws.WebSocketReader.FrameCallback;
-
-/**
- * An implementation of {@link WebSocket} which sits on top of {@link WebSocketReader} and
- * {@link WebSocketWriter}.
- *
- * <h2>Threading</h2>
- * This class deals with three threads concurrently and care must be taken to only access the
- * appropriate resources on each:
- * <ul>
- * <li><b>Reader</b>: This is the only thread allowed to access {@link #reader}. Methods from
- * {@link FrameCallback} will happen on this thread as a result. This is the only thread that
- * should invoke methods on the {@link #readerListener}.</li>
- * <li><b>Replier</b>: Invoked on {@link #replier} to write responses from reading
- * frames. Contends with the "Sender" thread for access to {@link #writer}.</li>
- * <li><b>Sender</b>: Methods from {@link WebSocket} will happen on this thread. Contends with the
- * "Replier" thread</li>
- * </ul>
- * Instance variables have prefixes matching the thread names based on the thread on which they can
- * be accessed. A prefix of "writer" indicates both "Sender" and "Replier" threads can access.
- */
-public abstract class RealWebSocket implements WebSocket, FrameCallback {
-  private final WebSocketReader reader;
-  private final WebSocketListener readerListener;
-  /** True after a close frame was read by the reader. No frames will follow it. */
-  private boolean readerSawClose;
-
-  final WebSocketWriter writer;
-  /** True after calling {@link WebSocketWriter#writeClose(int, String)} to send a close frame. */
-  final AtomicBoolean writerClosed = new AtomicBoolean();
-
-  /** Guarded by itself. Must check {@link #isShutdown} before enqueuing work. */
-  private final Executor replier;
-
-  /** True after calling {@link #close(int, String)}. No writes are allowed afterward. */
-  private boolean senderSentClose;
-  /** True after {@link IOException}. {@link #close(int, String)} becomes only valid call. */
-  private boolean senderWantsClose;
-
-  private final Response response;
-  private final String name;
-
-  /** The thread looping the reader. Will become null when looping stops for any reason. */
-  private volatile Thread looperThread;
-  /** Guarded by {@link #replier}. True after calling {@link #shutdown()}. */
-  private boolean isShutdown;
-
-  protected RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random,
-      Executor replier, WebSocketListener readerListener, Response response, String name) {
-    this.readerListener = readerListener;
-    this.replier = replier;
-    this.response = response;
-    this.name = name;
-
-    reader = new WebSocketReader(isClient, source, this);
-    writer = new WebSocketWriter(isClient, sink, random);
-  }
-
-  ////// READER THREAD
-
-  /** Read and process all socket messages delivering callbacks to the supplied listener. */
-  public final void loopReader() {
-    looperThread = Thread.currentThread();
-
-    try {
-      try {
-        readerListener.onOpen(this, response);
-      } catch (Throwable t) {
-        Util.throwIfFatal(t);
-        replyToReaderError(t);
-        readerListener.onFailure(t, null);
-        return;
-      }
-
-      while (processNextFrame()) {
-      }
-    } finally {
-      looperThread = null;
-    }
-  }
-
-  /**
-   * Read a single control frame or all frames of a message from the web socket and deliver any
-   * notifications to the listener. Returns false when no more messages can be read.
-   */
-  final boolean processNextFrame() {
-    try {
-      // This method call results in one or more onRead* methods being called on this thread.
-      reader.processNextFrame();
-
-      return !readerSawClose;
-    } catch (Throwable t) {
-      Util.throwIfFatal(t);
-      replyToReaderError(t);
-      if (t instanceof IOException && !(t instanceof ProtocolException)) {
-        readerListener.onClose(CLOSE_ABNORMAL_TERMINATION, "");
-      } else {
-        readerListener.onFailure(t, null);
-      }
-      return false;
-    }
-  }
-
-  @Override public final void onReadMessage(ResponseBody message) throws IOException {
-    readerListener.onMessage(message);
-  }
-
-  @Override public final void onReadPing(ByteString buffer) {
-    replyToPeerPing(buffer);
-  }
-
-  @Override public final void onReadPong(ByteString buffer) {
-    readerListener.onPong(buffer);
-  }
-
-  @Override public final void onReadClose(int code, String reason) {
-    replyToPeerClose(code, reason);
-    readerSawClose = true;
-    readerListener.onClose(code, reason);
-  }
-
-  ///// REPLIER THREAD (executed on replier, contends with sender thread)
-
-  /** Replies with a pong when a ping frame is read from the peer. */
-  private void replyToPeerPing(final ByteString payload) {
-    Runnable replierPong = new NamedRunnable("OkHttp %s WebSocket Pong Reply", name) {
-      @Override protected void execute() {
-        try {
-          writer.writePong(payload);
-        } catch (IOException t) {
-          Platform.get().log(INFO, "Unable to send pong reply in response to peer ping.", t);
-        }
-      }
-    };
-    synchronized (replier) {
-      if (!isShutdown) {
-        replier.execute(replierPong);
-      }
-    }
-  }
-
-  /** Replies and closes this web socket when a close frame is read from the peer. */
-  private void replyToPeerClose(final int code, final String reason) {
-    Runnable replierClose = new NamedRunnable("OkHttp %s WebSocket Close Reply", name) {
-      @Override protected void execute() {
-        if (writerClosed.compareAndSet(false, true)) {
-          try {
-            writer.writeClose(code, reason);
-          } catch (IOException t) {
-            Platform.get().log(INFO, "Unable to send close reply in response to peer close.", t);
-          }
-        }
-
-        quietlyCloseConnection();
-      }
-    };
-    synchronized (replier) {
-      if (!isShutdown) {
-        replier.execute(replierClose);
-      }
-    }
-  }
-
-  private void replyToReaderError(final Throwable t) {
-    Runnable replierClose = new NamedRunnable("OkHttp %s WebSocket Fatal Reply", name) {
-      @Override protected void execute() {
-        if (writerClosed.compareAndSet(false, true)) {
-          // For protocol and runtime exceptions, try to inform the server of such.
-          boolean protocolException = t instanceof ProtocolException;
-          boolean runtimeException = !(t instanceof IOException);
-          if (protocolException || runtimeException) {
-            int code = protocolException ? CLOSE_PROTOCOL_EXCEPTION : CLOSE_CLIENT_GOING_AWAY;
-            try {
-              writer.writeClose(code, null);
-            } catch (IOException inner) {
-              Platform.get()
-                  .log(INFO, "Unable to send close in response to listener error.", inner);
-            }
-          }
-        }
-
-        quietlyCloseConnection();
-      }
-    };
-    synchronized (replier) {
-      if (!isShutdown) {
-        replier.execute(replierClose);
-      }
-    }
-  }
-
-  ////// SENDER THREAD (aka user thread)
-
-  @Override public final void message(RequestBody message) throws IOException {
-    if (message == null) throw new NullPointerException("message == null");
-    if (senderSentClose) throw new IllegalStateException("closed");
-    if (senderWantsClose) throw new IllegalStateException("must call close()");
-    if (Thread.currentThread() == looperThread) {
-      throw new IllegalStateException("attempting to write from reader thread");
-    }
-
-    MediaType contentType = message.contentType();
-    if (contentType == null) {
-      throw new IllegalArgumentException(
-          "Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.");
-    }
-    String contentSubtype = contentType.subtype();
-
-    int formatOpcode;
-    if (WebSocket.TEXT.subtype().equals(contentSubtype)) {
-      formatOpcode = OPCODE_TEXT;
-    } else if (WebSocket.BINARY.subtype().equals(contentSubtype)) {
-      formatOpcode = OPCODE_BINARY;
-    } else {
-      throw new IllegalArgumentException("Unknown message content type: "
-          + contentType.type() + "/" + contentType.subtype() // Omit any implicitly added charset.
-          + ". Must use WebSocket.TEXT or WebSocket.BINARY.");
-    }
-
-    BufferedSink sink = Okio.buffer(writer.newMessageSink(formatOpcode, message.contentLength()));
-    try {
-      message.writeTo(sink);
-      sink.close();
-    } catch (IOException e) {
-      senderWantsClose = true;
-      throw e;
-    }
-  }
-
-  @Override public final void ping(ByteString payload) throws IOException {
-    if (payload == null) throw new NullPointerException("payload == null");
-    if (senderSentClose) throw new IllegalStateException("closed");
-    if (senderWantsClose) throw new IllegalStateException("must call close()");
-    if (Thread.currentThread() == looperThread) {
-      throw new IllegalStateException("attempting to write from reader thread");
-    }
-
-    try {
-      writer.writePing(payload);
-    } catch (IOException e) {
-      senderWantsClose = true;
-      throw e;
-    }
-  }
-
-  /** Send an unsolicited pong with the specified payload. */
-  public final void pong(ByteString payload) throws IOException {
-    if (payload == null) throw new NullPointerException("payload == null");
-    if (senderSentClose) throw new IllegalStateException("closed");
-    if (senderWantsClose) throw new IllegalStateException("must call close()");
-    if (Thread.currentThread() == looperThread) {
-      throw new IllegalStateException("attempting to write from reader thread");
-    }
-
-    try {
-      writer.writePong(payload);
-    } catch (IOException e) {
-      senderWantsClose = true;
-      throw e;
-    }
-  }
-
-  @Override public final void close(int code, String reason) throws IOException {
-    if (senderSentClose) throw new IllegalStateException("closed");
-    if (Thread.currentThread() == looperThread) {
-      throw new IllegalStateException("attempting to write from reader thread");
-    }
-
-    senderSentClose = true;
-
-    // Not doing a CAS because we want writer to throw if already closed via peer close.
-    writerClosed.set(true);
-
-    try {
-      writer.writeClose(code, reason);
-    } catch (IOException e) {
-      quietlyCloseConnection();
-      throw e;
-    }
-
-    // NOTE: We do not close the connection here! That will happen when we read the close reply.
-  }
-
-  ////// ANY THREAD
-
-  void quietlyCloseConnection() {
-    synchronized (replier) {
-      if (isShutdown) return;
-      isShutdown = true;
-    }
-    try {
-      shutdown();
-    } catch (Throwable inner) {
-      Util.throwIfFatal(inner);
-      Platform.get().log(INFO, "Unable to close web socket connection.", inner);
-    }
-  }
-
-  /** Perform any tear-down work (close the connection, shutdown executors). */
-  protected abstract void shutdown();
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
index bb6f5760d8..0d9873bfbe 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
@@ -18,15 +18,9 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
-import okhttp3.MediaType;
-import okhttp3.ResponseBody;
-import okhttp3.WebSocket;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
-import okio.Okio;
-import okio.Source;
-import okio.Timeout;
 
 import static java.lang.Integer.toHexString;
 import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
@@ -57,7 +51,8 @@
  */
 final class WebSocketReader {
   public interface FrameCallback {
-    void onReadMessage(ResponseBody body) throws IOException;
+    void onReadMessage(String text) throws IOException;
+    void onReadMessage(ByteString bytes) throws IOException;
     void onReadPing(ByteString buffer);
     void onReadPong(ByteString buffer);
     void onReadClose(int code, String reason);
@@ -67,10 +62,7 @@
   final BufferedSource source;
   final FrameCallback frameCallback;
 
-  final Source framedMessageSource = new FramedMessageSource();
-
   boolean closed;
-  boolean messageClosed;
 
   // Stateful data about the current frame.
   int opcode;
@@ -209,37 +201,18 @@ private void readControlFrame() throws IOException {
   }
 
   private void readMessageFrame() throws IOException {
-    final MediaType type;
-    switch (opcode) {
-      case OPCODE_TEXT:
-        type = WebSocket.TEXT;
-        break;
-      case OPCODE_BINARY:
-        type = WebSocket.BINARY;
-        break;
-      default:
-        throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
+    int opcode = this.opcode;
+    if (opcode != OPCODE_TEXT && opcode != OPCODE_BINARY) {
+      throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
     }
 
-    final BufferedSource source = Okio.buffer(framedMessageSource);
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return type;
-      }
-
-      @Override public long contentLength() {
-        return -1;
-      }
-
-      @Override public BufferedSource source() {
-        return source;
-      }
-    };
+    Buffer message = new Buffer();
+    readMessage(message);
 
-    messageClosed = false;
-    frameCallback.onReadMessage(body);
-    if (!messageClosed) {
-      throw new IllegalStateException("Listener failed to call close on message payload.");
+    if (opcode == OPCODE_TEXT) {
+      frameCallback.onReadMessage(message.readUtf8());
+    } else {
+      frameCallback.onReadMessage(message.readByteString());
     }
   }
 
@@ -255,28 +228,27 @@ void readUntilNonControlFrame() throws IOException {
   }
 
   /**
-   * A special source which knows how to read a message body across one or more frames. Control
-   * frames that occur between fragments will be processed. If the message payload is masked this
-   * will unmask as it's being processed.
+   * Reads a message body into across one or more frames. Control frames that occur between
+   * fragments will be processed. If the message payload is masked this will unmask as it's being
+   * processed.
    */
-  final class FramedMessageSource implements Source {
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
+  private void readMessage(Buffer sink) throws IOException {
+    while (true) {
       if (closed) throw new IOException("closed");
-      if (messageClosed) throw new IllegalStateException("closed");
 
       if (frameBytesRead == frameLength) {
-        if (isFinalFrame) return -1; // We are exhausted and have no continuations.
+        if (isFinalFrame) return; // We are exhausted and have no continuations.
 
         readUntilNonControlFrame();
         if (opcode != OPCODE_CONTINUATION) {
           throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
         }
         if (isFinalFrame && frameLength == 0) {
-          return -1; // Fast-path for empty final frame.
+          return; // Fast-path for empty final frame.
         }
       }
 
-      long toRead = Math.min(byteCount, frameLength - frameBytesRead);
+      long toRead = frameLength - frameBytesRead;
 
       long read;
       if (isMasked) {
@@ -291,24 +263,6 @@ void readUntilNonControlFrame() throws IOException {
       }
 
       frameBytesRead += read;
-      return read;
-    }
-
-    @Override public Timeout timeout() {
-      return source.timeout();
-    }
-
-    @Override public void close() throws IOException {
-      if (messageClosed) return;
-      messageClosed = true;
-      if (closed) return;
-
-      // Exhaust the remainder of the message, if any.
-      source.skip(frameLength - frameBytesRead);
-      while (!isFinalFrame) {
-        readUntilNonControlFrame();
-        source.skip(frameLength);
-      }
     }
   }
 }
diff --git a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
index d737171256..817d768971 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
@@ -1,24 +1,13 @@
 package okhttp3.recipes;
 
-import java.io.IOException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
+import okhttp3.NewWebSocket;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
-import okhttp3.RequestBody;
 import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.WebSocket;
-import okhttp3.WebSocketListener;
 import okio.ByteString;
 
-import static okhttp3.WebSocket.BINARY;
-import static okhttp3.WebSocket.TEXT;
-
-public final class WebSocketEcho implements WebSocketListener {
-  private final ExecutorService writeExecutor = Executors.newSingleThreadExecutor();
-
+public final class WebSocketEcho extends NewWebSocket.Listener {
   private void run() {
     OkHttpClient client = new OkHttpClient.Builder()
         .readTimeout(0,  TimeUnit.MILLISECONDS)
@@ -27,48 +16,34 @@ private void run() {
     Request request = new Request.Builder()
         .url("ws://echo.websocket.org")
         .build();
-    client.newWebSocketCall(request).enqueue(this);
+    client.newWebSocket(request, this);
 
     // Trigger shutdown of the dispatcher's executor so this process can exit cleanly.
     client.dispatcher().executorService().shutdown();
   }
 
-  @Override public void onOpen(final WebSocket webSocket, Response response) {
-    writeExecutor.execute(new Runnable() {
-      @Override public void run() {
-        try {
-          webSocket.message(RequestBody.create(TEXT, "Hello..."));
-          webSocket.message(RequestBody.create(TEXT, "...World!"));
-          webSocket.message(RequestBody.create(BINARY, ByteString.decodeHex("deadbeef")));
-          webSocket.close(1000, "Goodbye, World!");
-        } catch (IOException e) {
-          System.err.println("Unable to send messages: " + e.getMessage());
-        }
-      }
-    });
+  @Override public void onOpen(NewWebSocket webSocket, Response response) {
+    webSocket.send("Hello...");
+    webSocket.send("...World!");
+    webSocket.send(ByteString.decodeHex("deadbeef"));
+    webSocket.close(1000, "Goodbye, World!");
   }
 
-  @Override public void onMessage(ResponseBody message) throws IOException {
-    if (message.contentType() == TEXT) {
-      System.out.println("MESSAGE: " + message.string());
-    } else {
-      System.out.println("MESSAGE: " + message.source().readByteString().hex());
-    }
-    message.close();
+  @Override public void onMessage(NewWebSocket webSocket, String text) {
+    System.out.println("MESSAGE: " + text);
   }
 
-  @Override public void onPong(ByteString payload) {
-    System.out.println("PONG: " + payload.utf8());
+  @Override public void onMessage(NewWebSocket webSocket, ByteString bytes) {
+    System.out.println("MESSAGE: " + bytes.hex());
   }
 
-  @Override public void onClose(int code, String reason) {
+  @Override public void onClosing(NewWebSocket webSocket, int code, String reason) {
+    webSocket.close(1000, null);
     System.out.println("CLOSE: " + code + " " + reason);
-    writeExecutor.shutdown();
   }
 
-  @Override public void onFailure(Throwable t, Response response) {
+  @Override public void onFailure(NewWebSocket webSocket, Throwable t, Response response) {
     t.printStackTrace();
-    writeExecutor.shutdown();
   }
 
   public static void main(String... args) {
diff --git a/samples/slack/src/main/java/okhttp3/slack/RtmSession.java b/samples/slack/src/main/java/okhttp3/slack/RtmSession.java
index 83011d44ca..17b0a7bed3 100644
--- a/samples/slack/src/main/java/okhttp3/slack/RtmSession.java
+++ b/samples/slack/src/main/java/okhttp3/slack/RtmSession.java
@@ -17,73 +17,58 @@
 
 import java.io.Closeable;
 import java.io.IOException;
+import okhttp3.NewWebSocket;
 import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.WebSocket;
-import okhttp3.WebSocketCall;
-import okhttp3.WebSocketListener;
-import okio.ByteString;
 
 /** A realtime messaging session. */
-public final class RtmSession implements WebSocketListener, Closeable {
+public final class RtmSession extends NewWebSocket.Listener implements Closeable {
   private final SlackApi slackApi;
-  private WebSocketCall webSocketCall;
 
   /** Guarded by this. */
-  private WebSocket webSocket;
+  private NewWebSocket webSocket;
 
   public RtmSession(SlackApi slackApi) {
     this.slackApi = slackApi;
   }
 
   public void open(String accessToken) throws IOException {
-    if (webSocketCall != null) throw new IllegalStateException();
+    if (webSocket != null) throw new IllegalStateException();
 
     RtmStartResponse rtmStartResponse = slackApi.rtmStart(accessToken);
-    webSocketCall = slackApi.rtm(rtmStartResponse.url);
-    webSocketCall.enqueue(this);
+    webSocket = slackApi.rtm(rtmStartResponse.url, this);
   }
 
   // TODO(jwilson): can I read the response body? Do I have to?
   //                the body from slack is a 0-byte-buffer
-  @Override public synchronized void onOpen(WebSocket webSocket, Response response) {
+  @Override public synchronized void onOpen(NewWebSocket webSocket, Response response) {
     System.out.println("onOpen: " + response);
-    this.webSocket = webSocket;
   }
 
   // TOOD(jwilson): decode incoming messages and dispatch them somewhere.
-  @Override public void onMessage(ResponseBody message) throws IOException {
-    System.out.println("onMessage: " + message.string());
+  @Override public void onMessage(NewWebSocket webSocket, String text) {
+    System.out.println("onMessage: " + text);
   }
 
-  @Override public void onPong(ByteString payload) {
-    System.out.println("onPong: " + payload);
-  }
-
-  @Override public void onClose(int code, String reason) {
+  @Override public void onClosing(NewWebSocket webSocket, int code, String reason) {
+    webSocket.close(1000, null);
     System.out.println("onClose (" + code + "): " + reason);
   }
 
-  // TODO(jwilson): can I read the response body? Do I have to?
-  @Override public void onFailure(Throwable t, Response response) {
+  @Override public void onFailure(NewWebSocket webSocket, Throwable t, Response response) {
+    // TODO(jwilson): can I read the response body? Do I have to?
     System.out.println("onFailure " + response);
   }
 
   @Override public void close() throws IOException {
-    if (webSocketCall == null) return;
+    if (webSocket == null) return;
 
-    WebSocket webSocket;
+    NewWebSocket webSocket;
     synchronized (this) {
       webSocket = this.webSocket;
     }
 
-    // TODO(jwilson): Racy? Is there an interleaving of events where the websocket is not closed?
-    //                Our docs say we can’t close if we have an active writer: that seems like it
-    //                could cause problems?
     if (webSocket != null) {
       webSocket.close(1000, "bye");
-    } else {
-      webSocketCall.cancel();
     }
   }
 }
diff --git a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
index 0d0086b579..3bfee53492 100644
--- a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
+++ b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
@@ -22,10 +22,10 @@
 import java.io.IOException;
 import okhttp3.Call;
 import okhttp3.HttpUrl;
+import okhttp3.NewWebSocket;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.WebSocketCall;
 import okio.ByteString;
 
 /**
@@ -105,10 +105,10 @@ public RtmStartResponse rtmStart(String accessToken) throws IOException {
   }
 
   /** See https://api.slack.com/rtm. */
-  public WebSocketCall rtm(HttpUrl url) {
-    return httpClient.newWebSocketCall(new Request.Builder()
+  public NewWebSocket rtm(HttpUrl url, NewWebSocket.Listener listener) {
+    return httpClient.newWebSocket(new Request.Builder()
         .url(url)
-        .build());
+        .build(), listener);
   }
 
   static final class SlackJsonAdapters {
