diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
index 9b3d4c11d2..e135ef7ff6 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
@@ -16,7 +16,7 @@
 
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.File;
 import java.io.FileInputStream;
@@ -33,7 +33,7 @@
 import javax.net.ssl.SSLSocketFactory;
 import org.eclipse.jetty.npn.NextProtoNego;
 
-import static com.squareup.okhttp.internal.Util.byteStringList;
+import static com.squareup.okhttp.internal.Util.headerEntries;
 
 /** A basic SPDY server that serves the contents of a local directory. */
 public final class SpdyServer implements IncomingStreamHandler {
@@ -71,7 +71,7 @@ private Socket doSsl(Socket socket) throws IOException {
         System.out.println("UNSUPPORTED");
       }
       @Override public List<String> protocols() {
-        return Arrays.asList("spdy/3");
+        return Arrays.asList(Protocol.SPDY_3.name.utf8());
       }
       @Override public void protocolSelected(String protocol) {
         System.out.println("PROTOCOL SELECTED: " + protocol);
@@ -81,12 +81,11 @@ private Socket doSsl(Socket socket) throws IOException {
   }
 
   @Override public void receive(final SpdyStream stream) throws IOException {
-    List<ByteString> requestHeaders = stream.getRequestHeaders();
+    List<Header> requestHeaders = stream.getRequestHeaders();
     String path = null;
-    for (int i = 0; i < requestHeaders.size(); i += 2) {
-      ByteString s = requestHeaders.get(i);
-      if (s.utf8Equals(":path")) {
-        path = requestHeaders.get(i + 1).utf8();
+    for (int i = 0; i < requestHeaders.size(); i++) {
+      if (requestHeaders.get(i).name.equals(Header.TARGET_PATH)) {
+        path = requestHeaders.get(i).value.utf8();
         break;
       }
     }
@@ -108,8 +107,8 @@ private Socket doSsl(Socket socket) throws IOException {
   }
 
   private void send404(SpdyStream stream, String path) throws IOException {
-    List<ByteString> responseHeaders =
-        byteStringList(":status", "404", ":version", "HTTP/1.1", "content-type", "text/plain");
+    List<Header> responseHeaders =
+        headerEntries(":status", "404", ":version", "HTTP/1.1", "content-type", "text/plain");
     stream.reply(responseHeaders, true);
     OutputStream out = stream.getOutputStream();
     String text = "Not found: " + path;
@@ -118,8 +117,8 @@ private void send404(SpdyStream stream, String path) throws IOException {
   }
 
   private void serveDirectory(SpdyStream stream, String[] files) throws IOException {
-    List<ByteString> responseHeaders =
-        byteStringList(":status", "200", ":version", "HTTP/1.1", "content-type",
+    List<Header> responseHeaders =
+        headerEntries(":status", "200", ":version", "HTTP/1.1", "content-type",
             "text/html; charset=UTF-8");
     stream.reply(responseHeaders, true);
     OutputStream out = stream.getOutputStream();
@@ -134,7 +133,7 @@ private void serveFile(SpdyStream stream, File file) throws IOException {
     InputStream in = new FileInputStream(file);
     byte[] buffer = new byte[8192];
     stream.reply(
-        byteStringList(":status", "200", ":version", "HTTP/1.1", "content-type", contentType(file)),
+        headerEntries(":status", "200", ":version", "HTTP/1.1", "content-type", contentType(file)),
         true);
     OutputStream out = stream.getOutputStream();
     int count;
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 35dac4dcf3..f37fde104d 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -17,10 +17,12 @@
 
 package com.squareup.okhttp.mockwebserver;
 
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.spdy.Header;
 import com.squareup.okhttp.internal.spdy.IncomingStreamHandler;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
@@ -43,7 +45,6 @@
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
@@ -71,29 +72,6 @@
  * replays them upon request in sequence.
  */
 public final class MockWebServer {
-  private static final byte[] HTTP_20_DRAFT_09 = new byte[] {
-      'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '9', '/', '2', '.', '0'
-  };
-  private static final byte[] SPDY3 = new byte[] {
-      's', 'p', 'd', 'y', '/', '3'
-  };
-  private static final byte[] HTTP_11 = new byte[] {
-      'h', 't', 't', 'p', '/', '1', '.', '1'
-  };
-  private static final byte[] NPN_PROTOCOLS = joinNpnProtocols(HTTP_20_DRAFT_09, SPDY3, HTTP_11);
-
-  private static byte[] joinNpnProtocols(byte[]... protocols) {
-    try {
-      ByteArrayOutputStream baos = new ByteArrayOutputStream();
-      for (byte[] protocol : protocols) {
-        baos.write(protocol.length);
-        baos.write(protocol);
-      }
-      return baos.toByteArray();
-    } catch (IOException e) {
-      throw new AssertionError(e);
-    }
-  }
 
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
     @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
@@ -181,7 +159,7 @@ public void setBodyLimit(int maxBodyLength) {
 
   /**
    * Sets whether NPN is used on incoming HTTPS connections to negotiate a
-   * transport like HTTP/1.1 or SPDY/3. Call this method to disable NPN and
+   * protocol like HTTP/1.1 or SPDY/3. Call this method to disable NPN and
    * SPDY.
    */
   public void setNpnEnabled(boolean npnEnabled) {
@@ -308,7 +286,7 @@ private void serveConnection(final Socket raw) {
       }
 
       public void processConnection() throws Exception {
-        Transport transport = Transport.HTTP_11;
+        Protocol protocol = Protocol.HTTP_11;
         Socket socket;
         if (sslSocketFactory != null) {
           if (tunnelProxy) {
@@ -327,39 +305,26 @@ public void processConnection() throws Exception {
           openClientSockets.put(socket, true);
 
           if (npnEnabled) {
-            Platform.get().setNpnProtocols(sslSocket, NPN_PROTOCOLS);
+            // TODO: expose means to select which protocols to advertise.
+            Platform.get().setNpnProtocols(sslSocket, Protocol.HTTP2_SPDY3_AND_HTTP);
           }
 
           sslSocket.startHandshake();
 
           if (npnEnabled) {
-            byte[] selectedProtocol = Platform.get().getNpnSelectedProtocol(sslSocket);
-            if (selectedProtocol == null || Arrays.equals(selectedProtocol, HTTP_11)) {
-              transport = Transport.HTTP_11;
-            } else if (Arrays.equals(selectedProtocol, HTTP_20_DRAFT_09)) {
-              transport = Transport.HTTP_20_DRAFT_09;
-            } else if (Arrays.equals(selectedProtocol, SPDY3)) {
-              transport = Transport.SPDY_3;
-            } else {
-              throw new IllegalStateException(
-                  "Unexpected transport: " + new String(selectedProtocol, Util.US_ASCII));
-            }
+            ByteString selectedProtocol = Platform.get().getNpnSelectedProtocol(sslSocket);
+            protocol = Protocol.find(selectedProtocol);
           }
           openClientSockets.remove(raw);
         } else {
           socket = raw;
         }
 
-        if (transport == Transport.HTTP_20_DRAFT_09 || transport == Transport.SPDY_3) {
-          SpdySocketHandler spdySocketHandler = new SpdySocketHandler(socket, transport);
-          SpdyConnection.Builder builder = new SpdyConnection.Builder(false, socket)
-              .handler(spdySocketHandler);
-          if (transport == Transport.HTTP_20_DRAFT_09) {
-            builder.http20Draft09();
-          } else {
-            builder.spdy3();
-          }
-          SpdyConnection spdyConnection = builder.build();
+        if (protocol.spdyVariant) {
+          SpdySocketHandler spdySocketHandler = new SpdySocketHandler(socket, protocol);
+          SpdyConnection spdyConnection = new SpdyConnection.Builder(false, socket)
+              .protocol(protocol)
+              .handler(spdySocketHandler).build();
           openSpdyConnections.put(spdyConnection, Boolean.TRUE);
           openClientSockets.remove(socket);
           spdyConnection.readConnectionHeader();
@@ -628,12 +593,12 @@ public void setDispatcher(Dispatcher dispatcher) {
   /** Processes HTTP requests layered over SPDY/3. */
   private class SpdySocketHandler implements IncomingStreamHandler {
     private final Socket socket;
-    private final Transport transport;
+    private final Protocol protocol;
     private final AtomicInteger sequenceNumber = new AtomicInteger();
 
-    private SpdySocketHandler(Socket socket, Transport transport) {
+    private SpdySocketHandler(Socket socket, Protocol protocol) {
       this.socket = socket;
-      this.transport = transport;
+      this.protocol = protocol;
     }
 
     @Override public void receive(SpdyStream stream) throws IOException {
@@ -647,26 +612,26 @@ private SpdySocketHandler(Socket socket, Transport transport) {
       }
       writeResponse(stream, response);
       logger.info("Received request: " + request + " and responded: " + response
-          + " transport is " + transport);
+          + " protocol is " + protocol.name.utf8());
     }
 
     private RecordedRequest readRequest(SpdyStream stream) throws IOException {
-      List<ByteString> spdyHeaders = stream.getRequestHeaders();
+      List<Header> spdyHeaders = stream.getRequestHeaders();
       List<String> httpHeaders = new ArrayList<String>();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
-      String version = "<:version omitted>";
-      for (int i = 0, size = spdyHeaders.size(); i < size; i += 2) {
-        String name = spdyHeaders.get(i).utf8();
-        String value = spdyHeaders.get(i + 1).utf8();
-        if (":method".equals(name)) {
+      String version = protocol == Protocol.SPDY_3 ? "<:version omitted>" : "HTTP/1.1";
+      for (int i = 0, size = spdyHeaders.size(); i < size; i++) {
+        ByteString name = spdyHeaders.get(i).name;
+        String value = spdyHeaders.get(i).value.utf8();
+        if (name.equals(Header.TARGET_METHOD)) {
           method = value;
-        } else if (":path".equals(name)) {
+        } else if (name.equals(Header.TARGET_PATH)) {
           path = value;
-        } else if (":version".equals(name)) {
+        } else if (name.equals(Header.VERSION)) {
           version = value;
         } else {
-          httpHeaders.add(name + ": " + value);
+          httpHeaders.add(name.utf8() + ": " + value);
         }
       }
 
@@ -688,17 +653,16 @@ private void writeResponse(SpdyStream stream, MockResponse response) throws IOEx
       if (response.getSocketPolicy() == SocketPolicy.NO_RESPONSE) {
         return;
       }
-      List<ByteString> spdyHeaders = new ArrayList<ByteString>();
+      List<Header> spdyHeaders = new ArrayList<Header>();
       String[] statusParts = response.getStatus().split(" ", 2);
       if (statusParts.length != 2) {
         throw new AssertionError("Unexpected status: " + response.getStatus());
       }
       // TODO: constants for well-known header names.
-      spdyHeaders.add(ByteString.encodeUtf8(":status"));
-      spdyHeaders.add(ByteString.encodeUtf8(statusParts[1]));
-      // TODO: no ":version" header for HTTP/2.0, only SPDY.
-      spdyHeaders.add(ByteString.encodeUtf8(":version"));
-      spdyHeaders.add(ByteString.encodeUtf8(statusParts[0]));
+      spdyHeaders.add(new Header(Header.RESPONSE_STATUS, statusParts[1]));
+      if (protocol == Protocol.SPDY_3) {
+        spdyHeaders.add(new Header(Header.VERSION, statusParts[0]));
+      }
       List<String> headers = response.getHeaders();
       for (int i = 0, size = headers.size(); i < size; i++) {
         String header = headers.get(i);
@@ -706,8 +670,7 @@ private void writeResponse(SpdyStream stream, MockResponse response) throws IOEx
         if (headerParts.length != 2) {
           throw new AssertionError("Unexpected header: " + header);
         }
-        spdyHeaders.add(ByteString.encodeUtf8(headerParts[0].toLowerCase(Locale.US).trim()));
-        spdyHeaders.add(ByteString.encodeUtf8(headerParts[1].trim()));
+        spdyHeaders.add(new Header(headerParts[0], headerParts[1]));
       }
       byte[] body = response.getBody();
       stream.reply(spdyHeaders, body.length > 0);
@@ -724,8 +687,4 @@ private void writeResponse(SpdyStream stream, MockResponse response) throws IOEx
       }
     }
   }
-
-  enum Transport {
-    HTTP_11, SPDY_3, HTTP_20_DRAFT_09
-  }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java
new file mode 100644
index 0000000000..f57361ee0c
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Contains protocols that OkHttp supports
+ * <a href="http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04">NPN</a> or
+ * <a href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> selection.
+ *
+ * <p/>
+ * <h3>Protocol vs Scheme</h3>
+ * Despite its name, {@link java.net.URL#getProtocol()} returns the
+ * {@link java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not
+ * the protocol (http/1.1, spdy/3, etc.).  OkHttp uses the word protocol to
+ * indicate how HTTP messages are framed.
+ */
+public enum Protocol {
+  HTTP_2("HTTP-draft-09/2.0", true),
+  SPDY_3("spdy/3", true),
+  HTTP_11("http/1.1", false);
+
+  public static final List<Protocol> HTTP2_SPDY3_AND_HTTP =
+      Util.immutableList(Arrays.asList(HTTP_2, SPDY_3, HTTP_11));
+  public static final List<Protocol> SPDY3_AND_HTTP11 =
+      Util.immutableList(Arrays.asList(SPDY_3, HTTP_11));
+  public static final List<Protocol> HTTP2_AND_HTTP_11 =
+      Util.immutableList(Arrays.asList(HTTP_2, HTTP_11));
+
+  /** Identifier string used in NPN or ALPN selection. */
+  public final ByteString name;
+
+  /**
+   * When true the protocol is binary framed and derived from SPDY.
+   *
+   * @see com.squareup.okhttp.internal.spdy.Variant
+   */
+  public final boolean spdyVariant;
+
+  Protocol(String name, boolean spdyVariant) {
+    this.name = ByteString.encodeUtf8(name);
+    this.spdyVariant = spdyVariant;
+  }
+
+  /**
+   * Returns the protocol matching {@code input} or {@link #HTTP_11} is on
+   * {@code null}. Throws an {@link IOException} when {@code input} doesn't
+   * match the {@link #name} of a supported protocol.
+   */
+  public static Protocol find(ByteString input) throws IOException {
+    if (input == null) return HTTP_11;
+    for (Protocol protocol : values()) {
+      if (protocol.name.equals(input)) return protocol;
+    }
+    throw new IOException("Unexpected protocol: " + input.utf8());
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java
new file mode 100644
index 0000000000..c83f1dd50d
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright 2014 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static java.lang.String.format;
+
+/** A simple bitset which supports left shifting. */
+public interface BitArray {
+
+  void clear();
+
+  void set(int index);
+
+  void toggle(int index);
+
+  boolean get(int index);
+
+  void shiftLeft(int count);
+
+  /** Bit set that only supports settings bits 0 - 63. */
+  public final class FixedCapacity implements BitArray {
+    long data = 0x0000000000000000L;
+
+    @Override public void clear() {
+      data = 0x0000000000000000L;
+    }
+
+    @Override public void set(int index) {
+      data |= (1L << checkInput(index));
+    }
+
+    @Override public void toggle(int index) {
+      data ^= (1L << checkInput(index));
+    }
+
+    @Override public boolean get(int index) {
+      return ((data >> checkInput(index)) & 1L) == 1;
+    }
+
+    @Override public void shiftLeft(int count) {
+      data = data << checkInput(count);
+    }
+
+    @Override public String toString() {
+      return Long.toBinaryString(data);
+    }
+
+    public BitArray toVariableCapacity() {
+      return new VariableCapacity(this);
+    }
+
+    private static int checkInput(int index) {
+      if (index < 0 || index > 63) {
+        throw new IllegalArgumentException(format("input must be between 0 and 63: %s", index));
+      }
+      return index;
+    }
+  }
+
+  /** Bit set that grows as needed. */
+  public final class VariableCapacity implements BitArray {
+
+    long[] data;
+
+    // Start offset which allows for cheap shifting. Data is always kept on 64-bit bounds but we
+    // offset the outward facing index to support shifts without having to move the underlying bits.
+    private int start; // Valid values are [0..63]
+
+    public VariableCapacity() {
+      data = new long[1];
+    }
+
+    private VariableCapacity(FixedCapacity small) {
+      data = new long[] {small.data, 0};
+    }
+
+    private void growToSize(int size) {
+      long[] newData = new long[size];
+      if (data != null) {
+        System.arraycopy(data, 0, newData, 0, data.length);
+      }
+      data = newData;
+    }
+
+    private int offsetOf(int index) {
+      index += start;
+      int offset = index / 64;
+      if (offset > data.length - 1) {
+        growToSize(offset + 1);
+      }
+      return offset;
+    }
+
+    private int shiftOf(int index) {
+      return (index + start) % 64;
+    }
+
+    @Override public void clear() {
+      Arrays.fill(data, 0);
+    }
+
+    @Override public void set(int index) {
+      checkInput(index);
+      int offset = offsetOf(index);
+      data[offset] |= 1L << shiftOf(index);
+    }
+
+    @Override public void toggle(int index) {
+      checkInput(index);
+      int offset = offsetOf(index);
+      data[offset] ^= 1L << shiftOf(index);
+    }
+
+    @Override public boolean get(int index) {
+      checkInput(index);
+      int offset = offsetOf(index);
+      return (data[offset] & (1L << shiftOf(index))) != 0;
+    }
+
+    @Override public void shiftLeft(int count) {
+      start -= checkInput(count);
+      if (start < 0) {
+        int arrayShift = (start / -64) + 1;
+        long[] newData = new long[data.length + arrayShift];
+        System.arraycopy(data, 0, newData, arrayShift, data.length);
+        data = newData;
+        start = 64 + (start % 64);
+      }
+    }
+
+    @Override public String toString() {
+      StringBuilder builder = new StringBuilder("{");
+      List<Integer> ints = toIntegerList();
+      for (int i = 0, count = ints.size(); i < count; i++) {
+        if (i > 0) {
+          builder.append(',');
+        }
+        builder.append(ints.get(i));
+      }
+      return builder.append('}').toString();
+    }
+
+    List<Integer> toIntegerList() {
+      List<Integer> ints = new ArrayList<Integer>();
+      for (int i = 0, count = data.length * 64 - start; i < count; i++) {
+        if (get(i)) {
+          ints.add(i);
+        }
+      }
+      return ints;
+    }
+
+    private static int checkInput(int index) {
+      if (index < 0) {
+        throw new IllegalArgumentException(format("input must be a positive number: %s", index));
+      }
+      return index;
+    }
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java
index b6a688e3d7..9370ebbea6 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java
@@ -15,12 +15,13 @@
  */
 package com.squareup.okhttp.internal;
 
-import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.Arrays;
 
+import static com.squareup.okhttp.internal.Util.asciiLowerCase;
+
 /**
  * An immutable sequence of bytes.
  *
@@ -37,41 +38,24 @@
   private transient int hashCode; // Lazily computed; 0 if unknown.
   private transient String utf8; // Lazily computed.
 
-  /**
-   * A singleton empty {@code ByteString}.
-   */
+  /** A singleton empty {@code ByteString}. */
   public static final ByteString EMPTY = new ByteString(Util.EMPTY_BYTE_ARRAY);
 
   /**
-   * Returns a new byte string containing the bytes of {@code data}, or
-   * {@link #EMPTY} if {@code data} is an empty array.
+   * Returns a new byte string containing a clone of the bytes of {@code data}.
    */
   public static ByteString of(byte... data) {
     return new ByteString(data.clone());
   }
 
-  /**
-   * Returns a new byte string containing the bytes of {@code data}
-   * from {@code offset} to {@code offset + count - 1}, inclusive, or
-   * {@link #EMPTY} if {@code count} is zero.
-   */
-  public static ByteString of(byte[] data, int offset, int count) {
-    byte[] bytes = new byte[count];
-    System.arraycopy(data, offset, bytes, 0, count);
-    return new ByteString(bytes);
-  }
-
-  /**
-   * Returns a new byte string containing the {@code UTF-8} bytes of {@code s},
-   * or {@link #EMPTY} if {@code s} is zero length.
-   */
+  /** Returns a new byte string containing the {@code UTF-8} bytes of {@code s}. */
   public static ByteString encodeUtf8(String s) {
     ByteString byteString = new ByteString(s.getBytes(Util.UTF_8));
     byteString.utf8 = s;
     return byteString;
   }
 
-  /** Constructs a new {@code String} by decoding the bytes as UTF-8. */
+  /** Constructs a new {@code String} by decoding the bytes as {@code UTF-8}. */
   public String utf8() {
     String result = utf8;
     // We don't care if we double-allocate in racy code.
@@ -79,28 +63,45 @@ public String utf8() {
   }
 
   /**
-   * Returns true when {@code s} is not null and its {@code UTF-8} encoded
-   * bytes are equivalent to the bytes wrapped by this byte string.
+   * Returns true when {@code ascii} is not null and equals the bytes wrapped
+   * by this byte string.
    */
-  public boolean utf8Equals(String s) {
-    if (s == null) return false;
-    // TODO: avoid allocation
-    return utf8().equals(s);
+  public boolean equalsAscii(String ascii) {
+    if (ascii == null || data.length != ascii.length()) {
+      return false;
+    }
+    if (ascii == this.utf8) {
+      return true;
+    }
+    for (int i = 0; i < data.length; i++) {
+      if (data[i] != ascii.charAt(i)) return false;
+    }
+    return true;
   }
 
   /**
    * Reads {@code count} bytes from {@code in} and returns the result.
    *
-   * @throws EOFException if {@code in} has fewer than {@code count} bytes to
-   * read.
+   * @throws java.io.EOFException if {@code in} has fewer than {@code count}
+   * bytes to read.
    */
   public static ByteString read(InputStream in, int count) throws IOException {
     byte[] result = new byte[count];
-    for (int c = 0; c < count; ) {
-      int read = in.read(result, c, count - c);
-      if (read == -1) throw new EOFException("Expected " + count + "; received " + c);
-      c += read;
-    }
+    Util.readFully(in, result);
+    return new ByteString(result);
+  }
+
+  /**
+   * Reads {@code count} bytes from {@code in} and returns the result converted
+   * to ASCII lowercase.
+   *
+   * @throws java.io.EOFException if {@code in} has fewer than {@code count}
+   * bytes to read.
+   */
+  public static ByteString readLowerCase(InputStream in, int count) throws IOException {
+    byte[] result = new byte[count];
+    Util.readFully(in, result);
+    asciiLowerCase(result);
     return new ByteString(result);
   }
 
@@ -115,7 +116,7 @@ public static ByteString concat(ByteString... byteStrings) {
       System.arraycopy(byteString.data, 0, result, pos, byteString.size());
       pos += byteString.size();
     }
-    return ByteString.of(result);
+    return new ByteString(result);
   }
 
   private ByteString(byte[] data) {
@@ -141,11 +142,6 @@ public void write(OutputStream out) throws IOException {
     out.write(data);
   }
 
-  /** Writes a subsequence of this byte string to {@code out}. */
-  public void write(OutputStream out, int offset, int count) throws IOException {
-    out.write(data, offset, count);
-  }
-
   @Override public boolean equals(Object o) {
     return o == this || o instanceof ByteString && Arrays.equals(((ByteString) o).data, data);
   }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
index 33c120d163..f02a2ca602 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -16,9 +16,9 @@
  */
 package com.squareup.okhttp.internal;
 
+import com.squareup.okhttp.Protocol;
 import java.io.IOException;
 import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
@@ -106,7 +106,7 @@ public void supportTlsIntolerantServer(SSLSocket socket) {
   }
 
   /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  public byte[] getNpnSelectedProtocol(SSLSocket socket) {
+  public ByteString getNpnSelectedProtocol(SSLSocket socket) {
     return null;
   }
 
@@ -114,7 +114,7 @@ public void supportTlsIntolerantServer(SSLSocket socket) {
    * Sets client-supported protocols on a socket to send to a server. The
    * protocols are only sent if the socket implementation supports NPN.
    */
-  public void setNpnProtocols(SSLSocket socket, byte[] npnProtocols) {
+  public void setNpnProtocols(SSLSocket socket, List<Protocol> npnProtocols) {
   }
 
   public void connectSocket(Socket socket, InetSocketAddress address,
@@ -267,11 +267,11 @@ private Android(
       }
     }
 
-    @Override public void setNpnProtocols(SSLSocket socket, byte[] npnProtocols) {
+    @Override public void setNpnProtocols(SSLSocket socket, List<Protocol> npnProtocols) {
       if (setNpnProtocols == null) return;
       if (!openSslSocketClass.isInstance(socket)) return;
       try {
-        Object[] parameters = { npnProtocols };
+        Object[] parameters = { concatLengthPrefixed(npnProtocols) };
         if (setAlpnProtocols != null) {
           setAlpnProtocols.invoke(socket, parameters);
         }
@@ -283,16 +283,16 @@ private Android(
       }
     }
 
-    @Override public byte[] getNpnSelectedProtocol(SSLSocket socket) {
+    @Override public ByteString getNpnSelectedProtocol(SSLSocket socket) {
       if (getNpnSelectedProtocol == null) return null;
       if (!openSslSocketClass.isInstance(socket)) return null;
       try {
         if (getAlpnSelectedProtocol != null) {
           // Prefer ALPN's result if it is present.
           byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invoke(socket);
-          if (alpnResult != null) return alpnResult;
+          if (alpnResult != null) return ByteString.of(alpnResult);
         }
-        return (byte[]) getNpnSelectedProtocol.invoke(socket);
+        return ByteString.of((byte[]) getNpnSelectedProtocol.invoke(socket));
       } catch (InvocationTargetException e) {
         throw new RuntimeException(e);
       } catch (IllegalAccessException e) {
@@ -316,20 +316,15 @@ public JdkWithJettyNpnPlatform(Method putMethod, Method getMethod, Class<?> clie
       this.serverProviderClass = serverProviderClass;
     }
 
-    @Override public void setNpnProtocols(SSLSocket socket, byte[] npnProtocols) {
+    @Override public void setNpnProtocols(SSLSocket socket, List<Protocol> npnProtocols) {
       try {
-        List<String> strings = new ArrayList<String>();
-        for (int i = 0; i < npnProtocols.length; ) {
-          int length = npnProtocols[i++];
-          strings.add(new String(npnProtocols, i, length, "US-ASCII"));
-          i += length;
+        List<String> names = new ArrayList<String>(npnProtocols.size());
+        for (int i = 0, size = npnProtocols.size(); i < size; i++) {
+          names.add(npnProtocols.get(i).name.utf8());
         }
         Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
-            new Class[] {clientProviderClass, serverProviderClass},
-            new JettyNpnProvider(strings));
+            new Class[] { clientProviderClass, serverProviderClass }, new JettyNpnProvider(names));
         putMethod.invoke(null, socket, provider);
-      } catch (UnsupportedEncodingException e) {
-        throw new AssertionError(e);
       } catch (InvocationTargetException e) {
         throw new AssertionError(e);
       } catch (IllegalAccessException e) {
@@ -337,7 +332,7 @@ public JdkWithJettyNpnPlatform(Method putMethod, Method getMethod, Class<?> clie
       }
     }
 
-    @Override public byte[] getNpnSelectedProtocol(SSLSocket socket) {
+    @Override public ByteString getNpnSelectedProtocol(SSLSocket socket) {
       try {
         JettyNpnProvider provider =
             (JettyNpnProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
@@ -347,9 +342,7 @@ public JdkWithJettyNpnPlatform(Method putMethod, Method getMethod, Class<?> clie
               "NPN callback dropped so SPDY is disabled. " + "Is npn-boot on the boot class path?");
           return null;
         }
-        return provider.unsupported ? null : provider.selected.getBytes("US-ASCII");
-      } catch (UnsupportedEncodingException e) {
-        throw new AssertionError();
+        return provider.unsupported ? null : ByteString.encodeUtf8(provider.selected);
       } catch (InvocationTargetException e) {
         throw new AssertionError();
       } catch (IllegalAccessException e) {
@@ -363,8 +356,11 @@ public JdkWithJettyNpnPlatform(Method putMethod, Method getMethod, Class<?> clie
    * without a compile-time dependency on those interfaces.
    */
   private static class JettyNpnProvider implements InvocationHandler {
+    /** This peer's supported protocols. */
     private final List<String> protocols;
+    /** Set when remote peer notifies NPN is unsupported. */
     private boolean unsupported;
+    /** The protocol the client selected. */
     private String selected;
 
     public JettyNpnProvider(List<String> protocols) {
@@ -378,26 +374,53 @@ public JettyNpnProvider(List<String> protocols) {
         args = Util.EMPTY_STRING_ARRAY;
       }
       if (methodName.equals("supports") && boolean.class == returnType) {
-        return true;
+        return true; // Client supports NPN.
       } else if (methodName.equals("unsupported") && void.class == returnType) {
-        this.unsupported = true;
+        this.unsupported = true; // Remote peer doesn't support NPN.
         return null;
       } else if (methodName.equals("protocols") && args.length == 0) {
-        return protocols;
-      } else if (methodName.equals("selectProtocol")
+        return protocols; // Server advertises these protocols.
+      } else if (methodName.equals("selectProtocol") // Called when client.
           && String.class == returnType
           && args.length == 1
           && (args[0] == null || args[0] instanceof List)) {
-        // TODO: use OpenSSL's algorithm which uses both lists
-        List<?> serverProtocols = (List) args[0];
-        this.selected = protocols.get(0);
-        return selected;
+        List<String> serverProtocols = (List) args[0];
+        // Pick the first protocol the server advertises and client knows.
+        for (int i = 0, size = serverProtocols.size(); i < size; i++) {
+          if (protocols.contains(serverProtocols.get(i))) {
+            return selected = serverProtocols.get(i);
+          }
+        }
+        // On no intersection, try client's first protocol.
+        return selected = protocols.get(0);
       } else if (methodName.equals("protocolSelected") && args.length == 1) {
-        this.selected = (String) args[0];
+        this.selected = (String) args[0]; // Client selected this protocol.
         return null;
       } else {
         return method.invoke(this, args);
       }
     }
   }
+
+  /**
+   * Concatenation of 8-bit, length prefixed protocol names.
+   *
+   * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
+   */
+  static byte[] concatLengthPrefixed(List<Protocol> protocols) {
+    int size = 0;
+    for (Protocol protocol : protocols) {
+      size += protocol.name.size() + 1; // add a byte for 8-bit length prefix.
+    }
+    byte[] result = new byte[size];
+    int pos = 0;
+    for (Protocol protocol : protocols) {
+      int nameSize = protocol.name.size();
+      result[pos++] = (byte) nameSize;
+      // toByteArray allocates an array, but this is only called on new connections.
+      System.arraycopy(protocol.name.toByteArray(), 0, result, pos, nameSize);
+      pos += nameSize;
+    }
+    return result;
+  }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
index 93fc2f03e1..0cd85e1917 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp.internal;
 
+import com.squareup.okhttp.internal.spdy.Header;
 import java.io.ByteArrayInputStream;
 import java.io.Closeable;
 import java.io.EOFException;
@@ -400,11 +401,22 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
     };
   }
 
-  public static List<ByteString> byteStringList(String... strings) {
-    List<ByteString> result = new ArrayList<ByteString>(strings.length);
-    for (String string : strings) {
-      result.add(ByteString.encodeUtf8(string));
+  public static List<Header> headerEntries(String... elements) {
+    List<Header> result = new ArrayList<Header>(elements.length / 2);
+    for (int i = 0; i < elements.length; i += 2) {
+      result.add(new Header(elements[i], elements[i + 1]));
     }
     return result;
   }
+
+  /** Mutates the byte array to ensure all characters are lowercase. */
+  public static void asciiLowerCase(byte[] bytes) {
+    for (int i = 0; i < bytes.length; i++) {
+      bytes[i] = asciiLowerCase(bytes[i]);
+    }
+  }
+
+  public static byte asciiLowerCase(byte c) {
+    return 'A' <= c && c <= 'Z' ? (byte) (c + 'a' - 'A') : c;
+  }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index a2228601a6..5c0888cb3c 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -16,7 +16,6 @@
 
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
@@ -44,7 +43,7 @@
      * (highest) thru 7 (lowest). For HTTP/2.0, priorities range from 0
      */
     void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-        int priority, List<ByteString> nameValueBlock, HeadersMode headersMode);
+        int priority, List<Header> nameValueBlock, HeadersMode headersMode);
     void rstStream(int streamId, ErrorCode errorCode);
     void settings(boolean clearPrevious, Settings settings);
     void noop();
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index 77bbdf8c99..63d2007e04 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -16,7 +16,6 @@
 
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
 import java.io.Closeable;
 import java.io.IOException;
 import java.util.List;
@@ -25,19 +24,21 @@
 public interface FrameWriter extends Closeable {
   /** HTTP/2.0 only. */
   void connectionHeader() throws IOException;
+  void ackSettings() throws IOException;
 
   /** SPDY/3 only. */
   void flush() throws IOException;
   void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      int priority, int slot, List<ByteString> nameValueBlock) throws IOException;
-  void synReply(boolean outFinished, int streamId, List<ByteString> nameValueBlock)
+      int priority, int slot, List<Header> nameValueBlock) throws IOException;
+  void synReply(boolean outFinished, int streamId, List<Header> nameValueBlock)
       throws IOException;
-  void headers(int streamId, List<ByteString> nameValueBlock) throws IOException;
+  void headers(int streamId, List<Header> nameValueBlock) throws IOException;
   void rstStream(int streamId, ErrorCode errorCode) throws IOException;
   void data(boolean outFinished, int streamId, byte[] data) throws IOException;
   void data(boolean outFinished, int streamId, byte[] data, int offset, int byteCount)
       throws IOException;
-  void settings(Settings settings) throws IOException;
+  /** Write okhttp's settings to the peer. */
+  void settings(Settings okHttpSettings) throws IOException;
   void noop() throws IOException;
   void ping(boolean reply, int payload1, int payload2) throws IOException;
   void goAway(int lastGoodStreamId, ErrorCode errorCode) throws IOException;
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Header.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
new file mode 100644
index 0000000000..7b1f44b5c2
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
@@ -0,0 +1,56 @@
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.ByteString;
+
+/** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
+public final class Header {
+  // Special header names defined in the SPDY and HTTP/2 specs.
+  public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(":status");
+  public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(":method");
+  public static final ByteString TARGET_PATH = ByteString.encodeUtf8(":path");
+  public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(":scheme");
+  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority"); // http/2
+  public static final ByteString TARGET_HOST = ByteString.encodeUtf8(":host"); // spdy/3
+  public static final ByteString VERSION = ByteString.encodeUtf8(":version"); // spdy/3
+
+  /** Name in case-insensitive ASCII encoding. */
+  public final ByteString name;
+  /** Value in UTF-8 encoding. */
+  public final ByteString value;
+  final int hpackSize;
+
+  // TODO: search for toLowerCase and consider moving logic here.
+  public Header(String name, String value) {
+    this(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value));
+  }
+
+  public Header(ByteString name, String value) {
+    this(name, ByteString.encodeUtf8(value));
+  }
+
+  public Header(ByteString name, ByteString value) {
+    this.name = name;
+    this.value = value;
+    this.hpackSize = 32 + name.size() + value.size();
+  }
+
+  @Override public boolean equals(Object other) {
+    if (other instanceof Header) {
+      Header that = (Header) other;
+      return this.name.equals(that.name)
+          && this.value.equals(that.value);
+    }
+    return false;
+  }
+
+  @Override public int hashCode() {
+    int result = 17;
+    result = 31 * result + name.hashCode();
+    result = 31 * result + value.hashCode();
+    return result;
+  }
+
+  @Override public String toString() {
+    return String.format("%s: %s", name.utf8(), value.utf8());
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 63a504624f..75c77240a0 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -1,5 +1,6 @@
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.BitArray;
 import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
 import java.io.DataInputStream;
@@ -9,6 +10,8 @@
 import java.util.Arrays;
 import java.util.List;
 
+import static com.squareup.okhttp.internal.Util.asciiLowerCase;
+
 /**
  * Read and write HPACK v05.
  *
@@ -16,114 +19,90 @@
  *
  * This implementation uses an array for the header table with a bitset for
  * references.  Dynamic entries are added to the array, starting in the last
- * position moving forward.  When the array fills, it is doubled, up to the
- * supported maximum of 64 headers.  HTTP requests or responses that require
- * more than 64 headers are hence not currently supported.
+ * position moving forward.  When the array fills, it is doubled.
  */
 final class HpackDraft05 {
-
-  // Visible for testing.
-  static class HeaderEntry {
-    final ByteString name;
-    final ByteString value;
-    final int size;
-
-    HeaderEntry(String name, String value) {
-      this(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value));
-    }
-
-    HeaderEntry(ByteString name, ByteString value) {
-      this(name, value, 32 + name.size() + value.size());
-    }
-
-    private HeaderEntry(ByteString name, ByteString value, int size) {
-      this.name = name;
-      this.value = value;
-      this.size = size;
-    }
-  }
-
   private static final int PREFIX_6_BITS = 0x3f;
   private static final int PREFIX_7_BITS = 0x7f;
   private static final int PREFIX_8_BITS = 0xff;
 
-  private static final HeaderEntry[] STATIC_HEADER_TABLE = new HeaderEntry[] {
-      new HeaderEntry(":authority", ""),
-      new HeaderEntry(":method", "GET"),
-      new HeaderEntry(":method", "POST"),
-      new HeaderEntry(":path", "/"),
-      new HeaderEntry(":path", "/index.html"),
-      new HeaderEntry(":scheme", "http"),
-      new HeaderEntry(":scheme", "https"),
-      new HeaderEntry(":status", "200"),
-      new HeaderEntry(":status", "500"),
-      new HeaderEntry(":status", "404"),
-      new HeaderEntry(":status", "403"),
-      new HeaderEntry(":status", "400"),
-      new HeaderEntry(":status", "401"),
-      new HeaderEntry("accept-charset", ""),
-      new HeaderEntry("accept-encoding", ""),
-      new HeaderEntry("accept-language", ""),
-      new HeaderEntry("accept-ranges", ""),
-      new HeaderEntry("accept", ""),
-      new HeaderEntry("access-control-allow-origin", ""),
-      new HeaderEntry("age", ""),
-      new HeaderEntry("allow", ""),
-      new HeaderEntry("authorization", ""),
-      new HeaderEntry("cache-control", ""),
-      new HeaderEntry("content-disposition", ""),
-      new HeaderEntry("content-encoding", ""),
-      new HeaderEntry("content-language", ""),
-      new HeaderEntry("content-length", ""),
-      new HeaderEntry("content-location", ""),
-      new HeaderEntry("content-range", ""),
-      new HeaderEntry("content-type", ""),
-      new HeaderEntry("cookie", ""),
-      new HeaderEntry("date", ""),
-      new HeaderEntry("etag", ""),
-      new HeaderEntry("expect", ""),
-      new HeaderEntry("expires", ""),
-      new HeaderEntry("from", ""),
-      new HeaderEntry("host", ""),
-      new HeaderEntry("if-match", ""),
-      new HeaderEntry("if-modified-since", ""),
-      new HeaderEntry("if-none-match", ""),
-      new HeaderEntry("if-range", ""),
-      new HeaderEntry("if-unmodified-since", ""),
-      new HeaderEntry("last-modified", ""),
-      new HeaderEntry("link", ""),
-      new HeaderEntry("location", ""),
-      new HeaderEntry("max-forwards", ""),
-      new HeaderEntry("proxy-authenticate", ""),
-      new HeaderEntry("proxy-authorization", ""),
-      new HeaderEntry("range", ""),
-      new HeaderEntry("referer", ""),
-      new HeaderEntry("refresh", ""),
-      new HeaderEntry("retry-after", ""),
-      new HeaderEntry("server", ""),
-      new HeaderEntry("set-cookie", ""),
-      new HeaderEntry("strict-transport-security", ""),
-      new HeaderEntry("transfer-encoding", ""),
-      new HeaderEntry("user-agent", ""),
-      new HeaderEntry("vary", ""),
-      new HeaderEntry("via", ""),
-      new HeaderEntry("www-authenticate", "")
+  private static final Header[] STATIC_HEADER_TABLE = new Header[] {
+      new Header(Header.TARGET_AUTHORITY, ""),
+      new Header(Header.TARGET_METHOD, "GET"),
+      new Header(Header.TARGET_METHOD, "POST"),
+      new Header(Header.TARGET_PATH, "/"),
+      new Header(Header.TARGET_PATH, "/index.html"),
+      new Header(Header.TARGET_SCHEME, "http"),
+      new Header(Header.TARGET_SCHEME, "https"),
+      new Header(Header.RESPONSE_STATUS, "200"),
+      new Header(Header.RESPONSE_STATUS, "500"),
+      new Header(Header.RESPONSE_STATUS, "404"),
+      new Header(Header.RESPONSE_STATUS, "403"),
+      new Header(Header.RESPONSE_STATUS, "400"),
+      new Header(Header.RESPONSE_STATUS, "401"),
+      new Header("accept-charset", ""),
+      new Header("accept-encoding", ""),
+      new Header("accept-language", ""),
+      new Header("accept-ranges", ""),
+      new Header("accept", ""),
+      new Header("access-control-allow-origin", ""),
+      new Header("age", ""),
+      new Header("allow", ""),
+      new Header("authorization", ""),
+      new Header("cache-control", ""),
+      new Header("content-disposition", ""),
+      new Header("content-encoding", ""),
+      new Header("content-language", ""),
+      new Header("content-length", ""),
+      new Header("content-location", ""),
+      new Header("content-range", ""),
+      new Header("content-type", ""),
+      new Header("cookie", ""),
+      new Header("date", ""),
+      new Header("etag", ""),
+      new Header("expect", ""),
+      new Header("expires", ""),
+      new Header("from", ""),
+      new Header("host", ""),
+      new Header("if-match", ""),
+      new Header("if-modified-since", ""),
+      new Header("if-none-match", ""),
+      new Header("if-range", ""),
+      new Header("if-unmodified-since", ""),
+      new Header("last-modified", ""),
+      new Header("link", ""),
+      new Header("location", ""),
+      new Header("max-forwards", ""),
+      new Header("proxy-authenticate", ""),
+      new Header("proxy-authorization", ""),
+      new Header("range", ""),
+      new Header("referer", ""),
+      new Header("refresh", ""),
+      new Header("retry-after", ""),
+      new Header("server", ""),
+      new Header("set-cookie", ""),
+      new Header("strict-transport-security", ""),
+      new Header("transfer-encoding", ""),
+      new Header("user-agent", ""),
+      new Header("vary", ""),
+      new Header("via", ""),
+      new Header("www-authenticate", "")
   };
 
   private HpackDraft05() {
   }
 
-  // TODO: huffman encoding!
   // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.2
   static class Reader {
     private final Huffman.Codec huffmanCodec;
 
     private final DataInputStream in;
-    private final List<ByteString> emittedHeaders = new ArrayList<ByteString>();
+    private final List<Header> emittedHeaders = new ArrayList<Header>();
+    private int maxHeaderTableByteCount;
     private long bytesLeft = 0;
 
     // Visible for testing.
-    HeaderEntry[] headerTable = new HeaderEntry[8]; // must be less than 64
+    Header[] headerTable = new Header[8];
     // Array is populated back to front, so new entries always have lowest index.
     int nextHeaderIndex = headerTable.length - 1;
     int headerCount = 0;
@@ -131,23 +110,70 @@ private HpackDraft05() {
     /**
      * Set bit positions indicate {@code headerTable[pos]} should be emitted.
      */
-    // Using a long since the reference table < 64 entries.
-    long referencedHeaders = 0x0000000000000000L;
+    // Using a BitArray as it has left-shift operator.
+    BitArray referencedHeaders = new BitArray.FixedCapacity();
 
     /**
      * Set bit positions indicate {@code STATIC_HEADER_TABLE[pos]} should be
      * emitted.
      */
     // Using a long since the static table < 64 entries.
-    long referencedStaticHeaders = 0x0000000000000000L;
+    long referencedStaticHeaders = 0L;
     int headerTableByteCount = 0;
-    int maxHeaderTableByteCount = 4096; // TODO: needs to come from SETTINGS_HEADER_TABLE_SIZE.
 
-    Reader(boolean client, DataInputStream in) {
+    Reader(boolean client, int maxHeaderTableByteCount, DataInputStream in) {
       this.huffmanCodec = client ? Huffman.Codec.RESPONSE : Huffman.Codec.REQUEST;
+      this.maxHeaderTableByteCount = maxHeaderTableByteCount;
       this.in = in;
     }
 
+    int maxHeaderTableByteCount() {
+      return maxHeaderTableByteCount;
+    }
+
+    /**
+     * Called by the reader when the peer sent a new header table size setting.
+     *
+     * Evicts entries or clears the table as needed.
+     */
+    void maxHeaderTableByteCount(int newMaxHeaderTableByteCount) {
+      this.maxHeaderTableByteCount = newMaxHeaderTableByteCount;
+      if (maxHeaderTableByteCount < headerTableByteCount) {
+        if (maxHeaderTableByteCount == 0) {
+          clearHeaderTable();
+        } else {
+          evictToRecoverBytes(headerTableByteCount - maxHeaderTableByteCount);
+        }
+      }
+    }
+
+    private void clearHeaderTable() {
+      clearReferenceSet();
+      Arrays.fill(headerTable, null);
+      nextHeaderIndex = headerTable.length - 1;
+      headerCount = 0;
+      headerTableByteCount = 0;
+    }
+
+    /** Returns the count of entries evicted. */
+    private int evictToRecoverBytes(int bytesToRecover) {
+      int entriesToEvict = 0;
+      if (bytesToRecover > 0) {
+        // determine how many headers need to be evicted.
+        for (int j = headerTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
+          bytesToRecover -= headerTable[j].hpackSize;
+          headerTableByteCount -= headerTable[j].hpackSize;
+          headerCount--;
+          entriesToEvict++;
+        }
+        referencedHeaders.shiftLeft(entriesToEvict);
+        System.arraycopy(headerTable, nextHeaderIndex + 1, headerTable,
+            nextHeaderIndex + 1 + entriesToEvict, headerCount);
+        nextHeaderIndex += entriesToEvict;
+      }
+      return entriesToEvict;
+    }
+
     /**
      * Read {@code byteCount} bytes of headers from the source stream into the
      * set of emitted headers.
@@ -184,21 +210,19 @@ public void readHeaders(int byteCount) throws IOException {
     }
 
     private void clearReferenceSet() {
-      referencedStaticHeaders = 0x0000000000000000L;
-      referencedHeaders = 0x0000000000000000L;
+      referencedStaticHeaders = 0L;
+      referencedHeaders.clear();
     }
 
     public void emitReferenceSet() {
       for (int i = 0; i < STATIC_HEADER_TABLE.length; ++i) {
-        if (bitPositionSet(referencedStaticHeaders, i)) {
-          emittedHeaders.add(STATIC_HEADER_TABLE[i].name);
-          emittedHeaders.add(STATIC_HEADER_TABLE[i].value);
+        if (((referencedStaticHeaders >> i) & 1L) == 1) {
+          emittedHeaders.add(STATIC_HEADER_TABLE[i]);
         }
       }
       for (int i = headerTable.length - 1; i != nextHeaderIndex; --i) {
-        if (bitPositionSet(referencedHeaders, i)) {
-          emittedHeaders.add(headerTable[i].name);
-          emittedHeaders.add(headerTable[i].value);
+        if (referencedHeaders.get(i)) {
+          emittedHeaders.add(headerTable[i]);
         }
       }
     }
@@ -207,27 +231,22 @@ public void emitReferenceSet() {
      * Returns all headers emitted since they were last cleared, then clears the
      * emitted headers.
      */
-    public List<ByteString> getAndReset() {
-      List<ByteString> result = new ArrayList<ByteString>(emittedHeaders);
+    public List<Header> getAndReset() {
+      List<Header> result = new ArrayList<Header>(emittedHeaders);
       emittedHeaders.clear();
       return result;
     }
 
     private void readIndexedHeader(int index) {
-
       if (isStaticHeader(index)) {
         if (maxHeaderTableByteCount == 0) {
-          // Set bit designating this static entry is referenced.
           referencedStaticHeaders |= (1L << (index - headerCount));
         } else {
-          HeaderEntry staticEntry = STATIC_HEADER_TABLE[index - headerCount];
+          Header staticEntry = STATIC_HEADER_TABLE[index - headerCount];
           insertIntoHeaderTable(-1, staticEntry);
         }
-      } else if (!bitPositionSet(referencedHeaders, headerTableIndex(index))) {
-        referencedHeaders |= (1L << headerTableIndex(index));
       } else {
-        // TODO: we should throw something that we can coerce to a PROTOCOL_ERROR
-        throw new AssertionError("invalid index " + index);
+        referencedHeaders.toggle(headerTableIndex(index));
       }
     }
 
@@ -238,29 +257,27 @@ private int headerTableIndex(int index) {
 
     private void readLiteralHeaderWithoutIndexingIndexedName(int index) throws IOException {
       ByteString name = getName(index);
-      ByteString value = readString();
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
+      ByteString value = readByteString(false);
+      emittedHeaders.add(new Header(name, value));
     }
 
     private void readLiteralHeaderWithoutIndexingNewName() throws IOException {
-      ByteString name = readString();
-      ByteString value = readString();
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
+      ByteString name = readByteString(true);
+      ByteString value = readByteString(false);
+      emittedHeaders.add(new Header(name, value));
     }
 
     private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
         throws IOException {
       ByteString name = getName(nameIndex);
-      ByteString value = readString();
-      insertIntoHeaderTable(-1, new HeaderEntry(name, value));
+      ByteString value = readByteString(false);
+      insertIntoHeaderTable(-1, new Header(name, value));
     }
 
     private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
-      ByteString name = readString();
-      ByteString value = readString();
-      insertIntoHeaderTable(-1, new HeaderEntry(name, value));
+      ByteString name = readByteString(true);
+      ByteString value = readByteString(false);
+      insertIntoHeaderTable(-1, new Header(name, value));
     }
 
     private ByteString getName(int index) {
@@ -276,64 +293,42 @@ private boolean isStaticHeader(int index) {
     }
 
     /** index == -1 when new. */
-    private void insertIntoHeaderTable(int index, HeaderEntry entry) {
-      int delta = entry.size;
+    private void insertIntoHeaderTable(int index, Header entry) {
+      int delta = entry.hpackSize;
       if (index != -1) { // Index -1 == new header.
-        delta -= headerTable[headerTableIndex(index)].size;
+        delta -= headerTable[headerTableIndex(index)].hpackSize;
       }
 
       // if the new or replacement header is too big, drop all entries.
       if (delta > maxHeaderTableByteCount) {
-        referencedStaticHeaders = 0x0000000000000000L;
-        referencedHeaders = 0x0000000000000000L;
-        Arrays.fill(headerTable, null);
-        nextHeaderIndex = headerTable.length - 1;
-        headerCount = 0;
-        headerTableByteCount = 0;
+        clearHeaderTable();
         // emit the large header to the callback.
-        emittedHeaders.add(entry.name);
-        emittedHeaders.add(entry.value);
+        emittedHeaders.add(entry);
         return;
       }
 
       // Evict headers to the required length.
       int bytesToRecover = (headerTableByteCount + delta) - maxHeaderTableByteCount;
-      int entriesToEvict = 0;
-      if (bytesToRecover > 0) {
-        // determine how many headers need to be evicted.
-        for (int j = headerTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
-          bytesToRecover -= headerTable[j].size;
-          headerTableByteCount -= headerTable[j].size;
-          headerCount--;
-          entriesToEvict++;
-        }
-        // shift elements over
-        referencedHeaders = referencedHeaders << entriesToEvict;
-        System.arraycopy(headerTable, nextHeaderIndex + 1, headerTable,
-            nextHeaderIndex + 1 + entriesToEvict, headerCount);
-        nextHeaderIndex += entriesToEvict;
-      }
+      int entriesEvicted = evictToRecoverBytes(bytesToRecover);
 
       if (index == -1) {
         if (headerCount + 1 > headerTable.length) {
-          if (headerTable.length == 64) {
-            // We would need to switch off long to bitset to support > 64 headers.
-            throw new UnsupportedOperationException(
-                "Header tables with count > 64 not yet supported!");
-          }
-          HeaderEntry[] doubled = new HeaderEntry[headerTable.length * 2];
+          Header[] doubled = new Header[headerTable.length * 2];
           System.arraycopy(headerTable, 0, doubled, headerTable.length, headerTable.length);
-          referencedHeaders = referencedHeaders << headerTable.length;
+          if (doubled.length == 64) {
+            referencedHeaders = ((BitArray.FixedCapacity) referencedHeaders).toVariableCapacity();
+          }
+          referencedHeaders.shiftLeft(headerTable.length);
           nextHeaderIndex = headerTable.length - 1;
           headerTable = doubled;
         }
         index = nextHeaderIndex--;
-        referencedHeaders |= (1L << index);
+        referencedHeaders.set(index);
         headerTable[index] = entry;
         headerCount++;
       } else { // Replace value at same position.
-        index += headerTableIndex(index) + entriesToEvict;
-        referencedHeaders |= (1L << index);
+        index += headerTableIndex(index) + entriesEvicted;
+        referencedHeaders.set(index);
         headerTable[index] = entry;
       }
       headerTableByteCount += delta;
@@ -367,10 +362,10 @@ int readInt(int firstByte, int prefixMask) throws IOException {
     }
 
     /**
-     * Reads a UTF-8 encoded string. Since ASCII is a subset of UTF-8, this method
-     * may be used to read strings that are known to be ASCII-only.
+     * Reads a potentially Huffman encoded string byte string. When
+     * {@code asciiLowercase} is true, bytes will be converted to lowercase.
      */
-    public ByteString readString() throws IOException {
+    public ByteString readByteString(boolean asciiLowercase) throws IOException {
       int firstByte = readByte();
       int length = readInt(firstByte, PREFIX_8_BITS);
       if ((length & 0x80) == 0x80) { // 1NNNNNNN
@@ -378,17 +373,16 @@ public ByteString readString() throws IOException {
         byte[] buff = new byte[length];
         Util.readFully(in, buff);
         bytesLeft -= length;
-        return ByteString.of(huffmanCodec.decode(buff));
+        buff = huffmanCodec.decode(buff); // TODO: streaming Huffman!
+        if (asciiLowercase) asciiLowerCase(buff);
+        return ByteString.of(buff);
       }
       bytesLeft -= length;
-      return ByteString.read(in, length);
+      return length == 0 ? ByteString.EMPTY
+          : asciiLowercase ? ByteString.readLowerCase(in, length) : ByteString.read(in, length);
     }
   }
 
-  static boolean bitPositionSet(long referenceBitSet, int i) {
-    return ((referenceBitSet >> i) & 1L) == 1;
-  }
-
   static class Writer {
     private final OutputStream out;
 
@@ -396,15 +390,16 @@ static boolean bitPositionSet(long referenceBitSet, int i) {
       this.out = out;
     }
 
-    public void writeHeaders(List<ByteString> nameValueBlock) throws IOException {
+    public void writeHeaders(List<Header> nameValueBlock) throws IOException {
       // TODO: implement a compression strategy.
-      for (int i = 0, size = nameValueBlock.size(); i < size; i += 2) {
+      for (int i = 0, size = nameValueBlock.size(); i < size; i++) {
         out.write(0x40); // Literal Header without Indexing - New Name.
-        writeByteString(nameValueBlock.get(i));
-        writeByteString(nameValueBlock.get(i + 1));
+        writeByteString(nameValueBlock.get(i).name);
+        writeByteString(nameValueBlock.get(i).value);
       }
     }
 
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.1
     public void writeInt(int value, int prefixMask, int bits) throws IOException {
       // Write the raw value for a single byte value.
       if (value < prefixMask) {
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index b124338681..7875656040 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -15,7 +15,7 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayOutputStream;
 import java.io.DataInputStream;
@@ -33,8 +33,29 @@
  */
 public final class Http20Draft09 implements Variant {
 
-  @Override public String getProtocol() {
-    return "HTTP-draft-09/2.0";
+  @Override public Protocol getProtocol() {
+    return Protocol.HTTP_2;
+  }
+
+  // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-6.5
+  @Override public Settings defaultOkHttpSettings(boolean client) {
+    Settings settings = new Settings();
+    settings.set(Settings.HEADER_TABLE_SIZE, 0, 4096);
+    if (!client) { // client doesn't send push requests.
+      settings.set(Settings.ENABLE_PUSH, 0, 0); // TODO: support writing push.
+    }
+    settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
+    return settings;
+  }
+
+  @Override public Settings initialPeerSettings(boolean client) {
+    Settings settings = new Settings();
+    settings.set(Settings.HEADER_TABLE_SIZE, 0, 4096);
+    if (client) { // server doesn't read push requests.
+      settings.set(Settings.ENABLE_PUSH, 0, 0); // TODO: support reading push.
+    }
+    settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
+    return settings;
   }
 
   private static final byte[] CONNECTION_HEADER;
@@ -65,11 +86,11 @@
   static final int FLAG_ACK = 0x1;
   static final int FLAG_END_FLOW_CONTROL = 0x1;
 
-  @Override public FrameReader newReader(InputStream in, boolean client) {
-    return new Reader(in, client);
+  @Override public FrameReader newReader(InputStream in, Settings peerSettings, boolean client) {
+    return new Reader(in, peerSettings.getHeaderTableSize(), client);
   }
 
-  @Override public FrameWriter newWriter(OutputStream out, boolean client) {
+  @Override public FrameWriter newWriter(OutputStream out, Settings ignored, boolean client) {
     return new Writer(out, client);
   }
 
@@ -80,10 +101,10 @@
     // Visible for testing.
     final HpackDraft05.Reader hpackReader;
 
-    Reader(InputStream in, boolean client) {
+    Reader(InputStream in, int headerTableSize, boolean client) {
       this.in = new DataInputStream(in);
       this.client = client;
-      this.hpackReader = new HpackDraft05.Reader(client, this.in);
+      this.hpackReader = new HpackDraft05.Reader(client, headerTableSize, this.in);
     }
 
     @Override public void readConnectionHeader() throws IOException {
@@ -164,7 +185,7 @@ private void readHeaders(Handler handler, int flags, int length, int streamId)
 
         if ((flags & FLAG_END_HEADERS) != 0) {
           hpackReader.emitReferenceSet();
-          List<ByteString> nameValueBlock = hpackReader.getAndReset();
+          List<Header> nameValueBlock = hpackReader.getAndReset();
           // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
           // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
           int priority = -1; // TODO: priority
@@ -224,9 +245,6 @@ private void readSettings(Handler handler, int flags, int length, int streamId)
         throws IOException {
       if ((flags & FLAG_ACK) != 0) {
         if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
-        // TODO: signal apply changes
-        // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-6.5.3
-        return;
       }
 
       if (length % 8 != 0) throw ioException("TYPE_SETTINGS length %% 8 != 0: %s", length);
@@ -240,6 +258,9 @@ private void readSettings(Handler handler, int flags, int length, int streamId)
         settings.set(id, 0, value);
       }
       handler.settings(false, settings);
+      if (settings.getHeaderTableSize() >= 0) {
+        hpackReader.maxHeaderTableByteCount(settings.getHeaderTableSize());
+      }
     }
 
     private void readPushPromise(Handler handler, int flags, int length, int streamId) {
@@ -302,6 +323,12 @@ private void readWindowUpdate(Handler handler, int flags, int length, int stream
       out.flush();
     }
 
+    @Override public synchronized void ackSettings() throws IOException {
+      // ACK the settings frame.
+      out.writeInt(0 | (TYPE_SETTINGS & 0xff) << 8 | (FLAG_ACK & 0xff));
+      out.writeInt(0);
+    }
+
     @Override public synchronized void connectionHeader() throws IOException {
       if (!client) return; // Nothing to write; servers don't send connection headers!
       out.write(CONNECTION_HEADER);
@@ -309,24 +336,24 @@ private void readWindowUpdate(Handler handler, int flags, int length, int stream
 
     @Override
     public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, int slot, List<ByteString> nameValueBlock)
+        int associatedStreamId, int priority, int slot, List<Header> nameValueBlock)
         throws IOException {
       if (inFinished) throw new UnsupportedOperationException();
       headers(outFinished, streamId, priority, nameValueBlock);
     }
 
     @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<ByteString> nameValueBlock) throws IOException {
+        List<Header> nameValueBlock) throws IOException {
       headers(outFinished, streamId, -1, nameValueBlock);
     }
 
-    @Override public synchronized void headers(int streamId, List<ByteString> nameValueBlock)
+    @Override public synchronized void headers(int streamId, List<Header> nameValueBlock)
         throws IOException {
       headers(false, streamId, -1, nameValueBlock);
     }
 
     private void headers(boolean outFinished, int streamId, int priority,
-        List<ByteString> nameValueBlock) throws IOException {
+        List<Header> nameValueBlock) throws IOException {
       hpackBuffer.reset();
       hpackWriter.writeHeaders(nameValueBlock);
       int type = TYPE_HEADERS;
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
index 85af6ed40d..34ce45522c 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
@@ -72,31 +72,26 @@ public FillableInflaterInputStream(InputStream in, Inflater inf) {
     }
   }
 
-  public List<ByteString> readNameValueBlock(int length) throws IOException {
+  public List<Header> readNameValueBlock(int length) throws IOException {
     this.compressedLimit += length;
-    try {
-      int numberOfPairs = nameValueBlockIn.readInt();
-      if (numberOfPairs < 0) {
-        throw new IOException("numberOfPairs < 0: " + numberOfPairs);
-      }
-      if (numberOfPairs > 1024) {
-        throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
-      }
-      List<ByteString> entries = new ArrayList<ByteString>(numberOfPairs * 2);
-      for (int i = 0; i < numberOfPairs; i++) {
-        ByteString name = readString();
-        ByteString values = readString();
-        if (name.size() == 0) throw new IOException("name.size == 0");
-        entries.add(name);
-        entries.add(values);
-      }
+    int numberOfPairs = nameValueBlockIn.readInt();
+    if (numberOfPairs < 0) {
+      throw new IOException("numberOfPairs < 0: " + numberOfPairs);
+    }
+    if (numberOfPairs > 1024) {
+      throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
+    }
+    List<Header> entries = new ArrayList<Header>(numberOfPairs);
+    for (int i = 0; i < numberOfPairs; i++) {
+      ByteString name = ByteString.readLowerCase(nameValueBlockIn, nameValueBlockIn.readInt());
+      ByteString values = ByteString.read(nameValueBlockIn, nameValueBlockIn.readInt());
+      if (name.size() == 0) throw new IOException("name.size == 0");
+      entries.add(new Header(name, values));
+    }
 
-      doneReading();
+    doneReading();
 
-      return entries;
-    } catch (DataFormatException e) {
-      throw new IOException(e.getMessage());
-    }
+    return entries;
   }
 
   private void doneReading() throws IOException {
@@ -111,13 +106,6 @@ private void doneReading() throws IOException {
     }
   }
 
-  private ByteString readString() throws DataFormatException, IOException {
-    int length = nameValueBlockIn.readInt();
-    byte[] bytes = new byte[length];
-    Util.readFully(nameValueBlockIn, bytes);
-    return ByteString.of(bytes);
-  }
-
   @Override public void close() throws IOException {
     nameValueBlockIn.close();
   }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
index f8b13ae330..f886b1b2ad 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
@@ -15,17 +15,13 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-final class Settings {
-  /**
-   * spdy/3: The default initial window size for all streams is 64 KiB. (Chrome
-   * 25 uses 10 MiB).
-   */
-  static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
-  /** http/2: The default header compression table size is 4 KiB. */
-  static final int DEFAULT_HEADER_TABLE_SIZE = 4096;
-  /** http/2: The default is to enable PUSH_PROMISE frames. */
-  static final int DEFAULT_ENABLE_PUSH = 1;
+import java.util.Arrays;
 
+/**
+ * Settings describe characteristics of the sending peer, which are used by the receiving peer.
+ * Settings are {@link com.squareup.okhttp.internal.spdy.SpdyConnection connection} scoped.
+ */
+final class Settings {
   /** Peer request to clear durable settings. */
   static final int FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS = 0x1;
 
@@ -75,6 +71,11 @@
   /** Flag values. */
   private final int[] values = new int[COUNT];
 
+  void clear() {
+    set = persistValue = persisted = 0;
+    Arrays.fill(values, 0);
+  }
+
   void set(int id, int idFlags, int value) {
     if (id >= values.length) {
       return; // Discard unknown settings.
@@ -126,11 +127,10 @@ int getUploadBandwidth(int defaultValue) {
     return (bit & set) != 0 ? values[UPLOAD_BANDWIDTH] : defaultValue;
   }
 
-  /** http/2 only. */
-  // TODO: honor this setting in http/2.
+  /** http/2 only. Returns -1 if unset. */
   int getHeaderTableSize() {
     int bit = 1 << HEADER_TABLE_SIZE;
-    return (bit & set) != 0 ? values[HEADER_TABLE_SIZE] : DEFAULT_HEADER_TABLE_SIZE;
+    return (bit & set) != 0 ? values[HEADER_TABLE_SIZE] : -1;
   }
 
   /** spdy/3 only. */
@@ -141,9 +141,9 @@ int getDownloadBandwidth(int defaultValue) {
 
   /** http/2 only. */
   // TODO: honor this setting in http/2.
-  boolean getEnablePush() {
+  boolean getEnablePush(boolean defaultValue) {
     int bit = 1 << ENABLE_PUSH;
-    return ((bit & set) != 0 ? values[ENABLE_PUSH] : DEFAULT_ENABLE_PUSH) == 1;
+    return ((bit & set) != 0 ? values[ENABLE_PUSH] : defaultValue ? 1 : 0) == 1;
   }
 
   /** spdy/3 only. */
@@ -171,9 +171,10 @@ int getDownloadRetransRate(int defaultValue) {
   }
 
   // TODO: honor this setting in http/2.
-  int getInitialWindowSize(int defaultValue) {
+  /** Returns -1 if unset. */
+  int getInitialWindowSize() {
     int bit = 1 << INITIAL_WINDOW_SIZE;
-    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : defaultValue;
+    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : -1;
   }
 
   /** spdy/3 only. */
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 595ea7b787..ad5081d633 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
@@ -31,8 +32,18 @@
 
 final class Spdy3 implements Variant {
 
-  @Override public String getProtocol() {
-    return "spdy/3";
+  @Override public Protocol getProtocol() {
+    return Protocol.SPDY_3;
+  }
+
+  @Override public Settings defaultOkHttpSettings(boolean client) {
+    return initialPeerSettings(client); // no difference in defaults.
+  }
+
+  @Override public Settings initialPeerSettings(boolean client) {
+    Settings settings = new Settings();
+    settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
+    return settings;
   }
 
   static final int TYPE_DATA = 0x0;
@@ -93,11 +104,11 @@
     }
   }
 
-  @Override public FrameReader newReader(InputStream in, boolean client) {
+  @Override public FrameReader newReader(InputStream in, Settings ignored, boolean client) {
     return new Reader(in, client);
   }
 
-  @Override public FrameWriter newWriter(OutputStream out, boolean client) {
+  @Override public FrameWriter newWriter(OutputStream out, Settings ignored, boolean client) {
     return new Writer(out, client);
   }
 
@@ -202,7 +213,7 @@ private void readSynStream(Handler handler, int flags, int length) throws IOExce
       int associatedStreamId = w2 & 0x7fffffff;
       int priority = (s3 & 0xe000) >>> 13;
       int slot = s3 & 0xff;
-      List<ByteString> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 10);
+      List<Header> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 10);
 
       boolean inFinished = (flags & FLAG_FIN) != 0;
       boolean outFinished = (flags & FLAG_UNIDIRECTIONAL) != 0;
@@ -213,7 +224,7 @@ private void readSynStream(Handler handler, int flags, int length) throws IOExce
     private void readSynReply(Handler handler, int flags, int length) throws IOException {
       int w1 = in.readInt();
       int streamId = w1 & 0x7fffffff;
-      List<ByteString> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 4);
+      List<Header> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 4);
       boolean inFinished = (flags & FLAG_FIN) != 0;
       handler.headers(false, inFinished, streamId, -1, -1, nameValueBlock, HeadersMode.SPDY_REPLY);
     }
@@ -232,7 +243,7 @@ private void readRstStream(Handler handler, int flags, int length) throws IOExce
     private void readHeaders(Handler handler, int flags, int length) throws IOException {
       int w1 = in.readInt();
       int streamId = w1 & 0x7fffffff;
-      List<ByteString> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 4);
+      List<Header> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 4);
       handler.headers(false, false, streamId, -1, -1, nameValueBlock, HeadersMode.SPDY_HEADERS);
     }
 
@@ -307,6 +318,10 @@ private static IOException ioException(String message, Object... args) throws IO
           Platform.get().newDeflaterOutputStream(nameValueBlockBuffer, deflater, true));
     }
 
+    @Override public void ackSettings() {
+      // Do nothing: no ACK for SPDY/3 settings.
+    }
+
     @Override public synchronized void connectionHeader() {
       // Do nothing: no connection header for SPDY/3.
     }
@@ -317,7 +332,7 @@ private static IOException ioException(String message, Object... args) throws IO
 
     @Override
     public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, int slot, List<ByteString> nameValueBlock)
+        int associatedStreamId, int priority, int slot, List<Header> nameValueBlock)
         throws IOException {
       writeNameValueBlockToBuffer(nameValueBlock);
       int length = 10 + nameValueBlockBuffer.size();
@@ -335,7 +350,7 @@ public synchronized void synStream(boolean outFinished, boolean inFinished, int
     }
 
     @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<ByteString> nameValueBlock) throws IOException {
+        List<Header> nameValueBlock) throws IOException {
       writeNameValueBlockToBuffer(nameValueBlock);
       int type = TYPE_SYN_REPLY;
       int flags = (outFinished ? FLAG_FIN : 0);
@@ -348,7 +363,7 @@ public synchronized void synStream(boolean outFinished, boolean inFinished, int
       out.flush();
     }
 
-    @Override public synchronized void headers(int streamId, List<ByteString> nameValueBlock)
+    @Override public synchronized void headers(int streamId, List<Header> nameValueBlock)
         throws IOException {
       writeNameValueBlockToBuffer(nameValueBlock);
       int flags = 0;
@@ -388,14 +403,16 @@ public synchronized void synStream(boolean outFinished, boolean inFinished, int
       out.write(data, offset, byteCount);
     }
 
-    private void writeNameValueBlockToBuffer(List<ByteString> nameValueBlock) throws IOException {
+    private void writeNameValueBlockToBuffer(List<Header> nameValueBlock) throws IOException {
       nameValueBlockBuffer.reset();
-      int numberOfPairs = nameValueBlock.size() / 2;
-      nameValueBlockOut.writeInt(numberOfPairs);
+      nameValueBlockOut.writeInt(nameValueBlock.size());
       for (int i = 0, size = nameValueBlock.size(); i < size; i++) {
-        ByteString s = nameValueBlock.get(i);
-        nameValueBlockOut.writeInt(s.size());
-        s.write(nameValueBlockOut);
+        ByteString name = nameValueBlock.get(i).name;
+        nameValueBlockOut.writeInt(name.size());
+        name.write(nameValueBlockOut);
+        ByteString value = nameValueBlock.get(i).value;
+        nameValueBlockOut.writeInt(value.size());
+        value.write(nameValueBlockOut);
       }
       nameValueBlockOut.flush();
     }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index aefa0819fa..5ed07bbf4f 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -16,7 +16,7 @@
 
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Util;
 import java.io.Closeable;
@@ -60,7 +60,7 @@
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
       Util.threadFactory("OkHttp SpdyConnection", true));
 
-  /** The protocol variant, like SPDY/3 or HTTP-draft-09/2.0. */
+  /** The protocol variant, like {@link com.squareup.okhttp.internal.spdy.Spdy3}. */
   final Variant variant;
 
   /** True if this peer initiated the connection. */
@@ -71,9 +71,6 @@
    * run on the callback executor.
    */
   private final IncomingStreamHandler handler;
-  private final FrameReader frameReader;
-  private final FrameWriter frameWriter;
-
   private final Map<Integer, SpdyStream> streams = new HashMap<Integer, SpdyStream>();
   private final String hostName;
   private int lastGoodStreamId;
@@ -85,17 +82,24 @@
   private Map<Integer, Ping> pings;
   private int nextPingId;
 
-  /** Lazily-created settings for the peer. */
-  Settings settings;
+  final Settings okHttpSettings;
+  final Settings peerSettings;
+  final FrameReader frameReader;
+  final FrameWriter frameWriter;
 
-  ByteArrayPool bufferPool = new ByteArrayPool(8 * Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+  final ByteArrayPool bufferPool;
 
   private SpdyConnection(Builder builder) {
     variant = builder.variant;
     client = builder.client;
+    okHttpSettings = variant.defaultOkHttpSettings(client);
+    // TODO: implement stream limit
+    // okHttpSettings.set(Settings.MAX_CONCURRENT_STREAMS, 0, max);
+    peerSettings = variant.initialPeerSettings(client);
+    bufferPool = new ByteArrayPool(peerSettings.getInitialWindowSize() * 8);
     handler = builder.handler;
-    frameReader = variant.newReader(builder.in, client);
-    frameWriter = variant.newWriter(builder.out, client);
+    frameReader = variant.newReader(builder.in, peerSettings, client);
+    frameWriter = variant.newWriter(builder.out, okHttpSettings, client);
     nextStreamId = builder.client ? 1 : 2;
     nextPingId = builder.client ? 1 : 2;
 
@@ -104,12 +108,8 @@ private SpdyConnection(Builder builder) {
     new Thread(new Reader()).start(); // Not a daemon thread.
   }
 
-  /**
-   * The protocol name, like {@code spdy/3} or {@code HTTP-draft-09/2.0}.
-   *
-   * @see com.squareup.okhttp.internal.spdy.Variant#getProtocol()
-   */
-  public String getProtocol() {
+  /** The protocol as selected using NPN or ALPN. */
+  public Protocol getProtocol() {
      return variant.getProtocol();
   }
 
@@ -158,7 +158,7 @@ public synchronized long getIdleStartTimeNs() {
    * @param in true to create an input stream that the remote peer can use to
    *     send data to us. Corresponds to {@code FLAG_UNIDIRECTIONAL}.
    */
-  public SpdyStream newStream(List<ByteString> requestHeaders, boolean out, boolean in)
+  public SpdyStream newStream(List<Header> requestHeaders, boolean out, boolean in)
       throws IOException {
     boolean outFinished = !out;
     boolean inFinished = !in;
@@ -176,7 +176,7 @@ public SpdyStream newStream(List<ByteString> requestHeaders, boolean out, boolea
         streamId = nextStreamId;
         nextStreamId += 2;
         stream = new SpdyStream(
-            streamId, this, outFinished, inFinished, priority, requestHeaders, settings);
+            streamId, this, outFinished, inFinished, priority, requestHeaders, peerSettings);
         if (stream.isOpen()) {
           streams.put(streamId, stream);
           setIdle(false);
@@ -190,7 +190,7 @@ public SpdyStream newStream(List<ByteString> requestHeaders, boolean out, boolea
     return stream;
   }
 
-  void writeSynReply(int streamId, boolean outFinished, List<ByteString> alternating)
+  void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
       throws IOException {
     frameWriter.synReply(outFinished, streamId, alternating);
   }
@@ -372,7 +372,7 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
    */
   public void sendConnectionHeader() throws IOException {
     frameWriter.connectionHeader();
-    frameWriter.settings(new Settings());
+    frameWriter.settings(okHttpSettings);
   }
 
   /**
@@ -423,13 +423,15 @@ public Builder handler(IncomingStreamHandler handler) {
       return this;
     }
 
-    public Builder spdy3() {
-      this.variant = Variant.SPDY3;
-      return this;
-    }
-
-    public Builder http20Draft09() {
-      this.variant = Variant.HTTP_20_DRAFT_09;
+    public Builder protocol(Protocol protocol) {
+      // TODO: protocol == variant.getProtocol, so we could map this.
+      if (protocol == Protocol.HTTP_2) {
+        this.variant = Variant.HTTP_20_DRAFT_09;
+      } else if (protocol == Protocol.SPDY_3) {
+        this.variant = Variant.SPDY3;
+      } else {
+        throw new AssertionError(protocol);
+      }
       return this;
     }
 
@@ -477,7 +479,7 @@ private Reader() {
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<ByteString> nameValueBlock,
+        int associatedStreamId, int priority, List<Header> nameValueBlock,
         HeadersMode headersMode) {
       SpdyStream stream;
       synchronized (SpdyConnection.this) {
@@ -501,7 +503,7 @@ private Reader() {
 
           // Create a stream.
           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,
-              inFinished, priority, nameValueBlock, settings);
+              inFinished, priority, nameValueBlock, peerSettings);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
           executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
@@ -539,10 +541,13 @@ private Reader() {
     @Override public void settings(boolean clearPrevious, Settings newSettings) {
       SpdyStream[] streamsToNotify = null;
       synchronized (SpdyConnection.this) {
-        if (settings == null || clearPrevious) {
-          settings = newSettings;
+        if (clearPrevious) {
+          peerSettings.clear();
         } else {
-          settings.merge(newSettings);
+          peerSettings.merge(newSettings);
+        }
+        if (SpdyConnection.this.variant.getProtocol() == Protocol.HTTP_2) {
+          ackSettingsLater();
         }
         if (!streams.isEmpty()) {
           streamsToNotify = streams.values().toArray(new SpdyStream[streams.size()]);
@@ -551,18 +556,29 @@ private Reader() {
       if (streamsToNotify != null) {
         for (SpdyStream stream : streamsToNotify) {
           // The synchronization here is ugly. We need to synchronize on 'this' to guard
-          // reads to 'settings'. We synchronize on 'stream' to guard the state change.
+          // reads to 'peerSettings'. We synchronize on 'stream' to guard the state change.
           // And we need to acquire the 'stream' lock first, since that may block.
           // TODO: this can block the reader thread until a write completes. That's bad!
           synchronized (stream) {
             synchronized (SpdyConnection.this) {
-              stream.receiveSettings(settings);
+              stream.receiveSettings(peerSettings);
             }
           }
         }
       }
     }
 
+    private void ackSettingsLater() {
+      executor.submit(new NamedRunnable("OkHttp %s ACK Settings", hostName) {
+        @Override public void execute() {
+          try {
+            frameWriter.ackSettings();
+          } catch (IOException ignored) {
+          }
+        }
+      });
+    }
+
     @Override public void noop() {
     }
 
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index baf7e6dc18..dbfb2dc3a9 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -16,7 +16,6 @@
 
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.io.InputStream;
@@ -40,19 +39,19 @@
    * window size, otherwise the remote peer will stop sending data on this
    * stream. (Chrome 25 uses 5 MiB.)
    */
-  public static final int WINDOW_UPDATE_THRESHOLD = Settings.DEFAULT_INITIAL_WINDOW_SIZE / 2;
+  int windowUpdateThreshold;
+  private int writeWindowSize;
 
   private final int id;
   private final SpdyConnection connection;
   private final int priority;
   private long readTimeoutMillis = 0;
-  private int writeWindowSize;
 
   /** Headers sent by the stream initiator. Immutable and non null. */
-  private final List<ByteString> requestHeaders;
+  private final List<Header> requestHeaders;
 
   /** Headers sent in the stream reply. Null if reply is either not sent or not sent yet. */
-  private List<ByteString> responseHeaders;
+  private List<Header> responseHeaders;
 
   private final SpdyDataInputStream in;
   private final SpdyDataOutputStream out;
@@ -65,19 +64,18 @@
   private ErrorCode errorCode = null;
 
   SpdyStream(int id, SpdyConnection connection, boolean outFinished, boolean inFinished,
-      int priority, List<ByteString> requestHeaders, Settings settings) {
+      int priority, List<Header> requestHeaders, Settings peerSettings) {
     if (connection == null) throw new NullPointerException("connection == null");
     if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
     this.id = id;
     this.connection = connection;
-    this.in = new SpdyDataInputStream();
+    this.in = new SpdyDataInputStream(peerSettings.getInitialWindowSize());
     this.out = new SpdyDataOutputStream();
     this.in.finished = inFinished;
     this.out.finished = outFinished;
     this.priority = priority;
     this.requestHeaders = requestHeaders;
-
-    setSettings(settings);
+    setPeerSettings(peerSettings);
   }
 
   /**
@@ -110,7 +108,7 @@ public SpdyConnection getConnection() {
     return connection;
   }
 
-  public List<ByteString> getRequestHeaders() {
+  public List<Header> getRequestHeaders() {
     return requestHeaders;
   }
 
@@ -118,7 +116,7 @@ public SpdyConnection getConnection() {
    * Returns the stream's response headers, blocking if necessary if they
    * have not been received yet.
    */
-  public synchronized List<ByteString> getResponseHeaders() throws IOException {
+  public synchronized List<Header> getResponseHeaders() throws IOException {
     long remaining = 0;
     long start = 0;
     if (readTimeoutMillis != 0) {
@@ -162,7 +160,7 @@ public synchronized ErrorCode getErrorCode() {
    * @param out true to create an output stream that we can use to send data
    * to the remote peer. Corresponds to {@code FLAG_FIN}.
    */
-  public void reply(List<ByteString> responseHeaders, boolean out) throws IOException {
+  public void reply(List<Header> responseHeaders, boolean out) throws IOException {
     assert (!Thread.holdsLock(SpdyStream.this));
     boolean outFinished = false;
     synchronized (this) {
@@ -255,7 +253,7 @@ private boolean closeInternal(ErrorCode errorCode) {
     return true;
   }
 
-  void receiveHeaders(List<ByteString> headers, HeadersMode headersMode) {
+  void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
     assert (!Thread.holdsLock(SpdyStream.this));
     ErrorCode errorCode = null;
     boolean open = true;
@@ -272,7 +270,7 @@ void receiveHeaders(List<ByteString> headers, HeadersMode headersMode) {
         if (headersMode.failIfHeadersPresent()) {
           errorCode = ErrorCode.STREAM_IN_USE;
         } else {
-          List<ByteString> newHeaders = new ArrayList<ByteString>();
+          List<Header> newHeaders = new ArrayList<Header>();
           newHeaders.addAll(responseHeaders);
           newHeaders.addAll(headers);
           this.responseHeaders = newHeaders;
@@ -311,18 +309,18 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     }
   }
 
-  private void setSettings(Settings settings) {
+  private void setPeerSettings(Settings peerSettings) {
     // TODO: For HTTP/2.0, also adjust the stream flow control window size
     // by the difference between the new value and the old value.
     assert (Thread.holdsLock(connection)); // Because 'settings' is guarded by 'connection'.
-    this.writeWindowSize = settings != null
-        ? settings.getInitialWindowSize(Settings.DEFAULT_INITIAL_WINDOW_SIZE)
-        : Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+    this.writeWindowSize = peerSettings.getInitialWindowSize();
+    this.windowUpdateThreshold = peerSettings.getInitialWindowSize() / 2;
   }
 
-  void receiveSettings(Settings settings) {
+  /** Notification received when peer settings change. */
+  void receiveSettings(Settings peerSettings) {
     assert (Thread.holdsLock(this));
-    setSettings(settings);
+    setPeerSettings(peerSettings);
     notifyAll();
   }
 
@@ -341,6 +339,7 @@ int getPriority() {
    * it is not intended for use by multiple readers.
    */
   private final class SpdyDataInputStream extends InputStream {
+
     // Store incoming data bytes in a circular buffer. When the buffer is
     // empty, pos == -1. Otherwise pos is the first byte to read and limit
     // is the first byte to write.
@@ -352,9 +351,13 @@ int getPriority() {
     // { X X X - - - - X X X }
     //         ^       ^
     //       limit    pos
+    private final byte[] buffer;
 
-    private final byte[] buffer = SpdyStream.this.connection.bufferPool.getBuf(
-        Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+    private SpdyDataInputStream(int bufferLength) {
+      // TODO: We probably need to change to growable buffers here pretty soon.
+      // Otherwise we have a performance problem where we pay for 64 KiB even if we aren't using it.
+      buffer = connection.bufferPool.getBuf(bufferLength);
+    }
 
     /** the next byte to be read, or -1 if the buffer is empty. Never buffer.length */
     private int pos = -1;
@@ -428,7 +431,7 @@ int getPriority() {
 
         // Flow control: notify the peer that we're ready for more data!
         unacknowledgedBytes += copied;
-        if (unacknowledgedBytes >= WINDOW_UPDATE_THRESHOLD) {
+        if (unacknowledgedBytes >= windowUpdateThreshold) {
           connection.writeWindowUpdateLater(id, unacknowledgedBytes);
           unacknowledgedBytes = 0;
         }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
index 3ff3e0b2f9..116f9ea1e6 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.Protocol;
 import java.io.InputStream;
 import java.io.OutputStream;
 
@@ -23,18 +24,32 @@
   Variant SPDY3 = new Spdy3();
   Variant HTTP_20_DRAFT_09 = new Http20Draft09();
 
-  /** The protocol name, like {@code spdy/3} or {@code HTTP-draft-09/2.0}. */
-  String getProtocol();
+  /** The protocol as selected using NPN or ALPN. */
+  Protocol getProtocol();
 
   /**
-   * @param client true if this is the HTTP client's reader, reading frames from
-   *     a peer SPDY or HTTP/2 server.
+   * Default settings used for sending frames to the peer.
+   * @param client true if these settings apply to writing requests, false if responses.
    */
-  FrameReader newReader(InputStream in, boolean client);
+  Settings defaultOkHttpSettings(boolean client);
 
   /**
-   * @param client true if this is the HTTP client's writer, writing frames to a
-   *     peer SPDY or HTTP/2 server.
+   * Initial settings used for reading frames from the peer until we are sent
+   * a Settings frame.
+   * @param client true if these settings apply to reading responses, false if requests.
    */
-  FrameWriter newWriter(OutputStream out, boolean client);
+  Settings initialPeerSettings(boolean client);
+
+  /**
+   * @param peerSettings potentially stale settings that reflect the remote peer.
+   * @param client true if this is the HTTP client's reader, reading frames from a server.
+   */
+  FrameReader newReader(InputStream in, Settings peerSettings, boolean client);
+
+  /**
+   * @param okHttpSettings settings configured locally.
+   * @param client true if this is the HTTP client's writer, writing frames to a server.
+   */
+  FrameWriter newWriter(OutputStream out, Settings okHttpSettings, boolean client);
+
 }
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
new file mode 100644
index 0000000000..7f80c3b949
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
@@ -0,0 +1,190 @@
+/*
+ * Copyright 2014 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import java.math.BigInteger;
+import org.junit.Test;
+
+import static java.util.Arrays.asList;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class BitArrayTest {
+
+  /** Lazy grow into a variable capacity bit set. */
+  @Test public void hpackUseCase() {
+    BitArray b = new BitArray.FixedCapacity();
+    for (int i = 0; i < 64; i++) {
+      b.set(i);
+    }
+    assertTrue(b.get(0));
+    assertTrue(b.get(1));
+    assertTrue(b.get(63));
+    try {
+      b.get(64);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    b = ((BitArray.FixedCapacity) b).toVariableCapacity();
+    assertTrue(b.get(0));
+    assertTrue(b.get(1));
+    assertTrue(b.get(63));
+    assertFalse(b.get(64));
+    b.set(64);
+    assertTrue(b.get(64));
+  }
+
+  @Test public void setExpandsData_FixedCapacity() {
+    BitArray.FixedCapacity b = new BitArray.FixedCapacity();
+    b.set(63);
+    assertEquals(b.data, BigInteger.ZERO.setBit(63).longValue());
+  }
+
+  @Test public void toggleBit_FixedCapacity() {
+    BitArray.FixedCapacity b = new BitArray.FixedCapacity();
+    b.set(63);
+    b.toggle(63);
+    assertEquals(b.data, 0l);
+    b.toggle(1);
+    assertEquals(b.data, 2l);
+  }
+
+  @Test public void shiftLeft_FixedCapacity() {
+    BitArray.FixedCapacity b = new BitArray.FixedCapacity();
+    b.set(0);
+    b.shiftLeft(1);
+    assertEquals(b.data, 2l);
+  }
+
+  @Test public void multipleShifts_FixedCapacity() {
+    BitArray.FixedCapacity b = new BitArray.FixedCapacity();
+    b.set(10);
+    b.shiftLeft(2);
+    b.shiftLeft(2);
+    assertEquals(b.data, BigInteger.ZERO.setBit(10).shiftLeft(2).shiftLeft(2).longValue());
+  }
+
+  @Test public void clearBits_FixedCapacity() {
+    BitArray.FixedCapacity b = new BitArray.FixedCapacity();
+    b.set(1);
+    b.set(3);
+    b.set(5);
+    b.clear();
+    assertEquals(b.data, 0l);
+  }
+
+  @Test public void setExpandsData_VariableCapacity() {
+    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
+    b.set(64);
+    assertEquals(asList(64), b.toIntegerList());
+  }
+
+  @Test public void toggleBit_VariableCapacity() {
+    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
+    b.set(100);
+    b.toggle(100);
+    assertTrue(b.toIntegerList().isEmpty());
+    b.toggle(1);
+    assertEquals(asList(1), b.toIntegerList());
+  }
+
+  @Test public void shiftLeftExpandsData_VariableCapacity() {
+    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
+    b.set(0);
+    b.shiftLeft(64);
+    assertEquals(asList(64), b.toIntegerList());
+  }
+
+  @Test public void shiftLeftFromZero_VariableCapacity() {
+    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
+    b.set(0);
+    b.shiftLeft(1);
+    assertEquals(asList(1), b.toIntegerList());
+  }
+
+  @Test public void shiftLeftAcrossOffset_VariableCapacity() {
+    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
+    b.set(63);
+    assertEquals(1, b.data.length);
+    b.shiftLeft(1);
+    assertEquals(asList(64), b.toIntegerList());
+    assertEquals(2, b.data.length);
+  }
+
+  @Test public void multipleShiftsLeftAcrossOffset_VariableCapacity() {
+    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
+    b.set(1000);
+    b.shiftLeft(67);
+    assertEquals(asList(1067), b.toIntegerList());
+    b.shiftLeft(69);
+    assertEquals(asList(1136), b.toIntegerList());
+  }
+
+  @Test public void clearBits_VariableCapacity() {
+    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
+    b.set(10);
+    b.set(100);
+    b.set(1000);
+    b.clear();
+    assertTrue(b.toIntegerList().isEmpty());
+  }
+
+  @Test public void bigIntegerSanityCheck_VariableCapacity() {
+    BitArray a = new BitArray.VariableCapacity();
+    BigInteger b = BigInteger.ZERO;
+
+    a.set(64);
+    b = b.setBit(64);
+    assertEquals(bigIntegerToString(b), a.toString());
+
+    a.set(1000000);
+    b = b.setBit(1000000);
+    assertEquals(bigIntegerToString(b), a.toString());
+
+    a.shiftLeft(100);
+    b = b.shiftLeft(100);
+    assertEquals(bigIntegerToString(b), a.toString());
+
+    a.set(0xF00D);
+    b = b.setBit(0xF00D);
+    a.set(0xBEEF);
+    b = b.setBit(0xBEEF);
+    a.set(0xDEAD);
+    b = b.setBit(0xDEAD);
+    assertEquals(bigIntegerToString(b), a.toString());
+
+    a.shiftLeft(0xB0B);
+    b = b.shiftLeft(0xB0B);
+    assertEquals(bigIntegerToString(b), a.toString());
+
+    a.toggle(64280);
+    b = b.clearBit(64280);
+    assertEquals(bigIntegerToString(b), a.toString());
+  }
+
+  private static String bigIntegerToString(BigInteger b) {
+    StringBuilder builder = new StringBuilder("{");
+    for (int i = 0, count = b.bitLength(); i < count; i++) {
+      if (b.testBit(i)) {
+        builder.append(i).append(',');
+      }
+    }
+    builder.setCharAt(builder.length() - 1, '}');
+    return builder.toString();
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
index 95b91d176e..bf8101caf6 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
@@ -41,12 +41,20 @@
 
   @Test public void utf8() throws Exception {
     ByteString byteString = ByteString.encodeUtf8(bronzeHorseman);
-    assertByteArraysEquals(byteString.toByteArray(), bronzeHorseman.getBytes("UTF-8"));
-    assertTrue(byteString.equals(ByteString.of(bronzeHorseman.getBytes("UTF-8"))));
-    assertTrue(byteString.utf8Equals(bronzeHorseman));
+    assertByteArraysEquals(byteString.toByteArray(), bronzeHorseman.getBytes(Util.UTF_8));
+    assertTrue(byteString.equals(ByteString.of(bronzeHorseman.getBytes(Util.UTF_8))));
     assertEquals(byteString.utf8(), bronzeHorseman);
   }
 
+  @Test public void equalsAscii() throws Exception {
+    ByteString byteString = ByteString.encodeUtf8("Content-Length");
+    assertTrue(byteString.equalsAscii("Content-Length"));
+    assertFalse(byteString.equalsAscii("content-length"));
+    assertFalse(ByteString.of((byte) 0x63).equalsAscii(null));
+    assertFalse(byteString.equalsAscii(bronzeHorseman));
+    assertFalse(ByteString.encodeUtf8("Content-Length").equalsAscii("content-length"));
+  }
+
   @Test public void testHashCode() throws Exception {
     ByteString byteString = ByteString.of((byte) 0x1, (byte) 0x2);
     assertEquals(byteString.hashCode(), byteString.hashCode());
@@ -54,24 +62,25 @@
   }
 
   @Test public void read() throws Exception {
-    InputStream in = new ByteArrayInputStream("abc".getBytes("UTF-8"));
+    InputStream in = new ByteArrayInputStream("abc".getBytes(Util.UTF_8));
     assertEquals(ByteString.of((byte) 0x61, (byte) 0x62), ByteString.read(in, 2));
     assertEquals(ByteString.of((byte) 0x63), ByteString.read(in, 1));
     assertEquals(ByteString.of(), ByteString.read(in, 0));
   }
 
+  @Test public void readLowerCase() throws Exception {
+    InputStream in = new ByteArrayInputStream("ABC".getBytes(Util.UTF_8));
+    assertEquals(ByteString.of((byte) 0x61, (byte) 0x62), ByteString.readLowerCase(in, 2));
+    assertEquals(ByteString.of((byte) 0x63), ByteString.readLowerCase(in, 1));
+    assertEquals(ByteString.of(), ByteString.readLowerCase(in, 0));
+  }
+
   @Test public void write() throws Exception {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     ByteString.of((byte) 0x61, (byte) 0x62, (byte) 0x63).write(out);
     assertByteArraysEquals(new byte[] { 0x61, 0x62, 0x63 }, out.toByteArray());
   }
 
-  @Test public void writeWithOffset() throws Exception {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    ByteString.of((byte) 0x61, (byte) 0x62, (byte) 0x63).write(out, 1, 2);
-    assertByteArraysEquals(new byte[] { 0x62, 0x63 }, out.toByteArray());
-  }
-
   @Test public void concat() {
     assertEquals(ByteString.of(), ByteString.concat());
     assertEquals(ByteString.of(), ByteString.concat(ByteString.EMPTY));
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
index 9933b09a82..eefb461f75 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -15,7 +15,6 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.List;
@@ -30,7 +29,7 @@
 
   @Override
   public void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      int priority, List<ByteString> nameValueBlock, HeadersMode headersMode) {
+      int priority, List<Header> nameValueBlock, HeadersMode headersMode) {
     fail();
   }
 
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index 2ddb84315f..7bd99b2016 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -26,12 +26,11 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.Util.byteStringList;
-import static com.squareup.okhttp.internal.spdy.HpackDraft05.bitPositionSet;
+import static com.squareup.okhttp.internal.Util.headerEntries;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
 
 public class HpackDraft05Test {
 
@@ -39,7 +38,7 @@
   private HpackDraft05.Reader hpackReader;
 
   @Before public void resetReader() {
-    hpackReader = new HpackDraft05.Reader(false, new DataInputStream(bytesIn));
+    hpackReader = newReader(new DataInputStream(bytesIn));
   }
 
   /**
@@ -57,13 +56,13 @@
     out.write("custom-header".getBytes(), 0, 13);
 
     bytesIn.set(out.toByteArray());
-    hpackReader.maxHeaderTableByteCount = 1;
+    hpackReader.maxHeaderTableByteCount(1);
     hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
     assertEquals(0, hpackReader.headerCount);
 
-    assertEquals(byteStringList("custom-key", "custom-header"), hpackReader.getAndReset());
+    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndReset());
   }
 
   /** Oldest entries are evicted to support newer ones. */
@@ -92,13 +91,14 @@
     out.write("custom-header".getBytes(), 0, 13);
 
     bytesIn.set(out.toByteArray());
-    hpackReader.maxHeaderTableByteCount = 110;
+    // Set to only support 110 bytes (enough for 2 headers).
+    hpackReader.maxHeaderTableByteCount(110);
     hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
     assertEquals(2, hpackReader.headerCount);
 
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
     checkEntry(entry, "custom-bar", "custom-header", 55);
     assertHeaderReferenced(headerTableLength() - 1);
 
@@ -108,15 +108,19 @@
 
     // foo isn't here as it is no longer in the table.
     // TODO: emit before eviction?
-    assertEquals(byteStringList("custom-bar", "custom-header", "custom-baz", "custom-header"),
+    assertEquals(headerEntries("custom-bar", "custom-header", "custom-baz", "custom-header"),
         hpackReader.getAndReset());
+
+    // Simulate receiving a small settings frame, that implies eviction.
+    hpackReader.maxHeaderTableByteCount(55);
+    assertEquals(1, hpackReader.headerCount);
   }
 
   /** Header table backing array is initially 8 long, let's ensure it grows. */
-  @Test public void dynamicallyGrowsUpTo64Entries() throws IOException {
+  @Test public void dynamicallyGrowsBeyond64Entries() throws IOException {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
 
-    for (int i = 0; i < 64; i++) {
+    for (int i = 0; i < 256; i++) {
       out.write(0x00); // Literal indexed
       out.write(0x0a); // Literal name (len = 10)
       out.write("custom-foo".getBytes(), 0, 10);
@@ -126,34 +130,16 @@
     }
 
     bytesIn.set(out.toByteArray());
+    hpackReader.maxHeaderTableByteCount(16384); // Lots of headers need more room!
     hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
-    assertEquals(64, hpackReader.headerCount);
-  }
-
-  @Test public void greaterThan64HeadersNotYetSupported() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-
-    for (int i = 0; i < 65; i++) {
-      out.write(0x00); // Literal indexed
-      out.write(0x0a); // Literal name (len = 10)
-      out.write("custom-foo".getBytes(), 0, 10);
-
-      out.write(0x0d); // Literal value (len = 13)
-      out.write("custom-header".getBytes(), 0, 13);
-    }
-
-    bytesIn.set(out.toByteArray());
-    try {
-      hpackReader.readHeaders(out.size());
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
+    assertEquals(256, hpackReader.headerCount);
+    assertHeaderReferenced(headerTableLength() - 1);
+    assertHeaderReferenced(headerTableLength() - hpackReader.headerCount);
   }
 
-  /** Huffman headers are accepted, but come out as garbage for now. */
-  @Test public void huffmanDecodingNotYetSupported() throws IOException {
+  @Test public void huffmanDecodingSupported() throws IOException {
     ByteArrayOutputStream out = new ByteArrayOutputStream();
 
     out.write(0x04); // == Literal indexed ==
@@ -173,7 +159,7 @@
     assertEquals(1, hpackReader.headerCount);
     assertEquals(52, hpackReader.headerTableByteCount);
 
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
     checkEntry(entry, ":path", "www.example.com", 52);
     assertHeaderReferenced(headerTableLength() - 1);
   }
@@ -198,11 +184,11 @@
     assertEquals(1, hpackReader.headerCount);
     assertEquals(55, hpackReader.headerTableByteCount);
 
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
     checkEntry(entry, "custom-key", "custom-header", 55);
     assertHeaderReferenced(headerTableLength() - 1);
 
-    assertEquals(byteStringList("custom-key", "custom-header"), hpackReader.getAndReset());
+    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndReset());
   }
 
   /**
@@ -222,7 +208,7 @@
 
     assertEquals(0, hpackReader.headerCount);
 
-    assertEquals(byteStringList(":path", "/sample/path"), hpackReader.getAndReset());
+    assertEquals(headerEntries(":path", "/sample/path"), hpackReader.getAndReset());
   }
 
   /**
@@ -241,11 +227,38 @@
     assertEquals(1, hpackReader.headerCount);
     assertEquals(42, hpackReader.headerTableByteCount);
 
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 1];
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
     checkEntry(entry, ":method", "GET", 42);
     assertHeaderReferenced(headerTableLength() - 1);
 
-    assertEquals(byteStringList(":method", "GET"), hpackReader.getAndReset());
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-3.2.1
+   */
+  @Test public void toggleIndex() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    // Static table entries are copied to the top of the reference set.
+    out.write(0x82); // == Indexed - Add ==
+                     // idx = 2 -> :method: GET
+    // Specifying an index to an entry in the reference set removes it.
+    out.write(0x81); // == Indexed - Remove ==
+                     // idx = 1 -> :method: GET
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(42, hpackReader.headerTableByteCount);
+
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderNotReferenced(headerTableLength() - 1);
+
+    assertTrue(hpackReader.getAndReset().isEmpty());
   }
 
   /**
@@ -258,14 +271,14 @@
                      // idx = 2 -> :method: GET
 
     bytesIn.set(out.toByteArray());
-    hpackReader.maxHeaderTableByteCount = 0; // SETTINGS_HEADER_TABLE_SIZE == 0
+    hpackReader.maxHeaderTableByteCount(0); // SETTINGS_HEADER_TABLE_SIZE == 0
     hpackReader.readHeaders(out.size());
     hpackReader.emitReferenceSet();
 
     // Not buffered in header table.
     assertEquals(0, hpackReader.headerCount);
 
-    assertEquals(byteStringList(":method", "GET"), hpackReader.getAndReset());
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());
   }
 
   /**
@@ -312,7 +325,7 @@ private void checkFirstRequestWithoutHuffman() {
     assertEquals(4, hpackReader.headerCount);
 
     // [  1] (s =  57) :authority: www.example.com
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 4];
+    Header entry = hpackReader.headerTable[headerTableLength() - 4];
     checkEntry(entry, ":authority", "www.example.com", 57);
     assertHeaderReferenced(headerTableLength() - 4);
 
@@ -335,7 +348,7 @@ private void checkFirstRequestWithoutHuffman() {
     assertEquals(180, hpackReader.headerTableByteCount);
 
     // Decoded header set:
-    assertEquals(byteStringList(
+    assertEquals(headerEntries(
         ":method", "GET",
         ":scheme", "http",
         ":path", "/",
@@ -357,7 +370,7 @@ private void checkSecondRequestWithoutHuffman() {
     assertEquals(5, hpackReader.headerCount);
 
     // [  1] (s =  53) cache-control: no-cache
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 5];
+    Header entry = hpackReader.headerTable[headerTableLength() - 5];
     checkEntry(entry, "cache-control", "no-cache", 53);
     assertHeaderReferenced(headerTableLength() - 5);
 
@@ -385,7 +398,7 @@ private void checkSecondRequestWithoutHuffman() {
     assertEquals(233, hpackReader.headerTableByteCount);
 
     // Decoded header set:
-    assertEquals(byteStringList(
+    assertEquals(headerEntries(
         ":method", "GET",
         ":scheme", "http",
         ":path", "/",
@@ -418,7 +431,7 @@ private void checkThirdRequestWithoutHuffman() {
     assertEquals(8, hpackReader.headerCount);
 
     // [  1] (s =  54) custom-key: custom-value
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 8];
+    Header entry = hpackReader.headerTable[headerTableLength() - 8];
     checkEntry(entry, "custom-key", "custom-value", 54);
     assertHeaderReferenced(headerTableLength() - 8);
 
@@ -462,7 +475,7 @@ private void checkThirdRequestWithoutHuffman() {
 
     // Decoded header set:
     // TODO: order is not correct per docs, but then again, the spec doesn't require ordering.
-    assertEquals(byteStringList(
+    assertEquals(headerEntries(
         ":method", "GET",
         ":authority", "www.example.com",
         ":scheme", "https",
@@ -519,7 +532,7 @@ private void checkFirstRequestWithHuffman() {
     assertEquals(4, hpackReader.headerCount);
 
     // [  1] (s =  57) :authority: www.example.com
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 4];
+    Header entry = hpackReader.headerTable[headerTableLength() - 4];
     checkEntry(entry, ":authority", "www.example.com", 57);
     assertHeaderReferenced(headerTableLength() - 4);
 
@@ -542,7 +555,7 @@ private void checkFirstRequestWithHuffman() {
     assertEquals(180, hpackReader.headerTableByteCount);
 
     // Decoded header set:
-    assertEquals(byteStringList(
+    assertEquals(headerEntries(
         ":method", "GET",
         ":scheme", "http",
         ":path", "/",
@@ -568,7 +581,7 @@ private void checkSecondRequestWithHuffman() {
     assertEquals(5, hpackReader.headerCount);
 
     // [  1] (s =  53) cache-control: no-cache
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 5];
+    Header entry = hpackReader.headerTable[headerTableLength() - 5];
     checkEntry(entry, "cache-control", "no-cache", 53);
     assertHeaderReferenced(headerTableLength() - 5);
 
@@ -596,7 +609,7 @@ private void checkSecondRequestWithHuffman() {
     assertEquals(233, hpackReader.headerTableByteCount);
 
     // Decoded header set:
-    assertEquals(byteStringList(
+    assertEquals(headerEntries(
         ":method", "GET",
         ":scheme", "http",
         ":path", "/",
@@ -638,7 +651,7 @@ private void checkThirdRequestWithHuffman() {
     assertEquals(8, hpackReader.headerCount);
 
     // [  1] (s =  54) custom-key: custom-value
-    HpackDraft05.HeaderEntry entry = hpackReader.headerTable[headerTableLength() - 8];
+    Header entry = hpackReader.headerTable[headerTableLength() - 8];
     checkEntry(entry, "custom-key", "custom-value", 54);
     assertHeaderReferenced(headerTableLength() - 8);
 
@@ -682,7 +695,7 @@ private void checkThirdRequestWithHuffman() {
 
     // Decoded header set:
     // TODO: order is not correct per docs, but then again, the spec doesn't require ordering.
-    assertEquals(byteStringList(
+    assertEquals(headerEntries(
         ":method", "GET",
         ":authority", "www.example.com",
         ":scheme", "https",
@@ -695,12 +708,12 @@ private void checkThirdRequestWithHuffman() {
       new HpackDraft05.Writer(new DataOutputStream(bytesOut));
 
   @Test public void readSingleByteInt() throws IOException {
-    assertEquals(10, new HpackDraft05.Reader(false, byteStream()).readInt(10, 31));
-    assertEquals(10, new HpackDraft05.Reader(false, byteStream()).readInt(0xe0 | 10, 31));
+    assertEquals(10, newReader(byteStream()).readInt(10, 31));
+    assertEquals(10, newReader(byteStream()).readInt(0xe0 | 10, 31));
   }
 
   @Test public void readMultibyteInt() throws IOException {
-    assertEquals(1337, new HpackDraft05.Reader(false, byteStream(154, 10)).readInt(31, 31));
+    assertEquals(1337, newReader(byteStream(154, 10)).readInt(31, 31));
   }
 
   @Test public void writeSingleByteInt() throws IOException {
@@ -721,65 +734,64 @@ private void checkThirdRequestWithHuffman() {
     hpackWriter.writeInt(0x7fffffff, 31, 0);
     assertBytes(31, 224, 255, 255, 255, 7);
     assertEquals(0x7fffffff,
-        new HpackDraft05.Reader(false, byteStream(224, 255, 255, 255, 7)).readInt(31, 31));
+        newReader(byteStream(224, 255, 255, 255, 7)).readInt(31, 31));
   }
 
   @Test public void prefixMask() throws IOException {
     hpackWriter.writeInt(31, 31, 0);
     assertBytes(31, 0);
-    assertEquals(31, new HpackDraft05.Reader(false, byteStream(0)).readInt(31, 31));
+    assertEquals(31, newReader(byteStream(0)).readInt(31, 31));
   }
 
   @Test public void prefixMaskMinusOne() throws IOException {
     hpackWriter.writeInt(30, 31, 0);
     assertBytes(30);
-    assertEquals(31, new HpackDraft05.Reader(false, byteStream(0)).readInt(31, 31));
+    assertEquals(31, newReader(byteStream(0)).readInt(31, 31));
   }
 
   @Test public void zero() throws IOException {
     hpackWriter.writeInt(0, 31, 0);
     assertBytes(0);
-    assertEquals(0, new HpackDraft05.Reader(false, byteStream()).readInt(0, 31));
+    assertEquals(0, newReader(byteStream()).readInt(0, 31));
   }
 
   @Test public void headerName() throws IOException {
     hpackWriter.writeByteString(ByteString.encodeUtf8("foo"));
     assertBytes(3, 'f', 'o', 'o');
-    assertEquals("foo", new HpackDraft05.Reader(false, byteStream(3, 'f', 'o', 'o')).readString().utf8());
+    assertEquals("foo", newReader(byteStream(3, 'F', 'o', 'o')).readByteString(true).utf8());
   }
 
   @Test public void emptyHeaderName() throws IOException {
     hpackWriter.writeByteString(ByteString.encodeUtf8(""));
     assertBytes(0);
-    assertEquals("", new HpackDraft05.Reader(false, byteStream(0)).readString().utf8());
+    assertSame(ByteString.EMPTY, newReader(byteStream(0)).readByteString(true));
+    assertSame(ByteString.EMPTY, newReader(byteStream(0)).readByteString(false));
   }
 
   @Test public void headersRoundTrip() throws IOException {
-    List<ByteString> sentHeaders = byteStringList("name", "value");
+    List<Header> sentHeaders = headerEntries("name", "value");
     hpackWriter.writeHeaders(sentHeaders);
     ByteArrayInputStream bytesIn = new ByteArrayInputStream(bytesOut.toByteArray());
-    HpackDraft05.Reader reader = new HpackDraft05.Reader(false, new DataInputStream(bytesIn));
+    HpackDraft05.Reader reader = newReader(new DataInputStream(bytesIn));
     reader.readHeaders(bytesOut.size());
     reader.emitReferenceSet();
-    List<ByteString> receivedHeaders = reader.getAndReset();
+    List<Header> receivedHeaders = reader.getAndReset();
     assertEquals(sentHeaders, receivedHeaders);
   }
 
+  private HpackDraft05.Reader newReader(DataInputStream input) {
+    return new HpackDraft05.Reader(false, 4096, input);
+  }
+
   private DataInputStream byteStream(int... bytes) {
     byte[] data = intArrayToByteArray(bytes);
     return new DataInputStream(new ByteArrayInputStream(data));
   }
 
-  private ByteArrayOutputStream literalHeaders(List<ByteString> sentHeaders) throws IOException {
-    ByteArrayOutputStream headerBytes = new ByteArrayOutputStream();
-    new HpackDraft05.Writer(new DataOutputStream(headerBytes)).writeHeaders(sentHeaders);
-    return headerBytes;
-  }
-
-  private void checkEntry(HpackDraft05.HeaderEntry entry, String name, String value, int size) {
+  private void checkEntry(Header entry, String name, String value, int size) {
     assertEquals(name, entry.name.utf8());
     assertEquals(value, entry.value.utf8());
-    assertEquals(size, entry.size);
+    assertEquals(size, entry.hpackSize);
   }
 
   private void assertBytes(int... bytes) {
@@ -798,11 +810,11 @@ private void assertBytes(int... bytes) {
   }
 
   private void assertHeaderReferenced(int index) {
-    assertTrue(bitPositionSet(hpackReader.referencedHeaders, index));
+    assertTrue(hpackReader.referencedHeaders.get(index));
   }
 
   private void assertHeaderNotReferenced(int index) {
-    assertFalse(bitPositionSet(hpackReader.referencedHeaders, index));
+    assertFalse(hpackReader.referencedHeaders.get(index));
   }
 
   private int headerTableLength() {
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index 4c750712c2..3dc4c085da 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -15,7 +15,6 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.DataOutputStream;
@@ -23,7 +22,7 @@
 import java.util.List;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.Util.byteStringList;
+import static com.squareup.okhttp.internal.Util.headerEntries;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -32,7 +31,7 @@
   static final int expectedStreamId = 15;
 
   @Test public void onlyOneLiteralHeadersFrame() throws IOException {
-    final List<ByteString> sentHeaders = byteStringList("name", "value");
+    final List<Header> sentHeaders = headerEntries("name", "value");
 
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     DataOutputStream dataOut = new DataOutputStream(out);
@@ -47,14 +46,14 @@
       dataOut.write(headerBytes);
     }
 
-    FrameReader fr = new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()), false);
+    FrameReader fr = newReader(out);
 
     // Consume the headers frame.
     fr.nextFrame(new BaseTestHandler() {
 
       @Override
       public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<ByteString> nameValueBlock,
+          int associatedStreamId, int priority, List<Header> nameValueBlock,
           HeadersMode headersMode) {
         assertFalse(outFinished);
         assertTrue(inFinished);
@@ -74,7 +73,7 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
 
     // Write the first headers frame.
     {
-      byte[] headerBytes = literalHeaders(byteStringList("foo", "bar"));
+      byte[] headerBytes = literalHeaders(headerEntries("foo", "bar"));
       dataOut.writeShort(headerBytes.length);
       dataOut.write(Http20Draft09.TYPE_HEADERS);
       dataOut.write(0); // no flags
@@ -84,7 +83,7 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
 
     // Write the continuation frame, specifying no more frames are expected.
     {
-      byte[] headerBytes = literalHeaders(byteStringList("baz", "qux"));
+      byte[] headerBytes = literalHeaders(headerEntries("baz", "qux"));
       dataOut.writeShort(headerBytes.length);
       dataOut.write(Http20Draft09.TYPE_CONTINUATION);
       dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_END_STREAM);
@@ -92,21 +91,21 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
       dataOut.write(headerBytes);
     }
 
-    FrameReader fr = new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()), false);
+    FrameReader fr = newReader(out);
 
     // Reading the above frames should result in a concatenated nameValueBlock.
     fr.nextFrame(new BaseTestHandler() {
 
       @Override
       public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<ByteString> nameValueBlock,
+          int associatedStreamId, int priority, List<Header> nameValueBlock,
           HeadersMode headersMode) {
         assertFalse(outFinished);
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(-1, associatedStreamId);
         assertEquals(-1, priority);
-        assertEquals(byteStringList("foo", "bar", "baz", "qux"), nameValueBlock);
+        assertEquals(headerEntries("foo", "bar", "baz", "qux"), nameValueBlock);
         assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
       }
     });
@@ -122,7 +121,7 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
     dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
     dataOut.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
 
-    FrameReader fr = new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()), false);
+    FrameReader fr = newReader(out);
 
     // Consume the reset frame.
     fr.nextFrame(new BaseTestHandler() {
@@ -133,7 +132,36 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
     });
   }
 
-  private byte[] literalHeaders(List<ByteString> sentHeaders) throws IOException {
+  @Test public void readSettingsFrame() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final int reducedTableSizeBytes = 16;
+
+    dataOut.writeShort(8); // 1 setting = 4 bytes for the code and 4 for the value.
+    dataOut.write(Http20Draft09.TYPE_SETTINGS);
+    dataOut.write(0); // No flags
+    dataOut.writeInt(0 & 0x7fffffff); // Settings are always on the connection stream 0.
+    dataOut.writeInt(Settings.HEADER_TABLE_SIZE & 0xffffff);
+    dataOut.writeInt(reducedTableSizeBytes);
+
+    final Http20Draft09.Reader fr = newReader(out);
+
+    // Consume the settings frame.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void settings(boolean clearPrevious, Settings settings) {
+        assertFalse(clearPrevious); // No clearPrevious in http/2.
+        assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
+      }
+    });
+  }
+
+  private Http20Draft09.Reader newReader(ByteArrayOutputStream out) {
+    return new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()),
+        Variant.HTTP_20_DRAFT_09.initialPeerSettings(false).getHeaderTableSize(), false);
+  }
+
+  private byte[] literalHeaders(List<Header> sentHeaders) throws IOException {
     ByteArrayOutputStream headerBytes = new ByteArrayOutputStream();
     new HpackDraft05.Writer(new DataOutputStream(headerBytes)).writeHeaders(sentHeaders);
     return headerBytes.toByteArray();
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index c90a593f0a..fe1789f454 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -16,7 +16,6 @@
 
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
@@ -37,6 +36,7 @@
 public final class MockSpdyPeer implements Closeable {
   private int frameCount = 0;
   private final boolean client;
+  private final Variant variant;
   private final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
   private final FrameWriter frameWriter;
   private final List<OutFrame> outFrames = new ArrayList<OutFrame>();
@@ -47,9 +47,10 @@
   private ServerSocket serverSocket;
   private Socket socket;
 
-  public MockSpdyPeer(boolean client) {
+  public MockSpdyPeer(Variant variant, boolean client) {
     this.client = client;
-    this.frameWriter = Variant.SPDY3.newWriter(bytesOut, client);
+    this.variant = variant;
+    this.frameWriter = variant.newWriter(bytesOut, variant.defaultOkHttpSettings(client), client);
   }
 
   public void acceptFrame() {
@@ -109,7 +110,7 @@ private void readAndWriteFrames() throws IOException {
     socket = serverSocket.accept();
     OutputStream out = socket.getOutputStream();
     InputStream in = socket.getInputStream();
-    FrameReader reader = Variant.SPDY3.newReader(in, client);
+    FrameReader reader = variant.newReader(in, variant.initialPeerSettings(client), client);
 
     Iterator<OutFrame> outFramesIterator = outFrames.iterator();
     byte[] outBytes = bytesOut.toByteArray();
@@ -185,7 +186,7 @@ private OutFrame(int sequence, int start, int truncateToLength) {
     public int priority;
     public ErrorCode errorCode;
     public int deltaWindowSize;
-    public List<ByteString> nameValueBlock;
+    public List<Header> nameValueBlock;
     public byte[] data;
     public Settings settings;
     public HeadersMode headersMode;
@@ -203,7 +204,7 @@ public InFrame(int sequence, FrameReader reader) {
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<ByteString> nameValueBlock,
+        int associatedStreamId, int priority, List<Header> nameValueBlock,
         HeadersMode headersMode) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_HEADERS;
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
index ead73eba53..31df6d2fa5 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
@@ -38,7 +38,7 @@
 
     // WARNING: clash on flags between spdy/3 and http/2!
     assertEquals(-3, settings.getUploadBandwidth(-3));
-    assertEquals(4096, settings.getHeaderTableSize());
+    assertEquals(-1, settings.getHeaderTableSize());
     settings.set(Settings.UPLOAD_BANDWIDTH, 0, 42);
     assertEquals(42, settings.getUploadBandwidth(-3));
     settings.set(Settings.HEADER_TABLE_SIZE, 0, 8096);
@@ -46,11 +46,11 @@
 
     // WARNING: clash on flags between spdy/3 and http/2!
     assertEquals(-3, settings.getDownloadBandwidth(-3));
-    assertTrue(settings.getEnablePush());
+    assertEquals(true, settings.getEnablePush(true));
     settings.set(Settings.DOWNLOAD_BANDWIDTH, 0, 53);
     assertEquals(53, settings.getDownloadBandwidth(-3));
     settings.set(Settings.ENABLE_PUSH, 0, 0);
-    assertFalse(settings.getEnablePush());
+    assertEquals(false, settings.getEnablePush(true));
 
     assertEquals(-3, settings.getRoundTripTime(-3));
     settings.set(Settings.ROUND_TRIP_TIME, 0, 64);
@@ -68,9 +68,9 @@
     settings.set(Settings.DOWNLOAD_RETRANS_RATE, 0, 97);
     assertEquals(97, settings.getDownloadRetransRate(-3));
 
-    assertEquals(-3, settings.getInitialWindowSize(-3));
+    assertEquals(-1, settings.getInitialWindowSize());
     settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 108);
-    assertEquals(108, settings.getInitialWindowSize(-3));
+    assertEquals(108, settings.getInitialWindowSize());
 
     assertEquals(-3, settings.getClientCertificateVectorSize(-3));
     settings.set(Settings.CLIENT_CERTIFICATE_VECTOR_SIZE, 0, 117);
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index 8d263885b7..928ff23c2b 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.Base64;
 import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayOutputStream;
@@ -30,7 +31,7 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.UTF_8;
-import static com.squareup.okhttp.internal.Util.byteStringList;
+import static com.squareup.okhttp.internal.Util.headerEntries;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.CANCEL;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.FLOW_CONTROL_ERROR;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.INTERNAL_ERROR;
@@ -45,8 +46,8 @@
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_NOOP;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_PING;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_RST_STREAM;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_SETTINGS;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_WINDOW_UPDATE;
-import static com.squareup.okhttp.internal.spdy.SpdyStream.WINDOW_UPDATE_THRESHOLD;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -58,7 +59,7 @@
       throw new AssertionError();
     }
   };
-  private final MockSpdyPeer peer = new MockSpdyPeer(false);
+  private final MockSpdyPeer peer = new MockSpdyPeer(Variant.SPDY3, false);
 
   @After public void tearDown() throws Exception {
     peer.close();
@@ -68,15 +69,15 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame()
-        .synReply(false, 1, byteStringList("a", "android"));
+        .synReply(false, 1, headerEntries("a", "android"));
     peer.sendFrame().data(true, 1, "robot".getBytes("UTF-8"));
     peer.acceptFrame(); // DATA
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
-    assertEquals(byteStringList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     assertStreamData("robot", stream.getInputStream());
     writeAndClose(stream, "c3po");
     assertEquals(0, connection.openStreamCount());
@@ -89,20 +90,20 @@
     assertFalse(synStream.outFinished);
     assertEquals(1, synStream.streamId);
     assertEquals(0, synStream.associatedStreamId);
-    assertEquals(byteStringList("b", "banana"), synStream.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), synStream.nameValueBlock);
     MockSpdyPeer.InFrame requestData = peer.takeFrame();
     assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
   }
 
   @Test public void headersOnlyStreamIsClosedAfterReplyHeaders() throws Exception {
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.play();
 
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), false, false);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, false);
     assertEquals(1, connection.openStreamCount());
-    assertEquals(byteStringList("b", "banana"), stream.getResponseHeaders());
+    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
     assertEquals(0, connection.openStreamCount());
   }
 
@@ -110,13 +111,13 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(true, 1, byteStringList("a", "android"));
+    peer.sendFrame().synReply(true, 1, headerEntries("a", "android"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    connection.newStream(byteStringList("b", "banana"), false, true);
+    connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(1, connection.openStreamCount());
     connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
     assertEquals(0, connection.openStreamCount());
@@ -131,7 +132,7 @@
 
   @Test public void serverCreatesStreamAndClientReplies() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 5, 129, byteStringList("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, 5, 129, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
     peer.play();
 
@@ -140,10 +141,10 @@
     IncomingStreamHandler handler = new IncomingStreamHandler() {
       @Override public void receive(SpdyStream stream) throws IOException {
         receiveCount.incrementAndGet();
-        assertEquals(byteStringList("a", "android"), stream.getRequestHeaders());
+        assertEquals(headerEntries("a", "android"), stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
         assertEquals(5, stream.getPriority());
-        stream.reply(byteStringList("b", "banana"), true);
+        stream.reply(headerEntries("b", "banana"), true);
       }
     };
     new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
@@ -154,13 +155,13 @@
     assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
     assertFalse(reply.inFinished);
     assertEquals(2, reply.streamId);
-    assertEquals(byteStringList("b", "banana"), reply.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), reply.nameValueBlock);
     assertEquals(1, receiveCount.get());
   }
 
   @Test public void replyWithNoData() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, byteStringList("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
     peer.play();
 
@@ -168,7 +169,7 @@
     final AtomicInteger receiveCount = new AtomicInteger();
     IncomingStreamHandler handler = new IncomingStreamHandler() {
       @Override public void receive(SpdyStream stream) throws IOException {
-        stream.reply(byteStringList("b", "banana"), false);
+        stream.reply(headerEntries("b", "banana"), false);
         receiveCount.incrementAndGet();
       }
     };
@@ -179,7 +180,7 @@
     assertEquals(TYPE_HEADERS, reply.type);
     assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
     assertTrue(reply.inFinished);
-    assertEquals(byteStringList("b", "banana"), reply.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), reply.nameValueBlock);
     assertEquals(1, receiveCount.get());
   }
 
@@ -253,6 +254,37 @@
     assertEquals(4, ping4.streamId);
   }
 
+  @Test public void http2SettingsAck() throws Exception {
+    MockSpdyPeer peer = new MockSpdyPeer(Variant.HTTP_20_DRAFT_09, false);
+    // write the mocking script
+    Settings settings = new Settings();
+    settings.set(Settings.HEADER_TABLE_SIZE, PERSIST_VALUE, 1024);
+    peer.sendFrame().settings(settings);
+    peer.acceptFrame(); // ACK
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
+        .protocol(Protocol.HTTP_2)
+        .handler(REJECT_INCOMING_STREAMS)
+        .build();
+
+    // verify the peer received the ACK
+    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, pingFrame.type);
+    assertEquals(0, pingFrame.streamId);
+    // TODO: check for ACK flag.
+    assertEquals(0, pingFrame.settings.size());
+
+    // verify the peer's settings were read and applied.
+    synchronized (connection) {
+      assertEquals(1024, connection.peerSettings.getHeaderTableSize());
+      Http20Draft09.Reader frameReader = (Http20Draft09.Reader) connection.frameReader;
+      assertEquals(1024, frameReader.hpackReader.maxHeaderTableByteCount());
+    }
+    peer.close();
+  }
+
   @Test public void serverSendsSettingsToClient() throws Exception {
     // write the mocking script
     Settings settings = new Settings();
@@ -267,9 +299,9 @@
         .handler(REJECT_INCOMING_STREAMS)
         .build();
 
-    peer.takeFrame(); // Guarantees that the Settings frame has been processed.
+    peer.takeFrame(); // Guarantees that the peer Settings frame has been processed.
     synchronized (connection) {
-      assertEquals(10, connection.settings.getMaxConcurrentStreams(-1));
+      assertEquals(10, connection.peerSettings.getMaxConcurrentStreams(-1));
     }
   }
 
@@ -296,14 +328,14 @@
 
     peer.takeFrame(); // Guarantees that the Settings frame has been processed.
     synchronized (connection) {
-      assertEquals(100, connection.settings.getUploadBandwidth(-1));
-      assertEquals(PERSIST_VALUE, connection.settings.flags(Settings.UPLOAD_BANDWIDTH));
-      assertEquals(400, connection.settings.getDownloadBandwidth(-1));
-      assertEquals(0, connection.settings.flags(Settings.DOWNLOAD_BANDWIDTH));
-      assertEquals(500, connection.settings.getDownloadRetransRate(-1));
-      assertEquals(PERSIST_VALUE, connection.settings.flags(Settings.DOWNLOAD_RETRANS_RATE));
-      assertEquals(600, connection.settings.getMaxConcurrentStreams(-1));
-      assertEquals(PERSIST_VALUE, connection.settings.flags(Settings.MAX_CONCURRENT_STREAMS));
+      assertEquals(100, connection.peerSettings.getUploadBandwidth(-1));
+      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(Settings.UPLOAD_BANDWIDTH));
+      assertEquals(400, connection.peerSettings.getDownloadBandwidth(-1));
+      assertEquals(0, connection.peerSettings.flags(Settings.DOWNLOAD_BANDWIDTH));
+      assertEquals(500, connection.peerSettings.getDownloadRetransRate(-1));
+      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(Settings.DOWNLOAD_RETRANS_RATE));
+      assertEquals(600, connection.peerSettings.getMaxConcurrentStreams(-1));
+      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(Settings.MAX_CONCURRENT_STREAMS));
     }
   }
 
@@ -329,7 +361,7 @@
 
   @Test public void bogusReplyFrameDoesNotDisruptConnection() throws Exception {
     // write the mocking script
-    peer.sendFrame().synReply(false, 42, byteStringList("a", "android"));
+    peer.sendFrame().synReply(false, 42, headerEntries("a", "android"));
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
@@ -350,7 +382,7 @@
   @Test public void clientClosesClientOutputStream() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.acceptFrame(); // TYPE_DATA
     peer.acceptFrame(); // TYPE_DATA with FLAG_FIN
     peer.acceptFrame(); // PING
@@ -361,7 +393,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
         .handler(REJECT_INCOMING_STREAMS)
         .build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, false);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, false);
     OutputStream out = stream.getOutputStream();
     out.write("square".getBytes(UTF_8));
     out.flush();
@@ -407,7 +439,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
         .handler(REJECT_INCOMING_STREAMS)
         .build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     OutputStream out = stream.getOutputStream();
     connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
     try {
@@ -449,7 +481,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
         .handler(REJECT_INCOMING_STREAMS)
         .build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), false, true);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     InputStream in = stream.getInputStream();
     OutputStream out = stream.getOutputStream();
     in.close();
@@ -494,7 +526,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
         .handler(REJECT_INCOMING_STREAMS)
         .build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     InputStream in = stream.getInputStream();
     OutputStream out = stream.getOutputStream();
     in.close();
@@ -530,7 +562,7 @@
   @Test public void serverClosesClientInputStream() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.sendFrame().data(true, 1, "square".getBytes(UTF_8));
     peer.play();
 
@@ -538,7 +570,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
         .handler(REJECT_INCOMING_STREAMS)
         .build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), false, true);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     InputStream in = stream.getInputStream();
     assertStreamData("square", in);
     assertEquals(0, connection.openStreamCount());
@@ -554,17 +586,17 @@
   @Test public void remoteDoubleSynReply() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 1, byteStringList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("c", "cola"), true, true);
-    assertEquals(byteStringList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(headerEntries("c", "cola"), true, true);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
     try {
       stream.getInputStream().read();
@@ -587,9 +619,9 @@
 
   @Test public void remoteDoubleSynStream() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, byteStringList("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, byteStringList("b", "banana"));
+    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("b", "banana"));
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
@@ -598,9 +630,9 @@
     IncomingStreamHandler handler = new IncomingStreamHandler() {
       @Override public void receive(SpdyStream stream) throws IOException {
         receiveCount.incrementAndGet();
-        assertEquals(byteStringList("a", "android"), stream.getRequestHeaders());
+        assertEquals(headerEntries("a", "android"), stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
-        stream.reply(byteStringList("c", "cola"), true);
+        stream.reply(headerEntries("c", "cola"), true);
       }
     };
     new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
@@ -619,7 +651,7 @@
   @Test public void remoteSendsDataAfterInFinished() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     peer.sendFrame().data(true, 1, "robot".getBytes("UTF-8"));
     peer.sendFrame().data(true, 1, "c3po".getBytes("UTF-8")); // Ignored.
     peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
@@ -628,8 +660,8 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
-    assertEquals(byteStringList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     assertStreamData("robot", stream.getInputStream());
 
     // verify the peer received what was expected
@@ -644,7 +676,7 @@
   @Test public void remoteSendsTooMuchData() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.sendFrame().data(false, 1, new byte[64 * 1024 + 1]);
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
@@ -653,8 +685,8 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, true);
-    assertEquals(byteStringList("b", "banana"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
@@ -679,7 +711,7 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     try {
       stream.getResponseHeaders();
       fail();
@@ -709,8 +741,8 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream1 = connection.newStream(byteStringList("a", "android"), true, true);
-    SpdyStream stream2 = connection.newStream(byteStringList("b", "banana"), true, true);
+    SpdyStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
+    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the GO_AWAY has been received.
     stream1.getOutputStream().write("abc".getBytes(UTF_8));
     try {
@@ -722,7 +754,7 @@
     stream1.getOutputStream().write("def".getBytes(UTF_8));
     stream1.getOutputStream().close();
     try {
-      connection.newStream(byteStringList("c", "cola"), true, true);
+      connection.newStream(headerEntries("c", "cola"), true, true);
       fail();
     } catch (IOException expected) {
       assertEquals("shutdown", expected.getMessage());
@@ -747,13 +779,13 @@
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // GOAWAY
     peer.acceptFrame(); // PING
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, byteStringList("b", "b")); // Should be ignored!
+    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("b", "b")); // Should be ignored!
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    connection.newStream(byteStringList("a", "android"), true, true);
+    connection.newStream(headerEntries("a", "android"), true, true);
     Ping ping = connection.ping();
     connection.shutdown(PROTOCOL_ERROR);
     assertEquals(1, connection.openStreamCount());
@@ -800,12 +832,12 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     assertEquals(1, connection.openStreamCount());
     connection.close();
     assertEquals(0, connection.openStreamCount());
     try {
-      connection.newStream(byteStringList("b", "banana"), true, true);
+      connection.newStream(headerEntries("b", "banana"), true, true);
       fail();
     } catch (IOException expected) {
       assertEquals("shutdown", expected.getMessage());
@@ -850,14 +882,14 @@
   @Test public void readTimeoutExpires() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     stream.setReadTimeout(1000);
     InputStream in = stream.getInputStream();
     long startNanos = System.nanoTime();
@@ -880,16 +912,16 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
-    peer.sendFrame().headers(1, byteStringList("c", "c3po"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().headers(1, headerEntries("c", "c3po"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
-    assertEquals(byteStringList("a", "android", "c", "c3po"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android", "c", "c3po"), stream.getResponseHeaders());
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
@@ -903,14 +935,14 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().headers(1, byteStringList("c", "c3po"));
+    peer.sendFrame().headers(1, headerEntries("c", "c3po"));
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
     try {
       stream.getResponseHeaders();
@@ -931,11 +963,12 @@
   }
 
   @Test public void readSendsWindowUpdate() throws Exception {
+    int windowUpdateThreshold = Variant.SPDY3.initialPeerSettings(true).getInitialWindowSize() / 2;
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     for (int i = 0; i < 3; i++) {
-      peer.sendFrame().data(false, 1, new byte[WINDOW_UPDATE_THRESHOLD]);
+      peer.sendFrame().data(false, 1, new byte[windowUpdateThreshold]);
       peer.acceptFrame(); // WINDOW UPDATE
     }
     peer.sendFrame().data(true, 1, new byte[0]);
@@ -943,15 +976,16 @@
 
     // Play it back.
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
-    assertEquals(byteStringList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals(windowUpdateThreshold, stream.windowUpdateThreshold);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     InputStream in = stream.getInputStream();
     int total = 0;
     byte[] buffer = new byte[1024];
     int count;
     while ((count = in.read(buffer)) != -1) {
       total += count;
-      if (total == 3 * WINDOW_UPDATE_THRESHOLD) break;
+      if (total == 3 * windowUpdateThreshold) break;
     }
     assertEquals(-1, in.read());
 
@@ -962,23 +996,25 @@
       MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
       assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
       assertEquals(1, windowUpdate.streamId);
-      assertEquals(WINDOW_UPDATE_THRESHOLD, windowUpdate.deltaWindowSize);
+      assertEquals(windowUpdateThreshold, windowUpdate.deltaWindowSize);
     }
   }
 
   @Test public void writeAwaitsWindowUpdate() throws Exception {
+    int windowSize = Variant.SPDY3.initialPeerSettings(true).getInitialWindowSize();
+
     // Write the mocking script. This accepts more data frames than necessary!
     peer.acceptFrame(); // SYN_STREAM
-    for (int i = 0; i < Settings.DEFAULT_INITIAL_WINDOW_SIZE / 1024; i++) {
+    for (int i = 0; i < windowSize / 1024; i++) {
       peer.acceptFrame(); // DATA
     }
     peer.play();
 
     // Play it back.
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     OutputStream out = stream.getOutputStream();
-    out.write(new byte[Settings.DEFAULT_INITIAL_WINDOW_SIZE]);
+    out.write(new byte[windowSize]);
     interruptAfterDelay(500);
     try {
       out.write('a');
@@ -997,14 +1033,14 @@
   @Test public void testTruncatedDataFrame() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     peer.sendTruncatedFrame(8 + 100).data(false, 1, new byte[1024]);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
-    assertEquals(byteStringList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     InputStream in = stream.getInputStream();
     try {
       Util.readFully(in, new byte[101]);
@@ -1035,9 +1071,9 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
-    assertEquals("a", stream.getResponseHeaders().get(0).utf8());
-    assertEquals(60, stream.getResponseHeaders().get(1).size());
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals("a", stream.getResponseHeaders().get(0).name.utf8());
+    assertEquals(60, stream.getResponseHeaders().get(0).value.size());
     assertStreamData("robot", stream.getInputStream());
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Address.java b/okhttp/src/main/java/com/squareup/okhttp/Address.java
index b34bd9128c..ebda2a64a5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Address.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Address.java
@@ -41,22 +41,22 @@
   final SSLSocketFactory sslSocketFactory;
   final HostnameVerifier hostnameVerifier;
   final OkAuthenticator authenticator;
-  final List<String> transports;
+  final List<Protocol> protocols;
 
   public Address(String uriHost, int uriPort, SSLSocketFactory sslSocketFactory,
       HostnameVerifier hostnameVerifier, OkAuthenticator authenticator, Proxy proxy,
-      List<String> transports) throws UnknownHostException {
+      List<Protocol> protocols) throws UnknownHostException {
     if (uriHost == null) throw new NullPointerException("uriHost == null");
     if (uriPort <= 0) throw new IllegalArgumentException("uriPort <= 0: " + uriPort);
     if (authenticator == null) throw new IllegalArgumentException("authenticator == null");
-    if (transports == null) throw new IllegalArgumentException("transports == null");
+    if (protocols == null) throw new IllegalArgumentException("protocols == null");
     this.proxy = proxy;
     this.uriHost = uriHost;
     this.uriPort = uriPort;
     this.sslSocketFactory = sslSocketFactory;
     this.hostnameVerifier = hostnameVerifier;
     this.authenticator = authenticator;
-    this.transports = Util.immutableList(transports);
+    this.protocols = Util.immutableList(protocols);
   }
 
   /** Returns the hostname of the origin server. */
@@ -97,11 +97,12 @@ public OkAuthenticator getAuthenticator() {
   }
 
   /**
-   * Returns the client's transports. This method always returns a non-null list
-   * that contains "http/1.1", possibly among other transports.
+   * Returns the protocols the client supports. This method always returns a
+   * non-null list that contains minimally
+   * {@link Protocol#HTTP_11}.
    */
-  public List<String> getTransports() {
-    return transports;
+  public List<Protocol> getProtocols() {
+    return protocols;
   }
 
   /**
@@ -121,7 +122,7 @@ public Proxy getProxy() {
           && equal(this.sslSocketFactory, that.sslSocketFactory)
           && equal(this.hostnameVerifier, that.hostnameVerifier)
           && equal(this.authenticator, that.authenticator)
-          && equal(this.transports, that.transports);
+          && equal(this.protocols, that.protocols);
     }
     return false;
   }
@@ -134,7 +135,7 @@ public Proxy getProxy() {
     result = 31 * result + (hostnameVerifier != null ? hostnameVerifier.hashCode() : 0);
     result = 31 * result + (authenticator != null ? authenticator.hashCode() : 0);
     result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
-    result = 31 * result + transports.hashCode();
+    result = 31 * result + protocols.hashCode();
     return result;
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index 9a7f1b0f99..9ff7b7069c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -16,6 +16,7 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpEngine;
@@ -31,7 +32,6 @@
 import java.net.Proxy;
 import java.net.Socket;
 import java.net.SocketTimeoutException;
-import java.util.Arrays;
 import javax.net.ssl.SSLSocket;
 
 import static java.net.HttpURLConnection.HTTP_OK;
@@ -56,7 +56,7 @@
  *   <li>Server Name Indication (SNI) enables one IP address to negotiate secure
  *       connections for multiple domain names.
  *   <li>Next Protocol Negotiation (NPN) enables the HTTPS port (443) to be used
- *       for both HTTP and SPDY transports.
+ *       for both HTTP and SPDY protocols.
  * </ul>
  * Unfortunately, older HTTPS servers refuse to connect when such options are
  * presented. Rather than avoiding these options entirely, this class allows a
@@ -64,31 +64,6 @@
  * should the attempt fail.
  */
 public final class Connection implements Closeable {
-  private static final byte[] ALL_PROTOCOLS = new byte[] {
-      17, 'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '9', '/', '2', '.', '0',
-      6, 's', 'p', 'd', 'y', '/', '3',
-      8, 'h', 't', 't', 'p', '/', '1', '.', '1'
-  };
-
-  private static final byte[] SPDY3_AND_HTTP11 = new byte[] {
-      6, 's', 'p', 'd', 'y', '/', '3',
-      8, 'h', 't', 't', 'p', '/', '1', '.', '1'
-  };
-
-  private static final byte[] HTTP2_AND_HTTP = new byte[] {
-      17, 'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '9', '/', '2', '.', '0',
-      8, 'h', 't', 't', 'p', '/', '1', '.', '1'
-  };
-
-  private static final byte[] HTTP_20_DRAFT_09 = new byte[] {
-      'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '9', '/', '2', '.', '0'
-  };
-  private static final byte[] SPDY3 = new byte[] {
-      's', 'p', 'd', 'y', '/', '3'
-  };
-  private static final byte[] HTTP_11 = new byte[] {
-      'h', 't', 't', 'p', '/', '1', '.', '1'
-  };
 
   private final Route route;
 
@@ -145,19 +120,19 @@ private void upgradeToTls(TunnelRequest tunnelRequest) throws IOException {
       platform.supportTlsIntolerantServer(sslSocket);
     }
 
-    boolean useNpn = route.modernTls && (
-        route.address.transports.contains("HTTP-draft-09/2.0")
-     || route.address.transports.contains("spdy/3")
+    boolean useNpn = route.modernTls && (// Contains a spdy variant.
+        route.address.protocols.contains(Protocol.HTTP_2)
+     || route.address.protocols.contains(Protocol.SPDY_3)
     );
 
     if (useNpn) {
-      if (route.address.transports.contains("HTTP-draft-09/2.0")
-       && route.address.transports.contains("spdy/3")) {
-        platform.setNpnProtocols(sslSocket, ALL_PROTOCOLS);
-      } else if (route.address.transports.contains("HTTP-draft-09/2.0")) {
-        platform.setNpnProtocols(sslSocket, HTTP2_AND_HTTP);
+      if (route.address.protocols.contains(Protocol.HTTP_2) // Contains both spdy variants.
+          && route.address.protocols.contains(Protocol.SPDY_3)) {
+        platform.setNpnProtocols(sslSocket, Protocol.HTTP2_SPDY3_AND_HTTP);
+      } else if (route.address.protocols.contains(Protocol.HTTP_2)) {
+        platform.setNpnProtocols(sslSocket, Protocol.HTTP2_AND_HTTP_11);
       } else {
-        platform.setNpnProtocols(sslSocket, SPDY3_AND_HTTP11);
+        platform.setNpnProtocols(sslSocket, Protocol.SPDY3_AND_HTTP11);
       }
     }
 
@@ -174,19 +149,14 @@ private void upgradeToTls(TunnelRequest tunnelRequest) throws IOException {
     handshake = Handshake.get(sslSocket.getSession());
     streamWrapper();
 
-    byte[] selectedProtocol;
-    if (useNpn && (selectedProtocol = platform.getNpnSelectedProtocol(sslSocket)) != null) {
-      if (Arrays.equals(selectedProtocol, HTTP_20_DRAFT_09)
-       || Arrays.equals(selectedProtocol, SPDY3)) {
-        SpdyConnection.Builder builder =
-            new SpdyConnection.Builder(route.address.getUriHost(), true, in, out);
-        if (Arrays.equals(selectedProtocol, HTTP_20_DRAFT_09)) builder.http20Draft09();
+    ByteString maybeProtocol;
+    if (useNpn && (maybeProtocol = platform.getNpnSelectedProtocol(sslSocket)) != null) {
+      Protocol selectedProtocol = Protocol.find(maybeProtocol); // Throws IOE on unknown.
+      if (selectedProtocol.spdyVariant) {
         sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
-        spdyConnection = builder.build();
+        spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, in, out)
+            .protocol(selectedProtocol).build();
         spdyConnection.sendConnectionHeader();
-      } else if (!Arrays.equals(selectedProtocol, HTTP_11)) {
-        throw new IOException(
-            "Unexpected NPN transport " + new String(selectedProtocol, "ISO-8859-1"));
       }
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Headers.java b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
index 7753d9f1f6..1221aa4e09 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Headers.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
@@ -119,6 +119,14 @@ public Builder newBuilder() {
     return result;
   }
 
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder();
+    for (int i = 0; i < size(); i++) {
+      result.append(name(i)).append(": ").append(value(i)).append("\n");
+    }
+    return result.toString();
+  }
+
   private static String get(String[] namesAndValues, String fieldName) {
     for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
       if (fieldName.equalsIgnoreCase(namesAndValues[i])) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index ef934328d3..5765997626 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -15,11 +15,13 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
 import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
+import java.io.IOException;
 import java.net.CookieHandler;
 import java.net.HttpURLConnection;
 import java.net.Proxy;
@@ -29,7 +31,7 @@
 import java.net.URLConnection;
 import java.net.URLStreamHandler;
 import java.net.URLStreamHandlerFactory;
-import java.util.Arrays;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HostnameVerifier;
@@ -38,13 +40,11 @@
 
 /** Configures and creates HTTP connections. */
 public final class OkHttpClient implements URLStreamHandlerFactory, Cloneable {
-  private static final List<String> DEFAULT_TRANSPORTS
-      = Util.immutableList(Arrays.asList("HTTP-draft-09/2.0", "spdy/3", "http/1.1"));
 
   private final RouteDatabase routeDatabase;
   private Dispatcher dispatcher;
   private Proxy proxy;
-  private List<String> transports;
+  private List<Protocol> protocols;
   private ProxySelector proxySelector;
   private CookieHandler cookieHandler;
   private OkResponseCache responseCache;
@@ -296,20 +296,39 @@ public Dispatcher getDispatcher() {
   }
 
   /**
-   * Configure the transports used by this client to communicate with remote
+   * @deprecated OkHttp 2 enforces an enumeration of {@link Protocol protocols}
+   * that can be selected. Please switch to {@link #setProtocols(java.util.List)}.
+   */
+  @Deprecated
+  public OkHttpClient setTransports(List<String> transports) {
+    List<Protocol> protocols = new ArrayList<Protocol>(transports.size());
+    for (int i = 0, size = transports.size(); i < size; i++) {
+      try {
+        Protocol protocol = Protocol.find(ByteString.encodeUtf8(transports.get(i)));
+        protocols.add(protocol);
+      } catch (IOException e) {
+        throw new IllegalArgumentException(e);
+      }
+    }
+    return setProtocols(protocols);
+  }
+
+  /**
+   * Configure the protocols used by this client to communicate with remote
    * servers. By default this client will prefer the most efficient transport
-   * available, falling back to more ubiquitous transports. Applications should
+   * available, falling back to more ubiquitous protocols. Applications should
    * only call this method to avoid specific compatibility problems, such as web
    * servers that behave incorrectly when SPDY is enabled.
    *
-   * <p>The following transports are currently supported:
+   * <p>The following protocols are currently supported:
    * <ul>
    *   <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
    *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3">spdy/3</a>
+   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-09">HTTP-draft-09/2.0</a>
    * </ul>
    *
    * <p><strong>This is an evolving set.</strong> Future releases may drop
-   * support for transitional transports (like spdy/3), in favor of their
+   * support for transitional protocols (like spdy/3), in favor of their
    * successors (spdy/4 or http/2.0). The http/1.1 transport will never be
    * dropped.
    *
@@ -319,28 +338,41 @@ public Dispatcher getDispatcher() {
    * (such as <a href="http://tools.ietf.org/html/draft-friedl-tls-applayerprotoneg-02">ALPN</a>)
    * to negotiate a transport.
    *
-   * @param transports the transports to use, in order of preference. The list
+   * @param protocols the protocols to use, in order of preference. The list
    *     must contain "http/1.1". It must not contain null.
    */
-  public OkHttpClient setTransports(List<String> transports) {
-    transports = Util.immutableList(transports);
-    if (!transports.contains("http/1.1")) {
-      throw new IllegalArgumentException("transports doesn't contain http/1.1: " + transports);
+  public OkHttpClient setProtocols(List<Protocol> protocols) {
+    protocols = Util.immutableList(protocols);
+    if (!protocols.contains(Protocol.HTTP_11)) {
+      throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
     }
-    if (transports.contains(null)) {
-      throw new IllegalArgumentException("transports must not contain null");
+    if (protocols.contains(null)) {
+      throw new IllegalArgumentException("protocols must not contain null");
     }
-    if (transports.contains("")) {
-      throw new IllegalArgumentException("transports contains an empty string");
+    if (protocols.contains(ByteString.EMPTY)) {
+      throw new IllegalArgumentException("protocols contains an empty string");
     }
-    this.transports = transports;
+    this.protocols = Util.immutableList(protocols);
     return this;
   }
 
+  /**
+   * @deprecated OkHttp 2 enforces an enumeration of {@link Protocol protocols}
+   * that can be selected. Please switch to {@link #getProtocols()}.
+   */
+  @Deprecated
   public List<String> getTransports() {
+    List<String> transports = new ArrayList<String>(protocols.size());
+    for (int i = 0, size = protocols.size(); i < size; i++) {
+      transports.add(protocols.get(i).name.utf8());
+    }
     return transports;
   }
 
+  public List<Protocol> getProtocols() {
+    return protocols;
+  }
+
   /**
    * Schedules {@code request} to be executed at some point in the future. The
    * {@link #getDispatcher dispatcher} defines when the request will run:
@@ -404,8 +436,8 @@ OkHttpClient copyWithDefaults() {
     if (result.connectionPool == null) {
       result.connectionPool = ConnectionPool.getDefault();
     }
-    if (result.transports == null) {
-      result.transports = DEFAULT_TRANSPORTS;
+    if (result.protocols == null) {
+      result.protocols = Protocol.HTTP2_SPDY3_AND_HTTP;
     }
     return result;
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index af90db1527..317e0b4c86 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -17,7 +17,6 @@
 
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HttpDate;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -28,7 +27,6 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
-import java.util.Date;
 import java.util.List;
 
 /**
@@ -298,14 +296,6 @@ public Builder setUserAgent(String userAgent) {
       return header("User-Agent", userAgent);
     }
 
-    public Builder setIfModifiedSince(Date date) {
-      return header("If-Modified-Since", HttpDate.format(date));
-    }
-
-    public Builder setIfNoneMatch(String ifNoneMatch) {
-      return header("If-None-Match", ifNoneMatch);
-    }
-
     public Builder get() {
       return method("GET", null);
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index 0110f3e19c..0a95a0de77 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -16,7 +16,6 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HeaderParser;
 import com.squareup.okhttp.internal.http.HttpDate;
 import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.StatusLine;
@@ -137,22 +136,7 @@ public Response redirectedBy() {
     return redirectedBy;
   }
 
-  public Date getServedDate() {
-    return parsedHeaders().servedDate;
-  }
-
-  public Date getLastModified() {
-    return parsedHeaders().lastModified;
-  }
-
-  public Date getExpires() {
-    return parsedHeaders().expires;
-  }
-
-  public String getEtag() {
-    return parsedHeaders().etag;
-  }
-
+  // TODO: move out of public API
   public Set<String> getVaryFields() {
     return parsedHeaders().varyFields;
   }
@@ -161,6 +145,7 @@ public String getEtag() {
    * Returns true if a Vary header contains an asterisk. Such responses cannot
    * be cached.
    */
+  // TODO: move out of public API
   public boolean hasVaryAll() {
     return parsedHeaders().varyFields.contains("*");
   }
@@ -169,6 +154,7 @@ public boolean hasVaryAll() {
    * Returns true if none of the Vary headers on this response have changed
    * between {@code cachedRequest} and {@code newRequest}.
    */
+  // TODO: move out of public API
   public boolean varyMatches(Headers varyHeaders, Request newRequest) {
     for (String field : parsedHeaders().varyFields) {
       if (!equal(varyHeaders.values(field), newRequest.headers(field))) return false;
@@ -180,6 +166,7 @@ public boolean varyMatches(Headers varyHeaders, Request newRequest) {
    * Returns true if this cached response should be used; false if the
    * network response should be used.
    */
+  // TODO: move out of public API
   public boolean validate(Response network) {
     if (network.code() == HttpURLConnection.HTTP_NOT_MODIFIED) {
       return true;
@@ -198,27 +185,13 @@ public boolean validate(Response network) {
     return false;
   }
 
-  // TODO: should not be public?
-  public long getReceivedResponseMillis() {
-    return parsedHeaders().receivedResponseMillis;
-  }
-
-  // TODO: should not be public?
-  public long getSentRequestMillis() {
-    return parsedHeaders.sentRequestMillis;
-  }
-
-  public long getAgeSeconds() {
-    return parsedHeaders().ageSeconds;
-  }
-
   public abstract static class Body implements Closeable {
     /** Multiple calls to {@link #charStream()} must return the same instance. */
     private Reader reader;
 
     /**
      * Returns true if further data from this response body should be read at
-     * this time. For asynchronous transports like SPDY and HTTP/2.0, this will
+     * this time. For asynchronous protocols like SPDY and HTTP/2.0, this will
      * return false once all locally-available body bytes have been read.
      *
      * <p>Clients with many concurrent downloads can use this method to reduce
@@ -307,33 +280,9 @@ public CacheControl cacheControl() {
 
   /** Parsed response headers, computed on-demand and cached. */
   private static class ParsedHeaders {
-    /** The server's time when this response was served, if known. */
-    Date servedDate;
-
     /** The last modified date of the response, if known. */
     Date lastModified;
 
-    /**
-     * The expiration date of the response, if known. If both this field and the
-     * max age are set, the max age is preferred.
-     */
-    Date expires;
-
-    /**
-     * Extension header set by HttpURLConnectionImpl specifying the timestamp
-     * when the HTTP request was first initiated.
-     */
-    long sentRequestMillis;
-
-    /**
-     * Extension header set by HttpURLConnectionImpl specifying the timestamp
-     * when the HTTP response was first received.
-     */
-    long receivedResponseMillis;
-
-    String etag;
-    int ageSeconds = -1;
-
     /** Case-insensitive set of field names. */
     private Set<String> varyFields = Collections.emptySet();
 
@@ -341,16 +290,8 @@ private ParsedHeaders(Headers headers) {
       for (int i = 0; i < headers.size(); i++) {
         String fieldName = headers.name(i);
         String value = headers.value(i);
-        if ("Date".equalsIgnoreCase(fieldName)) {
-          servedDate = HttpDate.parse(value);
-        } else if ("Expires".equalsIgnoreCase(fieldName)) {
-          expires = HttpDate.parse(value);
-        } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
+        if ("Last-Modified".equalsIgnoreCase(fieldName)) {
           lastModified = HttpDate.parse(value);
-        } else if ("ETag".equalsIgnoreCase(fieldName)) {
-          etag = value;
-        } else if ("Age".equalsIgnoreCase(fieldName)) {
-          ageSeconds = HeaderParser.parseSeconds(value);
         } else if ("Vary".equalsIgnoreCase(fieldName)) {
           // Replace the immutable empty set with something we can mutate.
           if (varyFields.isEmpty()) {
@@ -359,10 +300,6 @@ private ParsedHeaders(Headers headers) {
           for (String varyField : value.split(",")) {
             varyFields.add(varyField.trim());
           }
-        } else if (OkHeaders.SENT_MILLIS.equalsIgnoreCase(fieldName)) {
-          sentRequestMillis = Long.parseLong(value);
-        } else if (OkHeaders.RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
-          receivedResponseMillis = Long.parseLong(value);
         }
       }
     }
@@ -488,7 +425,7 @@ public Builder body(Body body) {
       return this;
     }
 
-    // TODO: this shouldn't be public.
+    // TODO: move out of public API
     public Builder setResponseSource(ResponseSource responseSource) {
       return header(OkHeaders.RESPONSE_SOURCE, responseSource + " " + statusLine.code());
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java
index 612693644a..a7a818e2e6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java
@@ -36,7 +36,7 @@
   protected final InputStream in;
   protected final HttpEngine httpEngine;
   private final CacheRequest cacheRequest;
-  private final OutputStream cacheBody;
+  protected final OutputStream cacheBody;
   protected boolean closed;
 
   AbstractHttpInputStream(InputStream in, HttpEngine httpEngine, CacheRequest cacheRequest)
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
index b8c1d5155b..ae0acdfb7e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
@@ -8,6 +8,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.HttpURLConnection;
+import java.util.Date;
 
 import static com.squareup.okhttp.internal.Util.EMPTY_INPUT_STREAM;
 import static java.util.concurrent.TimeUnit.SECONDS;
@@ -16,9 +17,9 @@
  * Given a request and cached response, this figures out whether to use the
  * network, the cache, or both.
  *
- * <p>Selecting the next action may have side effects. The request may gain
- * conditions such as an "If-None-Match" or "If-Modified-Since" header. The
- * response may gain a warning if it is potentially stale.
+ * <p>Selecting a cache strategy may add conditions to the request (like the
+ * "If-Modified-Since" header for conditional GETs) or warnings to the cached
+ * response (if the cached data is potentially stale).
  */
 public final class CacheStrategy {
   private static final Response.Body EMPTY_BODY = new Response.Body() {
@@ -56,60 +57,6 @@ private CacheStrategy(
     this.source = source;
   }
 
-  /**
-   * Returns the current age of the response, in milliseconds. The calculation
-   * is specified by RFC 2616, 13.2.3 Age Calculations.
-   */
-  private static long computeAge(Response response, long nowMillis) {
-    long apparentReceivedAge = response.getServedDate() != null
-        ? Math.max(0, response.getReceivedResponseMillis() - response.getServedDate().getTime())
-        : 0;
-    long receivedAge = response.getAgeSeconds() != -1
-        ? Math.max(apparentReceivedAge, SECONDS.toMillis(response.getAgeSeconds()))
-        : apparentReceivedAge;
-    long responseDuration = response.getReceivedResponseMillis() - response.getSentRequestMillis();
-    long residentDuration = nowMillis - response.getReceivedResponseMillis();
-    return receivedAge + responseDuration + residentDuration;
-  }
-
-  /**
-   * Returns the number of milliseconds that the response was fresh for,
-   * starting from the served date.
-   */
-  private static long computeFreshnessLifetime(Response response) {
-    CacheControl responseCaching = response.cacheControl();
-    if (responseCaching.maxAgeSeconds() != -1) {
-      return SECONDS.toMillis(responseCaching.maxAgeSeconds());
-    } else if (response.getExpires() != null) {
-      long servedMillis = response.getServedDate() != null
-          ? response.getServedDate().getTime()
-          : response.getReceivedResponseMillis();
-      long delta = response.getExpires().getTime() - servedMillis;
-      return delta > 0 ? delta : 0;
-    } else if (response.getLastModified() != null && response.request().url().getQuery() == null) {
-      // As recommended by the HTTP RFC and implemented in Firefox, the
-      // max age of a document should be defaulted to 10% of the
-      // document's age at the time it was served. Default expiration
-      // dates aren't used for URIs containing a query.
-      long servedMillis = response.getServedDate() != null
-          ? response.getServedDate().getTime()
-          : response.getSentRequestMillis();
-      long delta = servedMillis - response.getLastModified().getTime();
-      return delta > 0 ? (delta / 10) : 0;
-    }
-    return 0;
-  }
-
-  /**
-   * Returns true if computeFreshnessLifetime used a heuristic. If we used a
-   * heuristic to serve a cached response older than 24 hours, we are required
-   * to attach a warning.
-   */
-  private static boolean isFreshnessLifetimeHeuristic(Response response) {
-    return response.cacheControl().maxAgeSeconds() == -1
-        && response.getExpires() == null;
-  }
-
   /**
    * Returns true if this response can be stored to later serve another
    * request.
@@ -143,107 +90,225 @@ public static boolean isCacheable(Response response, Request request) {
     return true;
   }
 
-  /**
-   * Returns a strategy to satisfy {@code request} using the a cached response
-   * {@code response}.
-   */
-  public static CacheStrategy get(long nowMillis, Response response, Request request) {
-    CacheStrategy candidate = getCandidate(nowMillis, response, request);
-
-    if (candidate.source != ResponseSource.CACHE && request.cacheControl().onlyIfCached()) {
-      // We're forbidden from using the network, but the cache is insufficient.
-      Response noneResponse = new Response.Builder()
-          .request(candidate.request)
-          .statusLine(GATEWAY_TIMEOUT_STATUS_LINE)
-          .setResponseSource(ResponseSource.NONE)
-          .body(EMPTY_BODY)
-          .build();
-      return new CacheStrategy(candidate.request, noneResponse, ResponseSource.NONE);
-    }
+  public static class Factory {
+    final long nowMillis;
+    final Request request;
+    final Response cacheResponse;
 
-    return candidate;
-  }
+    /** The server's time when the cached response was served, if known. */
+    private Date servedDate;
 
-  /** Returns a strategy to use assuming the request can use the network. */
-  private static CacheStrategy getCandidate(long nowMillis, Response response, Request request) {
-    // No cached response.
-    if (response == null) {
-      return new CacheStrategy(request, response, ResponseSource.NETWORK);
-    }
+    /** The last modified date of the cached response, if known. */
+    private Date lastModified;
 
-    // Drop the cached response if it's missing a required handshake.
-    if (request.isHttps() && response.handshake() == null) {
-      return new CacheStrategy(request, response, ResponseSource.NETWORK);
-    }
+    /**
+     * The expiration date of the cached response, if known. If both this field
+     * and the max age are set, the max age is preferred.
+     */
+    private Date expires;
 
-    // If this response shouldn't have been stored, it should never be used
-    // as a response source. This check should be redundant as long as the
-    // persistence store is well-behaved and the rules are constant.
-    if (!isCacheable(response, request)) {
-      return new CacheStrategy(request, response, ResponseSource.NETWORK);
-    }
+    /**
+     * Extension header set by OkHttp specifying the timestamp when the cached
+     * HTTP request was first initiated.
+     */
+    private long sentRequestMillis;
 
-    CacheControl requestCaching = request.cacheControl();
-    if (requestCaching.noCache() || hasConditions(request)) {
-      return new CacheStrategy(request, response, ResponseSource.NETWORK);
-    }
+    /**
+     * Extension header set by OkHttp specifying the timestamp when the cached
+     * HTTP response was first received.
+     */
+    private long receivedResponseMillis;
 
-    long ageMillis = computeAge(response, nowMillis);
-    long freshMillis = computeFreshnessLifetime(response);
+    /** Etag of the cached response. */
+    private String etag;
 
-    if (requestCaching.maxAgeSeconds() != -1) {
-      freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
-    }
+    /** Age of the cached response. */
+    private int ageSeconds = -1;
+
+    public Factory(long nowMillis, Request request, Response cacheResponse) {
+      this.nowMillis = nowMillis;
+      this.request = request;
+      this.cacheResponse = cacheResponse;
 
-    long minFreshMillis = 0;
-    if (requestCaching.minFreshSeconds() != -1) {
-      minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
+      if (cacheResponse != null) {
+        for (int i = 0; i < cacheResponse.headers().size(); i++) {
+          String fieldName = cacheResponse.headers().name(i);
+          String value = cacheResponse.headers().value(i);
+          if ("Date".equalsIgnoreCase(fieldName)) {
+            servedDate = HttpDate.parse(value);
+          } else if ("Expires".equalsIgnoreCase(fieldName)) {
+            expires = HttpDate.parse(value);
+          } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
+            lastModified = HttpDate.parse(value);
+          } else if ("ETag".equalsIgnoreCase(fieldName)) {
+            etag = value;
+          } else if ("Age".equalsIgnoreCase(fieldName)) {
+            ageSeconds = HeaderParser.parseSeconds(value);
+          } else if (OkHeaders.SENT_MILLIS.equalsIgnoreCase(fieldName)) {
+            sentRequestMillis = Long.parseLong(value);
+          } else if (OkHeaders.RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
+            receivedResponseMillis = Long.parseLong(value);
+          }
+        }
+      }
     }
 
-    long maxStaleMillis = 0;
-    CacheControl responseCaching = response.cacheControl();
-    if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
-      maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
+    /**
+     * Returns a strategy to satisfy {@code request} using the a cached response
+     * {@code response}.
+     */
+    public CacheStrategy get() {
+      CacheStrategy candidate = getCandidate();
+
+      if (candidate.source != ResponseSource.CACHE && request.cacheControl().onlyIfCached()) {
+        // We're forbidden from using the network, but the cache is insufficient.
+        Response noneResponse = new Response.Builder()
+            .request(candidate.request)
+            .statusLine(GATEWAY_TIMEOUT_STATUS_LINE)
+            .setResponseSource(ResponseSource.NONE)
+            .body(EMPTY_BODY)
+            .build();
+        return new CacheStrategy(candidate.request, noneResponse, ResponseSource.NONE);
+      }
+
+      return candidate;
     }
 
-    if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
-      Response.Builder builder = response.newBuilder()
-          .setResponseSource(ResponseSource.CACHE); // Overwrite any stored response source.
-      if (ageMillis + minFreshMillis >= freshMillis) {
-        builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
+    /** Returns a strategy to use assuming the request can use the network. */
+    private CacheStrategy getCandidate() {
+      // No cached response.
+      if (cacheResponse == null) {
+        return new CacheStrategy(request, cacheResponse, ResponseSource.NETWORK);
       }
-      long oneDayMillis = 24 * 60 * 60 * 1000L;
-      if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic(response)) {
-        builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
+
+      // Drop the cached response if it's missing a required handshake.
+      if (request.isHttps() && cacheResponse.handshake() == null) {
+        return new CacheStrategy(request, cacheResponse, ResponseSource.NETWORK);
+      }
+
+      // If this response shouldn't have been stored, it should never be used
+      // as a response source. This check should be redundant as long as the
+      // persistence store is well-behaved and the rules are constant.
+      if (!isCacheable(cacheResponse, request)) {
+        return new CacheStrategy(request, cacheResponse, ResponseSource.NETWORK);
+      }
+
+      CacheControl requestCaching = request.cacheControl();
+      if (requestCaching.noCache() || hasConditions(request)) {
+        return new CacheStrategy(request, cacheResponse, ResponseSource.NETWORK);
+      }
+
+      long ageMillis = cacheResponseAge();
+      long freshMillis = computeFreshnessLifetime();
+
+      if (requestCaching.maxAgeSeconds() != -1) {
+        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
+      }
+
+      long minFreshMillis = 0;
+      if (requestCaching.minFreshSeconds() != -1) {
+        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
+      }
+
+      long maxStaleMillis = 0;
+      CacheControl responseCaching = cacheResponse.cacheControl();
+      if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
+        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
+      }
+
+      if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
+        Response.Builder builder = cacheResponse.newBuilder()
+            .setResponseSource(ResponseSource.CACHE); // Overwrite any stored response source.
+        if (ageMillis + minFreshMillis >= freshMillis) {
+          builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
+        }
+        long oneDayMillis = 24 * 60 * 60 * 1000L;
+        if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
+          builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
+        }
+        return new CacheStrategy(request, builder.build(), ResponseSource.CACHE);
+      }
+
+      Request.Builder conditionalRequestBuilder = request.newBuilder();
+
+      if (lastModified != null) {
+        conditionalRequestBuilder.header("If-Modified-Since", HttpDate.format(lastModified));
+      } else if (servedDate != null) {
+        conditionalRequestBuilder.header("If-Modified-Since", HttpDate.format(servedDate));
       }
-      return new CacheStrategy(request, builder.build(), ResponseSource.CACHE);
-    }
 
-    Request.Builder conditionalRequestBuilder = request.newBuilder();
+      if (etag != null) {
+        conditionalRequestBuilder.header("If-None-Match", etag);
+      }
+
+      Request conditionalRequest = conditionalRequestBuilder.build();
+      ResponseSource responseSource = hasConditions(conditionalRequest)
+          ? ResponseSource.CONDITIONAL_CACHE
+          : ResponseSource.NETWORK;
+      return new CacheStrategy(conditionalRequest, cacheResponse, responseSource);
+    }
 
-    if (response.getLastModified() != null) {
-      conditionalRequestBuilder.setIfModifiedSince(response.getLastModified());
-    } else if (response.getServedDate() != null) {
-      conditionalRequestBuilder.setIfModifiedSince(response.getServedDate());
+    /**
+     * Returns the number of milliseconds that the response was fresh for,
+     * starting from the served date.
+     */
+    private long computeFreshnessLifetime() {
+      CacheControl responseCaching = cacheResponse.cacheControl();
+      if (responseCaching.maxAgeSeconds() != -1) {
+        return SECONDS.toMillis(responseCaching.maxAgeSeconds());
+      } else if (expires != null) {
+        long servedMillis = servedDate != null
+            ? servedDate.getTime()
+            : receivedResponseMillis;
+        long delta = expires.getTime() - servedMillis;
+        return delta > 0 ? delta : 0;
+      } else if (lastModified != null
+          && cacheResponse.request().url().getQuery() == null) {
+        // As recommended by the HTTP RFC and implemented in Firefox, the
+        // max age of a document should be defaulted to 10% of the
+        // document's age at the time it was served. Default expiration
+        // dates aren't used for URIs containing a query.
+        long servedMillis = servedDate != null
+            ? servedDate.getTime()
+            : sentRequestMillis;
+        long delta = servedMillis - lastModified.getTime();
+        return delta > 0 ? (delta / 10) : 0;
+      }
+      return 0;
     }
 
-    if (response.getEtag() != null) {
-      conditionalRequestBuilder.setIfNoneMatch(response.getEtag());
+    /**
+     * Returns the current age of the response, in milliseconds. The calculation
+     * is specified by RFC 2616, 13.2.3 Age Calculations.
+     */
+    private long cacheResponseAge() {
+      long apparentReceivedAge = servedDate != null
+          ? Math.max(0, receivedResponseMillis - servedDate.getTime())
+          : 0;
+      long receivedAge = ageSeconds != -1
+          ? Math.max(apparentReceivedAge, SECONDS.toMillis(ageSeconds))
+          : apparentReceivedAge;
+      long responseDuration = receivedResponseMillis - sentRequestMillis;
+      long residentDuration = nowMillis - receivedResponseMillis;
+      return receivedAge + responseDuration + residentDuration;
     }
 
-    Request conditionalRequest = conditionalRequestBuilder.build();
-    ResponseSource responseSource = hasConditions(conditionalRequest)
-        ? ResponseSource.CONDITIONAL_CACHE
-        : ResponseSource.NETWORK;
-    return new CacheStrategy(conditionalRequest, response, responseSource);
-  }
+    /**
+     * Returns true if computeFreshnessLifetime used a heuristic. If we used a
+     * heuristic to serve a cached response older than 24 hours, we are required
+     * to attach a warning.
+     */
+    private boolean isFreshnessLifetimeHeuristic() {
+      return cacheResponse.cacheControl().maxAgeSeconds() == -1 && expires == null;
+    }
 
-  /**
-   * Returns true if the request contains conditions that save the server from
-   * sending a response that the client has locally. When a request is enqueued
-   * with its own conditions, the built-in response cache won't be used.
-   */
-  private static boolean hasConditions(Request request) {
-    return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
+    /**
+     * Returns true if the request contains conditions that save the server from
+     * sending a response that the client has locally. When a request is enqueued
+     * with its own conditions, the built-in response cache won't be used.
+     */
+    private static boolean hasConditions(Request request) {
+      return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
+    }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 4545e6e79b..1cf9bd3751 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -168,7 +168,7 @@ public final void sendRequest() throws IOException {
         ? responseCache.get(request)
         : null;
     long now = System.currentTimeMillis();
-    CacheStrategy cacheStrategy = CacheStrategy.get(now, cacheResponse, request);
+    CacheStrategy cacheStrategy = new CacheStrategy.Factory(now, request, cacheResponse).get();
     responseSource = cacheStrategy.source;
     request = cacheStrategy.request;
 
@@ -234,7 +234,7 @@ private void connect() throws IOException {
         hostnameVerifier = client.getHostnameVerifier();
       }
       Address address = new Address(uriHost, getEffectivePort(request.url()), sslSocketFactory,
-          hostnameVerifier, client.getAuthenticator(), client.getProxy(), client.getTransports());
+          hostnameVerifier, client.getAuthenticator(), client.getProxy(), client.getProtocols());
       routeSelector = new RouteSelector(address, request.uri(), client.getProxySelector(),
           client.getConnectionPool(), Dns.getDefault(), client.getRoutesDatabase());
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
index d2fe8910cb..caf512858a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
@@ -18,6 +18,7 @@
 
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.AbstractOutputStream;
@@ -34,13 +35,6 @@
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
 
 public final class HttpTransport implements Transport {
-  /**
-   * The timeout to use while discarding a stream of input data. Since this is
-   * used for connection reuse, this timeout should be significantly less than
-   * the time it takes to establish a new connection.
-   */
-  private static final int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
-
   public static final int DEFAULT_CHUNK_LENGTH = 1024;
 
   private final HttpEngine httpEngine;
@@ -155,7 +149,8 @@ public static void writeRequest(OutputStream out, Headers headers, String reques
 
       Response.Builder responseBuilder = new Response.Builder()
           .statusLine(statusLine)
-          .header(OkHeaders.SELECTED_TRANSPORT, "http/1.1");
+          .header(OkHeaders.SELECTED_TRANSPORT, Protocol.HTTP_11.name.utf8())
+          .header(OkHeaders.SELECTED_PROTOCOL, Protocol.HTTP_11.name.utf8());
 
       Headers.Builder headersBuilder = new Headers.Builder();
       OkHeaders.readHeaders(headersBuilder, in);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
index 0546123108..e255dbc988 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
@@ -20,9 +20,11 @@
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.Route;
+import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
 import java.io.FileNotFoundException;
@@ -496,8 +498,9 @@ private Retry processResponseHeaders() throws IOException {
       return;
     }
 
-    if ("X-Android-Transports".equals(field)) {
-      setTransports(newValue, false /* append */);
+    // TODO: Deprecate use of X-Android-Transports header?
+    if ("X-Android-Transports".equals(field) || "X-Android-Protocols".equals(field)) {
+      setProtocols(newValue, false /* append */);
     } else {
       requestHeaders.set(field, newValue);
     }
@@ -529,26 +532,33 @@ private Retry processResponseHeaders() throws IOException {
       return;
     }
 
-    if ("X-Android-Transports".equals(field)) {
-      setTransports(value, true /* append */);
+    // TODO: Deprecate use of X-Android-Transports header?
+    if ("X-Android-Transports".equals(field) || "X-Android-Protocols".equals(field)) {
+      setProtocols(value, true /* append */);
     } else {
       requestHeaders.add(field, value);
     }
   }
 
   /*
-   * Splits and validates a comma-separated string of transports.
+   * Splits and validates a comma-separated string of protocols.
    * When append == false, we require that the transport list contains "http/1.1".
+   * Throws {@link IllegalStateException} when one of the protocols isn't
+   * defined in {@link Protocol OkHttp's protocol enumeration}.
    */
-  private void setTransports(String transportsString, boolean append) {
-    List<String> transportsList = new ArrayList<String>();
+  private void setProtocols(String protocolsString, boolean append) {
+    List<Protocol> protocolsList = new ArrayList<Protocol>();
     if (append) {
-      transportsList.addAll(client.getTransports());
+      protocolsList.addAll(client.getProtocols());
     }
-    for (String transport : transportsString.split(",", -1)) {
-      transportsList.add(transport);
+    for (String protocol : protocolsString.split(",", -1)) {
+      try {
+        protocolsList.add(Protocol.find(ByteString.encodeUtf8(protocol)));
+      } catch (IOException e) {
+        throw new IllegalStateException(e);
+      }
     }
-    client.setTransports(transportsList);
+    client.setProtocols(protocolsList);
   }
 
   @Override public void setFixedLengthStreamingMode(int contentLength) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
index 09193537cb..bc18ea6ed3 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
@@ -50,10 +50,18 @@
   public static final String RESPONSE_SOURCE = PREFIX + "-Response-Source";
 
   /**
-   * Synthetic response header: the selected transport ("spdy/3", "http/1.1", etc).
+   * @deprecated OkHttp 2 enforces an enumeration of {@link com.squareup.okhttp.Protocol protocols}
+   * that can be selected. Please use #SELECTED_PROTOCOL
    */
+  @Deprecated
   public static final String SELECTED_TRANSPORT = PREFIX + "-Selected-Transport";
 
+  /**
+   * Synthetic response header: the selected
+   * {@link com.squareup.okhttp.Protocol protocol} ("spdy/3", "http/1.1", etc).
+   */
+  public static final String SELECTED_PROTOCOL = PREFIX + "-Selected-Protocol";
+
   private OkHeaders() {
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 07bb90e795..03578e27a1 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -17,10 +17,13 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.spdy.ErrorCode;
+import com.squareup.okhttp.internal.spdy.Header;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
 import java.io.IOException;
@@ -34,15 +37,16 @@
 import java.util.Locale;
 import java.util.Set;
 
-public final class SpdyTransport implements Transport {
-  private static final ByteString HEADER_METHOD = ByteString.encodeUtf8(":method");
-  private static final ByteString HEADER_PATH = ByteString.encodeUtf8(":path");
-  private static final ByteString HEADER_VERSION = ByteString.encodeUtf8(":version");
-  private static final ByteString HEADER_HOST = ByteString.encodeUtf8(":host");
-  private static final ByteString HEADER_AUTHORITY = ByteString.encodeUtf8(":authority");
-  private static final ByteString HEADER_SCHEME = ByteString.encodeUtf8(":scheme");
-  private static final ByteString NULL = ByteString.of((byte) 0x00);
+import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
+import static com.squareup.okhttp.internal.spdy.Header.RESPONSE_STATUS;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_AUTHORITY;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_HOST;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_METHOD;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_PATH;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_SCHEME;
+import static com.squareup.okhttp.internal.spdy.Header.VERSION;
 
+public final class SpdyTransport implements Transport {
   private final HttpEngine httpEngine;
   private final SpdyConnection spdyConnection;
   private SpdyStream stream;
@@ -85,61 +89,58 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
 
   /**
    * Returns a list of alternating names and values containing a SPDY request.
-   * Names are all lower case. No names are repeated. If any name has multiple
+   * Names are all lowercase. No names are repeated. If any name has multiple
    * values, they are concatenated using "\0" as a delimiter.
    */
-  public static List<ByteString> writeNameValueBlock(Request request, String protocol,
+  public static List<Header> writeNameValueBlock(Request request, Protocol protocol,
       String version) {
     Headers headers = request.headers();
     // TODO: make the known header names constants.
-    List<ByteString> result = new ArrayList<ByteString>(headers.size() + 10);
-    result.add(HEADER_METHOD);
-    result.add(ByteString.encodeUtf8(request.method()));
-    result.add(HEADER_PATH);
-    result.add(ByteString.encodeUtf8(RequestLine.requestPath(request.url())));
-    result.add(HEADER_VERSION);
-    result.add(ByteString.encodeUtf8(version));
-    if (protocol.equals("spdy/3")) {
-      result.add(HEADER_HOST);
-    } else if (protocol.equals("HTTP-draft-09/2.0")) {
-      result.add(HEADER_AUTHORITY);
+    List<Header> result = new ArrayList<Header>(headers.size() + 10);
+    result.add(new Header(TARGET_METHOD, request.method()));
+    result.add(
+        new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
+    String host = HttpEngine.hostHeader(request.url());
+    if (Protocol.SPDY_3 == protocol) {
+      result.add(new Header(VERSION, version));
+      result.add(new Header(TARGET_HOST, host));
+    } else if (Protocol.HTTP_2 == protocol) {
+      result.add(new Header(TARGET_AUTHORITY, host));
     } else {
       throw new AssertionError();
     }
-    result.add(ByteString.encodeUtf8(HttpEngine.hostHeader(request.url())));
-    result.add(HEADER_SCHEME);
-    result.add(ByteString.encodeUtf8(request.url().getProtocol()));
+    result.add(new Header(TARGET_SCHEME, request.url().getProtocol()));
 
     Set<ByteString> names = new LinkedHashSet<ByteString>();
     for (int i = 0; i < headers.size(); i++) {
-      String name = headers.name(i).toLowerCase(Locale.US);
+      // header names must be lowercase.
+      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
       String value = headers.value(i);
 
       // Drop headers that are forbidden when layering HTTP over SPDY.
       if (isProhibitedHeader(protocol, name)) continue;
 
       // They shouldn't be set, but if they are, drop them. We've already written them!
-      if (name.equals(":method")
-          || name.equals(":path")
-          || name.equals(":version")
-          || name.equals(":host")
-          || name.equals(":authority")
-          || name.equals(":scheme")) {
+      if (name.equals(TARGET_METHOD)
+          || name.equals(TARGET_PATH)
+          || name.equals(TARGET_SCHEME)
+          || name.equals(TARGET_AUTHORITY)
+          || name.equals(TARGET_HOST)
+          || name.equals(VERSION)) {
         continue;
       }
-      ByteString valueBytes = ByteString.encodeUtf8(value);
 
       // If we haven't seen this name before, add the pair to the end of the list...
-      if (names.add(ByteString.encodeUtf8(name))) {
-        result.add(ByteString.encodeUtf8(name));
-        result.add(valueBytes);
+      if (names.add(name)) {
+        result.add(new Header(name, value));
         continue;
       }
 
       // ...otherwise concatenate the existing values and this value.
-      for (int j = 0; j < result.size(); j += 2) {
-        if (result.get(j).utf8Equals(name)) {
-          result.set(j + 1, ByteString.concat(result.get(j + 1), NULL, valueBytes));
+      for (int j = 0; j < result.size(); j++) {
+        if (result.get(j).name.equals(name)) {
+          String concatenated = joinOnNull(result.get(j).value.utf8(), value);
+          result.set(j, new Header(name, concatenated));
           break;
         }
       }
@@ -147,32 +148,34 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     return result;
   }
 
+  private static String joinOnNull(String first, String second) {
+    return new StringBuilder(first).append('\0').append(second).toString();
+  }
+
   /** Returns headers for a name value block containing a SPDY response. */
-  public static Response.Builder readNameValueBlock(List<ByteString> nameValueBlock,
-      String protocol) throws IOException {
-    if (nameValueBlock.size() % 2 != 0) {
-      throw new IllegalArgumentException("Unexpected name value block: " + nameValueBlock);
-    }
+  public static Response.Builder readNameValueBlock(List<Header> nameValueBlock,
+      Protocol protocol) throws IOException {
     String status = null;
-    String version = "HTTP/1.1"; // TODO: why are we expecting :version?
+    String version = "HTTP/1.1"; // :version present only in spdy/3.
 
     Headers.Builder headersBuilder = new Headers.Builder();
-    headersBuilder.set(OkHeaders.SELECTED_TRANSPORT, protocol);
-    for (int i = 0; i < nameValueBlock.size(); i += 2) {
-      String name = nameValueBlock.get(i).utf8();
-      String values = nameValueBlock.get(i + 1).utf8();
+    headersBuilder.set(OkHeaders.SELECTED_TRANSPORT, protocol.name.utf8());
+    headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.name.utf8());
+    for (int i = 0; i < nameValueBlock.size(); i++) {
+      ByteString name = nameValueBlock.get(i).name;
+      String values = nameValueBlock.get(i).value.utf8();
       for (int start = 0; start < values.length(); ) {
         int end = values.indexOf('\0', start);
         if (end == -1) {
           end = values.length();
         }
         String value = values.substring(start, end);
-        if (":status".equals(name)) {
+        if (name.equals(RESPONSE_STATUS)) {
           status = value;
-        } else if (":version".equals(name)) {
+        } else if (name.equals(VERSION)) {
           version = value;
         } else if (!isProhibitedHeader(protocol, name)) { // Don't write forbidden headers!
-          headersBuilder.add(name, value);
+          headersBuilder.add(name.utf8(), value);
         }
         start = end + 1;
       }
@@ -186,52 +189,105 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
   }
 
   @Override public InputStream getTransferStream(CacheRequest cacheRequest) throws IOException {
-    return new UnknownLengthHttpInputStream(stream.getInputStream(), cacheRequest, httpEngine);
+    return new SpdyInputStream(stream, cacheRequest, httpEngine);
   }
 
   @Override public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
       InputStream responseBodyIn) {
-    if (streamCanceled) {
-      if (stream != null) {
-        stream.closeLater(ErrorCode.CANCEL);
-        return true;
-      } else {
-        // If stream is null, it either means that writeRequestHeaders wasn't called
-        // or that SpdyConnection#newStream threw an IOException. In both cases there's
-        // nothing to do here and this stream can't be reused.
-        return false;
-      }
-    }
-    return true;
+    return true; // SPDY sockets are always reusable.
   }
 
   /** When true, this header should not be emitted or consumed. */
-  private static boolean isProhibitedHeader(String protocol, String name) {
+  private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
     boolean prohibited = false;
-    if (protocol.equals("spdy/3")) {
+    if (protocol == Protocol.SPDY_3) {
       // http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3#TOC-3.2.1-Request
-      if (name.equals("connection")
-          || name.equals("host")
-          || name.equals("keep-alive")
-          || name.equals("proxy-connection")
-          || name.equals("transfer-encoding")) {
+      if (name.equalsAscii("connection")
+          || name.equalsAscii("host")
+          || name.equalsAscii("keep-alive")
+          || name.equalsAscii("proxy-connection")
+          || name.equalsAscii("transfer-encoding")) {
         prohibited = true;
       }
-    } else if (protocol.equals("HTTP-draft-09/2.0")) {
+    } else if (protocol == Protocol.HTTP_2) {
       // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
-      if (name.equals("connection")
-          || name.equals("host")
-          || name.equals("keep-alive")
-          || name.equals("proxy-connection")
-          || name.equals("te")
-          || name.equals("transfer-encoding")
-          || name.equals("encoding")
-          || name.equals("upgrade")) {
+      if (name.equalsAscii("connection")
+          || name.equalsAscii("host")
+          || name.equalsAscii("keep-alive")
+          || name.equalsAscii("proxy-connection")
+          || name.equalsAscii("te")
+          || name.equalsAscii("transfer-encoding")
+          || name.equalsAscii("encoding")
+          || name.equalsAscii("upgrade")) {
         prohibited = true;
       }
     } else {
-      throw new AssertionError();
+      throw new AssertionError(protocol);
     }
     return prohibited;
   }
+
+  /** An HTTP message body terminated by the end of the underlying stream. */
+  private static class SpdyInputStream extends AbstractHttpInputStream {
+    private final SpdyStream stream;
+    private boolean inputExhausted;
+
+    SpdyInputStream(SpdyStream stream, CacheRequest cacheRequest, HttpEngine httpEngine)
+        throws IOException {
+      super(stream.getInputStream(), httpEngine, cacheRequest);
+      this.stream = stream;
+    }
+
+    @Override public int read(byte[] buffer, int offset, int count) throws IOException {
+      checkOffsetAndCount(buffer.length, offset, count);
+      checkNotClosed();
+      if (in == null || inputExhausted) {
+        return -1;
+      }
+      int read = in.read(buffer, offset, count);
+      if (read == -1) {
+        inputExhausted = true;
+        endOfInput();
+        return -1;
+      }
+      cacheWrite(buffer, offset, read);
+      return read;
+    }
+
+    @Override public int available() throws IOException {
+      checkNotClosed();
+      return in == null ? 0 : in.available();
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+
+      if (!inputExhausted && cacheBody != null) {
+        discardStream(); // Could make inputExhausted true!
+      }
+
+      closed = true;
+
+      if (!inputExhausted) {
+        stream.closeLater(ErrorCode.CANCEL);
+        unexpectedEndOfInput();
+      }
+    }
+
+    private boolean discardStream() {
+      try {
+        long socketTimeout = stream.getReadTimeoutMillis();
+        stream.setReadTimeout(socketTimeout);
+        stream.setReadTimeout(DISCARD_STREAM_TIMEOUT_MILLIS);
+        try {
+          Util.skipByReading(this, Long.MAX_VALUE, DISCARD_STREAM_TIMEOUT_MILLIS);
+          return true;
+        } finally {
+          stream.setReadTimeout(socketTimeout);
+        }
+      } catch (IOException e) {
+        return false;
+      }
+    }
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
index e62f21836a..d295891392 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
@@ -18,26 +18,48 @@ public StatusLine(String statusLine) throws IOException {
     // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
     // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
 
-    // We allow empty message without leading white space since some servers
-    // do not send the white space when the message is empty.
-    boolean hasMessage = statusLine.length() > 13;
-    if (!statusLine.startsWith("HTTP/1.")
-        || statusLine.length() < 12
-        || statusLine.charAt(8) != ' '
-        || (hasMessage && statusLine.charAt(12) != ' ')) {
+    // Parse protocol like "HTTP/1.1" followed by a space.
+    int codeStart;
+    int httpMinorVersion;
+    if (statusLine.startsWith("HTTP/1.")) {
+      if (statusLine.length() < 9 || statusLine.charAt(8) != ' ') {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+      httpMinorVersion = statusLine.charAt(7) - '0';
+      codeStart = 9;
+      if (httpMinorVersion < 0 || httpMinorVersion > 9) {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+    } else if (statusLine.startsWith("ICY ")) {
+      // Shoutcast uses ICY instead of "HTTP/1.0".
+      httpMinorVersion = 0;
+      codeStart = 4;
+    } else {
       throw new ProtocolException("Unexpected status line: " + statusLine);
     }
-    int httpMinorVersion = statusLine.charAt(7) - '0';
-    if (httpMinorVersion < 0 || httpMinorVersion > 9) {
+
+    // Parse response code like "200". Always 3 digits.
+    if (statusLine.length() < codeStart + 3) {
       throw new ProtocolException("Unexpected status line: " + statusLine);
     }
     int responseCode;
     try {
-      responseCode = Integer.parseInt(statusLine.substring(9, 12));
+      responseCode = Integer.parseInt(statusLine.substring(codeStart, codeStart + 3));
     } catch (NumberFormatException e) {
       throw new ProtocolException("Unexpected status line: " + statusLine);
     }
-    this.responseMessage = hasMessage ? statusLine.substring(13) : "";
+
+    // Parse an optional response message like "OK" or "Not Modified". If it
+    // exists, it is separated from the response code by a space.
+    String responseMessage = "";
+    if (statusLine.length() > codeStart + 3) {
+      if (statusLine.charAt(codeStart + 3) != ' ') {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+      responseMessage = statusLine.substring(codeStart + 4);
+    }
+
+    this.responseMessage = responseMessage;
     this.responseCode = responseCode;
     this.statusLine = statusLine;
     this.httpMinorVersion = httpMinorVersion;
@@ -64,5 +86,4 @@ public int code() {
   public String message() {
     return responseMessage;
   }
-
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
index 59e986f1a0..b1c38fec5a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
@@ -24,6 +24,13 @@
 import java.net.CacheRequest;
 
 interface Transport {
+  /**
+   * The timeout to use while discarding a stream of input data. Since this is
+   * used for connection reuse, this timeout should be significantly less than
+   * the time it takes to establish a new connection.
+   */
+  int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
+
   /**
    * Returns an output stream where the request body can be written. The
    * returned stream will of one of two types:
diff --git a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
index bebe7220ba..c02be45cfd 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
@@ -61,14 +61,14 @@
 
     httpServer.play();
     httpAddress = new Address(httpServer.getHostName(), httpServer.getPort(), null, null,
-        HttpAuthenticator.SYSTEM_DEFAULT, null, Arrays.asList("spdy/3", "http/1.1"));
+        HttpAuthenticator.SYSTEM_DEFAULT, null, Protocol.SPDY3_AND_HTTP11);
     httpSocketAddress = new InetSocketAddress(InetAddress.getByName(httpServer.getHostName()),
         httpServer.getPort());
 
     spdyServer.play();
     spdyAddress = new Address(spdyServer.getHostName(), spdyServer.getPort(),
         sslContext.getSocketFactory(), new RecordingHostnameVerifier(),
-        HttpAuthenticator.SYSTEM_DEFAULT, null, Arrays.asList("spdy/3", "http/1.1"));
+        HttpAuthenticator.SYSTEM_DEFAULT, null,Protocol.SPDY3_AND_HTTP11);
     spdySocketAddress = new InetSocketAddress(InetAddress.getByName(spdyServer.getHostName()),
         spdyServer.getPort());
 
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
index 36d54668ed..a7b85e3537 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
@@ -20,10 +20,13 @@
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.net.URL;
+import java.util.List;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLSession;
 
+import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
+
 public final class ExternalHttp2Example {
   public static void main(String[] args) throws Exception {
     URL url = new URL("https://twitter.com/");
@@ -38,8 +41,11 @@ public static void main(String[] args) throws Exception {
 
     int responseCode = connection.getResponseCode();
     System.out.println(responseCode);
-    System.out.println(connection.getHeaderFields());
-
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    // If null, probably you didn't add jetty's npn jar to your boot classpath!
+    if (protocolValues != null && !protocolValues.isEmpty()) {
+      System.out.println("PROTOCOL " + protocolValues.get(0));
+    }
     BufferedReader reader =
         new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
     String line;
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
index 11d7239050..e43fbb0650 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
@@ -20,10 +20,13 @@
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.net.URL;
+import java.util.List;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLSession;
 
+import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
+
 public final class ExternalSpdyExample {
   public static void main(String[] args) throws Exception {
     URL url = new URL("https://www.google.ca/");
@@ -38,6 +41,11 @@ public static void main(String[] args) throws Exception {
 
     int responseCode = connection.getResponseCode();
     System.out.println(responseCode);
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    // If null, probably you didn't add jetty's npn jar to your boot classpath!
+    if (protocolValues != null && !protocolValues.isEmpty()) {
+      System.out.println("PROTOCOL " + protocolValues.get(0));
+    }
 
     BufferedReader reader =
         new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
index 238a199a0d..84926bc4a3 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
@@ -16,71 +16,78 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.ByteString;
+import com.squareup.okhttp.internal.spdy.Header;
 import java.io.IOException;
 import java.util.List;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.Util.byteStringList;
+import static com.squareup.okhttp.internal.Util.headerEntries;
 import static junit.framework.Assert.assertNull;
 import static org.junit.Assert.assertEquals;
 
 public final class HeadersTest {
   @Test public void parseNameValueBlock() throws IOException {
-    List<ByteString> nameValueBlock = byteStringList(
+    List<Header> nameValueBlock = headerEntries(
         "cache-control", "no-cache, no-store",
         "set-cookie", "Cookie1\u0000Cookie2",
         ":status", "200 OK",
         ":version", "HTTP/1.1");
     Request request = new Request.Builder().url("http://square.com/").build();
     Response response =
-        SpdyTransport.readNameValueBlock(nameValueBlock, "spdy/3").request(request).build();
+        SpdyTransport.readNameValueBlock(nameValueBlock, Protocol.SPDY_3).request(request).build();
     Headers headers = response.headers();
-    assertEquals(4, headers.size());
+    assertEquals(5, headers.size());
     assertEquals("HTTP/1.1 200 OK", response.statusLine());
     assertEquals("no-cache, no-store", headers.get("cache-control"));
     assertEquals("Cookie2", headers.get("set-cookie"));
-    assertEquals("spdy/3", headers.get(OkHeaders.SELECTED_TRANSPORT));
+    assertEquals(Protocol.SPDY_3.name.utf8(), headers.get(OkHeaders.SELECTED_TRANSPORT));
     assertEquals(OkHeaders.SELECTED_TRANSPORT, headers.name(0));
-    assertEquals("spdy/3", headers.value(0));
-    assertEquals("cache-control", headers.name(1));
-    assertEquals("no-cache, no-store", headers.value(1));
-    assertEquals("set-cookie", headers.name(2));
-    assertEquals("Cookie1", headers.value(2));
+    assertEquals(Protocol.SPDY_3.name.utf8(), headers.get(OkHeaders.SELECTED_PROTOCOL));
+    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(1));
+    assertEquals(Protocol.SPDY_3.name.utf8(), headers.value(1));
+    assertEquals("cache-control", headers.name(2));
+    assertEquals("no-cache, no-store", headers.value(2));
     assertEquals("set-cookie", headers.name(3));
-    assertEquals("Cookie2", headers.value(3));
+    assertEquals("Cookie1", headers.value(3));
+    assertEquals("set-cookie", headers.name(4));
+    assertEquals("Cookie2", headers.value(4));
     assertNull(headers.get(":status"));
     assertNull(headers.get(":version"));
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersSpdy3() throws IOException {
-    List<ByteString> nameValueBlock = byteStringList(
+    List<Header> nameValueBlock = headerEntries(
         ":status", "200 OK",
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
     Response response =
-        SpdyTransport.readNameValueBlock(nameValueBlock, "spdy/3").request(request).build();
+        SpdyTransport.readNameValueBlock(nameValueBlock, Protocol.SPDY_3).request(request).build();
     Headers headers = response.headers();
-    assertEquals(1, headers.size());
+    assertEquals(2, headers.size());
     assertEquals(OkHeaders.SELECTED_TRANSPORT, headers.name(0));
-    assertEquals("spdy/3", headers.value(0));;
+    assertEquals(Protocol.SPDY_3.name.utf8(), headers.value(0));
+    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(1));
+    assertEquals(Protocol.SPDY_3.name.utf8(), headers.value(1));;
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
-    List<ByteString> nameValueBlock = byteStringList(
+    List<Header> nameValueBlock = headerEntries(
         ":status", "200 OK",
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response =
-        SpdyTransport.readNameValueBlock(nameValueBlock, "HTTP-draft-09/2.0").request(request).build();
+    Response response = SpdyTransport.readNameValueBlock(nameValueBlock, Protocol.HTTP_2)
+        .request(request).build();
     Headers headers = response.headers();
-    assertEquals(1, headers.size());
+    assertEquals(2, headers.size());
     assertEquals(OkHeaders.SELECTED_TRANSPORT, headers.name(0));
-    assertEquals("HTTP-draft-09/2.0", headers.value(0));;
+    assertEquals(Protocol.HTTP_2.name.utf8(), headers.value(0));
+    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(1));
+    assertEquals(Protocol.HTTP_2.name.utf8(), headers.value(1));
   }
 
   @Test public void toNameValueBlock() {
@@ -91,8 +98,9 @@
         .addHeader("set-cookie", "Cookie2")
         .header(":status", "200 OK")
         .build();
-    List<ByteString> nameValueBlock = SpdyTransport.writeNameValueBlock(request, "spdy/3", "HTTP/1.1");
-    List<ByteString> expected = byteStringList(
+    List<Header> nameValueBlock =
+        SpdyTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1");
+    List<Header> expected = headerEntries(
         ":method", "GET",
         ":path", "/",
         ":version", "HTTP/1.1",
@@ -110,13 +118,13 @@
         .header("Connection", "close")
         .header("Transfer-Encoding", "chunked")
         .build();
-    List<ByteString> expected = byteStringList(
+    List<Header> expected = headerEntries(
         ":method", "GET",
         ":path", "/",
         ":version", "HTTP/1.1",
         ":host", "square.com",
         ":scheme", "http");
-    assertEquals(expected, SpdyTransport.writeNameValueBlock(request, "spdy/3", "HTTP/1.1"));
+    assertEquals(expected, SpdyTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1"));
   }
 
   @Test public void toNameValueBlockDropsForbiddenHeadersHttp2() {
@@ -125,13 +133,12 @@
         .header("Connection", "upgrade")
         .header("Upgrade", "websocket")
         .build();
-    List<ByteString> expected = byteStringList(
+    List<Header> expected = headerEntries(
         ":method", "GET",
         ":path", "/",
-        ":version", "HTTP/1.1",
         ":authority", "square.com",
         ":scheme", "http");
     assertEquals(expected,
-        SpdyTransport.writeNameValueBlock(request, "HTTP-draft-09/2.0", "HTTP/1.1"));
+        SpdyTransport.writeNameValueBlock(request, Protocol.HTTP_2, "HTTP/1.1"));
   }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
index dfc962be97..c1f4d3cf88 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
@@ -15,12 +15,12 @@
  */
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Protocol;
+
 public class HttpOverHttp20Draft09Test extends HttpOverSpdyTest {
 
   public HttpOverHttp20Draft09Test() {
-    super("HTTP-draft-09/2.0");
-    // TODO: is this really the whole authority, or just the host/port?
-    // https://github.com/http2/http2-spec/issues/334
+    super(Protocol.HTTP_2);
     this.hostHeader = ":authority";
   }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
index 4c30e45f4a..4020bf4c25 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
@@ -15,9 +15,11 @@
  */
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Protocol;
+
 public class HttpOverSpdy3Test extends HttpOverSpdyTest {
 
   public HttpOverSpdy3Test() {
-    super("spdy/3");
+    super(Protocol.SPDY_3);
   }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index e2994a9e35..8cc7bfd702 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -17,6 +17,7 @@
 
 import com.squareup.okhttp.HttpResponseCache;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.RecordingAuthenticator;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
@@ -61,12 +62,12 @@
 /** Test how SPDY interacts with HTTP features. */
 public abstract class HttpOverSpdyTest {
 
-  /** Transport to test, for example {@code spdy/3} */
-  private final String transport;
+  /** Protocol to test, for example {@link com.squareup.okhttp.Protocol#SPDY_3} */
+  private final Protocol protocol;
   protected String hostHeader = ":host";
 
-  protected HttpOverSpdyTest(String transport){
-    this.transport = transport;
+  protected HttpOverSpdyTest(Protocol protocol){
+    this.protocol = protocol;
   }
 
   private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
@@ -83,11 +84,11 @@ public boolean verify(String hostname, SSLSession session) {
 
   @Before public void setUp() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
-    client.setTransports(Arrays.asList(transport, "http/1.1"));
+    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_11));
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     String systemTmpDir = System.getProperty("java.io.tmpdir");
-    File cacheDir = new File(systemTmpDir, "HttpCache-" + transport + "-" + UUID.randomUUID());
+    File cacheDir = new File(systemTmpDir, "HttpCache-" + protocol + "-" + UUID.randomUUID());
     cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
   }
 
@@ -281,7 +282,7 @@ public boolean verify(String hostname, SSLSession session) {
   }
 
   @Test public void responsesAreCached() throws IOException {
-    client.setResponseCache(cache);
+    client.setOkResponseCache(cache);
 
     server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("A"));
     server.play();
@@ -298,7 +299,7 @@ public boolean verify(String hostname, SSLSession session) {
   }
 
   @Test public void conditionalCache() throws IOException {
-    client.setResponseCache(cache);
+    client.setOkResponseCache(cache);
 
     server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
@@ -314,6 +315,24 @@ public boolean verify(String hostname, SSLSession session) {
     assertEquals(1, cache.getHitCount());
   }
 
+  @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
+    client.setOkResponseCache(cache);
+
+    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("ABCD"));
+    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("EFGH"));
+    server.play();
+
+    URLConnection connection1 = client.open(server.getUrl("/"));
+    InputStream in1 = connection1.getInputStream();
+    assertEquals("AB", readAscii(in1, 2));
+    in1.close();
+
+    URLConnection connection2 = client.open(server.getUrl("/"));
+    InputStream in2 = connection2.getInputStream();
+    assertEquals("ABCD", readAscii(in2, Integer.MAX_VALUE));
+    in2.close();
+  }
+
   @Test public void acceptAndTransmitCookies() throws Exception {
     CookieManager cookieManager = new CookieManager();
     client.setCookieHandler(cookieManager);
@@ -386,8 +405,7 @@ public SpdyRequest(String path, CountDownLatch countDownLatch) {
 
     @Override public void run() {
       try {
-        HttpURLConnection conn = null;
-        conn = (HttpURLConnection) client.open(server.getUrl(path));
+        HttpURLConnection conn = client.open(server.getUrl(path));
         assertEquals("A", readAscii(conn.getInputStream(), 1));
         countDownLatch.countDown();
       } catch (Exception e) {
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
index 713c89e2d0..9a4cb25bc2 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
@@ -19,6 +19,7 @@
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.OkAuthenticator;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.RouteDatabase;
 import com.squareup.okhttp.internal.Dns;
 import com.squareup.okhttp.internal.SslContextBuilder;
@@ -75,12 +76,12 @@
   }
 
   private final OkAuthenticator authenticator = HttpAuthenticator.SYSTEM_DEFAULT;
-  private final List<String> transports = Arrays.asList("http/1.1");
+  private final List<Protocol> protocols = Arrays.asList(Protocol.HTTP_11);
   private final FakeDns dns = new FakeDns();
   private final FakeProxySelector proxySelector = new FakeProxySelector();
 
   @Test public void singleRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
+    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
         new RouteDatabase());
 
@@ -99,7 +100,7 @@
   }
 
   @Test public void singleRouteReturnsFailedRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
+    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
         new RouteDatabase());
 
@@ -120,7 +121,7 @@
   }
 
   @Test public void explicitProxyTriesThatProxiesAddressesOnly() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, proxyA, transports);
+    Address address = new Address(uriHost, uriPort, null, null, authenticator, proxyA, protocols);
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
         new RouteDatabase());
 
@@ -138,7 +139,7 @@
 
   @Test public void explicitDirectProxy() throws Exception {
     Address address = new Address(uriHost, uriPort, null, null, authenticator, NO_PROXY,
-        transports);
+        protocols);
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
         new RouteDatabase());
 
@@ -155,7 +156,7 @@
   }
 
   @Test public void proxySelectorReturnsNull() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
+    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
 
     proxySelector.proxies = null;
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
@@ -172,7 +173,7 @@
   }
 
   @Test public void proxySelectorReturnsNoProxies() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
+    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
         new RouteDatabase());
 
@@ -189,7 +190,7 @@
   }
 
   @Test public void proxySelectorReturnsMultipleProxies() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
+    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
 
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
@@ -224,7 +225,7 @@
   }
 
   @Test public void proxySelectorDirectConnectionsAreSkipped() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
+    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
 
     proxySelector.proxies.add(NO_PROXY);
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
@@ -242,7 +243,7 @@
   }
 
   @Test public void proxyDnsFailureContinuesToNextProxy() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
+    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
 
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
@@ -284,7 +285,7 @@
   // https://github.com/square/okhttp/issues/442
   @Test public void nonSslErrorAddsAllTlsModesToFailedRoute() throws Exception {
     Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        Proxy.NO_PROXY, transports);
+        Proxy.NO_PROXY, protocols);
     RouteDatabase routeDatabase = new RouteDatabase();
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
         routeDatabase);
@@ -298,7 +299,7 @@
 
   @Test public void sslErrorAddsOnlyFailedTlsModeToFailedRoute() throws Exception {
     Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        Proxy.NO_PROXY, transports);
+        Proxy.NO_PROXY, protocols);
     RouteDatabase routeDatabase = new RouteDatabase();
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
         routeDatabase);
@@ -312,7 +313,7 @@
 
   @Test public void multipleProxiesMultipleInetAddressesMultipleTlsModes() throws Exception {
     Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        null, transports);
+        null, protocols);
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
@@ -359,7 +360,7 @@
 
   @Test public void failedRoutesAreLast() throws Exception {
     Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        Proxy.NO_PROXY, transports);
+        Proxy.NO_PROXY, protocols);
 
     RouteDatabase routeDatabase = new RouteDatabase();
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
index bc92397e64..c3ea3a982d 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
@@ -16,8 +16,10 @@
 package com.squareup.okhttp.internal.http;
 
 import java.io.IOException;
+import java.net.ProtocolException;
 import org.junit.Test;
 
+import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertEquals;
 
 public final class StatusLineTest {
@@ -53,4 +55,63 @@
     assertEquals(version, statusLine.httpMinorVersion());
     assertEquals(code, statusLine.code());
   }
+
+  // https://github.com/square/okhttp/issues/386
+  @Test public void shoutcast() throws IOException {
+    StatusLine statusLine = new StatusLine("ICY 200 OK");
+    assertEquals("OK", statusLine.message());
+    assertEquals(0, statusLine.httpMinorVersion());
+    assertEquals(200, statusLine.code());
+  }
+
+  @Test public void missingProtocol() throws IOException {
+    assertInvalid("");
+    assertInvalid(" ");
+    assertInvalid("200 OK");
+    assertInvalid(" 200 OK");
+  }
+
+  @Test public void protocolVersions() throws IOException {
+    assertInvalid("HTTP/2.0 200 OK");
+    assertInvalid("HTTP/2.1 200 OK");
+    assertInvalid("HTTP/-.1 200 OK");
+    assertInvalid("HTTP/1.- 200 OK");
+    assertInvalid("HTTP/0.1 200 OK");
+    assertInvalid("HTTP/101 200 OK");
+    assertInvalid("HTTP/1.1_200 OK");
+  }
+
+  @Test public void nonThreeDigitCode() throws IOException {
+    assertInvalid("HTTP/1.1  OK");
+    assertInvalid("HTTP/1.1 2 OK");
+    assertInvalid("HTTP/1.1 20 OK");
+    assertInvalid("HTTP/1.1 2000 OK");
+    assertInvalid("HTTP/1.1 two OK");
+    assertInvalid("HTTP/1.1 2");
+    assertInvalid("HTTP/1.1 2000");
+    assertInvalid("HTTP/1.1 two");
+  }
+
+  @Test public void truncated() throws IOException {
+    assertInvalid("");
+    assertInvalid("H");
+    assertInvalid("HTTP/1");
+    assertInvalid("HTTP/1.");
+    assertInvalid("HTTP/1.1");
+    assertInvalid("HTTP/1.1 ");
+    assertInvalid("HTTP/1.1 2");
+    assertInvalid("HTTP/1.1 20");
+  }
+
+  @Test public void wrongMessageDelimiter() throws IOException {
+    assertInvalid("HTTP/1.1 200_");
+  }
+
+  private void assertInvalid(String statusLine) throws IOException {
+    try {
+      new StatusLine(statusLine);
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index b1abccd97e..5704b6b5cb 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -18,6 +18,7 @@
 
 import com.squareup.okhttp.HttpResponseCache;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.RecordingAuthenticator;
 import com.squareup.okhttp.internal.RecordingHostnameVerifier;
 import com.squareup.okhttp.internal.RecordingOkAuthenticator;
@@ -1323,6 +1324,32 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
     }
   }
 
+  @Test public void shoutcast() throws Exception {
+    server.enqueue(new MockResponse().setStatus("ICY 200 OK")
+        // .addHeader("HTTP/1.0 200 OK")
+        .addHeader("Accept-Ranges: none")
+        .addHeader("Content-Type: audio/mpeg")
+        .addHeader("icy-br:128")
+        .addHeader("ice-audio-info: bitrate=128;samplerate=44100;channels=2")
+        .addHeader("icy-br:128")
+        .addHeader("icy-description:Rock")
+        .addHeader("icy-genre:riders")
+        .addHeader("icy-name:A2RRock")
+        .addHeader("icy-pub:1")
+        .addHeader("icy-url:http://www.A2Rradio.com")
+        .addHeader("Server: Icecast 2.3.3-kh8")
+        .addHeader("Cache-Control: no-cache")
+        .addHeader("Pragma: no-cache")
+        .addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT")
+        .addHeader("icy-metaint:16000")
+        .setBody("mp3 data"));
+    server.play();
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("OK", connection.getResponseMessage());
+    assertContent("mp3 data", connection);
+  }
+
   @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
     server.play();
     HttpURLConnection connection = client.open(server.getUrl("/"));
@@ -2500,24 +2527,24 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertTrue(call, call.contains("challenges=[Basic realm=\"protected area\"]"));
   }
 
-  @Test public void setTransports() throws Exception {
+  @Test public void setProtocols() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    client.setTransports(Arrays.asList("http/1.1"));
+    client.setProtocols(Arrays.asList(Protocol.HTTP_11));
     assertContent("A", client.open(server.getUrl("/")));
   }
 
-  @Test public void setTransportsWithoutHttp11() throws Exception {
+  @Test public void setProtocolsWithoutHttp11() throws Exception {
     try {
-      client.setTransports(Arrays.asList("spdy/3"));
+      client.setProtocols(Arrays.asList(Protocol.SPDY_3));
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
-  @Test public void setTransportsWithNull() throws Exception {
+  @Test public void setProtocolsWithNull() throws Exception {
     try {
-      client.setTransports(Arrays.asList("http/1.1", null));
+      client.setProtocols(Arrays.asList(Protocol.HTTP_11, null));
       fail();
     } catch (IllegalArgumentException expected) {
     }
